// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../net/Uri.dart" as uri_;

import "Context.dart" as context_;

import "IntentSender.dart" as intentsender_;

import "ComponentName.dart" as componentname_;

import "ContentResolver.dart" as contentresolver_;

import "ClipData.dart" as clipdata_;

import "../os/Bundle.dart" as bundle_;

import "../graphics/Rect.dart" as rect_;

import "pm/PackageManager.dart" as packagemanager_;

import "pm/ActivityInfo.dart" as activityinfo_;

import "../os/Parcel.dart" as parcel_;

import "res/Resources.dart" as resources_;

import "../util/AttributeSet.dart" as attributeset_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.Intent
///
/// An intent is an abstract description of an operation to be performed.  It
/// can be used with Context\#startActivity(Intent) startActivity to
/// launch an android.app.Activity,
/// android.content.Context\#sendBroadcast(Intent) broadcastIntent to
/// send it to any interested BroadcastReceiver BroadcastReceiver components,
/// and android.content.Context\#startService or
/// android.content.Context\#bindService to communicate with a
/// background android.app.Service.
///
/// An Intent provides a facility for performing late runtime binding between the code in
/// different applications. Its most significant use is in the launching of activities, where it
/// can be thought of as the glue between activities. It is basically a passive data structure
/// holding an abstract description of an action to be performed.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For information about how to create and resolve intents, read the
/// <a href="{@docRoot}guide/topics/intents/intents-filters.html">Intents and Intent Filters</a>
/// developer guide.
///
/// </div>
///
/// <a name="IntentStructure"></a>
/// <h3>Intent Structure</h3>
/// The primary pieces of information in an intent are:
///
///
/// <ul>
///   <li> __action__ -- The general action to be performed, such as
///     \#ACTION_VIEW, \#ACTION_EDIT, \#ACTION_MAIN,
///     etc.
///
///   </li>
///   <li> __data__ -- The data to operate on, such as a person record
///     in the contacts database, expressed as a android.net.Uri.
///
///   </li>
/// </ul>
///
///
/// Some examples of action/data pairs are:
///
///
/// <ul>
///   <li> __\#ACTION_VIEW <i>content://contacts/people/1</i>__ -- Display
///     information about the person whose identifier is "1".
///
///   </li>
///   <li> __\#ACTION_DIAL <i>content://contacts/people/1</i>__ -- Display
///     the phone dialer with the person filled in.
///
///   </li>
///   <li> __\#ACTION_VIEW <i>tel:123</i>__ -- Display
///     the phone dialer with the given number filled in.  Note how the
///     VIEW action does what is considered the most reasonable thing for
///     a particular URI.
///
///   </li>
///   <li> __\#ACTION_DIAL <i>tel:123</i>__ -- Display
///     the phone dialer with the given number filled in.
///
///   </li>
///   <li> __\#ACTION_EDIT <i>content://contacts/people/1</i>__ -- Edit
///     information about the person whose identifier is "1".
///
///   </li>
///   <li> __\#ACTION_VIEW <i>content://contacts/people/</i>__ -- Display
///     a list of people, which the user can browse through.  This example is a
///     typical top-level entry into the Contacts application, showing you the
///     list of people. Selecting a particular person to view would result in a
///     new intent { __\#ACTION_VIEW <i>content://contacts/people/N</i>__ }
///     being used to start an activity to display that person.
///
///   </li>
/// </ul>
///
/// In addition to these primary attributes, there are a number of secondary
/// attributes that you can also include with an intent:
///
///
/// <ul>
///     <li> __category__ -- Gives additional information about the action
///         to execute.  For example, \#CATEGORY_LAUNCHER means it should
///         appear in the Launcher as a top-level application, while
///         \#CATEGORY_ALTERNATIVE means it should be included in a list
///         of alternative actions the user can perform on a piece of data.
///
///     <li> __type__ -- Specifies an explicit type (a MIME type) of the
///         intent data.  Normally the type is inferred from the data itself.
///         By setting this attribute, you disable that evaluation and force
///         an explicit type.
///
///     <li> __component__ -- Specifies an explicit name of a component
///         class to use for the intent.  Normally this is determined by looking
///         at the other information in the intent (the action, data/type, and
///         categories) and matching that with a component that can handle it.
///         If this attribute is set then none of the evaluation is performed,
///         and this component is used exactly as is.  By specifying this attribute,
///         all of the other Intent attributes become optional.
///
///     <li> __extras__ -- This is a Bundle of any additional information.
///         This can be used to provide extended information to the component.
///         For example, if we have a action to send an e-mail message, we could
///         also include extra pieces of data here to supply a subject, body,
///         etc.
///
/// </ul>
///
/// Here are some examples of other operations you can specify as intents
/// using these additional parameters:
///
///
/// <ul>
///   <li> __\#ACTION_MAIN with category \#CATEGORY_HOME__ --
///     Launch the home screen.
///
///   </li>
///   <li> __\#ACTION_GET_CONTENT with MIME type
///     <i>android.provider.Contacts.Phones\#CONTENT_URI vnd.android.cursor.item/phone</i>__
///     -- Display the list of people's phone numbers, allowing the user to
///     browse through them and pick one and return it to the parent activity.
///
///   </li>
///   <li> __\#ACTION_GET_CONTENT with MIME type
///     <i>*{@literal /}*</i> and category \#CATEGORY_OPENABLE__
///     -- Display all pickers for data that can be opened with
///     ContentResolver\#openInputStream(Uri) ContentResolver.openInputStream(),
///     allowing the user to pick one of them and then some data inside of it
///     and returning the resulting URI to the caller.  This can be used,
///     for example, in an e-mail application to allow the user to pick some
///     data to include as an attachment.
///
///   </li>
/// </ul>
///
/// There are a variety of standard Intent action and category constants
/// defined in the Intent class, but applications can also define their own.
/// These strings use Java-style scoping, to ensure they are unique -- for
/// example, the standard \#ACTION_VIEW is called
/// "android.intent.action.VIEW".
///
///
/// Put together, the set of actions, data types, categories, and extra data
/// defines a language for the system allowing for the expression of phrases
/// such as "call john smith's cell".  As applications are added to the system,
/// they can extend this language by adding new actions, types, and categories, or
/// they can modify the behavior of existing phrases by supplying their own
/// activities that handle them.
///
///
/// <a name="IntentResolution"></a>
/// <h3>Intent Resolution</h3>
///
/// There are two primary forms of intents you will use.
///
/// <ul>
///     <li> __Explicit Intents__ have specified a component (via
///     \#setComponent or \#setClass), which provides the exact
///     class to be run.  Often these will not include any other information,
///     simply being a way for an application to launch various internal
///     activities it has as the user interacts with the application.
///
///     <li> __Implicit Intents__ have not specified a component;
///     instead, they must include enough information for the system to
///     determine which of the available components is best to run for that
///     intent.
/// </ul>
///
/// When using implicit intents, given such an arbitrary intent we need to
/// know what to do with it. This is handled by the process of _Intent
/// resolution_, which maps an Intent to an android.app.Activity,
/// BroadcastReceiver, or android.app.Service (or sometimes two or
/// more activities/receivers) that can handle it.
///
///
/// The intent resolution mechanism basically revolves around matching an
/// Intent against all of the &lt;intent-filter&gt; descriptions in the
/// installed application packages.  (Plus, in the case of broadcasts, any BroadcastReceiver
/// objects explicitly registered with Context\#registerReceiver.)  More
/// details on this can be found in the documentation on the IntentFilter class.
///
///
/// There are three pieces of information in the Intent that are used for
/// resolution: the action, type, and category.  Using this information, a query
/// is done on the PackageManager for a component that can handle the
/// intent. The appropriate component is determined based on the intent
/// information supplied in the <code>AndroidManifest.xml</code> file as
/// follows:
///
///
/// <ul>
///     <li> The __action__, if given, must be listed by the component as
///         one it handles.
///
///     <li> The __type__ is retrieved from the Intent's data, if not
///         already supplied in the Intent.  Like the action, if a type is
///         included in the intent (either explicitly or implicitly in its
///         data), then this must be listed by the component as one it handles.
///
///     <li> For data that is not a <code>content:</code> URI and where no explicit
///         type is included in the Intent, instead the __scheme__ of the
///         intent data (such as <code>http:</code> or <code>mailto:</code>) is
///         considered. Again like the action, if we are matching a scheme it
///         must be listed by the component as one it can handle.
///     <li> The __categories__, if supplied, must _all_ be listed
///         by the activity as categories it handles.  That is, if you include
///         the categories \#CATEGORY_LAUNCHER and
///         \#CATEGORY_ALTERNATIVE, then you will only resolve to components
///         with an intent that lists _both_ of those categories.
///         Activities will very often need to support the
///         \#CATEGORY_DEFAULT so that they can be found by
///         Context\#startActivity Context.startActivity().
///
/// </ul>
///
/// For example, consider the Note Pad sample application that
/// allows a user to browse through a list of notes data and view details about
/// individual items.  Text in italics indicates places where you would replace a
/// name with one specific to your own package.
///
///
/// <pre> &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
///       package="<i>com.android.notepad</i>"&gt;
///     &lt;application android:icon="@drawable/app_notes"
///             android:label="@string/app_name"&gt;
///
///         &lt;provider class=".NotePadProvider"
///                 android:authorities="<i>com.google.provider.NotePad</i>" /&gt;
///
///         &lt;activity class=".NotesList" android:label="@string/title_notes_list"&gt;
///             &lt;intent-filter&gt;
///                 &lt;action android:name="android.intent.action.MAIN" /&gt;
///                 &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
///             &lt;/intent-filter&gt;
///             &lt;intent-filter&gt;
///                 &lt;action android:name="android.intent.action.VIEW" /&gt;
///                 &lt;action android:name="android.intent.action.EDIT" /&gt;
///                 &lt;action android:name="android.intent.action.PICK" /&gt;
///                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
///                 &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
///             &lt;/intent-filter&gt;
///             &lt;intent-filter&gt;
///                 &lt;action android:name="android.intent.action.GET_CONTENT" /&gt;
///                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
///                 &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
///             &lt;/intent-filter&gt;
///         &lt;/activity&gt;
///
///         &lt;activity class=".NoteEditor" android:label="@string/title_note"&gt;
///             &lt;intent-filter android:label="@string/resolve_edit"&gt;
///                 &lt;action android:name="android.intent.action.VIEW" /&gt;
///                 &lt;action android:name="android.intent.action.EDIT" /&gt;
///                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
///                 &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
///             &lt;/intent-filter&gt;
///
///             &lt;intent-filter&gt;
///                 &lt;action android:name="android.intent.action.INSERT" /&gt;
///                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
///                 &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
///             &lt;/intent-filter&gt;
///
///         &lt;/activity&gt;
///
///         &lt;activity class=".TitleEditor" android:label="@string/title_edit_title"
///                 android:theme="@android:style/Theme.Dialog"&gt;
///             &lt;intent-filter android:label="@string/resolve_title"&gt;
///                 &lt;action android:name="<i>com.android.notepad.action.EDIT_TITLE</i>" /&gt;
///                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
///                 &lt;category android:name="android.intent.category.ALTERNATIVE" /&gt;
///                 &lt;category android:name="android.intent.category.SELECTED_ALTERNATIVE" /&gt;
///                 &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
///             &lt;/intent-filter&gt;
///         &lt;/activity&gt;
///
///     &lt;/application&gt;
/// &lt;/manifest&gt;</pre>
///
/// The first activity,
/// <code>com.android.notepad.NotesList</code>, serves as our main
/// entry into the app.  It can do three things as described by its three intent
/// templates:
/// <ol>
/// <li><pre>
/// &lt;intent-filter&gt;
///     &lt;action android:name="\#ACTION_MAIN android.intent.action.MAIN" /&gt;
///     &lt;category android:name="\#CATEGORY_LAUNCHER android.intent.category.LAUNCHER" /&gt;
/// &lt;/intent-filter&gt;</pre>
/// This provides a top-level entry into the NotePad application: the standard
/// MAIN action is a main entry point (not requiring any other information in
/// the Intent), and the LAUNCHER category says that this entry point should be
/// listed in the application launcher.
///
/// <li><pre>
/// &lt;intent-filter&gt;
///     &lt;action android:name="\#ACTION_VIEW android.intent.action.VIEW" /&gt;
///     &lt;action android:name="\#ACTION_EDIT android.intent.action.EDIT" /&gt;
///     &lt;action android:name="\#ACTION_PICK android.intent.action.PICK" /&gt;
///     &lt;category android:name="\#CATEGORY_DEFAULT android.intent.category.DEFAULT" /&gt;
///     &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
/// &lt;/intent-filter&gt;</pre>
/// This declares the things that the activity can do on a directory of
/// notes.  The type being supported is given with the &lt;type&gt; tag, where
/// <code>vnd.android.cursor.dir/vnd.google.note</code> is a URI from which
/// a Cursor of zero or more items (<code>vnd.android.cursor.dir</code>) can
/// be retrieved which holds our note pad data (<code>vnd.google.note</code>).
/// The activity allows the user to view or edit the directory of data (via
/// the VIEW and EDIT actions), or to pick a particular note and return it
/// to the caller (via the PICK action).  Note also the DEFAULT category
/// supplied here: this is _required_ for the
/// Context\#startActivity Context.startActivity method to resolve your
/// activity when its component name is not explicitly specified.
///
/// <li><pre>
/// &lt;intent-filter&gt;
///     &lt;action android:name="\#ACTION_GET_CONTENT android.intent.action.GET_CONTENT" /&gt;
///     &lt;category android:name="\#CATEGORY_DEFAULT android.intent.category.DEFAULT" /&gt;
///     &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
/// &lt;/intent-filter&gt;</pre>
/// This filter describes the ability to return to the caller a note selected by
/// the user without needing to know where it came from.  The data type
/// <code>vnd.android.cursor.item/vnd.google.note</code> is a URI from which
/// a Cursor of exactly one (<code>vnd.android.cursor.item</code>) item can
/// be retrieved which contains our note pad data (<code>vnd.google.note</code>).
/// The GET_CONTENT action is similar to the PICK action, where the activity
/// will return to its caller a piece of data selected by the user.  Here,
/// however, the caller specifies the type of data they desire instead of
/// the type of data the user will be picking from.
///
/// </ol>
///
/// Given these capabilities, the following intents will resolve to the
/// NotesList activity:
///
///
/// <ul>
///     <li> __{ action=android.app.action.MAIN }__ matches all of the
///         activities that can be used as top-level entry points into an
///         application.
///
///     <li> __{ action=android.app.action.MAIN,
///         category=android.app.category.LAUNCHER }__ is the actual intent
///         used by the Launcher to populate its top-level list.
///
///     <li> __{ action=android.intent.action.VIEW
///          data=content://com.google.provider.NotePad/notes }__
///         displays a list of all the notes under
///         "content://com.google.provider.NotePad/notes", which
///         the user can browse through and see the details on.
///
///     <li> __{ action=android.app.action.PICK
///          data=content://com.google.provider.NotePad/notes }__
///         provides a list of the notes under
///         "content://com.google.provider.NotePad/notes", from which
///         the user can pick a note whose data URL is returned back to the caller.
///
///     <li> __{ action=android.app.action.GET_CONTENT
///          type=vnd.android.cursor.item/vnd.google.note }__
///         is similar to the pick action, but allows the caller to specify the
///         kind of data they want back so that the system can find the appropriate
///         activity to pick something of that data type.
///
/// </ul>
///
/// The second activity,
/// <code>com.android.notepad.NoteEditor</code>, shows the user a single
/// note entry and allows them to edit it.  It can do two things as described
/// by its two intent templates:
/// <ol>
/// <li><pre>
/// &lt;intent-filter android:label="@string/resolve_edit"&gt;
///     &lt;action android:name="\#ACTION_VIEW android.intent.action.VIEW" /&gt;
///     &lt;action android:name="\#ACTION_EDIT android.intent.action.EDIT" /&gt;
///     &lt;category android:name="\#CATEGORY_DEFAULT android.intent.category.DEFAULT" /&gt;
///     &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
/// &lt;/intent-filter&gt;</pre>
/// The first, primary, purpose of this activity is to let the user interact
/// with a single note, as decribed by the MIME type
/// <code>vnd.android.cursor.item/vnd.google.note</code>.  The activity can
/// either VIEW a note or allow the user to EDIT it.  Again we support the
/// DEFAULT category to allow the activity to be launched without explicitly
/// specifying its component.
///
/// <li><pre>
/// &lt;intent-filter&gt;
///     &lt;action android:name="\#ACTION_INSERT android.intent.action.INSERT" /&gt;
///     &lt;category android:name="\#CATEGORY_DEFAULT android.intent.category.DEFAULT" /&gt;
///     &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
/// &lt;/intent-filter&gt;</pre>
/// The secondary use of this activity is to insert a new note entry into
/// an existing directory of notes.  This is used when the user creates a new
/// note: the INSERT action is executed on the directory of notes, causing
/// this activity to run and have the user create the new note data which
/// it then adds to the content provider.
///
/// </ol>
///
/// Given these capabilities, the following intents will resolve to the
/// NoteEditor activity:
///
///
/// <ul>
///     <li> __{ action=android.intent.action.VIEW
///          data=content://com.google.provider.NotePad/notes/<var>{ID}</var> }__
///         shows the user the content of note <var>{ID}</var>.
///
///     <li> __{ action=android.app.action.EDIT
///          data=content://com.google.provider.NotePad/notes/<var>{ID}</var> }__
///         allows the user to edit the content of note <var>{ID}</var>.
///
///     <li> __{ action=android.app.action.INSERT
///          data=content://com.google.provider.NotePad/notes }__
///         creates a new, empty note in the notes list at
///         "content://com.google.provider.NotePad/notes"
///         and allows the user to edit it.  If they keep their changes, the URI
///         of the newly created note is returned to the caller.
///
/// </ul>
///
/// The last activity,
/// <code>com.android.notepad.TitleEditor</code>, allows the user to
/// edit the title of a note.  This could be implemented as a class that the
/// application directly invokes (by explicitly setting its component in
/// the Intent), but here we show a way you can publish alternative
/// operations on existing data:
///
///
/// <pre>
/// &lt;intent-filter android:label="@string/resolve_title"&gt;
///     &lt;action android:name="<i>com.android.notepad.action.EDIT_TITLE</i>" /&gt;
///     &lt;category android:name="\#CATEGORY_DEFAULT android.intent.category.DEFAULT" /&gt;
///     &lt;category android:name="\#CATEGORY_ALTERNATIVE android.intent.category.ALTERNATIVE" /&gt;
///     &lt;category android:name="\#CATEGORY_SELECTED_ALTERNATIVE android.intent.category.SELECTED_ALTERNATIVE" /&gt;
///     &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
/// &lt;/intent-filter&gt;</pre>
///
/// In the single intent template here, we
/// have created our own private action called
/// <code>com.android.notepad.action.EDIT_TITLE</code> which means to
/// edit the title of a note.  It must be invoked on a specific note
/// (data type <code>vnd.android.cursor.item/vnd.google.note</code>) like the previous
/// view and edit actions, but here displays and edits the title contained
/// in the note data.
///
/// In addition to supporting the default category as usual, our title editor
/// also supports two other standard categories: ALTERNATIVE and
/// SELECTED_ALTERNATIVE.  Implementing
/// these categories allows others to find the special action it provides
/// without directly knowing about it, through the
/// android.content.pm.PackageManager\#queryIntentActivityOptions method, or
/// more often to build dynamic menu items with
/// android.view.Menu\#addIntentOptions.  Note that in the intent
/// template here was also supply an explicit name for the template
/// (via <code>android:label="@string/resolve_title"</code>) to better control
/// what the user sees when presented with this activity as an alternative
/// action to the data they are viewing.
///
/// Given these capabilities, the following intent will resolve to the
/// TitleEditor activity:
///
///
/// <ul>
///     <li> __{ action=com.android.notepad.action.EDIT_TITLE
///          data=content://com.google.provider.NotePad/notes/<var>{ID}</var> }__
///         displays and allows the user to edit the title associated
///         with note <var>{ID}</var>.
///
/// </ul>
///
/// <h3>Standard Activity Actions</h3>
///
/// These are the current standard actions that Intent defines for launching
/// activities (usually through Context\#startActivity.  The most
/// important, and by far most frequently used, are \#ACTION_MAIN and
/// \#ACTION_EDIT.
///
/// <ul>
///     <li> \#ACTION_MAIN
///     <li> \#ACTION_VIEW
///     <li> \#ACTION_ATTACH_DATA
///     <li> \#ACTION_EDIT
///     <li> \#ACTION_PICK
///     <li> \#ACTION_CHOOSER
///     <li> \#ACTION_GET_CONTENT
///     <li> \#ACTION_DIAL
///     <li> \#ACTION_CALL
///     <li> \#ACTION_SEND
///     <li> \#ACTION_SENDTO
///     <li> \#ACTION_ANSWER
///     <li> \#ACTION_INSERT
///     <li> \#ACTION_DELETE
///     <li> \#ACTION_RUN
///     <li> \#ACTION_SYNC
///     <li> \#ACTION_PICK_ACTIVITY
///     <li> \#ACTION_SEARCH
///     <li> \#ACTION_WEB_SEARCH
///     <li> \#ACTION_FACTORY_TEST
/// </ul>
///
/// <h3>Standard Broadcast Actions</h3>
///
/// These are the current standard actions that Intent defines for receiving
/// broadcasts (usually through Context\#registerReceiver or a
/// &lt;receiver&gt; tag in a manifest).
///
/// <ul>
///     <li> \#ACTION_TIME_TICK
///     <li> \#ACTION_TIME_CHANGED
///     <li> \#ACTION_TIMEZONE_CHANGED
///     <li> \#ACTION_BOOT_COMPLETED
///     <li> \#ACTION_PACKAGE_ADDED
///     <li> \#ACTION_PACKAGE_CHANGED
///     <li> \#ACTION_PACKAGE_REMOVED
///     <li> \#ACTION_PACKAGE_RESTARTED
///     <li> \#ACTION_PACKAGE_DATA_CLEARED
///     <li> \#ACTION_PACKAGES_SUSPENDED
///     <li> \#ACTION_PACKAGES_UNSUSPENDED
///     <li> \#ACTION_UID_REMOVED
///     <li> \#ACTION_BATTERY_CHANGED
///     <li> \#ACTION_POWER_CONNECTED
///     <li> \#ACTION_POWER_DISCONNECTED
///     <li> \#ACTION_SHUTDOWN
/// </ul>
///
/// <h3>Standard Categories</h3>
///
/// These are the current standard categories that can be used to further
/// clarify an Intent via \#addCategory.
///
/// <ul>
///     <li> \#CATEGORY_DEFAULT
///     <li> \#CATEGORY_BROWSABLE
///     <li> \#CATEGORY_TAB
///     <li> \#CATEGORY_ALTERNATIVE
///     <li> \#CATEGORY_SELECTED_ALTERNATIVE
///     <li> \#CATEGORY_LAUNCHER
///     <li> \#CATEGORY_INFO
///     <li> \#CATEGORY_HOME
///     <li> \#CATEGORY_PREFERENCE
///     <li> \#CATEGORY_TEST
///     <li> \#CATEGORY_CAR_DOCK
///     <li> \#CATEGORY_DESK_DOCK
///     <li> \#CATEGORY_LE_DESK_DOCK
///     <li> \#CATEGORY_HE_DESK_DOCK
///     <li> \#CATEGORY_CAR_MODE
///     <li> \#CATEGORY_APP_MARKET
///     <li> \#CATEGORY_VR_HOME
/// </ul>
///
/// <h3>Standard Extra Data</h3>
///
/// These are the current standard fields that can be used as extra data via
/// \#putExtra.
///
/// <ul>
///     <li> \#EXTRA_ALARM_COUNT
///     <li> \#EXTRA_BCC
///     <li> \#EXTRA_CC
///     <li> \#EXTRA_CHANGED_COMPONENT_NAME
///     <li> \#EXTRA_DATA_REMOVED
///     <li> \#EXTRA_DOCK_STATE
///     <li> \#EXTRA_DOCK_STATE_HE_DESK
///     <li> \#EXTRA_DOCK_STATE_LE_DESK
///     <li> \#EXTRA_DOCK_STATE_CAR
///     <li> \#EXTRA_DOCK_STATE_DESK
///     <li> \#EXTRA_DOCK_STATE_UNDOCKED
///     <li> \#EXTRA_DONT_KILL_APP
///     <li> \#EXTRA_EMAIL
///     <li> \#EXTRA_INITIAL_INTENTS
///     <li> \#EXTRA_INTENT
///     <li> \#EXTRA_KEY_EVENT
///     <li> \#EXTRA_ORIGINATING_URI
///     <li> \#EXTRA_PHONE_NUMBER
///     <li> \#EXTRA_REFERRER
///     <li> \#EXTRA_REMOTE_INTENT_TOKEN
///     <li> \#EXTRA_REPLACING
///     <li> \#EXTRA_SHORTCUT_ICON
///     <li> \#EXTRA_SHORTCUT_ICON_RESOURCE
///     <li> \#EXTRA_SHORTCUT_INTENT
///     <li> \#EXTRA_STREAM
///     <li> \#EXTRA_SHORTCUT_NAME
///     <li> \#EXTRA_SUBJECT
///     <li> \#EXTRA_TEMPLATE
///     <li> \#EXTRA_TEXT
///     <li> \#EXTRA_TITLE
///     <li> \#EXTRA_UID
/// </ul>
///
/// <h3>Flags</h3>
///
/// These are the possible flags that can be used in the Intent via
/// \#setFlags and \#addFlags.  See \#setFlags for a list
/// of all possible flags.
class Intent extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/content/Intent");
  Intent.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_AIRPLANE_MODE_CHANGED
  ///
  /// Broadcast Action: The user has switched the phone into or out of Airplane Mode. One or
  /// more radios have been turned off or on. The intent will have the following extra value:
  ///
  /// <ul>
  ///   <li>_state_ - A boolean value indicating whether Airplane Mode is on. If true,
  ///   then cell radio and possibly other radios such as bluetooth or WiFi may have also been
  ///   turned off</li>
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent by the system.
  ///
  static const ACTION_AIRPLANE_MODE_CHANGED =
      "android.intent.action.AIRPLANE_MODE";

  /// from: static public final java.lang.String ACTION_ALL_APPS
  ///
  /// Activity Action: List all available applications.
  /// Input: Nothing.
  /// Output: nothing.
  static const ACTION_ALL_APPS = "android.intent.action.ALL_APPS";

  /// from: static public final java.lang.String ACTION_ANSWER
  ///
  /// Activity Action: Handle an incoming phone call.
  /// Input: nothing.
  /// Output: nothing.
  static const ACTION_ANSWER = "android.intent.action.ANSWER";

  /// from: static public final java.lang.String ACTION_APPLICATION_PREFERENCES
  ///
  /// An activity that provides a user interface for adjusting application preferences.
  /// Optional but recommended settings for all applications which have settings.
  static const ACTION_APPLICATION_PREFERENCES =
      "android.intent.action.APPLICATION_PREFERENCES";

  /// from: static public final java.lang.String ACTION_APPLICATION_RESTRICTIONS_CHANGED
  ///
  /// Broadcast Action: Sent after application restrictions are changed.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  ///
  static const ACTION_APPLICATION_RESTRICTIONS_CHANGED =
      "android.intent.action.APPLICATION_RESTRICTIONS_CHANGED";

  /// from: static public final java.lang.String ACTION_APP_ERROR
  ///
  /// Activity Action: The user pressed the "Report" button in the crash/ANR dialog.
  /// This intent is delivered to the package which installed the application, usually
  /// Google Play.
  /// Input: No data is specified. The bug report is passed in using
  /// an \#EXTRA_BUG_REPORT field.
  /// Output: Nothing.
  ///@see \#EXTRA_BUG_REPORT
  static const ACTION_APP_ERROR = "android.intent.action.APP_ERROR";

  /// from: static public final java.lang.String ACTION_ASSIST
  ///
  /// Activity Action: Perform assist action.
  ///
  /// Input: \#EXTRA_ASSIST_PACKAGE, \#EXTRA_ASSIST_CONTEXT, can provide
  /// additional optional contextual information about where the user was when they
  /// requested the assist; \#EXTRA_REFERRER may be set with additional referrer
  /// information.
  /// Output: nothing.
  static const ACTION_ASSIST = "android.intent.action.ASSIST";

  /// from: static public final java.lang.String ACTION_ATTACH_DATA
  ///
  /// Used to indicate that some piece of data should be attached to some other
  /// place.  For example, image data could be attached to a contact.  It is up
  /// to the recipient to decide where the data should be attached; the intent
  /// does not specify the ultimate destination.
  /// Input: \#getData is URI of data to be attached.
  /// Output: nothing.
  static const ACTION_ATTACH_DATA = "android.intent.action.ATTACH_DATA";

  /// from: static public final java.lang.String ACTION_BATTERY_CHANGED
  ///
  /// Broadcast Action:  This is a _sticky broadcast_ containing the
  /// charging state, level, and other information about the battery.
  /// See android.os.BatteryManager for documentation on the
  /// contents of the Intent.
  ///
  /// <p class="note">
  /// You _cannot_ receive this through components declared
  /// in manifests, only by explicitly registering for it with
  /// Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver().  See \#ACTION_BATTERY_LOW,
  /// \#ACTION_BATTERY_OKAY, \#ACTION_POWER_CONNECTED,
  /// and \#ACTION_POWER_DISCONNECTED for distinct battery-related
  /// broadcasts that are sent and can be received through manifest
  /// receivers.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_BATTERY_CHANGED = "android.intent.action.BATTERY_CHANGED";

  /// from: static public final java.lang.String ACTION_BATTERY_LOW
  ///
  /// Broadcast Action:  Indicates low battery condition on the device.
  /// This broadcast corresponds to the "Low battery warning" system dialog.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_BATTERY_LOW = "android.intent.action.BATTERY_LOW";

  /// from: static public final java.lang.String ACTION_BATTERY_OKAY
  ///
  /// Broadcast Action:  Indicates the battery is now okay after being low.
  /// This will be sent after \#ACTION_BATTERY_LOW once the battery has
  /// gone back up to an okay state.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_BATTERY_OKAY = "android.intent.action.BATTERY_OKAY";

  /// from: static public final java.lang.String ACTION_BOOT_COMPLETED
  ///
  /// Broadcast Action: This is broadcast once, after the user has finished
  /// booting. It can be used to perform application-specific initialization,
  /// such as installing alarms. You must hold the
  /// android.Manifest.permission\#RECEIVE_BOOT_COMPLETED permission in
  /// order to receive this broadcast.
  ///
  /// This broadcast is sent at boot by all devices (both with and without
  /// direct boot support). Upon receipt of this broadcast, the user is
  /// unlocked and both device-protected and credential-protected storage can
  /// accessed safely.
  ///
  /// If you need to run while the user is still locked (before they've entered
  /// their lock pattern or PIN for the first time), you can listen for the
  /// \#ACTION_LOCKED_BOOT_COMPLETED broadcast.
  /// <p class="note">
  /// This is a protected intent that can only be sent by the system.
  static const ACTION_BOOT_COMPLETED = "android.intent.action.BOOT_COMPLETED";

  /// from: static public final java.lang.String ACTION_BUG_REPORT
  ///
  /// Activity Action: Show activity for reporting a bug.
  /// Input: Nothing.
  /// Output: Nothing.
  static const ACTION_BUG_REPORT = "android.intent.action.BUG_REPORT";

  /// from: static public final java.lang.String ACTION_CALL
  ///
  /// Activity Action: Perform a call to someone specified by the data.
  /// Input: If nothing, an empty dialer is started; else \#getData
  /// is URI of a phone number to be dialed or a tel: URI of an explicit phone
  /// number.
  /// Output: nothing.
  ///
  /// Note: there will be restrictions on which applications can initiate a
  /// call; most applications should use the \#ACTION_DIAL.
  /// Note: this Intent <strong>cannot</strong> be used to call emergency
  /// numbers.  Applications can <strong>dial</strong> emergency numbers using
  /// \#ACTION_DIAL, however.
  ///
  /// Note: if you app targets android.os.Build.VERSION_CODES\#M M
  /// and above and declares as using the android.Manifest.permission\#CALL_PHONE
  /// permission which is not granted, then attempting to use this action will
  /// result in a java.lang.SecurityException.
  static const ACTION_CALL = "android.intent.action.CALL";

  /// from: static public final java.lang.String ACTION_CALL_BUTTON
  ///
  /// Activity Action: The user pressed the "call" button to go to the dialer
  /// or other appropriate UI for placing a call.
  /// Input: Nothing.
  /// Output: Nothing.
  static const ACTION_CALL_BUTTON = "android.intent.action.CALL_BUTTON";

  /// from: static public final java.lang.String ACTION_CAMERA_BUTTON
  ///
  /// Broadcast Action:  The "Camera Button" was pressed.  Includes a single
  /// extra field, \#EXTRA_KEY_EVENT, containing the key event that
  /// caused the broadcast.
  static const ACTION_CAMERA_BUTTON = "android.intent.action.CAMERA_BUTTON";

  /// from: static public final java.lang.String ACTION_CARRIER_SETUP
  ///
  /// Activity Action: Main entry point for carrier setup apps.
  /// Carrier apps that provide an implementation for this action may be invoked to configure
  /// carrier service and typically require
  /// android.telephony.TelephonyManager\#hasCarrierPrivileges() carrier privileges to
  /// fulfill their duties.
  static const ACTION_CARRIER_SETUP = "android.intent.action.CARRIER_SETUP";

  /// from: static public final java.lang.String ACTION_CHOOSER
  ///
  /// Activity Action: Display an activity chooser, allowing the user to pick
  /// what they want to before proceeding.  This can be used as an alternative
  /// to the standard activity picker that is displayed by the system when
  /// you try to start an activity with multiple possible matches, with these
  /// differences in behavior:
  /// <ul>
  /// <li>You can specify the title that will appear in the activity chooser.
  /// <li>The user does not have the option to make one of the matching
  /// activities a preferred activity, and all possible activities will
  /// always be shown even if one of them is currently marked as the
  /// preferred activity.
  /// </ul>
  ///
  /// This action should be used when the user will naturally expect to
  /// select an activity in order to proceed.  An example if when not to use
  /// it is when the user clicks on a "mailto:" link.  They would naturally
  /// expect to go directly to their mail app, so startActivity() should be
  /// called directly: it will
  /// either launch the current preferred app, or put up a dialog allowing the
  /// user to pick an app to use and optionally marking that as preferred.
  ///
  /// In contrast, if the user is selecting a menu item to send a picture
  /// they are viewing to someone else, there are many different things they
  /// may want to do at this point: send it through e-mail, upload it to a
  /// web service, etc.  In this case the CHOOSER action should be used, to
  /// always present to the user a list of the things they can do, with a
  /// nice title given by the caller such as "Send this photo with:".
  ///
  /// If you need to grant URI permissions through a chooser, you must specify
  /// the permissions to be granted on the ACTION_CHOOSER Intent
  /// _in addition_ to the EXTRA_INTENT inside.  This means using
  /// \#setClipData to specify the URIs to be granted as well as
  /// \#FLAG_GRANT_READ_URI_PERMISSION and/or
  /// \#FLAG_GRANT_WRITE_URI_PERMISSION as appropriate.
  ///
  /// As a convenience, an Intent of this form can be created with the
  /// \#createChooser function.
  ///
  /// Input: No data should be specified.  get*Extra must have
  /// a \#EXTRA_INTENT field containing the Intent being executed,
  /// and can optionally have a \#EXTRA_TITLE field containing the
  /// title text to display in the chooser.
  ///
  /// Output: Depends on the protocol of \#EXTRA_INTENT.
  static const ACTION_CHOOSER = "android.intent.action.CHOOSER";

  /// from: static public final java.lang.String ACTION_CLOSE_SYSTEM_DIALOGS
  ///
  /// Broadcast Action: This is broadcast when a user action should request a
  /// temporary system dialog to dismiss.  Some examples of temporary system
  /// dialogs are the notification window-shade and the recent tasks dialog.
  static const ACTION_CLOSE_SYSTEM_DIALOGS =
      "android.intent.action.CLOSE_SYSTEM_DIALOGS";

  /// from: static public final java.lang.String ACTION_CONFIGURATION_CHANGED
  ///
  /// Broadcast Action: The current device android.content.res.Configuration
  /// (orientation, locale, etc) has changed.  When such a change happens, the
  /// UIs (view hierarchy) will need to be rebuilt based on this new
  /// information; for the most part, applications don't need to worry about
  /// this, because the system will take care of stopping and restarting the
  /// application to make sure it sees the new changes.  Some system code that
  /// can not be restarted will need to watch for this action and handle it
  /// appropriately.
  ///
  /// <p class="note">
  /// You _cannot_ receive this through components declared
  /// in manifests, only by explicitly registering for it with
  /// Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver().
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  ///@see android.content.res.Configuration
  static const ACTION_CONFIGURATION_CHANGED =
      "android.intent.action.CONFIGURATION_CHANGED";

  /// from: static public final java.lang.String ACTION_CREATE_DOCUMENT
  ///
  /// Activity Action: Allow the user to create a new document. When invoked,
  /// the system will display the various DocumentsProvider instances
  /// installed on the device, letting the user navigate through them. The
  /// returned document may be a newly created document with no content, or it
  /// may be an existing document with the requested MIME type.
  ///
  /// Each document is represented as a {@code content://} URI backed by a
  /// DocumentsProvider, which can be opened as a stream with
  /// ContentResolver\#openFileDescriptor(Uri, String), or queried for
  /// android.provider.DocumentsContract.Document metadata.
  ///
  /// Callers must indicate the concrete MIME type of the document being
  /// created by setting \#setType(String). This MIME type cannot be
  /// changed after the document is created.
  ///
  /// Callers can provide an initial display name through \#EXTRA_TITLE,
  /// but the user may change this value before creating the file.
  ///
  /// Callers must include \#CATEGORY_OPENABLE in the Intent to obtain
  /// URIs that can be opened with
  /// ContentResolver\#openFileDescriptor(Uri, String).
  ///
  /// Callers can set a document URI through
  /// DocumentsContract\#EXTRA_INITIAL_URI to indicate the initial
  /// location of documents navigator. System will do its best to launch the
  /// navigator in the specified document if it's a folder, or the folder that
  /// contains the specified document if not.
  ///
  /// Output: The URI of the item that was created. This must be a
  /// {@code content://} URI so that any receiver can access it.
  ///@see DocumentsContract
  ///@see \#ACTION_OPEN_DOCUMENT
  ///@see \#ACTION_OPEN_DOCUMENT_TREE
  ///@see \#FLAG_GRANT_PERSISTABLE_URI_PERMISSION
  static const ACTION_CREATE_DOCUMENT = "android.intent.action.CREATE_DOCUMENT";

  /// from: static public final java.lang.String ACTION_CREATE_SHORTCUT
  ///
  /// Activity Action: Creates a shortcut.
  /// Input: Nothing.
  ///
  /// Output: An Intent representing the android.content.pm.ShortcutInfo result.
  ///
  /// For compatibility with older versions of android the intent may also contain three
  /// extras: SHORTCUT_INTENT (value: Intent), SHORTCUT_NAME (value: String),
  /// and SHORTCUT_ICON (value: Bitmap) or SHORTCUT_ICON_RESOURCE
  /// (value: ShortcutIconResource).
  ///
  ///@see android.content.pm.ShortcutManager\#createShortcutResultIntent
  ///@see \#EXTRA_SHORTCUT_INTENT
  ///@see \#EXTRA_SHORTCUT_NAME
  ///@see \#EXTRA_SHORTCUT_ICON
  ///@see \#EXTRA_SHORTCUT_ICON_RESOURCE
  ///@see android.content.Intent.ShortcutIconResource
  static const ACTION_CREATE_SHORTCUT = "android.intent.action.CREATE_SHORTCUT";

  /// from: static public final java.lang.String ACTION_DATE_CHANGED
  ///
  /// Broadcast Action: The date has changed.
  static const ACTION_DATE_CHANGED = "android.intent.action.DATE_CHANGED";

  /// from: static public final java.lang.String ACTION_DEFAULT
  ///
  /// A synonym for \#ACTION_VIEW, the "standard" action that is
  /// performed on a piece of data.
  static const ACTION_DEFAULT = "android.intent.action.VIEW";

  /// from: static public final java.lang.String ACTION_DELETE
  ///
  /// Activity Action: Delete the given data from its container.
  /// Input: \#getData is URI of data to be deleted.
  /// Output: nothing.
  static const ACTION_DELETE = "android.intent.action.DELETE";

  /// from: static public final java.lang.String ACTION_DEVICE_STORAGE_LOW
  ///
  /// Broadcast Action: A sticky broadcast that indicates low storage space
  /// condition on the device
  /// <p class="note">
  /// This is a protected intent that can only be sent by the system.
  ///@deprecated if your app targets android.os.Build.VERSION_CODES\#O
  ///             or above, this broadcast will no longer be delivered to any
  ///             BroadcastReceiver defined in your manifest. Instead,
  ///             apps are strongly encouraged to use the improved
  ///             Context\#getCacheDir() behavior so the system can
  ///             automatically free up storage when needed.
  static const ACTION_DEVICE_STORAGE_LOW =
      "android.intent.action.DEVICE_STORAGE_LOW";

  /// from: static public final java.lang.String ACTION_DEVICE_STORAGE_OK
  ///
  /// Broadcast Action: Indicates low storage space condition on the device no
  /// longer exists
  /// <p class="note">
  /// This is a protected intent that can only be sent by the system.
  ///@deprecated if your app targets android.os.Build.VERSION_CODES\#O
  ///             or above, this broadcast will no longer be delivered to any
  ///             BroadcastReceiver defined in your manifest. Instead,
  ///             apps are strongly encouraged to use the improved
  ///             Context\#getCacheDir() behavior so the system can
  ///             automatically free up storage when needed.
  static const ACTION_DEVICE_STORAGE_OK =
      "android.intent.action.DEVICE_STORAGE_OK";

  /// from: static public final java.lang.String ACTION_DIAL
  ///
  /// Activity Action: Dial a number as specified by the data.  This shows a
  /// UI with the number being dialed, allowing the user to explicitly
  /// initiate the call.
  /// Input: If nothing, an empty dialer is started; else \#getData
  /// is URI of a phone number to be dialed or a tel: URI of an explicit phone
  /// number.
  /// Output: nothing.
  static const ACTION_DIAL = "android.intent.action.DIAL";

  /// from: static public final java.lang.String ACTION_DOCK_EVENT
  ///
  /// Broadcast Action:  A sticky broadcast for changes in the physical
  /// docking state of the device.
  ///
  /// The intent will have the following extra values:
  /// <ul>
  ///   <li>_\#EXTRA_DOCK_STATE_ - the current dock
  ///       state, indicating which dock the device is physically in.</li>
  /// </ul>
  /// This is intended for monitoring the current physical dock state.
  /// See android.app.UiModeManager for the normal API dealing with
  /// dock mode changes.
  static const ACTION_DOCK_EVENT = "android.intent.action.DOCK_EVENT";

  /// from: static public final java.lang.String ACTION_DREAMING_STARTED
  ///
  /// Broadcast Action: Sent after the system starts dreaming.
  ///
  /// <p class="note">This is a protected intent that can only be sent by the system.
  /// It is only sent to registered receivers.
  ///
  static const ACTION_DREAMING_STARTED =
      "android.intent.action.DREAMING_STARTED";

  /// from: static public final java.lang.String ACTION_DREAMING_STOPPED
  ///
  /// Broadcast Action: Sent after the system stops dreaming.
  ///
  /// <p class="note">This is a protected intent that can only be sent by the system.
  /// It is only sent to registered receivers.
  ///
  static const ACTION_DREAMING_STOPPED =
      "android.intent.action.DREAMING_STOPPED";

  /// from: static public final java.lang.String ACTION_EDIT
  ///
  /// Activity Action: Provide explicit editable access to the given data.
  /// Input: \#getData is URI of data to be edited.
  /// Output: nothing.
  static const ACTION_EDIT = "android.intent.action.EDIT";

  /// from: static public final java.lang.String ACTION_EXTERNAL_APPLICATIONS_AVAILABLE
  ///
  /// Broadcast Action: Resources for a set of packages (which were
  /// previously unavailable) are currently
  /// available since the media on which they exist is available.
  /// The extra data \#EXTRA_CHANGED_PACKAGE_LIST contains a
  /// list of packages whose availability changed.
  /// The extra data \#EXTRA_CHANGED_UID_LIST contains a
  /// list of uids of packages whose availability changed.
  /// Note that the
  /// packages in this list do _not_ receive this broadcast.
  /// The specified set of packages are now available on the system.
  /// Includes the following extras:
  /// <ul>
  /// <li> \#EXTRA_CHANGED_PACKAGE_LIST is the set of packages
  /// whose resources(were previously unavailable) are currently available.
  /// \#EXTRA_CHANGED_UID_LIST is the set of uids of the
  /// packages whose resources(were previously unavailable)
  /// are  currently available.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_EXTERNAL_APPLICATIONS_AVAILABLE =
      "android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE";

  /// from: static public final java.lang.String ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE
  ///
  /// Broadcast Action: Resources for a set of packages are currently
  /// unavailable since the media on which they exist is unavailable.
  /// The extra data \#EXTRA_CHANGED_PACKAGE_LIST contains a
  /// list of packages whose availability changed.
  /// The extra data \#EXTRA_CHANGED_UID_LIST contains a
  /// list of uids of packages whose availability changed.
  /// The specified set of packages can no longer be
  /// launched and are practically unavailable on the system.
  /// Inclues the following extras:
  /// <ul>
  /// <li> \#EXTRA_CHANGED_PACKAGE_LIST is the set of packages
  /// whose resources are no longer available.
  /// \#EXTRA_CHANGED_UID_LIST is the set of packages
  /// whose resources are no longer available.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE =
      "android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE";

  /// from: static public final java.lang.String ACTION_FACTORY_TEST
  ///
  /// Activity Action: Main entry point for factory tests.  Only used when
  ///  the device is booting in factory test node.  The implementing package
  ///  must be installed in the system image.
  ///  Input: nothing
  ///  Output: nothing
  static const ACTION_FACTORY_TEST = "android.intent.action.FACTORY_TEST";

  /// from: static public final java.lang.String ACTION_GET_CONTENT
  ///
  /// Activity Action: Allow the user to select a particular kind of data and
  /// return it.  This is different than \#ACTION_PICK in that here we
  /// just say what kind of data is desired, not a URI of existing data from
  /// which the user can pick.  An ACTION_GET_CONTENT could allow the user to
  /// create the data as it runs (for example taking a picture or recording a
  /// sound), let them browse over the web and download the desired data,
  /// etc.
  ///
  /// There are two main ways to use this action: if you want a specific kind
  /// of data, such as a person contact, you set the MIME type to the kind of
  /// data you want and launch it with Context\#startActivity(Intent).
  /// The system will then launch the best application to select that kind
  /// of data for you.
  ///
  /// You may also be interested in any of a set of types of content the user
  /// can pick.  For example, an e-mail application that wants to allow the
  /// user to add an attachment to an e-mail message can use this action to
  /// bring up a list of all of the types of content the user can attach.
  ///
  /// In this case, you should wrap the GET_CONTENT intent with a chooser
  /// (through \#createChooser), which will give the proper interface
  /// for the user to pick how to send your data and allow you to specify
  /// a prompt indicating what they are doing.  You will usually specify a
  /// broad MIME type (such as image/* or {@literal *}/*), resulting in a
  /// broad range of content types the user can select from.
  ///
  /// When using such a broad GET_CONTENT action, it is often desirable to
  /// only pick from data that can be represented as a stream.  This is
  /// accomplished by requiring the \#CATEGORY_OPENABLE in the Intent.
  ///
  /// Callers can optionally specify \#EXTRA_LOCAL_ONLY to request that
  /// the launched content chooser only returns results representing data that
  /// is locally available on the device.  For example, if this extra is set
  /// to true then an image picker should not show any pictures that are available
  /// from a remote server but not already on the local device (thus requiring
  /// they be downloaded when opened).
  ///
  /// If the caller can handle multiple returned items (the user performing
  /// multiple selection), then it can specify \#EXTRA_ALLOW_MULTIPLE
  /// to indicate this.
  ///
  /// Input: \#getType is the desired MIME type to retrieve.  Note
  /// that no URI is supplied in the intent, as there are no constraints on
  /// where the returned data originally comes from.  You may also include the
  /// \#CATEGORY_OPENABLE if you can only accept data that can be
  /// opened as a stream.  You may use \#EXTRA_LOCAL_ONLY to limit content
  /// selection to local data.  You may use \#EXTRA_ALLOW_MULTIPLE to
  /// allow the user to select multiple items.
  ///
  /// Output: The URI of the item that was picked.  This must be a content:
  /// URI so that any receiver can access it.
  static const ACTION_GET_CONTENT = "android.intent.action.GET_CONTENT";

  /// from: static public final java.lang.String ACTION_GET_RESTRICTION_ENTRIES
  ///
  /// Broadcast to a specific application to query any supported restrictions to impose
  /// on restricted users. The broadcast intent contains an extra
  /// \#EXTRA_RESTRICTIONS_BUNDLE with the currently persisted
  /// restrictions as a Bundle of key/value pairs. The value types can be Boolean, String or
  /// String[] depending on the restriction type.<p/>
  /// The response should contain an extra \#EXTRA_RESTRICTIONS_LIST,
  /// which is of type <code>ArrayList&lt;RestrictionEntry&gt;</code>. It can also
  /// contain an extra \#EXTRA_RESTRICTIONS_INTENT, which is of type <code>Intent</code>.
  /// The activity specified by that intent will be launched for a result which must contain
  /// one of the extras \#EXTRA_RESTRICTIONS_LIST or \#EXTRA_RESTRICTIONS_BUNDLE.
  /// The keys and values of the returned restrictions will be persisted.
  ///@see RestrictionEntry
  static const ACTION_GET_RESTRICTION_ENTRIES =
      "android.intent.action.GET_RESTRICTION_ENTRIES";

  /// from: static public final java.lang.String ACTION_GTALK_SERVICE_CONNECTED
  ///
  /// Broadcast Action: A GTalk connection has been established.
  static const ACTION_GTALK_SERVICE_CONNECTED =
      "android.intent.action.GTALK_CONNECTED";

  /// from: static public final java.lang.String ACTION_GTALK_SERVICE_DISCONNECTED
  ///
  /// Broadcast Action: A GTalk connection has been disconnected.
  static const ACTION_GTALK_SERVICE_DISCONNECTED =
      "android.intent.action.GTALK_DISCONNECTED";

  /// from: static public final java.lang.String ACTION_HEADSET_PLUG
  ///
  /// Broadcast Action: Wired Headset plugged in or unplugged.
  ///
  /// Same as android.media.AudioManager\#ACTION_HEADSET_PLUG, to be consulted for value
  ///   and documentation.
  /// If the minimum SDK version of your application is
  /// android.os.Build.VERSION_CODES\#LOLLIPOP, it is recommended to refer
  /// to the <code>AudioManager</code> constant in your receiver registration code instead.
  static const ACTION_HEADSET_PLUG = "android.intent.action.HEADSET_PLUG";

  /// from: static public final java.lang.String ACTION_INPUT_METHOD_CHANGED
  ///
  /// Broadcast Action: An input method has been changed.
  static const ACTION_INPUT_METHOD_CHANGED =
      "android.intent.action.INPUT_METHOD_CHANGED";

  /// from: static public final java.lang.String ACTION_INSERT
  ///
  /// Activity Action: Insert an empty item into the given container.
  /// Input: \#getData is URI of the directory (vnd.android.cursor.dir/*)
  /// in which to place the data.
  /// Output: URI of the new data that was created.
  static const ACTION_INSERT = "android.intent.action.INSERT";

  /// from: static public final java.lang.String ACTION_INSERT_OR_EDIT
  ///
  /// Activity Action: Pick an existing item, or insert a new item, and then edit it.
  /// Input: \#getType is the desired MIME type of the item to create or edit.
  /// The extras can contain type specific data to pass through to the editing/creating
  /// activity.
  /// Output: The URI of the item that was picked.  This must be a content:
  /// URI so that any receiver can access it.
  static const ACTION_INSERT_OR_EDIT = "android.intent.action.INSERT_OR_EDIT";

  /// from: static public final java.lang.String ACTION_INSTALL_FAILURE
  ///
  /// Activity Action: Activity to handle split installation failures.
  /// Splits may be installed dynamically. This happens when an Activity is launched,
  /// but the split that contains the application isn't installed. When a split is
  /// installed in this manner, the containing package usually doesn't know this is
  /// happening. However, if an error occurs during installation, the containing
  /// package can define a single activity handling this action to deal with such
  /// failures.
  /// The activity handling this action must be in the base package.
  ///
  /// Input: \#EXTRA_INTENT the original intent that started split installation.
  /// \#EXTRA_SPLIT_NAME the name of the split that failed to be installed.
  static const ACTION_INSTALL_FAILURE = "android.intent.action.INSTALL_FAILURE";

  /// from: static public final java.lang.String ACTION_INSTALL_PACKAGE
  ///
  /// Activity Action: Launch application installer.
  ///
  /// Input: The data must be a content: URI at which the application
  /// can be retrieved.  As of android.os.Build.VERSION_CODES\#JELLY_BEAN_MR1,
  /// you can also use "package:<package-name>" to install an application for the
  /// current user that is already installed for another user. You can optionally supply
  /// \#EXTRA_INSTALLER_PACKAGE_NAME, \#EXTRA_NOT_UNKNOWN_SOURCE,
  /// \#EXTRA_ALLOW_REPLACE, and \#EXTRA_RETURN_RESULT.
  ///
  /// Output: If \#EXTRA_RETURN_RESULT, returns whether the install
  /// succeeded.
  ///
  /// <strong>Note:</strong>If your app is targeting API level higher than 25 you
  /// need to hold android.Manifest.permission\#REQUEST_INSTALL_PACKAGES
  /// in order to launch the application installer.
  ///
  ///
  ///@see \#EXTRA_INSTALLER_PACKAGE_NAME
  ///@see \#EXTRA_NOT_UNKNOWN_SOURCE
  ///@see \#EXTRA_RETURN_RESULT
  static const ACTION_INSTALL_PACKAGE = "android.intent.action.INSTALL_PACKAGE";

  /// from: static public final java.lang.String ACTION_LOCALE_CHANGED
  ///
  /// Broadcast Action: The current device's locale has changed.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_LOCALE_CHANGED = "android.intent.action.LOCALE_CHANGED";

  /// from: static public final java.lang.String ACTION_LOCKED_BOOT_COMPLETED
  ///
  /// Broadcast Action: This is broadcast once, after the user has finished
  /// booting, but while still in the "locked" state. It can be used to perform
  /// application-specific initialization, such as installing alarms. You must
  /// hold the android.Manifest.permission\#RECEIVE_BOOT_COMPLETED
  /// permission in order to receive this broadcast.
  ///
  /// This broadcast is sent immediately at boot by all devices (regardless of
  /// direct boot support) running android.os.Build.VERSION_CODES\#N or
  /// higher. Upon receipt of this broadcast, the user is still locked and only
  /// device-protected storage can be accessed safely. If you want to access
  /// credential-protected storage, you need to wait for the user to be
  /// unlocked (typically by entering their lock pattern or PIN for the first
  /// time), after which the \#ACTION_USER_UNLOCKED and
  /// \#ACTION_BOOT_COMPLETED broadcasts are sent.
  ///
  /// To receive this broadcast, your receiver component must be marked as
  /// being ComponentInfo\#directBootAware.
  /// <p class="note">
  /// This is a protected intent that can only be sent by the system.
  ///@see Context\#createDeviceProtectedStorageContext()
  static const ACTION_LOCKED_BOOT_COMPLETED =
      "android.intent.action.LOCKED_BOOT_COMPLETED";

  /// from: static public final java.lang.String ACTION_MAIN
  ///
  /// Activity Action: Start as a main entry point, does not expect to
  ///  receive data.
  ///  Input: nothing
  ///  Output: nothing
  static const ACTION_MAIN = "android.intent.action.MAIN";

  /// from: static public final java.lang.String ACTION_MANAGED_PROFILE_ADDED
  ///
  /// Broadcast sent to the primary user when an associated managed profile is added (the profile
  /// was created and is ready to be used). Carries an extra \#EXTRA_USER that specifies
  /// the UserHandle of the profile that was added. Only applications (for example Launchers)
  /// that need to display merged content across both primary and managed profiles need to
  /// worry about this broadcast. This is only sent to registered receivers,
  /// not manifest receivers.
  static const ACTION_MANAGED_PROFILE_ADDED =
      "android.intent.action.MANAGED_PROFILE_ADDED";

  /// from: static public final java.lang.String ACTION_MANAGED_PROFILE_AVAILABLE
  ///
  /// Broadcast sent to the primary user when an associated managed profile has become available.
  /// Currently this includes when the user disables quiet mode for the profile. Carries an extra
  /// \#EXTRA_USER that specifies the UserHandle of the profile. When quiet mode is changed,
  /// this broadcast will carry a boolean extra \#EXTRA_QUIET_MODE indicating the new state
  /// of quiet mode. This is only sent to registered receivers, not manifest receivers.
  static const ACTION_MANAGED_PROFILE_AVAILABLE =
      "android.intent.action.MANAGED_PROFILE_AVAILABLE";

  /// from: static public final java.lang.String ACTION_MANAGED_PROFILE_REMOVED
  ///
  /// Broadcast sent to the primary user when an associated managed profile is removed. Carries an
  /// extra \#EXTRA_USER that specifies the UserHandle of the profile that was removed.
  /// Only applications (for example Launchers) that need to display merged content across both
  /// primary and managed profiles need to worry about this broadcast. This is only sent to
  /// registered receivers, not manifest receivers.
  static const ACTION_MANAGED_PROFILE_REMOVED =
      "android.intent.action.MANAGED_PROFILE_REMOVED";

  /// from: static public final java.lang.String ACTION_MANAGED_PROFILE_UNAVAILABLE
  ///
  /// Broadcast sent to the primary user when an associated managed profile has become unavailable.
  /// Currently this includes when the user enables quiet mode for the profile. Carries an extra
  /// \#EXTRA_USER that specifies the UserHandle of the profile. When quiet mode is changed,
  /// this broadcast will carry a boolean extra \#EXTRA_QUIET_MODE indicating the new state
  /// of quiet mode. This is only sent to registered receivers, not manifest receivers.
  static const ACTION_MANAGED_PROFILE_UNAVAILABLE =
      "android.intent.action.MANAGED_PROFILE_UNAVAILABLE";

  /// from: static public final java.lang.String ACTION_MANAGED_PROFILE_UNLOCKED
  ///
  /// Broadcast sent to the primary user when the credential-encrypted private storage for
  /// an associated managed profile is unlocked. Carries an extra \#EXTRA_USER that
  /// specifies the UserHandle of the profile that was unlocked. Only applications (for example
  /// Launchers) that need to display merged content across both primary and managed profiles
  /// need to worry about this broadcast. This is only sent to registered receivers,
  /// not manifest receivers.
  static const ACTION_MANAGED_PROFILE_UNLOCKED =
      "android.intent.action.MANAGED_PROFILE_UNLOCKED";

  /// from: static public final java.lang.String ACTION_MANAGE_NETWORK_USAGE
  ///
  /// Activity Action: Show settings for managing network data usage of a
  /// specific application. Applications should define an activity that offers
  /// options to control data usage.
  static const ACTION_MANAGE_NETWORK_USAGE =
      "android.intent.action.MANAGE_NETWORK_USAGE";

  /// from: static public final java.lang.String ACTION_MANAGE_PACKAGE_STORAGE
  ///
  /// Broadcast Action:  Indicates low memory condition notification acknowledged by user
  /// and package management should be started.
  /// This is triggered by the user from the ACTION_DEVICE_STORAGE_LOW
  /// notification.
  static const ACTION_MANAGE_PACKAGE_STORAGE =
      "android.intent.action.MANAGE_PACKAGE_STORAGE";

  /// from: static public final java.lang.String ACTION_MEDIA_BAD_REMOVAL
  ///
  /// Broadcast Action:  External media was removed from SD card slot, but mount point was not unmounted.
  /// The path to the mount point for the removed media is contained in the Intent.mData field.
  static const ACTION_MEDIA_BAD_REMOVAL =
      "android.intent.action.MEDIA_BAD_REMOVAL";

  /// from: static public final java.lang.String ACTION_MEDIA_BUTTON
  ///
  /// Broadcast Action:  The "Media Button" was pressed.  Includes a single
  /// extra field, \#EXTRA_KEY_EVENT, containing the key event that
  /// caused the broadcast.
  static const ACTION_MEDIA_BUTTON = "android.intent.action.MEDIA_BUTTON";

  /// from: static public final java.lang.String ACTION_MEDIA_CHECKING
  ///
  /// Broadcast Action:  External media is present, and being disk-checked
  /// The path to the mount point for the checking media is contained in the Intent.mData field.
  static const ACTION_MEDIA_CHECKING = "android.intent.action.MEDIA_CHECKING";

  /// from: static public final java.lang.String ACTION_MEDIA_EJECT
  ///
  /// Broadcast Action:  User has expressed the desire to remove the external storage media.
  /// Applications should close all files they have open within the mount point when they receive this intent.
  /// The path to the mount point for the media to be ejected is contained in the Intent.mData field.
  static const ACTION_MEDIA_EJECT = "android.intent.action.MEDIA_EJECT";

  /// from: static public final java.lang.String ACTION_MEDIA_MOUNTED
  ///
  /// Broadcast Action:  External media is present and mounted at its mount point.
  /// The path to the mount point for the mounted media is contained in the Intent.mData field.
  /// The Intent contains an extra with name "read-only" and Boolean value to indicate if the
  /// media was mounted read only.
  static const ACTION_MEDIA_MOUNTED = "android.intent.action.MEDIA_MOUNTED";

  /// from: static public final java.lang.String ACTION_MEDIA_NOFS
  ///
  /// Broadcast Action:  External media is present, but is using an incompatible fs (or is blank)
  /// The path to the mount point for the checking media is contained in the Intent.mData field.
  static const ACTION_MEDIA_NOFS = "android.intent.action.MEDIA_NOFS";

  /// from: static public final java.lang.String ACTION_MEDIA_REMOVED
  ///
  /// Broadcast Action:  External media has been removed.
  /// The path to the mount point for the removed media is contained in the Intent.mData field.
  static const ACTION_MEDIA_REMOVED = "android.intent.action.MEDIA_REMOVED";

  /// from: static public final java.lang.String ACTION_MEDIA_SCANNER_FINISHED
  ///
  /// Broadcast Action:  The media scanner has finished scanning a directory.
  /// The path to the scanned directory is contained in the Intent.mData field.
  static const ACTION_MEDIA_SCANNER_FINISHED =
      "android.intent.action.MEDIA_SCANNER_FINISHED";

  /// from: static public final java.lang.String ACTION_MEDIA_SCANNER_SCAN_FILE
  ///
  /// Broadcast Action:  Request the media scanner to scan a file and add it to the media database.
  /// The path to the file is contained in the Intent.mData field.
  static const ACTION_MEDIA_SCANNER_SCAN_FILE =
      "android.intent.action.MEDIA_SCANNER_SCAN_FILE";

  /// from: static public final java.lang.String ACTION_MEDIA_SCANNER_STARTED
  ///
  /// Broadcast Action:  The media scanner has started scanning a directory.
  /// The path to the directory being scanned is contained in the Intent.mData field.
  static const ACTION_MEDIA_SCANNER_STARTED =
      "android.intent.action.MEDIA_SCANNER_STARTED";

  /// from: static public final java.lang.String ACTION_MEDIA_SHARED
  ///
  /// Broadcast Action:  External media is unmounted because it is being shared via USB mass storage.
  /// The path to the mount point for the shared media is contained in the Intent.mData field.
  static const ACTION_MEDIA_SHARED = "android.intent.action.MEDIA_SHARED";

  /// from: static public final java.lang.String ACTION_MEDIA_UNMOUNTABLE
  ///
  /// Broadcast Action:  External media is present but cannot be mounted.
  /// The path to the mount point for the unmountable media is contained in the Intent.mData field.
  static const ACTION_MEDIA_UNMOUNTABLE =
      "android.intent.action.MEDIA_UNMOUNTABLE";

  /// from: static public final java.lang.String ACTION_MEDIA_UNMOUNTED
  ///
  /// Broadcast Action:  External media is present, but not mounted at its mount point.
  /// The path to the mount point for the unmounted media is contained in the Intent.mData field.
  static const ACTION_MEDIA_UNMOUNTED = "android.intent.action.MEDIA_UNMOUNTED";

  /// from: static public final java.lang.String ACTION_MY_PACKAGE_REPLACED
  ///
  /// Broadcast Action: A new version of your application has been installed
  /// over an existing one.  This is only sent to the application that was
  /// replaced.  It does not contain any additional data; to receive it, just
  /// use an intent filter for this action.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_MY_PACKAGE_REPLACED =
      "android.intent.action.MY_PACKAGE_REPLACED";

  /// from: static public final java.lang.String ACTION_MY_PACKAGE_SUSPENDED
  ///
  /// Broadcast Action: Sent to a package that has been suspended by the system. This is sent
  /// whenever a package is put into a suspended state or any of its app extras change while in the
  /// suspended state.
  ///  Optionally includes the following extras:
  /// <ul>
  ///     <li> \#EXTRA_SUSPENDED_PACKAGE_EXTRAS which is a Bundle which will contain
  ///     useful information for the app being suspended.
  /// </ul>
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system. _This will be delivered to BroadcastReceiver components declared in
  /// the manifest._
  ///@see \#ACTION_MY_PACKAGE_UNSUSPENDED
  ///@see \#EXTRA_SUSPENDED_PACKAGE_EXTRAS
  ///@see PackageManager\#isPackageSuspended()
  ///@see PackageManager\#getSuspendedPackageAppExtras()
  static const ACTION_MY_PACKAGE_SUSPENDED =
      "android.intent.action.MY_PACKAGE_SUSPENDED";

  /// from: static public final java.lang.String ACTION_MY_PACKAGE_UNSUSPENDED
  ///
  /// Broadcast Action: Sent to a package that has been unsuspended.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system. _This will be delivered to BroadcastReceiver components declared in
  /// the manifest._
  ///@see \#ACTION_MY_PACKAGE_SUSPENDED
  ///@see \#EXTRA_SUSPENDED_PACKAGE_EXTRAS
  ///@see PackageManager\#isPackageSuspended()
  ///@see PackageManager\#getSuspendedPackageAppExtras()
  static const ACTION_MY_PACKAGE_UNSUSPENDED =
      "android.intent.action.MY_PACKAGE_UNSUSPENDED";

  /// from: static public final java.lang.String ACTION_NEW_OUTGOING_CALL
  ///
  /// Broadcast Action: An outgoing call is about to be placed.
  ///
  /// The Intent will have the following extra value:
  ///
  /// <ul>
  ///   <li>_android.content.Intent\#EXTRA_PHONE_NUMBER_ -
  ///       the phone number originally intended to be dialed.</li>
  /// </ul>
  /// Once the broadcast is finished, the resultData is used as the actual
  /// number to call.  If  <code>null</code>, no call will be placed.
  ///
  /// It is perfectly acceptable for multiple receivers to process the
  /// outgoing call in turn: for example, a parental control application
  /// might verify that the user is authorized to place the call at that
  /// time, then a number-rewriting application might add an area code if
  /// one was not specified.
  ///
  /// For consistency, any receiver whose purpose is to prohibit phone
  /// calls should have a priority of 0, to ensure it will see the final
  /// phone number to be dialed.
  /// Any receiver whose purpose is to rewrite phone numbers to be called
  /// should have a positive priority.
  /// Negative priorities are reserved for the system for this broadcast;
  /// using them may cause problems.
  ///
  /// Any BroadcastReceiver receiving this Intent _must not_
  /// abort the broadcast.
  ///
  /// Emergency calls cannot be intercepted using this mechanism, and
  /// other calls cannot be modified to call emergency numbers using this
  /// mechanism.
  /// Some apps (such as VoIP apps) may want to redirect the outgoing
  /// call to use their own service instead. Those apps should first prevent
  /// the call from being placed by setting resultData to <code>null</code>
  /// and then start their own app to make the call.
  /// You must hold the
  /// android.Manifest.permission\#PROCESS_OUTGOING_CALLS
  /// permission to receive this Intent.
  ///
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_NEW_OUTGOING_CALL =
      "android.intent.action.NEW_OUTGOING_CALL";

  /// from: static public final java.lang.String ACTION_OPEN_DOCUMENT
  ///
  /// Activity Action: Allow the user to select and return one or more existing
  /// documents. When invoked, the system will display the various
  /// DocumentsProvider instances installed on the device, letting the
  /// user interactively navigate through them. These documents include local
  /// media, such as photos and video, and documents provided by installed
  /// cloud storage providers.
  ///
  /// Each document is represented as a {@code content://} URI backed by a
  /// DocumentsProvider, which can be opened as a stream with
  /// ContentResolver\#openFileDescriptor(Uri, String), or queried for
  /// android.provider.DocumentsContract.Document metadata.
  ///
  /// All selected documents are returned to the calling application with
  /// persistable read and write permission grants. If you want to maintain
  /// access to the documents across device reboots, you need to explicitly
  /// take the persistable permissions using
  /// ContentResolver\#takePersistableUriPermission(Uri, int).
  ///
  /// Callers must indicate the acceptable document MIME types through
  /// \#setType(String). For example, to select photos, use
  /// {@code image/*}. If multiple disjoint MIME types are acceptable, define
  /// them in \#EXTRA_MIME_TYPES and \#setType(String) to
  /// {@literal *}/*.
  ///
  /// If the caller can handle multiple returned items (the user performing
  /// multiple selection), then you can specify \#EXTRA_ALLOW_MULTIPLE
  /// to indicate this.
  ///
  /// Callers must include \#CATEGORY_OPENABLE in the Intent to obtain
  /// URIs that can be opened with
  /// ContentResolver\#openFileDescriptor(Uri, String).
  ///
  /// Callers can set a document URI through
  /// DocumentsContract\#EXTRA_INITIAL_URI to indicate the initial
  /// location of documents navigator. System will do its best to launch the
  /// navigator in the specified document if it's a folder, or the folder that
  /// contains the specified document if not.
  ///
  /// Output: The URI of the item that was picked, returned in
  /// \#getData(). This must be a {@code content://} URI so that any
  /// receiver can access it. If multiple documents were selected, they are
  /// returned in \#getClipData().
  ///@see DocumentsContract
  ///@see \#ACTION_OPEN_DOCUMENT_TREE
  ///@see \#ACTION_CREATE_DOCUMENT
  ///@see \#FLAG_GRANT_PERSISTABLE_URI_PERMISSION
  static const ACTION_OPEN_DOCUMENT = "android.intent.action.OPEN_DOCUMENT";

  /// from: static public final java.lang.String ACTION_OPEN_DOCUMENT_TREE
  ///
  /// Activity Action: Allow the user to pick a directory subtree. When
  /// invoked, the system will display the various DocumentsProvider
  /// instances installed on the device, letting the user navigate through
  /// them. Apps can fully manage documents within the returned directory.
  ///
  /// To gain access to descendant (child, grandchild, etc) documents, use
  /// DocumentsContract\#buildDocumentUriUsingTree(Uri, String) and
  /// DocumentsContract\#buildChildDocumentsUriUsingTree(Uri, String)
  /// with the returned URI.
  ///
  /// Callers can set a document URI through
  /// DocumentsContract\#EXTRA_INITIAL_URI to indicate the initial
  /// location of documents navigator. System will do its best to launch the
  /// navigator in the specified document if it's a folder, or the folder that
  /// contains the specified document if not.
  ///
  /// Output: The URI representing the selected directory tree.
  ///@see DocumentsContract
  static const ACTION_OPEN_DOCUMENT_TREE =
      "android.intent.action.OPEN_DOCUMENT_TREE";

  /// from: static public final java.lang.String ACTION_PACKAGES_SUSPENDED
  ///
  /// Broadcast Action: Packages have been suspended.
  /// Includes the following extras:
  /// <ul>
  /// <li> \#EXTRA_CHANGED_PACKAGE_LIST is the set of packages which have been suspended
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system. It is only sent to registered receivers.
  static const ACTION_PACKAGES_SUSPENDED =
      "android.intent.action.PACKAGES_SUSPENDED";

  /// from: static public final java.lang.String ACTION_PACKAGES_UNSUSPENDED
  ///
  /// Broadcast Action: Packages have been unsuspended.
  /// Includes the following extras:
  /// <ul>
  /// <li> \#EXTRA_CHANGED_PACKAGE_LIST is the set of packages which have been unsuspended
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system. It is only sent to registered receivers.
  static const ACTION_PACKAGES_UNSUSPENDED =
      "android.intent.action.PACKAGES_UNSUSPENDED";

  /// from: static public final java.lang.String ACTION_PACKAGE_ADDED
  ///
  /// Broadcast Action: A new application package has been installed on the
  /// device. The data contains the name of the package.  Note that the
  /// newly installed package does _not_ receive this broadcast.
  /// May include the following extras:
  /// <ul>
  /// <li> \#EXTRA_UID containing the integer uid assigned to the new package.
  /// <li> \#EXTRA_REPLACING is set to true if this is following
  /// an \#ACTION_PACKAGE_REMOVED broadcast for the same package.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_PACKAGE_ADDED = "android.intent.action.PACKAGE_ADDED";

  /// from: static public final java.lang.String ACTION_PACKAGE_CHANGED
  ///
  /// Broadcast Action: An existing application package has been changed (for
  /// example, a component has been enabled or disabled).  The data contains
  /// the name of the package.
  /// <ul>
  /// <li> \#EXTRA_UID containing the integer uid assigned to the package.
  /// <li> \#EXTRA_CHANGED_COMPONENT_NAME_LIST containing the class name
  /// of the changed components (or the package name itself).
  /// <li> \#EXTRA_DONT_KILL_APP containing boolean field to override the
  /// default action of restarting the application.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_PACKAGE_CHANGED = "android.intent.action.PACKAGE_CHANGED";

  /// from: static public final java.lang.String ACTION_PACKAGE_DATA_CLEARED
  ///
  /// Broadcast Action: The user has cleared the data of a package.  This should
  /// be preceded by \#ACTION_PACKAGE_RESTARTED, after which all of
  /// its persistent data is erased and this broadcast sent.
  /// Note that the cleared package does _not_
  /// receive this broadcast. The data contains the name of the package.
  /// <ul>
  /// <li> \#EXTRA_UID containing the integer uid assigned to the package. If the
  ///      package whose data was cleared is an uninstalled instant app, then the UID
  ///      will be -1. The platform keeps some meta-data associated with instant apps
  ///      after they are uninstalled.
  /// <li> \#EXTRA_PACKAGE_NAME containing the package name only if the cleared
  ///      data was for an instant app.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_PACKAGE_DATA_CLEARED =
      "android.intent.action.PACKAGE_DATA_CLEARED";

  /// from: static public final java.lang.String ACTION_PACKAGE_FIRST_LAUNCH
  ///
  /// Broadcast Action: Sent to the installer package of an application when
  /// that application is first launched (that is the first time it is moved
  /// out of the stopped state).  The data contains the name of the package.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_PACKAGE_FIRST_LAUNCH =
      "android.intent.action.PACKAGE_FIRST_LAUNCH";

  /// from: static public final java.lang.String ACTION_PACKAGE_FULLY_REMOVED
  ///
  /// Broadcast Action: An existing application package has been completely
  /// removed from the device.  The data contains the name of the package.
  /// This is like \#ACTION_PACKAGE_REMOVED, but only set when
  /// \#EXTRA_DATA_REMOVED is true and
  /// \#EXTRA_REPLACING is false of that broadcast.
  ///
  /// <ul>
  /// <li> \#EXTRA_UID containing the integer uid previously assigned
  /// to the package.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_PACKAGE_FULLY_REMOVED =
      "android.intent.action.PACKAGE_FULLY_REMOVED";

  /// from: static public final java.lang.String ACTION_PACKAGE_INSTALL
  ///
  /// Broadcast Action: Trigger the download and eventual installation
  /// of a package.
  /// Input: \#getData is the URI of the package file to download.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  ///@deprecated This constant has never been used.
  static const ACTION_PACKAGE_INSTALL = "android.intent.action.PACKAGE_INSTALL";

  /// from: static public final java.lang.String ACTION_PACKAGE_NEEDS_VERIFICATION
  ///
  /// Broadcast Action: Sent to the system package verifier when a package
  /// needs to be verified. The data contains the package URI.
  /// <p class="note">
  /// This is a protected intent that can only be sent by the system.
  ///
  ///
  static const ACTION_PACKAGE_NEEDS_VERIFICATION =
      "android.intent.action.PACKAGE_NEEDS_VERIFICATION";

  /// from: static public final java.lang.String ACTION_PACKAGE_REMOVED
  ///
  /// Broadcast Action: An existing application package has been removed from
  /// the device.  The data contains the name of the package.  The package
  /// that is being removed does _not_ receive this Intent.
  /// <ul>
  /// <li> \#EXTRA_UID containing the integer uid previously assigned
  /// to the package.
  /// <li> \#EXTRA_DATA_REMOVED is set to true if the entire
  /// application -- data and code -- is being removed.
  /// <li> \#EXTRA_REPLACING is set to true if this will be followed
  /// by an \#ACTION_PACKAGE_ADDED broadcast for the same package.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_PACKAGE_REMOVED = "android.intent.action.PACKAGE_REMOVED";

  /// from: static public final java.lang.String ACTION_PACKAGE_REPLACED
  ///
  /// Broadcast Action: A new version of an application package has been
  /// installed, replacing an existing version that was previously installed.
  /// The data contains the name of the package.
  /// May include the following extras:
  /// <ul>
  /// <li> \#EXTRA_UID containing the integer uid assigned to the new package.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_PACKAGE_REPLACED =
      "android.intent.action.PACKAGE_REPLACED";

  /// from: static public final java.lang.String ACTION_PACKAGE_RESTARTED
  ///
  /// Broadcast Action: The user has restarted a package, and all of its
  /// processes have been killed.  All runtime state
  /// associated with it (processes, alarms, notifications, etc) should
  /// be removed.  Note that the restarted package does _not_
  /// receive this broadcast.
  /// The data contains the name of the package.
  /// <ul>
  /// <li> \#EXTRA_UID containing the integer uid assigned to the package.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_PACKAGE_RESTARTED =
      "android.intent.action.PACKAGE_RESTARTED";

  /// from: static public final java.lang.String ACTION_PACKAGE_VERIFIED
  ///
  /// Broadcast Action: Sent to the system package verifier when a package is
  /// verified. The data contains the package URI.
  /// <p class="note">
  /// This is a protected intent that can only be sent by the system.
  static const ACTION_PACKAGE_VERIFIED =
      "android.intent.action.PACKAGE_VERIFIED";

  /// from: static public final java.lang.String ACTION_PASTE
  ///
  /// Activity Action: Create a new item in the given container, initializing it
  /// from the current contents of the clipboard.
  /// Input: \#getData is URI of the directory (vnd.android.cursor.dir/*)
  /// in which to place the data.
  /// Output: URI of the new data that was created.
  static const ACTION_PASTE = "android.intent.action.PASTE";

  /// from: static public final java.lang.String ACTION_PICK
  ///
  /// Activity Action: Pick an item from the data, returning what was selected.
  /// Input: \#getData is URI containing a directory of data
  /// (vnd.android.cursor.dir/*) from which to pick an item.
  /// Output: The URI of the item that was picked.
  static const ACTION_PICK = "android.intent.action.PICK";

  /// from: static public final java.lang.String ACTION_PICK_ACTIVITY
  ///
  /// Activity Action: Pick an activity given an intent, returning the class
  /// selected.
  /// Input: get*Extra field \#EXTRA_INTENT is an Intent
  /// used with PackageManager\#queryIntentActivities to determine the
  /// set of activities from which to pick.
  /// Output: Class name of the activity that was selected.
  static const ACTION_PICK_ACTIVITY = "android.intent.action.PICK_ACTIVITY";

  /// from: static public final java.lang.String ACTION_POWER_CONNECTED
  ///
  /// Broadcast Action:  External power has been connected to the device.
  /// This is intended for applications that wish to register specifically to this notification.
  /// Unlike ACTION_BATTERY_CHANGED, applications will be woken for this and so do not have to
  /// stay active to receive this notification.  This action can be used to implement actions
  /// that wait until power is available to trigger.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_POWER_CONNECTED =
      "android.intent.action.ACTION_POWER_CONNECTED";

  /// from: static public final java.lang.String ACTION_POWER_DISCONNECTED
  ///
  /// Broadcast Action:  External power has been removed from the device.
  /// This is intended for applications that wish to register specifically to this notification.
  /// Unlike ACTION_BATTERY_CHANGED, applications will be woken for this and so do not have to
  /// stay active to receive this notification.  This action can be used to implement actions
  /// that wait until power is available to trigger.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_POWER_DISCONNECTED =
      "android.intent.action.ACTION_POWER_DISCONNECTED";

  /// from: static public final java.lang.String ACTION_POWER_USAGE_SUMMARY
  ///
  /// Activity Action: Show power usage information to the user.
  /// Input: Nothing.
  /// Output: Nothing.
  static const ACTION_POWER_USAGE_SUMMARY =
      "android.intent.action.POWER_USAGE_SUMMARY";

  /// from: static public final java.lang.String ACTION_PROCESS_TEXT
  ///
  /// Activity Action: Process a piece of text.
  /// Input: \#EXTRA_PROCESS_TEXT contains the text to be processed.
  /// \#EXTRA_PROCESS_TEXT_READONLY states if the resulting text will be read-only.
  ///
  /// Output: \#EXTRA_PROCESS_TEXT contains the processed text.
  ///
  static const ACTION_PROCESS_TEXT = "android.intent.action.PROCESS_TEXT";

  /// from: static public final java.lang.String ACTION_PROVIDER_CHANGED
  ///
  /// Broadcast Action: Some content providers have parts of their namespace
  /// where they publish new events or items that the user may be especially
  /// interested in. For these things, they may broadcast this action when the
  /// set of interesting items change.
  ///
  /// For example, GmailProvider sends this notification when the set of unread
  /// mail in the inbox changes.
  ///
  /// The data of the intent identifies which part of which provider
  /// changed. When queried through the content resolver, the data URI will
  /// return the data set in question.
  ///
  /// The intent will have the following extra values:
  /// <ul>
  ///   <li>_count_ - The number of items in the data set. This is the
  ///       same as the number of items in the cursor returned by querying the
  ///       data URI. </li>
  /// </ul>
  ///
  /// This intent will be sent at boot (if the count is non-zero) and when the
  /// data set changes. It is possible for the data set to change without the
  /// count changing (for example, if a new unread message arrives in the same
  /// sync operation in which a message is archived). The phone should still
  /// ring/vibrate/etc as normal in this case.
  static const ACTION_PROVIDER_CHANGED =
      "android.intent.action.PROVIDER_CHANGED";

  /// from: static public final java.lang.String ACTION_QUICK_CLOCK
  ///
  /// Sent when the user taps on the clock widget in the system's "quick settings" area.
  static const ACTION_QUICK_CLOCK = "android.intent.action.QUICK_CLOCK";

  /// from: static public final java.lang.String ACTION_QUICK_VIEW
  ///
  /// Activity Action: Quick view the data. Launches a quick viewer for
  /// a URI or a list of URIs.
  /// Activities handling this intent action should handle the vast majority of
  /// MIME types rather than only specific ones.
  /// Quick viewers must render the quick view image locally, and must not send
  /// file content outside current device.
  /// Input: \#getData is a mandatory content URI of the item to
  /// preview. \#getClipData contains an optional list of content URIs
  /// if there is more than one item to preview. \#EXTRA_INDEX is an
  /// optional index of the URI in the clip data to show first.
  /// \#EXTRA_QUICK_VIEW_FEATURES is an optional extra indicating the features
  /// that can be shown in the quick view UI.
  /// Output: nothing.
  ///@see \#EXTRA_INDEX
  ///@see \#EXTRA_QUICK_VIEW_FEATURES
  static const ACTION_QUICK_VIEW = "android.intent.action.QUICK_VIEW";

  /// from: static public final java.lang.String ACTION_REBOOT
  ///
  /// Broadcast Action: Have the device reboot.  This is only for use by
  /// system code.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_REBOOT = "android.intent.action.REBOOT";

  /// from: static public final java.lang.String ACTION_RUN
  ///
  /// Activity Action: Run the data, whatever that means.
  /// Input: ?  (Note: this is currently specific to the test harness.)
  /// Output: nothing.
  static const ACTION_RUN = "android.intent.action.RUN";

  /// from: static public final java.lang.String ACTION_SCREEN_OFF
  ///
  /// Broadcast Action: Sent when the device goes to sleep and becomes non-interactive.
  ///
  /// For historical reasons, the name of this broadcast action refers to the power
  /// state of the screen but it is actually sent in response to changes in the
  /// overall interactive state of the device.
  ///
  ///
  /// This broadcast is sent when the device becomes non-interactive which may have
  /// nothing to do with the screen turning off.  To determine the
  /// actual state of the screen, use android.view.Display\#getState.
  ///
  ///
  /// See android.os.PowerManager\#isInteractive for details.
  ///
  ///
  /// You _cannot_ receive this through components declared in
  /// manifests, only by explicitly registering for it with
  /// Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver().
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_SCREEN_OFF = "android.intent.action.SCREEN_OFF";

  /// from: static public final java.lang.String ACTION_SCREEN_ON
  ///
  /// Broadcast Action: Sent when the device wakes up and becomes interactive.
  ///
  /// For historical reasons, the name of this broadcast action refers to the power
  /// state of the screen but it is actually sent in response to changes in the
  /// overall interactive state of the device.
  ///
  ///
  /// This broadcast is sent when the device becomes interactive which may have
  /// nothing to do with the screen turning on.  To determine the
  /// actual state of the screen, use android.view.Display\#getState.
  ///
  ///
  /// See android.os.PowerManager\#isInteractive for details.
  ///
  ///
  /// You _cannot_ receive this through components declared in
  /// manifests, only by explicitly registering for it with
  /// Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver().
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_SCREEN_ON = "android.intent.action.SCREEN_ON";

  /// from: static public final java.lang.String ACTION_SEARCH
  ///
  /// Activity Action: Perform a search.
  /// Input: android.app.SearchManager\#QUERY getStringExtra(SearchManager.QUERY)
  /// is the text to search for.  If empty, simply
  /// enter your search results Activity with the search UI activated.
  /// Output: nothing.
  static const ACTION_SEARCH = "android.intent.action.SEARCH";

  /// from: static public final java.lang.String ACTION_SEARCH_LONG_PRESS
  ///
  /// Activity Action: Start action associated with long pressing on the
  /// search key.
  /// Input: Nothing.
  /// Output: Nothing.
  static const ACTION_SEARCH_LONG_PRESS =
      "android.intent.action.SEARCH_LONG_PRESS";

  /// from: static public final java.lang.String ACTION_SEND
  ///
  /// Activity Action: Deliver some data to someone else.  Who the data is
  /// being delivered to is not specified; it is up to the receiver of this
  /// action to ask the user where the data should be sent.
  ///
  /// When launching a SEND intent, you should usually wrap it in a chooser
  /// (through \#createChooser), which will give the proper interface
  /// for the user to pick how to send your data and allow you to specify
  /// a prompt indicating what they are doing.
  ///
  /// Input: \#getType is the MIME type of the data being sent.
  /// get*Extra can have either a \#EXTRA_TEXT
  /// or \#EXTRA_STREAM field, containing the data to be sent.  If
  /// using EXTRA_TEXT, the MIME type should be "text/plain"; otherwise it
  /// should be the MIME type of the data in EXTRA_STREAM.  Use {@literal *}/*
  /// if the MIME type is unknown (this will only allow senders that can
  /// handle generic data streams).  If using \#EXTRA_TEXT, you can
  /// also optionally supply \#EXTRA_HTML_TEXT for clients to retrieve
  /// your text with HTML formatting.
  ///
  /// As of android.os.Build.VERSION_CODES\#JELLY_BEAN, the data
  /// being sent can be supplied through \#setClipData(ClipData).  This
  /// allows you to use \#FLAG_GRANT_READ_URI_PERMISSION when sharing
  /// content: URIs and other advanced features of ClipData.  If
  /// using this approach, you still must supply the same data through the
  /// \#EXTRA_TEXT or \#EXTRA_STREAM fields described below
  /// for compatibility with old applications.  If you don't set a ClipData,
  /// it will be copied there for you when calling Context\#startActivity(Intent).
  ///
  /// Starting from android.os.Build.VERSION_CODES\#O, if
  /// \#CATEGORY_TYPED_OPENABLE is passed, then the Uris passed in
  /// either \#EXTRA_STREAM or via \#setClipData(ClipData) may
  /// be openable only as asset typed files using
  /// ContentResolver\#openTypedAssetFileDescriptor(Uri, String, Bundle).
  ///
  /// Optional standard extras, which may be interpreted by some recipients as
  /// appropriate, are: \#EXTRA_EMAIL, \#EXTRA_CC,
  /// \#EXTRA_BCC, \#EXTRA_SUBJECT.
  ///
  /// Output: nothing.
  static const ACTION_SEND = "android.intent.action.SEND";

  /// from: static public final java.lang.String ACTION_SENDTO
  ///
  /// Activity Action: Send a message to someone specified by the data.
  /// Input: \#getData is URI describing the target.
  /// Output: nothing.
  static const ACTION_SENDTO = "android.intent.action.SENDTO";

  /// from: static public final java.lang.String ACTION_SEND_MULTIPLE
  ///
  /// Activity Action: Deliver multiple data to someone else.
  ///
  /// Like \#ACTION_SEND, except the data is multiple.
  ///
  /// Input: \#getType is the MIME type of the data being sent.
  /// get*ArrayListExtra can have either a \#EXTRA_TEXT or \#EXTRA_STREAM field, containing the data to be sent.  If using
  /// \#EXTRA_TEXT, you can also optionally supply \#EXTRA_HTML_TEXT
  /// for clients to retrieve your text with HTML formatting.
  ///
  /// Multiple types are supported, and receivers should handle mixed types
  /// whenever possible. The right way for the receiver to check them is to
  /// use the content resolver on each URI. The intent sender should try to
  /// put the most concrete mime type in the intent type, but it can fall
  /// back to {@literal <type>/*} or {@literal *}/* as needed.
  ///
  /// e.g. if you are sending image/jpg and image/jpg, the intent's type can
  /// be image/jpg, but if you are sending image/jpg and image/png, then the
  /// intent's type should be image/*.
  ///
  /// As of android.os.Build.VERSION_CODES\#JELLY_BEAN, the data
  /// being sent can be supplied through \#setClipData(ClipData).  This
  /// allows you to use \#FLAG_GRANT_READ_URI_PERMISSION when sharing
  /// content: URIs and other advanced features of ClipData.  If
  /// using this approach, you still must supply the same data through the
  /// \#EXTRA_TEXT or \#EXTRA_STREAM fields described below
  /// for compatibility with old applications.  If you don't set a ClipData,
  /// it will be copied there for you when calling Context\#startActivity(Intent).
  ///
  /// Starting from android.os.Build.VERSION_CODES\#O, if
  /// \#CATEGORY_TYPED_OPENABLE is passed, then the Uris passed in
  /// either \#EXTRA_STREAM or via \#setClipData(ClipData) may
  /// be openable only as asset typed files using
  /// ContentResolver\#openTypedAssetFileDescriptor(Uri, String, Bundle).
  ///
  /// Optional standard extras, which may be interpreted by some recipients as
  /// appropriate, are: \#EXTRA_EMAIL, \#EXTRA_CC,
  /// \#EXTRA_BCC, \#EXTRA_SUBJECT.
  ///
  /// Output: nothing.
  static const ACTION_SEND_MULTIPLE = "android.intent.action.SEND_MULTIPLE";

  /// from: static public final java.lang.String ACTION_SET_WALLPAPER
  ///
  /// Activity Action: Show settings for choosing wallpaper.
  /// Input: Nothing.
  /// Output: Nothing.
  static const ACTION_SET_WALLPAPER = "android.intent.action.SET_WALLPAPER";

  /// from: static public final java.lang.String ACTION_SHOW_APP_INFO
  ///
  /// Activity Action: Launch an activity showing the app information.
  /// For applications which install other applications (such as app stores), it is recommended
  /// to handle this action for providing the app information to the user.
  ///
  /// Input: \#EXTRA_PACKAGE_NAME specifies the package whose information needs
  /// to be displayed.
  /// Output: Nothing.
  static const ACTION_SHOW_APP_INFO = "android.intent.action.SHOW_APP_INFO";

  /// from: static public final java.lang.String ACTION_SHUTDOWN
  ///
  /// Broadcast Action:  Device is shutting down.
  /// This is broadcast when the device is being shut down (completely turned
  /// off, not sleeping).  Once the broadcast is complete, the final shutdown
  /// will proceed and all unsaved data lost.  Apps will not normally need
  /// to handle this, since the foreground activity will be paused as well.
  /// As of Build.VERSION_CODES\#P this broadcast is only sent to receivers registered
  /// through Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  /// May include the following extras:
  /// <ul>
  /// <li> \#EXTRA_SHUTDOWN_USERSPACE_ONLY a boolean that is set to true if this
  /// shutdown is only for userspace processes.  If not set, assumed to be false.
  /// </ul>
  static const ACTION_SHUTDOWN = "android.intent.action.ACTION_SHUTDOWN";

  /// from: static public final java.lang.String ACTION_SYNC
  ///
  /// Activity Action: Perform a data synchronization.
  /// Input: ?
  /// Output: ?
  static const ACTION_SYNC = "android.intent.action.SYNC";

  /// from: static public final java.lang.String ACTION_SYSTEM_TUTORIAL
  ///
  /// Activity Action: Start the platform-defined tutorial
  /// Input: android.app.SearchManager\#QUERY getStringExtra(SearchManager.QUERY)
  /// is the text to search for.  If empty, simply
  /// enter your search results Activity with the search UI activated.
  /// Output: nothing.
  static const ACTION_SYSTEM_TUTORIAL = "android.intent.action.SYSTEM_TUTORIAL";

  /// from: static public final java.lang.String ACTION_TIMEZONE_CHANGED
  ///
  /// Broadcast Action: The timezone has changed. The intent will have the following extra values:
  ///
  /// <ul>
  ///   <li>_time-zone_ - The java.util.TimeZone.getID() value identifying the new time zone.</li>
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_TIMEZONE_CHANGED =
      "android.intent.action.TIMEZONE_CHANGED";

  /// from: static public final java.lang.String ACTION_TIME_CHANGED
  ///
  /// Broadcast Action: The time was set.
  static const ACTION_TIME_CHANGED = "android.intent.action.TIME_SET";

  /// from: static public final java.lang.String ACTION_TIME_TICK
  ///
  /// Broadcast Action: The current time has changed.  Sent every
  /// minute.  You _cannot_ receive this through components declared
  /// in manifests, only by explicitly registering for it with
  /// Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver().
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_TIME_TICK = "android.intent.action.TIME_TICK";

  /// from: static public final java.lang.String ACTION_UID_REMOVED
  ///
  /// Broadcast Action: A user ID has been removed from the system.  The user
  /// ID number is stored in the extra data under \#EXTRA_UID.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_UID_REMOVED = "android.intent.action.UID_REMOVED";

  /// from: static public final java.lang.String ACTION_UMS_CONNECTED
  ///
  /// Broadcast Action:  The device has entered USB Mass Storage mode.
  /// This is used mainly for the USB Settings panel.
  /// Apps should listen for ACTION_MEDIA_MOUNTED and ACTION_MEDIA_UNMOUNTED broadcasts to be notified
  /// when the SD card file system is mounted or unmounted
  ///@deprecated replaced by android.os.storage.StorageEventListener
  static const ACTION_UMS_CONNECTED = "android.intent.action.UMS_CONNECTED";

  /// from: static public final java.lang.String ACTION_UMS_DISCONNECTED
  ///
  /// Broadcast Action:  The device has exited USB Mass Storage mode.
  /// This is used mainly for the USB Settings panel.
  /// Apps should listen for ACTION_MEDIA_MOUNTED and ACTION_MEDIA_UNMOUNTED broadcasts to be notified
  /// when the SD card file system is mounted or unmounted
  ///@deprecated replaced by android.os.storage.StorageEventListener
  static const ACTION_UMS_DISCONNECTED =
      "android.intent.action.UMS_DISCONNECTED";

  /// from: static public final java.lang.String ACTION_UNINSTALL_PACKAGE
  ///
  /// Activity Action: Launch application uninstaller.
  ///
  /// Input: The data must be a package: URI whose scheme specific part is
  /// the package name of the current installed package to be uninstalled.
  /// You can optionally supply \#EXTRA_RETURN_RESULT.
  ///
  /// Output: If \#EXTRA_RETURN_RESULT, returns whether the install
  /// succeeded.
  ///
  /// Requires android.Manifest.permission\#REQUEST_DELETE_PACKAGES
  /// since Build.VERSION_CODES\#P.
  static const ACTION_UNINSTALL_PACKAGE =
      "android.intent.action.UNINSTALL_PACKAGE";

  /// from: static public final java.lang.String ACTION_USER_BACKGROUND
  ///
  /// Sent when a user switch is happening, causing the process's user to be
  /// sent to the background.  This is only sent to receivers registered
  /// through Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver.  It is sent to the user that is going to the
  /// background.  This is sent as a foreground
  /// broadcast, since it is part of a visible user interaction; be as quick
  /// as possible when handling it.
  static const ACTION_USER_BACKGROUND = "android.intent.action.USER_BACKGROUND";

  /// from: static public final java.lang.String ACTION_USER_FOREGROUND
  ///
  /// Sent when a user switch is happening, causing the process's user to be
  /// brought to the foreground.  This is only sent to receivers registered
  /// through Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver.  It is sent to the user that is going to the
  /// foreground.  This is sent as a foreground
  /// broadcast, since it is part of a visible user interaction; be as quick
  /// as possible when handling it.
  static const ACTION_USER_FOREGROUND = "android.intent.action.USER_FOREGROUND";

  /// from: static public final java.lang.String ACTION_USER_INITIALIZE
  ///
  /// Sent the first time a user is starting, to allow system apps to
  /// perform one time initialization.  (This will not be seen by third
  /// party applications because a newly initialized user does not have any
  /// third party applications installed for it.)  This is sent early in
  /// starting the user, around the time the home app is started, before
  /// \#ACTION_BOOT_COMPLETED is sent.  This is sent as a foreground
  /// broadcast, since it is part of a visible user interaction; be as quick
  /// as possible when handling it.
  static const ACTION_USER_INITIALIZE = "android.intent.action.USER_INITIALIZE";

  /// from: static public final java.lang.String ACTION_USER_PRESENT
  ///
  /// Broadcast Action: Sent when the user is present after device wakes up (e.g when the
  /// keyguard is gone).
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_USER_PRESENT = "android.intent.action.USER_PRESENT";

  /// from: static public final java.lang.String ACTION_USER_UNLOCKED
  ///
  /// Broadcast Action: Sent when the credential-encrypted private storage has
  /// become unlocked for the target user. This is only sent to registered
  /// receivers, not manifest receivers.
  static const ACTION_USER_UNLOCKED = "android.intent.action.USER_UNLOCKED";

  /// from: static public final java.lang.String ACTION_VIEW
  ///
  /// Activity Action: Display the data to the user.  This is the most common
  /// action performed on data -- it is the generic action you can use on
  /// a piece of data to get the most reasonable thing to occur.  For example,
  /// when used on a contacts entry it will view the entry; when used on a
  /// mailto: URI it will bring up a compose window filled with the information
  /// supplied by the URI; when used with a tel: URI it will invoke the
  /// dialer.
  /// Input: \#getData is URI from which to retrieve data.
  /// Output: nothing.
  static const ACTION_VIEW = "android.intent.action.VIEW";

  /// from: static public final java.lang.String ACTION_VOICE_COMMAND
  ///
  /// Activity Action: Start Voice Command.
  /// Input: Nothing.
  /// Output: Nothing.
  /// <p class="note">
  /// In some cases, a matching Activity may not exist, so ensure you
  /// safeguard against this.
  static const ACTION_VOICE_COMMAND = "android.intent.action.VOICE_COMMAND";

  /// from: static public final java.lang.String ACTION_WALLPAPER_CHANGED
  ///
  /// Broadcast Action:  The current system wallpaper has changed.  See
  /// android.app.WallpaperManager for retrieving the new wallpaper.
  /// This should _only_ be used to determine when the wallpaper
  /// has changed to show the new wallpaper to the user.  You should certainly
  /// never, in response to this, change the wallpaper or other attributes of
  /// it such as the suggested size.  That would be crazy, right?  You'd cause
  /// all kinds of loops, especially if other apps are doing similar things,
  /// right?  Of course.  So please don't do this.
  ///@deprecated Modern applications should use
  /// android.view.WindowManager.LayoutParams\#FLAG_SHOW_WALLPAPER WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER to have the wallpaper
  /// shown behind their UI, rather than watching for this broadcast and
  /// rendering the wallpaper on their own.
  static const ACTION_WALLPAPER_CHANGED =
      "android.intent.action.WALLPAPER_CHANGED";

  /// from: static public final java.lang.String ACTION_WEB_SEARCH
  ///
  /// Activity Action: Perform a web search.
  ///
  /// Input: android.app.SearchManager\#QUERY getStringExtra(SearchManager.QUERY) is the text to search for. If it is
  /// a url starts with http or https, the site will be opened. If it is plain
  /// text, Google search will be applied.
  ///
  /// Output: nothing.
  static const ACTION_WEB_SEARCH = "android.intent.action.WEB_SEARCH";

  /// from: static public final java.lang.String CATEGORY_ALTERNATIVE
  ///
  /// Set if the activity should be considered as an alternative action to
  /// the data the user is currently viewing.  See also
  /// \#CATEGORY_SELECTED_ALTERNATIVE for an alternative action that
  /// applies to the selection in a list of items.
  ///
  /// Supporting this category means that you would like your activity to be
  /// displayed in the set of alternative things the user can do, usually as
  /// part of the current activity's options menu.  You will usually want to
  /// include a specific label in the &lt;intent-filter&gt; of this action
  /// describing to the user what it does.
  ///
  /// The action of IntentFilter with this category is important in that it
  /// describes the specific action the target will perform.  This generally
  /// should not be a generic action (such as \#ACTION_VIEW, but rather
  /// a specific name such as "com.android.camera.action.CROP.  Only one
  /// alternative of any particular action will be shown to the user, so using
  /// a specific action like this makes sure that your alternative will be
  /// displayed while also allowing other applications to provide their own
  /// overrides of that particular action.
  static const CATEGORY_ALTERNATIVE = "android.intent.category.ALTERNATIVE";

  /// from: static public final java.lang.String CATEGORY_APP_BROWSER
  ///
  /// Used with \#ACTION_MAIN to launch the browser application.
  /// The activity should be able to browse the Internet.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_BROWSER = "android.intent.category.APP_BROWSER";

  /// from: static public final java.lang.String CATEGORY_APP_CALCULATOR
  ///
  /// Used with \#ACTION_MAIN to launch the calculator application.
  /// The activity should be able to perform standard arithmetic operations.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_CALCULATOR =
      "android.intent.category.APP_CALCULATOR";

  /// from: static public final java.lang.String CATEGORY_APP_CALENDAR
  ///
  /// Used with \#ACTION_MAIN to launch the calendar application.
  /// The activity should be able to view and manipulate calendar entries.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_CALENDAR = "android.intent.category.APP_CALENDAR";

  /// from: static public final java.lang.String CATEGORY_APP_CONTACTS
  ///
  /// Used with \#ACTION_MAIN to launch the contacts application.
  /// The activity should be able to view and manipulate address book entries.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_CONTACTS = "android.intent.category.APP_CONTACTS";

  /// from: static public final java.lang.String CATEGORY_APP_EMAIL
  ///
  /// Used with \#ACTION_MAIN to launch the email application.
  /// The activity should be able to send and receive email.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_EMAIL = "android.intent.category.APP_EMAIL";

  /// from: static public final java.lang.String CATEGORY_APP_GALLERY
  ///
  /// Used with \#ACTION_MAIN to launch the gallery application.
  /// The activity should be able to view and manipulate image and video files
  /// stored on the device.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_GALLERY = "android.intent.category.APP_GALLERY";

  /// from: static public final java.lang.String CATEGORY_APP_MAPS
  ///
  /// Used with \#ACTION_MAIN to launch the maps application.
  /// The activity should be able to show the user's current location and surroundings.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_MAPS = "android.intent.category.APP_MAPS";

  /// from: static public final java.lang.String CATEGORY_APP_MARKET
  ///
  /// This activity allows the user to browse and download new applications.
  static const CATEGORY_APP_MARKET = "android.intent.category.APP_MARKET";

  /// from: static public final java.lang.String CATEGORY_APP_MESSAGING
  ///
  /// Used with \#ACTION_MAIN to launch the messaging application.
  /// The activity should be able to send and receive text messages.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_MESSAGING = "android.intent.category.APP_MESSAGING";

  /// from: static public final java.lang.String CATEGORY_APP_MUSIC
  ///
  /// Used with \#ACTION_MAIN to launch the music application.
  /// The activity should be able to play, browse, or manipulate music files
  /// stored on the device.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_MUSIC = "android.intent.category.APP_MUSIC";

  /// from: static public final java.lang.String CATEGORY_BROWSABLE
  ///
  /// Activities that can be safely invoked from a browser must support this
  /// category.  For example, if the user is viewing a web page or an e-mail
  /// and clicks on a link in the text, the Intent generated execute that
  /// link will require the BROWSABLE category, so that only activities
  /// supporting this category will be considered as possible actions.  By
  /// supporting this category, you are promising that there is nothing
  /// damaging (without user intervention) that can happen by invoking any
  /// matching Intent.
  static const CATEGORY_BROWSABLE = "android.intent.category.BROWSABLE";

  /// from: static public final java.lang.String CATEGORY_CAR_DOCK
  ///
  /// An activity to run when device is inserted into a car dock.
  /// Used with \#ACTION_MAIN to launch an activity.  For more
  /// information, see android.app.UiModeManager.
  static const CATEGORY_CAR_DOCK = "android.intent.category.CAR_DOCK";

  /// from: static public final java.lang.String CATEGORY_CAR_MODE
  ///
  /// Used to indicate that the activity can be used in a car environment.
  static const CATEGORY_CAR_MODE = "android.intent.category.CAR_MODE";

  /// from: static public final java.lang.String CATEGORY_DEFAULT
  ///
  /// Set if the activity should be an option for the default action
  /// (center press) to perform on a piece of data.  Setting this will
  /// hide from the user any activities without it set when performing an
  /// action on some data.  Note that this is normally -not- set in the
  /// Intent when initiating an action -- it is for use in intent filters
  /// specified in packages.
  static const CATEGORY_DEFAULT = "android.intent.category.DEFAULT";

  /// from: static public final java.lang.String CATEGORY_DESK_DOCK
  ///
  /// An activity to run when device is inserted into a car dock.
  /// Used with \#ACTION_MAIN to launch an activity.  For more
  /// information, see android.app.UiModeManager.
  static const CATEGORY_DESK_DOCK = "android.intent.category.DESK_DOCK";

  /// from: static public final java.lang.String CATEGORY_DEVELOPMENT_PREFERENCE
  ///
  /// This activity is a development preference panel.
  static const CATEGORY_DEVELOPMENT_PREFERENCE =
      "android.intent.category.DEVELOPMENT_PREFERENCE";

  /// from: static public final java.lang.String CATEGORY_EMBED
  ///
  /// Capable of running inside a parent activity container.
  static const CATEGORY_EMBED = "android.intent.category.EMBED";

  /// from: static public final java.lang.String CATEGORY_FRAMEWORK_INSTRUMENTATION_TEST
  ///
  /// To be used as code under test for framework instrumentation tests.
  static const CATEGORY_FRAMEWORK_INSTRUMENTATION_TEST =
      "android.intent.category.FRAMEWORK_INSTRUMENTATION_TEST";

  /// from: static public final java.lang.String CATEGORY_HE_DESK_DOCK
  ///
  /// An activity to run when device is inserted into a digital (high end) dock.
  /// Used with \#ACTION_MAIN to launch an activity.  For more
  /// information, see android.app.UiModeManager.
  static const CATEGORY_HE_DESK_DOCK = "android.intent.category.HE_DESK_DOCK";

  /// from: static public final java.lang.String CATEGORY_HOME
  ///
  /// This is the home activity, that is the first activity that is displayed
  /// when the device boots.
  static const CATEGORY_HOME = "android.intent.category.HOME";

  /// from: static public final java.lang.String CATEGORY_INFO
  ///
  /// Provides information about the package it is in; typically used if
  /// a package does not contain a \#CATEGORY_LAUNCHER to provide
  /// a front-door to the user without having to be shown in the all apps list.
  static const CATEGORY_INFO = "android.intent.category.INFO";

  /// from: static public final java.lang.String CATEGORY_LAUNCHER
  ///
  /// Should be displayed in the top-level launcher.
  static const CATEGORY_LAUNCHER = "android.intent.category.LAUNCHER";

  /// from: static public final java.lang.String CATEGORY_LEANBACK_LAUNCHER
  ///
  /// Indicates an activity optimized for Leanback mode, and that should
  /// be displayed in the Leanback launcher.
  static const CATEGORY_LEANBACK_LAUNCHER =
      "android.intent.category.LEANBACK_LAUNCHER";

  /// from: static public final java.lang.String CATEGORY_LE_DESK_DOCK
  ///
  /// An activity to run when device is inserted into a analog (low end) dock.
  /// Used with \#ACTION_MAIN to launch an activity.  For more
  /// information, see android.app.UiModeManager.
  static const CATEGORY_LE_DESK_DOCK = "android.intent.category.LE_DESK_DOCK";

  /// from: static public final java.lang.String CATEGORY_MONKEY
  ///
  /// This activity may be exercised by the monkey or other automated test tools.
  static const CATEGORY_MONKEY = "android.intent.category.MONKEY";

  /// from: static public final java.lang.String CATEGORY_OPENABLE
  ///
  /// Used to indicate that an intent only wants URIs that can be opened with
  /// ContentResolver\#openFileDescriptor(Uri, String). Openable URIs
  /// must support at least the columns defined in OpenableColumns when
  /// queried.
  ///@see \#ACTION_GET_CONTENT
  ///@see \#ACTION_OPEN_DOCUMENT
  ///@see \#ACTION_CREATE_DOCUMENT
  static const CATEGORY_OPENABLE = "android.intent.category.OPENABLE";

  /// from: static public final java.lang.String CATEGORY_PREFERENCE
  ///
  /// This activity is a preference panel.
  static const CATEGORY_PREFERENCE = "android.intent.category.PREFERENCE";

  /// from: static public final java.lang.String CATEGORY_SAMPLE_CODE
  ///
  /// To be used as a sample code example (not part of the normal user
  /// experience).
  static const CATEGORY_SAMPLE_CODE = "android.intent.category.SAMPLE_CODE";

  /// from: static public final java.lang.String CATEGORY_SELECTED_ALTERNATIVE
  ///
  /// Set if the activity should be considered as an alternative selection
  /// action to the data the user has currently selected.  This is like
  /// \#CATEGORY_ALTERNATIVE, but is used in activities showing a list
  /// of items from which the user can select, giving them alternatives to the
  /// default action that will be performed on it.
  static const CATEGORY_SELECTED_ALTERNATIVE =
      "android.intent.category.SELECTED_ALTERNATIVE";

  /// from: static public final java.lang.String CATEGORY_TAB
  ///
  /// Intended to be used as a tab inside of a containing TabActivity.
  static const CATEGORY_TAB = "android.intent.category.TAB";

  /// from: static public final java.lang.String CATEGORY_TEST
  ///
  /// To be used as a test (not part of the normal user experience).
  static const CATEGORY_TEST = "android.intent.category.TEST";

  /// from: static public final java.lang.String CATEGORY_TYPED_OPENABLE
  ///
  /// Used to indicate that an intent filter can accept files which are not necessarily
  /// openable by ContentResolver\#openFileDescriptor(Uri, String), but
  /// at least streamable via
  /// ContentResolver\#openTypedAssetFileDescriptor(Uri, String, Bundle)
  /// using one of the stream types exposed via
  /// ContentResolver\#getStreamTypes(Uri, String).
  ///@see \#ACTION_SEND
  ///@see \#ACTION_SEND_MULTIPLE
  static const CATEGORY_TYPED_OPENABLE =
      "android.intent.category.TYPED_OPENABLE";

  /// from: static public final java.lang.String CATEGORY_UNIT_TEST
  ///
  /// To be used as a unit test (run through the Test Harness).
  static const CATEGORY_UNIT_TEST = "android.intent.category.UNIT_TEST";

  /// from: static public final java.lang.String CATEGORY_VOICE
  ///
  /// Categories for activities that can participate in voice interaction.
  /// An activity that supports this category must be prepared to run with
  /// no UI shown at all (though in some case it may have a UI shown), and
  /// rely on android.app.VoiceInteractor to interact with the user.
  static const CATEGORY_VOICE = "android.intent.category.VOICE";

  /// from: static public final java.lang.String CATEGORY_VR_HOME
  ///
  /// An activity to use for the launcher when the device is placed in a VR Headset viewer.
  /// Used with \#ACTION_MAIN to launch an activity.  For more
  /// information, see android.app.UiModeManager.
  static const CATEGORY_VR_HOME = "android.intent.category.VR_HOME";

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.content.Intent> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final java.lang.String EXTRA_ALARM_COUNT
  ///
  /// Used as an int extra field in android.app.AlarmManager intents
  /// to tell the application being invoked how many pending alarms are being
  /// delievered with the intent.  For one-shot alarms this will always be 1.
  /// For recurring alarms, this might be greater than 1 if the device was
  /// asleep or powered off at the time an earlier alarm would have been
  /// delivered.
  static const EXTRA_ALARM_COUNT = "android.intent.extra.ALARM_COUNT";

  /// from: static public final java.lang.String EXTRA_ALLOW_MULTIPLE
  ///
  /// Extra used to indicate that an intent can allow the user to select and
  /// return multiple items. This is a boolean extra; the default is false. If
  /// true, an implementation is allowed to present the user with a UI where
  /// they can pick multiple items that are all returned to the caller. When
  /// this happens, they should be returned as the \#getClipData() part
  /// of the result Intent.
  ///@see \#ACTION_GET_CONTENT
  ///@see \#ACTION_OPEN_DOCUMENT
  static const EXTRA_ALLOW_MULTIPLE = "android.intent.extra.ALLOW_MULTIPLE";

  /// from: static public final java.lang.String EXTRA_ALLOW_REPLACE
  ///
  /// Used as a boolean extra field with \#ACTION_INSTALL_PACKAGE to install a
  /// package.  Tells the installer UI to skip the confirmation with the user
  /// if the .apk is replacing an existing one.
  ///@deprecated As of android.os.Build.VERSION_CODES\#JELLY_BEAN, Android
  /// will no longer show an interstitial message about updating existing
  /// applications so this is no longer needed.
  static const EXTRA_ALLOW_REPLACE = "android.intent.extra.ALLOW_REPLACE";

  /// from: static public final java.lang.String EXTRA_ALTERNATE_INTENTS
  ///
  /// An Intent[] describing additional, alternate choices you would like shown with
  /// \#ACTION_CHOOSER.
  ///
  /// An app may be capable of providing several different payload types to complete a
  /// user's intended action. For example, an app invoking \#ACTION_SEND to share photos
  /// with another app may use EXTRA_ALTERNATE_INTENTS to have the chooser transparently offer
  /// several different supported sending mechanisms for sharing, such as the actual "image/*"
  /// photo data or a hosted link where the photos can be viewed.
  ///
  ///
  /// The intent present in \#EXTRA_INTENT will be treated as the
  /// first/primary/preferred intent in the set. Additional intents specified in
  /// this extra are ordered; by default intents that appear earlier in the array will be
  /// preferred over intents that appear later in the array as matches for the same
  /// target component. To alter this preference, a calling app may also supply
  /// \#EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER.
  ///
  static const EXTRA_ALTERNATE_INTENTS =
      "android.intent.extra.ALTERNATE_INTENTS";

  /// from: static public final java.lang.String EXTRA_ASSIST_CONTEXT
  ///
  /// An optional field on \#ACTION_ASSIST and containing additional contextual
  /// information supplied by the current foreground app at the time of the assist request.
  /// This is a Bundle of additional data.
  static const EXTRA_ASSIST_CONTEXT = "android.intent.extra.ASSIST_CONTEXT";

  /// from: static public final java.lang.String EXTRA_ASSIST_INPUT_DEVICE_ID
  ///
  /// An optional field on \#ACTION_ASSIST containing the InputDevice id
  /// that was used to invoke the assist.
  static const EXTRA_ASSIST_INPUT_DEVICE_ID =
      "android.intent.extra.ASSIST_INPUT_DEVICE_ID";

  /// from: static public final java.lang.String EXTRA_ASSIST_INPUT_HINT_KEYBOARD
  ///
  /// An optional field on \#ACTION_ASSIST suggesting that the user will likely use a
  /// keyboard as the primary input device for assistance.
  static const EXTRA_ASSIST_INPUT_HINT_KEYBOARD =
      "android.intent.extra.ASSIST_INPUT_HINT_KEYBOARD";

  /// from: static public final java.lang.String EXTRA_ASSIST_PACKAGE
  ///
  /// An optional field on \#ACTION_ASSIST containing the name of the current foreground
  /// application package at the time the assist was invoked.
  static const EXTRA_ASSIST_PACKAGE = "android.intent.extra.ASSIST_PACKAGE";

  /// from: static public final java.lang.String EXTRA_ASSIST_UID
  ///
  /// An optional field on \#ACTION_ASSIST containing the uid of the current foreground
  /// application package at the time the assist was invoked.
  static const EXTRA_ASSIST_UID = "android.intent.extra.ASSIST_UID";

  /// from: static public final java.lang.String EXTRA_BCC
  ///
  /// A String[] holding e-mail addresses that should be blind carbon copied.
  static const EXTRA_BCC = "android.intent.extra.BCC";

  /// from: static public final java.lang.String EXTRA_BUG_REPORT
  ///
  /// Used as a parcelable extra field in \#ACTION_APP_ERROR, containing
  /// the bug report.
  static const EXTRA_BUG_REPORT = "android.intent.extra.BUG_REPORT";

  /// from: static public final java.lang.String EXTRA_CC
  ///
  /// A String[] holding e-mail addresses that should be carbon copied.
  static const EXTRA_CC = "android.intent.extra.CC";

  /// from: static public final java.lang.String EXTRA_CHANGED_COMPONENT_NAME
  ///
  /// @deprecated See \#EXTRA_CHANGED_COMPONENT_NAME_LIST; this field
  /// will contain only the first name in the list.
  static const EXTRA_CHANGED_COMPONENT_NAME =
      "android.intent.extra.changed_component_name";

  /// from: static public final java.lang.String EXTRA_CHANGED_COMPONENT_NAME_LIST
  ///
  /// This field is part of android.content.Intent\#ACTION_PACKAGE_CHANGED,
  /// and contains a string array of all of the components that have changed.  If
  /// the state of the overall package has changed, then it will contain an entry
  /// with the package name itself.
  static const EXTRA_CHANGED_COMPONENT_NAME_LIST =
      "android.intent.extra.changed_component_name_list";

  /// from: static public final java.lang.String EXTRA_CHANGED_PACKAGE_LIST
  ///
  /// This field is part of
  /// android.content.Intent\#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE,
  /// android.content.Intent\#ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE,
  /// android.content.Intent\#ACTION_PACKAGES_SUSPENDED,
  /// android.content.Intent\#ACTION_PACKAGES_UNSUSPENDED
  /// and contains a string array of all of the components that have changed.
  static const EXTRA_CHANGED_PACKAGE_LIST =
      "android.intent.extra.changed_package_list";

  /// from: static public final java.lang.String EXTRA_CHANGED_UID_LIST
  ///
  /// This field is part of
  /// android.content.Intent\#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE,
  /// android.content.Intent\#ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE
  /// and contains an integer array of uids of all of the components
  /// that have changed.
  static const EXTRA_CHANGED_UID_LIST = "android.intent.extra.changed_uid_list";

  /// from: static public final java.lang.String EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER
  ///
  /// An IntentSender for an Activity that will be invoked when the user makes a selection
  /// from the chooser activity presented by \#ACTION_CHOOSER.
  ///
  /// An app preparing an action for another app to complete may wish to allow the user to
  /// disambiguate between several options for completing the action based on the chosen target
  /// or otherwise refine the action before it is invoked.
  ///
  ///
  ///
  /// When sent, this IntentSender may be filled in with the following extras:
  ///
  /// <ul>
  ///     <li>\#EXTRA_INTENT The first intent that matched the user's chosen target</li>
  ///     <li>\#EXTRA_ALTERNATE_INTENTS Any additional intents that also matched the user's
  ///     chosen target beyond the first</li>
  ///     <li>\#EXTRA_RESULT_RECEIVER A ResultReceiver that the refinement activity
  ///     should fill in and send once the disambiguation is complete</li>
  /// </ul>
  static const EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER =
      "android.intent.extra.CHOOSER_REFINEMENT_INTENT_SENDER";

  /// from: static public final java.lang.String EXTRA_CHOOSER_TARGETS
  ///
  /// A android.service.chooser.ChooserTarget ChooserTarget[] for \#ACTION_CHOOSER
  /// describing additional high-priority deep-link targets for the chooser to present to the user.
  ///
  /// Targets provided in this way will be presented inline with all other targets provided
  /// by services from other apps. They will be prioritized before other service targets, but
  /// after those targets provided by sources that the user has manually pinned to the front.
  ///
  ///@see \#ACTION_CHOOSER
  static const EXTRA_CHOOSER_TARGETS = "android.intent.extra.CHOOSER_TARGETS";

  /// from: static public final java.lang.String EXTRA_CHOSEN_COMPONENT
  ///
  /// The ComponentName chosen by the user to complete an action.
  ///@see \#EXTRA_CHOSEN_COMPONENT_INTENT_SENDER
  static const EXTRA_CHOSEN_COMPONENT = "android.intent.extra.CHOSEN_COMPONENT";

  /// from: static public final java.lang.String EXTRA_CHOSEN_COMPONENT_INTENT_SENDER
  ///
  /// An IntentSender that will be notified if a user successfully chooses a target
  /// component to handle an action in an \#ACTION_CHOOSER activity. The IntentSender
  /// will have the extra \#EXTRA_CHOSEN_COMPONENT appended to it containing the
  /// ComponentName of the chosen component.
  ///
  /// In some situations this callback may never come, for example if the user abandons
  /// the chooser, switches to another task or any number of other reasons. Apps should not
  /// be written assuming that this callback will always occur.
  ///
  static const EXTRA_CHOSEN_COMPONENT_INTENT_SENDER =
      "android.intent.extra.CHOSEN_COMPONENT_INTENT_SENDER";

  /// from: static public final java.lang.String EXTRA_COMPONENT_NAME
  ///
  /// Intent extra: A ComponentName value.
  ///
  /// Type: String
  ///
  ///
  static const EXTRA_COMPONENT_NAME = "android.intent.extra.COMPONENT_NAME";

  /// from: static public final java.lang.String EXTRA_CONTENT_ANNOTATIONS
  ///
  /// An {@code ArrayList} of {@code String} annotations describing content for
  /// \#ACTION_CHOOSER.
  ///
  /// If \#EXTRA_CONTENT_ANNOTATIONS is present in an intent used to start a
  /// \#ACTION_CHOOSER activity, the first three annotations will be used to rank apps.
  ///
  ///
  /// Annotations should describe the major components or topics of the content. It is up to
  /// apps initiating \#ACTION_CHOOSER to learn and add annotations. Annotations should be
  /// learned in advance, e.g., when creating or saving content, to avoid increasing latency to
  /// start \#ACTION_CHOOSER. Names of customized annotations should not contain the colon
  /// character. Performance on customized annotations can suffer, if they are rarely used for
  /// \#ACTION_CHOOSER in the past 14 days. Therefore, it is recommended to use the
  /// following annotations when applicable.
  ///
  /// <ul>
  ///     <li>"product" represents that the topic of the content is mainly about products, e.g.,
  ///     health & beauty, and office supplies.</li>
  ///     <li>"emotion" represents that the topic of the content is mainly about emotions, e.g.,
  ///     happy, and sad.</li>
  ///     <li>"person" represents that the topic of the content is mainly about persons, e.g.,
  ///     face, finger, standing, and walking.</li>
  ///     <li>"child" represents that the topic of the content is mainly about children, e.g.,
  ///     child, and baby.</li>
  ///     <li>"selfie" represents that the topic of the content is mainly about selfies.</li>
  ///     <li>"crowd" represents that the topic of the content is mainly about crowds.</li>
  ///     <li>"party" represents that the topic of the content is mainly about parties.</li>
  ///     <li>"animal" represent that the topic of the content is mainly about animals.</li>
  ///     <li>"plant" represents that the topic of the content is mainly about plants, e.g.,
  ///     flowers.</li>
  ///     <li>"vacation" represents that the topic of the content is mainly about vacations.</li>
  ///     <li>"fashion" represents that the topic of the content is mainly about fashion, e.g.
  ///     sunglasses, jewelry, handbags and clothing.</li>
  ///     <li>"material" represents that the topic of the content is mainly about materials, e.g.,
  ///     paper, and silk.</li>
  ///     <li>"vehicle" represents that the topic of the content is mainly about vehicles, like
  ///     cars, and boats.</li>
  ///     <li>"document" represents that the topic of the content is mainly about documents, e.g.
  ///     posters.</li>
  ///     <li>"design" represents that the topic of the content is mainly about design, e.g. arts
  ///     and designs of houses.</li>
  ///     <li>"holiday" represents that the topic of the content is mainly about holidays, e.g.,
  ///     Christmas and Thanksgiving.</li>
  /// </ul>
  static const EXTRA_CONTENT_ANNOTATIONS =
      "android.intent.extra.CONTENT_ANNOTATIONS";

  /// from: static public final java.lang.String EXTRA_DATA_REMOVED
  ///
  /// Used as a boolean extra field in android.content.Intent\#ACTION_PACKAGE_REMOVED
  /// intents to indicate whether this represents a full uninstall (removing
  /// both the code and its data) or a partial uninstall (leaving its data,
  /// implying that this is an update).
  static const EXTRA_DATA_REMOVED = "android.intent.extra.DATA_REMOVED";

  /// from: static public final java.lang.String EXTRA_DOCK_STATE
  ///
  /// Used as an int extra field in android.content.Intent\#ACTION_DOCK_EVENT
  /// intents to request the dock state.  Possible values are
  /// android.content.Intent\#EXTRA_DOCK_STATE_UNDOCKED,
  /// android.content.Intent\#EXTRA_DOCK_STATE_DESK, or
  /// android.content.Intent\#EXTRA_DOCK_STATE_CAR, or
  /// android.content.Intent\#EXTRA_DOCK_STATE_LE_DESK, or
  /// android.content.Intent\#EXTRA_DOCK_STATE_HE_DESK.
  static const EXTRA_DOCK_STATE = "android.intent.extra.DOCK_STATE";

  /// from: static public final int EXTRA_DOCK_STATE_CAR
  ///
  /// Used as an int value for android.content.Intent\#EXTRA_DOCK_STATE
  /// to represent that the phone is in a car dock.
  static const EXTRA_DOCK_STATE_CAR = 2;

  /// from: static public final int EXTRA_DOCK_STATE_DESK
  ///
  /// Used as an int value for android.content.Intent\#EXTRA_DOCK_STATE
  /// to represent that the phone is in a desk dock.
  static const EXTRA_DOCK_STATE_DESK = 1;

  /// from: static public final int EXTRA_DOCK_STATE_HE_DESK
  ///
  /// Used as an int value for android.content.Intent\#EXTRA_DOCK_STATE
  /// to represent that the phone is in a digital (high end) dock.
  static const EXTRA_DOCK_STATE_HE_DESK = 4;

  /// from: static public final int EXTRA_DOCK_STATE_LE_DESK
  ///
  /// Used as an int value for android.content.Intent\#EXTRA_DOCK_STATE
  /// to represent that the phone is in a analog (low end) dock.
  static const EXTRA_DOCK_STATE_LE_DESK = 3;

  /// from: static public final int EXTRA_DOCK_STATE_UNDOCKED
  ///
  /// Used as an int value for android.content.Intent\#EXTRA_DOCK_STATE
  /// to represent that the phone is not in any dock.
  static const EXTRA_DOCK_STATE_UNDOCKED = 0;

  /// from: static public final java.lang.String EXTRA_DONT_KILL_APP
  ///
  /// Used as a boolean extra field in android.content.Intent\#ACTION_PACKAGE_REMOVED or
  /// android.content.Intent\#ACTION_PACKAGE_CHANGED intents to override the default action
  /// of restarting the application.
  static const EXTRA_DONT_KILL_APP = "android.intent.extra.DONT_KILL_APP";

  /// from: static public final java.lang.String EXTRA_EMAIL
  ///
  /// A String[] holding e-mail addresses that should be delivered to.
  static const EXTRA_EMAIL = "android.intent.extra.EMAIL";

  /// from: static public final java.lang.String EXTRA_EXCLUDE_COMPONENTS
  ///
  /// A ComponentName ComponentName[] describing components that should be filtered out
  /// and omitted from a list of components presented to the user.
  ///
  /// When used with \#ACTION_CHOOSER, the chooser will omit any of the components
  /// in this array if it otherwise would have shown them. Useful for omitting specific targets
  /// from your own package or other apps from your organization if the idea of sending to those
  /// targets would be redundant with other app functionality. Filtered components will not
  /// be able to present targets from an associated <code>ChooserTargetService</code>.
  ///
  static const EXTRA_EXCLUDE_COMPONENTS =
      "android.intent.extra.EXCLUDE_COMPONENTS";

  /// from: static public final java.lang.String EXTRA_FROM_STORAGE
  ///
  /// Extra that can be included on activity intents coming from the storage UI
  /// when it launches sub-activities to manage various types of storage.  For example,
  /// it may use \#ACTION_VIEW with a "image/*" MIME type to have an app show
  /// the images on the device, and in that case also include this extra to tell the
  /// app it is coming from the storage UI so should help the user manage storage of
  /// this type.
  static const EXTRA_FROM_STORAGE = "android.intent.extra.FROM_STORAGE";

  /// from: static public final java.lang.String EXTRA_HTML_TEXT
  ///
  /// A constant String that is associated with the Intent, used with
  /// \#ACTION_SEND to supply an alternative to \#EXTRA_TEXT
  /// as HTML formatted text.  Note that you _must_ also supply
  /// \#EXTRA_TEXT.
  static const EXTRA_HTML_TEXT = "android.intent.extra.HTML_TEXT";

  /// from: static public final java.lang.String EXTRA_INDEX
  ///
  /// Optional index with semantics depending on the intent action.
  ///
  /// The value must be an integer greater or equal to 0.
  ///@see \#ACTION_QUICK_VIEW
  static const EXTRA_INDEX = "android.intent.extra.INDEX";

  /// from: static public final java.lang.String EXTRA_INITIAL_INTENTS
  ///
  /// A Parcelable[] of Intent or
  /// android.content.pm.LabeledIntent objects as set with
  /// \#putExtra(String, Parcelable[]) of additional activities to place
  /// a the front of the list of choices, when shown to the user with a
  /// \#ACTION_CHOOSER.
  static const EXTRA_INITIAL_INTENTS = "android.intent.extra.INITIAL_INTENTS";

  /// from: static public final java.lang.String EXTRA_INSTALLER_PACKAGE_NAME
  ///
  /// Used as a string extra field with \#ACTION_INSTALL_PACKAGE to install a
  /// package.  Specifies the installer package name; this package will receive the
  /// \#ACTION_APP_ERROR intent.
  static const EXTRA_INSTALLER_PACKAGE_NAME =
      "android.intent.extra.INSTALLER_PACKAGE_NAME";

  /// from: static public final java.lang.String EXTRA_INTENT
  ///
  /// An Intent describing the choices you would like shown with
  /// \#ACTION_PICK_ACTIVITY or \#ACTION_CHOOSER.
  static const EXTRA_INTENT = "android.intent.extra.INTENT";

  /// from: static public final java.lang.String EXTRA_KEY_EVENT
  ///
  /// A android.view.KeyEvent object containing the event that
  /// triggered the creation of the Intent it is in.
  static const EXTRA_KEY_EVENT = "android.intent.extra.KEY_EVENT";

  /// from: static public final java.lang.String EXTRA_LOCAL_ONLY
  ///
  /// Extra used to indicate that an intent should only return data that is on
  /// the local device. This is a boolean extra; the default is false. If true,
  /// an implementation should only allow the user to select data that is
  /// already on the device, not requiring it be downloaded from a remote
  /// service when opened.
  ///@see \#ACTION_GET_CONTENT
  ///@see \#ACTION_OPEN_DOCUMENT
  ///@see \#ACTION_OPEN_DOCUMENT_TREE
  ///@see \#ACTION_CREATE_DOCUMENT
  static const EXTRA_LOCAL_ONLY = "android.intent.extra.LOCAL_ONLY";

  /// from: static public final java.lang.String EXTRA_MIME_TYPES
  ///
  /// Extra used to communicate a set of acceptable MIME types. The type of the
  /// extra is {@code String[]}. Values may be a combination of concrete MIME
  /// types (such as "image/png") and/or partial MIME types (such as
  /// "audio/*").
  ///@see \#ACTION_GET_CONTENT
  ///@see \#ACTION_OPEN_DOCUMENT
  static const EXTRA_MIME_TYPES = "android.intent.extra.MIME_TYPES";

  /// from: static public final java.lang.String EXTRA_NOT_UNKNOWN_SOURCE
  ///
  /// Used as a boolean extra field with \#ACTION_INSTALL_PACKAGE to install a
  /// package.  Specifies that the application being installed should not be
  /// treated as coming from an unknown source, but as coming from the app
  /// invoking the Intent.  For this to work you must start the installer with
  /// startActivityForResult().
  static const EXTRA_NOT_UNKNOWN_SOURCE =
      "android.intent.extra.NOT_UNKNOWN_SOURCE";

  /// from: static public final java.lang.String EXTRA_ORIGINATING_URI
  ///
  /// Used as a URI extra field with \#ACTION_INSTALL_PACKAGE and
  /// \#ACTION_VIEW to indicate the URI from which the local APK in the Intent
  /// data field originated from.
  static const EXTRA_ORIGINATING_URI = "android.intent.extra.ORIGINATING_URI";

  /// from: static public final java.lang.String EXTRA_PACKAGE_NAME
  ///
  /// Intent extra: An app package name.
  ///
  /// Type: String
  ///
  ///
  static const EXTRA_PACKAGE_NAME = "android.intent.extra.PACKAGE_NAME";

  /// from: static public final java.lang.String EXTRA_PHONE_NUMBER
  ///
  /// A String holding the phone number originally entered in
  /// android.content.Intent\#ACTION_NEW_OUTGOING_CALL, or the actual
  /// number to call in a android.content.Intent\#ACTION_CALL.
  static const EXTRA_PHONE_NUMBER = "android.intent.extra.PHONE_NUMBER";

  /// from: static public final java.lang.String EXTRA_PROCESS_TEXT
  ///
  /// The name of the extra used to define the text to be processed, as a
  /// CharSequence. Note that this may be a styled CharSequence, so you must use
  /// Bundle\#getCharSequence(String) Bundle.getCharSequence() to retrieve it.
  static const EXTRA_PROCESS_TEXT = "android.intent.extra.PROCESS_TEXT";

  /// from: static public final java.lang.String EXTRA_PROCESS_TEXT_READONLY
  ///
  /// The name of the boolean extra used to define if the processed text will be used as read-only.
  static const EXTRA_PROCESS_TEXT_READONLY =
      "android.intent.extra.PROCESS_TEXT_READONLY";

  /// from: static public final java.lang.String EXTRA_QUICK_VIEW_FEATURES
  ///
  /// An optional extra of {@code String[]} indicating which quick view features should be made
  /// available to the user in the quick view UI while handing a
  /// Intent\#ACTION_QUICK_VIEW intent.
  /// <li>Enumeration of features here is not meant to restrict capabilities of the quick viewer.
  /// Quick viewer can implement features not listed below.
  /// <li>Features included at this time are: QuickViewConstants\#FEATURE_VIEW,
  /// QuickViewConstants\#FEATURE_EDIT, QuickViewConstants\#FEATURE_DELETE,
  /// QuickViewConstants\#FEATURE_DOWNLOAD, QuickViewConstants\#FEATURE_SEND,
  /// QuickViewConstants\#FEATURE_PRINT.
  ///
  /// Requirements:
  /// <li>Quick viewer shouldn't show a feature if the feature is absent in
  /// \#EXTRA_QUICK_VIEW_FEATURES.
  /// <li>When \#EXTRA_QUICK_VIEW_FEATURES is not present, quick viewer should follow
  /// internal policies.
  /// <li>Presence of an feature in \#EXTRA_QUICK_VIEW_FEATURES, does not constitute a
  /// requirement that the feature be shown. Quick viewer may, according to its own policies,
  /// disable or hide features.
  ///@see \#ACTION_QUICK_VIEW
  static const EXTRA_QUICK_VIEW_FEATURES =
      "android.intent.extra.QUICK_VIEW_FEATURES";

  /// from: static public final java.lang.String EXTRA_QUIET_MODE
  ///
  /// Optional boolean extra indicating whether quiet mode has been switched on or off.
  /// When a profile goes into quiet mode, all apps in the profile are killed and the
  /// profile user is stopped. Widgets originating from the profile are masked, and app
  /// launcher icons are grayed out.
  static const EXTRA_QUIET_MODE = "android.intent.extra.QUIET_MODE";

  /// from: static public final java.lang.String EXTRA_REFERRER
  ///
  /// This extra can be used with any Intent used to launch an activity, supplying information
  /// about who is launching that activity.  This field contains a android.net.Uri
  /// object, typically an http: or https: URI of the web site that the referral came from;
  /// it can also use the \#URI_ANDROID_APP_SCHEME android-app: scheme to identify
  /// a native application that it came from.
  ///
  /// To retrieve this value in a client, use android.app.Activity\#getReferrer
  /// instead of directly retrieving the extra.  It is also valid for applications to
  /// instead supply \#EXTRA_REFERRER_NAME for cases where they can only create
  /// a string, not a Uri; the field here, if supplied, will always take precedence,
  /// however.
  ///
  ///@see \#EXTRA_REFERRER_NAME
  static const EXTRA_REFERRER = "android.intent.extra.REFERRER";

  /// from: static public final java.lang.String EXTRA_REFERRER_NAME
  ///
  /// Alternate version of \#EXTRA_REFERRER that supplies the URI as a String rather
  /// than a android.net.Uri object.  Only for use in cases where Uri objects can
  /// not be created, in particular when Intent extras are supplied through the
  /// \#URI_INTENT_SCHEME intent: or \#URI_ANDROID_APP_SCHEME android-app:
  /// schemes.
  ///@see \#EXTRA_REFERRER
  static const EXTRA_REFERRER_NAME = "android.intent.extra.REFERRER_NAME";

  /// from: static public final java.lang.String EXTRA_REMOTE_INTENT_TOKEN
  ///
  /// Used in the extra field in the remote intent. It's astring token passed with the
  /// remote intent.
  static const EXTRA_REMOTE_INTENT_TOKEN =
      "android.intent.extra.remote_intent_token";

  /// from: static public final java.lang.String EXTRA_REPLACEMENT_EXTRAS
  ///
  /// A Bundle forming a mapping of potential target package names to different extras Bundles
  /// to add to the default intent extras in \#EXTRA_INTENT when used with
  /// \#ACTION_CHOOSER. Each key should be a package name. The package need not
  /// be currently installed on the device.
  ///
  /// An application may choose to provide alternate extras for the case where a user
  /// selects an activity from a predetermined set of target packages. If the activity
  /// the user selects from the chooser belongs to a package with its package name as
  /// a key in this bundle, the corresponding extras for that package will be merged with
  /// the extras already present in the intent at \#EXTRA_INTENT. If a replacement
  /// extra has the same key as an extra already present in the intent it will overwrite
  /// the extra from the intent.
  ///
  ///
  /// _Examples:_
  /// <ul>
  ///     <li>An application may offer different \#EXTRA_TEXT to an application
  ///     when sharing with it via \#ACTION_SEND, augmenting a link with additional query
  ///     parameters for that target.</li>
  ///     <li>An application may offer additional metadata for known targets of a given intent
  ///     to pass along information only relevant to that target such as account or content
  ///     identifiers already known to that application.</li>
  /// </ul>
  ///
  static const EXTRA_REPLACEMENT_EXTRAS =
      "android.intent.extra.REPLACEMENT_EXTRAS";

  /// from: static public final java.lang.String EXTRA_REPLACING
  ///
  /// Used as a boolean extra field in android.content.Intent\#ACTION_PACKAGE_REMOVED
  /// intents to indicate that this is a replacement of the package, so this
  /// broadcast will immediately be followed by an add broadcast for a
  /// different version of the same package.
  static const EXTRA_REPLACING = "android.intent.extra.REPLACING";

  /// from: static public final java.lang.String EXTRA_RESTRICTIONS_BUNDLE
  ///
  /// Extra sent in the intent to the BroadcastReceiver that handles
  /// \#ACTION_GET_RESTRICTION_ENTRIES. The type of the extra is a Bundle containing
  /// the restrictions as key/value pairs.
  static const EXTRA_RESTRICTIONS_BUNDLE =
      "android.intent.extra.restrictions_bundle";

  /// from: static public final java.lang.String EXTRA_RESTRICTIONS_INTENT
  ///
  /// Extra used in the response from a BroadcastReceiver that handles
  /// \#ACTION_GET_RESTRICTION_ENTRIES.
  static const EXTRA_RESTRICTIONS_INTENT =
      "android.intent.extra.restrictions_intent";

  /// from: static public final java.lang.String EXTRA_RESTRICTIONS_LIST
  ///
  /// Extra used in the response from a BroadcastReceiver that handles
  /// \#ACTION_GET_RESTRICTION_ENTRIES. The type of the extra is
  /// <code>ArrayList&lt;RestrictionEntry&gt;</code>.
  static const EXTRA_RESTRICTIONS_LIST =
      "android.intent.extra.restrictions_list";

  /// from: static public final java.lang.String EXTRA_RESULT_RECEIVER
  ///
  /// A ResultReceiver used to return data back to the sender.
  ///
  /// Used to complete an app-specific
  /// \#EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER refinement for \#ACTION_CHOOSER.
  ///
  ///
  /// If \#EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER is present in the intent
  /// used to start a \#ACTION_CHOOSER activity this extra will be
  /// \#fillIn(Intent, int) filled in to that IntentSender and sent
  /// when the user selects a target component from the chooser. It is up to the recipient
  /// to send a result to this ResultReceiver to signal that disambiguation is complete
  /// and that the chooser should invoke the user's choice.
  ///
  ///
  /// The disambiguator should provide a Bundle to the ResultReceiver with an intent
  /// assigned to the key \#EXTRA_INTENT. This supplied intent will be used by the chooser
  /// to match and fill in the final Intent or ChooserTarget before starting it.
  /// The supplied intent must \#filterEquals(Intent) match one of the intents from
  /// \#EXTRA_INTENT or \#EXTRA_ALTERNATE_INTENTS passed to
  /// \#EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER to be accepted.
  ///
  ///
  /// The result code passed to the ResultReceiver should be
  /// android.app.Activity\#RESULT_OK if the refinement succeeded and the supplied intent's
  /// target in the chooser should be started, or android.app.Activity\#RESULT_CANCELED if
  /// the chooser should finish without starting a target.
  ///
  static const EXTRA_RESULT_RECEIVER = "android.intent.extra.RESULT_RECEIVER";

  /// from: static public final java.lang.String EXTRA_RETURN_RESULT
  ///
  /// Used as a boolean extra field with \#ACTION_INSTALL_PACKAGE or
  /// \#ACTION_UNINSTALL_PACKAGE.  Specifies that the installer UI should
  /// return to the application the result code of the install/uninstall.  The returned result
  /// code will be android.app.Activity\#RESULT_OK on success or
  /// android.app.Activity\#RESULT_FIRST_USER on failure.
  static const EXTRA_RETURN_RESULT = "android.intent.extra.RETURN_RESULT";

  /// from: static public final java.lang.String EXTRA_SHORTCUT_ICON
  ///
  /// The name of the extra used to define the icon, as a Bitmap, of a shortcut.
  ///@see \#ACTION_CREATE_SHORTCUT
  ///@deprecated Replaced with android.content.pm.ShortcutManager\#createShortcutResultIntent
  static const EXTRA_SHORTCUT_ICON = "android.intent.extra.shortcut.ICON";

  /// from: static public final java.lang.String EXTRA_SHORTCUT_ICON_RESOURCE
  ///
  /// The name of the extra used to define the icon, as a ShortcutIconResource, of a shortcut.
  ///@see \#ACTION_CREATE_SHORTCUT
  ///@see android.content.Intent.ShortcutIconResource
  ///@deprecated Replaced with android.content.pm.ShortcutManager\#createShortcutResultIntent
  static const EXTRA_SHORTCUT_ICON_RESOURCE =
      "android.intent.extra.shortcut.ICON_RESOURCE";

  /// from: static public final java.lang.String EXTRA_SHORTCUT_INTENT
  ///
  /// The name of the extra used to define the Intent of a shortcut.
  ///@see \#ACTION_CREATE_SHORTCUT
  ///@deprecated Replaced with android.content.pm.ShortcutManager\#createShortcutResultIntent
  static const EXTRA_SHORTCUT_INTENT = "android.intent.extra.shortcut.INTENT";

  /// from: static public final java.lang.String EXTRA_SHORTCUT_NAME
  ///
  /// The name of the extra used to define the name of a shortcut.
  ///@see \#ACTION_CREATE_SHORTCUT
  ///@deprecated Replaced with android.content.pm.ShortcutManager\#createShortcutResultIntent
  static const EXTRA_SHORTCUT_NAME = "android.intent.extra.shortcut.NAME";

  /// from: static public final java.lang.String EXTRA_SHUTDOWN_USERSPACE_ONLY
  ///
  /// Optional extra for \#ACTION_SHUTDOWN that allows the sender to qualify that
  /// this shutdown is only for the user space of the system, not a complete shutdown.
  /// When this is true, hardware devices can use this information to determine that
  /// they shouldn't do a complete shutdown of their device since this is not a
  /// complete shutdown down to the kernel, but only user space restarting.
  /// The default if not supplied is false.
  static const EXTRA_SHUTDOWN_USERSPACE_ONLY =
      "android.intent.extra.SHUTDOWN_USERSPACE_ONLY";

  /// from: static public final java.lang.String EXTRA_SPLIT_NAME
  ///
  /// Intent extra: An app split name.
  ///
  /// Type: String
  ///
  ///
  static const EXTRA_SPLIT_NAME = "android.intent.extra.SPLIT_NAME";

  /// from: static public final java.lang.String EXTRA_STREAM
  ///
  /// A content: URI holding a stream of data associated with the Intent,
  /// used with \#ACTION_SEND to supply the data being sent.
  static const EXTRA_STREAM = "android.intent.extra.STREAM";

  /// from: static public final java.lang.String EXTRA_SUBJECT
  ///
  /// A constant string holding the desired subject line of a message.
  static const EXTRA_SUBJECT = "android.intent.extra.SUBJECT";

  /// from: static public final java.lang.String EXTRA_SUSPENDED_PACKAGE_EXTRAS
  ///
  /// Intent extra: A Bundle of extras for a package being suspended. Will be sent as an
  /// extra with \#ACTION_MY_PACKAGE_SUSPENDED.
  ///
  /// The contents of this Bundle are a contract between the suspended app and the
  /// suspending app, i.e. any app with the permission {@code android.permission.SUSPEND_APPS}.
  /// This is meant to enable the suspended app to better handle the state of being suspended.
  ///@see \#ACTION_MY_PACKAGE_SUSPENDED
  ///@see \#ACTION_MY_PACKAGE_UNSUSPENDED
  ///@see PackageManager\#isPackageSuspended()
  ///@see PackageManager\#getSuspendedPackageAppExtras()
  static const EXTRA_SUSPENDED_PACKAGE_EXTRAS =
      "android.intent.extra.SUSPENDED_PACKAGE_EXTRAS";

  /// from: static public final java.lang.String EXTRA_TEMPLATE
  ///
  /// The initial data to place in a newly created record.  Use with
  /// \#ACTION_INSERT.  The data here is a Map containing the same
  /// fields as would be given to the underlying ContentProvider.insert()
  /// call.
  static const EXTRA_TEMPLATE = "android.intent.extra.TEMPLATE";

  /// from: static public final java.lang.String EXTRA_TEXT
  ///
  /// A constant CharSequence that is associated with the Intent, used with
  /// \#ACTION_SEND to supply the literal data to be sent.  Note that
  /// this may be a styled CharSequence, so you must use
  /// Bundle\#getCharSequence(String) Bundle.getCharSequence() to
  /// retrieve it.
  static const EXTRA_TEXT = "android.intent.extra.TEXT";

  /// from: static public final java.lang.String EXTRA_TITLE
  ///
  /// A CharSequence dialog title to provide to the user when used with a
  /// \#ACTION_CHOOSER.
  static const EXTRA_TITLE = "android.intent.extra.TITLE";

  /// from: static public final java.lang.String EXTRA_UID
  ///
  /// Used as an int extra field in android.content.Intent\#ACTION_UID_REMOVED
  /// intents to supply the uid the package had been assigned.  Also an optional
  /// extra in android.content.Intent\#ACTION_PACKAGE_REMOVED or
  /// android.content.Intent\#ACTION_PACKAGE_CHANGED for the same
  /// purpose.
  static const EXTRA_UID = "android.intent.extra.UID";

  /// from: static public final java.lang.String EXTRA_USER
  ///
  /// The UserHandle carried with broadcasts intents related to addition and removal of managed
  /// profiles - \#ACTION_MANAGED_PROFILE_ADDED and \#ACTION_MANAGED_PROFILE_REMOVED.
  static const EXTRA_USER = "android.intent.extra.USER";

  /// from: static public final int FILL_IN_ACTION
  ///
  /// Use with \#fillIn to allow the current action value to be
  /// overwritten, even if it is already set.
  static const FILL_IN_ACTION = 1;

  /// from: static public final int FILL_IN_CATEGORIES
  ///
  /// Use with \#fillIn to allow the current categories to be
  /// overwritten, even if they are already set.
  static const FILL_IN_CATEGORIES = 4;

  /// from: static public final int FILL_IN_CLIP_DATA
  ///
  /// Use with \#fillIn to allow the current ClipData to be
  /// overwritten, even if it is already set.
  static const FILL_IN_CLIP_DATA = 128;

  /// from: static public final int FILL_IN_COMPONENT
  ///
  /// Use with \#fillIn to allow the current component value to be
  /// overwritten, even if it is already set.
  static const FILL_IN_COMPONENT = 8;

  /// from: static public final int FILL_IN_DATA
  ///
  /// Use with \#fillIn to allow the current data or type value
  /// overwritten, even if it is already set.
  static const FILL_IN_DATA = 2;

  /// from: static public final int FILL_IN_PACKAGE
  ///
  /// Use with \#fillIn to allow the current package value to be
  /// overwritten, even if it is already set.
  static const FILL_IN_PACKAGE = 16;

  /// from: static public final int FILL_IN_SELECTOR
  ///
  /// Use with \#fillIn to allow the current selector to be
  /// overwritten, even if it is already set.
  static const FILL_IN_SELECTOR = 64;

  /// from: static public final int FILL_IN_SOURCE_BOUNDS
  ///
  /// Use with \#fillIn to allow the current bounds rectangle to be
  /// overwritten, even if it is already set.
  static const FILL_IN_SOURCE_BOUNDS = 32;

  /// from: static public final int FLAG_ACTIVITY_BROUGHT_TO_FRONT
  ///
  /// This flag is not normally set by application code, but set for you by
  /// the system as described in the
  /// android.R.styleable\#AndroidManifestActivity_launchMode launchMode documentation for the singleTask mode.
  static const FLAG_ACTIVITY_BROUGHT_TO_FRONT = 4194304;

  /// from: static public final int FLAG_ACTIVITY_CLEAR_TASK
  ///
  /// If set in an Intent passed to Context\#startActivity Context.startActivity(),
  /// this flag will cause any existing task that would be associated with the
  /// activity to be cleared before the activity is started.  That is, the activity
  /// becomes the new root of an otherwise empty task, and any old activities
  /// are finished.  This can only be used in conjunction with \#FLAG_ACTIVITY_NEW_TASK.
  static const FLAG_ACTIVITY_CLEAR_TASK = 32768;

  /// from: static public final int FLAG_ACTIVITY_CLEAR_TOP
  ///
  /// If set, and the activity being launched is already running in the
  /// current task, then instead of launching a new instance of that activity,
  /// all of the other activities on top of it will be closed and this Intent
  /// will be delivered to the (now on top) old activity as a new Intent.
  ///
  /// For example, consider a task consisting of the activities: A, B, C, D.
  /// If D calls startActivity() with an Intent that resolves to the component
  /// of activity B, then C and D will be finished and B receive the given
  /// Intent, resulting in the stack now being: A, B.
  ///
  /// The currently running instance of activity B in the above example will
  /// either receive the new intent you are starting here in its
  /// onNewIntent() method, or be itself finished and restarted with the
  /// new intent.  If it has declared its launch mode to be "multiple" (the
  /// default) and you have not set \#FLAG_ACTIVITY_SINGLE_TOP in
  /// the same intent, then it will be finished and re-created; for all other
  /// launch modes or if \#FLAG_ACTIVITY_SINGLE_TOP is set then this
  /// Intent will be delivered to the current instance's onNewIntent().
  ///
  /// This launch mode can also be used to good effect in conjunction with
  /// \#FLAG_ACTIVITY_NEW_TASK: if used to start the root activity
  /// of a task, it will bring any currently running instance of that task
  /// to the foreground, and then clear it to its root state.  This is
  /// especially useful, for example, when launching an activity from the
  /// notification manager.
  ///
  /// See
  /// <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
  /// Stack</a> for more information about tasks.
  static const FLAG_ACTIVITY_CLEAR_TOP = 67108864;

  /// from: static public final int FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET
  ///
  /// @deprecated As of API 21 this performs identically to
  /// \#FLAG_ACTIVITY_NEW_DOCUMENT which should be used instead of this.
  static const FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET = 524288;

  /// from: static public final int FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
  ///
  /// If set, the new activity is not kept in the list of recently launched
  /// activities.
  static const FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS = 8388608;

  /// from: static public final int FLAG_ACTIVITY_FORWARD_RESULT
  ///
  /// If set and this intent is being used to launch a new activity from an
  /// existing one, then the reply target of the existing activity will be
  /// transfered to the new activity.  This way the new activity can call
  /// android.app.Activity\#setResult and have that result sent back to
  /// the reply target of the original activity.
  static const FLAG_ACTIVITY_FORWARD_RESULT = 33554432;

  /// from: static public final int FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY
  ///
  /// This flag is not normally set by application code, but set for you by
  /// the system if this activity is being launched from history
  /// (longpress home key).
  static const FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY = 1048576;

  /// from: static public final int FLAG_ACTIVITY_LAUNCH_ADJACENT
  ///
  /// This flag is only used in split-screen multi-window mode. The new activity will be displayed
  /// adjacent to the one launching it. This can only be used in conjunction with
  /// \#FLAG_ACTIVITY_NEW_TASK. Also, setting \#FLAG_ACTIVITY_MULTIPLE_TASK is
  /// required if you want a new instance of an existing activity to be created.
  static const FLAG_ACTIVITY_LAUNCH_ADJACENT = 4096;

  /// from: static public final int FLAG_ACTIVITY_MATCH_EXTERNAL
  ///
  /// If set in an Intent passed to Context\#startActivity Context.startActivity(),
  /// this flag will attempt to launch an instant app if no full app on the device can already
  /// handle the intent.
  ///
  /// When attempting to resolve instant apps externally, the following Intent properties
  /// are supported:
  /// <ul>
  ///     <li>Intent\#setAction(String)</li>
  ///     <li>Intent\#addCategory(String)</li>
  ///     <li>Intent\#setData(Uri)</li>
  ///     <li>Intent\#setType(String)</li>
  ///     <li>Intent\#setPackage(String)</li>
  ///     <li>Intent\#addFlags(int)</li>
  /// </ul>
  ///
  /// In the case that no instant app can be found, the installer will be launched to notify the
  /// user that the intent could not be resolved. On devices that do not support instant apps,
  /// the flag will be ignored.
  static const FLAG_ACTIVITY_MATCH_EXTERNAL = 2048;

  /// from: static public final int FLAG_ACTIVITY_MULTIPLE_TASK
  ///
  /// This flag is used to create a new task and launch an activity into it.
  /// This flag is always paired with either \#FLAG_ACTIVITY_NEW_DOCUMENT
  /// or \#FLAG_ACTIVITY_NEW_TASK. In both cases these flags alone would
  /// search through existing tasks for ones matching this Intent. Only if no such
  /// task is found would a new task be created. When paired with
  /// FLAG_ACTIVITY_MULTIPLE_TASK both of these behaviors are modified to skip
  /// the search for a matching task and unconditionally start a new task.
  ///
  /// <strong>When used with \#FLAG_ACTIVITY_NEW_TASK do not use this
  /// flag unless you are implementing your own
  /// top-level application launcher.</strong>  Used in conjunction with
  /// \#FLAG_ACTIVITY_NEW_TASK to disable the
  /// behavior of bringing an existing task to the foreground.  When set,
  /// a new task is _always_ started to host the Activity for the
  /// Intent, regardless of whether there is already an existing task running
  /// the same thing.
  ///
  /// <strong>Because the default system does not include graphical task management,
  /// you should not use this flag unless you provide some way for a user to
  /// return back to the tasks you have launched.</strong>
  ///
  /// See \#FLAG_ACTIVITY_NEW_DOCUMENT for details of this flag's use for
  /// creating new document tasks.
  ///
  /// This flag is ignored if one of \#FLAG_ACTIVITY_NEW_TASK or
  /// \#FLAG_ACTIVITY_NEW_DOCUMENT is not also set.
  ///
  /// See
  /// <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
  /// Stack</a> for more information about tasks.
  ///@see \#FLAG_ACTIVITY_NEW_DOCUMENT
  ///@see \#FLAG_ACTIVITY_NEW_TASK
  static const FLAG_ACTIVITY_MULTIPLE_TASK = 134217728;

  /// from: static public final int FLAG_ACTIVITY_NEW_DOCUMENT
  ///
  /// This flag is used to open a document into a new task rooted at the activity launched
  /// by this Intent. Through the use of this flag, or its equivalent attribute,
  /// android.R.attr\#documentLaunchMode multiple instances of the same activity
  /// containing different documents will appear in the recent tasks list.
  ///
  /// The use of the activity attribute form of this,
  /// android.R.attr\#documentLaunchMode, is
  /// preferred over the Intent flag described here. The attribute form allows the
  /// Activity to specify multiple document behavior for all launchers of the Activity
  /// whereas using this flag requires each Intent that launches the Activity to specify it.
  ///
  /// Note that the default semantics of this flag w.r.t. whether the recents entry for
  /// it is kept after the activity is finished is different than the use of
  /// \#FLAG_ACTIVITY_NEW_TASK and android.R.attr\#documentLaunchMode -- if
  /// this flag is being used to create a new recents entry, then by default that entry
  /// will be removed once the activity is finished.  You can modify this behavior with
  /// \#FLAG_ACTIVITY_RETAIN_IN_RECENTS.
  ///
  /// FLAG_ACTIVITY_NEW_DOCUMENT may be used in conjunction with \#FLAG_ACTIVITY_MULTIPLE_TASK. When used alone it is the
  /// equivalent of the Activity manifest specifying android.R.attr\#documentLaunchMode="intoExisting". When used with
  /// FLAG_ACTIVITY_MULTIPLE_TASK it is the equivalent of the Activity manifest specifying
  /// android.R.attr\#documentLaunchMode="always".
  ///
  /// Refer to android.R.attr\#documentLaunchMode for more information.
  ///@see android.R.attr\#documentLaunchMode
  ///@see \#FLAG_ACTIVITY_MULTIPLE_TASK
  static const FLAG_ACTIVITY_NEW_DOCUMENT = 524288;

  /// from: static public final int FLAG_ACTIVITY_NEW_TASK
  ///
  /// If set, this activity will become the start of a new task on this
  /// history stack.  A task (from the activity that started it to the
  /// next task activity) defines an atomic group of activities that the
  /// user can move to.  Tasks can be moved to the foreground and background;
  /// all of the activities inside of a particular task always remain in
  /// the same order.  See
  /// <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
  /// Stack</a> for more information about tasks.
  ///
  /// This flag is generally used by activities that want
  /// to present a "launcher" style behavior: they give the user a list of
  /// separate things that can be done, which otherwise run completely
  /// independently of the activity launching them.
  ///
  /// When using this flag, if a task is already running for the activity
  /// you are now starting, then a new activity will not be started; instead,
  /// the current task will simply be brought to the front of the screen with
  /// the state it was last in.  See \#FLAG_ACTIVITY_MULTIPLE_TASK for a flag
  /// to disable this behavior.
  ///
  /// This flag can not be used when the caller is requesting a result from
  /// the activity being launched.
  static const FLAG_ACTIVITY_NEW_TASK = 268435456;

  /// from: static public final int FLAG_ACTIVITY_NO_ANIMATION
  ///
  /// If set in an Intent passed to Context\#startActivity Context.startActivity(),
  /// this flag will prevent the system from applying an activity transition
  /// animation to go to the next activity state.  This doesn't mean an
  /// animation will never run -- if another activity change happens that doesn't
  /// specify this flag before the activity started here is displayed, then
  /// that transition will be used.  This flag can be put to good use
  /// when you are going to do a series of activity operations but the
  /// animation seen by the user shouldn't be driven by the first activity
  /// change but rather a later one.
  static const FLAG_ACTIVITY_NO_ANIMATION = 65536;

  /// from: static public final int FLAG_ACTIVITY_NO_HISTORY
  ///
  /// If set, the new activity is not kept in the history stack.  As soon as
  /// the user navigates away from it, the activity is finished.  This may also
  /// be set with the android.R.styleable\#AndroidManifestActivity_noHistory noHistory attribute.
  ///
  /// If set, android.app.Activity\#onActivityResult onActivityResult()
  /// is never invoked when the current activity starts a new activity which
  /// sets a result and finishes.
  static const FLAG_ACTIVITY_NO_HISTORY = 1073741824;

  /// from: static public final int FLAG_ACTIVITY_NO_USER_ACTION
  ///
  /// If set, this flag will prevent the normal android.app.Activity\#onUserLeaveHint
  /// callback from occurring on the current frontmost activity before it is
  /// paused as the newly-started activity is brought to the front.
  ///
  /// Typically, an activity can rely on that callback to indicate that an
  /// explicit user action has caused their activity to be moved out of the
  /// foreground. The callback marks an appropriate point in the activity's
  /// lifecycle for it to dismiss any notifications that it intends to display
  /// "until the user has seen them," such as a blinking LED.
  ///
  /// If an activity is ever started via any non-user-driven events such as
  /// phone-call receipt or an alarm handler, this flag should be passed to Context\#startActivity Context.startActivity, ensuring that the pausing
  /// activity does not think the user has acknowledged its notification.
  static const FLAG_ACTIVITY_NO_USER_ACTION = 262144;

  /// from: static public final int FLAG_ACTIVITY_PREVIOUS_IS_TOP
  ///
  /// If set and this intent is being used to launch a new activity from an
  /// existing one, the current activity will not be counted as the top
  /// activity for deciding whether the new intent should be delivered to
  /// the top instead of starting a new one.  The previous activity will
  /// be used as the top, with the assumption being that the current activity
  /// will finish itself immediately.
  static const FLAG_ACTIVITY_PREVIOUS_IS_TOP = 16777216;

  /// from: static public final int FLAG_ACTIVITY_REORDER_TO_FRONT
  ///
  /// If set in an Intent passed to Context\#startActivity Context.startActivity(),
  /// this flag will cause the launched activity to be brought to the front of its
  /// task's history stack if it is already running.
  ///
  /// For example, consider a task consisting of four activities: A, B, C, D.
  /// If D calls startActivity() with an Intent that resolves to the component
  /// of activity B, then B will be brought to the front of the history stack,
  /// with this resulting order:  A, C, D, B.
  ///
  /// This flag will be ignored if \#FLAG_ACTIVITY_CLEAR_TOP is also
  /// specified.
  static const FLAG_ACTIVITY_REORDER_TO_FRONT = 131072;

  /// from: static public final int FLAG_ACTIVITY_RESET_TASK_IF_NEEDED
  ///
  /// If set, and this activity is either being started in a new task or
  /// bringing to the top an existing task, then it will be launched as
  /// the front door of the task.  This will result in the application of
  /// any affinities needed to have that task in the proper state (either
  /// moving activities to or from it), or simply resetting that task to
  /// its initial state if needed.
  static const FLAG_ACTIVITY_RESET_TASK_IF_NEEDED = 2097152;

  /// from: static public final int FLAG_ACTIVITY_RETAIN_IN_RECENTS
  ///
  /// By default a document created by \#FLAG_ACTIVITY_NEW_DOCUMENT will
  /// have its entry in recent tasks removed when the user closes it (with back
  /// or however else it may finish()). If you would like to instead allow the
  /// document to be kept in recents so that it can be re-launched, you can use
  /// this flag. When set and the task's activity is finished, the recents
  /// entry will remain in the interface for the user to re-launch it, like a
  /// recents entry for a top-level application.
  ///
  /// The receiving activity can override this request with
  /// android.R.attr\#autoRemoveFromRecents or by explcitly calling
  /// android.app.Activity\#finishAndRemoveTask() Activity.finishAndRemoveTask().
  static const FLAG_ACTIVITY_RETAIN_IN_RECENTS = 8192;

  /// from: static public final int FLAG_ACTIVITY_SINGLE_TOP
  ///
  /// If set, the activity will not be launched if it is already running
  /// at the top of the history stack.
  static const FLAG_ACTIVITY_SINGLE_TOP = 536870912;

  /// from: static public final int FLAG_ACTIVITY_TASK_ON_HOME
  ///
  /// If set in an Intent passed to Context\#startActivity Context.startActivity(),
  /// this flag will cause a newly launching task to be placed on top of the current
  /// home activity task (if there is one).  That is, pressing back from the task
  /// will always return the user to home even if that was not the last activity they
  /// saw.   This can only be used in conjunction with \#FLAG_ACTIVITY_NEW_TASK.
  static const FLAG_ACTIVITY_TASK_ON_HOME = 16384;

  /// from: static public final int FLAG_DEBUG_LOG_RESOLUTION
  ///
  /// A flag you can enable for debugging: when set, log messages will be
  /// printed during the resolution of this intent to show you what has
  /// been found to create the final resolved list.
  static const FLAG_DEBUG_LOG_RESOLUTION = 8;

  /// from: static public final int FLAG_EXCLUDE_STOPPED_PACKAGES
  ///
  /// If set, this intent will not match any components in packages that
  /// are currently stopped.  If this is not set, then the default behavior
  /// is to include such applications in the result.
  static const FLAG_EXCLUDE_STOPPED_PACKAGES = 16;

  /// from: static public final int FLAG_FROM_BACKGROUND
  ///
  /// Can be set by the caller to indicate that this Intent is coming from
  /// a background operation, not from direct user interaction.
  static const FLAG_FROM_BACKGROUND = 4;

  /// from: static public final int FLAG_GRANT_PERSISTABLE_URI_PERMISSION
  ///
  /// When combined with \#FLAG_GRANT_READ_URI_PERMISSION and/or
  /// \#FLAG_GRANT_WRITE_URI_PERMISSION, the URI permission grant can be
  /// persisted across device reboots until explicitly revoked with
  /// Context\#revokeUriPermission(Uri, int). This flag only offers the
  /// grant for possible persisting; the receiving application must call
  /// ContentResolver\#takePersistableUriPermission(Uri, int) to
  /// actually persist.
  ///@see ContentResolver\#takePersistableUriPermission(Uri, int)
  ///@see ContentResolver\#releasePersistableUriPermission(Uri, int)
  ///@see ContentResolver\#getPersistedUriPermissions()
  ///@see ContentResolver\#getOutgoingPersistedUriPermissions()
  static const FLAG_GRANT_PERSISTABLE_URI_PERMISSION = 64;

  /// from: static public final int FLAG_GRANT_PREFIX_URI_PERMISSION
  ///
  /// When combined with \#FLAG_GRANT_READ_URI_PERMISSION and/or
  /// \#FLAG_GRANT_WRITE_URI_PERMISSION, the URI permission grant
  /// applies to any URI that is a prefix match against the original granted
  /// URI. (Without this flag, the URI must match exactly for access to be
  /// granted.) Another URI is considered a prefix match only when scheme,
  /// authority, and all path segments defined by the prefix are an exact
  /// match.
  static const FLAG_GRANT_PREFIX_URI_PERMISSION = 128;

  /// from: static public final int FLAG_GRANT_READ_URI_PERMISSION
  ///
  /// If set, the recipient of this Intent will be granted permission to
  /// perform read operations on the URI in the Intent's data and any URIs
  /// specified in its ClipData.  When applying to an Intent's ClipData,
  /// all URIs as well as recursive traversals through data or other ClipData
  /// in Intent items will be granted; only the grant flags of the top-level
  /// Intent are used.
  static const FLAG_GRANT_READ_URI_PERMISSION = 1;

  /// from: static public final int FLAG_GRANT_WRITE_URI_PERMISSION
  ///
  /// If set, the recipient of this Intent will be granted permission to
  /// perform write operations on the URI in the Intent's data and any URIs
  /// specified in its ClipData.  When applying to an Intent's ClipData,
  /// all URIs as well as recursive traversals through data or other ClipData
  /// in Intent items will be granted; only the grant flags of the top-level
  /// Intent are used.
  static const FLAG_GRANT_WRITE_URI_PERMISSION = 2;

  /// from: static public final int FLAG_INCLUDE_STOPPED_PACKAGES
  ///
  /// If set, this intent will always match any components in packages that
  /// are currently stopped.  This is the default behavior when
  /// \#FLAG_EXCLUDE_STOPPED_PACKAGES is not set.  If both of these
  /// flags are set, this one wins (it allows overriding of exclude for
  /// places where the framework may automatically set the exclude flag).
  static const FLAG_INCLUDE_STOPPED_PACKAGES = 32;

  /// from: static public final int FLAG_RECEIVER_FOREGROUND
  ///
  /// If set, when sending a broadcast the recipient is allowed to run at
  /// foreground priority, with a shorter timeout interval.  During normal
  /// broadcasts the receivers are not automatically hoisted out of the
  /// background priority class.
  static const FLAG_RECEIVER_FOREGROUND = 268435456;

  /// from: static public final int FLAG_RECEIVER_NO_ABORT
  ///
  /// If this is an ordered broadcast, don't allow receivers to abort the broadcast.
  /// They can still propagate results through to later receivers, but they can not prevent
  /// later receivers from seeing the broadcast.
  static const FLAG_RECEIVER_NO_ABORT = 134217728;

  /// from: static public final int FLAG_RECEIVER_REGISTERED_ONLY
  ///
  /// If set, when sending a broadcast only registered receivers will be
  /// called -- no BroadcastReceiver components will be launched.
  static const FLAG_RECEIVER_REGISTERED_ONLY = 1073741824;

  /// from: static public final int FLAG_RECEIVER_REPLACE_PENDING
  ///
  /// If set, when sending a broadcast the new broadcast will replace
  /// any existing pending broadcast that matches it.  Matching is defined
  /// by Intent\#filterEquals(Intent) Intent.filterEquals returning
  /// true for the intents of the two broadcasts.  When a match is found,
  /// the new broadcast (and receivers associated with it) will replace the
  /// existing one in the pending broadcast list, remaining at the same
  /// position in the list.
  ///
  /// This flag is most typically used with sticky broadcasts, which
  /// only care about delivering the most recent values of the broadcast
  /// to their receivers.
  static const FLAG_RECEIVER_REPLACE_PENDING = 536870912;

  /// from: static public final int FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///
  /// If set, the broadcast will be visible to receivers in Instant Apps. By default Instant Apps
  /// will not receive broadcasts.
  ///
  /// _This flag has no effect when used by an Instant App._
  static const FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS = 2097152;

  /// from: static public final java.lang.String METADATA_DOCK_HOME
  ///
  /// Boolean that can be supplied as meta-data with a dock activity, to
  /// indicate that the dock should take over the home key when it is active.
  static const METADATA_DOCK_HOME = "android.dock_home";

  /// from: static public final int URI_ALLOW_UNSAFE
  ///
  /// Flag for use with \#toUri and \#parseUri: allow parsing
  /// of unsafe information.  In particular, the flags \#FLAG_GRANT_READ_URI_PERMISSION,
  /// \#FLAG_GRANT_WRITE_URI_PERMISSION, \#FLAG_GRANT_PERSISTABLE_URI_PERMISSION,
  /// and \#FLAG_GRANT_PREFIX_URI_PERMISSION flags can not be set, so that the
  /// generated Intent can not cause unexpected data access to happen.
  ///
  /// If you do not trust the source of the URI being parsed, you should still do further
  /// processing to protect yourself from it.  In particular, when using it to start an
  /// activity you should usually add in \#CATEGORY_BROWSABLE to limit the activities
  /// that can handle it.
  ///
  static const URI_ALLOW_UNSAFE = 4;

  /// from: static public final int URI_ANDROID_APP_SCHEME
  ///
  /// Flag for use with \#toUri and \#parseUri: the URI string
  /// always has the "android-app:" scheme.  This is a variation of
  /// \#URI_INTENT_SCHEME whose format is simpler for the case of an
  /// http/https URI being delivered to a specific package name.  The format
  /// is:
  ///
  /// <pre class="prettyprint">
  /// android-app://{package_id}[/{scheme}[/{host}[/{path}]]][\#Intent;{...}]</pre>
  ///
  /// In this scheme, only the <code>package_id</code> is required.  If you include a host,
  /// you must also include a scheme; including a path also requires both a host and a scheme.
  /// The final \#Intent; fragment can be used without a scheme, host, or path.
  /// Note that this can not be
  /// used with intents that have a \#setSelector, since the base intent
  /// will always have an explicit package name.
  ///
  ///
  /// Some examples of how this scheme maps to Intent objects:
  ///
  /// <table border="2"width="85%"align="center"frame="hsides"rules="rows">
  ///     <colgroup align="left"/>
  ///     <colgroup align="left"/>
  ///     <thead>
  ///     <tr><th>URI</th> <th>Intent</th></tr>
  ///     </thead>
  ///
  ///     <tbody>
  ///     <tr><td><code>android-app://com.example.app</code></td>
  ///         <td><table style="margin:0;border:0;cellpadding:0;cellspacing:0">
  ///             <tr><td>Action: </td><td>\#ACTION_MAIN</td></tr>
  ///             <tr><td>Package: </td><td><code>com.example.app</code></td></tr>
  ///         </table></td>
  ///     </tr>
  ///     <tr><td><code>android-app://com.example.app/http/example.com</code></td>
  ///         <td><table style="margin:0;border:0;cellpadding:0;cellspacing:0">
  ///             <tr><td>Action: </td><td>\#ACTION_VIEW</td></tr>
  ///             <tr><td>Data: </td><td><code>http://example.com/</code></td></tr>
  ///             <tr><td>Package: </td><td><code>com.example.app</code></td></tr>
  ///         </table></td>
  ///     </tr>
  ///     <tr><td><code>android-app://com.example.app/http/example.com/foo?1234</code></td>
  ///         <td><table style="margin:0;border:0;cellpadding:0;cellspacing:0">
  ///             <tr><td>Action: </td><td>\#ACTION_VIEW</td></tr>
  ///             <tr><td>Data: </td><td><code>http://example.com/foo?1234</code></td></tr>
  ///             <tr><td>Package: </td><td><code>com.example.app</code></td></tr>
  ///         </table></td>
  ///     </tr>
  ///     <tr><td><code>android-app://com.example.app/<br/>\#Intent;action=com.example.MY_ACTION;end</code></td>
  ///         <td><table style="margin:0;border:0;cellpadding:0;cellspacing:0">
  ///             <tr><td>Action: </td><td><code>com.example.MY_ACTION</code></td></tr>
  ///             <tr><td>Package: </td><td><code>com.example.app</code></td></tr>
  ///         </table></td>
  ///     </tr>
  ///     <tr><td><code>android-app://com.example.app/http/example.com/foo?1234<br/>\#Intent;action=com.example.MY_ACTION;end</code></td>
  ///         <td><table style="margin:0;border:0;cellpadding:0;cellspacing:0">
  ///             <tr><td>Action: </td><td><code>com.example.MY_ACTION</code></td></tr>
  ///             <tr><td>Data: </td><td><code>http://example.com/foo?1234</code></td></tr>
  ///             <tr><td>Package: </td><td><code>com.example.app</code></td></tr>
  ///         </table></td>
  ///     </tr>
  ///     <tr><td><code>android-app://com.example.app/<br/>\#Intent;action=com.example.MY_ACTION;<br/>i.some_int=100;S.some_str=hello;end</code></td>
  ///         <td><table border=""style="margin:0">
  ///             <tr><td>Action: </td><td><code>com.example.MY_ACTION</code></td></tr>
  ///             <tr><td>Package: </td><td><code>com.example.app</code></td></tr>
  ///             <tr><td>Extras: </td><td><code>some_int=(int)100<br/>some_str=(String)hello</code></td></tr>
  ///         </table></td>
  ///     </tr>
  ///     </tbody>
  /// </table>
  static const URI_ANDROID_APP_SCHEME = 2;

  /// from: static public final int URI_INTENT_SCHEME
  ///
  /// Flag for use with \#toUri and \#parseUri: the URI string
  /// always has the "intent:" scheme.  This syntax can be used when you want
  /// to later disambiguate between URIs that are intended to describe an
  /// Intent vs. all others that should be treated as raw URIs.  When used
  /// with \#parseUri, any other scheme will result in a generic
  /// VIEW action for that raw URI.
  static const URI_INTENT_SCHEME = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an empty intent.
  Intent()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Intent;)V");

  /// from: public void <init>(android.content.Intent o)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copy constructor.
  Intent.ctor1(Intent o)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [o.reference]).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String action)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an intent with a given action.  All other fields (data, type,
  /// class) are null.  Note that the action _must_ be in a
  /// namespace because Intents are used globally in the system -- for
  /// example the system VIEW action is android.intent.action.VIEW; an
  /// application's custom action would be something like
  /// com.google.app.myapp.CUSTOM_ACTION.
  ///@param action The Intent action, such as ACTION_VIEW.
  Intent.ctor2(jni.JniString action)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [action.reference]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/String;Landroid/net/Uri;)V");

  /// from: public void <init>(java.lang.String action, android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an intent with a given action and for a given data url.  Note
  /// that the action _must_ be in a namespace because Intents are
  /// used globally in the system -- for example the system VIEW action is
  /// android.intent.action.VIEW; an application's custom action would be
  /// something like com.google.app.myapp.CUSTOM_ACTION.
  ///
  /// _Note: scheme and host name matching in the Android framework is
  /// case-sensitive, unlike the formal RFC.  As a result,
  /// you should always ensure that you write your Uri with these elements
  /// using lower case letters, and normalize any Uris you receive from
  /// outside of Android to ensure the scheme and host is lower case._
  ///
  ///@param action The Intent action, such as ACTION_VIEW.
  ///@param uri The Intent data URI.
  Intent.ctor3(jni.JniString action, uri_.Uri uri)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor3, [action.reference, uri.reference]).object);

  static final _id_ctor4 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;Ljava/lang/Class;)V");

  /// from: public void <init>(android.content.Context packageContext, java.lang.Class<?> cls)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an intent for a specific component.  All other fields (action, data,
  /// type, class) are null, though they can be modified later with explicit
  /// calls.  This provides a convenient way to create an intent that is
  /// intended to execute a hard-coded class name, rather than relying on the
  /// system to find an appropriate class for you; see \#setComponent
  /// for more information on the repercussions of this.
  ///@param packageContext A Context of the application package implementing
  /// this class.
  ///@param cls The component class that is to be used for the intent.
  ///@see \#setClass
  ///@see \#setComponent
  ///@see \#Intent(String, android.net.Uri , Context, Class)
  Intent.ctor4(context_.Context packageContext, jni.JniObject cls)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor4,
            [packageContext.reference, cls.reference]).object);

  static final _id_ctor5 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;Landroid/net/Uri;Landroid/content/Context;Ljava/lang/Class;)V");

  /// from: public void <init>(java.lang.String action, android.net.Uri uri, android.content.Context packageContext, java.lang.Class<?> cls)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an intent for a specific component with a specified action and data.
  /// This is equivalent to using \#Intent(String, android.net.Uri) to
  /// construct the Intent and then calling \#setClass to set its
  /// class.
  ///
  /// _Note: scheme and host name matching in the Android framework is
  /// case-sensitive, unlike the formal RFC.  As a result,
  /// you should always ensure that you write your Uri with these elements
  /// using lower case letters, and normalize any Uris you receive from
  /// outside of Android to ensure the scheme and host is lower case._
  ///
  ///@param action The Intent action, such as ACTION_VIEW.
  ///@param uri The Intent data URI.
  ///@param packageContext A Context of the application package implementing
  /// this class.
  ///@param cls The component class that is to be used for the intent.
  ///@see \#Intent(String, android.net.Uri)
  ///@see \#Intent(Context, Class)
  ///@see \#setClass
  ///@see \#setComponent
  Intent.ctor5(jni.JniString action, uri_.Uri uri,
      context_.Context packageContext, jni.JniObject cls)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor5, [
          action.reference,
          uri.reference,
          packageContext.reference,
          cls.reference
        ]).object);

  static final _id_createChooser = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createChooser",
      "(Landroid/content/Intent;Ljava/lang/CharSequence;)Landroid/content/Intent;");

  /// from: static public android.content.Intent createChooser(android.content.Intent target, java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience function for creating a \#ACTION_CHOOSER Intent.
  ///
  /// Builds a new \#ACTION_CHOOSER Intent that wraps the given
  /// target intent, also optionally supplying a title.  If the target
  /// intent has specified \#FLAG_GRANT_READ_URI_PERMISSION or
  /// \#FLAG_GRANT_WRITE_URI_PERMISSION, then these flags will also be
  /// set in the returned chooser intent, with its ClipData set appropriately:
  /// either a direct reflection of \#getClipData() if that is non-null,
  /// or a new ClipData built from \#getData().
  ///@param target The Intent that the user will be selecting an activity
  /// to perform.
  ///@param title Optional title that will be displayed in the chooser.
  ///@return Return a new Intent object that you can hand to
  /// Context\#startActivity(Intent) Context.startActivity() and
  /// related methods.
  static Intent createChooser(Intent target, jni.JniObject title) =>
      Intent.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createChooser,
          jni.JniType.objectType,
          [target.reference, title.reference]).object);

  static final _id_createChooser1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createChooser",
      "(Landroid/content/Intent;Ljava/lang/CharSequence;Landroid/content/IntentSender;)Landroid/content/Intent;");

  /// from: static public android.content.Intent createChooser(android.content.Intent target, java.lang.CharSequence title, android.content.IntentSender sender)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience function for creating a \#ACTION_CHOOSER Intent.
  ///
  /// Builds a new \#ACTION_CHOOSER Intent that wraps the given
  /// target intent, also optionally supplying a title.  If the target
  /// intent has specified \#FLAG_GRANT_READ_URI_PERMISSION or
  /// \#FLAG_GRANT_WRITE_URI_PERMISSION, then these flags will also be
  /// set in the returned chooser intent, with its ClipData set appropriately:
  /// either a direct reflection of \#getClipData() if that is non-null,
  /// or a new ClipData built from \#getData().
  ///
  ///
  /// The caller may optionally supply an IntentSender to receive a callback
  /// when the user makes a choice. This can be useful if the calling application wants
  /// to remember the last chosen target and surface it as a more prominent or one-touch
  /// affordance elsewhere in the UI for next time.
  ///
  ///@param target The Intent that the user will be selecting an activity
  /// to perform.
  ///@param title Optional title that will be displayed in the chooser.
  ///@param sender Optional IntentSender to be called when a choice is made.
  ///@return Return a new Intent object that you can hand to
  /// Context\#startActivity(Intent) Context.startActivity() and
  /// related methods.
  static Intent createChooser1(Intent target, jni.JniObject title,
          intentsender_.IntentSender sender) =>
      Intent.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createChooser1,
          jni.JniType.objectType,
          [target.reference, title.reference, sender.reference]).object);

  static final _id_clone =
      jniAccessors.getMethodIDOf(_classRef, "clone", "()Ljava/lang/Object;");

  /// from: public java.lang.Object clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject clone() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_cloneFilter = jniAccessors.getMethodIDOf(
      _classRef, "cloneFilter", "()Landroid/content/Intent;");

  /// from: public android.content.Intent cloneFilter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Make a clone of only the parts of the Intent that are relevant for
  /// filter matching: the action, data, type, component, and categories.
  ///@return This value will never be {@code null}.
  Intent cloneFilter() => Intent.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_cloneFilter, jni.JniType.objectType, []).object);

  static final _id_makeMainActivity = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "makeMainActivity",
      "(Landroid/content/ComponentName;)Landroid/content/Intent;");

  /// from: static public android.content.Intent makeMainActivity(android.content.ComponentName mainActivity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an intent to launch the main (root) activity of a task.  This
  /// is the Intent that is started when the application's is launched from
  /// Home.  For anything else that wants to launch an application in the
  /// same way, it is important that they use an Intent structured the same
  /// way, and can use this function to ensure this is the case.
  ///
  /// The returned Intent has the given Activity component as its explicit
  /// component, \#ACTION_MAIN as its action, and includes the
  /// category \#CATEGORY_LAUNCHER.  This does _not_ have
  /// \#FLAG_ACTIVITY_NEW_TASK set, though typically you will want
  /// to do that through \#addFlags(int) on the returned Intent.
  ///@param mainActivity The main activity component that this Intent will
  /// launch.
  ///@return Returns a newly created Intent that can be used to launch the
  /// activity as a main application entry.
  ///@see \#setClass
  ///@see \#setComponent
  static Intent makeMainActivity(componentname_.ComponentName mainActivity) =>
      Intent.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_makeMainActivity,
          jni.JniType.objectType,
          [mainActivity.reference]).object);

  static final _id_makeMainSelectorActivity = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "makeMainSelectorActivity",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/content/Intent;");

  /// from: static public android.content.Intent makeMainSelectorActivity(java.lang.String selectorAction, java.lang.String selectorCategory)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Make an Intent for the main activity of an application, without
  /// specifying a specific activity to run but giving a selector to find
  /// the activity.  This results in a final Intent that is structured
  /// the same as when the application is launched from
  /// Home.  For anything else that wants to launch an application in the
  /// same way, it is important that they use an Intent structured the same
  /// way, and can use this function to ensure this is the case.
  ///
  /// The returned Intent has \#ACTION_MAIN as its action, and includes the
  /// category \#CATEGORY_LAUNCHER.  This does _not_ have
  /// \#FLAG_ACTIVITY_NEW_TASK set, though typically you will want
  /// to do that through \#addFlags(int) on the returned Intent.
  ///@param selectorAction The action name of the Intent's selector.
  ///@param selectorCategory The name of a category to add to the Intent's
  /// selector.
  ///@return Returns a newly created Intent that can be used to launch the
  /// activity as a main application entry.
  ///@see \#setSelector(Intent)
  static Intent makeMainSelectorActivity(
          jni.JniString selectorAction, jni.JniString selectorCategory) =>
      Intent.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_makeMainSelectorActivity,
          jni.JniType.objectType,
          [selectorAction.reference, selectorCategory.reference]).object);

  static final _id_makeRestartActivityTask = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "makeRestartActivityTask",
      "(Landroid/content/ComponentName;)Landroid/content/Intent;");

  /// from: static public android.content.Intent makeRestartActivityTask(android.content.ComponentName mainActivity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Make an Intent that can be used to re-launch an application's task
  /// in its base state.  This is like \#makeMainActivity(ComponentName),
  /// but also sets the flags \#FLAG_ACTIVITY_NEW_TASK and
  /// \#FLAG_ACTIVITY_CLEAR_TASK.
  ///@param mainActivity The activity component that is the root of the
  /// task; this is the activity that has been published in the application's
  /// manifest as the main launcher icon.
  ///@return Returns a newly created Intent that can be used to relaunch the
  /// activity's task in its root state.
  static Intent makeRestartActivityTask(
          componentname_.ComponentName mainActivity) =>
      Intent.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_makeRestartActivityTask,
          jni.JniType.objectType,
          [mainActivity.reference]).object);

  static final _id_getIntent = jniAccessors.getStaticMethodIDOf(
      _classRef, "getIntent", "(Ljava/lang/String;)Landroid/content/Intent;");

  /// from: static public android.content.Intent getIntent(java.lang.String uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call \#parseUri with 0 flags.
  ///@deprecated Use \#parseUri instead.
  static Intent getIntent(jni.JniString uri) =>
      Intent.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getIntent, jni.JniType.objectType, [uri.reference]).object);

  static final _id_parseUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "parseUri", "(Ljava/lang/String;I)Landroid/content/Intent;");

  /// from: static public android.content.Intent parseUri(java.lang.String uri, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an intent from a URI.  This URI may encode the action,
  /// category, and other intent fields, if it was returned by
  /// \#toUri.  If the Intent was not generate by toUri(), its data
  /// will be the entire URI and its action will be ACTION_VIEW.
  ///
  /// The URI given here must not be relative -- that is, it must include
  /// the scheme and full path.
  ///@param uri The URI to turn into an Intent.
  ///@param flags Additional processing flags.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#URI_ALLOW_UNSAFE, android.content.Intent\#URI_ANDROID_APP_SCHEME, and android.content.Intent\#URI_INTENT_SCHEME
  ///@return Intent The newly created Intent object.
  ///@throws URISyntaxException Throws URISyntaxError if the basic URI syntax
  /// it bad (as parsed by the Uri class) or the Intent data within the
  /// URI is invalid.
  ///@see \#toUri
  static Intent parseUri(jni.JniString uri, int flags) =>
      Intent.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_parseUri, jni.JniType.objectType, [uri.reference, flags]).object);

  static final _id_getIntentOld = jniAccessors.getStaticMethodIDOf(_classRef,
      "getIntentOld", "(Ljava/lang/String;)Landroid/content/Intent;");

  /// from: static public android.content.Intent getIntentOld(java.lang.String uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Intent getIntentOld(jni.JniString uri) =>
      Intent.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getIntentOld, jni.JniType.objectType, [uri.reference]).object);

  static final _id_getAction = jniAccessors.getMethodIDOf(
      _classRef, "getAction", "()Ljava/lang/String;");

  /// from: public java.lang.String getAction()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the general action to be performed, such as
  /// \#ACTION_VIEW.  The action describes the general way the rest of
  /// the information in the intent should be interpreted -- most importantly,
  /// what to do with the data returned by \#getData.
  ///@return The action of this intent or null if none is specified.
  ///@see \#setAction
  jni.JniString getAction() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAction, jni.JniType.objectType, []).object);

  static final _id_getData =
      jniAccessors.getMethodIDOf(_classRef, "getData", "()Landroid/net/Uri;");

  /// from: public android.net.Uri getData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve data this intent is operating on.  This URI specifies the name
  /// of the data; often it uses the content: scheme, specifying data in a
  /// content provider.  Other schemes may be handled by specific activities,
  /// such as http: by the web browser.
  ///@return The URI of the data this intent is targeting or null.
  ///@see \#getScheme
  ///@see \#setData
  uri_.Uri getData() => uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getData, jni.JniType.objectType, []).object);

  static final _id_getDataString = jniAccessors.getMethodIDOf(
      _classRef, "getDataString", "()Ljava/lang/String;");

  /// from: public java.lang.String getDataString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The same as \#getData(), but returns the URI as an encoded
  /// String.
  ///@return This value may be {@code null}.
  jni.JniString getDataString() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDataString, jni.JniType.objectType, []).object);

  static final _id_getScheme = jniAccessors.getMethodIDOf(
      _classRef, "getScheme", "()Ljava/lang/String;");

  /// from: public java.lang.String getScheme()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the scheme portion of the intent's data.  If the data is null or
  /// does not include a scheme, null is returned.  Otherwise, the scheme
  /// prefix without the final ':' is returned, i.e. "http".
  ///
  /// This is the same as calling getData().getScheme() (and checking for
  /// null data).
  ///@return The scheme of this intent.
  ///@see \#getData
  jni.JniString getScheme() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getScheme, jni.JniType.objectType, []).object);

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "()Ljava/lang/String;");

  /// from: public java.lang.String getType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve any explicit MIME type included in the intent.  This is usually
  /// null, as the type is determined by the intent data.
  ///@return If a type was manually set, it is returned; else null is
  ///         returned.
  ///@see \#resolveType(ContentResolver)
  ///@see \#setType
  jni.JniString getType() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getType, jni.JniType.objectType, []).object);

  static final _id_resolveType = jniAccessors.getMethodIDOf(_classRef,
      "resolveType", "(Landroid/content/Context;)Ljava/lang/String;");

  /// from: public java.lang.String resolveType(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the MIME data type of this intent.  If the type field is
  /// explicitly set, that is simply returned.  Otherwise, if the data is set,
  /// the type of that data is returned.  If neither fields are set, a null is
  /// returned.
  ///@param context This value must never be {@code null}.
  ///@return The MIME type of this intent.
  ///@see \#getType
  ///@see \#resolveType(ContentResolver)
  jni.JniString resolveType(context_.Context context) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_resolveType, jni.JniType.objectType, [context.reference]).object);

  static final _id_resolveType1 = jniAccessors.getMethodIDOf(_classRef,
      "resolveType", "(Landroid/content/ContentResolver;)Ljava/lang/String;");

  /// from: public java.lang.String resolveType(android.content.ContentResolver resolver)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the MIME data type of this intent.  If the type field is
  /// explicitly set, that is simply returned.  Otherwise, if the data is set,
  /// the type of that data is returned.  If neither fields are set, a null is
  /// returned.
  ///@param resolver A ContentResolver that can be used to determine the MIME
  ///                 type of the intent's data.
  ///
  /// This value must never be {@code null}.
  ///@return The MIME type of this intent.
  ///@see \#getType
  ///@see \#resolveType(Context)
  jni.JniString resolveType1(contentresolver_.ContentResolver resolver) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_resolveType1,
          jni.JniType.objectType,
          [resolver.reference]).object);

  static final _id_resolveTypeIfNeeded = jniAccessors.getMethodIDOf(
      _classRef,
      "resolveTypeIfNeeded",
      "(Landroid/content/ContentResolver;)Ljava/lang/String;");

  /// from: public java.lang.String resolveTypeIfNeeded(android.content.ContentResolver resolver)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the MIME data type of this intent, only if it will be needed for
  /// intent resolution.  This is not generally useful for application code;
  /// it is used by the frameworks for communicating with back-end system
  /// services.
  ///@param resolver A ContentResolver that can be used to determine the MIME
  ///                 type of the intent's data.
  ///
  /// This value must never be {@code null}.
  ///@return The MIME type of this intent, or null if it is unknown or not
  ///         needed.
  jni.JniString resolveTypeIfNeeded(
          contentresolver_.ContentResolver resolver) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_resolveTypeIfNeeded,
          jni.JniType.objectType,
          [resolver.reference]).object);

  static final _id_hasCategory = jniAccessors.getMethodIDOf(
      _classRef, "hasCategory", "(Ljava/lang/String;)Z");

  /// from: public boolean hasCategory(java.lang.String category)
  ///
  /// Check if a category exists in the intent.
  ///@param category The category to check.
  ///@return boolean True if the intent contains the category, else false.
  ///@see \#getCategories
  ///@see \#addCategory
  bool hasCategory(jni.JniString category) => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasCategory,
      jni.JniType.booleanType,
      [category.reference]).boolean;

  static final _id_getCategories = jniAccessors.getMethodIDOf(
      _classRef, "getCategories", "()Ljava/util/Set;");

  /// from: public java.util.Set<java.lang.String> getCategories()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the set of all categories in the intent.  If there are no categories,
  /// returns NULL.
  ///@return The set of categories you can examine.  Do not modify!
  ///@see \#hasCategory
  ///@see \#addCategory
  jni.JniObject getCategories() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCategories, jni.JniType.objectType, []).object);

  static final _id_getSelector = jniAccessors.getMethodIDOf(
      _classRef, "getSelector", "()Landroid/content/Intent;");

  /// from: public android.content.Intent getSelector()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the specific selector associated with this Intent.  If there is
  /// none, returns null.  See \#setSelector for more information.
  ///@see \#setSelector
  Intent getSelector() => Intent.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getSelector, jni.JniType.objectType, []).object);

  static final _id_getClipData = jniAccessors.getMethodIDOf(
      _classRef, "getClipData", "()Landroid/content/ClipData;");

  /// from: public android.content.ClipData getClipData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the ClipData associated with this Intent.  If there is
  /// none, returns null.  See \#setClipData for more information.
  ///@see \#setClipData
  clipdata_.ClipData getClipData() =>
      clipdata_.ClipData.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getClipData, jni.JniType.objectType, []).object);

  static final _id_setExtrasClassLoader = jniAccessors.getMethodIDOf(
      _classRef, "setExtrasClassLoader", "(Ljava/lang/ClassLoader;)V");

  /// from: public void setExtrasClassLoader(java.lang.ClassLoader loader)
  ///
  /// Sets the ClassLoader that will be used when unmarshalling
  /// any Parcelable values from the extras of this Intent.
  ///@param loader a ClassLoader, or null to use the default loader
  /// at the time of unmarshalling.
  ///
  /// This value may be {@code null}.
  void setExtrasClassLoader(jni.JniObject loader) =>
      jniAccessors.callMethodWithArgs(reference, _id_setExtrasClassLoader,
          jni.JniType.voidType, [loader.reference]).check();

  static final _id_hasExtra = jniAccessors.getMethodIDOf(
      _classRef, "hasExtra", "(Ljava/lang/String;)Z");

  /// from: public boolean hasExtra(java.lang.String name)
  ///
  /// Returns true if an extra value is associated with the given name.
  ///@param name the extra's name
  ///@return true if the given extra is present.
  bool hasExtra(jni.JniString name) => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasExtra,
      jni.JniType.booleanType,
      [name.reference]).boolean;

  static final _id_hasFileDescriptors =
      jniAccessors.getMethodIDOf(_classRef, "hasFileDescriptors", "()Z");

  /// from: public boolean hasFileDescriptors()
  ///
  /// Returns true if the Intent's extras contain a parcelled file descriptor.
  ///@return true if the Intent contains a parcelled file descriptor.
  bool hasFileDescriptors() => jniAccessors.callMethodWithArgs(
      reference, _id_hasFileDescriptors, jni.JniType.booleanType, []).boolean;

  static final _id_getBooleanExtra = jniAccessors.getMethodIDOf(
      _classRef, "getBooleanExtra", "(Ljava/lang/String;Z)Z");

  /// from: public boolean getBooleanExtra(java.lang.String name, boolean defaultValue)
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@param defaultValue the value to be returned if no value of the desired
  /// type is stored with the given name.
  ///@return the value of an item previously added with putExtra(),
  /// or the default value if none was found.
  ///@see \#putExtra(String, boolean)
  bool getBooleanExtra(jni.JniString name, bool defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getBooleanExtra,
          jni.JniType.booleanType, [name.reference, defaultValue]).boolean;

  static final _id_getByteExtra = jniAccessors.getMethodIDOf(
      _classRef, "getByteExtra", "(Ljava/lang/String;B)B");

  /// from: public byte getByteExtra(java.lang.String name, byte defaultValue)
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@param defaultValue the value to be returned if no value of the desired
  /// type is stored with the given name.
  ///@return the value of an item previously added with putExtra(),
  /// or the default value if none was found.
  ///@see \#putExtra(String, byte)
  int getByteExtra(jni.JniString name, int defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getByteExtra,
          jni.JniType.byteType, [name.reference, defaultValue]).byte;

  static final _id_getShortExtra = jniAccessors.getMethodIDOf(
      _classRef, "getShortExtra", "(Ljava/lang/String;S)S");

  /// from: public short getShortExtra(java.lang.String name, short defaultValue)
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@param defaultValue the value to be returned if no value of the desired
  /// type is stored with the given name.
  ///@return the value of an item previously added with putExtra(),
  /// or the default value if none was found.
  ///@see \#putExtra(String, short)
  int getShortExtra(jni.JniString name, int defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getShortExtra,
          jni.JniType.shortType, [name.reference, defaultValue]).short;

  static final _id_getCharExtra = jniAccessors.getMethodIDOf(
      _classRef, "getCharExtra", "(Ljava/lang/String;C)C");

  /// from: public char getCharExtra(java.lang.String name, char defaultValue)
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@param defaultValue the value to be returned if no value of the desired
  /// type is stored with the given name.
  ///@return the value of an item previously added with putExtra(),
  /// or the default value if none was found.
  ///@see \#putExtra(String, char)
  int getCharExtra(jni.JniString name, int defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getCharExtra,
          jni.JniType.charType, [name.reference, defaultValue]).char;

  static final _id_getIntExtra = jniAccessors.getMethodIDOf(
      _classRef, "getIntExtra", "(Ljava/lang/String;I)I");

  /// from: public int getIntExtra(java.lang.String name, int defaultValue)
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@param defaultValue the value to be returned if no value of the desired
  /// type is stored with the given name.
  ///@return the value of an item previously added with putExtra(),
  /// or the default value if none was found.
  ///@see \#putExtra(String, int)
  int getIntExtra(jni.JniString name, int defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getIntExtra,
          jni.JniType.intType, [name.reference, defaultValue]).integer;

  static final _id_getLongExtra = jniAccessors.getMethodIDOf(
      _classRef, "getLongExtra", "(Ljava/lang/String;J)J");

  /// from: public long getLongExtra(java.lang.String name, long defaultValue)
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@param defaultValue the value to be returned if no value of the desired
  /// type is stored with the given name.
  ///@return the value of an item previously added with putExtra(),
  /// or the default value if none was found.
  ///@see \#putExtra(String, long)
  int getLongExtra(jni.JniString name, int defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getLongExtra,
          jni.JniType.longType, [name.reference, defaultValue]).long;

  static final _id_getFloatExtra = jniAccessors.getMethodIDOf(
      _classRef, "getFloatExtra", "(Ljava/lang/String;F)F");

  /// from: public float getFloatExtra(java.lang.String name, float defaultValue)
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@param defaultValue the value to be returned if no value of the desired
  /// type is stored with the given name.
  ///@return the value of an item previously added with putExtra(),
  /// or the default value if no such item is present
  ///@see \#putExtra(String, float)
  double getFloatExtra(jni.JniString name, double defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getFloatExtra,
          jni.JniType.floatType, [name.reference, defaultValue]).float;

  static final _id_getDoubleExtra = jniAccessors.getMethodIDOf(
      _classRef, "getDoubleExtra", "(Ljava/lang/String;D)D");

  /// from: public double getDoubleExtra(java.lang.String name, double defaultValue)
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@param defaultValue the value to be returned if no value of the desired
  /// type is stored with the given name.
  ///@return the value of an item previously added with putExtra(),
  /// or the default value if none was found.
  ///@see \#putExtra(String, double)
  double getDoubleExtra(jni.JniString name, double defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getDoubleExtra,
          jni.JniType.doubleType, [name.reference, defaultValue]).doubleFloat;

  static final _id_getStringExtra = jniAccessors.getMethodIDOf(
      _classRef, "getStringExtra", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String getStringExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no String value was found.
  ///@see \#putExtra(String, String)
  jni.JniString getStringExtra(jni.JniString name) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getStringExtra, jni.JniType.objectType, [name.reference]).object);

  static final _id_getCharSequenceExtra = jniAccessors.getMethodIDOf(_classRef,
      "getCharSequenceExtra", "(Ljava/lang/String;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getCharSequenceExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no CharSequence value was found.
  ///@see \#putExtra(String, CharSequence)
  jni.JniObject getCharSequenceExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCharSequenceExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getParcelableArrayExtra = jniAccessors.getMethodIDOf(
      _classRef,
      "getParcelableArrayExtra",
      "(Ljava/lang/String;)[Landroid/os/Parcelable;");

  /// from: public android.os.Parcelable[] getParcelableArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no Parcelable[] value was found.
  ///@see \#putExtra(String, Parcelable[])
  jni.JniObject getParcelableArrayExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getParcelableArrayExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getParcelableArrayListExtra = jniAccessors.getMethodIDOf(
      _classRef,
      "getParcelableArrayListExtra",
      "(Ljava/lang/String;)Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList<T> getParcelableArrayListExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with
  /// putParcelableArrayListExtra(), or null if no
  /// ArrayList<Parcelable> value was found.
  ///@see \#putParcelableArrayListExtra(String, ArrayList)
  jni.JniObject getParcelableArrayListExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getParcelableArrayListExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getSerializableExtra = jniAccessors.getMethodIDOf(_classRef,
      "getSerializableExtra", "(Ljava/lang/String;)Ljava/io/Serializable;");

  /// from: public java.io.Serializable getSerializableExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no Serializable value was found.
  ///@see \#putExtra(String, Serializable)
  jni.JniObject getSerializableExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSerializableExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getIntegerArrayListExtra = jniAccessors.getMethodIDOf(
      _classRef,
      "getIntegerArrayListExtra",
      "(Ljava/lang/String;)Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList<java.lang.Integer> getIntegerArrayListExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with
  /// putIntegerArrayListExtra(), or null if no
  /// ArrayList<Integer> value was found.
  ///@see \#putIntegerArrayListExtra(String, ArrayList)
  jni.JniObject getIntegerArrayListExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getIntegerArrayListExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getStringArrayListExtra = jniAccessors.getMethodIDOf(
      _classRef,
      "getStringArrayListExtra",
      "(Ljava/lang/String;)Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList<java.lang.String> getStringArrayListExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with
  /// putStringArrayListExtra(), or null if no
  /// ArrayList<String> value was found.
  ///@see \#putStringArrayListExtra(String, ArrayList)
  jni.JniObject getStringArrayListExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getStringArrayListExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getCharSequenceArrayListExtra = jniAccessors.getMethodIDOf(
      _classRef,
      "getCharSequenceArrayListExtra",
      "(Ljava/lang/String;)Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList<java.lang.CharSequence> getCharSequenceArrayListExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with
  /// putCharSequenceArrayListExtra, or null if no
  /// ArrayList<CharSequence> value was found.
  ///@see \#putCharSequenceArrayListExtra(String, ArrayList)
  jni.JniObject getCharSequenceArrayListExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCharSequenceArrayListExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getBooleanArrayExtra = jniAccessors.getMethodIDOf(
      _classRef, "getBooleanArrayExtra", "(Ljava/lang/String;)[Z");

  /// from: public boolean[] getBooleanArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no boolean array value was found.
  ///@see \#putExtra(String, boolean[])
  jni.JniObject getBooleanArrayExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getBooleanArrayExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getByteArrayExtra = jniAccessors.getMethodIDOf(
      _classRef, "getByteArrayExtra", "(Ljava/lang/String;)[B");

  /// from: public byte[] getByteArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no byte array value was found.
  ///@see \#putExtra(String, byte[])
  jni.JniObject getByteArrayExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getByteArrayExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getShortArrayExtra = jniAccessors.getMethodIDOf(
      _classRef, "getShortArrayExtra", "(Ljava/lang/String;)[S");

  /// from: public short[] getShortArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no short array value was found.
  ///@see \#putExtra(String, short[])
  jni.JniObject getShortArrayExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getShortArrayExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getCharArrayExtra = jniAccessors.getMethodIDOf(
      _classRef, "getCharArrayExtra", "(Ljava/lang/String;)[C");

  /// from: public char[] getCharArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no char array value was found.
  ///@see \#putExtra(String, char[])
  jni.JniObject getCharArrayExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCharArrayExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getIntArrayExtra = jniAccessors.getMethodIDOf(
      _classRef, "getIntArrayExtra", "(Ljava/lang/String;)[I");

  /// from: public int[] getIntArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no int array value was found.
  ///@see \#putExtra(String, int[])
  jni.JniObject getIntArrayExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getIntArrayExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getLongArrayExtra = jniAccessors.getMethodIDOf(
      _classRef, "getLongArrayExtra", "(Ljava/lang/String;)[J");

  /// from: public long[] getLongArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no long array value was found.
  ///@see \#putExtra(String, long[])
  jni.JniObject getLongArrayExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getLongArrayExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getFloatArrayExtra = jniAccessors.getMethodIDOf(
      _classRef, "getFloatArrayExtra", "(Ljava/lang/String;)[F");

  /// from: public float[] getFloatArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no float array value was found.
  ///@see \#putExtra(String, float[])
  jni.JniObject getFloatArrayExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getFloatArrayExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getDoubleArrayExtra = jniAccessors.getMethodIDOf(
      _classRef, "getDoubleArrayExtra", "(Ljava/lang/String;)[D");

  /// from: public double[] getDoubleArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no double array value was found.
  ///@see \#putExtra(String, double[])
  jni.JniObject getDoubleArrayExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDoubleArrayExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getStringArrayExtra = jniAccessors.getMethodIDOf(_classRef,
      "getStringArrayExtra", "(Ljava/lang/String;)[Ljava/lang/String;");

  /// from: public java.lang.String[] getStringArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no String array value was found.
  ///@see \#putExtra(String, String[])
  jni.JniObject getStringArrayExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getStringArrayExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getCharSequenceArrayExtra = jniAccessors.getMethodIDOf(
      _classRef,
      "getCharSequenceArrayExtra",
      "(Ljava/lang/String;)[Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence[] getCharSequenceArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no CharSequence array value was found.
  ///@see \#putExtra(String, CharSequence[])
  jni.JniObject getCharSequenceArrayExtra(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCharSequenceArrayExtra,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getBundleExtra = jniAccessors.getMethodIDOf(
      _classRef, "getBundleExtra", "(Ljava/lang/String;)Landroid/os/Bundle;");

  /// from: public android.os.Bundle getBundleExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no Bundle value was found.
  ///@see \#putExtra(String, Bundle)
  bundle_.Bundle getBundleExtra(jni.JniString name) =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getBundleExtra, jni.JniType.objectType, [name.reference]).object);

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves a map of extended data from the intent.
  ///@return the map of all extras previously added with putExtra(),
  /// or null if none have been added.
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_getFlags =
      jniAccessors.getMethodIDOf(_classRef, "getFlags", "()I");

  /// from: public int getFlags()
  ///
  /// Retrieve any special flags associated with this intent.  You will
  /// normally just set them with \#setFlags and let the system
  /// take the appropriate action with them.
  ///@return The currently set flags.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION, android.content.Intent\#FLAG_FROM_BACKGROUND, android.content.Intent\#FLAG_DEBUG_LOG_RESOLUTION, android.content.Intent\#FLAG_EXCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_INCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_GRANT_PERSISTABLE_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_PREFIX_URI_PERMISSION, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, android.content.Intent\#FLAG_ACTIVITY_MATCH_EXTERNAL, android.content.Intent\#FLAG_ACTIVITY_NO_HISTORY, android.content.Intent\#FLAG_ACTIVITY_SINGLE_TOP, android.content.Intent\#FLAG_ACTIVITY_NEW_TASK, android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TOP, android.content.Intent\#FLAG_ACTIVITY_FORWARD_RESULT, android.content.Intent\#FLAG_ACTIVITY_PREVIOUS_IS_TOP, android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, android.content.Intent\#FLAG_ACTIVITY_BROUGHT_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED, android.content.Intent\#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NO_USER_ACTION, android.content.Intent\#FLAG_ACTIVITY_REORDER_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_NO_ANIMATION, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TASK, android.content.Intent\#FLAG_ACTIVITY_TASK_ON_HOME, android.content.Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS, android.content.Intent\#FLAG_ACTIVITY_LAUNCH_ADJACENT, android.content.Intent\#FLAG_RECEIVER_REGISTERED_ONLY, android.content.Intent\#FLAG_RECEIVER_REPLACE_PENDING, android.content.Intent\#FLAG_RECEIVER_FOREGROUND, android.content.Intent\#FLAG_RECEIVER_NO_ABORT, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, and android.content.Intent\#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@see \#setFlags
  ///@see \#addFlags
  ///@see \#removeFlags
  int getFlags() => jniAccessors.callMethodWithArgs(
      reference, _id_getFlags, jni.JniType.intType, []).integer;

  static final _id_getPackage = jniAccessors.getMethodIDOf(
      _classRef, "getPackage", "()Ljava/lang/String;");

  /// from: public java.lang.String getPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the application package name this Intent is limited to.  When
  /// resolving an Intent, if non-null this limits the resolution to only
  /// components in the given application package.
  ///@return The name of the application package for the Intent.
  ///@see \#resolveActivity
  ///@see \#setPackage
  jni.JniString getPackage() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPackage, jni.JniType.objectType, []).object);

  static final _id_getComponent = jniAccessors.getMethodIDOf(
      _classRef, "getComponent", "()Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName getComponent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the concrete component associated with the intent.  When receiving
  /// an intent, this is the component that was found to best handle it (that is,
  /// yourself) and will always be non-null; in all other cases it will be
  /// null unless explicitly set.
  ///@return The name of the application component to handle the intent.
  ///@see \#resolveActivity
  ///@see \#setComponent
  componentname_.ComponentName getComponent() =>
      componentname_.ComponentName.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getComponent, jni.JniType.objectType, []).object);

  static final _id_getSourceBounds = jniAccessors.getMethodIDOf(
      _classRef, "getSourceBounds", "()Landroid/graphics/Rect;");

  /// from: public android.graphics.Rect getSourceBounds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the bounds of the sender of this intent, in screen coordinates.  This can be
  /// used as a hint to the receiver for animations and the like.  Null means that there
  /// is no source bounds.
  ///@return This value may be {@code null}.
  rect_.Rect getSourceBounds() =>
      rect_.Rect.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSourceBounds, jni.JniType.objectType, []).object);

  static final _id_resolveActivity = jniAccessors.getMethodIDOf(
      _classRef,
      "resolveActivity",
      "(Landroid/content/pm/PackageManager;)Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName resolveActivity(android.content.pm.PackageManager pm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Activity component that should be used to handle this intent.
  /// The appropriate component is determined based on the information in the
  /// intent, evaluated as follows:
  ///
  /// If \#getComponent returns an explicit class, that is returned
  /// without any further consideration.
  ///
  /// The activity must handle the Intent\#CATEGORY_DEFAULT Intent
  /// category to be considered.
  ///
  /// If \#getAction is non-NULL, the activity must handle this
  /// action.
  ///
  /// If \#resolveType returns non-NULL, the activity must handle
  /// this type.
  ///
  /// If \#addCategory has added any categories, the activity must
  /// handle ALL of the categories specified.
  ///
  /// If \#getPackage is non-NULL, only activity components in
  /// that application package will be considered.
  ///
  /// If there are no activities that satisfy all of these conditions, a
  /// null string is returned.
  ///
  /// If multiple activities are found to satisfy the intent, the one with
  /// the highest priority will be used.  If there are multiple activities
  /// with the same priority, the system will either pick the best activity
  /// based on user preference, or resolve to a system class that will allow
  /// the user to pick an activity and forward from there.
  ///
  /// This method is implemented simply by calling
  /// PackageManager\#resolveActivity with the "defaultOnly" parameter
  /// true.
  ///
  ///  This API is called for you as part of starting an activity from an
  /// intent.  You do not normally need to call it yourself.
  ///
  ///@param pm The package manager with which to resolve the Intent.
  ///
  /// This value must never be {@code null}.
  ///@return Name of the component implementing an activity that can
  ///         display the intent.
  ///@see \#setComponent
  ///@see \#getComponent
  ///@see \#resolveActivityInfo
  componentname_.ComponentName resolveActivity(
          packagemanager_.PackageManager pm) =>
      componentname_.ComponentName.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_resolveActivity,
          jni.JniType.objectType,
          [pm.reference]).object);

  static final _id_resolveActivityInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "resolveActivityInfo",
      "(Landroid/content/pm/PackageManager;I)Landroid/content/pm/ActivityInfo;");

  /// from: public android.content.pm.ActivityInfo resolveActivityInfo(android.content.pm.PackageManager pm, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Resolve the Intent into an ActivityInfo
  /// describing the activity that should execute the intent.  Resolution
  /// follows the same rules as described for \#resolveActivity, but
  /// you get back the completely information about the resolved activity
  /// instead of just its class name.
  ///@param pm The package manager with which to resolve the Intent.
  /// This value must never be {@code null}.
  ///@param flags Addition information to retrieve as per
  /// PackageManager\#getActivityInfo(ComponentName, int) PackageManager.getActivityInfo().
  ///
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return PackageManager.ActivityInfo
  ///@see \#resolveActivity
  activityinfo_.ActivityInfo resolveActivityInfo(
          packagemanager_.PackageManager pm, int flags) =>
      activityinfo_.ActivityInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_resolveActivityInfo,
          jni.JniType.objectType,
          [pm.reference, flags]).object);

  static final _id_setAction = jniAccessors.getMethodIDOf(
      _classRef, "setAction", "(Ljava/lang/String;)Landroid/content/Intent;");

  /// from: public android.content.Intent setAction(java.lang.String action)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the general action to be performed.
  ///@param action An action name, such as ACTION_VIEW.  Application-specific
  ///               actions should be prefixed with the vendor's package name.
  ///
  /// This value may be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#getAction
  Intent setAction(jni.JniString action) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_setAction,
          jni.JniType.objectType, [action.reference]).object);

  static final _id_setData = jniAccessors.getMethodIDOf(
      _classRef, "setData", "(Landroid/net/Uri;)Landroid/content/Intent;");

  /// from: public android.content.Intent setData(android.net.Uri data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the data this intent is operating on.  This method automatically
  /// clears any type that was previously set by \#setType or
  /// \#setTypeAndNormalize.
  ///
  /// _Note: scheme matching in the Android framework is
  /// case-sensitive, unlike the formal RFC. As a result,
  /// you should always write your Uri with a lower case scheme,
  /// or use Uri\#normalizeScheme or
  /// \#setDataAndNormalize
  /// to ensure that the scheme is converted to lower case._
  ///@param data The Uri of the data this intent is now targeting.
  ///
  /// This value may be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#getData
  ///@see \#setDataAndNormalize
  ///@see android.net.Uri\#normalizeScheme()
  Intent setData(uri_.Uri data) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_setData,
          jni.JniType.objectType, [data.reference]).object);

  static final _id_setDataAndNormalize = jniAccessors.getMethodIDOf(_classRef,
      "setDataAndNormalize", "(Landroid/net/Uri;)Landroid/content/Intent;");

  /// from: public android.content.Intent setDataAndNormalize(android.net.Uri data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Normalize and set the data this intent is operating on.
  ///
  /// This method automatically clears any type that was
  /// previously set (for example, by \#setType).
  ///
  /// The data Uri is normalized using
  /// android.net.Uri\#normalizeScheme before it is set,
  /// so really this is just a convenience method for
  /// <pre>
  /// setData(data.normalize())
  /// </pre>
  ///@param data The Uri of the data this intent is now targeting.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#getData
  ///@see \#setType
  ///@see android.net.Uri\#normalizeScheme
  Intent setDataAndNormalize(uri_.Uri data) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setDataAndNormalize,
          jni.JniType.objectType,
          [data.reference]).object);

  static final _id_setType = jniAccessors.getMethodIDOf(
      _classRef, "setType", "(Ljava/lang/String;)Landroid/content/Intent;");

  /// from: public android.content.Intent setType(java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set an explicit MIME data type.
  ///
  /// This is used to create intents that only specify a type and not data,
  /// for example to indicate the type of data to return.
  ///
  /// This method automatically clears any data that was
  /// previously set (for example by \#setData).
  ///
  /// _Note: MIME type matching in the Android framework is
  /// case-sensitive, unlike formal RFC MIME types.  As a result,
  /// you should always write your MIME types with lower case letters,
  /// or use \#normalizeMimeType or \#setTypeAndNormalize
  /// to ensure that it is converted to lower case._
  ///@param type The MIME type of the data being handled by this intent.
  ///
  /// This value may be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#getType
  ///@see \#setTypeAndNormalize
  ///@see \#setDataAndType
  ///@see \#normalizeMimeType
  Intent setType(jni.JniString type) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_setType,
          jni.JniType.objectType, [type.reference]).object);

  static final _id_setTypeAndNormalize = jniAccessors.getMethodIDOf(_classRef,
      "setTypeAndNormalize", "(Ljava/lang/String;)Landroid/content/Intent;");

  /// from: public android.content.Intent setTypeAndNormalize(java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Normalize and set an explicit MIME data type.
  ///
  /// This is used to create intents that only specify a type and not data,
  /// for example to indicate the type of data to return.
  ///
  /// This method automatically clears any data that was
  /// previously set (for example by \#setData).
  ///
  /// The MIME type is normalized using
  /// \#normalizeMimeType before it is set,
  /// so really this is just a convenience method for
  /// <pre>
  /// setType(Intent.normalizeMimeType(type))
  /// </pre>
  ///@param type The MIME type of the data being handled by this intent.
  ///
  /// This value may be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#getType
  ///@see \#setData
  ///@see \#normalizeMimeType
  Intent setTypeAndNormalize(jni.JniString type) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setTypeAndNormalize,
          jni.JniType.objectType,
          [type.reference]).object);

  static final _id_setDataAndType = jniAccessors.getMethodIDOf(
      _classRef,
      "setDataAndType",
      "(Landroid/net/Uri;Ljava/lang/String;)Landroid/content/Intent;");

  /// from: public android.content.Intent setDataAndType(android.net.Uri data, java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// (Usually optional) Set the data for the intent along with an explicit
  /// MIME data type.  This method should very rarely be used -- it allows you
  /// to override the MIME type that would ordinarily be inferred from the
  /// data with your own type given here.
  ///
  /// _Note: MIME type and Uri scheme matching in the
  /// Android framework is case-sensitive, unlike the formal RFC definitions.
  /// As a result, you should always write these elements with lower case letters,
  /// or use \#normalizeMimeType or android.net.Uri\#normalizeScheme or
  /// \#setDataAndTypeAndNormalize
  /// to ensure that they are converted to lower case._
  ///@param data The Uri of the data this intent is now targeting.
  /// This value may be {@code null}.
  ///@param type The MIME type of the data being handled by this intent.
  ///
  /// This value may be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#setType
  ///@see \#setData
  ///@see \#normalizeMimeType
  ///@see android.net.Uri\#normalizeScheme
  ///@see \#setDataAndTypeAndNormalize
  Intent setDataAndType(uri_.Uri data, jni.JniString type) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setDataAndType,
          jni.JniType.objectType,
          [data.reference, type.reference]).object);

  static final _id_setDataAndTypeAndNormalize = jniAccessors.getMethodIDOf(
      _classRef,
      "setDataAndTypeAndNormalize",
      "(Landroid/net/Uri;Ljava/lang/String;)Landroid/content/Intent;");

  /// from: public android.content.Intent setDataAndTypeAndNormalize(android.net.Uri data, java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// (Usually optional) Normalize and set both the data Uri and an explicit
  /// MIME data type.  This method should very rarely be used -- it allows you
  /// to override the MIME type that would ordinarily be inferred from the
  /// data with your own type given here.
  ///
  /// The data Uri and the MIME type are normalize using
  /// android.net.Uri\#normalizeScheme and \#normalizeMimeType
  /// before they are set, so really this is just a convenience method for
  /// <pre>
  /// setDataAndType(data.normalize(), Intent.normalizeMimeType(type))
  /// </pre>
  ///@param data The Uri of the data this intent is now targeting.
  /// This value must never be {@code null}.
  ///@param type The MIME type of the data being handled by this intent.
  ///
  /// This value may be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#setType
  ///@see \#setData
  ///@see \#setDataAndType
  ///@see \#normalizeMimeType
  ///@see android.net.Uri\#normalizeScheme
  Intent setDataAndTypeAndNormalize(uri_.Uri data, jni.JniString type) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setDataAndTypeAndNormalize,
          jni.JniType.objectType,
          [data.reference, type.reference]).object);

  static final _id_addCategory = jniAccessors.getMethodIDOf(
      _classRef, "addCategory", "(Ljava/lang/String;)Landroid/content/Intent;");

  /// from: public android.content.Intent addCategory(java.lang.String category)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a new category to the intent.  Categories provide additional detail
  /// about the action the intent performs.  When resolving an intent, only
  /// activities that provide _all_ of the requested categories will be
  /// used.
  ///@param category The desired category.  This can be either one of the
  ///               predefined Intent categories, or a custom category in your own
  ///               namespace.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#hasCategory
  ///@see \#removeCategory
  Intent addCategory(jni.JniString category) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_addCategory,
          jni.JniType.objectType, [category.reference]).object);

  static final _id_removeCategory = jniAccessors.getMethodIDOf(
      _classRef, "removeCategory", "(Ljava/lang/String;)V");

  /// from: public void removeCategory(java.lang.String category)
  ///
  /// Remove a category from an intent.
  ///@param category The category to remove.
  ///@see \#addCategory
  void removeCategory(jni.JniString category) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeCategory,
          jni.JniType.voidType, [category.reference]).check();

  static final _id_setSelector = jniAccessors.getMethodIDOf(
      _classRef, "setSelector", "(Landroid/content/Intent;)V");

  /// from: public void setSelector(android.content.Intent selector)
  ///
  /// Set a selector for this Intent.  This is a modification to the kinds of
  /// things the Intent will match.  If the selector is set, it will be used
  /// when trying to find entities that can handle the Intent, instead of the
  /// main contents of the Intent.  This allows you build an Intent containing
  /// a generic protocol while targeting it more specifically.
  ///
  /// An example of where this may be used is with things like
  /// \#CATEGORY_APP_BROWSER.  This category allows you to build an
  /// Intent that will launch the Browser application.  However, the correct
  /// main entry point of an application is actually \#ACTION_MAIN
  /// \#CATEGORY_LAUNCHER with \#setComponent(ComponentName)
  /// used to specify the actual Activity to launch.  If you launch the browser
  /// with something different, undesired behavior may happen if the user has
  /// previously or later launches it the normal way, since they do not match.
  /// Instead, you can build an Intent with the MAIN action (but no ComponentName
  /// yet specified) and set a selector with \#ACTION_MAIN and
  /// \#CATEGORY_APP_BROWSER to point it specifically to the browser activity.
  ///
  /// Setting a selector does not impact the behavior of
  /// \#filterEquals(Intent) and \#filterHashCode().  This is part of the
  /// desired behavior of a selector -- it does not impact the base meaning
  /// of the Intent, just what kinds of things will be matched against it
  /// when determining who can handle it.
  ///
  ///
  /// You can not use both a selector and \#setPackage(String) on
  /// the same base Intent.
  ///
  ///@param selector The desired selector Intent; set to null to not use
  /// a special selector.
  ///
  /// This value may be {@code null}.
  void setSelector(Intent selector) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSelector,
      jni.JniType.voidType,
      [selector.reference]).check();

  static final _id_setClipData = jniAccessors.getMethodIDOf(
      _classRef, "setClipData", "(Landroid/content/ClipData;)V");

  /// from: public void setClipData(android.content.ClipData clip)
  ///
  /// Set a ClipData associated with this Intent.  This replaces any
  /// previously set ClipData.
  ///
  /// The ClipData in an intent is not used for Intent matching or other
  /// such operations.  Semantically it is like extras, used to transmit
  /// additional data with the Intent.  The main feature of using this over
  /// the extras for data is that \#FLAG_GRANT_READ_URI_PERMISSION
  /// and \#FLAG_GRANT_WRITE_URI_PERMISSION will operate on any URI
  /// items included in the clip data.  This is useful, in particular, if
  /// you want to transmit an Intent containing multiple <code>content:</code>
  /// URIs for which the recipient may not have global permission to access the
  /// content provider.
  ///
  /// If the ClipData contains items that are themselves Intents, any
  /// grant flags in those Intents will be ignored.  Only the top-level flags
  /// of the main Intent are respected, and will be applied to all Uri or
  /// Intent items in the clip (or sub-items of the clip).
  ///
  /// The MIME type, label, and icon in the ClipData object are not
  /// directly used by Intent.  Applications should generally rely on the
  /// MIME type of the Intent itself, not what it may find in the ClipData.
  /// A common practice is to construct a ClipData for use with an Intent
  /// with a MIME type of "*&\#47;*".
  ///@param clip The new clip to set.  May be null to clear the current clip.
  ///
  /// This value may be {@code null}.
  void setClipData(clipdata_.ClipData clip) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setClipData,
      jni.JniType.voidType,
      [clip.reference]).check();

  static final _id_putExtra = jniAccessors.getMethodIDOf(
      _classRef, "putExtra", "(Ljava/lang/String;Z)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, boolean value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The boolean data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getBooleanExtra(String, boolean)
  Intent putExtra(jni.JniString name, bool value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra,
          jni.JniType.objectType, [name.reference, value]).object);

  static final _id_putExtra1 = jniAccessors.getMethodIDOf(
      _classRef, "putExtra", "(Ljava/lang/String;B)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, byte value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The byte data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getByteExtra(String, byte)
  Intent putExtra1(jni.JniString name, int value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra1,
          jni.JniType.objectType, [name.reference, value]).object);

  static final _id_putExtra2 = jniAccessors.getMethodIDOf(
      _classRef, "putExtra", "(Ljava/lang/String;C)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, char value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The char data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getCharExtra(String, char)
  Intent putExtra2(jni.JniString name, int value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra2,
          jni.JniType.objectType, [name.reference, value]).object);

  static final _id_putExtra3 = jniAccessors.getMethodIDOf(
      _classRef, "putExtra", "(Ljava/lang/String;S)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, short value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The short data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getShortExtra(String, short)
  Intent putExtra3(jni.JniString name, int value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra3,
          jni.JniType.objectType, [name.reference, value]).object);

  static final _id_putExtra4 = jniAccessors.getMethodIDOf(
      _classRef, "putExtra", "(Ljava/lang/String;I)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, int value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The integer data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getIntExtra(String, int)
  Intent putExtra4(jni.JniString name, int value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra4,
          jni.JniType.objectType, [name.reference, value]).object);

  static final _id_putExtra5 = jniAccessors.getMethodIDOf(
      _classRef, "putExtra", "(Ljava/lang/String;J)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, long value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The long data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getLongExtra(String, long)
  Intent putExtra5(jni.JniString name, int value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra5,
          jni.JniType.objectType, [name.reference, value]).object);

  static final _id_putExtra6 = jniAccessors.getMethodIDOf(
      _classRef, "putExtra", "(Ljava/lang/String;F)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, float value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The float data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getFloatExtra(String, float)
  Intent putExtra6(jni.JniString name, double value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra6,
          jni.JniType.objectType, [name.reference, value]).object);

  static final _id_putExtra7 = jniAccessors.getMethodIDOf(
      _classRef, "putExtra", "(Ljava/lang/String;D)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, double value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The double data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getDoubleExtra(String, double)
  Intent putExtra7(jni.JniString name, double value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra7,
          jni.JniType.objectType, [name.reference, value]).object);

  static final _id_putExtra8 = jniAccessors.getMethodIDOf(_classRef, "putExtra",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, java.lang.String value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The String data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getStringExtra(String)
  Intent putExtra8(jni.JniString name, jni.JniString value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra8,
          jni.JniType.objectType, [name.reference, value.reference]).object);

  static final _id_putExtra9 = jniAccessors.getMethodIDOf(_classRef, "putExtra",
      "(Ljava/lang/String;Ljava/lang/CharSequence;)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, java.lang.CharSequence value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The CharSequence data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getCharSequenceExtra(String)
  Intent putExtra9(jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra9,
          jni.JniType.objectType, [name.reference, value.reference]).object);

  static final _id_putExtra10 = jniAccessors.getMethodIDOf(
      _classRef,
      "putExtra",
      "(Ljava/lang/String;Landroid/os/Parcelable;)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, android.os.Parcelable value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The Parcelable data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getParcelableExtra(String)
  Intent putExtra10(jni.JniString name, parcelable_.Parcelable value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra10,
          jni.JniType.objectType, [name.reference, value.reference]).object);

  static final _id_putExtra11 = jniAccessors.getMethodIDOf(
      _classRef,
      "putExtra",
      "(Ljava/lang/String;[Landroid/os/Parcelable;)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, android.os.Parcelable[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The Parcelable[] data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getParcelableArrayExtra(String)
  Intent putExtra11(jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra11,
          jni.JniType.objectType, [name.reference, value.reference]).object);

  static final _id_putParcelableArrayListExtra = jniAccessors.getMethodIDOf(
      _classRef,
      "putParcelableArrayListExtra",
      "(Ljava/lang/String;Ljava/util/ArrayList;)Landroid/content/Intent;");

  /// from: public android.content.Intent putParcelableArrayListExtra(java.lang.String name, java.util.ArrayList<? extends android.os.Parcelable> value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The ArrayList<Parcelable> data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getParcelableArrayListExtra(String)
  Intent putParcelableArrayListExtra(jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_putParcelableArrayListExtra,
          jni.JniType.objectType,
          [name.reference, value.reference]).object);

  static final _id_putIntegerArrayListExtra = jniAccessors.getMethodIDOf(
      _classRef,
      "putIntegerArrayListExtra",
      "(Ljava/lang/String;Ljava/util/ArrayList;)Landroid/content/Intent;");

  /// from: public android.content.Intent putIntegerArrayListExtra(java.lang.String name, java.util.ArrayList<java.lang.Integer> value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The ArrayList<Integer> data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getIntegerArrayListExtra(String)
  Intent putIntegerArrayListExtra(jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_putIntegerArrayListExtra,
          jni.JniType.objectType,
          [name.reference, value.reference]).object);

  static final _id_putStringArrayListExtra = jniAccessors.getMethodIDOf(
      _classRef,
      "putStringArrayListExtra",
      "(Ljava/lang/String;Ljava/util/ArrayList;)Landroid/content/Intent;");

  /// from: public android.content.Intent putStringArrayListExtra(java.lang.String name, java.util.ArrayList<java.lang.String> value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The ArrayList<String> data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getStringArrayListExtra(String)
  Intent putStringArrayListExtra(jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_putStringArrayListExtra,
          jni.JniType.objectType,
          [name.reference, value.reference]).object);

  static final _id_putCharSequenceArrayListExtra = jniAccessors.getMethodIDOf(
      _classRef,
      "putCharSequenceArrayListExtra",
      "(Ljava/lang/String;Ljava/util/ArrayList;)Landroid/content/Intent;");

  /// from: public android.content.Intent putCharSequenceArrayListExtra(java.lang.String name, java.util.ArrayList<java.lang.CharSequence> value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The ArrayList<CharSequence> data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getCharSequenceArrayListExtra(String)
  Intent putCharSequenceArrayListExtra(
          jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_putCharSequenceArrayListExtra,
          jni.JniType.objectType,
          [name.reference, value.reference]).object);

  static final _id_putExtra12 = jniAccessors.getMethodIDOf(
      _classRef,
      "putExtra",
      "(Ljava/lang/String;Ljava/io/Serializable;)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, java.io.Serializable value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The Serializable data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getSerializableExtra(String)
  Intent putExtra12(jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra12,
          jni.JniType.objectType, [name.reference, value.reference]).object);

  static final _id_putExtra13 = jniAccessors.getMethodIDOf(
      _classRef, "putExtra", "(Ljava/lang/String;[Z)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, boolean[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The boolean array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getBooleanArrayExtra(String)
  Intent putExtra13(jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra13,
          jni.JniType.objectType, [name.reference, value.reference]).object);

  static final _id_putExtra14 = jniAccessors.getMethodIDOf(
      _classRef, "putExtra", "(Ljava/lang/String;[B)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, byte[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The byte array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getByteArrayExtra(String)
  Intent putExtra14(jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra14,
          jni.JniType.objectType, [name.reference, value.reference]).object);

  static final _id_putExtra15 = jniAccessors.getMethodIDOf(
      _classRef, "putExtra", "(Ljava/lang/String;[S)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, short[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The short array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getShortArrayExtra(String)
  Intent putExtra15(jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra15,
          jni.JniType.objectType, [name.reference, value.reference]).object);

  static final _id_putExtra16 = jniAccessors.getMethodIDOf(
      _classRef, "putExtra", "(Ljava/lang/String;[C)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, char[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The char array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getCharArrayExtra(String)
  Intent putExtra16(jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra16,
          jni.JniType.objectType, [name.reference, value.reference]).object);

  static final _id_putExtra17 = jniAccessors.getMethodIDOf(
      _classRef, "putExtra", "(Ljava/lang/String;[I)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, int[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The int array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getIntArrayExtra(String)
  Intent putExtra17(jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra17,
          jni.JniType.objectType, [name.reference, value.reference]).object);

  static final _id_putExtra18 = jniAccessors.getMethodIDOf(
      _classRef, "putExtra", "(Ljava/lang/String;[J)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, long[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The byte array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getLongArrayExtra(String)
  Intent putExtra18(jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra18,
          jni.JniType.objectType, [name.reference, value.reference]).object);

  static final _id_putExtra19 = jniAccessors.getMethodIDOf(
      _classRef, "putExtra", "(Ljava/lang/String;[F)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, float[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The float array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getFloatArrayExtra(String)
  Intent putExtra19(jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra19,
          jni.JniType.objectType, [name.reference, value.reference]).object);

  static final _id_putExtra20 = jniAccessors.getMethodIDOf(
      _classRef, "putExtra", "(Ljava/lang/String;[D)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, double[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The double array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getDoubleArrayExtra(String)
  Intent putExtra20(jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra20,
          jni.JniType.objectType, [name.reference, value.reference]).object);

  static final _id_putExtra21 = jniAccessors.getMethodIDOf(
      _classRef,
      "putExtra",
      "(Ljava/lang/String;[Ljava/lang/String;)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, java.lang.String[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The String array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getStringArrayExtra(String)
  Intent putExtra21(jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra21,
          jni.JniType.objectType, [name.reference, value.reference]).object);

  static final _id_putExtra22 = jniAccessors.getMethodIDOf(
      _classRef,
      "putExtra",
      "(Ljava/lang/String;[Ljava/lang/CharSequence;)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, java.lang.CharSequence[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The CharSequence array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getCharSequenceArrayExtra(String)
  Intent putExtra22(jni.JniString name, jni.JniObject value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra22,
          jni.JniType.objectType, [name.reference, value.reference]).object);

  static final _id_putExtra23 = jniAccessors.getMethodIDOf(
      _classRef,
      "putExtra",
      "(Ljava/lang/String;Landroid/os/Bundle;)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtra(java.lang.String name, android.os.Bundle value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The Bundle data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getBundleExtra(String)
  Intent putExtra23(jni.JniString name, bundle_.Bundle value) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtra23,
          jni.JniType.objectType, [name.reference, value.reference]).object);

  static final _id_putExtras = jniAccessors.getMethodIDOf(_classRef,
      "putExtras", "(Landroid/content/Intent;)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtras(android.content.Intent src)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copy all extras in 'src' in to this intent.
  ///@param src Contains the extras to copy.
  ///
  /// This value must never be {@code null}.
  ///@see \#putExtra
  ///@return This value will never be {@code null}.
  Intent putExtras(Intent src) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtras,
          jni.JniType.objectType, [src.reference]).object);

  static final _id_putExtras1 = jniAccessors.getMethodIDOf(
      _classRef, "putExtras", "(Landroid/os/Bundle;)Landroid/content/Intent;");

  /// from: public android.content.Intent putExtras(android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a set of extended data to the intent.  The keys must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param extras The Bundle of extras to add to this intent.
  ///
  /// This value must never be {@code null}.
  ///@see \#putExtra
  ///@see \#removeExtra
  ///@return This value will never be {@code null}.
  Intent putExtras1(bundle_.Bundle extras) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_putExtras1,
          jni.JniType.objectType, [extras.reference]).object);

  static final _id_replaceExtras = jniAccessors.getMethodIDOf(_classRef,
      "replaceExtras", "(Landroid/content/Intent;)Landroid/content/Intent;");

  /// from: public android.content.Intent replaceExtras(android.content.Intent src)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Completely replace the extras in the Intent with the extras in the
  /// given Intent.
  ///@param src The exact extras contained in this Intent are copied
  /// into the target intent, replacing any that were previously there.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  Intent replaceExtras(Intent src) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_replaceExtras, jni.JniType.objectType, [src.reference]).object);

  static final _id_replaceExtras1 = jniAccessors.getMethodIDOf(_classRef,
      "replaceExtras", "(Landroid/os/Bundle;)Landroid/content/Intent;");

  /// from: public android.content.Intent replaceExtras(android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Completely replace the extras in the Intent with the given Bundle of
  /// extras.
  ///@param extras The new set of extras in the Intent, or null to erase
  /// all extras.
  ///
  /// This value must never be {@code null}.
  Intent replaceExtras1(bundle_.Bundle extras) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_replaceExtras1,
          jni.JniType.objectType,
          [extras.reference]).object);

  static final _id_removeExtra = jniAccessors.getMethodIDOf(
      _classRef, "removeExtra", "(Ljava/lang/String;)V");

  /// from: public void removeExtra(java.lang.String name)
  ///
  /// Remove extended data from the intent.
  ///@see \#putExtra
  void removeExtra(jni.JniString name) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeExtra,
      jni.JniType.voidType,
      [name.reference]).check();

  static final _id_setFlags = jniAccessors.getMethodIDOf(
      _classRef, "setFlags", "(I)Landroid/content/Intent;");

  /// from: public android.content.Intent setFlags(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set special flags controlling how this intent is handled.  Most values
  /// here depend on the type of component being executed by the Intent,
  /// specifically the FLAG_ACTIVITY_* flags are all for use with
  /// Context\#startActivity Context.startActivity() and the
  /// FLAG_RECEIVER_* flags are all for use with
  /// Context\#sendBroadcast(Intent) Context.sendBroadcast().
  ///
  /// See the
  /// <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
  /// Stack</a> documentation for important information on how some of these options impact
  /// the behavior of your application.
  ///@param flags The desired flags.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION, android.content.Intent\#FLAG_FROM_BACKGROUND, android.content.Intent\#FLAG_DEBUG_LOG_RESOLUTION, android.content.Intent\#FLAG_EXCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_INCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_GRANT_PERSISTABLE_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_PREFIX_URI_PERMISSION, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, android.content.Intent\#FLAG_ACTIVITY_MATCH_EXTERNAL, android.content.Intent\#FLAG_ACTIVITY_NO_HISTORY, android.content.Intent\#FLAG_ACTIVITY_SINGLE_TOP, android.content.Intent\#FLAG_ACTIVITY_NEW_TASK, android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TOP, android.content.Intent\#FLAG_ACTIVITY_FORWARD_RESULT, android.content.Intent\#FLAG_ACTIVITY_PREVIOUS_IS_TOP, android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, android.content.Intent\#FLAG_ACTIVITY_BROUGHT_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED, android.content.Intent\#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NO_USER_ACTION, android.content.Intent\#FLAG_ACTIVITY_REORDER_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_NO_ANIMATION, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TASK, android.content.Intent\#FLAG_ACTIVITY_TASK_ON_HOME, android.content.Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS, android.content.Intent\#FLAG_ACTIVITY_LAUNCH_ADJACENT, android.content.Intent\#FLAG_RECEIVER_REGISTERED_ONLY, android.content.Intent\#FLAG_RECEIVER_REPLACE_PENDING, android.content.Intent\#FLAG_RECEIVER_FOREGROUND, android.content.Intent\#FLAG_RECEIVER_NO_ABORT, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, and android.content.Intent\#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  /// This value will never be {@code null}.
  ///@see \#getFlags
  ///@see \#addFlags
  ///@see \#removeFlags
  Intent setFlags(int flags) => Intent.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_setFlags, jni.JniType.objectType, [flags]).object);

  static final _id_addFlags = jniAccessors.getMethodIDOf(
      _classRef, "addFlags", "(I)Landroid/content/Intent;");

  /// from: public android.content.Intent addFlags(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add additional flags to the intent (or with existing flags value).
  ///@param flags The new flags to set.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION, android.content.Intent\#FLAG_FROM_BACKGROUND, android.content.Intent\#FLAG_DEBUG_LOG_RESOLUTION, android.content.Intent\#FLAG_EXCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_INCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_GRANT_PERSISTABLE_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_PREFIX_URI_PERMISSION, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, android.content.Intent\#FLAG_ACTIVITY_MATCH_EXTERNAL, android.content.Intent\#FLAG_ACTIVITY_NO_HISTORY, android.content.Intent\#FLAG_ACTIVITY_SINGLE_TOP, android.content.Intent\#FLAG_ACTIVITY_NEW_TASK, android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TOP, android.content.Intent\#FLAG_ACTIVITY_FORWARD_RESULT, android.content.Intent\#FLAG_ACTIVITY_PREVIOUS_IS_TOP, android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, android.content.Intent\#FLAG_ACTIVITY_BROUGHT_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED, android.content.Intent\#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NO_USER_ACTION, android.content.Intent\#FLAG_ACTIVITY_REORDER_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_NO_ANIMATION, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TASK, android.content.Intent\#FLAG_ACTIVITY_TASK_ON_HOME, android.content.Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS, android.content.Intent\#FLAG_ACTIVITY_LAUNCH_ADJACENT, android.content.Intent\#FLAG_RECEIVER_REGISTERED_ONLY, android.content.Intent\#FLAG_RECEIVER_REPLACE_PENDING, android.content.Intent\#FLAG_RECEIVER_FOREGROUND, android.content.Intent\#FLAG_RECEIVER_NO_ABORT, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, and android.content.Intent\#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@return Returns the same Intent object, for chaining multiple calls into
  ///         a single statement.
  /// This value will never be {@code null}.
  ///@see \#setFlags
  ///@see \#getFlags
  ///@see \#removeFlags
  Intent addFlags(int flags) => Intent.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_addFlags, jni.JniType.objectType, [flags]).object);

  static final _id_removeFlags =
      jniAccessors.getMethodIDOf(_classRef, "removeFlags", "(I)V");

  /// from: public void removeFlags(int flags)
  ///
  /// Remove these flags from the intent.
  ///@param flags The flags to remove.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION, android.content.Intent\#FLAG_FROM_BACKGROUND, android.content.Intent\#FLAG_DEBUG_LOG_RESOLUTION, android.content.Intent\#FLAG_EXCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_INCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_GRANT_PERSISTABLE_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_PREFIX_URI_PERMISSION, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, android.content.Intent\#FLAG_ACTIVITY_MATCH_EXTERNAL, android.content.Intent\#FLAG_ACTIVITY_NO_HISTORY, android.content.Intent\#FLAG_ACTIVITY_SINGLE_TOP, android.content.Intent\#FLAG_ACTIVITY_NEW_TASK, android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TOP, android.content.Intent\#FLAG_ACTIVITY_FORWARD_RESULT, android.content.Intent\#FLAG_ACTIVITY_PREVIOUS_IS_TOP, android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, android.content.Intent\#FLAG_ACTIVITY_BROUGHT_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED, android.content.Intent\#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NO_USER_ACTION, android.content.Intent\#FLAG_ACTIVITY_REORDER_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_NO_ANIMATION, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TASK, android.content.Intent\#FLAG_ACTIVITY_TASK_ON_HOME, android.content.Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS, android.content.Intent\#FLAG_ACTIVITY_LAUNCH_ADJACENT, android.content.Intent\#FLAG_RECEIVER_REGISTERED_ONLY, android.content.Intent\#FLAG_RECEIVER_REPLACE_PENDING, android.content.Intent\#FLAG_RECEIVER_FOREGROUND, android.content.Intent\#FLAG_RECEIVER_NO_ABORT, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, and android.content.Intent\#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@see \#setFlags
  ///@see \#getFlags
  ///@see \#addFlags
  void removeFlags(int flags) => jniAccessors.callMethodWithArgs(
      reference, _id_removeFlags, jni.JniType.voidType, [flags]).check();

  static final _id_setPackage = jniAccessors.getMethodIDOf(
      _classRef, "setPackage", "(Ljava/lang/String;)Landroid/content/Intent;");

  /// from: public android.content.Intent setPackage(java.lang.String packageName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// (Usually optional) Set an explicit application package name that limits
  /// the components this Intent will resolve to.  If left to the default
  /// value of null, all components in all applications will considered.
  /// If non-null, the Intent can only match the components in the given
  /// application package.
  ///@param packageName The name of the application package to handle the
  /// intent, or null to allow any application package.
  ///
  /// This value may be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///@see \#getPackage
  ///@see \#resolveActivity
  Intent setPackage(jni.JniString packageName) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(reference, _id_setPackage,
          jni.JniType.objectType, [packageName.reference]).object);

  static final _id_setComponent = jniAccessors.getMethodIDOf(
      _classRef,
      "setComponent",
      "(Landroid/content/ComponentName;)Landroid/content/Intent;");

  /// from: public android.content.Intent setComponent(android.content.ComponentName component)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// (Usually optional) Explicitly set the component to handle the intent.
  /// If left with the default value of null, the system will determine the
  /// appropriate class to use based on the other fields (action, data,
  /// type, categories) in the Intent.  If this class is defined, the
  /// specified class will always be used regardless of the other fields.  You
  /// should only set this value when you know you absolutely want a specific
  /// class to be used; otherwise it is better to let the system find the
  /// appropriate class so that you will respect the installed applications
  /// and user preferences.
  ///@param component The name of the application component to handle the
  /// intent, or null to let the system find one for you.
  ///
  /// This value may be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///@see \#setClass
  ///@see \#setClassName(Context, String)
  ///@see \#setClassName(String, String)
  ///@see \#getComponent
  ///@see \#resolveActivity
  Intent setComponent(componentname_.ComponentName component) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setComponent,
          jni.JniType.objectType,
          [component.reference]).object);

  static final _id_setClassName = jniAccessors.getMethodIDOf(
      _classRef,
      "setClassName",
      "(Landroid/content/Context;Ljava/lang/String;)Landroid/content/Intent;");

  /// from: public android.content.Intent setClassName(android.content.Context packageContext, java.lang.String className)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for calling \#setComponent with an
  /// explicit class name.
  ///@param packageContext A Context of the application package implementing
  /// this class.
  /// This value must never be {@code null}.
  ///@param className The name of a class inside of the application package
  /// that will be used as the component for this Intent.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#setComponent
  ///@see \#setClass
  Intent setClassName(
          context_.Context packageContext, jni.JniString className) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setClassName,
          jni.JniType.objectType,
          [packageContext.reference, className.reference]).object);

  static final _id_setClassName1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setClassName",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/content/Intent;");

  /// from: public android.content.Intent setClassName(java.lang.String packageName, java.lang.String className)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for calling \#setComponent with an
  /// explicit application package name and class name.
  ///@param packageName The name of the package implementing the desired
  /// component.
  /// This value must never be {@code null}.
  ///@param className The name of a class inside of the application package
  /// that will be used as the component for this Intent.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#setComponent
  ///@see \#setClass
  Intent setClassName1(jni.JniString packageName, jni.JniString className) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setClassName1,
          jni.JniType.objectType,
          [packageName.reference, className.reference]).object);

  static final _id_setClass = jniAccessors.getMethodIDOf(_classRef, "setClass",
      "(Landroid/content/Context;Ljava/lang/Class;)Landroid/content/Intent;");

  /// from: public android.content.Intent setClass(android.content.Context packageContext, java.lang.Class<?> cls)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for calling \#setComponent(ComponentName) with the
  /// name returned by a Class object.
  ///@param packageContext A Context of the application package implementing
  /// this class.
  /// This value must never be {@code null}.
  ///@param cls The class name to set, equivalent to
  ///            <code>setClassName(context, cls.getName())</code>.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#setComponent
  Intent setClass(context_.Context packageContext, jni.JniObject cls) =>
      Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setClass,
          jni.JniType.objectType,
          [packageContext.reference, cls.reference]).object);

  static final _id_setSourceBounds = jniAccessors.getMethodIDOf(
      _classRef, "setSourceBounds", "(Landroid/graphics/Rect;)V");

  /// from: public void setSourceBounds(android.graphics.Rect r)
  ///
  /// Set the bounds of the sender of this intent, in screen coordinates.  This can be
  /// used as a hint to the receiver for animations and the like.  Null means that there
  /// is no source bounds.
  ///@param r This value may be {@code null}.
  void setSourceBounds(rect_.Rect r) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSourceBounds,
      jni.JniType.voidType,
      [r.reference]).check();

  static final _id_fillIn = jniAccessors.getMethodIDOf(
      _classRef, "fillIn", "(Landroid/content/Intent;I)I");

  /// from: public int fillIn(android.content.Intent other, int flags)
  ///
  /// Copy the contents of <var>other</var> in to this object, but only
  /// where fields are not defined by this object.  For purposes of a field
  /// being defined, the following pieces of data in the Intent are
  /// considered to be separate fields:
  ///
  /// <ul>
  /// <li> action, as set by \#setAction.
  /// <li> data Uri and MIME type, as set by \#setData(Uri),
  /// \#setType(String), or \#setDataAndType(Uri, String).
  /// <li> categories, as set by \#addCategory.
  /// <li> package, as set by \#setPackage.
  /// <li> component, as set by \#setComponent(ComponentName) or
  /// related methods.
  /// <li> source bounds, as set by \#setSourceBounds.
  /// <li> selector, as set by \#setSelector(Intent).
  /// <li> clip data, as set by \#setClipData(ClipData).
  /// <li> each top-level name in the associated extras.
  /// </ul>
  ///
  /// In addition, you can use the \#FILL_IN_ACTION,
  /// \#FILL_IN_DATA, \#FILL_IN_CATEGORIES, \#FILL_IN_PACKAGE,
  /// \#FILL_IN_COMPONENT, \#FILL_IN_SOURCE_BOUNDS,
  /// \#FILL_IN_SELECTOR, and \#FILL_IN_CLIP_DATA to override
  /// the restriction where the corresponding field will not be replaced if
  /// it is already set.
  ///
  /// Note: The component field will only be copied if \#FILL_IN_COMPONENT
  /// is explicitly specified.  The selector will only be copied if
  /// \#FILL_IN_SELECTOR is explicitly specified.
  ///
  /// For example, consider Intent A with {data="foo", categories="bar"}
  /// and Intent B with {action="gotit", data-type="some/thing",
  /// categories="one","two"}.
  ///
  /// Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
  /// containing: {action="gotit", data-type="some/thing",
  /// categories="bar"}.
  ///@param other Another Intent whose values are to be used to fill in
  /// the current one.
  /// This value must never be {@code null}.
  ///@param flags Options to control which fields can be filled in.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns a bit mask of \#FILL_IN_ACTION,
  /// \#FILL_IN_DATA, \#FILL_IN_CATEGORIES, \#FILL_IN_PACKAGE,
  /// \#FILL_IN_COMPONENT, \#FILL_IN_SOURCE_BOUNDS,
  /// \#FILL_IN_SELECTOR and \#FILL_IN_CLIP_DATA indicating which fields were
  /// changed.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  int fillIn(Intent other, int flags) => jniAccessors.callMethodWithArgs(
      reference,
      _id_fillIn,
      jni.JniType.intType,
      [other.reference, flags]).integer;

  static final _id_filterEquals = jniAccessors.getMethodIDOf(
      _classRef, "filterEquals", "(Landroid/content/Intent;)Z");

  /// from: public boolean filterEquals(android.content.Intent other)
  ///
  /// Determine if two intents are the same for the purposes of intent
  /// resolution (filtering). That is, if their action, data, type,
  /// class, and categories are the same.  This does _not_ compare
  /// any extra data included in the intents.
  ///@param other The other Intent to compare against.
  ///@return Returns true if action, data, type, class, and categories
  ///         are the same.
  bool filterEquals(Intent other) => jniAccessors.callMethodWithArgs(reference,
      _id_filterEquals, jni.JniType.booleanType, [other.reference]).boolean;

  static final _id_filterHashCode =
      jniAccessors.getMethodIDOf(_classRef, "filterHashCode", "()I");

  /// from: public int filterHashCode()
  ///
  /// Generate hash code that matches semantics of filterEquals().
  ///@return Returns the hash value of the action, data, type, class, and
  ///         categories.
  ///@see \#filterEquals
  int filterHashCode() => jniAccessors.callMethodWithArgs(
      reference, _id_filterHashCode, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_toURI =
      jniAccessors.getMethodIDOf(_classRef, "toURI", "()Ljava/lang/String;");

  /// from: public java.lang.String toURI()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call \#toUri with 0 flags.
  ///@deprecated Use \#toUri instead.
  jni.JniString toURI() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toURI, jni.JniType.objectType, []).object);

  static final _id_toUri =
      jniAccessors.getMethodIDOf(_classRef, "toUri", "(I)Ljava/lang/String;");

  /// from: public java.lang.String toUri(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convert this Intent into a String holding a URI representation of it.
  /// The returned URI string has been properly URI encoded, so it can be
  /// used with Uri\#parse Uri.parse(String).  The URI contains the
  /// Intent's data as the base URI, with an additional fragment describing
  /// the action, categories, type, flags, package, component, and extras.
  ///
  /// You can convert the returned string back to an Intent with
  /// \#getIntent.
  ///@param flags Additional operating flags.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#URI_ALLOW_UNSAFE, android.content.Intent\#URI_ANDROID_APP_SCHEME, and android.content.Intent\#URI_INTENT_SCHEME
  ///@return Returns a URI encoding URI string describing the entire contents
  /// of the Intent.
  jni.JniString toUri(int flags) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toUri, jni.JniType.objectType, [flags]).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(parcel_.Parcel out, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [out.reference, flags]).check();

  static final _id_readFromParcel = jniAccessors.getMethodIDOf(
      _classRef, "readFromParcel", "(Landroid/os/Parcel;)V");

  /// from: public void readFromParcel(android.os.Parcel in)
  void readFromParcel(parcel_.Parcel in0) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readFromParcel,
      jni.JniType.voidType,
      [in0.reference]).check();

  static final _id_parseIntent = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "parseIntent",
      "(Landroid/content/res/Resources;Lorg/xmlpull/v1/XmlPullParser;Landroid/util/AttributeSet;)Landroid/content/Intent;");

  /// from: static public android.content.Intent parseIntent(android.content.res.Resources resources, org.xmlpull.v1.XmlPullParser parser, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses the "intent" element (and its children) from XML and instantiates
  /// an Intent object.  The given XML parser should be located at the tag
  /// where parsing should start (often named "intent"), from which the
  /// basic action, data, type, and package and class name will be
  /// retrieved.  The function will then parse in to any child elements,
  /// looking for <category android:name="xxx"> tags to add categories and
  /// <extra android:name="xxx" android:value="yyy"> to attach extra data
  /// to the intent.
  ///@param resources The Resources to use when inflating resources.
  /// This value must never be {@code null}.
  ///@param parser The XML parser pointing at an "intent" tag.
  /// This value must never be {@code null}.
  ///@param attrs The AttributeSet interface for retrieving extended
  /// attribute data at the current <var>parser</var> location.
  ///@return An Intent object matching the XML data.
  /// This value will never be {@code null}.
  ///@throws XmlPullParserException If there was an XML parsing error.
  ///@throws IOException If there was an I/O error.
  static Intent parseIntent(resources_.Resources resources,
          jni.JniObject parser, attributeset_.AttributeSet attrs) =>
      Intent.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_parseIntent,
          jni.JniType.objectType,
          [resources.reference, parser.reference, attrs.reference]).object);

  static final _id_normalizeMimeType = jniAccessors.getStaticMethodIDOf(
      _classRef, "normalizeMimeType", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String normalizeMimeType(java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Normalize a MIME data type.
  ///
  /// A normalized MIME type has white-space trimmed,
  /// content-type parameters removed, and is lower-case.
  /// This aligns the type with Android best practices for
  /// intent filtering.
  ///
  /// For example, "text/plain; charset=utf-8" becomes "text/plain".
  /// "text/x-vCard" becomes "text/x-vcard".
  ///
  /// All MIME types received from outside Android (such as user input,
  /// or external sources like Bluetooth, NFC, or the Internet) should
  /// be normalized before they are used to create an Intent.
  ///@param type MIME data type to normalize
  /// This value may be {@code null}.
  ///@return normalized MIME data type, or null if the input was null
  ///@see \#setType
  ///@see \#setTypeAndNormalize
  static jni.JniString normalizeMimeType(jni.JniString type) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_normalizeMimeType,
          jni.JniType.objectType,
          [type.reference]).object);
}

/// from: android.content.Intent$ShortcutIconResource
///
/// Represents a shortcut/live folder icon resource.
///@see Intent\#ACTION_CREATE_SHORTCUT
///@see Intent\#EXTRA_SHORTCUT_ICON_RESOURCE
///@see android.provider.LiveFolders\#ACTION_CREATE_LIVE_FOLDER
///@see android.provider.LiveFolders\#EXTRA_LIVE_FOLDER_ICON
class Intent_ShortcutIconResource extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/Intent\$ShortcutIconResource");
  Intent_ShortcutIconResource.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.content.Intent.ShortcutIconResource> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used to read a ShortcutIconResource from a Parcel.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_packageName =
      jniAccessors.getFieldIDOf(_classRef, "packageName", "Ljava/lang/String;");

  /// from: public java.lang.String packageName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The package name of the application containing the icon.
  jni.JniString get packageName => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_packageName, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String packageName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The package name of the application containing the icon.
  set packageName(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_packageName, value.reference);

  static final _id_resourceName = jniAccessors.getFieldIDOf(
      _classRef, "resourceName", "Ljava/lang/String;");

  /// from: public java.lang.String resourceName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The resource name of the icon, including package, name and type.
  jni.JniString get resourceName => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_resourceName, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String resourceName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The resource name of the icon, including package, name and type.
  set resourceName(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_resourceName, value.reference);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Intent_ShortcutIconResource()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_fromContext = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "fromContext",
      "(Landroid/content/Context;I)Landroid/content/Intent\$ShortcutIconResource;");

  /// from: static public android.content.Intent.ShortcutIconResource fromContext(android.content.Context context, int resourceId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new ShortcutIconResource for the specified context and resource
  /// identifier.
  ///@param context The context of the application.
  ///@param resourceId The resource identifier for the icon.
  ///@return A new ShortcutIconResource with the specified's context package name
  ///         and icon resource identifier.``
  static Intent_ShortcutIconResource fromContext(
          context_.Context context, int resourceId) =>
      Intent_ShortcutIconResource.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_fromContext,
          jni.JniType.objectType,
          [context.reference, resourceId]).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  ///
  /// No special parcel contents.
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.content.Intent$FilterComparison
///
/// Wrapper class holding an Intent and implementing comparisons on it for
/// the purpose of filtering.  The class implements its
/// \#equals equals() and \#hashCode hashCode() methods as
/// simple calls to Intent\#filterEquals(Intent)  filterEquals()} and
/// android.content.Intent\#filterHashCode()  filterHashCode()}
/// on the wrapped Intent.
class Intent_FilterComparison extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/Intent\$FilterComparison");
  Intent_FilterComparison.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Intent;)V");

  /// from: public void <init>(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Intent_FilterComparison(Intent intent)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [intent.reference]).object);

  static final _id_getIntent = jniAccessors.getMethodIDOf(
      _classRef, "getIntent", "()Landroid/content/Intent;");

  /// from: public android.content.Intent getIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Intent that this FilterComparison represents.
  ///@return Returns the Intent held by the FilterComparison.  Do
  /// not modify!
  Intent getIntent() => Intent.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getIntent, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}
