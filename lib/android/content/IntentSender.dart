// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/IBinder.dart" as ibinder_;

import "Context.dart" as context_;

import "Intent.dart" as intent_;

import "../os/Handler.dart" as handler_;

import "../os/UserHandle.dart" as userhandle_;

import "../os/Parcel.dart" as parcel_;

import "../util/AndroidException.dart" as androidexception_;

import "../os/Bundle.dart" as bundle_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.IntentSender
///
/// A description of an Intent and target action to perform with it.
/// The returned object can be
/// handed to other applications so that they can perform the action you
/// described on your behalf at a later time.
///
/// By giving a IntentSender to another application,
/// you are granting it the right to perform the operation you have specified
/// as if the other application was yourself (with the same permissions and
/// identity).  As such, you should be careful about how you build the IntentSender:
/// often, for example, the base Intent you supply will have the component
/// name explicitly set to one of your own components, to ensure it is ultimately
/// sent there and nowhere else.
///
/// A IntentSender itself is simply a reference to a token maintained by
/// the system describing the original data used to retrieve it.  This means
/// that, even if its owning application's process is killed, the
/// IntentSender itself will remain usable from other processes that
/// have been given it.  If the creating application later re-retrieves the
/// same kind of IntentSender (same operation, same Intent action, data,
/// categories, and components, and same flags), it will receive a IntentSender
/// representing the same token if that is still valid.
///
/// Instances of this class can not be made directly, but rather must be
/// created from an existing android.app.PendingIntent with
/// android.app.PendingIntent\#getIntentSender() PendingIntent.getIntentSender().
class IntentSender extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/IntentSender");
  IntentSender.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.content.IntentSender> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/os/IBinder;)V");

  /// from: void <init>(android.os.IBinder target)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  IntentSender(ibinder_.IBinder target)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [target.reference]).object);

  static final _id_sendIntent = jniAccessors.getMethodIDOf(
      _classRef,
      "sendIntent",
      "(Landroid/content/Context;ILandroid/content/Intent;Landroid/content/IntentSender\$OnFinished;Landroid/os/Handler;)V");

  /// from: public void sendIntent(android.content.Context context, int code, android.content.Intent intent, android.content.IntentSender.OnFinished onFinished, android.os.Handler handler)
  ///
  /// Perform the operation associated with this IntentSender, allowing the
  /// caller to specify information about the Intent to use and be notified
  /// when the send has completed.
  ///@param context The Context of the caller.  This may be null if
  /// <var>intent</var> is also null.
  ///@param code Result code to supply back to the IntentSender's target.
  ///@param intent Additional Intent data.  See Intent\#fillIn Intent.fillIn() for information on how this is applied to the
  /// original Intent.  Use null to not modify the original Intent.
  ///@param onFinished The object to call back on when the send has
  /// completed, or null for no callback.
  ///@param handler Handler identifying the thread on which the callback
  /// should happen.  If null, the callback will happen from the thread
  /// pool of the process.
  ///@throws SendIntentException Throws CanceledIntentException if the IntentSender
  /// is no longer allowing more intents to be sent through it.
  void sendIntent(context_.Context context, int code, intent_.Intent intent,
          IntentSender_OnFinished onFinished, handler_.Handler handler) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_sendIntent, jni.JniType.voidType, [
        context.reference,
        code,
        intent.reference,
        onFinished.reference,
        handler.reference
      ]).check();

  static final _id_sendIntent1 = jniAccessors.getMethodIDOf(
      _classRef,
      "sendIntent",
      "(Landroid/content/Context;ILandroid/content/Intent;Landroid/content/IntentSender\$OnFinished;Landroid/os/Handler;Ljava/lang/String;)V");

  /// from: public void sendIntent(android.content.Context context, int code, android.content.Intent intent, android.content.IntentSender.OnFinished onFinished, android.os.Handler handler, java.lang.String requiredPermission)
  ///
  /// Perform the operation associated with this IntentSender, allowing the
  /// caller to specify information about the Intent to use and be notified
  /// when the send has completed.
  ///@param context The Context of the caller.  This may be null if
  /// <var>intent</var> is also null.
  ///@param code Result code to supply back to the IntentSender's target.
  ///@param intent Additional Intent data.  See Intent\#fillIn Intent.fillIn() for information on how this is applied to the
  /// original Intent.  Use null to not modify the original Intent.
  ///@param onFinished The object to call back on when the send has
  /// completed, or null for no callback.
  ///@param handler Handler identifying the thread on which the callback
  /// should happen.  If null, the callback will happen from the thread
  /// pool of the process.
  ///@param requiredPermission Name of permission that a recipient of the PendingIntent
  /// is required to hold.  This is only valid for broadcast intents, and
  /// corresponds to the permission argument in
  /// Context\#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String).
  /// If null, no permission is required.
  ///@throws SendIntentException Throws CanceledIntentException if the IntentSender
  /// is no longer allowing more intents to be sent through it.
  void sendIntent1(
          context_.Context context,
          int code,
          intent_.Intent intent,
          IntentSender_OnFinished onFinished,
          handler_.Handler handler,
          jni.JniString requiredPermission) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_sendIntent1, jni.JniType.voidType, [
        context.reference,
        code,
        intent.reference,
        onFinished.reference,
        handler.reference,
        requiredPermission.reference
      ]).check();

  static final _id_getTargetPackage = jniAccessors.getMethodIDOf(
      _classRef, "getTargetPackage", "()Ljava/lang/String;");

  /// from: public java.lang.String getTargetPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Renamed to \#getCreatorPackage().
  jni.JniString getTargetPackage() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTargetPackage, jni.JniType.objectType, []).object);

  static final _id_getCreatorPackage = jniAccessors.getMethodIDOf(
      _classRef, "getCreatorPackage", "()Ljava/lang/String;");

  /// from: public java.lang.String getCreatorPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the package name of the application that created this
  /// IntentSender, that is the identity under which you will actually be
  /// sending the Intent.  The returned string is supplied by the system, so
  /// that an application can not spoof its package.
  ///@return The package name of the PendingIntent, or null if there is
  /// none associated with it.
  jni.JniString getCreatorPackage() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCreatorPackage, jni.JniType.objectType, []).object);

  static final _id_getCreatorUid =
      jniAccessors.getMethodIDOf(_classRef, "getCreatorUid", "()I");

  /// from: public int getCreatorUid()
  ///
  /// Return the uid of the application that created this
  /// PendingIntent, that is the identity under which you will actually be
  /// sending the Intent.  The returned integer is supplied by the system, so
  /// that an application can not spoof its uid.
  ///@return The uid of the PendingIntent, or -1 if there is
  /// none associated with it.
  int getCreatorUid() => jniAccessors.callMethodWithArgs(
      reference, _id_getCreatorUid, jni.JniType.intType, []).integer;

  static final _id_getCreatorUserHandle = jniAccessors.getMethodIDOf(
      _classRef, "getCreatorUserHandle", "()Landroid/os/UserHandle;");

  /// from: public android.os.UserHandle getCreatorUserHandle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the user handle of the application that created this
  /// PendingIntent, that is the user under which you will actually be
  /// sending the Intent.  The returned UserHandle is supplied by the system, so
  /// that an application can not spoof its user.  See
  /// android.os.Process\#myUserHandle() Process.myUserHandle() for
  /// more explanation of user handles.
  ///@return The user handle of the PendingIntent, or null if there is
  /// none associated with it.
  userhandle_.UserHandle getCreatorUserHandle() =>
      userhandle_.UserHandle.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCreatorUserHandle, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object otherObj)
  ///
  /// Comparison operator on two IntentSender objects, such that true
  /// is returned then they both represent the same operation from the
  /// same package.
  bool equals1(jni.JniObject otherObj) => jniAccessors.callMethodWithArgs(
      reference,
      _id_equals1,
      jni.JniType.booleanType,
      [otherObj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(parcel_.Parcel out, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [out.reference, flags]).check();

  static final _id_writeIntentSenderOrNullToParcel =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "writeIntentSenderOrNullToParcel",
          "(Landroid/content/IntentSender;Landroid/os/Parcel;)V");

  /// from: static public void writeIntentSenderOrNullToParcel(android.content.IntentSender sender, android.os.Parcel out)
  ///
  /// Convenience function for writing either a IntentSender or null pointer to
  /// a Parcel.  You must use this with \#readIntentSenderOrNullFromParcel
  /// for later reading it.
  ///@param sender The IntentSender to write, or null.
  ///@param out Where to write the IntentSender.
  static void writeIntentSenderOrNullToParcel(
          IntentSender sender, parcel_.Parcel out) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_writeIntentSenderOrNullToParcel,
          jni.JniType.voidType,
          [sender.reference, out.reference]).check();

  static final _id_readIntentSenderOrNullFromParcel =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "readIntentSenderOrNullFromParcel",
          "(Landroid/os/Parcel;)Landroid/content/IntentSender;");

  /// from: static public android.content.IntentSender readIntentSenderOrNullFromParcel(android.os.Parcel in)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience function for reading either a Messenger or null pointer from
  /// a Parcel.  You must have previously written the Messenger with
  /// \#writeIntentSenderOrNullToParcel.
  ///@param in The Parcel containing the written Messenger.
  ///@return Returns the Messenger read from the Parcel, or null if null had
  /// been written.
  static IntentSender readIntentSenderOrNullFromParcel(parcel_.Parcel in0) =>
      IntentSender.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_readIntentSenderOrNullFromParcel,
          jni.JniType.objectType,
          [in0.reference]).object);
}

/// from: android.content.IntentSender$SendIntentException
///
/// Exception thrown when trying to send through a PendingIntent that
/// has been canceled or is otherwise no longer able to execute the request.
class IntentSender_SendIntentException
    extends androidexception_.AndroidException {
  static final _classRef = jniAccessors
      .getClassOf("android/content/IntentSender\$SendIntentException");
  IntentSender_SendIntentException.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  IntentSender_SendIntentException()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  IntentSender_SendIntentException.ctor1(jni.JniString name)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [name.reference]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/Exception;)V");

  /// from: public void <init>(java.lang.Exception cause)
  /// The returned object must be deleted after use, by calling the `delete` method.
  IntentSender_SendIntentException.ctor3(jni.JniObject cause)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor3, [cause.reference]).object);
}

/// from: android.content.IntentSender$OnFinished
///
/// Callback interface for discovering when a send operation has
/// completed.  Primarily for use with a IntentSender that is
/// performing a broadcast, this provides the same information as
/// calling Context\#sendOrderedBroadcast(Intent, String,
/// android.content.BroadcastReceiver, Handler, int, String, Bundle) Context.sendBroadcast() with a final BroadcastReceiver.
class IntentSender_OnFinished extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/IntentSender\$OnFinished");
  IntentSender_OnFinished.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onSendFinished = jniAccessors.getMethodIDOf(
      _classRef,
      "onSendFinished",
      "(Landroid/content/IntentSender;Landroid/content/Intent;ILjava/lang/String;Landroid/os/Bundle;)V");

  /// from: public abstract void onSendFinished(android.content.IntentSender IntentSender, android.content.Intent intent, int resultCode, java.lang.String resultData, android.os.Bundle resultExtras)
  ///
  /// Called when a send operation as completed.
  ///@param IntentSender The IntentSender this operation was sent through.
  ///@param intent The original Intent that was sent.
  ///@param resultCode The final result code determined by the send.
  ///@param resultData The final data collected by a broadcast.
  ///@param resultExtras The final extras collected by a broadcast.
  void onSendFinished(
          IntentSender IntentSender,
          intent_.Intent intent,
          int resultCode,
          jni.JniString resultData,
          bundle_.Bundle resultExtras) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onSendFinished, jni.JniType.voidType, [
        IntentSender.reference,
        intent.reference,
        resultCode,
        resultData.reference,
        resultExtras.reference
      ]).check();
}
