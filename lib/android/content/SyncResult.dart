// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "SyncStats.dart" as syncstats_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.SyncResult
///
/// This class is used to communicate the results of a sync operation to the SyncManager.
/// Based on the values here the SyncManager will determine the disposition of the
/// sync and whether or not a new sync operation needs to be scheduled in the future.
class SyncResult extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/SyncResult");
  SyncResult.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ALREADY_IN_PROGRESS = jniAccessors.getStaticFieldIDOf(
      _classRef, "ALREADY_IN_PROGRESS", "Landroid/content/SyncResult;");

  /// from: static public final android.content.SyncResult ALREADY_IN_PROGRESS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This instance of a SyncResult is returned by the SyncAdapter in response to a
  /// sync request when a sync is already underway. The SyncManager will reschedule the
  /// sync request to try again later.
  static SyncResult get ALREADY_IN_PROGRESS => SyncResult.fromRef(jniAccessors
      .getStaticField(
          _classRef, _id_ALREADY_IN_PROGRESS, jni.JniType.objectType)
      .object);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.content.SyncResult> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_databaseError =
      jniAccessors.getFieldIDOf(_classRef, "databaseError", "Z");

  /// from: public boolean databaseError
  ///
  /// Used to indicate that the SyncAdapter experienced a hard error due to an error it
  /// received from interacting with the storage layer. The SyncManager will record that
  /// the sync request failed and it will not reschedule the request.
  bool get databaseError => jniAccessors
      .getField(reference, _id_databaseError, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean databaseError
  ///
  /// Used to indicate that the SyncAdapter experienced a hard error due to an error it
  /// received from interacting with the storage layer. The SyncManager will record that
  /// the sync request failed and it will not reschedule the request.
  set databaseError(bool value) =>
      jniEnv.SetBooleanField(reference, _id_databaseError, value ? 1 : 0);

  static final _id_delayUntil =
      jniAccessors.getFieldIDOf(_classRef, "delayUntil", "J");

  /// from: public long delayUntil
  ///
  /// Used to indicate to the SyncManager that future sync requests that match the request's
  /// Account and authority should be delayed until a time in seconds since Java epoch.
  ///
  /// For example, if you want to delay the next sync for at least 5 minutes, then:
  /// <pre>
  /// result.delayUntil = (System.currentTimeMillis() / 1000) + 5 * 60;
  /// </pre>
  ///
  /// By default, when a sync fails, the system retries later with an exponential back-off
  /// with the system default initial delay time, which always wins over \#delayUntil --
  /// i.e. if the system back-off time is larger than \#delayUntil, \#delayUntil
  /// will essentially be ignored.
  int get delayUntil => jniAccessors
      .getField(reference, _id_delayUntil, jni.JniType.longType)
      .long;

  /// from: public long delayUntil
  ///
  /// Used to indicate to the SyncManager that future sync requests that match the request's
  /// Account and authority should be delayed until a time in seconds since Java epoch.
  ///
  /// For example, if you want to delay the next sync for at least 5 minutes, then:
  /// <pre>
  /// result.delayUntil = (System.currentTimeMillis() / 1000) + 5 * 60;
  /// </pre>
  ///
  /// By default, when a sync fails, the system retries later with an exponential back-off
  /// with the system default initial delay time, which always wins over \#delayUntil --
  /// i.e. if the system back-off time is larger than \#delayUntil, \#delayUntil
  /// will essentially be ignored.
  set delayUntil(int value) =>
      jniEnv.SetLongField(reference, _id_delayUntil, value);

  static final _id_fullSyncRequested =
      jniAccessors.getFieldIDOf(_classRef, "fullSyncRequested", "Z");

  /// from: public boolean fullSyncRequested
  ///
  /// If set the SyncManager will request an immediate sync with the same Account and authority
  /// (but empty extras Bundle) as was used in the sync request.
  bool get fullSyncRequested => jniAccessors
      .getField(reference, _id_fullSyncRequested, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean fullSyncRequested
  ///
  /// If set the SyncManager will request an immediate sync with the same Account and authority
  /// (but empty extras Bundle) as was used in the sync request.
  set fullSyncRequested(bool value) =>
      jniEnv.SetBooleanField(reference, _id_fullSyncRequested, value ? 1 : 0);

  static final _id_moreRecordsToGet =
      jniAccessors.getFieldIDOf(_classRef, "moreRecordsToGet", "Z");

  /// from: public boolean moreRecordsToGet
  ///
  /// This field is ignored by the SyncManager.
  bool get moreRecordsToGet => jniAccessors
      .getField(reference, _id_moreRecordsToGet, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean moreRecordsToGet
  ///
  /// This field is ignored by the SyncManager.
  set moreRecordsToGet(bool value) =>
      jniEnv.SetBooleanField(reference, _id_moreRecordsToGet, value ? 1 : 0);

  static final _id_partialSyncUnavailable =
      jniAccessors.getFieldIDOf(_classRef, "partialSyncUnavailable", "Z");

  /// from: public boolean partialSyncUnavailable
  ///
  /// This field is ignored by the SyncManager.
  bool get partialSyncUnavailable => jniAccessors
      .getField(reference, _id_partialSyncUnavailable, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean partialSyncUnavailable
  ///
  /// This field is ignored by the SyncManager.
  set partialSyncUnavailable(bool value) => jniEnv.SetBooleanField(
      reference, _id_partialSyncUnavailable, value ? 1 : 0);

  static final _id_stats = jniAccessors.getFieldIDOf(
      _classRef, "stats", "Landroid/content/SyncStats;");

  /// from: public final android.content.SyncStats stats
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used to hold extras statistics about the sync operation. Some of these indicate that
  /// the sync request resulted in a hard or soft error, others are for purely informational
  /// purposes.
  syncstats_.SyncStats get stats => syncstats_.SyncStats.fromRef(jniAccessors
      .getField(reference, _id_stats, jni.JniType.objectType)
      .object);

  static final _id_syncAlreadyInProgress =
      jniAccessors.getFieldIDOf(_classRef, "syncAlreadyInProgress", "Z");

  /// from: public final boolean syncAlreadyInProgress
  ///
  /// Used to indicate that the SyncAdapter is already performing a sync operation, though
  /// not necessarily for the requested account and authority and that it wasn't able to
  /// process this request. The SyncManager will reschedule the request to run later.
  bool get syncAlreadyInProgress => jniAccessors
      .getField(reference, _id_syncAlreadyInProgress, jni.JniType.booleanType)
      .boolean;

  static final _id_tooManyDeletions =
      jniAccessors.getFieldIDOf(_classRef, "tooManyDeletions", "Z");

  /// from: public boolean tooManyDeletions
  ///
  /// Used to indicate that the SyncAdapter determined that it would need to issue
  /// too many delete operations to the server in order to satisfy the request
  /// (as defined by the SyncAdapter). The SyncManager will record
  /// that the sync request failed and will cause a System Notification to be created
  /// asking the user what they want to do about this. It will give the user a chance to
  /// choose between (1) go ahead even with those deletes, (2) revert the deletes,
  /// or (3) take no action. If the user decides (1) or (2) the SyncManager will issue another
  /// sync request with either ContentResolver\#SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS
  /// or ContentResolver\#SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS set in the extras.
  /// It is then up to the SyncAdapter to decide how to honor that request.
  bool get tooManyDeletions => jniAccessors
      .getField(reference, _id_tooManyDeletions, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean tooManyDeletions
  ///
  /// Used to indicate that the SyncAdapter determined that it would need to issue
  /// too many delete operations to the server in order to satisfy the request
  /// (as defined by the SyncAdapter). The SyncManager will record
  /// that the sync request failed and will cause a System Notification to be created
  /// asking the user what they want to do about this. It will give the user a chance to
  /// choose between (1) go ahead even with those deletes, (2) revert the deletes,
  /// or (3) take no action. If the user decides (1) or (2) the SyncManager will issue another
  /// sync request with either ContentResolver\#SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS
  /// or ContentResolver\#SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS set in the extras.
  /// It is then up to the SyncAdapter to decide how to honor that request.
  set tooManyDeletions(bool value) =>
      jniEnv.SetBooleanField(reference, _id_tooManyDeletions, value ? 1 : 0);

  static final _id_tooManyRetries =
      jniAccessors.getFieldIDOf(_classRef, "tooManyRetries", "Z");

  /// from: public boolean tooManyRetries
  ///
  /// Used to indicate that the SyncAdapter experienced a hard error due to trying the same
  /// operation too many times (as defined by the SyncAdapter). The SyncManager will record
  /// that the sync request failed and it will not reschedule the request.
  bool get tooManyRetries => jniAccessors
      .getField(reference, _id_tooManyRetries, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean tooManyRetries
  ///
  /// Used to indicate that the SyncAdapter experienced a hard error due to trying the same
  /// operation too many times (as defined by the SyncAdapter). The SyncManager will record
  /// that the sync request failed and it will not reschedule the request.
  set tooManyRetries(bool value) =>
      jniEnv.SetBooleanField(reference, _id_tooManyRetries, value ? 1 : 0);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a "clean" SyncResult. If this is returned without any changes then the
  /// SyncManager will consider the sync to have completed successfully. The various fields
  /// can be set by the SyncAdapter in order to give the SyncManager more information as to
  /// the disposition of the sync.
  ///
  /// The errors are classified into two broad categories: hard errors and soft errors.
  /// Soft errors are retried with exponential backoff. Hard errors are not retried (except
  /// when the hard error is for a ContentResolver\#SYNC_EXTRAS_UPLOAD request,
  /// in which the request is retryed without the ContentResolver\#SYNC_EXTRAS_UPLOAD
  /// extra set). The SyncManager checks the type of error by calling
  /// SyncResult\#hasHardError() and  SyncResult\#hasSoftError(). If both are
  /// true then the SyncManager treats it as a hard error, not a soft error.
  SyncResult()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_hasHardError =
      jniAccessors.getMethodIDOf(_classRef, "hasHardError", "()Z");

  /// from: public boolean hasHardError()
  ///
  /// Convenience method for determining if the SyncResult indicates that a hard error
  /// occurred. See \#SyncResult() for an explanation of what the SyncManager does
  /// when it sees a hard error.
  ///
  /// A hard error is indicated when any of the following is true:
  /// <ul>
  /// <li> SyncStats\#numParseExceptions > 0
  /// <li> SyncStats\#numConflictDetectedExceptions > 0
  /// <li> SyncStats\#numAuthExceptions > 0
  /// <li> \#tooManyDeletions
  /// <li> \#tooManyRetries
  /// <li> \#databaseError
  ///@return true if a hard error is indicated
  bool hasHardError() => jniAccessors.callMethodWithArgs(
      reference, _id_hasHardError, jni.JniType.booleanType, []).boolean;

  static final _id_hasSoftError =
      jniAccessors.getMethodIDOf(_classRef, "hasSoftError", "()Z");

  /// from: public boolean hasSoftError()
  ///
  /// Convenience method for determining if the SyncResult indicates that a soft error
  /// occurred. See \#SyncResult() for an explanation of what the SyncManager does
  /// when it sees a soft error.
  ///
  /// A soft error is indicated when any of the following is true:
  /// <ul>
  /// <li> SyncStats\#numIoExceptions > 0
  /// <li> \#syncAlreadyInProgress
  /// </ul>
  ///@return true if a soft error is indicated
  bool hasSoftError() => jniAccessors.callMethodWithArgs(
      reference, _id_hasSoftError, jni.JniType.booleanType, []).boolean;

  static final _id_hasError =
      jniAccessors.getMethodIDOf(_classRef, "hasError", "()Z");

  /// from: public boolean hasError()
  ///
  /// A convenience method for determining of the SyncResult indicates that an error occurred.
  ///@return true if either a soft or hard error occurred
  bool hasError() => jniAccessors.callMethodWithArgs(
      reference, _id_hasError, jni.JniType.booleanType, []).boolean;

  static final _id_madeSomeProgress =
      jniAccessors.getMethodIDOf(_classRef, "madeSomeProgress", "()Z");

  /// from: public boolean madeSomeProgress()
  ///
  /// Convenience method for determining if the Sync should be rescheduled after failing for some
  /// reason.
  ///@return true if the SyncManager should reschedule this sync.
  bool madeSomeProgress() => jniAccessors.callMethodWithArgs(
      reference, _id_madeSomeProgress, jni.JniType.booleanType, []).boolean;

  static final _id_clear =
      jniAccessors.getMethodIDOf(_classRef, "clear", "()V");

  /// from: public void clear()
  ///
  /// Clears the SyncResult to a clean state. Throws an UnsupportedOperationException
  /// if this is called when \#syncAlreadyInProgress is set.
  void clear() => jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniType.voidType, []).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  void writeToParcel(parcel_.Parcel parcel, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [parcel.reference, flags]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_toDebugString = jniAccessors.getMethodIDOf(
      _classRef, "toDebugString", "()Ljava/lang/String;");

  /// from: public java.lang.String toDebugString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Generates a debugging string indicating the status.
  /// The string consist of a sequence of code letter followed by the count.
  /// Code letters are f - fullSyncRequested, r - partialSyncUnavailable,
  /// X - hardError, e - numParseExceptions, c - numConflictDetectedExceptions,
  /// a - numAuthExceptions, D - tooManyDeletions, R - tooManyRetries,
  /// b - databaseError, x - softError, l - syncAlreadyInProgress,
  /// I - numIoExceptions
  ///@return debugging string.
  jni.JniString toDebugString() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toDebugString, jni.JniType.objectType, []).object);
}
