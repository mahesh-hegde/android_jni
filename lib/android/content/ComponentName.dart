// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "Context.dart" as context_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.ComponentName
///
/// Identifier for a specific application component
/// (android.app.Activity, android.app.Service,
/// android.content.BroadcastReceiver, or
/// android.content.ContentProvider) that is available.  Two
/// pieces of information, encapsulated here, are required to identify
/// a component: the package (a String) it exists in, and the class (a String)
/// name inside of that package.
class ComponentName extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/ComponentName");
  ComponentName.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.content.ComponentName> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String pkg, java.lang.String cls)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new component identifier.
  ///@param pkg The name of the package that the component exists in.  Can
  /// not be null.
  /// This value must never be {@code null}.
  ///@param cls The name of the class inside of <var>pkg</var> that
  /// implements the component.  Can not be null.
  ///
  /// This value must never be {@code null}.
  ComponentName(jni.JniString pkg, jni.JniString cls)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [pkg.reference, cls.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;Ljava/lang/String;)V");

  /// from: public void <init>(android.content.Context pkg, java.lang.String cls)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new component identifier from a Context and class name.
  ///@param pkg A Context for the package implementing the component,
  /// from which the actual package name will be retrieved.
  /// This value must never be {@code null}.
  ///@param cls The name of the class inside of <var>pkg</var> that
  /// implements the component.
  ///
  /// This value must never be {@code null}.
  ComponentName.ctor1(context_.Context pkg, jni.JniString cls)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [pkg.reference, cls.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;Ljava/lang/Class;)V");

  /// from: public void <init>(android.content.Context pkg, java.lang.Class<?> cls)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new component identifier from a Context and Class object.
  ///@param pkg A Context for the package implementing the component, from
  /// which the actual package name will be retrieved.
  /// This value must never be {@code null}.
  ///@param cls The Class object of the desired component, from which the
  /// actual class name will be retrieved.
  ///
  /// This value must never be {@code null}.
  ComponentName.ctor2(context_.Context pkg, jni.JniObject cls)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [pkg.reference, cls.reference]).object);

  static final _id_ctor3 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Parcel;)V");

  /// from: public void <init>(android.os.Parcel in)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Instantiate a new ComponentName from the data in a Parcel that was
  /// previously written with \#writeToParcel(Parcel, int).  Note that you
  /// must not use this with data written by
  /// \#writeToParcel(ComponentName, Parcel) since it is not possible
  /// to handle a null ComponentObject here.
  ///@param in The Parcel containing the previously written ComponentName,
  /// positioned at the location in the buffer where it was written.
  ComponentName.ctor3(parcel_.Parcel in0)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor3, [in0.reference]).object);

  static final _id_createRelative = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createRelative",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/content/ComponentName;");

  /// from: static public android.content.ComponentName createRelative(java.lang.String pkg, java.lang.String cls)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new component identifier where the class name may be specified
  /// as either absolute or relative to the containing package.
  ///
  /// Relative package names begin with a <code>'.'</code> character. For a package
  /// <code>"com.example"</code> and class name <code>".app.MyActivity"</code> this method
  /// will return a ComponentName with the package <code>"com.example"</code>and class name
  /// <code>"com.example.app.MyActivity"</code>. Fully qualified class names are also
  /// permitted.
  ///
  ///@param pkg the name of the package the component exists in
  /// This value must never be {@code null}.
  ///@param cls the name of the class inside of <var>pkg</var> that implements
  ///            the component
  /// This value must never be {@code null}.
  ///@return the new ComponentName
  ///
  /// This value will never be {@code null}.
  static ComponentName createRelative(jni.JniString pkg, jni.JniString cls) =>
      ComponentName.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createRelative,
          jni.JniType.objectType,
          [pkg.reference, cls.reference]).object);

  static final _id_createRelative1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createRelative",
      "(Landroid/content/Context;Ljava/lang/String;)Landroid/content/ComponentName;");

  /// from: static public android.content.ComponentName createRelative(android.content.Context pkg, java.lang.String cls)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new component identifier where the class name may be specified
  /// as either absolute or relative to the containing package.
  ///
  /// Relative package names begin with a <code>'.'</code> character. For a package
  /// <code>"com.example"</code> and class name <code>".app.MyActivity"</code> this method
  /// will return a ComponentName with the package <code>"com.example"</code>and class name
  /// <code>"com.example.app.MyActivity"</code>. Fully qualified class names are also
  /// permitted.
  ///
  ///@param pkg a Context for the package implementing the component
  /// This value must never be {@code null}.
  ///@param cls the name of the class inside of <var>pkg</var> that implements
  ///            the component
  /// This value must never be {@code null}.
  ///@return the new ComponentName
  ///
  /// This value will never be {@code null}.
  static ComponentName createRelative1(
          context_.Context pkg, jni.JniString cls) =>
      ComponentName.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createRelative1,
          jni.JniType.objectType,
          [pkg.reference, cls.reference]).object);

  static final _id_clone = jniAccessors.getMethodIDOf(
      _classRef, "clone", "()Landroid/content/ComponentName;");

  /// from: public android.content.ComponentName clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ComponentName clone() =>
      ComponentName.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_getPackageName = jniAccessors.getMethodIDOf(
      _classRef, "getPackageName", "()Ljava/lang/String;");

  /// from: public java.lang.String getPackageName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the package name of this component.
  ///@return This value will never be {@code null}.
  jni.JniString getPackageName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPackageName, jni.JniType.objectType, []).object);

  static final _id_getClassName = jniAccessors.getMethodIDOf(
      _classRef, "getClassName", "()Ljava/lang/String;");

  /// from: public java.lang.String getClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the class name of this component.
  ///@return This value will never be {@code null}.
  jni.JniString getClassName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getClassName, jni.JniType.objectType, []).object);

  static final _id_getShortClassName = jniAccessors.getMethodIDOf(
      _classRef, "getShortClassName", "()Ljava/lang/String;");

  /// from: public java.lang.String getShortClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the class name, either fully qualified or in a shortened form
  /// (with a leading '.') if it is a suffix of the package.
  jni.JniString getShortClassName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getShortClassName, jni.JniType.objectType, []).object);

  static final _id_flattenToString = jniAccessors.getMethodIDOf(
      _classRef, "flattenToString", "()Ljava/lang/String;");

  /// from: public java.lang.String flattenToString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a String that unambiguously describes both the package and
  /// class names contained in the ComponentName.  You can later recover
  /// the ComponentName from this string through
  /// \#unflattenFromString(String).
  ///@return Returns a new String holding the package and class names.  This
  /// is represented as the package name, concatenated with a '/' and then the
  /// class name.
  ///
  /// This value will never be {@code null}.
  ///@see \#unflattenFromString(String)
  jni.JniString flattenToString() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_flattenToString, jni.JniType.objectType, []).object);

  static final _id_flattenToShortString = jniAccessors.getMethodIDOf(
      _classRef, "flattenToShortString", "()Ljava/lang/String;");

  /// from: public java.lang.String flattenToShortString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The same as \#flattenToString(), but abbreviates the class
  /// name if it is a suffix of the package.  The result can still be used
  /// with \#unflattenFromString(String).
  ///@return Returns a new String holding the package and class names.  This
  /// is represented as the package name, concatenated with a '/' and then the
  /// class name.
  ///
  /// This value will never be {@code null}.
  ///@see \#unflattenFromString(String)
  jni.JniString flattenToShortString() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_flattenToShortString, jni.JniType.objectType, []).object);

  static final _id_unflattenFromString = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "unflattenFromString",
      "(Ljava/lang/String;)Landroid/content/ComponentName;");

  /// from: static public android.content.ComponentName unflattenFromString(java.lang.String str)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Recover a ComponentName from a String that was previously created with
  /// \#flattenToString().  It splits the string at the first '/',
  /// taking the part before as the package name and the part after as the
  /// class name.  As a special convenience (to use, for example, when
  /// parsing component names on the command line), if the '/' is immediately
  /// followed by a '.' then the final class name will be the concatenation
  /// of the package name with the string following the '/'.  Thus
  /// "com.foo/.Blah" becomes package="com.foo" class="com.foo.Blah".
  ///@param str The String that was returned by flattenToString().
  /// This value must never be {@code null}.
  ///@return Returns a new ComponentName containing the package and class
  /// names that were encoded in <var>str</var>
  ///
  /// This value may be {@code null}.
  ///@see \#flattenToString()
  static ComponentName unflattenFromString(jni.JniString str) =>
      ComponentName.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_unflattenFromString,
          jni.JniType.objectType,
          [str.reference]).object);

  static final _id_toShortString = jniAccessors.getMethodIDOf(
      _classRef, "toShortString", "()Ljava/lang/String;");

  /// from: public java.lang.String toShortString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return string representation of this class without the class's name
  /// as a prefix.
  jni.JniString toShortString() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toShortString, jni.JniType.objectType, []).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_compareTo = jniAccessors.getMethodIDOf(
      _classRef, "compareTo", "(Landroid/content/ComponentName;)I");

  /// from: public int compareTo(android.content.ComponentName that)
  int compareTo(ComponentName that) => jniAccessors.callMethodWithArgs(
      reference, _id_compareTo, jni.JniType.intType, [that.reference]).integer;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(parcel_.Parcel out, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [out.reference, flags]).check();

  static final _id_writeToParcel1 = jniAccessors.getStaticMethodIDOf(_classRef,
      "writeToParcel", "(Landroid/content/ComponentName;Landroid/os/Parcel;)V");

  /// from: static public void writeToParcel(android.content.ComponentName c, android.os.Parcel out)
  ///
  /// Write a ComponentName to a Parcel, handling null pointers.  Must be
  /// read with \#readFromParcel(Parcel).
  ///@param c The ComponentName to be written.
  ///@param out The Parcel in which the ComponentName will be placed.
  ///@see \#readFromParcel(Parcel)
  static void writeToParcel1(ComponentName c, parcel_.Parcel out) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_writeToParcel1,
          jni.JniType.voidType, [c.reference, out.reference]).check();

  static final _id_readFromParcel = jniAccessors.getStaticMethodIDOf(_classRef,
      "readFromParcel", "(Landroid/os/Parcel;)Landroid/content/ComponentName;");

  /// from: static public android.content.ComponentName readFromParcel(android.os.Parcel in)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read a ComponentName from a Parcel that was previously written
  /// with \#writeToParcel(ComponentName, Parcel), returning either
  /// a null or new object as appropriate.
  ///@param in The Parcel from which to read the ComponentName
  ///@return Returns a new ComponentName matching the previously written
  /// object, or null if a null had been written.
  ///@see \#writeToParcel(ComponentName, Parcel)
  static ComponentName readFromParcel(parcel_.Parcel in0) =>
      ComponentName.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_readFromParcel, jni.JniType.objectType, [in0.reference]).object);
}
