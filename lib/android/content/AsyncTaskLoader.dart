// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Loader.dart" as loader_;

import "Context.dart" as context_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.AsyncTaskLoader
///
/// Abstract Loader that provides an AsyncTask to do the work.  See
/// Loader and android.app.LoaderManager for more details.
///
/// Here is an example implementation of an AsyncTaskLoader subclass that
/// loads the currently installed applications from the package manager.  This
/// implementation takes care of retrieving the application labels and sorting
/// its result set from them, monitoring for changes to the installed
/// applications, and rebuilding the list when a change in configuration requires
/// this (such as a locale change).
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/LoaderCustom.java
///      loader}
///
/// An example implementation of a fragment that uses the above loader to show
/// the currently installed applications in a list is below.
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/LoaderCustom.java
///      fragment}
///@param <D> the data type to be loaded.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.content.AsyncTaskLoader
class AsyncTaskLoader extends loader_.Loader {
  static final _classRef =
      jniAccessors.getClassOf("android/content/AsyncTaskLoader");
  AsyncTaskLoader.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AsyncTaskLoader(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_setUpdateThrottle =
      jniAccessors.getMethodIDOf(_classRef, "setUpdateThrottle", "(J)V");

  /// from: public void setUpdateThrottle(long delayMS)
  ///
  /// Set amount to throttle updates by.  This is the minimum time from
  /// when the last \#loadInBackground() call has completed until
  /// a new load is scheduled.
  ///@param delayMS Amount of delay, in milliseconds.
  void setUpdateThrottle(int delayMS) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setUpdateThrottle,
      jni.JniType.voidType,
      [delayMS]).check();

  static final _id_onForceLoad =
      jniAccessors.getMethodIDOf(_classRef, "onForceLoad", "()V");

  /// from: protected void onForceLoad()
  void onForceLoad() => jniAccessors.callMethodWithArgs(
      reference, _id_onForceLoad, jni.JniType.voidType, []).check();

  static final _id_onCancelLoad =
      jniAccessors.getMethodIDOf(_classRef, "onCancelLoad", "()Z");

  /// from: protected boolean onCancelLoad()
  bool onCancelLoad() => jniAccessors.callMethodWithArgs(
      reference, _id_onCancelLoad, jni.JniType.booleanType, []).boolean;

  static final _id_cancelLoadInBackground =
      jniAccessors.getMethodIDOf(_classRef, "cancelLoadInBackground", "()V");

  /// from: public void cancelLoadInBackground()
  ///
  /// Called on the main thread to abort a load in progress.
  ///
  /// Override this method to abort the current invocation of \#loadInBackground
  /// that is running in the background on a worker thread.
  ///
  /// This method should do nothing if \#loadInBackground has not started
  /// running or if it has already finished.
  ///@see \#loadInBackground
  void cancelLoadInBackground() => jniAccessors.callMethodWithArgs(
      reference, _id_cancelLoadInBackground, jni.JniType.voidType, []).check();

  static final _id_isLoadInBackgroundCanceled = jniAccessors.getMethodIDOf(
      _classRef, "isLoadInBackgroundCanceled", "()Z");

  /// from: public boolean isLoadInBackgroundCanceled()
  ///
  /// Returns true if the current invocation of \#loadInBackground is being canceled.
  ///@return True if the current invocation of \#loadInBackground is being canceled.
  ///@see \#loadInBackground
  bool isLoadInBackgroundCanceled() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isLoadInBackgroundCanceled,
      jni.JniType.booleanType, []).boolean;

  static final _id_dump = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/lang/String;Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: public void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_dump, jni.JniType.voidType, [
        prefix.reference,
        fd.reference,
        writer.reference,
        args.reference
      ]).check();
}
