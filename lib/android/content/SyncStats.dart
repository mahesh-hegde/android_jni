// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.SyncStats
///
/// Used to record various statistics about the result of a sync operation. The SyncManager
/// gets access to these via a SyncResult and uses some of them to determine the
/// disposition of the sync. See SyncResult for further dicussion on how the
/// SyncManager uses these values.
class SyncStats extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/content/SyncStats");
  SyncStats.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.content.SyncStats> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_numAuthExceptions =
      jniAccessors.getFieldIDOf(_classRef, "numAuthExceptions", "J");

  /// from: public long numAuthExceptions
  ///
  /// The SyncAdapter was unable to authenticate the android.accounts.Account
  /// that was specified in the request. The user needs to take some action to resolve
  /// before a future request can expect to succeed. This is considered a hard error.
  int get numAuthExceptions => jniAccessors
      .getField(reference, _id_numAuthExceptions, jni.JniType.longType)
      .long;

  /// from: public long numAuthExceptions
  ///
  /// The SyncAdapter was unable to authenticate the android.accounts.Account
  /// that was specified in the request. The user needs to take some action to resolve
  /// before a future request can expect to succeed. This is considered a hard error.
  set numAuthExceptions(int value) =>
      jniEnv.SetLongField(reference, _id_numAuthExceptions, value);

  static final _id_numConflictDetectedExceptions = jniAccessors.getFieldIDOf(
      _classRef, "numConflictDetectedExceptions", "J");

  /// from: public long numConflictDetectedExceptions
  ///
  /// The SyncAdapter detected that there was an unrecoverable version conflict when it
  /// attempted to update or delete a version of a resource on the server. This is expected
  /// to clear itself automatically once the new state is retrieved from the server,
  /// though it may remain until the user intervenes manually, perhaps by clearing the
  /// local storage and starting over frmo scratch. This is considered a hard error.
  int get numConflictDetectedExceptions => jniAccessors
      .getField(
          reference, _id_numConflictDetectedExceptions, jni.JniType.longType)
      .long;

  /// from: public long numConflictDetectedExceptions
  ///
  /// The SyncAdapter detected that there was an unrecoverable version conflict when it
  /// attempted to update or delete a version of a resource on the server. This is expected
  /// to clear itself automatically once the new state is retrieved from the server,
  /// though it may remain until the user intervenes manually, perhaps by clearing the
  /// local storage and starting over frmo scratch. This is considered a hard error.
  set numConflictDetectedExceptions(int value) =>
      jniEnv.SetLongField(reference, _id_numConflictDetectedExceptions, value);

  static final _id_numDeletes =
      jniAccessors.getFieldIDOf(_classRef, "numDeletes", "J");

  /// from: public long numDeletes
  ///
  /// Counter for tracking how many deletes were performed by the sync operation, as defined
  /// by the SyncAdapter.
  int get numDeletes => jniAccessors
      .getField(reference, _id_numDeletes, jni.JniType.longType)
      .long;

  /// from: public long numDeletes
  ///
  /// Counter for tracking how many deletes were performed by the sync operation, as defined
  /// by the SyncAdapter.
  set numDeletes(int value) =>
      jniEnv.SetLongField(reference, _id_numDeletes, value);

  static final _id_numEntries =
      jniAccessors.getFieldIDOf(_classRef, "numEntries", "J");

  /// from: public long numEntries
  ///
  /// Counter for tracking how many entries were affected by the sync operation, as defined
  /// by the SyncAdapter.
  int get numEntries => jniAccessors
      .getField(reference, _id_numEntries, jni.JniType.longType)
      .long;

  /// from: public long numEntries
  ///
  /// Counter for tracking how many entries were affected by the sync operation, as defined
  /// by the SyncAdapter.
  set numEntries(int value) =>
      jniEnv.SetLongField(reference, _id_numEntries, value);

  static final _id_numInserts =
      jniAccessors.getFieldIDOf(_classRef, "numInserts", "J");

  /// from: public long numInserts
  ///
  /// Counter for tracking how many inserts were performed by the sync operation, as defined
  /// by the SyncAdapter.
  int get numInserts => jniAccessors
      .getField(reference, _id_numInserts, jni.JniType.longType)
      .long;

  /// from: public long numInserts
  ///
  /// Counter for tracking how many inserts were performed by the sync operation, as defined
  /// by the SyncAdapter.
  set numInserts(int value) =>
      jniEnv.SetLongField(reference, _id_numInserts, value);

  static final _id_numIoExceptions =
      jniAccessors.getFieldIDOf(_classRef, "numIoExceptions", "J");

  /// from: public long numIoExceptions
  ///
  /// The SyncAdapter had a problem, most likely with the network connectivity or a timeout
  /// while waiting for a network response. The request may succeed if it is tried again
  /// later. This is considered a soft error.
  int get numIoExceptions => jniAccessors
      .getField(reference, _id_numIoExceptions, jni.JniType.longType)
      .long;

  /// from: public long numIoExceptions
  ///
  /// The SyncAdapter had a problem, most likely with the network connectivity or a timeout
  /// while waiting for a network response. The request may succeed if it is tried again
  /// later. This is considered a soft error.
  set numIoExceptions(int value) =>
      jniEnv.SetLongField(reference, _id_numIoExceptions, value);

  static final _id_numParseExceptions =
      jniAccessors.getFieldIDOf(_classRef, "numParseExceptions", "J");

  /// from: public long numParseExceptions
  ///
  /// The SyncAdapter had a problem with the data it received from the server or the storage
  /// later. This problem will likely repeat if the request is tried again. The problem
  /// will need to be cleared up by either the server or the storage layer (likely with help
  /// from the user). If the SyncAdapter cleans up the data itself then it typically won't
  /// increment this value although it may still do so in order to record that it had to
  /// perform some cleanup. E.g., if the SyncAdapter received a bad entry from the server
  /// when processing a feed of entries, it may choose to drop the entry and thus make
  /// progress and still increment this value just so the SyncAdapter can record that an
  /// error occurred. This is considered a hard error.
  int get numParseExceptions => jniAccessors
      .getField(reference, _id_numParseExceptions, jni.JniType.longType)
      .long;

  /// from: public long numParseExceptions
  ///
  /// The SyncAdapter had a problem with the data it received from the server or the storage
  /// later. This problem will likely repeat if the request is tried again. The problem
  /// will need to be cleared up by either the server or the storage layer (likely with help
  /// from the user). If the SyncAdapter cleans up the data itself then it typically won't
  /// increment this value although it may still do so in order to record that it had to
  /// perform some cleanup. E.g., if the SyncAdapter received a bad entry from the server
  /// when processing a feed of entries, it may choose to drop the entry and thus make
  /// progress and still increment this value just so the SyncAdapter can record that an
  /// error occurred. This is considered a hard error.
  set numParseExceptions(int value) =>
      jniEnv.SetLongField(reference, _id_numParseExceptions, value);

  static final _id_numSkippedEntries =
      jniAccessors.getFieldIDOf(_classRef, "numSkippedEntries", "J");

  /// from: public long numSkippedEntries
  ///
  /// Counter for tracking how many entries, either from the server or the local store, were
  /// ignored during the sync operation. This could happen if the SyncAdapter detected some
  /// unparsable data but decided to skip it and move on rather than failing immediately.
  int get numSkippedEntries => jniAccessors
      .getField(reference, _id_numSkippedEntries, jni.JniType.longType)
      .long;

  /// from: public long numSkippedEntries
  ///
  /// Counter for tracking how many entries, either from the server or the local store, were
  /// ignored during the sync operation. This could happen if the SyncAdapter detected some
  /// unparsable data but decided to skip it and move on rather than failing immediately.
  set numSkippedEntries(int value) =>
      jniEnv.SetLongField(reference, _id_numSkippedEntries, value);

  static final _id_numUpdates =
      jniAccessors.getFieldIDOf(_classRef, "numUpdates", "J");

  /// from: public long numUpdates
  ///
  /// Counter for tracking how many updates were performed by the sync operation, as defined
  /// by the SyncAdapter.
  int get numUpdates => jniAccessors
      .getField(reference, _id_numUpdates, jni.JniType.longType)
      .long;

  /// from: public long numUpdates
  ///
  /// Counter for tracking how many updates were performed by the sync operation, as defined
  /// by the SyncAdapter.
  set numUpdates(int value) =>
      jniEnv.SetLongField(reference, _id_numUpdates, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  SyncStats()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Parcel;)V");

  /// from: public void <init>(android.os.Parcel in)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SyncStats.ctor1(parcel_.Parcel in0)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [in0.reference]).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_clear =
      jniAccessors.getMethodIDOf(_classRef, "clear", "()V");

  /// from: public void clear()
  ///
  /// Reset all the counters to 0.
  void clear() => jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniType.voidType, []).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}
