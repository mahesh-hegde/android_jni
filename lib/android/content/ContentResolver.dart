// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Context.dart" as context_;

import "../net/Uri.dart" as uri_;

import "../database/Cursor.dart" as cursor_;

import "../os/CancellationSignal.dart" as cancellationsignal_;

import "../os/Bundle.dart" as bundle_;

import "../os/ParcelFileDescriptor.dart" as parcelfiledescriptor_;

import "res/AssetFileDescriptor.dart" as assetfiledescriptor_;

import "ContentValues.dart" as contentvalues_;

import "ContentProviderClient.dart" as contentproviderclient_;

import "../database/ContentObserver.dart" as contentobserver_;

import "../accounts/Account.dart" as account_;

import "SyncRequest.dart" as syncrequest_;

import "SyncInfo.dart" as syncinfo_;

import "SyncStatusObserver.dart" as syncstatusobserver_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.ContentResolver
///
/// This class provides applications access to the content model.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using a ContentResolver with content providers, read the
/// <a href="{@docRoot}guide/topics/providers/content-providers.html">Content Providers</a>
/// developer guide.
///
class ContentResolver extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/ContentResolver");
  ContentResolver.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ANY_CURSOR_ITEM_TYPE
  ///
  /// This is the Android platform's generic MIME type to match any MIME
  /// type of the form "\#CURSOR_ITEM_BASE_TYPE/{@code SUB_TYPE}".
  /// {@code SUB_TYPE} is the sub-type of the application-dependent
  /// content, e.g., "audio", "video", "playlist".
  static const ANY_CURSOR_ITEM_TYPE = "vnd.android.cursor.item/*";

  /// from: static public final java.lang.String CURSOR_DIR_BASE_TYPE
  ///
  /// This is the Android platform's base MIME type for a content: URI
  /// containing a Cursor of zero or more items.  Applications should use this
  /// as the base type along with their own sub-type of their content: URIs
  /// that represent a directory of items.  For example, hypothetical IMAP email
  /// client may have a URI
  /// <code>content://com.company.provider.imap/inbox</code> for all of the
  /// messages in its inbox, whose MIME type would be reported as
  /// <code>CURSOR_DIR_BASE_TYPE + "/vnd.company.imap-msg"</code>
  ///
  /// Note how the base MIME type varies between this and
  /// \#CURSOR_ITEM_BASE_TYPE depending on whether there is
  /// one single item or multiple items in the data set, while the sub-type
  /// remains the same because in either case the data structure contained
  /// in the cursor is the same.
  static const CURSOR_DIR_BASE_TYPE = "vnd.android.cursor.dir";

  /// from: static public final java.lang.String CURSOR_ITEM_BASE_TYPE
  ///
  /// This is the Android platform's base MIME type for a content: URI
  /// containing a Cursor of a single item.  Applications should use this
  /// as the base type along with their own sub-type of their content: URIs
  /// that represent a particular item.  For example, hypothetical IMAP email
  /// client may have a URI
  /// <code>content://com.company.provider.imap/inbox/1</code> for a particular
  /// message in the inbox, whose MIME type would be reported as
  /// <code>CURSOR_ITEM_BASE_TYPE + "/vnd.company.imap-msg"</code>
  ///
  /// Compare with \#CURSOR_DIR_BASE_TYPE.
  static const CURSOR_ITEM_BASE_TYPE = "vnd.android.cursor.item";

  /// from: static public final java.lang.String EXTRA_HONORED_ARGS
  ///
  /// Allows provider to report back to client which query keys are honored in a Cursor.
  ///
  /// Key identifying a {@code String[]} containing all QUERY_ARG_SORT* arguments
  /// honored by the provider. Include this in Cursor extras Bundle
  /// when any QUERY_ARG_SORT* value was honored during the preparation of the
  /// results Cursor.
  ///
  /// If present, ALL honored arguments are enumerated in this extra\u2019s payload.
  ///@see \#QUERY_ARG_SORT_COLUMNS
  ///@see \#QUERY_ARG_SORT_DIRECTION
  ///@see \#QUERY_ARG_SORT_COLLATION
  static const EXTRA_HONORED_ARGS = "android.content.extra.HONORED_ARGS";

  /// from: static public final java.lang.String EXTRA_REFRESH_SUPPORTED
  ///
  /// An extra boolean describing whether a particular provider supports refresh
  /// or not. If a provider supports refresh, it should include this key in its
  /// returned Cursor as part of its query call.
  static const EXTRA_REFRESH_SUPPORTED =
      "android.content.extra.REFRESH_SUPPORTED";

  /// from: static public final java.lang.String EXTRA_SIZE
  ///
  /// An extra Point describing the optimal size for a requested image
  /// resource, in pixels. If a provider has multiple sizes of the image, it
  /// should return the image closest to this size.
  ///@see \#openTypedAssetFileDescriptor(Uri, String, Bundle)
  ///@see \#openTypedAssetFileDescriptor(Uri, String, Bundle,
  ///      CancellationSignal)
  static const EXTRA_SIZE = "android.content.extra.SIZE";

  /// from: static public final java.lang.String EXTRA_TOTAL_COUNT
  ///
  /// Added to Cursor extras Bundle to indicate total row count of
  /// recordset when paging is supported. Providers must include this when
  /// implementing paging support.
  ///
  /// A provider may return -1 that row count of the recordset is unknown.
  ///
  /// Providers having returned -1 in a previous query are recommended to
  /// send content change notification once (if) full recordset size becomes
  /// known.
  static const EXTRA_TOTAL_COUNT = "android.content.extra.TOTAL_COUNT";

  /// from: static public final int NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS
  ///
  /// Flag for \#notifyChange(Uri, ContentObserver, int): if set, this notification
  /// will be skipped if it is being delivered to the root URI of a ContentObserver that is
  /// using "notify for descendants."  The purpose of this is to allow the provide to send
  /// a general notification of "something under X" changed that observers of that specific
  /// URI can receive, while also sending a specific URI under X.  It would use this flag
  /// when sending the former, so that observers of "X and descendants" only see the latter.
  static const NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS = 2;

  /// from: static public final int NOTIFY_SYNC_TO_NETWORK
  ///
  /// Flag for \#notifyChange(Uri, ContentObserver, int): attempt to sync the change
  /// to the network.
  static const NOTIFY_SYNC_TO_NETWORK = 1;

  /// from: static public final java.lang.String QUERY_ARG_LIMIT
  ///
  /// Specifies the max number of rows to include in a Cursor.
  static const QUERY_ARG_LIMIT = "android:query-arg-limit";

  /// from: static public final java.lang.String QUERY_ARG_OFFSET
  ///
  /// Specifies the offset row index within a Cursor.
  static const QUERY_ARG_OFFSET = "android:query-arg-offset";

  /// from: static public final java.lang.String QUERY_ARG_SORT_COLLATION
  ///
  /// Allows client to specify a hint to the provider declaring which collation
  /// to use when sorting text values.
  ///
  /// Providers may support custom collators. When specifying a custom collator
  /// the value is determined by the Provider.
  ///
  /// <li>ContentProvider implementations: When preparing data in
  /// ContentProvider\#query(Uri, String[], Bundle, CancellationSignal), if sort collation
  /// is reflected in the returned Cursor, it is  strongly recommended that
  /// \#QUERY_ARG_SORT_COLLATION then be included in the array of honored arguments
  /// reflected in Cursor extras Bundle under \#EXTRA_HONORED_ARGS.
  ///
  /// <li>When querying a provider, where no QUERY_ARG_SQL* otherwise exists in the
  /// arguments Bundle, the Content framework will attempt to synthesize
  /// a QUERY_ARG_SQL* argument using the corresponding QUERY_ARG_SORT* values.
  ///@see java.text.Collator\#PRIMARY
  ///@see java.text.Collator\#SECONDARY
  ///@see java.text.Collator\#TERTIARY
  ///@see java.text.Collator\#IDENTICAL
  static const QUERY_ARG_SORT_COLLATION = "android:query-arg-sort-collation";

  /// from: static public final java.lang.String QUERY_ARG_SORT_COLUMNS
  ///
  /// Specifies the list of columns against which to sort results. When first column values
  /// are identical, records are then sorted based on second column values, and so on.
  ///
  /// Columns present in this list must also be included in the projection
  /// supplied to ContentResolver\#query(Uri, String[], Bundle, CancellationSignal).
  ///
  /// Apps targeting android.os.Build.VERSION_CODES\#O or higher:
  ///
  /// <li>ContentProvider implementations: When preparing data in
  /// ContentProvider\#query(Uri, String[], Bundle, CancellationSignal), if sort columns
  /// is reflected in the returned Cursor, it is  strongly recommended that
  /// \#QUERY_ARG_SORT_COLUMNS then be included in the array of honored arguments
  /// reflected in Cursor extras Bundle under \#EXTRA_HONORED_ARGS.
  ///
  /// <li>When querying a provider, where no QUERY_ARG_SQL* otherwise exists in the
  /// arguments Bundle, the Content framework will attempt to synthesize
  /// an QUERY_ARG_SQL* argument using the corresponding QUERY_ARG_SORT* values.
  static const QUERY_ARG_SORT_COLUMNS = "android:query-arg-sort-columns";

  /// from: static public final java.lang.String QUERY_ARG_SORT_DIRECTION
  ///
  /// Specifies desired sort order. When unspecified a provider may provide a default
  /// sort direction, or choose to return unsorted results.
  ///
  /// Apps targeting android.os.Build.VERSION_CODES\#O or higher:
  ///
  /// <li>ContentProvider implementations: When preparing data in
  /// ContentProvider\#query(Uri, String[], Bundle, CancellationSignal), if sort direction
  /// is reflected in the returned Cursor, it is  strongly recommended that
  /// \#QUERY_ARG_SORT_DIRECTION then be included in the array of honored arguments
  /// reflected in Cursor extras Bundle under \#EXTRA_HONORED_ARGS.
  ///
  /// <li>When querying a provider, where no QUERY_ARG_SQL* otherwise exists in the
  /// arguments Bundle, the Content framework will attempt to synthesize
  /// a QUERY_ARG_SQL* argument using the corresponding QUERY_ARG_SORT* values.
  ///@see \#QUERY_SORT_DIRECTION_ASCENDING
  ///@see \#QUERY_SORT_DIRECTION_DESCENDING
  static const QUERY_ARG_SORT_DIRECTION = "android:query-arg-sort-direction";

  /// from: static public final java.lang.String QUERY_ARG_SQL_SELECTION
  ///
  /// Key for an SQL style selection string that may be present in the query Bundle argument
  /// passed to ContentProvider\#query(Uri, String[], Bundle, CancellationSignal)
  /// when called by a legacy client.
  ///
  /// Clients should never include user supplied values directly in the selection string,
  /// as this presents an avenue for SQL injection attacks. In lieu of this, a client
  /// should use standard placeholder notation to represent values in a selection string,
  /// then supply a corresponding value in {@value \#QUERY_ARG_SQL_SELECTION_ARGS}.
  ///
  /// __Apps targeting android.os.Build.VERSION_CODES\#O or higher are strongly
  /// encourage to use structured query arguments in lieu of opaque SQL query clauses.__
  ///@see \#QUERY_ARG_SORT_COLUMNS
  ///@see \#QUERY_ARG_SORT_DIRECTION
  ///@see \#QUERY_ARG_SORT_COLLATION
  static const QUERY_ARG_SQL_SELECTION = "android:query-arg-sql-selection";

  /// from: static public final java.lang.String QUERY_ARG_SQL_SELECTION_ARGS
  ///
  /// Key for SQL selection string arguments list.
  ///
  /// Clients should never include user supplied values directly in the selection string,
  /// as this presents an avenue for SQL injection attacks. In lieu of this, a client
  /// should use standard placeholder notation to represent values in a selection string,
  /// then supply a corresponding value in {@value \#QUERY_ARG_SQL_SELECTION_ARGS}.
  ///
  /// __Apps targeting android.os.Build.VERSION_CODES\#O or higher are strongly
  /// encourage to use structured query arguments in lieu of opaque SQL query clauses.__
  ///@see \#QUERY_ARG_SORT_COLUMNS
  ///@see \#QUERY_ARG_SORT_DIRECTION
  ///@see \#QUERY_ARG_SORT_COLLATION
  static const QUERY_ARG_SQL_SELECTION_ARGS =
      "android:query-arg-sql-selection-args";

  /// from: static public final java.lang.String QUERY_ARG_SQL_SORT_ORDER
  ///
  /// Key for an SQL style sort string that may be present in the query Bundle argument
  /// passed to ContentProvider\#query(Uri, String[], Bundle, CancellationSignal)
  /// when called by a legacy client.
  ///
  /// __Apps targeting android.os.Build.VERSION_CODES\#O or higher are strongly
  /// encourage to use structured query arguments in lieu of opaque SQL query clauses.__
  ///@see \#QUERY_ARG_SORT_COLUMNS
  ///@see \#QUERY_ARG_SORT_DIRECTION
  ///@see \#QUERY_ARG_SORT_COLLATION
  static const QUERY_ARG_SQL_SORT_ORDER = "android:query-arg-sql-sort-order";

  /// from: static public final int QUERY_SORT_DIRECTION_ASCENDING
  static const QUERY_SORT_DIRECTION_ASCENDING = 0;

  /// from: static public final int QUERY_SORT_DIRECTION_DESCENDING
  static const QUERY_SORT_DIRECTION_DESCENDING = 1;

  /// from: static public final java.lang.String SCHEME_ANDROID_RESOURCE
  static const SCHEME_ANDROID_RESOURCE = "android.resource";

  /// from: static public final java.lang.String SCHEME_CONTENT
  static const SCHEME_CONTENT = "content";

  /// from: static public final java.lang.String SCHEME_FILE
  static const SCHEME_FILE = "file";

  /// from: static public final java.lang.String SYNC_EXTRAS_ACCOUNT
  ///
  /// @deprecated instead use
  /// \#requestSync(android.accounts.Account, String, android.os.Bundle)
  static const SYNC_EXTRAS_ACCOUNT = "account";

  /// from: static public final java.lang.String SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS
  ///
  /// Indicates that the sync adapter should not proceed with the delete operations,
  /// if it determines that there are too many.
  /// See SyncResult\#tooManyDeletions
  static const SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS = "discard_deletions";

  /// from: static public final java.lang.String SYNC_EXTRAS_DO_NOT_RETRY
  ///
  /// If this extra is set to true then the request will not be retried if it fails.
  static const SYNC_EXTRAS_DO_NOT_RETRY = "do_not_retry";

  /// from: static public final java.lang.String SYNC_EXTRAS_EXPEDITED
  ///
  /// If this extra is set to true, the sync request will be scheduled
  /// at the front of the sync request queue and without any delay
  static const SYNC_EXTRAS_EXPEDITED = "expedited";

  /// from: static public final java.lang.String SYNC_EXTRAS_FORCE
  ///
  /// @deprecated instead use
  /// \#SYNC_EXTRAS_MANUAL
  static const SYNC_EXTRAS_FORCE = "force";

  /// from: static public final java.lang.String SYNC_EXTRAS_IGNORE_BACKOFF
  ///
  /// If this extra is set to true then any backoffs for the initial attempt (e.g.&nbsp;due to retries)
  /// are ignored by the sync scheduler. If this request fails and gets rescheduled then the
  /// retries will still honor the backoff.
  static const SYNC_EXTRAS_IGNORE_BACKOFF = "ignore_backoff";

  /// from: static public final java.lang.String SYNC_EXTRAS_IGNORE_SETTINGS
  ///
  /// If this extra is set to true then the sync settings (like getSyncAutomatically())
  /// are ignored by the sync scheduler.
  static const SYNC_EXTRAS_IGNORE_SETTINGS = "ignore_settings";

  /// from: static public final java.lang.String SYNC_EXTRAS_INITIALIZE
  ///
  /// Set by the SyncManager to request that the SyncAdapter initialize itself for
  /// the given account/authority pair. One required initialization step is to
  /// ensure that \#setIsSyncable(android.accounts.Account, String, int) has been
  /// called with a >= 0 value. When this flag is set the SyncAdapter does not need to
  /// do a full sync, though it is allowed to do so.
  static const SYNC_EXTRAS_INITIALIZE = "initialize";

  /// from: static public final java.lang.String SYNC_EXTRAS_MANUAL
  ///
  /// Setting this extra is the equivalent of setting both \#SYNC_EXTRAS_IGNORE_SETTINGS
  /// and \#SYNC_EXTRAS_IGNORE_BACKOFF
  static const SYNC_EXTRAS_MANUAL = "force";

  /// from: static public final java.lang.String SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS
  ///
  /// Indicates that the sync adapter should proceed with the delete operations,
  /// even if it determines that there are too many.
  /// See SyncResult\#tooManyDeletions
  static const SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS = "deletions_override";

  /// from: static public final java.lang.String SYNC_EXTRAS_REQUIRE_CHARGING
  ///
  /// If this extra is set to true, the sync request will be scheduled
  /// only when the device is plugged in. This is equivalent to calling
  /// setRequiresCharging(true) on SyncRequest.
  static const SYNC_EXTRAS_REQUIRE_CHARGING = "require_charging";

  /// from: static public final java.lang.String SYNC_EXTRAS_UPLOAD
  ///
  /// Indicates that this sync is intended to only upload local changes to the server.
  /// For example, this will be set to true if the sync is initiated by a call to
  /// ContentResolver\#notifyChange(android.net.Uri, android.database.ContentObserver, boolean)
  static const SYNC_EXTRAS_UPLOAD = "upload";

  /// from: static public final int SYNC_OBSERVER_TYPE_ACTIVE
  static const SYNC_OBSERVER_TYPE_ACTIVE = 4;

  /// from: static public final int SYNC_OBSERVER_TYPE_PENDING
  static const SYNC_OBSERVER_TYPE_PENDING = 2;

  /// from: static public final int SYNC_OBSERVER_TYPE_SETTINGS
  static const SYNC_OBSERVER_TYPE_SETTINGS = 1;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ContentResolver(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_getType = jniAccessors.getMethodIDOf(
      _classRef, "getType", "(Landroid/net/Uri;)Ljava/lang/String;");

  /// from: public final java.lang.String getType(android.net.Uri url)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the MIME type of the given content URL.
  ///@param url A Uri identifying content (either a list or specific type),
  /// using the content:// scheme.
  /// This value must never be {@code null}.
  ///@return A MIME type for the content, or null if the URL is invalid or the type is unknown
  jni.JniString getType(uri_.Uri url) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getType, jni.JniType.objectType, [url.reference]).object);

  static final _id_getStreamTypes = jniAccessors.getMethodIDOf(
      _classRef,
      "getStreamTypes",
      "(Landroid/net/Uri;Ljava/lang/String;)[Ljava/lang/String;");

  /// from: public java.lang.String[] getStreamTypes(android.net.Uri url, java.lang.String mimeTypeFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query for the possible MIME types for the representations the given
  /// content URL can be returned when opened as as stream with
  /// \#openTypedAssetFileDescriptor.  Note that the types here are
  /// not necessarily a superset of the type returned by \#getType --
  /// many content providers cannot return a raw stream for the structured
  /// data that they contain.
  ///@param url A Uri identifying content (either a list or specific type),
  /// using the content:// scheme.
  /// This value must never be {@code null}.
  ///@param mimeTypeFilter The desired MIME type.  This may be a pattern,
  /// such as *&\#47;*, to query for all available MIME types that match the
  /// pattern.
  /// This value must never be {@code null}.
  ///@return Returns an array of MIME type strings for all available
  /// data streams that match the given mimeTypeFilter.  If there are none,
  /// null is returned.
  jni.JniObject getStreamTypes(uri_.Uri url, jni.JniString mimeTypeFilter) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getStreamTypes,
          jni.JniType.objectType,
          [url.reference, mimeTypeFilter.reference]).object);

  static final _id_query = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the given URI, returning a Cursor over the result set.
  ///
  /// For best performance, the caller should follow these guidelines:
  /// <ul>
  /// <li>Provide an explicit projection, to prevent
  /// reading data from storage that aren't going to be used.</li>
  /// <li>Use question mark parameter markers such as 'phone=?' instead of
  /// explicit values in the {@code selection} parameter, so that queries
  /// that differ only by those values will be recognized as the same
  /// for caching purposes.</li>
  /// </ul>
  ///
  ///
  ///@param uri The URI, using the content:// scheme, for the content to
  ///         retrieve.
  /// This value must never be {@code null}.
  ///@param projection A list of which columns to return. Passing null will
  ///         return all columns, which is inefficient.
  /// This value may be {@code null}.
  ///@param selection A filter declaring which rows to return, formatted as an
  ///         SQL WHERE clause (excluding the WHERE itself). Passing null will
  ///         return all rows for the given URI.
  /// This value may be {@code null}.
  ///@param selectionArgs You may include ?s in selection, which will be
  ///         replaced by the values from selectionArgs, in the order that they
  ///         appear in the selection. The values will be bound as Strings.
  /// This value may be {@code null}.
  ///@param sortOrder How to order the rows, formatted as an SQL ORDER BY
  ///         clause (excluding the ORDER BY itself). Passing null will use the
  ///         default sort order, which may be unordered.
  /// This value may be {@code null}.
  ///@return A Cursor object, which is positioned before the first entry, or null
  ///@see Cursor
  cursor_.Cursor query(
          uri_.Uri uri,
          jni.JniObject projection,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString sortOrder) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query, jni.JniType.objectType, [
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference
      ]).object);

  static final _id_query1 = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/database/Cursor;");

  /// from: public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the given URI, returning a Cursor over the result set
  /// with optional support for cancellation.
  ///
  /// For best performance, the caller should follow these guidelines:
  /// <ul>
  /// <li>Provide an explicit projection, to prevent
  /// reading data from storage that aren't going to be used.</li>
  /// <li>Use question mark parameter markers such as 'phone=?' instead of
  /// explicit values in the {@code selection} parameter, so that queries
  /// that differ only by those values will be recognized as the same
  /// for caching purposes.</li>
  /// </ul>
  ///
  ///
  ///@param uri The URI, using the content:// scheme, for the content to
  ///         retrieve.
  /// This value must never be {@code null}.
  ///@param projection A list of which columns to return. Passing null will
  ///         return all columns, which is inefficient.
  /// This value may be {@code null}.
  ///@param selection A filter declaring which rows to return, formatted as an
  ///         SQL WHERE clause (excluding the WHERE itself). Passing null will
  ///         return all rows for the given URI.
  /// This value may be {@code null}.
  ///@param selectionArgs You may include ?s in selection, which will be
  ///         replaced by the values from selectionArgs, in the order that they
  ///         appear in the selection. The values will be bound as Strings.
  /// This value may be {@code null}.
  ///@param sortOrder How to order the rows, formatted as an SQL ORDER BY
  ///         clause (excluding the ORDER BY itself). Passing null will use the
  ///         default sort order, which may be unordered.
  /// This value may be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress, or null if none.
  /// If the operation is canceled, then OperationCanceledException will be thrown
  /// when the query is executed.
  /// This value may be {@code null}.
  ///@return A Cursor object, which is positioned before the first entry, or null
  ///@see Cursor
  cursor_.Cursor query1(
          uri_.Uri uri,
          jni.JniObject projection,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString sortOrder,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query1, jni.JniType.objectType, [
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference,
        cancellationSignal.reference
      ]).object);

  static final _id_query2 = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/net/Uri;[Ljava/lang/String;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Landroid/database/Cursor;");

  /// from: public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, android.os.Bundle queryArgs, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the given URI, returning a Cursor over the result set
  /// with support for cancellation.
  ///
  /// For best performance, the caller should follow these guidelines:
  ///
  /// <li>Provide an explicit projection, to prevent reading data from storage
  /// that aren't going to be used.
  ///
  /// Provider must identify which QUERY_ARG_SORT* arguments were honored during
  /// the preparation of the result set by including the respective argument keys
  /// in the Cursor extras Bundle. See \#EXTRA_HONORED_ARGS
  /// for details.
  ///@see \#QUERY_ARG_SORT_COLUMNS, \#QUERY_ARG_SORT_DIRECTION, \#QUERY_ARG_SORT_COLLATION.
  ///@param uri The URI, using the content:// scheme, for the content to
  ///         retrieve.
  /// This value must never be {@code null}.
  ///@param projection A list of which columns to return. Passing null will
  ///         return all columns, which is inefficient.
  /// This value may be {@code null}.
  ///@param queryArgs A Bundle containing any arguments to the query.
  /// This value may be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress, or null if none.
  /// If the operation is canceled, then OperationCanceledException will be thrown
  /// when the query is executed.
  /// This value may be {@code null}.
  ///@return A Cursor object, which is positioned before the first entry, or null
  ///@see Cursor
  cursor_.Cursor query2(
          uri_.Uri uri,
          jni.JniObject projection,
          bundle_.Bundle queryArgs,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query2, jni.JniType.objectType, [
        uri.reference,
        projection.reference,
        queryArgs.reference,
        cancellationSignal.reference
      ]).object);

  static final _id_canonicalize = jniAccessors.getMethodIDOf(
      _classRef, "canonicalize", "(Landroid/net/Uri;)Landroid/net/Uri;");

  /// from: public final android.net.Uri canonicalize(android.net.Uri url)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Transform the given <var>url</var> to a canonical representation of
  /// its referenced resource, which can be used across devices, persisted,
  /// backed up and restored, etc.  The returned Uri is still a fully capable
  /// Uri for use with its content provider, allowing you to do all of the
  /// same content provider operations as with the original Uri --
  /// \#query, \#openInputStream(android.net.Uri), etc.  The
  /// only difference in behavior between the original and new Uris is that
  /// the content provider may need to do some additional work at each call
  /// using it to resolve it to the correct resource, especially if the
  /// canonical Uri has been moved to a different environment.
  ///
  /// If you are moving a canonical Uri between environments, you should
  /// perform another call to \#canonicalize with that original Uri to
  /// re-canonicalize it for the current environment.  Alternatively, you may
  /// want to use \#uncanonicalize to transform it to a non-canonical
  /// Uri that works only in the current environment but potentially more
  /// efficiently than the canonical representation.
  ///
  ///@param url The Uri that is to be transformed to a canonical
  /// representation.  Like all resolver calls, the input can be either
  /// a non-canonical or canonical Uri.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the official canonical representation of <var>url</var>,
  /// or null if the content provider does not support a canonical representation
  /// of the given Uri.  Many providers may not support canonicalization of some
  /// or all of their Uris.
  ///@see \#uncanonicalize
  uri_.Uri canonicalize(uri_.Uri url) =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_canonicalize, jni.JniType.objectType, [url.reference]).object);

  static final _id_uncanonicalize = jniAccessors.getMethodIDOf(
      _classRef, "uncanonicalize", "(Landroid/net/Uri;)Landroid/net/Uri;");

  /// from: public final android.net.Uri uncanonicalize(android.net.Uri url)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Given a canonical Uri previously generated by \#canonicalize, convert
  /// it to its local non-canonical form.  This can be useful in some cases where
  /// you know that you will only be using the Uri in the current environment and
  /// want to avoid any possible overhead when using it with the content
  /// provider or want to verify that the referenced data exists at all in the
  /// new environment.
  ///@param url The canonical Uri that is to be convered back to its
  /// non-canonical form.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the non-canonical representation of <var>url</var>.  This will
  /// return null if data identified by the canonical Uri can not be found in
  /// the current environment; callers must always check for null and deal with
  /// that by appropriately falling back to an alternative.
  ///@see \#canonicalize
  uri_.Uri uncanonicalize(uri_.Uri url) =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_uncanonicalize, jni.JniType.objectType, [url.reference]).object);

  static final _id_refresh = jniAccessors.getMethodIDOf(_classRef, "refresh",
      "(Landroid/net/Uri;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Z");

  /// from: public final boolean refresh(android.net.Uri url, android.os.Bundle args, android.os.CancellationSignal cancellationSignal)
  ///
  /// This allows clients to request an explicit refresh of content identified by {@code uri}.
  ///
  /// Client code should only invoke this method when there is a strong indication (such as a user
  /// initiated pull to refresh gesture) that the content is stale.
  ///
  ///@param url The Uri identifying the data to refresh.
  /// This value must never be {@code null}.
  ///@param args Additional options from the client. The definitions of these are specific to the
  ///            content provider being called.
  /// This value may be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress, or {@code null} if
  ///            none. For example, if you called refresh on a particular uri, you should call
  ///            CancellationSignal\#throwIfCanceled() to check whether the client has
  ///            canceled the refresh request.
  /// This value may be {@code null}.
  ///@return true if the provider actually tried refreshing.
  bool refresh(uri_.Uri url, bundle_.Bundle args,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_refresh, jni.JniType.booleanType, [
        url.reference,
        args.reference,
        cancellationSignal.reference
      ]).boolean;

  static final _id_openInputStream = jniAccessors.getMethodIDOf(
      _classRef, "openInputStream", "(Landroid/net/Uri;)Ljava/io/InputStream;");

  /// from: public final java.io.InputStream openInputStream(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a stream on to the content associated with a content URI.  If there
  /// is no data associated with the URI, FileNotFoundException is thrown.
  ///
  /// <h5>Accepts the following URI schemes:</h5>
  /// <ul>
  /// <li>content (\#SCHEME_CONTENT)</li>
  /// <li>android.resource (\#SCHEME_ANDROID_RESOURCE)</li>
  /// <li>file (\#SCHEME_FILE)</li>
  /// </ul>
  ///
  /// See \#openAssetFileDescriptor(Uri, String) for more information
  /// on these schemes.
  ///@param uri The desired URI.
  /// This value must never be {@code null}.
  ///@return InputStream
  /// This value may be {@code null}.
  ///@throws FileNotFoundException if the provided URI could not be opened.
  ///@see \#openAssetFileDescriptor(Uri, String)
  jni.JniObject openInputStream(uri_.Uri uri) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_openInputStream, jni.JniType.objectType, [uri.reference]).object);

  static final _id_openOutputStream = jniAccessors.getMethodIDOf(_classRef,
      "openOutputStream", "(Landroid/net/Uri;)Ljava/io/OutputStream;");

  /// from: public final java.io.OutputStream openOutputStream(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Synonym for \#openOutputStream(Uri, String) openOutputStream(uri, "w").
  ///@throws FileNotFoundException if the provided URI could not be opened.
  ///@param uri This value must never be {@code null}.
  ///@return This value may be {@code null}.
  jni.JniObject openOutputStream(uri_.Uri uri) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_openOutputStream,
          jni.JniType.objectType,
          [uri.reference]).object);

  static final _id_openOutputStream1 = jniAccessors.getMethodIDOf(
      _classRef,
      "openOutputStream",
      "(Landroid/net/Uri;Ljava/lang/String;)Ljava/io/OutputStream;");

  /// from: public final java.io.OutputStream openOutputStream(android.net.Uri uri, java.lang.String mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a stream on to the content associated with a content URI.  If there
  /// is no data associated with the URI, FileNotFoundException is thrown.
  ///
  /// <h5>Accepts the following URI schemes:</h5>
  /// <ul>
  /// <li>content (\#SCHEME_CONTENT)</li>
  /// <li>file (\#SCHEME_FILE)</li>
  /// </ul>
  ///
  /// See \#openAssetFileDescriptor(Uri, String) for more information
  /// on these schemes.
  ///@param uri The desired URI.
  /// This value must never be {@code null}.
  ///@param mode May be "w", "wa", "rw", or "rwt".
  /// This value must never be {@code null}.
  ///@return OutputStream
  /// This value may be {@code null}.
  ///@throws FileNotFoundException if the provided URI could not be opened.
  ///@see \#openAssetFileDescriptor(Uri, String)
  jni.JniObject openOutputStream1(uri_.Uri uri, jni.JniString mode) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_openOutputStream1,
          jni.JniType.objectType,
          [uri.reference, mode.reference]).object);

  static final _id_openFileDescriptor = jniAccessors.getMethodIDOf(
      _classRef,
      "openFileDescriptor",
      "(Landroid/net/Uri;Ljava/lang/String;)Landroid/os/ParcelFileDescriptor;");

  /// from: public final android.os.ParcelFileDescriptor openFileDescriptor(android.net.Uri uri, java.lang.String mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a raw file descriptor to access data under a URI.  This
  /// is like \#openAssetFileDescriptor(Uri, String), but uses the
  /// underlying ContentProvider\#openFile
  /// ContentProvider.openFile()} method, so will _not_ work with
  /// providers that return sub-sections of files.  If at all possible,
  /// you should use \#openAssetFileDescriptor(Uri, String).  You
  /// will receive a FileNotFoundException exception if the provider returns a
  /// sub-section of a file.
  ///
  /// <h5>Accepts the following URI schemes:</h5>
  /// <ul>
  /// <li>content (\#SCHEME_CONTENT)</li>
  /// <li>file (\#SCHEME_FILE)</li>
  /// </ul>
  ///
  /// See \#openAssetFileDescriptor(Uri, String) for more information
  /// on these schemes.
  ///
  /// If opening with the exclusive "r" or "w" modes, the returned
  /// ParcelFileDescriptor could be a pipe or socket pair to enable streaming
  /// of data. Opening with the "rw" mode implies a file on disk that supports
  /// seeking. If possible, always use an exclusive mode to give the underlying
  /// ContentProvider the most flexibility.
  ///
  /// If you are writing a file, and need to communicate an error to the
  /// provider, use ParcelFileDescriptor\#closeWithError(String).
  ///@param uri The desired URI to open.
  /// This value must never be {@code null}.
  ///@param mode The file mode to use, as per ContentProvider\#openFile ContentProvider.openFile.
  /// This value must never be {@code null}.
  ///@return Returns a new ParcelFileDescriptor pointing to the file.  You
  /// own this descriptor and are responsible for closing it when done.
  /// This value may be {@code null}.
  ///@throws FileNotFoundException Throws FileNotFoundException if no
  /// file exists under the URI or the mode is invalid.
  ///@see \#openAssetFileDescriptor(Uri, String)
  parcelfiledescriptor_.ParcelFileDescriptor openFileDescriptor(
          uri_.Uri uri, jni.JniString mode) =>
      parcelfiledescriptor_.ParcelFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openFileDescriptor,
              jni.JniType.objectType, [uri.reference, mode.reference]).object);

  static final _id_openFileDescriptor1 = jniAccessors.getMethodIDOf(
      _classRef,
      "openFileDescriptor",
      "(Landroid/net/Uri;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/os/ParcelFileDescriptor;");

  /// from: public final android.os.ParcelFileDescriptor openFileDescriptor(android.net.Uri uri, java.lang.String mode, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a raw file descriptor to access data under a URI.  This
  /// is like \#openAssetFileDescriptor(Uri, String), but uses the
  /// underlying ContentProvider\#openFile
  /// ContentProvider.openFile()} method, so will _not_ work with
  /// providers that return sub-sections of files.  If at all possible,
  /// you should use \#openAssetFileDescriptor(Uri, String).  You
  /// will receive a FileNotFoundException exception if the provider returns a
  /// sub-section of a file.
  ///
  /// <h5>Accepts the following URI schemes:</h5>
  /// <ul>
  /// <li>content (\#SCHEME_CONTENT)</li>
  /// <li>file (\#SCHEME_FILE)</li>
  /// </ul>
  ///
  /// See \#openAssetFileDescriptor(Uri, String) for more information
  /// on these schemes.
  ///
  /// If opening with the exclusive "r" or "w" modes, the returned
  /// ParcelFileDescriptor could be a pipe or socket pair to enable streaming
  /// of data. Opening with the "rw" mode implies a file on disk that supports
  /// seeking. If possible, always use an exclusive mode to give the underlying
  /// ContentProvider the most flexibility.
  ///
  /// If you are writing a file, and need to communicate an error to the
  /// provider, use ParcelFileDescriptor\#closeWithError(String).
  ///@param uri The desired URI to open.
  /// This value must never be {@code null}.
  ///@param mode The file mode to use, as per ContentProvider\#openFile ContentProvider.openFile.
  /// This value must never be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress,
  ///         or null if none. If the operation is canceled, then
  ///         OperationCanceledException will be thrown.
  /// This value may be {@code null}.
  ///@return Returns a new ParcelFileDescriptor pointing to the file.  You
  /// own this descriptor and are responsible for closing it when done.
  ///@throws FileNotFoundException Throws FileNotFoundException if no
  /// file exists under the URI or the mode is invalid.
  ///@see \#openAssetFileDescriptor(Uri, String)
  parcelfiledescriptor_.ParcelFileDescriptor openFileDescriptor1(
          uri_.Uri uri,
          jni.JniString mode,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      parcelfiledescriptor_.ParcelFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_openFileDescriptor1, jni.JniType.objectType, [
        uri.reference,
        mode.reference,
        cancellationSignal.reference
      ]).object);

  static final _id_openAssetFileDescriptor = jniAccessors.getMethodIDOf(
      _classRef,
      "openAssetFileDescriptor",
      "(Landroid/net/Uri;Ljava/lang/String;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public final android.content.res.AssetFileDescriptor openAssetFileDescriptor(android.net.Uri uri, java.lang.String mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a raw file descriptor to access data under a URI.  This
  /// interacts with the underlying ContentProvider\#openAssetFile
  /// method of the provider associated with the given URI, to retrieve any file stored there.
  ///
  /// <h5>Accepts the following URI schemes:</h5>
  /// <ul>
  /// <li>content (\#SCHEME_CONTENT)</li>
  /// <li>android.resource (\#SCHEME_ANDROID_RESOURCE)</li>
  /// <li>file (\#SCHEME_FILE)</li>
  /// </ul>
  /// <h5>The android.resource (\#SCHEME_ANDROID_RESOURCE) Scheme</h5>
  ///
  /// A Uri object can be used to reference a resource in an APK file.  The
  /// Uri should be one of the following formats:
  /// <ul>
  /// <li><code>android.resource://package_name/id_number</code><br/>
  /// <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
  /// For example <code>com.example.myapp</code><br/>
  /// <code>id_number</code> is the int form of the ID.<br/>
  /// The easiest way to construct this form is
  /// <pre>Uri uri = Uri.parse("android.resource://com.example.myapp/" + R.raw.my_resource");</pre>
  /// </li>
  /// <li><code>android.resource://package_name/type/name</code><br/>
  /// <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
  /// For example <code>com.example.myapp</code><br/>
  /// <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
  /// or <code>drawable</code>.
  /// <code>name</code> is the string form of the resource name.  That is, whatever the file
  /// name was in your res directory, without the type extension.
  /// The easiest way to construct this form is
  /// <pre>Uri uri = Uri.parse("android.resource://com.example.myapp/raw/my_resource");</pre>
  /// </li>
  /// </ul>
  ///
  /// Note that if this function is called for read-only input (mode is "r")
  /// on a content: URI, it will instead call \#openTypedAssetFileDescriptor
  /// for you with a MIME type of "*&\#47;*".  This allows such callers to benefit
  /// from any built-in data conversion that a provider implements.
  ///@param uri The desired URI to open.
  /// This value must never be {@code null}.
  ///@param mode The file mode to use, as per ContentProvider\#openAssetFile ContentProvider.openAssetFile.
  /// This value must never be {@code null}.
  ///@return Returns a new ParcelFileDescriptor pointing to the file.  You
  /// own this descriptor and are responsible for closing it when done.
  /// This value may be {@code null}.
  ///@throws FileNotFoundException Throws FileNotFoundException of no
  /// file exists under the URI or the mode is invalid.
  assetfiledescriptor_.AssetFileDescriptor openAssetFileDescriptor(
          uri_.Uri uri, jni.JniString mode) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openAssetFileDescriptor,
              jni.JniType.objectType, [uri.reference, mode.reference]).object);

  static final _id_openAssetFileDescriptor1 = jniAccessors.getMethodIDOf(
      _classRef,
      "openAssetFileDescriptor",
      "(Landroid/net/Uri;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public final android.content.res.AssetFileDescriptor openAssetFileDescriptor(android.net.Uri uri, java.lang.String mode, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a raw file descriptor to access data under a URI.  This
  /// interacts with the underlying ContentProvider\#openAssetFile
  /// method of the provider associated with the given URI, to retrieve any file stored there.
  ///
  /// <h5>Accepts the following URI schemes:</h5>
  /// <ul>
  /// <li>content (\#SCHEME_CONTENT)</li>
  /// <li>android.resource (\#SCHEME_ANDROID_RESOURCE)</li>
  /// <li>file (\#SCHEME_FILE)</li>
  /// </ul>
  /// <h5>The android.resource (\#SCHEME_ANDROID_RESOURCE) Scheme</h5>
  ///
  /// A Uri object can be used to reference a resource in an APK file.  The
  /// Uri should be one of the following formats:
  /// <ul>
  /// <li><code>android.resource://package_name/id_number</code><br/>
  /// <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
  /// For example <code>com.example.myapp</code><br/>
  /// <code>id_number</code> is the int form of the ID.<br/>
  /// The easiest way to construct this form is
  /// <pre>Uri uri = Uri.parse("android.resource://com.example.myapp/" + R.raw.my_resource");</pre>
  /// </li>
  /// <li><code>android.resource://package_name/type/name</code><br/>
  /// <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
  /// For example <code>com.example.myapp</code><br/>
  /// <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
  /// or <code>drawable</code>.
  /// <code>name</code> is the string form of the resource name.  That is, whatever the file
  /// name was in your res directory, without the type extension.
  /// The easiest way to construct this form is
  /// <pre>Uri uri = Uri.parse("android.resource://com.example.myapp/raw/my_resource");</pre>
  /// </li>
  /// </ul>
  ///
  /// Note that if this function is called for read-only input (mode is "r")
  /// on a content: URI, it will instead call \#openTypedAssetFileDescriptor
  /// for you with a MIME type of "*&\#47;*".  This allows such callers to benefit
  /// from any built-in data conversion that a provider implements.
  ///@param uri The desired URI to open.
  /// This value must never be {@code null}.
  ///@param mode The file mode to use, as per ContentProvider\#openAssetFile ContentProvider.openAssetFile.
  /// This value must never be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress, or null if
  ///            none. If the operation is canceled, then
  ///            OperationCanceledException will be thrown.
  /// This value may be {@code null}.
  ///@return Returns a new ParcelFileDescriptor pointing to the file.  You
  /// own this descriptor and are responsible for closing it when done.
  ///@throws FileNotFoundException Throws FileNotFoundException of no
  /// file exists under the URI or the mode is invalid.
  assetfiledescriptor_.AssetFileDescriptor openAssetFileDescriptor1(
          uri_.Uri uri,
          jni.JniString mode,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_openAssetFileDescriptor1, jni.JniType.objectType, [
        uri.reference,
        mode.reference,
        cancellationSignal.reference
      ]).object);

  static final _id_openTypedAssetFileDescriptor = jniAccessors.getMethodIDOf(
      _classRef,
      "openTypedAssetFileDescriptor",
      "(Landroid/net/Uri;Ljava/lang/String;Landroid/os/Bundle;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public final android.content.res.AssetFileDescriptor openTypedAssetFileDescriptor(android.net.Uri uri, java.lang.String mimeType, android.os.Bundle opts)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a raw file descriptor to access (potentially type transformed)
  /// data from a "content:" URI.  This interacts with the underlying
  /// ContentProvider\#openTypedAssetFile method of the provider
  /// associated with the given URI, to retrieve retrieve any appropriate
  /// data stream for the data stored there.
  ///
  /// Unlike \#openAssetFileDescriptor, this function only works
  /// with "content:" URIs, because content providers are the only facility
  /// with an associated MIME type to ensure that the returned data stream
  /// is of the desired type.
  ///
  /// All text/* streams are encoded in UTF-8.
  ///@param uri The desired URI to open.
  /// This value must never be {@code null}.
  ///@param mimeType The desired MIME type of the returned data.  This can
  /// be a pattern such as *&\#47;*, which will allow the content provider to
  /// select a type, though there is no way for you to determine what type
  /// it is returning.
  /// This value must never be {@code null}.
  ///@param opts Additional provider-dependent options.
  /// This value may be {@code null}.
  ///@return Returns a new ParcelFileDescriptor from which you can read the
  /// data stream from the provider.  Note that this may be a pipe, meaning
  /// you can't seek in it.  The only seek you should do is if the
  /// AssetFileDescriptor contains an offset, to move to that offset before
  /// reading.  You own this descriptor and are responsible for closing it when done.
  /// This value may be {@code null}.
  ///@throws FileNotFoundException Throws FileNotFoundException of no
  /// data of the desired type exists under the URI.
  assetfiledescriptor_.AssetFileDescriptor openTypedAssetFileDescriptor(
          uri_.Uri uri, jni.JniString mimeType, bundle_.Bundle opts) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(
              reference,
              _id_openTypedAssetFileDescriptor,
              jni.JniType.objectType,
              [uri.reference, mimeType.reference, opts.reference]).object);

  static final _id_openTypedAssetFileDescriptor1 = jniAccessors.getMethodIDOf(
      _classRef,
      "openTypedAssetFileDescriptor",
      "(Landroid/net/Uri;Ljava/lang/String;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public final android.content.res.AssetFileDescriptor openTypedAssetFileDescriptor(android.net.Uri uri, java.lang.String mimeType, android.os.Bundle opts, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a raw file descriptor to access (potentially type transformed)
  /// data from a "content:" URI.  This interacts with the underlying
  /// ContentProvider\#openTypedAssetFile method of the provider
  /// associated with the given URI, to retrieve retrieve any appropriate
  /// data stream for the data stored there.
  ///
  /// Unlike \#openAssetFileDescriptor, this function only works
  /// with "content:" URIs, because content providers are the only facility
  /// with an associated MIME type to ensure that the returned data stream
  /// is of the desired type.
  ///
  /// All text/* streams are encoded in UTF-8.
  ///@param uri The desired URI to open.
  /// This value must never be {@code null}.
  ///@param mimeType The desired MIME type of the returned data.  This can
  /// be a pattern such as *&\#47;*, which will allow the content provider to
  /// select a type, though there is no way for you to determine what type
  /// it is returning.
  /// This value must never be {@code null}.
  ///@param opts Additional provider-dependent options.
  /// This value may be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress,
  ///         or null if none. If the operation is canceled, then
  ///         OperationCanceledException will be thrown.
  /// This value may be {@code null}.
  ///@return Returns a new ParcelFileDescriptor from which you can read the
  /// data stream from the provider.  Note that this may be a pipe, meaning
  /// you can't seek in it.  The only seek you should do is if the
  /// AssetFileDescriptor contains an offset, to move to that offset before
  /// reading.  You own this descriptor and are responsible for closing it when done.
  ///@throws FileNotFoundException Throws FileNotFoundException of no
  /// data of the desired type exists under the URI.
  assetfiledescriptor_.AssetFileDescriptor openTypedAssetFileDescriptor1(
          uri_.Uri uri,
          jni.JniString mimeType,
          bundle_.Bundle opts,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openTypedAssetFileDescriptor1,
              jni.JniType.objectType, [
        uri.reference,
        mimeType.reference,
        opts.reference,
        cancellationSignal.reference
      ]).object);

  static final _id_insert = jniAccessors.getMethodIDOf(_classRef, "insert",
      "(Landroid/net/Uri;Landroid/content/ContentValues;)Landroid/net/Uri;");

  /// from: public final android.net.Uri insert(android.net.Uri url, android.content.ContentValues values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Inserts a row into a table at the given URL.
  ///
  /// If the content provider supports transactions the insertion will be atomic.
  ///@param url The URL of the table to insert into.
  /// This value must never be {@code null}.
  ///@param values The initial values for the newly inserted row. The key is the column name for
  ///               the field. Passing an empty ContentValues will create an empty row.
  /// This value may be {@code null}.
  ///@return the URL of the newly created row.
  ///
  /// This value may be {@code null}.
  uri_.Uri insert(uri_.Uri url, contentvalues_.ContentValues values) =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(reference, _id_insert,
          jni.JniType.objectType, [url.reference, values.reference]).object);

  static final _id_applyBatch = jniAccessors.getMethodIDOf(
      _classRef,
      "applyBatch",
      "(Ljava/lang/String;Ljava/util/ArrayList;)[Landroid/content/ContentProviderResult;");

  /// from: public android.content.ContentProviderResult[] applyBatch(java.lang.String authority, java.util.ArrayList<android.content.ContentProviderOperation> operations)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Applies each of the ContentProviderOperation objects and returns an array
  /// of their results. Passes through OperationApplicationException, which may be thrown
  /// by the call to ContentProviderOperation\#apply.
  /// If all the applications succeed then a ContentProviderResult array with the
  /// same number of elements as the operations will be returned. It is implementation-specific
  /// how many, if any, operations will have been successfully applied if a call to
  /// apply results in a OperationApplicationException.
  ///@param authority the authority of the ContentProvider to which this batch should be applied
  /// This value must never be {@code null}.
  ///@param operations the operations to apply
  /// This value must never be {@code null}.
  ///@return the results of the applications
  /// This value will never be {@code null}.
  ///@throws OperationApplicationException thrown if an application fails.
  /// See ContentProviderOperation\#apply for more information.
  ///@throws RemoteException thrown if a RemoteException is encountered while attempting
  ///   to communicate with a remote provider.
  jni.JniObject applyBatch(jni.JniString authority, jni.JniObject operations) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_applyBatch,
          jni.JniType.objectType,
          [authority.reference, operations.reference]).object);

  static final _id_bulkInsert = jniAccessors.getMethodIDOf(_classRef,
      "bulkInsert", "(Landroid/net/Uri;[Landroid/content/ContentValues;)I");

  /// from: public final int bulkInsert(android.net.Uri url, android.content.ContentValues[] values)
  ///
  /// Inserts multiple rows into a table at the given URL.
  ///
  /// This function make no guarantees about the atomicity of the insertions.
  ///@param url The URL of the table to insert into.
  /// This value must never be {@code null}.
  ///@param values The initial values for the newly inserted rows. The key is the column name for
  ///               the field. Passing null will create an empty row.
  /// This value must never be {@code null}.
  ///@return the number of newly created rows.
  int bulkInsert(uri_.Uri url, jni.JniObject values) =>
      jniAccessors.callMethodWithArgs(reference, _id_bulkInsert,
          jni.JniType.intType, [url.reference, values.reference]).integer;

  static final _id_delete1 = jniAccessors.getMethodIDOf(_classRef, "delete",
      "(Landroid/net/Uri;Ljava/lang/String;[Ljava/lang/String;)I");

  /// from: public final int delete(android.net.Uri url, java.lang.String where, java.lang.String[] selectionArgs)
  ///
  /// Deletes row(s) specified by a content URI.
  ///
  /// If the content provider supports transactions, the deletion will be atomic.
  ///@param url The URL of the row to delete.
  /// This value must never be {@code null}.
  ///@param where A filter to apply to rows before deleting, formatted as an SQL WHERE clause
  ///            (excluding the WHERE itself).
  /// This value may be {@code null}.
  ///@param selectionArgs This value may be {@code null}.
  ///@return The number of rows deleted.
  int delete1(uri_.Uri url, jni.JniString where, jni.JniObject selectionArgs) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_delete1,
          jni.JniType.intType,
          [url.reference, where.reference, selectionArgs.reference]).integer;

  static final _id_update = jniAccessors.getMethodIDOf(_classRef, "update",
      "(Landroid/net/Uri;Landroid/content/ContentValues;Ljava/lang/String;[Ljava/lang/String;)I");

  /// from: public final int update(android.net.Uri uri, android.content.ContentValues values, java.lang.String where, java.lang.String[] selectionArgs)
  ///
  /// Update row(s) in a content URI.
  ///
  /// If the content provider supports transactions the update will be atomic.
  ///@param uri The URI to modify.
  /// This value must never be {@code null}.
  ///@param values The new field values. The key is the column name for the field.
  ///            A null value will remove an existing field value.
  /// This value may be {@code null}.
  ///@param where A filter to apply to rows before updating, formatted as an SQL WHERE clause
  ///           (excluding the WHERE itself).
  /// This value may be {@code null}.
  ///@param selectionArgs This value may be {@code null}.
  ///@return the number of rows updated.
  ///@throws NullPointerException if uri or values are null
  int update(uri_.Uri uri, contentvalues_.ContentValues values,
          jni.JniString where, jni.JniObject selectionArgs) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_update, jni.JniType.intType, [
        uri.reference,
        values.reference,
        where.reference,
        selectionArgs.reference
      ]).integer;

  static final _id_call = jniAccessors.getMethodIDOf(_classRef, "call",
      "(Landroid/net/Uri;Ljava/lang/String;Ljava/lang/String;Landroid/os/Bundle;)Landroid/os/Bundle;");

  /// from: public final android.os.Bundle call(android.net.Uri uri, java.lang.String method, java.lang.String arg, android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call a provider-defined method.  This can be used to implement
  /// read or write interfaces which are cheaper than using a Cursor and/or
  /// do not fit into the traditional table model.
  ///@param method provider-defined method name to call.  Opaque to
  ///   framework, but must be non-null.
  /// This value must never be {@code null}.
  ///@param arg provider-defined String argument.  May be null.
  /// This value may be {@code null}.
  ///@param extras provider-defined Bundle argument.  May be null.
  /// This value may be {@code null}.
  ///@param uri This value must never be {@code null}.
  ///@return a result Bundle, possibly null.  Will be null if the ContentProvider
  ///   does not implement call.
  ///@throws NullPointerException if uri or method is null
  ///@throws IllegalArgumentException if uri is not known
  bundle_.Bundle call(uri_.Uri uri, jni.JniString method, jni.JniString arg,
          bundle_.Bundle extras) =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_call, jni.JniType.objectType, [
        uri.reference,
        method.reference,
        arg.reference,
        extras.reference
      ]).object);

  static final _id_acquireContentProviderClient = jniAccessors.getMethodIDOf(
      _classRef,
      "acquireContentProviderClient",
      "(Landroid/net/Uri;)Landroid/content/ContentProviderClient;");

  /// from: public final android.content.ContentProviderClient acquireContentProviderClient(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a ContentProviderClient that is associated with the ContentProvider
  /// that services the content at uri, starting the provider if necessary. Returns
  /// null if there is no provider associated wih the uri. The caller must indicate that they are
  /// done with the provider by calling ContentProviderClient\#release which will allow
  /// the system to release the provider it it determines that there is no other reason for
  /// keeping it active.
  ///@param uri specifies which provider should be acquired
  /// This value must never be {@code null}.
  ///@return a ContentProviderClient that is associated with the ContentProvider
  /// that services the content at uri or null if there isn't one.
  contentproviderclient_.ContentProviderClient acquireContentProviderClient(
          uri_.Uri uri) =>
      contentproviderclient_.ContentProviderClient.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_acquireContentProviderClient,
              jni.JniType.objectType, [uri.reference]).object);

  static final _id_acquireContentProviderClient1 = jniAccessors.getMethodIDOf(
      _classRef,
      "acquireContentProviderClient",
      "(Ljava/lang/String;)Landroid/content/ContentProviderClient;");

  /// from: public final android.content.ContentProviderClient acquireContentProviderClient(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a ContentProviderClient that is associated with the ContentProvider
  /// with the authority of name, starting the provider if necessary. Returns
  /// null if there is no provider associated wih the uri. The caller must indicate that they are
  /// done with the provider by calling ContentProviderClient\#release which will allow
  /// the system to release the provider it it determines that there is no other reason for
  /// keeping it active.
  ///@param name specifies which provider should be acquired
  /// This value must never be {@code null}.
  ///@return a ContentProviderClient that is associated with the ContentProvider
  /// with the authority of name or null if there isn't one.
  contentproviderclient_.ContentProviderClient acquireContentProviderClient1(
          jni.JniString name) =>
      contentproviderclient_.ContentProviderClient.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_acquireContentProviderClient1,
              jni.JniType.objectType, [name.reference]).object);

  static final _id_acquireUnstableContentProviderClient =
      jniAccessors.getMethodIDOf(
          _classRef,
          "acquireUnstableContentProviderClient",
          "(Landroid/net/Uri;)Landroid/content/ContentProviderClient;");

  /// from: public final android.content.ContentProviderClient acquireUnstableContentProviderClient(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#acquireContentProviderClient(Uri), but for use when you do
  /// not trust the stability of the target content provider.  This turns off
  /// the mechanism in the platform clean up processes that are dependent on
  /// a content provider if that content provider's process goes away.  Normally
  /// you can safely assume that once you have acquired a provider, you can freely
  /// use it as needed and it won't disappear, even if your process is in the
  /// background.  If using this method, you need to take care to deal with any
  /// failures when communicating with the provider, and be sure to close it
  /// so that it can be re-opened later.  In particular, catching a
  /// android.os.DeadObjectException from the calls there will let you
  /// know that the content provider has gone away; at that point the current
  /// ContentProviderClient object is invalid, and you should release it.  You
  /// can acquire a new one if you would like to try to restart the provider
  /// and perform new operations on it.
  ///@param uri This value must never be {@code null}.
  ///@return This value may be {@code null}.
  contentproviderclient_.ContentProviderClient
      acquireUnstableContentProviderClient(uri_.Uri uri) =>
          contentproviderclient_.ContentProviderClient.fromRef(jniAccessors
              .callMethodWithArgs(
                  reference,
                  _id_acquireUnstableContentProviderClient,
                  jni.JniType.objectType,
                  [uri.reference]).object);

  static final _id_acquireUnstableContentProviderClient1 =
      jniAccessors.getMethodIDOf(
          _classRef,
          "acquireUnstableContentProviderClient",
          "(Ljava/lang/String;)Landroid/content/ContentProviderClient;");

  /// from: public final android.content.ContentProviderClient acquireUnstableContentProviderClient(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#acquireContentProviderClient(String), but for use when you do
  /// not trust the stability of the target content provider.  This turns off
  /// the mechanism in the platform clean up processes that are dependent on
  /// a content provider if that content provider's process goes away.  Normally
  /// you can safely assume that once you have acquired a provider, you can freely
  /// use it as needed and it won't disappear, even if your process is in the
  /// background.  If using this method, you need to take care to deal with any
  /// failures when communicating with the provider, and be sure to close it
  /// so that it can be re-opened later.  In particular, catching a
  /// android.os.DeadObjectException from the calls there will let you
  /// know that the content provider has gone away; at that point the current
  /// ContentProviderClient object is invalid, and you should release it.  You
  /// can acquire a new one if you would like to try to restart the provider
  /// and perform new operations on it.
  ///@param name This value must never be {@code null}.
  ///@return This value may be {@code null}.
  contentproviderclient_.ContentProviderClient
      acquireUnstableContentProviderClient1(jni.JniString name) =>
          contentproviderclient_.ContentProviderClient.fromRef(jniAccessors
              .callMethodWithArgs(
                  reference,
                  _id_acquireUnstableContentProviderClient1,
                  jni.JniType.objectType,
                  [name.reference]).object);

  static final _id_registerContentObserver = jniAccessors.getMethodIDOf(
      _classRef,
      "registerContentObserver",
      "(Landroid/net/Uri;ZLandroid/database/ContentObserver;)V");

  /// from: public final void registerContentObserver(android.net.Uri uri, boolean notifyForDescendants, android.database.ContentObserver observer)
  ///
  /// Register an observer class that gets callbacks when data identified by a
  /// given content URI changes.
  ///
  /// Starting in android.os.Build.VERSION_CODES\#O, all content
  /// notifications must be backed by a valid ContentProvider.
  ///@param uri The URI to watch for changes. This can be a specific row URI,
  ///            or a base URI for a whole class of content.
  /// This value must never be {@code null}.
  ///@param notifyForDescendants When false, the observer will be notified
  ///            whenever a change occurs to the exact URI specified by
  ///            <code>uri</code> or to one of the URI's ancestors in the path
  ///            hierarchy. When true, the observer will also be notified
  ///            whenever a change occurs to the URI's descendants in the path
  ///            hierarchy.
  ///@param observer The object that receives callbacks when changes occur.
  /// This value must never be {@code null}.
  ///@see \#unregisterContentObserver
  void registerContentObserver(uri_.Uri uri, bool notifyForDescendants,
          contentobserver_.ContentObserver observer) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerContentObserver,
          jni.JniType.voidType,
          [uri.reference, notifyForDescendants, observer.reference]).check();

  static final _id_unregisterContentObserver = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterContentObserver",
      "(Landroid/database/ContentObserver;)V");

  /// from: public final void unregisterContentObserver(android.database.ContentObserver observer)
  ///
  /// Unregisters a change observer.
  ///@param observer The previously registered observer that is no longer needed.
  /// This value must never be {@code null}.
  ///@see \#registerContentObserver
  void unregisterContentObserver(contentobserver_.ContentObserver observer) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterContentObserver,
          jni.JniType.voidType, [observer.reference]).check();

  static final _id_notifyChange = jniAccessors.getMethodIDOf(_classRef,
      "notifyChange", "(Landroid/net/Uri;Landroid/database/ContentObserver;)V");

  /// from: public void notifyChange(android.net.Uri uri, android.database.ContentObserver observer)
  ///
  /// Notify registered observers that a row was updated and attempt to sync
  /// changes to the network.
  ///
  /// To observe events sent through this call, use
  /// \#registerContentObserver(Uri, boolean, ContentObserver).
  ///
  /// Starting in android.os.Build.VERSION_CODES\#O, all content
  /// notifications must be backed by a valid ContentProvider.
  ///@param uri The uri of the content that was changed.
  /// This value must never be {@code null}.
  ///@param observer The observer that originated the change, may be
  ///            <code>null</null>. The observer that originated the change
  ///            will only receive the notification if it has requested to
  ///            receive self-change notifications by implementing
  ///            ContentObserver\#deliverSelfNotifications() to return
  ///            true.
  ///
  /// This value may be {@code null}.
  void notifyChange(uri_.Uri uri, contentobserver_.ContentObserver observer) =>
      jniAccessors.callMethodWithArgs(reference, _id_notifyChange,
          jni.JniType.voidType, [uri.reference, observer.reference]).check();

  static final _id_notifyChange1 = jniAccessors.getMethodIDOf(
      _classRef,
      "notifyChange",
      "(Landroid/net/Uri;Landroid/database/ContentObserver;Z)V");

  /// from: public void notifyChange(android.net.Uri uri, android.database.ContentObserver observer, boolean syncToNetwork)
  ///
  /// Notify registered observers that a row was updated.
  ///
  /// To observe events sent through this call, use
  /// \#registerContentObserver(Uri, boolean, ContentObserver).
  ///
  /// If syncToNetwork is true, this will attempt to schedule a local sync
  /// using the sync adapter that's registered for the authority of the
  /// provided uri. No account will be passed to the sync adapter, so all
  /// matching accounts will be synchronized.
  ///
  /// Starting in android.os.Build.VERSION_CODES\#O, all content
  /// notifications must be backed by a valid ContentProvider.
  ///@param uri The uri of the content that was changed.
  /// This value must never be {@code null}.
  ///@param observer The observer that originated the change, may be
  ///            <code>null</null>. The observer that originated the change
  ///            will only receive the notification if it has requested to
  ///            receive self-change notifications by implementing
  ///            ContentObserver\#deliverSelfNotifications() to return
  ///            true.
  /// This value may be {@code null}.
  ///@param syncToNetwork If true, same as \#NOTIFY_SYNC_TO_NETWORK.
  ///@see \#requestSync(android.accounts.Account, String, android.os.Bundle)
  void notifyChange1(uri_.Uri uri, contentobserver_.ContentObserver observer,
          bool syncToNetwork) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_notifyChange1,
          jni.JniType.voidType,
          [uri.reference, observer.reference, syncToNetwork]).check();

  static final _id_notifyChange2 = jniAccessors.getMethodIDOf(
      _classRef,
      "notifyChange",
      "(Landroid/net/Uri;Landroid/database/ContentObserver;I)V");

  /// from: public void notifyChange(android.net.Uri uri, android.database.ContentObserver observer, int flags)
  ///
  /// Notify registered observers that a row was updated.
  ///
  /// To observe events sent through this call, use
  /// \#registerContentObserver(Uri, boolean, ContentObserver).
  ///
  /// If syncToNetwork is true, this will attempt to schedule a local sync
  /// using the sync adapter that's registered for the authority of the
  /// provided uri. No account will be passed to the sync adapter, so all
  /// matching accounts will be synchronized.
  ///
  /// Starting in android.os.Build.VERSION_CODES\#O, all content
  /// notifications must be backed by a valid ContentProvider.
  ///@param uri The uri of the content that was changed.
  /// This value must never be {@code null}.
  ///@param observer The observer that originated the change, may be
  ///            <code>null</null>. The observer that originated the change
  ///            will only receive the notification if it has requested to
  ///            receive self-change notifications by implementing
  ///            ContentObserver\#deliverSelfNotifications() to return
  ///            true.
  /// This value may be {@code null}.
  ///@param flags Additional flags: \#NOTIFY_SYNC_TO_NETWORK.
  /// Value is either <code>0</code> or a combination of android.content.ContentResolver\#NOTIFY_SYNC_TO_NETWORK, and android.content.ContentResolver\#NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS
  ///@see \#requestSync(android.accounts.Account, String, android.os.Bundle)
  void notifyChange2(
          uri_.Uri uri, contentobserver_.ContentObserver observer, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_notifyChange2,
          jni.JniType.voidType,
          [uri.reference, observer.reference, flags]).check();

  static final _id_takePersistableUriPermission = jniAccessors.getMethodIDOf(
      _classRef, "takePersistableUriPermission", "(Landroid/net/Uri;I)V");

  /// from: public void takePersistableUriPermission(android.net.Uri uri, int modeFlags)
  ///
  /// Take a persistable URI permission grant that has been offered. Once
  /// taken, the permission grant will be remembered across device reboots.
  /// Only URI permissions granted with
  /// Intent\#FLAG_GRANT_PERSISTABLE_URI_PERMISSION can be persisted. If
  /// the grant has already been persisted, taking it again will touch
  /// UriPermission\#getPersistedTime().
  ///@see \#getPersistedUriPermissions()
  ///@param uri This value must never be {@code null}.
  ///@param modeFlags Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  void takePersistableUriPermission(uri_.Uri uri, int modeFlags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_takePersistableUriPermission,
          jni.JniType.voidType,
          [uri.reference, modeFlags]).check();

  static final _id_releasePersistableUriPermission = jniAccessors.getMethodIDOf(
      _classRef, "releasePersistableUriPermission", "(Landroid/net/Uri;I)V");

  /// from: public void releasePersistableUriPermission(android.net.Uri uri, int modeFlags)
  ///
  /// Relinquish a persisted URI permission grant. The URI must have been
  /// previously made persistent with
  /// \#takePersistableUriPermission(Uri, int). Any non-persistent
  /// grants to the calling package will remain intact.
  ///@see \#getPersistedUriPermissions()
  ///@param uri This value must never be {@code null}.
  ///@param modeFlags Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  void releasePersistableUriPermission(uri_.Uri uri, int modeFlags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_releasePersistableUriPermission,
          jni.JniType.voidType,
          [uri.reference, modeFlags]).check();

  static final _id_getPersistedUriPermissions = jniAccessors.getMethodIDOf(
      _classRef, "getPersistedUriPermissions", "()Ljava/util/List;");

  /// from: public java.util.List<android.content.UriPermission> getPersistedUriPermissions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return list of all URI permission grants that have been persisted by the
  /// calling app. That is, the returned permissions have been granted
  /// _to_ the calling app. Only persistable grants taken with
  /// \#takePersistableUriPermission(Uri, int) are returned.
  /// Note: Some of the returned URIs may not be usable until after the user is unlocked.
  ///@see \#takePersistableUriPermission(Uri, int)
  ///@see \#releasePersistableUriPermission(Uri, int)
  ///@return This value will never be {@code null}.
  jni.JniObject getPersistedUriPermissions() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getPersistedUriPermissions, jni.JniType.objectType, []).object);

  static final _id_getOutgoingPersistedUriPermissions =
      jniAccessors.getMethodIDOf(_classRef,
          "getOutgoingPersistedUriPermissions", "()Ljava/util/List;");

  /// from: public java.util.List<android.content.UriPermission> getOutgoingPersistedUriPermissions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return list of all persisted URI permission grants that are hosted by the
  /// calling app. That is, the returned permissions have been granted
  /// _from_ the calling app. Only grants taken with
  /// \#takePersistableUriPermission(Uri, int) are returned.
  /// Note: Some of the returned URIs may not be usable until after the user is unlocked.
  ///@return This value will never be {@code null}.
  jni.JniObject getOutgoingPersistedUriPermissions() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getOutgoingPersistedUriPermissions,
          jni.JniType.objectType, []).object);

  static final _id_startSync = jniAccessors.getMethodIDOf(
      _classRef, "startSync", "(Landroid/net/Uri;Landroid/os/Bundle;)V");

  /// from: public void startSync(android.net.Uri uri, android.os.Bundle extras)
  ///
  /// Start an asynchronous sync operation. If you want to monitor the progress
  /// of the sync you may register a SyncObserver. Only values of the following
  /// types may be used in the extras bundle:
  /// <ul>
  /// <li>Integer</li>
  /// <li>Long</li>
  /// <li>Boolean</li>
  /// <li>Float</li>
  /// <li>Double</li>
  /// <li>String</li>
  /// <li>Account</li>
  /// <li>null</li>
  /// </ul>
  ///@param uri the uri of the provider to sync or null to sync all providers.
  ///@param extras any extras to pass to the SyncAdapter.
  ///@deprecated instead use
  /// \#requestSync(android.accounts.Account, String, android.os.Bundle)
  void startSync(uri_.Uri uri, bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(reference, _id_startSync,
          jni.JniType.voidType, [uri.reference, extras.reference]).check();

  static final _id_requestSync = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "requestSync",
      "(Landroid/accounts/Account;Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: static public void requestSync(android.accounts.Account account, java.lang.String authority, android.os.Bundle extras)
  ///
  /// Start an asynchronous sync operation. If you want to monitor the progress
  /// of the sync you may register a SyncObserver. Only values of the following
  /// types may be used in the extras bundle:
  /// <ul>
  /// <li>Integer</li>
  /// <li>Long</li>
  /// <li>Boolean</li>
  /// <li>Float</li>
  /// <li>Double</li>
  /// <li>String</li>
  /// <li>Account</li>
  /// <li>null</li>
  /// </ul>
  ///@param account which account should be synced
  ///@param authority which authority should be synced
  ///@param extras any extras to pass to the SyncAdapter.
  static void requestSync(account_.Account account, jni.JniString authority,
          bundle_.Bundle extras) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_requestSync,
          jni.JniType.voidType,
          [account.reference, authority.reference, extras.reference]).check();

  static final _id_requestSync1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "requestSync", "(Landroid/content/SyncRequest;)V");

  /// from: static public void requestSync(android.content.SyncRequest request)
  ///
  /// Register a sync with the SyncManager. These requests are built using the
  /// SyncRequest.Builder.
  static void requestSync1(syncrequest_.SyncRequest request) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_requestSync1,
          jni.JniType.voidType, [request.reference]).check();

  static final _id_validateSyncExtrasBundle = jniAccessors.getStaticMethodIDOf(
      _classRef, "validateSyncExtrasBundle", "(Landroid/os/Bundle;)V");

  /// from: static public void validateSyncExtrasBundle(android.os.Bundle extras)
  ///
  /// Check that only values of the following types are in the Bundle:
  /// <ul>
  /// <li>Integer</li>
  /// <li>Long</li>
  /// <li>Boolean</li>
  /// <li>Float</li>
  /// <li>Double</li>
  /// <li>String</li>
  /// <li>Account</li>
  /// <li>null</li>
  /// </ul>
  ///@param extras the Bundle to check
  static void validateSyncExtrasBundle(bundle_.Bundle extras) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_validateSyncExtrasBundle,
          jni.JniType.voidType,
          [extras.reference]).check();

  static final _id_cancelSync = jniAccessors.getMethodIDOf(
      _classRef, "cancelSync", "(Landroid/net/Uri;)V");

  /// from: public void cancelSync(android.net.Uri uri)
  ///
  /// Cancel any active or pending syncs that match the Uri. If the uri is null then
  /// all syncs will be canceled.
  ///@param uri the uri of the provider to sync or null to sync all providers.
  ///@deprecated instead use \#cancelSync(android.accounts.Account, String)
  void cancelSync(uri_.Uri uri) => jniAccessors.callMethodWithArgs(
      reference, _id_cancelSync, jni.JniType.voidType, [uri.reference]).check();

  static final _id_cancelSync1 = jniAccessors.getStaticMethodIDOf(_classRef,
      "cancelSync", "(Landroid/accounts/Account;Ljava/lang/String;)V");

  /// from: static public void cancelSync(android.accounts.Account account, java.lang.String authority)
  ///
  /// Cancel any active or pending syncs that match account and authority. The account and
  /// authority can each independently be set to null, which means that syncs with any account
  /// or authority, respectively, will match.
  ///@param account filters the syncs that match by this account
  ///@param authority filters the syncs that match by this authority
  static void cancelSync1(account_.Account account, jni.JniString authority) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_cancelSync1,
          jni.JniType.voidType,
          [account.reference, authority.reference]).check();

  static final _id_getSyncAdapterTypes = jniAccessors.getStaticMethodIDOf(
      _classRef, "getSyncAdapterTypes", "()[Landroid/content/SyncAdapterType;");

  /// from: static public android.content.SyncAdapterType[] getSyncAdapterTypes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get information about the SyncAdapters that are known to the system.
  ///@return an array of SyncAdapters that have registered with the system
  static jni.JniObject getSyncAdapterTypes() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getSyncAdapterTypes, jni.JniType.objectType, []).object);

  static final _id_getSyncAutomatically = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getSyncAutomatically",
      "(Landroid/accounts/Account;Ljava/lang/String;)Z");

  /// from: static public boolean getSyncAutomatically(android.accounts.Account account, java.lang.String authority)
  ///
  /// Check if the provider should be synced when a network tickle is received
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#READ_SYNC_SETTINGS.
  ///@param account the account whose setting we are querying
  ///@param authority the provider whose setting we are querying
  ///@return true if the provider should be synced when a network tickle is received
  static bool getSyncAutomatically(
          account_.Account account, jni.JniString authority) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getSyncAutomatically,
          jni.JniType.booleanType,
          [account.reference, authority.reference]).boolean;

  static final _id_setSyncAutomatically = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "setSyncAutomatically",
      "(Landroid/accounts/Account;Ljava/lang/String;Z)V");

  /// from: static public void setSyncAutomatically(android.accounts.Account account, java.lang.String authority, boolean sync)
  ///
  /// Set whether or not the provider is synced when it receives a network tickle.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#WRITE_SYNC_SETTINGS.
  ///@param account the account whose setting we are querying
  ///@param authority the provider whose behavior is being controlled
  ///@param sync true if the provider should be synced when tickles are received for it
  static void setSyncAutomatically(
          account_.Account account, jni.JniString authority, bool sync0) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_setSyncAutomatically,
          jni.JniType.voidType,
          [account.reference, authority.reference, sync0]).check();

  static final _id_addPeriodicSync = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "addPeriodicSync",
      "(Landroid/accounts/Account;Ljava/lang/String;Landroid/os/Bundle;J)V");

  /// from: static public void addPeriodicSync(android.accounts.Account account, java.lang.String authority, android.os.Bundle extras, long pollFrequency)
  ///
  /// Specifies that a sync should be requested with the specified the account, authority,
  /// and extras at the given frequency. If there is already another periodic sync scheduled
  /// with the account, authority and extras then a new periodic sync won't be added, instead
  /// the frequency of the previous one will be updated.
  ///
  /// These periodic syncs honor the "syncAutomatically" and "masterSyncAutomatically" settings.
  /// Although these sync are scheduled at the specified frequency, it may take longer for it to
  /// actually be started if other syncs are ahead of it in the sync operation queue. This means
  /// that the actual start time may drift.
  ///
  /// Periodic syncs are not allowed to have any of \#SYNC_EXTRAS_DO_NOT_RETRY,
  /// \#SYNC_EXTRAS_IGNORE_BACKOFF, \#SYNC_EXTRAS_IGNORE_SETTINGS,
  /// \#SYNC_EXTRAS_INITIALIZE, \#SYNC_EXTRAS_FORCE,
  /// \#SYNC_EXTRAS_EXPEDITED, \#SYNC_EXTRAS_MANUAL set to true.
  /// If any are supplied then an IllegalArgumentException will be thrown.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#WRITE_SYNC_SETTINGS.
  /// The bundle for a periodic sync can be queried by applications with the correct
  /// permissions using
  /// ContentResolver\#getPeriodicSyncs(Account account, String provider), so no
  /// sensitive data should be transferred here.
  ///@param account the account to specify in the sync
  ///@param authority the provider to specify in the sync request
  ///@param extras extra parameters to go along with the sync request
  ///@param pollFrequency how frequently the sync should be performed, in seconds.
  /// On Android API level 24 and above, a minmam interval of 15 minutes is enforced.
  /// On previous versions, the minimum interval is 1 hour.
  ///@throws IllegalArgumentException if an illegal extra was set or if any of the parameters
  /// are null.
  static void addPeriodicSync(account_.Account account, jni.JniString authority,
          bundle_.Bundle extras, int pollFrequency) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_addPeriodicSync, jni.JniType.voidType, [
        account.reference,
        authority.reference,
        extras.reference,
        pollFrequency
      ]).check();

  static final _id_removePeriodicSync = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "removePeriodicSync",
      "(Landroid/accounts/Account;Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: static public void removePeriodicSync(android.accounts.Account account, java.lang.String authority, android.os.Bundle extras)
  ///
  /// Remove a periodic sync. Has no affect if account, authority and extras don't match
  /// an existing periodic sync.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#WRITE_SYNC_SETTINGS.
  ///@param account the account of the periodic sync to remove
  ///@param authority the provider of the periodic sync to remove
  ///@param extras the extras of the periodic sync to remove
  static void removePeriodicSync(account_.Account account,
          jni.JniString authority, bundle_.Bundle extras) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_removePeriodicSync,
          jni.JniType.voidType,
          [account.reference, authority.reference, extras.reference]).check();

  static final _id_cancelSync2 = jniAccessors.getStaticMethodIDOf(
      _classRef, "cancelSync", "(Landroid/content/SyncRequest;)V");

  /// from: static public void cancelSync(android.content.SyncRequest request)
  ///
  /// Remove the specified sync. This will cancel any pending or active syncs. If the request is
  /// for a periodic sync, this call will remove any future occurrences.
  ///
  ///     If a periodic sync is specified, the caller must hold the permission
  ///     android.Manifest.permission\#WRITE_SYNC_SETTINGS.
  ///
  ///
  /// It is possible to cancel a sync using a SyncRequest object that is not the same object
  /// with which you requested the sync. Do so by building a SyncRequest with the same
  /// adapter, frequency, __and__ extras bundle.
  ///@param request SyncRequest object containing information about sync to cancel.
  static void cancelSync2(syncrequest_.SyncRequest request) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_cancelSync2,
          jni.JniType.voidType, [request.reference]).check();

  static final _id_getPeriodicSyncs = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getPeriodicSyncs",
      "(Landroid/accounts/Account;Ljava/lang/String;)Ljava/util/List;");

  /// from: static public java.util.List<android.content.PeriodicSync> getPeriodicSyncs(android.accounts.Account account, java.lang.String authority)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the list of information about the periodic syncs for the given account and authority.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#READ_SYNC_SETTINGS.
  ///@param account the account whose periodic syncs we are querying
  ///@param authority the provider whose periodic syncs we are querying
  ///@return a list of PeriodicSync objects. This list may be empty but will never be null.
  static jni.JniObject getPeriodicSyncs(
          account_.Account account, jni.JniString authority) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getPeriodicSyncs,
          jni.JniType.objectType,
          [account.reference, authority.reference]).object);

  static final _id_getIsSyncable = jniAccessors.getStaticMethodIDOf(_classRef,
      "getIsSyncable", "(Landroid/accounts/Account;Ljava/lang/String;)I");

  /// from: static public int getIsSyncable(android.accounts.Account account, java.lang.String authority)
  ///
  /// Check if this account/provider is syncable.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#READ_SYNC_SETTINGS.
  ///@return >0 if it is syncable, 0 if not, and <0 if the state isn't known yet.
  static int getIsSyncable(account_.Account account, jni.JniString authority) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getIsSyncable,
          jni.JniType.intType,
          [account.reference, authority.reference]).integer;

  static final _id_setIsSyncable = jniAccessors.getStaticMethodIDOf(_classRef,
      "setIsSyncable", "(Landroid/accounts/Account;Ljava/lang/String;I)V");

  /// from: static public void setIsSyncable(android.accounts.Account account, java.lang.String authority, int syncable)
  ///
  /// Set whether this account/provider is syncable.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#WRITE_SYNC_SETTINGS.
  ///@param syncable >0 denotes syncable, 0 means not syncable, <0 means unknown
  static void setIsSyncable(
          account_.Account account, jni.JniString authority, int syncable) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_setIsSyncable,
          jni.JniType.voidType,
          [account.reference, authority.reference, syncable]).check();

  static final _id_getMasterSyncAutomatically = jniAccessors
      .getStaticMethodIDOf(_classRef, "getMasterSyncAutomatically", "()Z");

  /// from: static public boolean getMasterSyncAutomatically()
  ///
  /// Gets the master auto-sync setting that applies to all the providers and accounts.
  /// If this is false then the per-provider auto-sync setting is ignored.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#READ_SYNC_SETTINGS.
  ///@return the master auto-sync setting that applies to all the providers and accounts
  static bool getMasterSyncAutomatically() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getMasterSyncAutomatically, jni.JniType.booleanType, []).boolean;

  static final _id_setMasterSyncAutomatically = jniAccessors
      .getStaticMethodIDOf(_classRef, "setMasterSyncAutomatically", "(Z)V");

  /// from: static public void setMasterSyncAutomatically(boolean sync)
  ///
  /// Sets the master auto-sync setting that applies to all the providers and accounts.
  /// If this is false then the per-provider auto-sync setting is ignored.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#WRITE_SYNC_SETTINGS.
  ///@param sync the master auto-sync setting that applies to all the providers and accounts
  static void setMasterSyncAutomatically(bool sync0) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_setMasterSyncAutomatically,
          jni.JniType.voidType,
          [sync0]).check();

  static final _id_isSyncActive = jniAccessors.getStaticMethodIDOf(_classRef,
      "isSyncActive", "(Landroid/accounts/Account;Ljava/lang/String;)Z");

  /// from: static public boolean isSyncActive(android.accounts.Account account, java.lang.String authority)
  ///
  /// Returns true if there is currently a sync operation for the given account or authority
  /// actively being processed.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#READ_SYNC_STATS.
  ///@param account the account whose setting we are querying
  ///@param authority the provider whose behavior is being queried
  ///@return true if a sync is active for the given account or authority.
  static bool isSyncActive(account_.Account account, jni.JniString authority) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_isSyncActive,
          jni.JniType.booleanType,
          [account.reference, authority.reference]).boolean;

  static final _id_getCurrentSync = jniAccessors.getStaticMethodIDOf(
      _classRef, "getCurrentSync", "()Landroid/content/SyncInfo;");

  /// from: static public android.content.SyncInfo getCurrentSync()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If a sync is active returns the information about it, otherwise returns null.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#READ_SYNC_STATS.
  ///
  ///@return the SyncInfo for the currently active sync or null if one is not active.
  ///@deprecated Since multiple concurrent syncs are now supported you should use
  /// \#getCurrentSyncs() to get the accurate list of current syncs.
  /// This method returns the first item from the list of current syncs
  /// or null if there are none.
  static syncinfo_.SyncInfo getCurrentSync() =>
      syncinfo_.SyncInfo.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getCurrentSync, jni.JniType.objectType, []).object);

  static final _id_getCurrentSyncs = jniAccessors.getStaticMethodIDOf(
      _classRef, "getCurrentSyncs", "()Ljava/util/List;");

  /// from: static public java.util.List<android.content.SyncInfo> getCurrentSyncs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list with information about all the active syncs. This list will be empty
  /// if there are no active syncs.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#READ_SYNC_STATS.
  ///
  ///@return a List of SyncInfo objects for the currently active syncs.
  static jni.JniObject getCurrentSyncs() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getCurrentSyncs, jni.JniType.objectType, []).object);

  static final _id_isSyncPending = jniAccessors.getStaticMethodIDOf(_classRef,
      "isSyncPending", "(Landroid/accounts/Account;Ljava/lang/String;)Z");

  /// from: static public boolean isSyncPending(android.accounts.Account account, java.lang.String authority)
  ///
  /// Return true if the pending status is true of any matching authorities.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#READ_SYNC_STATS.
  ///@param account the account whose setting we are querying
  ///@param authority the provider whose behavior is being queried
  ///@return true if there is a pending sync with the matching account and authority
  static bool isSyncPending(
          account_.Account account, jni.JniString authority) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_isSyncPending,
          jni.JniType.booleanType,
          [account.reference, authority.reference]).boolean;

  static final _id_addStatusChangeListener = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "addStatusChangeListener",
      "(ILandroid/content/SyncStatusObserver;)Ljava/lang/Object;");

  /// from: static public java.lang.Object addStatusChangeListener(int mask, android.content.SyncStatusObserver callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Request notifications when the different aspects of the SyncManager change. The
  /// different items that can be requested are:
  /// <ul>
  /// <li> \#SYNC_OBSERVER_TYPE_PENDING
  /// <li> \#SYNC_OBSERVER_TYPE_ACTIVE
  /// <li> \#SYNC_OBSERVER_TYPE_SETTINGS
  /// </ul>
  /// The caller can set one or more of the status types in the mask for any
  /// given listener registration.
  ///@param mask the status change types that will cause the callback to be invoked
  ///@param callback observer to be invoked when the status changes
  ///@return a handle that can be used to remove the listener at a later time
  static jni.JniObject addStatusChangeListener(
          int mask, syncstatusobserver_.SyncStatusObserver callback) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_addStatusChangeListener,
          jni.JniType.objectType,
          [mask, callback.reference]).object);

  static final _id_removeStatusChangeListener =
      jniAccessors.getStaticMethodIDOf(
          _classRef, "removeStatusChangeListener", "(Ljava/lang/Object;)V");

  /// from: static public void removeStatusChangeListener(java.lang.Object handle)
  ///
  /// Remove a previously registered status change listener.
  ///@param handle the handle that was returned by \#addStatusChangeListener
  static void removeStatusChangeListener(jni.JniObject handle) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_removeStatusChangeListener,
          jni.JniType.voidType,
          [handle.reference]).check();
}
