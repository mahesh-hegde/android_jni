// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/Parcelable.dart" as parcelable_;

import "Resources.dart" as resources_;

import "../../os/Parcel.dart" as parcel_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.res.ColorStateList
///
/// Lets you map android.view.View state sets to colors.
///
/// android.content.res.ColorStateLists are created from XML resource files defined in the
/// "color" subdirectory directory of an application's resource directory. The XML file contains
/// a single "selector" element with a number of "item" elements inside. For example:
/// <pre>
/// &lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt;
///   &lt;item android:state_focused="true"
///           android:color="@color/sample_focused" /&gt;
///   &lt;item android:state_pressed="true"
///           android:state_enabled="false"
///           android:color="@color/sample_disabled_pressed" /&gt;
///   &lt;item android:state_enabled="false"
///           android:color="@color/sample_disabled_not_pressed" /&gt;
///   &lt;item android:color="@color/sample_default" /&gt;
/// &lt;/selector&gt;
/// </pre>
///
/// This defines a set of state spec / color pairs where each state spec specifies a set of
/// states that a view must either be in or not be in and the color specifies the color associated
/// with that spec.
///
/// <a name="StateSpec"></a>
/// <h3>State specs</h3>
///
/// Each item defines a set of state spec and color pairs, where the state spec is a series of
/// attributes set to either {@code true} or {@code false} to represent inclusion or exclusion. If
/// an attribute is not specified for an item, it may be any value.
///
/// For example, the following item will be matched whenever the focused state is set; any other
/// states may be set or unset:
/// <pre>
/// &lt;item android:state_focused="true"
///         android:color="@color/sample_focused" /&gt;
/// </pre>
///
/// Typically, a color state list will reference framework-defined state attributes such as
/// android.R.attr\#state_focused android:state_focused or
/// android.R.attr\#state_enabled android:state_enabled; however, app-defined attributes may
/// also be used.
///
/// <strong>Note:</strong> The list of state specs will be matched against in the order that they
/// appear in the XML file. For this reason, more-specific items should be placed earlier in the
/// file. An item with no state spec is considered to match any set of states and is generally
/// useful as a final item to be used as a default.
///
/// If an item with no state spec is placed before other items, those items
/// will be ignored.
///
/// <a name="ItemAttributes"></a>
/// <h3>Item attributes</h3>
///
/// Each item must define an android.R.attr\#color android:color attribute, which may be
/// an HTML-style hex color, a reference to a color resource, or -- in API 23 and above -- a theme
/// attribute that resolves to a color.
///
/// Starting with API 23, items may optionally define an android.R.attr\#alpha android:alpha
/// attribute to modify the base color's opacity. This attribute takes a either floating-point value
/// between 0 and 1 or a theme attribute that resolves as such. The item's overall color is
/// calculated by multiplying by the base color's alpha channel by the {@code alpha} value. For
/// example, the following item represents the theme's accent color at 50% opacity:
/// <pre>
/// &lt;item android:state_enabled="false"
///         android:color="?android:attr/colorAccent"
///         android:alpha="0.5" /&gt;
/// </pre>
///
/// <a name="DeveloperGuide"></a>
/// <h3>Developer guide</h3>
///
/// For more information, see the guide to
/// <a href="{@docRoot}guide/topics/resources/color-list-resource.html">Color State
/// List Resource</a>.
///@attr ref android.R.styleable\#ColorStateListItem_alpha
///@attr ref android.R.styleable\#ColorStateListItem_color
class ColorStateList extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/res/ColorStateList");
  ColorStateList.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.content.res.ColorStateList> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "([[I[I)V");

  /// from: public void <init>(int[][] states, int[] colors)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a ColorStateList that returns the specified mapping from
  /// states to colors.
  ColorStateList(jni.JniObject states, jni.JniObject colors)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [states.reference, colors.reference]).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef, "valueOf", "(I)Landroid/content/res/ColorStateList;");

  /// from: static public android.content.res.ColorStateList valueOf(int color)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return A ColorStateList containing a single color.
  ///
  /// This value will never be {@code null}.
  static ColorStateList valueOf(int color) =>
      ColorStateList.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_valueOf, jni.JniType.objectType, [color]).object);

  static final _id_createFromXml = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromXml",
      "(Landroid/content/res/Resources;Lorg/xmlpull/v1/XmlPullParser;)Landroid/content/res/ColorStateList;");

  /// from: static public android.content.res.ColorStateList createFromXml(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a ColorStateList from an XML document.
  ///@param r Resources against which the ColorStateList should be inflated.
  ///@param parser Parser for the XML document defining the ColorStateList.
  ///@return A new color state list.
  ///
  /// This value will never be {@code null}.
  ///@deprecated Use \#createFromXml(Resources, XmlPullParser parser, Theme)
  static ColorStateList createFromXml(
          resources_.Resources r, jni.JniObject parser) =>
      ColorStateList.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createFromXml,
          jni.JniType.objectType,
          [r.reference, parser.reference]).object);

  static final _id_createFromXml1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createFromXml",
      "(Landroid/content/res/Resources;Lorg/xmlpull/v1/XmlPullParser;Landroid/content/res/Resources\$Theme;)Landroid/content/res/ColorStateList;");

  /// from: static public android.content.res.ColorStateList createFromXml(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser, android.content.res.Resources.Theme theme)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a ColorStateList from an XML document using given a set of
  /// Resources and a Theme.
  ///@param r Resources against which the ColorStateList should be inflated.
  /// This value must never be {@code null}.
  ///@param parser Parser for the XML document defining the ColorStateList.
  /// This value must never be {@code null}.
  ///@param theme Optional theme to apply to the color state list, may be
  ///              {@code null}.
  /// This value may be {@code null}.
  ///@return A new color state list.
  static ColorStateList createFromXml1(resources_.Resources r,
          jni.JniObject parser, resources_.Resources_Theme theme) =>
      ColorStateList.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createFromXml1,
          jni.JniType.objectType,
          [r.reference, parser.reference, theme.reference]).object);

  static final _id_withAlpha = jniAccessors.getMethodIDOf(
      _classRef, "withAlpha", "(I)Landroid/content/res/ColorStateList;");

  /// from: public android.content.res.ColorStateList withAlpha(int alpha)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new ColorStateList that has the same states and colors as this
  /// one but where each color has the specified alpha value (0-255).
  ///@param alpha The new alpha channel value (0-255).
  ///@return A new color state list.
  ///
  /// This value will never be {@code null}.
  ColorStateList withAlpha(int alpha) =>
      ColorStateList.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_withAlpha, jni.JniType.objectType, [alpha]).object);

  static final _id_getChangingConfigurations =
      jniAccessors.getMethodIDOf(_classRef, "getChangingConfigurations", "()I");

  /// from: public int getChangingConfigurations()
  ///
  /// Returns a mask of the configuration parameters for which this color
  /// state list may change, requiring that it be re-created.
  ///@return a mask of the changing configuration parameters, as defined by
  ///         android.content.pm.ActivityInfo
  ///
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@see android.content.pm.ActivityInfo
  int getChangingConfigurations() => jniAccessors.callMethodWithArgs(reference,
      _id_getChangingConfigurations, jni.JniType.intType, []).integer;

  static final _id_isStateful =
      jniAccessors.getMethodIDOf(_classRef, "isStateful", "()Z");

  /// from: public boolean isStateful()
  ///
  /// Indicates whether this color state list contains at least one state spec
  /// and the first spec is not empty (e.g.&nbsp;match-all).
  ///@return True if this color state list changes color based on state, false
  ///         otherwise.
  ///@see \#getColorForState(int[], int)
  bool isStateful() => jniAccessors.callMethodWithArgs(
      reference, _id_isStateful, jni.JniType.booleanType, []).boolean;

  static final _id_isOpaque =
      jniAccessors.getMethodIDOf(_classRef, "isOpaque", "()Z");

  /// from: public boolean isOpaque()
  ///
  /// Indicates whether this color state list is opaque, which means that every
  /// color returned from \#getColorForState(int[], int) has an alpha
  /// value of 255.
  ///@return True if this color state list is opaque.
  bool isOpaque() => jniAccessors.callMethodWithArgs(
      reference, _id_isOpaque, jni.JniType.booleanType, []).boolean;

  static final _id_getColorForState =
      jniAccessors.getMethodIDOf(_classRef, "getColorForState", "([II)I");

  /// from: public int getColorForState(int[] stateSet, int defaultColor)
  ///
  /// Return the color associated with the given set of
  /// android.view.View states.
  ///@param stateSet an array of android.view.View states
  /// This value may be {@code null}.
  ///@param defaultColor the color to return if there's no matching state
  ///                     spec in this ColorStateList that matches the
  ///                     stateSet.
  ///@return the color associated with that set of states in this ColorStateList.
  int getColorForState(jni.JniObject stateSet, int defaultColor) =>
      jniAccessors.callMethodWithArgs(reference, _id_getColorForState,
          jni.JniType.intType, [stateSet.reference, defaultColor]).integer;

  static final _id_getDefaultColor =
      jniAccessors.getMethodIDOf(_classRef, "getDefaultColor", "()I");

  /// from: public int getDefaultColor()
  ///
  /// Return the default color in this ColorStateList.
  ///@return the default color in this ColorStateList.
  int getDefaultColor() => jniAccessors.callMethodWithArgs(
      reference, _id_getDefaultColor, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}
