// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "AssetFileDescriptor.dart" as assetfiledescriptor_;

import "XmlResourceParser.dart" as xmlresourceparser_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.res.AssetManager
///
/// Provides access to an application's raw asset files; see Resources
/// for the way most applications will want to retrieve their resource data.
/// This class presents a lower-level API that allows you to open and read raw
/// files that have been bundled with the application as a simple stream of
/// bytes.
class AssetManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/res/AssetManager");
  AssetManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ACCESS_BUFFER
  ///
  /// Mode for \#open(String, int): Attempt to load contents into
  /// memory, for fast small reads.
  static const ACCESS_BUFFER = 3;

  /// from: static public final int ACCESS_RANDOM
  ///
  /// Mode for \#open(String, int): Read chunks, and seek forward and
  /// backward.
  static const ACCESS_RANDOM = 1;

  /// from: static public final int ACCESS_STREAMING
  ///
  /// Mode for \#open(String, int): Read sequentially, with an
  /// occasional forward seek.
  static const ACCESS_STREAMING = 2;

  /// from: static public final int ACCESS_UNKNOWN
  ///
  /// Mode for \#open(String, int): no specific information about how
  /// data will be accessed.
  static const ACCESS_UNKNOWN = 0;

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Close this asset manager.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_open = jniAccessors.getMethodIDOf(
      _classRef, "open", "(Ljava/lang/String;)Ljava/io/InputStream;");

  /// from: public java.io.InputStream open(java.lang.String fileName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open an asset using ACCESS_STREAMING mode.  This provides access to
  /// files that have been bundled with an application as assets -- that is,
  /// files placed in to the "assets" directory.
  ///@param fileName The name of the asset to open.  This name can be hierarchical.
  ///
  /// This value must never be {@code null}.
  ///@see \#open(String, int)
  ///@see \#list
  ///@return This value will never be {@code null}.
  jni.JniObject open(jni.JniString fileName) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference, _id_open,
          jni.JniType.objectType, [fileName.reference]).object);

  static final _id_open1 = jniAccessors.getMethodIDOf(
      _classRef, "open", "(Ljava/lang/String;I)Ljava/io/InputStream;");

  /// from: public java.io.InputStream open(java.lang.String fileName, int accessMode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open an asset using an explicit access mode, returning an InputStream to
  /// read its contents.  This provides access to files that have been bundled
  /// with an application as assets -- that is, files placed in to the
  /// "assets" directory.
  ///@param fileName The name of the asset to open.  This name can be hierarchical.
  /// This value must never be {@code null}.
  ///@param accessMode Desired access mode for retrieving the data.
  ///@see \#ACCESS_UNKNOWN
  ///@see \#ACCESS_STREAMING
  ///@see \#ACCESS_RANDOM
  ///@see \#ACCESS_BUFFER
  ///@see \#open(String)
  ///@see \#list
  ///@return This value will never be {@code null}.
  jni.JniObject open1(jni.JniString fileName, int accessMode) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_open1,
          jni.JniType.objectType,
          [fileName.reference, accessMode]).object);

  static final _id_openFd = jniAccessors.getMethodIDOf(_classRef, "openFd",
      "(Ljava/lang/String;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public android.content.res.AssetFileDescriptor openFd(java.lang.String fileName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open an uncompressed asset by mmapping it and returning an AssetFileDescriptor.
  /// This provides access to files that have been bundled with an application as assets -- that
  /// is, files placed in to the "assets" directory.
  ///
  /// The asset must be uncompressed, or an exception will be thrown.
  ///@param fileName The name of the asset to open.  This name can be hierarchical.
  /// This value must never be {@code null}.
  ///@return An open AssetFileDescriptor.
  ///
  /// This value will never be {@code null}.
  assetfiledescriptor_.AssetFileDescriptor openFd(jni.JniString fileName) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openFd, jni.JniType.objectType,
              [fileName.reference]).object);

  static final _id_list = jniAccessors.getMethodIDOf(
      _classRef, "list", "(Ljava/lang/String;)[Ljava/lang/String;");

  /// from: public java.lang.String[] list(java.lang.String path)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a String array of all the assets at the given path.
  ///@param path A relative path within the assets, i.e., "docs/home.html".
  ///
  /// This value must never be {@code null}.
  ///@return String[] Array of strings, one for each asset.  These file
  ///         names are relative to 'path'.  You can open the file by
  ///         concatenating 'path' and a name in the returned string (via
  ///         File) and passing that to open().
  ///
  /// This value may be {@code null}.
  ///@see \#open
  jni.JniObject list(jni.JniString path) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference, _id_list,
          jni.JniType.objectType, [path.reference]).object);

  static final _id_openNonAssetFd = jniAccessors.getMethodIDOf(
      _classRef,
      "openNonAssetFd",
      "(Ljava/lang/String;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public android.content.res.AssetFileDescriptor openNonAssetFd(java.lang.String fileName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a non-asset as an asset by mmapping it and returning an AssetFileDescriptor.
  /// This provides direct access to all of the files included in an application
  /// package (not only its assets).  Applications should not normally use this.
  ///
  /// The asset must not be compressed, or an exception will be thrown.
  ///@param fileName Name of the asset to retrieve.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  assetfiledescriptor_.AssetFileDescriptor openNonAssetFd(
          jni.JniString fileName) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openNonAssetFd,
              jni.JniType.objectType, [fileName.reference]).object);

  static final _id_openNonAssetFd1 = jniAccessors.getMethodIDOf(
      _classRef,
      "openNonAssetFd",
      "(ILjava/lang/String;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public android.content.res.AssetFileDescriptor openNonAssetFd(int cookie, java.lang.String fileName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a non-asset as an asset by mmapping it and returning an AssetFileDescriptor.
  /// This provides direct access to all of the files included in an application
  /// package (not only its assets).  Applications should not normally use this.
  ///
  /// The asset must not be compressed, or an exception will be thrown.
  ///@param cookie Identifier of the package to be opened.
  ///@param fileName Name of the asset to retrieve.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  assetfiledescriptor_.AssetFileDescriptor openNonAssetFd1(
          int cookie, jni.JniString fileName) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openNonAssetFd1,
              jni.JniType.objectType, [cookie, fileName.reference]).object);

  static final _id_openXmlResourceParser = jniAccessors.getMethodIDOf(
      _classRef,
      "openXmlResourceParser",
      "(Ljava/lang/String;)Landroid/content/res/XmlResourceParser;");

  /// from: public android.content.res.XmlResourceParser openXmlResourceParser(java.lang.String fileName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a parser for a compiled XML file.
  ///@param fileName The name of the file to retrieve.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  xmlresourceparser_.XmlResourceParser openXmlResourceParser(
          jni.JniString fileName) =>
      xmlresourceparser_.XmlResourceParser.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openXmlResourceParser,
              jni.JniType.objectType, [fileName.reference]).object);

  static final _id_openXmlResourceParser1 = jniAccessors.getMethodIDOf(
      _classRef,
      "openXmlResourceParser",
      "(ILjava/lang/String;)Landroid/content/res/XmlResourceParser;");

  /// from: public android.content.res.XmlResourceParser openXmlResourceParser(int cookie, java.lang.String fileName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a parser for a compiled XML file.
  ///@param cookie Identifier of the package to be opened.
  ///@param fileName The name of the file to retrieve.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  xmlresourceparser_.XmlResourceParser openXmlResourceParser1(
          int cookie, jni.JniString fileName) =>
      xmlresourceparser_.XmlResourceParser.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openXmlResourceParser1,
              jni.JniType.objectType, [cookie, fileName.reference]).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_getLocales = jniAccessors.getMethodIDOf(
      _classRef, "getLocales", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getLocales()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the locales that this asset manager contains data for.
  ///
  /// On SDK 21 (Android 5.0: Lollipop) and above, Locale strings are valid
  /// <a href="https://tools.ietf.org/html/bcp47">BCP-47</a> language tags and can be
  /// parsed using java.util.Locale\#forLanguageTag(String).
  ///
  /// On SDK 20 (Android 4.4W: KitKat for watches) and below, locale strings
  /// are of the form {@code ll_CC} where {@code ll} is a two letter language code,
  /// and {@code CC} is a two letter country code.
  jni.JniObject getLocales() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLocales, jni.JniType.objectType, []).object);
}

/// from: android.content.res.AssetManager$AssetInputStream
class AssetManager_AssetInputStream extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/content/res/AssetManager\$AssetInputStream");
  AssetManager_AssetInputStream.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_read = jniAccessors.getMethodIDOf(_classRef, "read", "()I");

  /// from: public int read()
  int read() => jniAccessors
      .callMethodWithArgs(reference, _id_read, jni.JniType.intType, []).integer;

  static final _id_read1 =
      jniAccessors.getMethodIDOf(_classRef, "read", "([B)I");

  /// from: public int read(byte[] b)
  ///
  /// @param b This value must never be {@code null}.
  int read1(jni.JniObject b) => jniAccessors.callMethodWithArgs(
      reference, _id_read1, jni.JniType.intType, [b.reference]).integer;

  static final _id_read2 =
      jniAccessors.getMethodIDOf(_classRef, "read", "([BII)I");

  /// from: public int read(byte[] b, int off, int len)
  ///
  /// @param b This value must never be {@code null}.
  int read2(jni.JniObject b, int off, int len) =>
      jniAccessors.callMethodWithArgs(reference, _id_read2, jni.JniType.intType,
          [b.reference, off, len]).integer;

  static final _id_skip = jniAccessors.getMethodIDOf(_classRef, "skip", "(J)J");

  /// from: public long skip(long n)
  int skip(int n) => jniAccessors
      .callMethodWithArgs(reference, _id_skip, jni.JniType.longType, [n]).long;

  static final _id_available =
      jniAccessors.getMethodIDOf(_classRef, "available", "()I");

  /// from: public int available()
  int available() => jniAccessors.callMethodWithArgs(
      reference, _id_available, jni.JniType.intType, []).integer;

  static final _id_markSupported =
      jniAccessors.getMethodIDOf(_classRef, "markSupported", "()Z");

  /// from: public boolean markSupported()
  bool markSupported() => jniAccessors.callMethodWithArgs(
      reference, _id_markSupported, jni.JniType.booleanType, []).boolean;

  static final _id_mark = jniAccessors.getMethodIDOf(_classRef, "mark", "(I)V");

  /// from: public void mark(int readlimit)
  void mark(int readlimit) => jniAccessors.callMethodWithArgs(
      reference, _id_mark, jni.JniType.voidType, [readlimit]).check();

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, "reset", "()V");

  /// from: public void reset()
  void reset() => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniType.voidType, []).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}
