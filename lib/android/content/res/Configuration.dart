// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/Parcelable.dart" as parcelable_;

import "../../os/Parcel.dart" as parcel_;

import "../../os/LocaleList.dart" as localelist_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.res.Configuration
///
/// This class describes all device configuration information that can
/// impact the resources the application retrieves.  This includes both
/// user-specified configuration options (locale list and scaling) as well
/// as device configurations (such as input modes, screen size and screen orientation).
/// You can acquire this object from Resources, using Resources\#getConfiguration. Thus, from an activity, you can get it by chaining the request
/// with android.app.Activity\#getResources:
///
/// <pre>Configuration config = getResources().getConfiguration();</pre>
class Configuration extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/res/Configuration");
  Configuration.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int COLOR_MODE_HDR_MASK
  ///
  /// Constant for \#colorMode: bits that encode the dynamic range of the screen.
  static const COLOR_MODE_HDR_MASK = 12;

  /// from: static public final int COLOR_MODE_HDR_NO
  ///
  /// Constant for \#colorMode: a \#COLOR_MODE_HDR_MASK value
  /// indicating that the screen is not HDR (low/standard dynamic range).
  /// Corresponds to the <code>-lowdr</code> resource qualifier.
  ///
  static const COLOR_MODE_HDR_NO = 4;

  /// from: static public final int COLOR_MODE_HDR_SHIFT
  ///
  /// Constant for \#colorMode: bits shift to get the screen dynamic range.
  static const COLOR_MODE_HDR_SHIFT = 2;

  /// from: static public final int COLOR_MODE_HDR_UNDEFINED
  ///
  /// Constant for \#colorMode: a \#COLOR_MODE_HDR_MASK value
  /// indicating that it is unknown whether or not the screen is HDR.
  static const COLOR_MODE_HDR_UNDEFINED = 0;

  /// from: static public final int COLOR_MODE_HDR_YES
  ///
  /// Constant for \#colorMode: a \#COLOR_MODE_HDR_MASK value
  /// indicating that the screen is HDR (dynamic range).
  /// Corresponds to the <code>-highdr</code> resource qualifier.
  ///
  static const COLOR_MODE_HDR_YES = 8;

  /// from: static public final int COLOR_MODE_UNDEFINED
  ///
  /// Constant for \#colorMode: a value indicating that the color mode is undefined
  static const COLOR_MODE_UNDEFINED = 0;

  /// from: static public final int COLOR_MODE_WIDE_COLOR_GAMUT_MASK
  ///
  /// Constant for \#colorMode: bits that encode whether the screen is wide gamut.
  static const COLOR_MODE_WIDE_COLOR_GAMUT_MASK = 3;

  /// from: static public final int COLOR_MODE_WIDE_COLOR_GAMUT_NO
  ///
  /// Constant for \#colorMode: a \#COLOR_MODE_WIDE_COLOR_GAMUT_MASK value
  /// indicating that the screen is not wide gamut.
  /// Corresponds to the <code>-nowidecg</code> resource qualifier.
  ///
  static const COLOR_MODE_WIDE_COLOR_GAMUT_NO = 1;

  /// from: static public final int COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED
  ///
  /// Constant for \#colorMode: a \#COLOR_MODE_WIDE_COLOR_GAMUT_MASK value
  /// indicating that it is unknown whether or not the screen is wide gamut.
  static const COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED = 0;

  /// from: static public final int COLOR_MODE_WIDE_COLOR_GAMUT_YES
  ///
  /// Constant for \#colorMode: a \#COLOR_MODE_WIDE_COLOR_GAMUT_MASK value
  /// indicating that the screen is wide gamut.
  /// Corresponds to the <code>-widecg</code> resource qualifier.
  ///
  static const COLOR_MODE_WIDE_COLOR_GAMUT_YES = 2;

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.content.res.Configuration> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int DENSITY_DPI_UNDEFINED
  ///
  /// Default value for \#densityDpi indicating that no width
  /// has been specified.
  static const DENSITY_DPI_UNDEFINED = 0;

  /// from: static public final int HARDKEYBOARDHIDDEN_NO
  ///
  /// Constant for \#hardKeyboardHidden, value corresponding to the
  /// physical keyboard being exposed.
  static const HARDKEYBOARDHIDDEN_NO = 1;

  /// from: static public final int HARDKEYBOARDHIDDEN_UNDEFINED
  ///
  /// Constant for \#hardKeyboardHidden: a value indicating that no value has been set.
  static const HARDKEYBOARDHIDDEN_UNDEFINED = 0;

  /// from: static public final int HARDKEYBOARDHIDDEN_YES
  ///
  /// Constant for \#hardKeyboardHidden, value corresponding to the
  /// physical keyboard being hidden.
  static const HARDKEYBOARDHIDDEN_YES = 2;

  /// from: static public final int KEYBOARDHIDDEN_NO
  ///
  /// Constant for \#keyboardHidden, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#KeyboardAvailQualifier">keysexposed</a>
  /// resource qualifier.
  static const KEYBOARDHIDDEN_NO = 1;

  /// from: static public final int KEYBOARDHIDDEN_UNDEFINED
  ///
  /// Constant for \#keyboardHidden: a value indicating that no value has been set.
  static const KEYBOARDHIDDEN_UNDEFINED = 0;

  /// from: static public final int KEYBOARDHIDDEN_YES
  ///
  /// Constant for \#keyboardHidden, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#KeyboardAvailQualifier">keyshidden</a>
  /// resource qualifier.
  static const KEYBOARDHIDDEN_YES = 2;

  /// from: static public final int KEYBOARD_12KEY
  ///
  /// Constant for \#keyboard, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ImeQualifier">12key</a>
  /// resource qualifier.
  static const KEYBOARD_12KEY = 3;

  /// from: static public final int KEYBOARD_NOKEYS
  ///
  /// Constant for \#keyboard, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ImeQualifier">nokeys</a>
  /// resource qualifier.
  static const KEYBOARD_NOKEYS = 1;

  /// from: static public final int KEYBOARD_QWERTY
  ///
  /// Constant for \#keyboard, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ImeQualifier">qwerty</a>
  /// resource qualifier.
  static const KEYBOARD_QWERTY = 2;

  /// from: static public final int KEYBOARD_UNDEFINED
  ///
  /// Constant for \#keyboard: a value indicating that no value has been set.
  static const KEYBOARD_UNDEFINED = 0;

  /// from: static public final int MNC_ZERO
  ///
  /// Constant used to to represent MNC (Mobile Network Code) zero.
  /// 0 cannot be used, since it is used to represent an undefined MNC.
  static const MNC_ZERO = 65535;

  /// from: static public final int NAVIGATIONHIDDEN_NO
  ///
  /// Constant for \#navigationHidden, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavAvailQualifier">navexposed</a>
  /// resource qualifier.
  static const NAVIGATIONHIDDEN_NO = 1;

  /// from: static public final int NAVIGATIONHIDDEN_UNDEFINED
  ///
  /// Constant for \#navigationHidden: a value indicating that no value has been set.
  static const NAVIGATIONHIDDEN_UNDEFINED = 0;

  /// from: static public final int NAVIGATIONHIDDEN_YES
  ///
  /// Constant for \#navigationHidden, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavAvailQualifier">navhidden</a>
  /// resource qualifier.
  static const NAVIGATIONHIDDEN_YES = 2;

  /// from: static public final int NAVIGATION_DPAD
  ///
  /// Constant for \#navigation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavigationQualifier">dpad</a>
  /// resource qualifier.
  static const NAVIGATION_DPAD = 2;

  /// from: static public final int NAVIGATION_NONAV
  ///
  /// Constant for \#navigation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavigationQualifier">nonav</a>
  /// resource qualifier.
  static const NAVIGATION_NONAV = 1;

  /// from: static public final int NAVIGATION_TRACKBALL
  ///
  /// Constant for \#navigation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavigationQualifier">trackball</a>
  /// resource qualifier.
  static const NAVIGATION_TRACKBALL = 3;

  /// from: static public final int NAVIGATION_UNDEFINED
  ///
  /// Constant for \#navigation: a value indicating that no value has been set.
  static const NAVIGATION_UNDEFINED = 0;

  /// from: static public final int NAVIGATION_WHEEL
  ///
  /// Constant for \#navigation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavigationQualifier">wheel</a>
  /// resource qualifier.
  static const NAVIGATION_WHEEL = 4;

  /// from: static public final int ORIENTATION_LANDSCAPE
  ///
  /// Constant for \#orientation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#OrientationQualifier">land</a>
  /// resource qualifier.
  static const ORIENTATION_LANDSCAPE = 2;

  /// from: static public final int ORIENTATION_PORTRAIT
  ///
  /// Constant for \#orientation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#OrientationQualifier">port</a>
  /// resource qualifier.
  static const ORIENTATION_PORTRAIT = 1;

  /// from: static public final int ORIENTATION_SQUARE
  ///
  /// @deprecated Not currently supported or used.
  static const ORIENTATION_SQUARE = 3;

  /// from: static public final int ORIENTATION_UNDEFINED
  ///
  /// Constant for \#orientation: a value indicating that no value has been set.
  static const ORIENTATION_UNDEFINED = 0;

  /// from: static public final int SCREENLAYOUT_LAYOUTDIR_LTR
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LAYOUTDIR_MASK
  /// value indicating that a layout dir has been set to LTR.
  static const SCREENLAYOUT_LAYOUTDIR_LTR = 64;

  /// from: static public final int SCREENLAYOUT_LAYOUTDIR_MASK
  ///
  /// Constant for \#screenLayout: bits that encode the layout direction.
  static const SCREENLAYOUT_LAYOUTDIR_MASK = 192;

  /// from: static public final int SCREENLAYOUT_LAYOUTDIR_RTL
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LAYOUTDIR_MASK
  /// value indicating that a layout dir has been set to RTL.
  static const SCREENLAYOUT_LAYOUTDIR_RTL = 128;

  /// from: static public final int SCREENLAYOUT_LAYOUTDIR_SHIFT
  ///
  /// Constant for \#screenLayout: bits shift to get the layout direction.
  static const SCREENLAYOUT_LAYOUTDIR_SHIFT = 6;

  /// from: static public final int SCREENLAYOUT_LAYOUTDIR_UNDEFINED
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LAYOUTDIR_MASK
  /// value indicating that no layout dir has been set.
  static const SCREENLAYOUT_LAYOUTDIR_UNDEFINED = 0;

  /// from: static public final int SCREENLAYOUT_LONG_MASK
  ///
  /// Constant for \#screenLayout: bits that encode the aspect ratio.
  static const SCREENLAYOUT_LONG_MASK = 48;

  /// from: static public final int SCREENLAYOUT_LONG_NO
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LONG_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenAspectQualifier">notlong</a>
  /// resource qualifier.
  static const SCREENLAYOUT_LONG_NO = 16;

  /// from: static public final int SCREENLAYOUT_LONG_UNDEFINED
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LONG_MASK
  /// value indicating that no size has been set.
  static const SCREENLAYOUT_LONG_UNDEFINED = 0;

  /// from: static public final int SCREENLAYOUT_LONG_YES
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LONG_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenAspectQualifier">long</a>
  /// resource qualifier.
  static const SCREENLAYOUT_LONG_YES = 32;

  /// from: static public final int SCREENLAYOUT_ROUND_MASK
  ///
  /// Constant for \#screenLayout: bits that encode roundness of the screen.
  static const SCREENLAYOUT_ROUND_MASK = 768;

  /// from: static public final int SCREENLAYOUT_ROUND_NO
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_ROUND_MASK value indicating
  /// that the screen does not have a rounded shape.
  static const SCREENLAYOUT_ROUND_NO = 256;

  /// from: static public final int SCREENLAYOUT_ROUND_UNDEFINED
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_ROUND_MASK value indicating
  /// that it is unknown whether or not the screen has a round shape.
  static const SCREENLAYOUT_ROUND_UNDEFINED = 0;

  /// from: static public final int SCREENLAYOUT_ROUND_YES
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_ROUND_MASK value indicating
  /// that the screen has a rounded shape. Corners may not be visible to the user;
  /// developers should pay special attention to the android.view.WindowInsets delivered
  /// to views for more information about ensuring content is not obscured.
  ///
  /// Corresponds to the <code>-round</code> resource qualifier.
  ///
  static const SCREENLAYOUT_ROUND_YES = 512;

  /// from: static public final int SCREENLAYOUT_SIZE_LARGE
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_SIZE_MASK
  /// value indicating the screen is at least approximately 480x640 dp units,
  /// corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenSizeQualifier">large</a>
  /// resource qualifier.
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  static const SCREENLAYOUT_SIZE_LARGE = 3;

  /// from: static public final int SCREENLAYOUT_SIZE_MASK
  ///
  /// Constant for \#screenLayout: bits that encode the size.
  static const SCREENLAYOUT_SIZE_MASK = 15;

  /// from: static public final int SCREENLAYOUT_SIZE_NORMAL
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_SIZE_MASK
  /// value indicating the screen is at least approximately 320x470 dp units,
  /// corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenSizeQualifier">normal</a>
  /// resource qualifier.
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  static const SCREENLAYOUT_SIZE_NORMAL = 2;

  /// from: static public final int SCREENLAYOUT_SIZE_SMALL
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_SIZE_MASK
  /// value indicating the screen is at least approximately 320x426 dp units,
  /// corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenSizeQualifier">small</a>
  /// resource qualifier.
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  static const SCREENLAYOUT_SIZE_SMALL = 1;

  /// from: static public final int SCREENLAYOUT_SIZE_UNDEFINED
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_SIZE_MASK
  /// value indicating that no size has been set.
  static const SCREENLAYOUT_SIZE_UNDEFINED = 0;

  /// from: static public final int SCREENLAYOUT_SIZE_XLARGE
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_SIZE_MASK
  /// value indicating the screen is at least approximately 720x960 dp units,
  /// corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenSizeQualifier">xlarge</a>
  /// resource qualifier.
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  static const SCREENLAYOUT_SIZE_XLARGE = 4;

  /// from: static public final int SCREENLAYOUT_UNDEFINED
  ///
  /// Constant for \#screenLayout: a value indicating that screenLayout is undefined
  static const SCREENLAYOUT_UNDEFINED = 0;

  /// from: static public final int SCREEN_HEIGHT_DP_UNDEFINED
  ///
  /// Default value for \#screenHeightDp indicating that no width
  /// has been specified.
  static const SCREEN_HEIGHT_DP_UNDEFINED = 0;

  /// from: static public final int SCREEN_WIDTH_DP_UNDEFINED
  ///
  /// Default value for \#screenWidthDp indicating that no width
  /// has been specified.
  static const SCREEN_WIDTH_DP_UNDEFINED = 0;

  /// from: static public final int SMALLEST_SCREEN_WIDTH_DP_UNDEFINED
  ///
  /// Default value for \#smallestScreenWidthDp indicating that no width
  /// has been specified.
  static const SMALLEST_SCREEN_WIDTH_DP_UNDEFINED = 0;

  /// from: static public final int TOUCHSCREEN_FINGER
  ///
  /// Constant for \#touchscreen, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#TouchscreenQualifier">finger</a>
  /// resource qualifier.
  static const TOUCHSCREEN_FINGER = 3;

  /// from: static public final int TOUCHSCREEN_NOTOUCH
  ///
  /// Constant for \#touchscreen, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#TouchscreenQualifier">notouch</a>
  /// resource qualifier.
  static const TOUCHSCREEN_NOTOUCH = 1;

  /// from: static public final int TOUCHSCREEN_STYLUS
  ///
  /// @deprecated Not currently supported or used.
  static const TOUCHSCREEN_STYLUS = 2;

  /// from: static public final int TOUCHSCREEN_UNDEFINED
  ///
  /// Constant for \#touchscreen: a value indicating that no value has been set.
  static const TOUCHSCREEN_UNDEFINED = 0;

  /// from: static public final int UI_MODE_NIGHT_MASK
  ///
  /// Constant for \#uiMode: bits that encode the night mode.
  static const UI_MODE_NIGHT_MASK = 48;

  /// from: static public final int UI_MODE_NIGHT_NO
  ///
  /// Constant for \#uiMode: a \#UI_MODE_NIGHT_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NightQualifier">notnight</a>
  /// resource qualifier.
  static const UI_MODE_NIGHT_NO = 16;

  /// from: static public final int UI_MODE_NIGHT_UNDEFINED
  ///
  /// Constant for \#uiMode: a \#UI_MODE_NIGHT_MASK
  /// value indicating that no mode type has been set.
  static const UI_MODE_NIGHT_UNDEFINED = 0;

  /// from: static public final int UI_MODE_NIGHT_YES
  ///
  /// Constant for \#uiMode: a \#UI_MODE_NIGHT_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NightQualifier">night</a>
  /// resource qualifier.
  static const UI_MODE_NIGHT_YES = 32;

  /// from: static public final int UI_MODE_TYPE_APPLIANCE
  ///
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">appliance</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_APPLIANCE = 5;

  /// from: static public final int UI_MODE_TYPE_CAR
  ///
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">car</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_CAR = 3;

  /// from: static public final int UI_MODE_TYPE_DESK
  ///
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">desk</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_DESK = 2;

  /// from: static public final int UI_MODE_TYPE_MASK
  ///
  /// Constant for \#uiMode: bits that encode the mode type.
  static const UI_MODE_TYPE_MASK = 15;

  /// from: static public final int UI_MODE_TYPE_NORMAL
  ///
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">no
  /// UI mode</a> resource qualifier specified.
  static const UI_MODE_TYPE_NORMAL = 1;

  /// from: static public final int UI_MODE_TYPE_TELEVISION
  ///
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">television</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_TELEVISION = 4;

  /// from: static public final int UI_MODE_TYPE_UNDEFINED
  ///
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value indicating that no mode type has been set.
  static const UI_MODE_TYPE_UNDEFINED = 0;

  /// from: static public final int UI_MODE_TYPE_VR_HEADSET
  ///
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">vrheadset</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_VR_HEADSET = 7;

  /// from: static public final int UI_MODE_TYPE_WATCH
  ///
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">watch</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_WATCH = 6;

  static final _id_colorMode =
      jniAccessors.getFieldIDOf(_classRef, "colorMode", "I");

  /// from: public int colorMode
  ///
  /// Bit mask of color capabilities of the screen. Currently there are two fields:
  /// The \#COLOR_MODE_WIDE_COLOR_GAMUT_MASK bits define the color gamut of
  /// the screen. They may be one of
  /// \#COLOR_MODE_WIDE_COLOR_GAMUT_NO or \#COLOR_MODE_WIDE_COLOR_GAMUT_YES.
  ///
  ///
  /// The \#COLOR_MODE_HDR_MASK defines the dynamic range of the screen. They may be
  /// one of \#COLOR_MODE_HDR_NO or \#COLOR_MODE_HDR_YES.
  ///
  ///
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  ///
  int get colorMode => jniAccessors
      .getField(reference, _id_colorMode, jni.JniType.intType)
      .integer;

  /// from: public int colorMode
  ///
  /// Bit mask of color capabilities of the screen. Currently there are two fields:
  /// The \#COLOR_MODE_WIDE_COLOR_GAMUT_MASK bits define the color gamut of
  /// the screen. They may be one of
  /// \#COLOR_MODE_WIDE_COLOR_GAMUT_NO or \#COLOR_MODE_WIDE_COLOR_GAMUT_YES.
  ///
  ///
  /// The \#COLOR_MODE_HDR_MASK defines the dynamic range of the screen. They may be
  /// one of \#COLOR_MODE_HDR_NO or \#COLOR_MODE_HDR_YES.
  ///
  ///
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  ///
  set colorMode(int value) =>
      jniEnv.SetIntField(reference, _id_colorMode, value);

  static final _id_densityDpi =
      jniAccessors.getFieldIDOf(_classRef, "densityDpi", "I");

  /// from: public int densityDpi
  ///
  /// The target screen density being rendered to,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#DensityQualifier">density</a>
  /// resource qualifier.  Set to
  /// \#DENSITY_DPI_UNDEFINED if no density is specified.
  int get densityDpi => jniAccessors
      .getField(reference, _id_densityDpi, jni.JniType.intType)
      .integer;

  /// from: public int densityDpi
  ///
  /// The target screen density being rendered to,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#DensityQualifier">density</a>
  /// resource qualifier.  Set to
  /// \#DENSITY_DPI_UNDEFINED if no density is specified.
  set densityDpi(int value) =>
      jniEnv.SetIntField(reference, _id_densityDpi, value);

  static final _id_fontScale =
      jniAccessors.getFieldIDOf(_classRef, "fontScale", "F");

  /// from: public float fontScale
  ///
  /// Current user preference for the scaling factor for fonts, relative
  /// to the base density scaling.
  double get fontScale => jniAccessors
      .getField(reference, _id_fontScale, jni.JniType.floatType)
      .float;

  /// from: public float fontScale
  ///
  /// Current user preference for the scaling factor for fonts, relative
  /// to the base density scaling.
  set fontScale(double value) =>
      jniEnv.SetFloatField(reference, _id_fontScale, value);

  static final _id_hardKeyboardHidden =
      jniAccessors.getFieldIDOf(_classRef, "hardKeyboardHidden", "I");

  /// from: public int hardKeyboardHidden
  ///
  /// A flag indicating whether the hard keyboard has been hidden.  This will
  /// be set on a device with a mechanism to hide the keyboard from the
  /// user, when that mechanism is closed.  One of:
  /// \#HARDKEYBOARDHIDDEN_NO, \#HARDKEYBOARDHIDDEN_YES.
  int get hardKeyboardHidden => jniAccessors
      .getField(reference, _id_hardKeyboardHidden, jni.JniType.intType)
      .integer;

  /// from: public int hardKeyboardHidden
  ///
  /// A flag indicating whether the hard keyboard has been hidden.  This will
  /// be set on a device with a mechanism to hide the keyboard from the
  /// user, when that mechanism is closed.  One of:
  /// \#HARDKEYBOARDHIDDEN_NO, \#HARDKEYBOARDHIDDEN_YES.
  set hardKeyboardHidden(int value) =>
      jniEnv.SetIntField(reference, _id_hardKeyboardHidden, value);

  static final _id_keyboard =
      jniAccessors.getFieldIDOf(_classRef, "keyboard", "I");

  /// from: public int keyboard
  ///
  /// The kind of keyboard attached to the device.
  /// One of: \#KEYBOARD_NOKEYS, \#KEYBOARD_QWERTY,
  /// \#KEYBOARD_12KEY.
  int get keyboard => jniAccessors
      .getField(reference, _id_keyboard, jni.JniType.intType)
      .integer;

  /// from: public int keyboard
  ///
  /// The kind of keyboard attached to the device.
  /// One of: \#KEYBOARD_NOKEYS, \#KEYBOARD_QWERTY,
  /// \#KEYBOARD_12KEY.
  set keyboard(int value) => jniEnv.SetIntField(reference, _id_keyboard, value);

  static final _id_keyboardHidden =
      jniAccessors.getFieldIDOf(_classRef, "keyboardHidden", "I");

  /// from: public int keyboardHidden
  ///
  /// A flag indicating whether any keyboard is available.  Unlike
  /// \#hardKeyboardHidden, this also takes into account a soft
  /// keyboard, so if the hard keyboard is hidden but there is soft
  /// keyboard available, it will be set to NO.  Value is one of:
  /// \#KEYBOARDHIDDEN_NO, \#KEYBOARDHIDDEN_YES.
  int get keyboardHidden => jniAccessors
      .getField(reference, _id_keyboardHidden, jni.JniType.intType)
      .integer;

  /// from: public int keyboardHidden
  ///
  /// A flag indicating whether any keyboard is available.  Unlike
  /// \#hardKeyboardHidden, this also takes into account a soft
  /// keyboard, so if the hard keyboard is hidden but there is soft
  /// keyboard available, it will be set to NO.  Value is one of:
  /// \#KEYBOARDHIDDEN_NO, \#KEYBOARDHIDDEN_YES.
  set keyboardHidden(int value) =>
      jniEnv.SetIntField(reference, _id_keyboardHidden, value);

  static final _id_locale =
      jniAccessors.getFieldIDOf(_classRef, "locale", "Ljava/util/Locale;");

  /// from: public java.util.Locale locale
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Current user preference for the locale, corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#LocaleQualifier">locale</a>
  /// resource qualifier.
  ///@deprecated Do not set or read this directly. Use \#getLocales() and
  /// \#setLocales(LocaleList). If only the primary locale is needed,
  /// <code>getLocales().get(0)</code> is now the preferred accessor.
  jni.JniObject get locale => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_locale, jni.JniType.objectType)
      .object);

  /// from: public java.util.Locale locale
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Current user preference for the locale, corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#LocaleQualifier">locale</a>
  /// resource qualifier.
  ///@deprecated Do not set or read this directly. Use \#getLocales() and
  /// \#setLocales(LocaleList). If only the primary locale is needed,
  /// <code>getLocales().get(0)</code> is now the preferred accessor.
  set locale(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_locale, value.reference);

  static final _id_mcc = jniAccessors.getFieldIDOf(_classRef, "mcc", "I");

  /// from: public int mcc
  ///
  /// IMSI MCC (Mobile Country Code), corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#MccQualifier">mcc</a>
  /// resource qualifier.  0 if undefined.
  int get mcc =>
      jniAccessors.getField(reference, _id_mcc, jni.JniType.intType).integer;

  /// from: public int mcc
  ///
  /// IMSI MCC (Mobile Country Code), corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#MccQualifier">mcc</a>
  /// resource qualifier.  0 if undefined.
  set mcc(int value) => jniEnv.SetIntField(reference, _id_mcc, value);

  static final _id_mnc = jniAccessors.getFieldIDOf(_classRef, "mnc", "I");

  /// from: public int mnc
  ///
  /// IMSI MNC (Mobile Network Code), corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#MccQualifier">mnc</a>
  /// resource qualifier.  0 if undefined. Note that the actual MNC may be 0; in order to check
  /// for this use the \#MNC_ZERO symbol.
  int get mnc =>
      jniAccessors.getField(reference, _id_mnc, jni.JniType.intType).integer;

  /// from: public int mnc
  ///
  /// IMSI MNC (Mobile Network Code), corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#MccQualifier">mnc</a>
  /// resource qualifier.  0 if undefined. Note that the actual MNC may be 0; in order to check
  /// for this use the \#MNC_ZERO symbol.
  set mnc(int value) => jniEnv.SetIntField(reference, _id_mnc, value);

  static final _id_navigation =
      jniAccessors.getFieldIDOf(_classRef, "navigation", "I");

  /// from: public int navigation
  ///
  /// The kind of navigation method available on the device.
  /// One of: \#NAVIGATION_NONAV, \#NAVIGATION_DPAD,
  /// \#NAVIGATION_TRACKBALL, \#NAVIGATION_WHEEL.
  int get navigation => jniAccessors
      .getField(reference, _id_navigation, jni.JniType.intType)
      .integer;

  /// from: public int navigation
  ///
  /// The kind of navigation method available on the device.
  /// One of: \#NAVIGATION_NONAV, \#NAVIGATION_DPAD,
  /// \#NAVIGATION_TRACKBALL, \#NAVIGATION_WHEEL.
  set navigation(int value) =>
      jniEnv.SetIntField(reference, _id_navigation, value);

  static final _id_navigationHidden =
      jniAccessors.getFieldIDOf(_classRef, "navigationHidden", "I");

  /// from: public int navigationHidden
  ///
  /// A flag indicating whether any 5-way or DPAD navigation available.
  /// This will be set on a device with a mechanism to hide the navigation
  /// controls from the user, when that mechanism is closed.  One of:
  /// \#NAVIGATIONHIDDEN_NO, \#NAVIGATIONHIDDEN_YES.
  int get navigationHidden => jniAccessors
      .getField(reference, _id_navigationHidden, jni.JniType.intType)
      .integer;

  /// from: public int navigationHidden
  ///
  /// A flag indicating whether any 5-way or DPAD navigation available.
  /// This will be set on a device with a mechanism to hide the navigation
  /// controls from the user, when that mechanism is closed.  One of:
  /// \#NAVIGATIONHIDDEN_NO, \#NAVIGATIONHIDDEN_YES.
  set navigationHidden(int value) =>
      jniEnv.SetIntField(reference, _id_navigationHidden, value);

  static final _id_orientation =
      jniAccessors.getFieldIDOf(_classRef, "orientation", "I");

  /// from: public int orientation
  ///
  /// Overall orientation of the screen.  May be one of
  /// \#ORIENTATION_LANDSCAPE, \#ORIENTATION_PORTRAIT.
  int get orientation => jniAccessors
      .getField(reference, _id_orientation, jni.JniType.intType)
      .integer;

  /// from: public int orientation
  ///
  /// Overall orientation of the screen.  May be one of
  /// \#ORIENTATION_LANDSCAPE, \#ORIENTATION_PORTRAIT.
  set orientation(int value) =>
      jniEnv.SetIntField(reference, _id_orientation, value);

  static final _id_screenHeightDp =
      jniAccessors.getFieldIDOf(_classRef, "screenHeightDp", "I");

  /// from: public int screenHeightDp
  ///
  /// The current height of the available screen space, in dp units,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenHeightQualifier">screen
  /// height</a> resource qualifier.  Set to
  /// \#SCREEN_HEIGHT_DP_UNDEFINED if no height is specified.
  int get screenHeightDp => jniAccessors
      .getField(reference, _id_screenHeightDp, jni.JniType.intType)
      .integer;

  /// from: public int screenHeightDp
  ///
  /// The current height of the available screen space, in dp units,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenHeightQualifier">screen
  /// height</a> resource qualifier.  Set to
  /// \#SCREEN_HEIGHT_DP_UNDEFINED if no height is specified.
  set screenHeightDp(int value) =>
      jniEnv.SetIntField(reference, _id_screenHeightDp, value);

  static final _id_screenLayout =
      jniAccessors.getFieldIDOf(_classRef, "screenLayout", "I");

  /// from: public int screenLayout
  ///
  /// Bit mask of overall layout of the screen.  Currently there are four
  /// fields:
  /// The \#SCREENLAYOUT_SIZE_MASK bits define the overall size
  /// of the screen.  They may be one of
  /// \#SCREENLAYOUT_SIZE_SMALL, \#SCREENLAYOUT_SIZE_NORMAL,
  /// \#SCREENLAYOUT_SIZE_LARGE, or \#SCREENLAYOUT_SIZE_XLARGE.
  ///
  ///
  /// The \#SCREENLAYOUT_LONG_MASK defines whether the screen
  /// is wider/taller than normal.  They may be one of
  /// \#SCREENLAYOUT_LONG_NO or \#SCREENLAYOUT_LONG_YES.
  ///
  ///
  /// The \#SCREENLAYOUT_LAYOUTDIR_MASK defines whether the screen layout
  /// is either LTR or RTL.  They may be one of
  /// \#SCREENLAYOUT_LAYOUTDIR_LTR or \#SCREENLAYOUT_LAYOUTDIR_RTL.
  ///
  ///
  /// The \#SCREENLAYOUT_ROUND_MASK defines whether the screen has a rounded
  /// shape. They may be one of \#SCREENLAYOUT_ROUND_NO or \#SCREENLAYOUT_ROUND_YES.
  ///
  ///
  ///
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  ///
  int get screenLayout => jniAccessors
      .getField(reference, _id_screenLayout, jni.JniType.intType)
      .integer;

  /// from: public int screenLayout
  ///
  /// Bit mask of overall layout of the screen.  Currently there are four
  /// fields:
  /// The \#SCREENLAYOUT_SIZE_MASK bits define the overall size
  /// of the screen.  They may be one of
  /// \#SCREENLAYOUT_SIZE_SMALL, \#SCREENLAYOUT_SIZE_NORMAL,
  /// \#SCREENLAYOUT_SIZE_LARGE, or \#SCREENLAYOUT_SIZE_XLARGE.
  ///
  ///
  /// The \#SCREENLAYOUT_LONG_MASK defines whether the screen
  /// is wider/taller than normal.  They may be one of
  /// \#SCREENLAYOUT_LONG_NO or \#SCREENLAYOUT_LONG_YES.
  ///
  ///
  /// The \#SCREENLAYOUT_LAYOUTDIR_MASK defines whether the screen layout
  /// is either LTR or RTL.  They may be one of
  /// \#SCREENLAYOUT_LAYOUTDIR_LTR or \#SCREENLAYOUT_LAYOUTDIR_RTL.
  ///
  ///
  /// The \#SCREENLAYOUT_ROUND_MASK defines whether the screen has a rounded
  /// shape. They may be one of \#SCREENLAYOUT_ROUND_NO or \#SCREENLAYOUT_ROUND_YES.
  ///
  ///
  ///
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  ///
  set screenLayout(int value) =>
      jniEnv.SetIntField(reference, _id_screenLayout, value);

  static final _id_screenWidthDp =
      jniAccessors.getFieldIDOf(_classRef, "screenWidthDp", "I");

  /// from: public int screenWidthDp
  ///
  /// The current width of the available screen space, in dp units,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenWidthQualifier">screen
  /// width</a> resource qualifier.  Set to
  /// \#SCREEN_WIDTH_DP_UNDEFINED if no width is specified.
  int get screenWidthDp => jniAccessors
      .getField(reference, _id_screenWidthDp, jni.JniType.intType)
      .integer;

  /// from: public int screenWidthDp
  ///
  /// The current width of the available screen space, in dp units,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenWidthQualifier">screen
  /// width</a> resource qualifier.  Set to
  /// \#SCREEN_WIDTH_DP_UNDEFINED if no width is specified.
  set screenWidthDp(int value) =>
      jniEnv.SetIntField(reference, _id_screenWidthDp, value);

  static final _id_smallestScreenWidthDp =
      jniAccessors.getFieldIDOf(_classRef, "smallestScreenWidthDp", "I");

  /// from: public int smallestScreenWidthDp
  ///
  /// The smallest screen size an application will see in normal operation,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#SmallestScreenWidthQualifier">smallest
  /// screen width</a> resource qualifier.
  /// This is the smallest value of both screenWidthDp and screenHeightDp
  /// in both portrait and landscape.  Set to
  /// \#SMALLEST_SCREEN_WIDTH_DP_UNDEFINED if no width is specified.
  int get smallestScreenWidthDp => jniAccessors
      .getField(reference, _id_smallestScreenWidthDp, jni.JniType.intType)
      .integer;

  /// from: public int smallestScreenWidthDp
  ///
  /// The smallest screen size an application will see in normal operation,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#SmallestScreenWidthQualifier">smallest
  /// screen width</a> resource qualifier.
  /// This is the smallest value of both screenWidthDp and screenHeightDp
  /// in both portrait and landscape.  Set to
  /// \#SMALLEST_SCREEN_WIDTH_DP_UNDEFINED if no width is specified.
  set smallestScreenWidthDp(int value) =>
      jniEnv.SetIntField(reference, _id_smallestScreenWidthDp, value);

  static final _id_touchscreen =
      jniAccessors.getFieldIDOf(_classRef, "touchscreen", "I");

  /// from: public int touchscreen
  ///
  /// The kind of touch screen attached to the device.
  /// One of: \#TOUCHSCREEN_NOTOUCH, \#TOUCHSCREEN_FINGER.
  int get touchscreen => jniAccessors
      .getField(reference, _id_touchscreen, jni.JniType.intType)
      .integer;

  /// from: public int touchscreen
  ///
  /// The kind of touch screen attached to the device.
  /// One of: \#TOUCHSCREEN_NOTOUCH, \#TOUCHSCREEN_FINGER.
  set touchscreen(int value) =>
      jniEnv.SetIntField(reference, _id_touchscreen, value);

  static final _id_uiMode = jniAccessors.getFieldIDOf(_classRef, "uiMode", "I");

  /// from: public int uiMode
  ///
  /// Bit mask of the ui mode.  Currently there are two fields:
  /// The \#UI_MODE_TYPE_MASK bits define the overall ui mode of the
  /// device. They may be one of \#UI_MODE_TYPE_UNDEFINED,
  /// \#UI_MODE_TYPE_NORMAL, \#UI_MODE_TYPE_DESK,
  /// \#UI_MODE_TYPE_CAR, \#UI_MODE_TYPE_TELEVISION,
  /// \#UI_MODE_TYPE_APPLIANCE, \#UI_MODE_TYPE_WATCH,
  /// or \#UI_MODE_TYPE_VR_HEADSET.
  ///
  /// The \#UI_MODE_NIGHT_MASK defines whether the screen
  /// is in a special mode. They may be one of \#UI_MODE_NIGHT_UNDEFINED,
  /// \#UI_MODE_NIGHT_NO or \#UI_MODE_NIGHT_YES.
  int get uiMode =>
      jniAccessors.getField(reference, _id_uiMode, jni.JniType.intType).integer;

  /// from: public int uiMode
  ///
  /// Bit mask of the ui mode.  Currently there are two fields:
  /// The \#UI_MODE_TYPE_MASK bits define the overall ui mode of the
  /// device. They may be one of \#UI_MODE_TYPE_UNDEFINED,
  /// \#UI_MODE_TYPE_NORMAL, \#UI_MODE_TYPE_DESK,
  /// \#UI_MODE_TYPE_CAR, \#UI_MODE_TYPE_TELEVISION,
  /// \#UI_MODE_TYPE_APPLIANCE, \#UI_MODE_TYPE_WATCH,
  /// or \#UI_MODE_TYPE_VR_HEADSET.
  ///
  /// The \#UI_MODE_NIGHT_MASK defines whether the screen
  /// is in a special mode. They may be one of \#UI_MODE_NIGHT_UNDEFINED,
  /// \#UI_MODE_NIGHT_NO or \#UI_MODE_NIGHT_YES.
  set uiMode(int value) => jniEnv.SetIntField(reference, _id_uiMode, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct an invalid Configuration. This state is only suitable for constructing a
  /// Configuration delta that will be applied to some valid Configuration object. In order to
  /// create a valid standalone Configuration, you must call \#setToDefaults.
  ///
  ///
  /// Example:
  ///
  /// <pre class="prettyprint">
  ///     Configuration validConfig = new Configuration();
  ///     validConfig.setToDefaults();
  ///
  ///     Configuration deltaOnlyConfig = new Configuration();
  ///     deltaOnlyConfig.orientation = Configuration.ORIENTATION_LANDSCAPE;
  ///
  ///     validConfig.updateFrom(deltaOnlyConfig);
  /// </pre>
  Configuration()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/res/Configuration;)V");

  /// from: public void <init>(android.content.res.Configuration o)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Makes a deep copy suitable for modification.
  Configuration.ctor1(Configuration o)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [o.reference]).object);

  static final _id_isLayoutSizeAtLeast =
      jniAccessors.getMethodIDOf(_classRef, "isLayoutSizeAtLeast", "(I)Z");

  /// from: public boolean isLayoutSizeAtLeast(int size)
  ///
  /// Check if the Configuration's current \#screenLayout is at
  /// least the given size.
  ///@param size The desired size, either \#SCREENLAYOUT_SIZE_SMALL,
  /// \#SCREENLAYOUT_SIZE_NORMAL, \#SCREENLAYOUT_SIZE_LARGE, or
  /// \#SCREENLAYOUT_SIZE_XLARGE.
  ///@return Returns true if the current screen layout size is at least
  /// the given size.
  bool isLayoutSizeAtLeast(int size) => jniAccessors.callMethodWithArgs(
      reference,
      _id_isLayoutSizeAtLeast,
      jni.JniType.booleanType,
      [size]).boolean;

  static final _id_setTo = jniAccessors.getMethodIDOf(
      _classRef, "setTo", "(Landroid/content/res/Configuration;)V");

  /// from: public void setTo(android.content.res.Configuration o)
  ///
  /// Sets the fields in this object to those in the given Configuration.
  ///@param o The Configuration object used to set the values of this Configuration's fields.
  void setTo(Configuration o) => jniAccessors.callMethodWithArgs(
      reference, _id_setTo, jni.JniType.voidType, [o.reference]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_setToDefaults =
      jniAccessors.getMethodIDOf(_classRef, "setToDefaults", "()V");

  /// from: public void setToDefaults()
  ///
  /// Set this object to the system defaults.
  void setToDefaults() => jniAccessors.callMethodWithArgs(
      reference, _id_setToDefaults, jni.JniType.voidType, []).check();

  static final _id_updateFrom = jniAccessors.getMethodIDOf(
      _classRef, "updateFrom", "(Landroid/content/res/Configuration;)I");

  /// from: public int updateFrom(android.content.res.Configuration delta)
  ///
  /// Copies the fields from delta into this Configuration object, keeping
  /// track of which ones have changed. Any undefined fields in {@code delta}
  /// are ignored and not copied in to the current Configuration.
  ///@param delta This value must never be {@code null}.
  ///@return a bit mask of the changed fields, as per \#diff
  ///
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  int updateFrom(Configuration delta) => jniAccessors.callMethodWithArgs(
      reference,
      _id_updateFrom,
      jni.JniType.intType,
      [delta.reference]).integer;

  static final _id_diff = jniAccessors.getMethodIDOf(
      _classRef, "diff", "(Landroid/content/res/Configuration;)I");

  /// from: public int diff(android.content.res.Configuration delta)
  ///
  /// Return a bit mask of the differences between this Configuration
  /// object and the given one.  Does not change the values of either.  Any
  /// undefined fields in <var>delta</var> are ignored.
  ///@return Returns a bit mask indicating which configuration
  /// values has changed, containing any combination of
  /// android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE PackageManager.ActivityInfo.CONFIG_FONT_SCALE,
  /// android.content.pm.ActivityInfo\#CONFIG_MCC PackageManager.ActivityInfo.CONFIG_MCC,
  /// android.content.pm.ActivityInfo\#CONFIG_MNC PackageManager.ActivityInfo.CONFIG_MNC,
  /// android.content.pm.ActivityInfo\#CONFIG_LOCALE PackageManager.ActivityInfo.CONFIG_LOCALE,
  /// android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN,
  /// android.content.pm.ActivityInfo\#CONFIG_KEYBOARD PackageManager.ActivityInfo.CONFIG_KEYBOARD,
  /// android.content.pm.ActivityInfo\#CONFIG_NAVIGATION PackageManager.ActivityInfo.CONFIG_NAVIGATION,
  /// android.content.pm.ActivityInfo\#CONFIG_ORIENTATION PackageManager.ActivityInfo.CONFIG_ORIENTATION,
  /// android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT, or
  /// android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE PackageManager.ActivityInfo.CONFIG_SCREEN_SIZE, or
  /// android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE PackageManager.ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE.
  /// android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION PackageManager.ActivityInfo.CONFIG_LAYOUT_DIRECTION.
  int diff(Configuration delta) => jniAccessors.callMethodWithArgs(
      reference, _id_diff, jni.JniType.intType, [delta.reference]).integer;

  static final _id_needNewResources =
      jniAccessors.getStaticMethodIDOf(_classRef, "needNewResources", "(II)Z");

  /// from: static public boolean needNewResources(int configChanges, int interestingChanges)
  ///
  /// Determines if a new resource needs to be loaded from the bit set of
  /// configuration changes returned by \#updateFrom(Configuration).
  ///@param configChanges the mask of changes configurations as returned by
  ///                      \#updateFrom(Configuration)
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@param interestingChanges the configuration changes that the resource
  ///                           can handle as given in
  ///                           android.util.TypedValue\#changingConfigurations
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@return {@code true} if the resource needs to be loaded, {@code false}
  ///         otherwise
  static bool needNewResources(int configChanges, int interestingChanges) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_needNewResources,
          jni.JniType.booleanType, [configChanges, interestingChanges]).boolean;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  ///
  /// Parcelable methods
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_readFromParcel = jniAccessors.getMethodIDOf(
      _classRef, "readFromParcel", "(Landroid/os/Parcel;)V");

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(parcel_.Parcel source) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readFromParcel,
      jni.JniType.voidType,
      [source.reference]).check();

  static final _id_compareTo = jniAccessors.getMethodIDOf(
      _classRef, "compareTo", "(Landroid/content/res/Configuration;)I");

  /// from: public int compareTo(android.content.res.Configuration that)
  int compareTo(Configuration that) => jniAccessors.callMethodWithArgs(
      reference, _id_compareTo, jni.JniType.intType, [that.reference]).integer;

  static final _id_equals1 = jniAccessors.getMethodIDOf(
      _classRef, "equals", "(Landroid/content/res/Configuration;)Z");

  /// from: public boolean equals(android.content.res.Configuration that)
  bool equals1(Configuration that) => jniAccessors.callMethodWithArgs(reference,
      _id_equals1, jni.JniType.booleanType, [that.reference]).boolean;

  static final _id_equals2 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object that)
  bool equals2(jni.JniObject that) => jniAccessors.callMethodWithArgs(reference,
      _id_equals2, jni.JniType.booleanType, [that.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_getLocales = jniAccessors.getMethodIDOf(
      _classRef, "getLocales", "()Landroid/os/LocaleList;");

  /// from: public android.os.LocaleList getLocales()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the locale list. This is the preferred way for getting the locales (instead of using
  /// the direct accessor to \#locale, which would only provide the primary locale).
  ///@return The locale list.
  ///
  /// This value will never be {@code null}.
  localelist_.LocaleList getLocales() =>
      localelist_.LocaleList.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLocales, jni.JniType.objectType, []).object);

  static final _id_setLocales = jniAccessors.getMethodIDOf(
      _classRef, "setLocales", "(Landroid/os/LocaleList;)V");

  /// from: public void setLocales(android.os.LocaleList locales)
  ///
  /// Set the locale list. This is the preferred way for setting up the locales (instead of using
  /// the direct accessor or \#setLocale(Locale)). This will also set the layout direction
  /// according to the first locale in the list.
  ///
  /// Note that the layout direction will always come from the first locale in the locale list,
  /// even if the locale is not supported by the resources (the resources may only support
  /// another locale further down the list which has a different direction).
  ///@param locales The locale list. If null, an empty LocaleList will be assigned.
  ///
  /// This value may be {@code null}.
  void setLocales(localelist_.LocaleList locales) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLocales,
          jni.JniType.voidType, [locales.reference]).check();

  static final _id_setLocale = jniAccessors.getMethodIDOf(
      _classRef, "setLocale", "(Ljava/util/Locale;)V");

  /// from: public void setLocale(java.util.Locale loc)
  ///
  /// Set the locale list to a list of just one locale. This will also set the layout direction
  /// according to the locale.
  ///
  /// Note that after this is run, calling <code>.equals()</code> on the input locale and the
  /// \#locale attribute would return <code>true</code> if they are not null, but there is
  /// no guarantee that they would be the same object.
  ///
  /// See also the note about layout direction in \#setLocales(LocaleList).
  ///@param loc The locale. Can be null.
  ///
  /// This value may be {@code null}.
  void setLocale(jni.JniObject loc) => jniAccessors.callMethodWithArgs(
      reference, _id_setLocale, jni.JniType.voidType, [loc.reference]).check();

  static final _id_getLayoutDirection =
      jniAccessors.getMethodIDOf(_classRef, "getLayoutDirection", "()I");

  /// from: public int getLayoutDirection()
  ///
  /// Return the layout direction. Will be either View\#LAYOUT_DIRECTION_LTR or
  /// View\#LAYOUT_DIRECTION_RTL.
  ///@return Returns View\#LAYOUT_DIRECTION_RTL if the configuration
  /// is \#SCREENLAYOUT_LAYOUTDIR_RTL, otherwise View\#LAYOUT_DIRECTION_LTR.
  int getLayoutDirection() => jniAccessors.callMethodWithArgs(
      reference, _id_getLayoutDirection, jni.JniType.intType, []).integer;

  static final _id_setLayoutDirection = jniAccessors.getMethodIDOf(
      _classRef, "setLayoutDirection", "(Ljava/util/Locale;)V");

  /// from: public void setLayoutDirection(java.util.Locale loc)
  ///
  /// Set the layout direction from a Locale.
  ///@param loc The Locale. If null will set the layout direction to
  /// View\#LAYOUT_DIRECTION_LTR. If not null will set it to the layout direction
  /// corresponding to the Locale.
  ///@see View\#LAYOUT_DIRECTION_LTR
  ///@see View\#LAYOUT_DIRECTION_RTL
  void setLayoutDirection(jni.JniObject loc) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLayoutDirection,
      jni.JniType.voidType,
      [loc.reference]).check();

  static final _id_isScreenRound =
      jniAccessors.getMethodIDOf(_classRef, "isScreenRound", "()Z");

  /// from: public boolean isScreenRound()
  ///
  /// Return whether the screen has a round shape. Apps may choose to change styling based
  /// on this property, such as the alignment or layout of text or informational icons.
  ///@return true if the screen is rounded, false otherwise
  bool isScreenRound() => jniAccessors.callMethodWithArgs(
      reference, _id_isScreenRound, jni.JniType.booleanType, []).boolean;

  static final _id_isScreenWideColorGamut =
      jniAccessors.getMethodIDOf(_classRef, "isScreenWideColorGamut", "()Z");

  /// from: public boolean isScreenWideColorGamut()
  ///
  /// Return whether the screen has a wide color gamut and wide color gamut rendering
  /// is supported by this device.
  ///
  /// When true, it implies the screen is colorspace aware but not
  /// necessarily color-managed. The final colors may still be changed by the
  /// screen depending on user settings.
  ///@return true if the screen has a wide color gamut and wide color gamut rendering
  /// is supported, false otherwise
  bool isScreenWideColorGamut() => jniAccessors.callMethodWithArgs(reference,
      _id_isScreenWideColorGamut, jni.JniType.booleanType, []).boolean;

  static final _id_isScreenHdr =
      jniAccessors.getMethodIDOf(_classRef, "isScreenHdr", "()Z");

  /// from: public boolean isScreenHdr()
  ///
  /// Return whether the screen has a high dynamic range.
  ///@return true if the screen has a high dynamic range, false otherwise
  bool isScreenHdr() => jniAccessors.callMethodWithArgs(
      reference, _id_isScreenHdr, jni.JniType.booleanType, []).boolean;
}
