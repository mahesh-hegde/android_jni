// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "AsyncTaskLoader.dart" as asynctaskloader_;

import "Context.dart" as context_;

import "../net/Uri.dart" as uri_;

import "../database/Cursor.dart" as cursor_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.CursorLoader
///
/// A loader that queries the ContentResolver and returns a Cursor.
/// This class implements the Loader protocol in a standard way for
/// querying cursors, building on AsyncTaskLoader to perform the cursor
/// query on a background thread so that it does not block the application's UI.
///
/// A CursorLoader must be built with the full information for the query to
/// perform, either through the
/// \#CursorLoader(Context, Uri, String[], String, String[], String) or
/// creating an empty instance with \#CursorLoader(Context) and filling
/// in the desired paramters with \#setUri(Uri), \#setSelection(String),
/// \#setSelectionArgs(String[]), \#setSortOrder(String),
/// and \#setProjection(String[]).
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.content.CursorLoader
class CursorLoader extends asynctaskloader_.AsyncTaskLoader {
  static final _classRef =
      jniAccessors.getClassOf("android/content/CursorLoader");
  CursorLoader.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an empty unspecified CursorLoader.  You must follow this with
  /// calls to \#setUri(Uri), \#setSelection(String), etc
  /// to specify the query to perform.
  CursorLoader(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void <init>(android.content.Context context, android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a fully-specified CursorLoader.  See
  /// ContentResolver\#query(Uri, String[], String, String[], String) ContentResolver.query() for documentation on the meaning of the
  /// parameters.  These will be passed as-is to that call.
  CursorLoader.ctor1(
      context_.Context context,
      uri_.Uri uri,
      jni.JniObject projection,
      jni.JniString selection,
      jni.JniObject selectionArgs,
      jni.JniString sortOrder)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1, [
          context.reference,
          uri.reference,
          projection.reference,
          selection.reference,
          selectionArgs.reference,
          sortOrder.reference
        ]).object);

  static final _id_loadInBackground1 = jniAccessors.getMethodIDOf(
      _classRef, "loadInBackground", "()Landroid/database/Cursor;");

  /// from: public android.database.Cursor loadInBackground()
  /// The returned object must be deleted after use, by calling the `delete` method.
  cursor_.Cursor loadInBackground1() =>
      cursor_.Cursor.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_loadInBackground1, jni.JniType.objectType, []).object);

  static final _id_cancelLoadInBackground =
      jniAccessors.getMethodIDOf(_classRef, "cancelLoadInBackground", "()V");

  /// from: public void cancelLoadInBackground()
  void cancelLoadInBackground() => jniAccessors.callMethodWithArgs(
      reference, _id_cancelLoadInBackground, jni.JniType.voidType, []).check();

  static final _id_deliverResult1 = jniAccessors.getMethodIDOf(
      _classRef, "deliverResult", "(Landroid/database/Cursor;)V");

  /// from: public void deliverResult(android.database.Cursor cursor)
  void deliverResult1(cursor_.Cursor cursor) => jniAccessors.callMethodWithArgs(
      reference,
      _id_deliverResult1,
      jni.JniType.voidType,
      [cursor.reference]).check();

  static final _id_onStartLoading1 =
      jniAccessors.getMethodIDOf(_classRef, "onStartLoading", "()V");

  /// from: protected void onStartLoading()
  ///
  /// Starts an asynchronous load of the data. When the result is ready the callbacks
  /// will be called on the UI thread. If a previous load has been completed and is still valid
  /// the result may be passed to the callbacks immediately.
  ///
  /// Must be called from the UI thread
  void onStartLoading1() => jniAccessors.callMethodWithArgs(
      reference, _id_onStartLoading1, jni.JniType.voidType, []).check();

  static final _id_onStopLoading1 =
      jniAccessors.getMethodIDOf(_classRef, "onStopLoading", "()V");

  /// from: protected void onStopLoading()
  ///
  /// Must be called from the UI thread
  void onStopLoading1() => jniAccessors.callMethodWithArgs(
      reference, _id_onStopLoading1, jni.JniType.voidType, []).check();

  static final _id_onCanceled1 = jniAccessors.getMethodIDOf(
      _classRef, "onCanceled", "(Landroid/database/Cursor;)V");

  /// from: public void onCanceled(android.database.Cursor cursor)
  void onCanceled1(cursor_.Cursor cursor) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onCanceled1,
      jni.JniType.voidType,
      [cursor.reference]).check();

  static final _id_onReset1 =
      jniAccessors.getMethodIDOf(_classRef, "onReset", "()V");

  /// from: protected void onReset()
  void onReset1() => jniAccessors.callMethodWithArgs(
      reference, _id_onReset1, jni.JniType.voidType, []).check();

  static final _id_getUri =
      jniAccessors.getMethodIDOf(_classRef, "getUri", "()Landroid/net/Uri;");

  /// from: public android.net.Uri getUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  uri_.Uri getUri() => uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getUri, jni.JniType.objectType, []).object);

  static final _id_setUri =
      jniAccessors.getMethodIDOf(_classRef, "setUri", "(Landroid/net/Uri;)V");

  /// from: public void setUri(android.net.Uri uri)
  void setUri(uri_.Uri uri) => jniAccessors.callMethodWithArgs(
      reference, _id_setUri, jni.JniType.voidType, [uri.reference]).check();

  static final _id_getProjection = jniAccessors.getMethodIDOf(
      _classRef, "getProjection", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getProjection()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getProjection() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getProjection, jni.JniType.objectType, []).object);

  static final _id_setProjection = jniAccessors.getMethodIDOf(
      _classRef, "setProjection", "([Ljava/lang/String;)V");

  /// from: public void setProjection(java.lang.String[] projection)
  void setProjection(jni.JniObject projection) =>
      jniAccessors.callMethodWithArgs(reference, _id_setProjection,
          jni.JniType.voidType, [projection.reference]).check();

  static final _id_getSelection = jniAccessors.getMethodIDOf(
      _classRef, "getSelection", "()Ljava/lang/String;");

  /// from: public java.lang.String getSelection()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getSelection() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSelection, jni.JniType.objectType, []).object);

  static final _id_setSelection = jniAccessors.getMethodIDOf(
      _classRef, "setSelection", "(Ljava/lang/String;)V");

  /// from: public void setSelection(java.lang.String selection)
  void setSelection(jni.JniString selection) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSelection,
      jni.JniType.voidType,
      [selection.reference]).check();

  static final _id_getSelectionArgs = jniAccessors.getMethodIDOf(
      _classRef, "getSelectionArgs", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getSelectionArgs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getSelectionArgs() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSelectionArgs, jni.JniType.objectType, []).object);

  static final _id_setSelectionArgs = jniAccessors.getMethodIDOf(
      _classRef, "setSelectionArgs", "([Ljava/lang/String;)V");

  /// from: public void setSelectionArgs(java.lang.String[] selectionArgs)
  void setSelectionArgs(jni.JniObject selectionArgs) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSelectionArgs,
          jni.JniType.voidType, [selectionArgs.reference]).check();

  static final _id_getSortOrder = jniAccessors.getMethodIDOf(
      _classRef, "getSortOrder", "()Ljava/lang/String;");

  /// from: public java.lang.String getSortOrder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getSortOrder() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSortOrder, jni.JniType.objectType, []).object);

  static final _id_setSortOrder = jniAccessors.getMethodIDOf(
      _classRef, "setSortOrder", "(Ljava/lang/String;)V");

  /// from: public void setSortOrder(java.lang.String sortOrder)
  void setSortOrder(jni.JniString sortOrder) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSortOrder,
      jni.JniType.voidType,
      [sortOrder.reference]).check();

  static final _id_dump = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/lang/String;Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: public void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_dump, jni.JniType.voidType, [
        prefix.reference,
        fd.reference,
        writer.reference,
        args.reference
      ]).check();
}
