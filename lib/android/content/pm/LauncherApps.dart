// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/UserHandle.dart" as userhandle_;

import "LauncherActivityInfo.dart" as launcheractivityinfo_;

import "../Intent.dart" as intent_;

import "../ComponentName.dart" as componentname_;

import "../../graphics/Rect.dart" as rect_;

import "../../os/Bundle.dart" as bundle_;

import "../IntentSender.dart" as intentsender_;

import "ApplicationInfo.dart" as applicationinfo_;

import "../../graphics/drawable/Drawable.dart" as drawable_;

import "ShortcutInfo.dart" as shortcutinfo_;

import "../../os/Handler.dart" as handler_;

import "../../os/Parcelable.dart" as parcelable_;

import "../../appwidget/AppWidgetProviderInfo.dart" as appwidgetproviderinfo_;

import "../Context.dart" as context_;

import "../../os/Parcel.dart" as parcel_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.pm.LauncherApps
///
/// Class for retrieving a list of launchable activities for the current user and any associated
/// managed profiles that are visible to the current user, which can be retrieved with
/// \#getProfiles. This is mainly for use by launchers.
///
/// Apps can be queried for each user profile.
/// Since the PackageManager will not deliver package broadcasts for other profiles, you can register
/// for package changes here.
///
/// To watch for managed profiles being added or removed, register for the following broadcasts:
/// Intent\#ACTION_MANAGED_PROFILE_ADDED and Intent\#ACTION_MANAGED_PROFILE_REMOVED.
///
/// Note as of Android O, apps on a managed profile are no longer allowed to access apps on the
/// main profile.  Apps can only access profiles returned by \#getProfiles().
class LauncherApps extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/pm/LauncherApps");
  LauncherApps.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_CONFIRM_PIN_APPWIDGET
  ///
  /// Activity Action: For the default launcher to show the confirmation dialog to create
  /// a pinned app widget.
  ///
  /// See the android.appwidget.AppWidgetManager\#requestPinAppWidget javadoc for
  /// details.
  ///
  ///
  /// Use \#getPinItemRequest(Intent) to get a PinItemRequest object,
  /// and call PinItemRequest\#accept(Bundle)
  /// if the user accepts.  If the user doesn't accept, no further action is required.
  ///@see \#EXTRA_PIN_ITEM_REQUEST
  static const ACTION_CONFIRM_PIN_APPWIDGET =
      "android.content.pm.action.CONFIRM_PIN_APPWIDGET";

  /// from: static public final java.lang.String ACTION_CONFIRM_PIN_SHORTCUT
  ///
  /// Activity Action: For the default launcher to show the confirmation dialog to create
  /// a pinned shortcut.
  ///
  /// See the ShortcutManager javadoc for details.
  ///
  ///
  /// Use \#getPinItemRequest(Intent) to get a PinItemRequest object,
  /// and call PinItemRequest\#accept(Bundle)
  /// if the user accepts.  If the user doesn't accept, no further action is required.
  ///@see \#EXTRA_PIN_ITEM_REQUEST
  static const ACTION_CONFIRM_PIN_SHORTCUT =
      "android.content.pm.action.CONFIRM_PIN_SHORTCUT";

  /// from: static public final java.lang.String EXTRA_PIN_ITEM_REQUEST
  ///
  /// An extra for \#ACTION_CONFIRM_PIN_SHORTCUT &amp; \#ACTION_CONFIRM_PIN_APPWIDGET
  /// containing a PinItemRequest of appropriate type asked to pin.
  ///
  /// A helper function \#getPinItemRequest(Intent) can be used
  /// instead of using this constant directly.
  ///@see \#ACTION_CONFIRM_PIN_SHORTCUT
  ///@see \#ACTION_CONFIRM_PIN_APPWIDGET
  static const EXTRA_PIN_ITEM_REQUEST =
      "android.content.pm.extra.PIN_ITEM_REQUEST";

  static final _id_getProfiles = jniAccessors.getMethodIDOf(
      _classRef, "getProfiles", "()Ljava/util/List;");

  /// from: public java.util.List<android.os.UserHandle> getProfiles()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a list of profiles that the caller can access via the LauncherApps APIs.
  ///
  /// If the caller is running on a managed profile, it'll return only the current profile.
  /// Otherwise it'll return the same list as UserManager\#getUserProfiles() would.
  jni.JniObject getProfiles() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getProfiles, jni.JniType.objectType, []).object);

  static final _id_getActivityList = jniAccessors.getMethodIDOf(
      _classRef,
      "getActivityList",
      "(Ljava/lang/String;Landroid/os/UserHandle;)Ljava/util/List;");

  /// from: public java.util.List<android.content.pm.LauncherActivityInfo> getActivityList(java.lang.String packageName, android.os.UserHandle user)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves a list of launchable activities that match Intent\#ACTION_MAIN and
  /// Intent\#CATEGORY_LAUNCHER, for a specified user.
  ///@param packageName The specific package to query. If null, it checks all installed packages
  ///            in the profile.
  ///@param user The UserHandle of the profile.
  ///@return List of launchable activities. Can be an empty list but will not be null.
  jni.JniObject getActivityList(
          jni.JniString packageName, userhandle_.UserHandle user) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getActivityList,
          jni.JniType.objectType,
          [packageName.reference, user.reference]).object);

  static final _id_resolveActivity = jniAccessors.getMethodIDOf(
      _classRef,
      "resolveActivity",
      "(Landroid/content/Intent;Landroid/os/UserHandle;)Landroid/content/pm/LauncherActivityInfo;");

  /// from: public android.content.pm.LauncherActivityInfo resolveActivity(android.content.Intent intent, android.os.UserHandle user)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the activity info for a given intent and user handle, if it resolves. Otherwise it
  /// returns null.
  ///@param intent The intent to find a match for.
  ///@param user The profile to look in for a match.
  ///@return An activity info object if there is a match.
  launcheractivityinfo_.LauncherActivityInfo resolveActivity(
          intent_.Intent intent, userhandle_.UserHandle user) =>
      launcheractivityinfo_.LauncherActivityInfo.fromRef(jniAccessors
          .callMethodWithArgs(
              reference,
              _id_resolveActivity,
              jni.JniType.objectType,
              [intent.reference, user.reference]).object);

  static final _id_startMainActivity = jniAccessors.getMethodIDOf(
      _classRef,
      "startMainActivity",
      "(Landroid/content/ComponentName;Landroid/os/UserHandle;Landroid/graphics/Rect;Landroid/os/Bundle;)V");

  /// from: public void startMainActivity(android.content.ComponentName component, android.os.UserHandle user, android.graphics.Rect sourceBounds, android.os.Bundle opts)
  ///
  /// Starts a Main activity in the specified profile.
  ///@param component The ComponentName of the activity to launch
  ///@param user The UserHandle of the profile
  ///@param sourceBounds The Rect containing the source bounds of the clicked icon
  ///@param opts Options to pass to startActivity
  void startMainActivity(
          componentname_.ComponentName component,
          userhandle_.UserHandle user,
          rect_.Rect sourceBounds,
          bundle_.Bundle opts) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startMainActivity, jni.JniType.voidType, [
        component.reference,
        user.reference,
        sourceBounds.reference,
        opts.reference
      ]).check();

  static final _id_startAppDetailsActivity = jniAccessors.getMethodIDOf(
      _classRef,
      "startAppDetailsActivity",
      "(Landroid/content/ComponentName;Landroid/os/UserHandle;Landroid/graphics/Rect;Landroid/os/Bundle;)V");

  /// from: public void startAppDetailsActivity(android.content.ComponentName component, android.os.UserHandle user, android.graphics.Rect sourceBounds, android.os.Bundle opts)
  ///
  /// Starts the settings activity to show the application details for a
  /// package in the specified profile.
  ///@param component The ComponentName of the package to launch settings for.
  ///@param user The UserHandle of the profile
  ///@param sourceBounds The Rect containing the source bounds of the clicked icon
  ///@param opts Options to pass to startActivity
  void startAppDetailsActivity(
          componentname_.ComponentName component,
          userhandle_.UserHandle user,
          rect_.Rect sourceBounds,
          bundle_.Bundle opts) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startAppDetailsActivity, jni.JniType.voidType, [
        component.reference,
        user.reference,
        sourceBounds.reference,
        opts.reference
      ]).check();

  static final _id_getShortcutConfigActivityList = jniAccessors.getMethodIDOf(
      _classRef,
      "getShortcutConfigActivityList",
      "(Ljava/lang/String;Landroid/os/UserHandle;)Ljava/util/List;");

  /// from: public java.util.List<android.content.pm.LauncherActivityInfo> getShortcutConfigActivityList(java.lang.String packageName, android.os.UserHandle user)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves a list of config activities for creating ShortcutInfo.
  ///@param packageName The specific package to query. If null, it checks all installed packages
  ///            in the profile.
  /// This value may be {@code null}.
  ///@param user The UserHandle of the profile.
  /// This value must never be {@code null}.
  ///@return List of config activities. Can be an empty list but will not be null.
  ///@see Intent\#ACTION_CREATE_SHORTCUT
  ///@see \#getShortcutConfigActivityIntent(LauncherActivityInfo)
  jni.JniObject getShortcutConfigActivityList(
          jni.JniString packageName, userhandle_.UserHandle user) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getShortcutConfigActivityList,
          jni.JniType.objectType,
          [packageName.reference, user.reference]).object);

  static final _id_getShortcutConfigActivityIntent = jniAccessors.getMethodIDOf(
      _classRef,
      "getShortcutConfigActivityIntent",
      "(Landroid/content/pm/LauncherActivityInfo;)Landroid/content/IntentSender;");

  /// from: public android.content.IntentSender getShortcutConfigActivityIntent(android.content.pm.LauncherActivityInfo info)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an intent sender which can be used to start the configure activity for creating
  /// custom shortcuts. Use this method if the provider is in another profile as you are not
  /// allowed to start an activity in another profile.
  ///
  /// The caller should receive PinItemRequest in onActivityResult on
  /// android.app.Activity\#RESULT_OK.
  ///
  /// Callers must be allowed to access the shortcut information, as defined in \#hasShortcutHostPermission().
  ///@param info a configuration activity returned by \#getShortcutConfigActivityList
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalStateException when the user is locked or not running.
  ///@throws SecurityException if \#hasShortcutHostPermission() is false.
  ///@see \#getPinItemRequest(Intent)
  ///@see Intent\#ACTION_CREATE_SHORTCUT
  ///@see android.app.Activity\#startIntentSenderForResult
  ///@return This value may be {@code null}.
  intentsender_.IntentSender getShortcutConfigActivityIntent(
          launcheractivityinfo_.LauncherActivityInfo info) =>
      intentsender_.IntentSender.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getShortcutConfigActivityIntent,
          jni.JniType.objectType,
          [info.reference]).object);

  static final _id_isPackageEnabled = jniAccessors.getMethodIDOf(_classRef,
      "isPackageEnabled", "(Ljava/lang/String;Landroid/os/UserHandle;)Z");

  /// from: public boolean isPackageEnabled(java.lang.String packageName, android.os.UserHandle user)
  ///
  /// Checks if the package is installed and enabled for a profile.
  ///@param packageName The package to check.
  ///@param user The UserHandle of the profile.
  ///@return true if the package exists and is enabled.
  bool isPackageEnabled(
          jni.JniString packageName, userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isPackageEnabled,
          jni.JniType.booleanType,
          [packageName.reference, user.reference]).boolean;

  static final _id_getSuspendedPackageLauncherExtras =
      jniAccessors.getMethodIDOf(_classRef, "getSuspendedPackageLauncherExtras",
          "(Ljava/lang/String;Landroid/os/UserHandle;)Landroid/os/Bundle;");

  /// from: public android.os.Bundle getSuspendedPackageLauncherExtras(java.lang.String packageName, android.os.UserHandle user)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the launcher extras supplied to the system when the given package was suspended via
  /// {@code PackageManager\#setPackagesSuspended(String[], boolean, PersistableBundle,
  /// PersistableBundle, String)}.
  ///
  /// The contents of this Bundle are supposed to be a contract between the suspending
  /// app and the launcher.
  ///
  /// Note: This just returns whatever extras were provided to the system, _which might
  /// even be {@code null}._
  ///@param packageName The package for which to fetch the launcher extras.
  ///@param user The UserHandle of the profile.
  ///@return A Bundle of launcher extras. Or {@code null} if the package is not currently
  ///         suspended.
  ///@see Callback\#onPackagesSuspended(String[], UserHandle, Bundle)
  ///@see PackageManager\#isPackageSuspended()
  bundle_.Bundle getSuspendedPackageLauncherExtras(
          jni.JniString packageName, userhandle_.UserHandle user) =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSuspendedPackageLauncherExtras,
          jni.JniType.objectType,
          [packageName.reference, user.reference]).object);

  static final _id_getApplicationInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getApplicationInfo",
      "(Ljava/lang/String;ILandroid/os/UserHandle;)Landroid/content/pm/ApplicationInfo;");

  /// from: public android.content.pm.ApplicationInfo getApplicationInfo(java.lang.String packageName, int flags, android.os.UserHandle user)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns ApplicationInfo about an application installed for a specific user profile.
  ///@param packageName The package name of the application
  /// This value must never be {@code null}.
  ///@param flags Additional option flags PackageManager\#getApplicationInfo
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@param user The UserHandle of the profile.
  ///
  /// This value must never be {@code null}.
  ///@return ApplicationInfo containing information about the package. Returns
  ///         {@code null} if the package isn't installed for the given profile, or the profile
  ///         isn't enabled.
  applicationinfo_.ApplicationInfo getApplicationInfo(
          jni.JniString packageName, int flags, userhandle_.UserHandle user) =>
      applicationinfo_.ApplicationInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getApplicationInfo,
          jni.JniType.objectType,
          [packageName.reference, flags, user.reference]).object);

  static final _id_isActivityEnabled = jniAccessors.getMethodIDOf(
      _classRef,
      "isActivityEnabled",
      "(Landroid/content/ComponentName;Landroid/os/UserHandle;)Z");

  /// from: public boolean isActivityEnabled(android.content.ComponentName component, android.os.UserHandle user)
  ///
  /// Checks if the activity exists and it enabled for a profile.
  ///@param component The activity to check.
  ///@param user The UserHandle of the profile.
  ///@return true if the activity exists and is enabled.
  bool isActivityEnabled(componentname_.ComponentName component,
          userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isActivityEnabled,
          jni.JniType.booleanType,
          [component.reference, user.reference]).boolean;

  static final _id_hasShortcutHostPermission =
      jniAccessors.getMethodIDOf(_classRef, "hasShortcutHostPermission", "()Z");

  /// from: public boolean hasShortcutHostPermission()
  ///
  /// Returns whether the caller can access the shortcut information.  Access is currently
  /// available to:
  ///
  /// <ul>
  ///     <li>The current launcher (or default launcher if there is no set current launcher).</li>
  ///     <li>The currently active voice interaction service.</li>
  /// </ul>
  ///
  /// Note when this method returns {@code false}, it may be a temporary situation because
  /// the user is trying a new launcher application.  The user may decide to change the default
  /// launcher back to the calling application again, so even if a launcher application loses
  /// this permission, it does __not__ have to purge pinned shortcut information.
  /// If the calling launcher application contains pinned shortcuts, they will still work,
  /// even though the caller no longer has the shortcut host permission.
  ///@throws IllegalStateException when the user is locked.
  ///@see ShortcutManager
  bool hasShortcutHostPermission() => jniAccessors.callMethodWithArgs(reference,
      _id_hasShortcutHostPermission, jni.JniType.booleanType, []).boolean;

  static final _id_getShortcuts = jniAccessors.getMethodIDOf(
      _classRef,
      "getShortcuts",
      "(Landroid/content/pm/LauncherApps\$ShortcutQuery;Landroid/os/UserHandle;)Ljava/util/List;");

  /// from: public java.util.List<android.content.pm.ShortcutInfo> getShortcuts(android.content.pm.LauncherApps.ShortcutQuery query, android.os.UserHandle user)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns ShortcutInfos that match {@code query}.
  ///
  /// Callers must be allowed to access the shortcut information, as defined in \#hasShortcutHostPermission().
  ///@param query result includes shortcuts matching this query.
  /// This value must never be {@code null}.
  ///@param user The UserHandle of the profile.
  ///
  /// This value must never be {@code null}.
  ///@return the IDs of ShortcutInfos that match the query.
  /// This value may be {@code null}.
  ///@throws IllegalStateException when the user is locked, or when the {@code user} user
  /// is locked or not running.
  ///@see ShortcutManager
  jni.JniObject getShortcuts(
          LauncherApps_ShortcutQuery query, userhandle_.UserHandle user) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getShortcuts,
          jni.JniType.objectType,
          [query.reference, user.reference]).object);

  static final _id_pinShortcuts = jniAccessors.getMethodIDOf(
      _classRef,
      "pinShortcuts",
      "(Ljava/lang/String;Ljava/util/List;Landroid/os/UserHandle;)V");

  /// from: public void pinShortcuts(java.lang.String packageName, java.util.List<java.lang.String> shortcutIds, android.os.UserHandle user)
  ///
  /// Pin shortcuts on a package.
  ///
  /// This API is __NOT__ cumulative; this will replace all pinned shortcuts for the package.
  /// However, different launchers may have different set of pinned shortcuts.
  ///
  /// The calling launcher application must be allowed to access the shortcut information,
  /// as defined in \#hasShortcutHostPermission().
  ///@param packageName The target package name.
  /// This value must never be {@code null}.
  ///@param shortcutIds The IDs of the shortcut to be pinned.
  /// This value must never be {@code null}.
  ///@param user The UserHandle of the profile.
  /// This value must never be {@code null}.
  ///@throws IllegalStateException when the user is locked, or when the {@code user} user
  /// is locked or not running.
  ///@see ShortcutManager
  void pinShortcuts(jni.JniString packageName, jni.JniObject shortcutIds,
          userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_pinShortcuts, jni.JniType.voidType, [
        packageName.reference,
        shortcutIds.reference,
        user.reference
      ]).check();

  static final _id_getShortcutIconDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "getShortcutIconDrawable",
      "(Landroid/content/pm/ShortcutInfo;I)Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getShortcutIconDrawable(android.content.pm.ShortcutInfo shortcut, int density)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the icon for this shortcut, without any badging for the profile.
  ///
  /// The calling launcher application must be allowed to access the shortcut information,
  /// as defined in \#hasShortcutHostPermission().
  ///@param density The preferred density of the icon, zero for default density. Use
  /// density DPI values from DisplayMetrics.
  ///@param shortcut This value must never be {@code null}.
  ///@return The drawable associated with the shortcut.
  ///@throws IllegalStateException when the user is locked, or when the {@code user} user
  /// is locked or not running.
  ///@see ShortcutManager
  ///@see \#getShortcutBadgedIconDrawable(ShortcutInfo, int)
  ///@see DisplayMetrics
  drawable_.Drawable getShortcutIconDrawable(
          shortcutinfo_.ShortcutInfo shortcut, int density) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getShortcutIconDrawable,
          jni.JniType.objectType,
          [shortcut.reference, density]).object);

  static final _id_getShortcutBadgedIconDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "getShortcutBadgedIconDrawable",
      "(Landroid/content/pm/ShortcutInfo;I)Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getShortcutBadgedIconDrawable(android.content.pm.ShortcutInfo shortcut, int density)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the shortcut icon with badging appropriate for the profile.
  ///
  /// The calling launcher application must be allowed to access the shortcut information,
  /// as defined in \#hasShortcutHostPermission().
  ///@param density Optional density for the icon, or 0 to use the default density. Use
  ///@return A badged icon for the shortcut.
  ///@throws IllegalStateException when the user is locked, or when the {@code user} user
  /// is locked or not running.
  ///@see ShortcutManager
  ///@see \#getShortcutIconDrawable(ShortcutInfo, int)
  ///@see DisplayMetrics
  drawable_.Drawable getShortcutBadgedIconDrawable(
          shortcutinfo_.ShortcutInfo shortcut, int density) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getShortcutBadgedIconDrawable,
          jni.JniType.objectType,
          [shortcut.reference, density]).object);

  static final _id_startShortcut = jniAccessors.getMethodIDOf(
      _classRef,
      "startShortcut",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/graphics/Rect;Landroid/os/Bundle;Landroid/os/UserHandle;)V");

  /// from: public void startShortcut(java.lang.String packageName, java.lang.String shortcutId, android.graphics.Rect sourceBounds, android.os.Bundle startActivityOptions, android.os.UserHandle user)
  ///
  /// Starts a shortcut.
  ///
  /// The calling launcher application must be allowed to access the shortcut information,
  /// as defined in \#hasShortcutHostPermission().
  ///@param packageName The target shortcut package name.
  /// This value must never be {@code null}.
  ///@param shortcutId The target shortcut ID.
  /// This value must never be {@code null}.
  ///@param sourceBounds The Rect containing the source bounds of the clicked icon.
  /// This value may be {@code null}.
  ///@param startActivityOptions Options to pass to startActivity.
  /// This value may be {@code null}.
  ///@param user The UserHandle of the profile.
  /// This value must never be {@code null}.
  ///@throws IllegalStateException when the user is locked, or when the {@code user} user
  /// is locked or not running.
  ///@throws android.content.ActivityNotFoundException failed to start shortcut. (e.g.
  /// the shortcut no longer exists, is disabled, the intent receiver activity doesn't exist, etc)
  void startShortcut(
          jni.JniString packageName,
          jni.JniString shortcutId,
          rect_.Rect sourceBounds,
          bundle_.Bundle startActivityOptions,
          userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startShortcut, jni.JniType.voidType, [
        packageName.reference,
        shortcutId.reference,
        sourceBounds.reference,
        startActivityOptions.reference,
        user.reference
      ]).check();

  static final _id_startShortcut1 = jniAccessors.getMethodIDOf(
      _classRef,
      "startShortcut",
      "(Landroid/content/pm/ShortcutInfo;Landroid/graphics/Rect;Landroid/os/Bundle;)V");

  /// from: public void startShortcut(android.content.pm.ShortcutInfo shortcut, android.graphics.Rect sourceBounds, android.os.Bundle startActivityOptions)
  ///
  /// Launches a shortcut.
  ///
  /// The calling launcher application must be allowed to access the shortcut information,
  /// as defined in \#hasShortcutHostPermission().
  ///@param shortcut The target shortcut.
  /// This value must never be {@code null}.
  ///@param sourceBounds The Rect containing the source bounds of the clicked icon.
  /// This value may be {@code null}.
  ///@param startActivityOptions Options to pass to startActivity.
  /// This value may be {@code null}.
  ///@throws IllegalStateException when the user is locked, or when the {@code user} user
  /// is locked or not running.
  ///@throws android.content.ActivityNotFoundException failed to start shortcut. (e.g.
  /// the shortcut no longer exists, is disabled, the intent receiver activity doesn't exist, etc)
  void startShortcut1(shortcutinfo_.ShortcutInfo shortcut,
          rect_.Rect sourceBounds, bundle_.Bundle startActivityOptions) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_startShortcut1, jni.JniType.voidType, [
        shortcut.reference,
        sourceBounds.reference,
        startActivityOptions.reference
      ]).check();

  static final _id_registerCallback = jniAccessors.getMethodIDOf(_classRef,
      "registerCallback", "(Landroid/content/pm/LauncherApps\$Callback;)V");

  /// from: public void registerCallback(android.content.pm.LauncherApps.Callback callback)
  ///
  /// Registers a callback for changes to packages in current and managed profiles.
  ///@param callback The callback to register.
  void registerCallback(LauncherApps_Callback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_registerCallback1 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerCallback",
      "(Landroid/content/pm/LauncherApps\$Callback;Landroid/os/Handler;)V");

  /// from: public void registerCallback(android.content.pm.LauncherApps.Callback callback, android.os.Handler handler)
  ///
  /// Registers a callback for changes to packages in current and managed profiles.
  ///@param callback The callback to register.
  ///@param handler that should be used to post callbacks on, may be null.
  void registerCallback1(
          LauncherApps_Callback callback, handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerCallback1,
          jni.JniType.voidType,
          [callback.reference, handler.reference]).check();

  static final _id_unregisterCallback = jniAccessors.getMethodIDOf(_classRef,
      "unregisterCallback", "(Landroid/content/pm/LauncherApps\$Callback;)V");

  /// from: public void unregisterCallback(android.content.pm.LauncherApps.Callback callback)
  ///
  /// Unregisters a callback that was previously registered.
  ///@param callback The callback to unregister.
  ///@see \#registerCallback(Callback)
  void unregisterCallback(LauncherApps_Callback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_getPinItemRequest = jniAccessors.getMethodIDOf(
      _classRef,
      "getPinItemRequest",
      "(Landroid/content/Intent;)Landroid/content/pm/LauncherApps\$PinItemRequest;");

  /// from: public android.content.pm.LauncherApps.PinItemRequest getPinItemRequest(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A helper method to extract a PinItemRequest set to
  /// the \#EXTRA_PIN_ITEM_REQUEST extra.
  LauncherApps_PinItemRequest getPinItemRequest(intent_.Intent intent) =>
      LauncherApps_PinItemRequest.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPinItemRequest,
          jni.JniType.objectType,
          [intent.reference]).object);
}

/// from: android.content.pm.LauncherApps$ShortcutQuery
///
/// Represents a query passed to \#getShortcuts(ShortcutQuery, UserHandle).
class LauncherApps_ShortcutQuery extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/pm/LauncherApps\$ShortcutQuery");
  LauncherApps_ShortcutQuery.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int FLAG_GET_KEY_FIELDS_ONLY
  ///
  /// Requests "key" fields only.  See ShortcutInfo\#hasKeyFieldsOnly()'s javadoc to
  /// see which fields fields "key".
  /// This allows quicker access to shortcut information in order to
  /// determine whether the caller's in-memory cache needs to be updated.
  ///
  /// Typically, launcher applications cache all or most shortcut information
  /// in memory in order to show shortcuts without a delay.
  ///
  /// When a given launcher application wants to update its cache, such as when its process
  /// restarts, it can fetch shortcut information with this flag.
  /// The application can then check ShortcutInfo\#getLastChangedTimestamp() for each
  /// shortcut, fetching a shortcut's non-key information only if that shortcut has been
  /// updated.
  ///@see ShortcutManager
  static const FLAG_GET_KEY_FIELDS_ONLY = 4;

  /// from: static public final int FLAG_MATCH_DYNAMIC
  ///
  /// Include dynamic shortcuts in the result.
  static const FLAG_MATCH_DYNAMIC = 1;

  /// from: static public final int FLAG_MATCH_MANIFEST
  ///
  /// Include manifest shortcuts in the result.
  static const FLAG_MATCH_MANIFEST = 8;

  /// from: static public final int FLAG_MATCH_PINNED
  ///
  /// Include pinned shortcuts in the result.
  ///
  /// If you are the selected assistant app, and wishes to fetch all shortcuts that the
  /// user owns on the launcher (or by other launchers, in case the user has multiple), use
  /// \#FLAG_MATCH_PINNED_BY_ANY_LAUNCHER instead.
  ///
  /// If you're a regular launcher app, there's no way to get shortcuts pinned by other
  /// launchers, and \#FLAG_MATCH_PINNED_BY_ANY_LAUNCHER will be ignored. So use this
  /// flag to get own pinned shortcuts.
  static const FLAG_MATCH_PINNED = 2;

  /// from: static public final int FLAG_MATCH_PINNED_BY_ANY_LAUNCHER
  ///
  /// Include all pinned shortcuts by any launchers, not just by the caller,
  /// in the result.
  ///
  /// The caller must be the selected assistant app to use this flag, or have the system
  /// {@code ACCESS_SHORTCUTS} permission.
  ///
  /// If you are the selected assistant app, and wishes to fetch all shortcuts that the
  /// user owns on the launcher (or by other launchers, in case the user has multiple), use
  /// \#FLAG_MATCH_PINNED_BY_ANY_LAUNCHER instead.
  ///
  /// If you're a regular launcher app (or any app that's not the selected assistant app)
  /// then this flag will be ignored.
  static const FLAG_MATCH_PINNED_BY_ANY_LAUNCHER = 1024;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  LauncherApps_ShortcutQuery()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setChangedSince = jniAccessors.getMethodIDOf(_classRef,
      "setChangedSince", "(J)Landroid/content/pm/LauncherApps\$ShortcutQuery;");

  /// from: public android.content.pm.LauncherApps.ShortcutQuery setChangedSince(long changedSince)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If non-zero, returns only shortcuts that have been added or updated
  /// since the given timestamp, expressed in milliseconds since the Epoch&mdash;see
  /// System\#currentTimeMillis().
  LauncherApps_ShortcutQuery setChangedSince(int changedSince) =>
      LauncherApps_ShortcutQuery.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setChangedSince,
          jni.JniType.objectType,
          [changedSince]).object);

  static final _id_setPackage = jniAccessors.getMethodIDOf(
      _classRef,
      "setPackage",
      "(Ljava/lang/String;)Landroid/content/pm/LauncherApps\$ShortcutQuery;");

  /// from: public android.content.pm.LauncherApps.ShortcutQuery setPackage(java.lang.String packageName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If non-null, returns only shortcuts from the package.
  ///@param packageName This value may be {@code null}.
  LauncherApps_ShortcutQuery setPackage(jni.JniString packageName) =>
      LauncherApps_ShortcutQuery.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setPackage,
          jni.JniType.objectType,
          [packageName.reference]).object);

  static final _id_setShortcutIds = jniAccessors.getMethodIDOf(
      _classRef,
      "setShortcutIds",
      "(Ljava/util/List;)Landroid/content/pm/LauncherApps\$ShortcutQuery;");

  /// from: public android.content.pm.LauncherApps.ShortcutQuery setShortcutIds(java.util.List<java.lang.String> shortcutIds)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If non-null, return only the specified shortcuts by ID.  When setting this field,
  /// a package name must also be set with \#setPackage.
  ///@param shortcutIds This value may be {@code null}.
  LauncherApps_ShortcutQuery setShortcutIds(jni.JniObject shortcutIds) =>
      LauncherApps_ShortcutQuery.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setShortcutIds,
          jni.JniType.objectType,
          [shortcutIds.reference]).object);

  static final _id_setActivity = jniAccessors.getMethodIDOf(
      _classRef,
      "setActivity",
      "(Landroid/content/ComponentName;)Landroid/content/pm/LauncherApps\$ShortcutQuery;");

  /// from: public android.content.pm.LauncherApps.ShortcutQuery setActivity(android.content.ComponentName activity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If non-null, returns only shortcuts associated with the activity; i.e.
  /// ShortcutInfos whose ShortcutInfo\#getActivity() are equal
  /// to {@code activity}.
  ///@param activity This value may be {@code null}.
  LauncherApps_ShortcutQuery setActivity(
          componentname_.ComponentName activity) =>
      LauncherApps_ShortcutQuery.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setActivity,
          jni.JniType.objectType,
          [activity.reference]).object);

  static final _id_setQueryFlags = jniAccessors.getMethodIDOf(_classRef,
      "setQueryFlags", "(I)Landroid/content/pm/LauncherApps\$ShortcutQuery;");

  /// from: public android.content.pm.LauncherApps.ShortcutQuery setQueryFlags(int queryFlags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set query options.  At least one of the {@code MATCH} flags should be set.  Otherwise,
  /// no shortcuts will be returned.
  ///
  /// <ul>
  ///     <li>\#FLAG_MATCH_DYNAMIC
  ///     <li>\#FLAG_MATCH_PINNED
  ///     <li>\#FLAG_MATCH_MANIFEST
  ///     <li>\#FLAG_GET_KEY_FIELDS_ONLY
  /// </ul>
  ///@param queryFlags Value is either <code>0</code> or a combination of android.content.pm.LauncherApps.ShortcutQuery\#FLAG_MATCH_DYNAMIC, android.content.pm.LauncherApps.ShortcutQuery\#FLAG_MATCH_PINNED, android.content.pm.LauncherApps.ShortcutQuery\#FLAG_MATCH_MANIFEST, android.content.pm.LauncherApps.ShortcutQuery\#FLAG_GET_KEY_FIELDS_ONLY, and android.content.pm.LauncherApps.ShortcutQuery\#FLAG_MATCH_MANIFEST
  LauncherApps_ShortcutQuery setQueryFlags(int queryFlags) =>
      LauncherApps_ShortcutQuery.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setQueryFlags,
          jni.JniType.objectType,
          [queryFlags]).object);
}

/// from: android.content.pm.LauncherApps$PinItemRequest
///
/// Represents a "pin shortcut" or a "pin appwidget" request made by an app, which is sent with
/// an \#ACTION_CONFIRM_PIN_SHORTCUT or \#ACTION_CONFIRM_PIN_APPWIDGET intent
/// respectively to the default launcher app.
///
/// <h3>Request of the \#REQUEST_TYPE_SHORTCUT type.
///
/// A \#REQUEST_TYPE_SHORTCUT request represents a request to pin a
/// ShortcutInfo.  If the launcher accepts a request, call \#accept(),
/// or \#accept(Bundle) with a null or empty Bundle.  No options are defined for
/// pin-shortcuts requests.
///
/// \#getShortcutInfo() always returns a non-null ShortcutInfo for this type.
///
/// The launcher may receive a request with a ShortcutInfo that is already pinned, in
/// which case ShortcutInfo\#isPinned() returns true.  This means the user wants to create
/// another pinned shortcut for a shortcut that's already pinned.  If the launcher accepts it,
/// \#accept() must still be called even though the shortcut is already pinned, and
/// create a new pinned shortcut icon for it.
///
/// See also ShortcutManager for more details.
///
/// <h3>Request of the \#REQUEST_TYPE_APPWIDGET type.
///
/// A \#REQUEST_TYPE_SHORTCUT request represents a request to pin a
/// an AppWidget.  If the launcher accepts a request, call \#accept(Bundle) with
/// the appwidget integer ID set to the
/// android.appwidget.AppWidgetManager\#EXTRA_APPWIDGET_ID extra.
///
/// \#getAppWidgetProviderInfo(Context) always returns a non-null
/// AppWidgetProviderInfo for this type.
///
/// See also AppWidgetManager for more details.
///@see \#EXTRA_PIN_ITEM_REQUEST
///@see \#getPinItemRequest(Intent)
class LauncherApps_PinItemRequest extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/content/pm/LauncherApps\$PinItemRequest");
  LauncherApps_PinItemRequest.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.LauncherApps.PinItemRequest> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int REQUEST_TYPE_APPWIDGET
  ///
  /// This is a request to pin app widget.
  static const REQUEST_TYPE_APPWIDGET = 2;

  /// from: static public final int REQUEST_TYPE_SHORTCUT
  ///
  /// This is a request to pin shortcut.
  static const REQUEST_TYPE_SHORTCUT = 1;

  static final _id_getRequestType =
      jniAccessors.getMethodIDOf(_classRef, "getRequestType", "()I");

  /// from: public int getRequestType()
  ///
  /// Represents the type of a request, which is one of the {@code REQUEST_TYPE_} constants.
  ///@return one of the {@code REQUEST_TYPE_} constants.
  ///
  /// Value is android.content.pm.LauncherApps.PinItemRequest\#REQUEST_TYPE_SHORTCUT, or android.content.pm.LauncherApps.PinItemRequest\#REQUEST_TYPE_APPWIDGET
  int getRequestType() => jniAccessors.callMethodWithArgs(
      reference, _id_getRequestType, jni.JniType.intType, []).integer;

  static final _id_getShortcutInfo = jniAccessors.getMethodIDOf(
      _classRef, "getShortcutInfo", "()Landroid/content/pm/ShortcutInfo;");

  /// from: public android.content.pm.ShortcutInfo getShortcutInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// ShortcutInfo sent by the requesting app.
  /// Always non-null for a \#REQUEST_TYPE_SHORTCUT request, and always null for a
  /// different request type.
  ///@return requested ShortcutInfo when a request is of the
  /// \#REQUEST_TYPE_SHORTCUT type.  Null otherwise.
  shortcutinfo_.ShortcutInfo getShortcutInfo() =>
      shortcutinfo_.ShortcutInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getShortcutInfo, jni.JniType.objectType, []).object);

  static final _id_getAppWidgetProviderInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getAppWidgetProviderInfo",
      "(Landroid/content/Context;)Landroid/appwidget/AppWidgetProviderInfo;");

  /// from: public android.appwidget.AppWidgetProviderInfo getAppWidgetProviderInfo(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// AppWidgetProviderInfo sent by the requesting app.
  /// Always non-null for a \#REQUEST_TYPE_APPWIDGET request, and always null for a
  /// different request type.
  ///
  /// Launcher should not show any configuration activity associated with the provider, and
  /// assume that the widget is already fully configured. Upon accepting the widget, it should
  /// pass the widgetId in \#accept(Bundle).
  ///@return requested AppWidgetProviderInfo when a request is of the
  /// \#REQUEST_TYPE_APPWIDGET type.  Null otherwise.
  appwidgetproviderinfo_.AppWidgetProviderInfo getAppWidgetProviderInfo(
          context_.Context context) =>
      appwidgetproviderinfo_.AppWidgetProviderInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getAppWidgetProviderInfo,
              jni.JniType.objectType, [context.reference]).object);

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Any extras sent by the requesting app.
  ///@return For a shortcut request, this method always return null.  For an AppWidget
  /// request, this method returns the extras passed to the
  /// android.appwidget.AppWidgetManager\#requestPinAppWidget(
  /// ComponentName, Bundle, PendingIntent) API.  See AppWidgetManager for details.
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_isValid =
      jniAccessors.getMethodIDOf(_classRef, "isValid", "()Z");

  /// from: public boolean isValid()
  ///
  /// Return whether a request is still valid.
  ///@return {@code TRUE} if a request is valid and \#accept(Bundle) may be called.
  bool isValid() => jniAccessors.callMethodWithArgs(
      reference, _id_isValid, jni.JniType.booleanType, []).boolean;

  static final _id_accept =
      jniAccessors.getMethodIDOf(_classRef, "accept", "(Landroid/os/Bundle;)Z");

  /// from: public boolean accept(android.os.Bundle options)
  ///
  /// Called by the receiving launcher app when the user accepts the request.
  ///@param options must be set for a \#REQUEST_TYPE_APPWIDGET request.
  ///
  /// This value may be {@code null}.
  ///@return {@code TRUE} if the shortcut or the AppWidget has actually been pinned.
  /// {@code FALSE} if the item hasn't been pinned, for example, because the request had
  /// already been canceled, in which case the launcher must not pin the requested item.
  bool accept(bundle_.Bundle options) => jniAccessors.callMethodWithArgs(
      reference,
      _id_accept,
      jni.JniType.booleanType,
      [options.reference]).boolean;

  static final _id_accept1 =
      jniAccessors.getMethodIDOf(_classRef, "accept", "()Z");

  /// from: public boolean accept()
  ///
  /// Called by the receiving launcher app when the user accepts the request, with no options.
  ///@return {@code TRUE} if the shortcut or the AppWidget has actually been pinned.
  /// {@code FALSE} if the item hasn't been pinned, for example, because the request had
  /// already been canceled, in which case the launcher must not pin the requested item.
  bool accept1() => jniAccessors.callMethodWithArgs(
      reference, _id_accept1, jni.JniType.booleanType, []).boolean;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;
}

/// from: android.content.pm.LauncherApps$Callback
///
/// Callbacks for package changes to this and related managed profiles.
class LauncherApps_Callback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/pm/LauncherApps\$Callback");
  LauncherApps_Callback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  LauncherApps_Callback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onPackageRemoved = jniAccessors.getMethodIDOf(_classRef,
      "onPackageRemoved", "(Ljava/lang/String;Landroid/os/UserHandle;)V");

  /// from: public abstract void onPackageRemoved(java.lang.String packageName, android.os.UserHandle user)
  ///
  /// Indicates that a package was removed from the specified profile.
  ///
  /// If a package is removed while being updated onPackageChanged will be
  /// called instead.
  ///@param packageName The name of the package that was removed.
  ///@param user The UserHandle of the profile that generated the change.
  void onPackageRemoved(
          jni.JniString packageName, userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPackageRemoved,
          jni.JniType.voidType,
          [packageName.reference, user.reference]).check();

  static final _id_onPackageAdded = jniAccessors.getMethodIDOf(_classRef,
      "onPackageAdded", "(Ljava/lang/String;Landroid/os/UserHandle;)V");

  /// from: public abstract void onPackageAdded(java.lang.String packageName, android.os.UserHandle user)
  ///
  /// Indicates that a package was added to the specified profile.
  ///
  /// If a package is added while being updated then onPackageChanged will be
  /// called instead.
  ///@param packageName The name of the package that was added.
  ///@param user The UserHandle of the profile that generated the change.
  void onPackageAdded(jni.JniString packageName, userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPackageAdded,
          jni.JniType.voidType,
          [packageName.reference, user.reference]).check();

  static final _id_onPackageChanged = jniAccessors.getMethodIDOf(_classRef,
      "onPackageChanged", "(Ljava/lang/String;Landroid/os/UserHandle;)V");

  /// from: public abstract void onPackageChanged(java.lang.String packageName, android.os.UserHandle user)
  ///
  /// Indicates that a package was modified in the specified profile.
  /// This can happen, for example, when the package is updated or when
  /// one or more components are enabled or disabled.
  ///@param packageName The name of the package that has changed.
  ///@param user The UserHandle of the profile that generated the change.
  void onPackageChanged(
          jni.JniString packageName, userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPackageChanged,
          jni.JniType.voidType,
          [packageName.reference, user.reference]).check();

  static final _id_onPackagesAvailable = jniAccessors.getMethodIDOf(_classRef,
      "onPackagesAvailable", "([Ljava/lang/String;Landroid/os/UserHandle;Z)V");

  /// from: public abstract void onPackagesAvailable(java.lang.String[] packageNames, android.os.UserHandle user, boolean replacing)
  ///
  /// Indicates that one or more packages have become available. For
  /// example, this can happen when a removable storage card has
  /// reappeared.
  ///@param packageNames The names of the packages that have become
  ///            available.
  ///@param user The UserHandle of the profile that generated the change.
  ///@param replacing Indicates whether these packages are replacing
  ///            existing ones.
  void onPackagesAvailable(jni.JniObject packageNames,
          userhandle_.UserHandle user, bool replacing) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPackagesAvailable,
          jni.JniType.voidType,
          [packageNames.reference, user.reference, replacing]).check();

  static final _id_onPackagesUnavailable = jniAccessors.getMethodIDOf(
      _classRef,
      "onPackagesUnavailable",
      "([Ljava/lang/String;Landroid/os/UserHandle;Z)V");

  /// from: public abstract void onPackagesUnavailable(java.lang.String[] packageNames, android.os.UserHandle user, boolean replacing)
  ///
  /// Indicates that one or more packages have become unavailable. For
  /// example, this can happen when a removable storage card has been
  /// removed.
  ///@param packageNames The names of the packages that have become
  ///            unavailable.
  ///@param user The UserHandle of the profile that generated the change.
  ///@param replacing Indicates whether the packages are about to be
  ///            replaced with new versions.
  void onPackagesUnavailable(jni.JniObject packageNames,
          userhandle_.UserHandle user, bool replacing) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPackagesUnavailable,
          jni.JniType.voidType,
          [packageNames.reference, user.reference, replacing]).check();

  static final _id_onPackagesSuspended = jniAccessors.getMethodIDOf(_classRef,
      "onPackagesSuspended", "([Ljava/lang/String;Landroid/os/UserHandle;)V");

  /// from: public void onPackagesSuspended(java.lang.String[] packageNames, android.os.UserHandle user)
  ///
  /// Indicates that one or more packages have been suspended. For
  /// example, this can happen when a Device Administrator suspends
  /// an applicaton.
  ///
  /// Note: On devices running android.os.Build.VERSION_CODES\#P Android P or higher,
  /// any apps that override \#onPackagesSuspended(String[], UserHandle, Bundle) will
  /// not receive this callback.
  ///@param packageNames The names of the packages that have just been
  ///            suspended.
  ///@param user The UserHandle of the profile that generated the change.
  void onPackagesSuspended(
          jni.JniObject packageNames, userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPackagesSuspended,
          jni.JniType.voidType,
          [packageNames.reference, user.reference]).check();

  static final _id_onPackagesSuspended1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onPackagesSuspended",
      "([Ljava/lang/String;Landroid/os/UserHandle;Landroid/os/Bundle;)V");

  /// from: public void onPackagesSuspended(java.lang.String[] packageNames, android.os.UserHandle user, android.os.Bundle launcherExtras)
  ///
  /// Indicates that one or more packages have been suspended. A device administrator or an app
  /// with {@code android.permission.SUSPEND_APPS} can do this.
  ///
  /// A suspending app with the permission {@code android.permission.SUSPEND_APPS} can
  /// optionally provide a Bundle of extra information that it deems helpful for the
  /// launcher to handle the suspended state of these packages. The contents of this
  /// Bundle are supposed to be a contract between the suspending app and the launcher.
  ///@param packageNames The names of the packages that have just been suspended.
  ///@param user the user for which the given packages were suspended.
  ///@param launcherExtras A Bundle of extras for the launcher, if provided to the
  ///                      system, {@code null} otherwise.
  /// This value may be {@code null}.
  ///@see PackageManager\#isPackageSuspended()
  ///@see \#getSuspendedPackageLauncherExtras(String, UserHandle)
  void onPackagesSuspended1(jni.JniObject packageNames,
          userhandle_.UserHandle user, bundle_.Bundle launcherExtras) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onPackagesSuspended1, jni.JniType.voidType, [
        packageNames.reference,
        user.reference,
        launcherExtras.reference
      ]).check();

  static final _id_onPackagesUnsuspended = jniAccessors.getMethodIDOf(_classRef,
      "onPackagesUnsuspended", "([Ljava/lang/String;Landroid/os/UserHandle;)V");

  /// from: public void onPackagesUnsuspended(java.lang.String[] packageNames, android.os.UserHandle user)
  ///
  /// Indicates that one or more packages have been unsuspended. For
  /// example, this can happen when a Device Administrator unsuspends
  /// an applicaton.
  ///@param packageNames The names of the packages that have just been
  ///            unsuspended.
  ///@param user The UserHandle of the profile that generated the change.
  void onPackagesUnsuspended(
          jni.JniObject packageNames, userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPackagesUnsuspended,
          jni.JniType.voidType,
          [packageNames.reference, user.reference]).check();

  static final _id_onShortcutsChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onShortcutsChanged",
      "(Ljava/lang/String;Ljava/util/List;Landroid/os/UserHandle;)V");

  /// from: public void onShortcutsChanged(java.lang.String packageName, java.util.List<android.content.pm.ShortcutInfo> shortcuts, android.os.UserHandle user)
  ///
  /// Indicates that one or more shortcuts of any kind (dynamic, pinned, or manifest)
  /// have been added, updated or removed.
  ///
  /// Only the applications that are allowed to access the shortcut information,
  /// as defined in \#hasShortcutHostPermission(), will receive it.
  ///@param packageName The name of the package that has the shortcuts.
  /// This value must never be {@code null}.
  ///@param shortcuts All shortcuts from the package (dynamic, manifest and/or pinned).
  ///    Only "key" information will be provided, as defined in
  ///    ShortcutInfo\#hasKeyFieldsOnly().
  /// This value must never be {@code null}.
  ///@param user The UserHandle of the profile that generated the change.
  ///
  /// This value must never be {@code null}.
  ///@see ShortcutManager
  void onShortcutsChanged(jni.JniString packageName, jni.JniObject shortcuts,
          userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onShortcutsChanged,
          jni.JniType.voidType,
          [packageName.reference, shortcuts.reference, user.reference]).check();
}
