// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../graphics/Bitmap.dart" as bitmap_;

import "../IntentSender.dart" as intentsender_;

import "VersionedPackage.dart" as versionedpackage_;

import "../../os/Handler.dart" as handler_;

import "../../os/Parcelable.dart" as parcelable_;

import "../../net/Uri.dart" as uri_;

import "../../os/Parcel.dart" as parcel_;

import "../Intent.dart" as intent_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.pm.PackageInstaller
///
/// Offers the ability to install, upgrade, and remove applications on the
/// device. This includes support for apps packaged either as a single
/// "monolithic" APK, or apps packaged as multiple "split" APKs.
///
/// An app is delivered for installation through a
/// PackageInstaller.Session, which any app can create. Once the session
/// is created, the installer can stream one or more APKs into place until it
/// decides to either commit or destroy the session. Committing may require user
/// intervention to complete the installation.
///
/// Sessions can install brand new apps, upgrade existing apps, or add new splits
/// into an existing app.
///
/// Apps packaged as multiple split APKs always consist of a single "base" APK
/// (with a {@code null} split name) and zero or more "split" APKs (with unique
/// split names). Any subset of these APKs can be installed together, as long as
/// the following constraints are met:
/// <ul>
/// <li>All APKs must have the exact same package name, version code, and signing
/// certificates.
/// <li>All APKs must have unique split names.
/// <li>All installations must contain a single base APK.
/// </ul>
///
/// The ApiDemos project contains examples of using this API:
/// <code>ApiDemos/src/com/example/android/apis/content/InstallApk*.java</code>.
class PackageInstaller extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/pm/PackageInstaller");
  PackageInstaller.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_SESSION_COMMITTED
  ///
  /// Broadcast Action: Explicit broadcast sent to the last known default launcher when a session
  /// for a new install is committed. For managed profile, this is sent to the default launcher
  /// of the primary profile.
  ///
  /// The associated session is defined in \#EXTRA_SESSION and the user for which this
  /// session was created in Intent\#EXTRA_USER.
  static const ACTION_SESSION_COMMITTED =
      "android.content.pm.action.SESSION_COMMITTED";

  /// from: static public final java.lang.String ACTION_SESSION_DETAILS
  ///
  /// Activity Action: Show details about a particular install session. This
  /// may surface actions such as pause, resume, or cancel.
  ///
  /// This should always be scoped to the installer package that owns the
  /// session. Clients should use SessionInfo\#createDetailsIntent() to
  /// build this intent correctly.
  ///
  /// In some cases, a matching Activity may not exist, so ensure you safeguard
  /// against this.
  ///
  /// The session to show details for is defined in \#EXTRA_SESSION_ID.
  static const ACTION_SESSION_DETAILS =
      "android.content.pm.action.SESSION_DETAILS";

  /// from: static public final java.lang.String EXTRA_OTHER_PACKAGE_NAME
  ///
  /// Another package name relevant to a status. This is typically the package
  /// responsible for causing an operation failure.
  ///@see Intent\#getStringExtra(String)
  static const EXTRA_OTHER_PACKAGE_NAME =
      "android.content.pm.extra.OTHER_PACKAGE_NAME";

  /// from: static public final java.lang.String EXTRA_PACKAGE_NAME
  ///
  /// Package name that an operation is working with.
  ///@see Intent\#getStringExtra(String)
  static const EXTRA_PACKAGE_NAME = "android.content.pm.extra.PACKAGE_NAME";

  /// from: static public final java.lang.String EXTRA_SESSION
  ///
  /// SessionInfo that an operation is working with.
  ///@see Intent\#getParcelableExtra(String)
  static const EXTRA_SESSION = "android.content.pm.extra.SESSION";

  /// from: static public final java.lang.String EXTRA_SESSION_ID
  ///
  /// An integer session ID that an operation is working with.
  ///@see Intent\#getIntExtra(String, int)
  static const EXTRA_SESSION_ID = "android.content.pm.extra.SESSION_ID";

  /// from: static public final java.lang.String EXTRA_STATUS
  ///
  /// Current status of an operation. Will be one of
  /// \#STATUS_PENDING_USER_ACTION, \#STATUS_SUCCESS,
  /// \#STATUS_FAILURE, \#STATUS_FAILURE_ABORTED,
  /// \#STATUS_FAILURE_BLOCKED, \#STATUS_FAILURE_CONFLICT,
  /// \#STATUS_FAILURE_INCOMPATIBLE, \#STATUS_FAILURE_INVALID, or
  /// \#STATUS_FAILURE_STORAGE.
  ///
  /// More information about a status may be available through additional
  /// extras; see the individual status documentation for details.
  ///@see Intent\#getIntExtra(String, int)
  static const EXTRA_STATUS = "android.content.pm.extra.STATUS";

  /// from: static public final java.lang.String EXTRA_STATUS_MESSAGE
  ///
  /// Detailed string representation of the status, including raw details that
  /// are useful for debugging.
  ///@see Intent\#getStringExtra(String)
  static const EXTRA_STATUS_MESSAGE = "android.content.pm.extra.STATUS_MESSAGE";

  /// from: static public final java.lang.String EXTRA_STORAGE_PATH
  ///
  /// Storage path relevant to a status.
  ///@see Intent\#getStringExtra(String)
  static const EXTRA_STORAGE_PATH = "android.content.pm.extra.STORAGE_PATH";

  /// from: static public final int STATUS_FAILURE
  ///
  /// The operation failed in a generic way. The system will always try to
  /// provide a more specific failure reason, but in some rare cases this may
  /// be delivered.
  ///@see \#EXTRA_STATUS_MESSAGE
  static const STATUS_FAILURE = 1;

  /// from: static public final int STATUS_FAILURE_ABORTED
  ///
  /// The operation failed because it was actively aborted. For example, the
  /// user actively declined requested permissions, or the session was
  /// abandoned.
  ///@see \#EXTRA_STATUS_MESSAGE
  static const STATUS_FAILURE_ABORTED = 3;

  /// from: static public final int STATUS_FAILURE_BLOCKED
  ///
  /// The operation failed because it was blocked. For example, a device policy
  /// may be blocking the operation, a package verifier may have blocked the
  /// operation, or the app may be required for core system operation.
  ///
  /// The result may also contain \#EXTRA_OTHER_PACKAGE_NAME with the
  /// specific package blocking the install.
  ///@see \#EXTRA_STATUS_MESSAGE
  ///@see \#EXTRA_OTHER_PACKAGE_NAME
  static const STATUS_FAILURE_BLOCKED = 2;

  /// from: static public final int STATUS_FAILURE_CONFLICT
  ///
  /// The operation failed because it conflicts (or is inconsistent with) with
  /// another package already installed on the device. For example, an existing
  /// permission, incompatible certificates, etc. The user may be able to
  /// uninstall another app to fix the issue.
  ///
  /// The result may also contain \#EXTRA_OTHER_PACKAGE_NAME with the
  /// specific package identified as the cause of the conflict.
  ///@see \#EXTRA_STATUS_MESSAGE
  ///@see \#EXTRA_OTHER_PACKAGE_NAME
  static const STATUS_FAILURE_CONFLICT = 5;

  /// from: static public final int STATUS_FAILURE_INCOMPATIBLE
  ///
  /// The operation failed because it is fundamentally incompatible with this
  /// device. For example, the app may require a hardware feature that doesn't
  /// exist, it may be missing native code for the ABIs supported by the
  /// device, or it requires a newer SDK version, etc.
  ///@see \#EXTRA_STATUS_MESSAGE
  static const STATUS_FAILURE_INCOMPATIBLE = 7;

  /// from: static public final int STATUS_FAILURE_INVALID
  ///
  /// The operation failed because one or more of the APKs was invalid. For
  /// example, they might be malformed, corrupt, incorrectly signed,
  /// mismatched, etc.
  ///@see \#EXTRA_STATUS_MESSAGE
  static const STATUS_FAILURE_INVALID = 4;

  /// from: static public final int STATUS_FAILURE_STORAGE
  ///
  /// The operation failed because of storage issues. For example, the device
  /// may be running low on space, or external media may be unavailable. The
  /// user may be able to help free space or insert different external media.
  ///
  /// The result may also contain \#EXTRA_STORAGE_PATH with the path to
  /// the storage device that caused the failure.
  ///@see \#EXTRA_STATUS_MESSAGE
  ///@see \#EXTRA_STORAGE_PATH
  static const STATUS_FAILURE_STORAGE = 6;

  /// from: static public final int STATUS_PENDING_USER_ACTION
  ///
  /// User action is currently required to proceed. You can launch the intent
  /// activity described by Intent\#EXTRA_INTENT to involve the user and
  /// continue.
  ///
  /// You may choose to immediately launch the intent if the user is actively
  /// using your app. Otherwise, you should use a notification to guide the
  /// user back into your app before launching.
  ///@see Intent\#getParcelableExtra(String)
  static const STATUS_PENDING_USER_ACTION = -1;

  /// from: static public final int STATUS_SUCCESS
  ///
  /// The operation succeeded.
  static const STATUS_SUCCESS = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  PackageInstaller()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_createSession = jniAccessors.getMethodIDOf(
      _classRef,
      "createSession",
      "(Landroid/content/pm/PackageInstaller\$SessionParams;)I");

  /// from: public int createSession(android.content.pm.PackageInstaller.SessionParams params)
  ///
  /// Create a new session using the given parameters, returning a unique ID
  /// that represents the session. Once created, the session can be opened
  /// multiple times across multiple device boots.
  ///
  /// The system may automatically destroy sessions that have not been
  /// finalized (either committed or abandoned) within a reasonable period of
  /// time, typically on the order of a day.
  ///@throws IOException if parameters were unsatisfiable, such as lack of
  ///             disk space or unavailable media.
  ///@throws SecurityException when installation services are unavailable,
  ///             such as when called from a restricted user.
  ///@throws IllegalArgumentException when SessionParams is invalid.
  ///@param params This value must never be {@code null}.
  ///@return positive, non-zero unique ID that represents the created session.
  ///         This ID remains consistent across device reboots until the
  ///         session is finalized. IDs are not reused during a given boot.
  int createSession(PackageInstaller_SessionParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_createSession,
          jni.JniType.intType, [params.reference]).integer;

  static final _id_openSession = jniAccessors.getMethodIDOf(_classRef,
      "openSession", "(I)Landroid/content/pm/PackageInstaller\$Session;");

  /// from: public android.content.pm.PackageInstaller.Session openSession(int sessionId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open an existing session to actively perform work. To succeed, the caller
  /// must be the owner of the install session.
  ///@throws IOException if parameters were unsatisfiable, such as lack of
  ///             disk space or unavailable media.
  ///@throws SecurityException when the caller does not own the session, or
  ///             the session is invalid.
  ///@return This value will never be {@code null}.
  PackageInstaller_Session openSession(int sessionId) =>
      PackageInstaller_Session.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_openSession,
          jni.JniType.objectType,
          [sessionId]).object);

  static final _id_updateSessionAppIcon = jniAccessors.getMethodIDOf(
      _classRef, "updateSessionAppIcon", "(ILandroid/graphics/Bitmap;)V");

  /// from: public void updateSessionAppIcon(int sessionId, android.graphics.Bitmap appIcon)
  ///
  /// Update the icon representing the app being installed in a specific
  /// session. This should be roughly
  /// ActivityManager\#getLauncherLargeIconSize() in both dimensions.
  ///@throws SecurityException when the caller does not own the session, or
  ///             the session is invalid.
  ///@param appIcon This value may be {@code null}.
  void updateSessionAppIcon(int sessionId, bitmap_.Bitmap appIcon) =>
      jniAccessors.callMethodWithArgs(reference, _id_updateSessionAppIcon,
          jni.JniType.voidType, [sessionId, appIcon.reference]).check();

  static final _id_updateSessionAppLabel = jniAccessors.getMethodIDOf(
      _classRef, "updateSessionAppLabel", "(ILjava/lang/CharSequence;)V");

  /// from: public void updateSessionAppLabel(int sessionId, java.lang.CharSequence appLabel)
  ///
  /// Update the label representing the app being installed in a specific
  /// session.
  ///@throws SecurityException when the caller does not own the session, or
  ///             the session is invalid.
  ///@param appLabel This value may be {@code null}.
  void updateSessionAppLabel(int sessionId, jni.JniObject appLabel) =>
      jniAccessors.callMethodWithArgs(reference, _id_updateSessionAppLabel,
          jni.JniType.voidType, [sessionId, appLabel.reference]).check();

  static final _id_abandonSession =
      jniAccessors.getMethodIDOf(_classRef, "abandonSession", "(I)V");

  /// from: public void abandonSession(int sessionId)
  ///
  /// Completely abandon the given session, destroying all staged data and
  /// rendering it invalid. Abandoned sessions will be reported to
  /// SessionCallback listeners as failures. This is equivalent to
  /// opening the session and calling Session\#abandon().
  ///@throws SecurityException when the caller does not own the session, or
  ///             the session is invalid.
  void abandonSession(int sessionId) => jniAccessors.callMethodWithArgs(
      reference, _id_abandonSession, jni.JniType.voidType, [sessionId]).check();

  static final _id_getSessionInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getSessionInfo",
      "(I)Landroid/content/pm/PackageInstaller\$SessionInfo;");

  /// from: public android.content.pm.PackageInstaller.SessionInfo getSessionInfo(int sessionId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return details for a specific session. No special permissions are
  /// required to retrieve these details.
  ///@return details for the requested session, or {@code null} if the session
  ///         does not exist.
  PackageInstaller_SessionInfo getSessionInfo(int sessionId) =>
      PackageInstaller_SessionInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSessionInfo,
          jni.JniType.objectType,
          [sessionId]).object);

  static final _id_getAllSessions = jniAccessors.getMethodIDOf(
      _classRef, "getAllSessions", "()Ljava/util/List;");

  /// from: public java.util.List<android.content.pm.PackageInstaller.SessionInfo> getAllSessions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return list of all known install sessions, regardless of the installer.
  ///@return This value will never be {@code null}.
  jni.JniObject getAllSessions() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAllSessions, jni.JniType.objectType, []).object);

  static final _id_getMySessions = jniAccessors.getMethodIDOf(
      _classRef, "getMySessions", "()Ljava/util/List;");

  /// from: public java.util.List<android.content.pm.PackageInstaller.SessionInfo> getMySessions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return list of all known install sessions owned by the calling app.
  ///@return This value will never be {@code null}.
  jni.JniObject getMySessions() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMySessions, jni.JniType.objectType, []).object);

  static final _id_uninstall = jniAccessors.getMethodIDOf(_classRef,
      "uninstall", "(Ljava/lang/String;Landroid/content/IntentSender;)V");

  /// from: public void uninstall(java.lang.String packageName, android.content.IntentSender statusReceiver)
  ///
  /// Uninstall the given package, removing it completely from the device. This
  /// method is available to:
  /// <ul>
  /// <li>the current "installer of record" for the package
  /// <li>the device owner
  /// <li>the affiliated profile owner
  /// </ul>
  ///
  /// Requires android.Manifest.permission\#DELETE_PACKAGES or android.Manifest.permission\#REQUEST_DELETE_PACKAGES
  ///@param packageName The package to uninstall.
  /// This value must never be {@code null}.
  ///@param statusReceiver Where to deliver the result.
  ///
  /// This value must never be {@code null}.
  ///@see android.app.admin.DevicePolicyManager
  void uninstall(jni.JniString packageName,
          intentsender_.IntentSender statusReceiver) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_uninstall,
          jni.JniType.voidType,
          [packageName.reference, statusReceiver.reference]).check();

  static final _id_uninstall1 = jniAccessors.getMethodIDOf(
      _classRef,
      "uninstall",
      "(Landroid/content/pm/VersionedPackage;Landroid/content/IntentSender;)V");

  /// from: public void uninstall(android.content.pm.VersionedPackage versionedPackage, android.content.IntentSender statusReceiver)
  ///
  /// Uninstall the given package with a specific version code, removing it
  /// completely from the device. If the version code of the package
  /// does not match the one passed in the versioned package argument this
  /// method is a no-op. Use PackageManager\#VERSION_CODE_HIGHEST to
  /// uninstall the latest version of the package.
  ///
  /// This method is available to:
  /// <ul>
  /// <li>the current "installer of record" for the package
  /// <li>the device owner
  /// <li>the affiliated profile owner
  /// </ul>
  ///
  /// Requires android.Manifest.permission\#DELETE_PACKAGES or android.Manifest.permission\#REQUEST_DELETE_PACKAGES
  ///@param versionedPackage The versioned package to uninstall.
  /// This value must never be {@code null}.
  ///@param statusReceiver Where to deliver the result.
  ///
  /// This value must never be {@code null}.
  ///@see android.app.admin.DevicePolicyManager
  void uninstall1(versionedpackage_.VersionedPackage versionedPackage,
          intentsender_.IntentSender statusReceiver) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_uninstall1,
          jni.JniType.voidType,
          [versionedPackage.reference, statusReceiver.reference]).check();

  static final _id_registerSessionCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerSessionCallback",
      "(Landroid/content/pm/PackageInstaller\$SessionCallback;)V");

  /// from: public void registerSessionCallback(android.content.pm.PackageInstaller.SessionCallback callback)
  ///
  /// Register to watch for session lifecycle events. No special permissions
  /// are required to watch for these events.
  ///@param callback This value must never be {@code null}.
  void registerSessionCallback(PackageInstaller_SessionCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerSessionCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_registerSessionCallback1 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerSessionCallback",
      "(Landroid/content/pm/PackageInstaller\$SessionCallback;Landroid/os/Handler;)V");

  /// from: public void registerSessionCallback(android.content.pm.PackageInstaller.SessionCallback callback, android.os.Handler handler)
  ///
  /// Register to watch for session lifecycle events. No special permissions
  /// are required to watch for these events.
  ///@param handler to dispatch callback events through, otherwise uses
  ///            calling thread.
  ///
  /// This value must never be {@code null}.
  ///@param callback This value must never be {@code null}.
  void registerSessionCallback1(PackageInstaller_SessionCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerSessionCallback1,
          jni.JniType.voidType,
          [callback.reference, handler.reference]).check();

  static final _id_unregisterSessionCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterSessionCallback",
      "(Landroid/content/pm/PackageInstaller\$SessionCallback;)V");

  /// from: public void unregisterSessionCallback(android.content.pm.PackageInstaller.SessionCallback callback)
  ///
  /// Unregister a previously registered callback.
  ///@param callback This value must never be {@code null}.
  void unregisterSessionCallback(PackageInstaller_SessionCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterSessionCallback,
          jni.JniType.voidType, [callback.reference]).check();
}

/// from: android.content.pm.PackageInstaller$SessionParams
///
/// Parameters for creating a new PackageInstaller.Session.
class PackageInstaller_SessionParams extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/content/pm/PackageInstaller\$SessionParams");
  PackageInstaller_SessionParams.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.PackageInstaller.SessionParams> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int MODE_FULL_INSTALL
  ///
  /// Mode for an install session whose staged APKs should fully replace any
  /// existing APKs for the target app.
  static const MODE_FULL_INSTALL = 1;

  /// from: static public final int MODE_INHERIT_EXISTING
  ///
  /// Mode for an install session that should inherit any existing APKs for the
  /// target app, unless they have been explicitly overridden (based on split
  /// name) by the session. For example, this can be used to add one or more
  /// split APKs to an existing installation.
  ///
  /// If there are no existing APKs for the target app, this behaves like
  /// \#MODE_FULL_INSTALL.
  static const MODE_INHERIT_EXISTING = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct parameters for a new package install session.
  ///@param mode one of \#MODE_FULL_INSTALL or
  ///            \#MODE_INHERIT_EXISTING describing how the session
  ///            should interact with an existing app.
  PackageInstaller_SessionParams(int mode)
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [mode]).object);

  static final _id_setInstallLocation =
      jniAccessors.getMethodIDOf(_classRef, "setInstallLocation", "(I)V");

  /// from: public void setInstallLocation(int installLocation)
  ///
  /// Provide value of PackageInfo\#installLocation, which may be used
  /// to determine where the app will be staged. Defaults to
  /// PackageInfo\#INSTALL_LOCATION_INTERNAL_ONLY.
  void setInstallLocation(int installLocation) =>
      jniAccessors.callMethodWithArgs(reference, _id_setInstallLocation,
          jni.JniType.voidType, [installLocation]).check();

  static final _id_setSize =
      jniAccessors.getMethodIDOf(_classRef, "setSize", "(J)V");

  /// from: public void setSize(long sizeBytes)
  ///
  /// Optionally indicate the total size (in bytes) of all APKs that will be
  /// delivered in this session. The system may use this to ensure enough disk
  /// space exists before proceeding, or to estimate container size for
  /// installations living on external storage.
  ///@see PackageInfo\#INSTALL_LOCATION_AUTO
  ///@see PackageInfo\#INSTALL_LOCATION_PREFER_EXTERNAL
  void setSize(int sizeBytes) => jniAccessors.callMethodWithArgs(
      reference, _id_setSize, jni.JniType.voidType, [sizeBytes]).check();

  static final _id_setAppPackageName = jniAccessors.getMethodIDOf(
      _classRef, "setAppPackageName", "(Ljava/lang/String;)V");

  /// from: public void setAppPackageName(java.lang.String appPackageName)
  ///
  /// Optionally set the package name of the app being installed. It's strongly
  /// recommended that you provide this value when known, so that observers can
  /// communicate installing apps to users.
  ///
  /// If the APKs staged in the session aren't consistent with this package
  /// name, the install will fail. Regardless of this value, all APKs in the
  /// app must have the same package name.
  ///@param appPackageName This value may be {@code null}.
  void setAppPackageName(jni.JniString appPackageName) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAppPackageName,
          jni.JniType.voidType, [appPackageName.reference]).check();

  static final _id_setAppIcon = jniAccessors.getMethodIDOf(
      _classRef, "setAppIcon", "(Landroid/graphics/Bitmap;)V");

  /// from: public void setAppIcon(android.graphics.Bitmap appIcon)
  ///
  /// Optionally set an icon representing the app being installed. This should
  /// be roughly ActivityManager\#getLauncherLargeIconSize() in both
  /// dimensions.
  ///@param appIcon This value may be {@code null}.
  void setAppIcon(bitmap_.Bitmap appIcon) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAppIcon,
      jni.JniType.voidType,
      [appIcon.reference]).check();

  static final _id_setAppLabel = jniAccessors.getMethodIDOf(
      _classRef, "setAppLabel", "(Ljava/lang/CharSequence;)V");

  /// from: public void setAppLabel(java.lang.CharSequence appLabel)
  ///
  /// Optionally set a label representing the app being installed.
  ///@param appLabel This value may be {@code null}.
  void setAppLabel(jni.JniObject appLabel) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAppLabel,
      jni.JniType.voidType,
      [appLabel.reference]).check();

  static final _id_setOriginatingUri = jniAccessors.getMethodIDOf(
      _classRef, "setOriginatingUri", "(Landroid/net/Uri;)V");

  /// from: public void setOriginatingUri(android.net.Uri originatingUri)
  ///
  /// Optionally set the URI where this package was downloaded from. This is
  /// informational and may be used as a signal for anti-malware purposes.
  ///@see Intent\#EXTRA_ORIGINATING_URI
  ///@param originatingUri This value may be {@code null}.
  void setOriginatingUri(uri_.Uri originatingUri) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOriginatingUri,
          jni.JniType.voidType, [originatingUri.reference]).check();

  static final _id_setOriginatingUid =
      jniAccessors.getMethodIDOf(_classRef, "setOriginatingUid", "(I)V");

  /// from: public void setOriginatingUid(int originatingUid)
  ///
  /// Sets the UID that initiated the package installation. This is informational
  /// and may be used as a signal for anti-malware purposes.
  ///@see Intent\#EXTRA_ORIGINATING_UID
  void setOriginatingUid(int originatingUid) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setOriginatingUid,
      jni.JniType.voidType,
      [originatingUid]).check();

  static final _id_setReferrerUri = jniAccessors.getMethodIDOf(
      _classRef, "setReferrerUri", "(Landroid/net/Uri;)V");

  /// from: public void setReferrerUri(android.net.Uri referrerUri)
  ///
  /// Optionally set the URI that referred you to install this package. This is
  /// informational and may be used as a signal for anti-malware purposes.
  ///@see Intent\#EXTRA_REFERRER
  ///@param referrerUri This value may be {@code null}.
  void setReferrerUri(uri_.Uri referrerUri) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setReferrerUri,
      jni.JniType.voidType,
      [referrerUri.reference]).check();

  static final _id_setInstallReason =
      jniAccessors.getMethodIDOf(_classRef, "setInstallReason", "(I)V");

  /// from: public void setInstallReason(int installReason)
  ///
  /// Set the reason for installing this package.
  ///@param installReason Value is android.content.pm.PackageManager\#INSTALL_REASON_UNKNOWN, android.content.pm.PackageManager\#INSTALL_REASON_POLICY, android.content.pm.PackageManager\#INSTALL_REASON_DEVICE_RESTORE, android.content.pm.PackageManager\#INSTALL_REASON_DEVICE_SETUP, or android.content.pm.PackageManager\#INSTALL_REASON_USER
  void setInstallReason(int installReason) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setInstallReason,
      jni.JniType.voidType,
      [installReason]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}

/// from: android.content.pm.PackageInstaller$SessionInfo
///
/// Details for an active install session.
class PackageInstaller_SessionInfo extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/content/pm/PackageInstaller\$SessionInfo");
  PackageInstaller_SessionInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.PackageInstaller.SessionInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@hide }
  PackageInstaller_SessionInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getSessionId =
      jniAccessors.getMethodIDOf(_classRef, "getSessionId", "()I");

  /// from: public int getSessionId()
  ///
  /// Return the ID for this session.
  int getSessionId() => jniAccessors.callMethodWithArgs(
      reference, _id_getSessionId, jni.JniType.intType, []).integer;

  static final _id_getInstallerPackageName = jniAccessors.getMethodIDOf(
      _classRef, "getInstallerPackageName", "()Ljava/lang/String;");

  /// from: public java.lang.String getInstallerPackageName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the package name of the app that owns this session.
  ///@return This value may be {@code null}.
  jni.JniString getInstallerPackageName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getInstallerPackageName, jni.JniType.objectType, []).object);

  static final _id_getProgress =
      jniAccessors.getMethodIDOf(_classRef, "getProgress", "()F");

  /// from: public float getProgress()
  ///
  /// Return current overall progress of this session, between 0 and 1.
  ///
  /// Note that this progress may not directly correspond to the value
  /// reported by
  /// PackageInstaller.Session\#setStagingProgress(float), as the
  /// system may carve out a portion of the overall progress to represent
  /// its own internal installation work.
  double getProgress() => jniAccessors.callMethodWithArgs(
      reference, _id_getProgress, jni.JniType.floatType, []).float;

  static final _id_isActive =
      jniAccessors.getMethodIDOf(_classRef, "isActive", "()Z");

  /// from: public boolean isActive()
  ///
  /// Return if this session is currently active.
  ///
  /// A session is considered active whenever there is ongoing forward
  /// progress being made, such as the installer holding an open
  /// Session instance while streaming data into place, or the
  /// system optimizing code as the result of
  /// Session\#commit(IntentSender).
  ///
  /// If the installer closes the Session without committing, the
  /// session is considered inactive until the installer opens the session
  /// again.
  bool isActive() => jniAccessors.callMethodWithArgs(
      reference, _id_isActive, jni.JniType.booleanType, []).boolean;

  static final _id_isSealed =
      jniAccessors.getMethodIDOf(_classRef, "isSealed", "()Z");

  /// from: public boolean isSealed()
  ///
  /// Return if this session is sealed.
  ///
  /// Once sealed, no further changes may be made to the session. A session
  /// is sealed the moment Session\#commit(IntentSender) is called.
  bool isSealed() => jniAccessors.callMethodWithArgs(
      reference, _id_isSealed, jni.JniType.booleanType, []).boolean;

  static final _id_getInstallReason =
      jniAccessors.getMethodIDOf(_classRef, "getInstallReason", "()I");

  /// from: public int getInstallReason()
  ///
  /// Return the reason for installing this package.
  ///@return The install reason.
  ///
  /// Value is android.content.pm.PackageManager\#INSTALL_REASON_UNKNOWN, android.content.pm.PackageManager\#INSTALL_REASON_POLICY, android.content.pm.PackageManager\#INSTALL_REASON_DEVICE_RESTORE, android.content.pm.PackageManager\#INSTALL_REASON_DEVICE_SETUP, or android.content.pm.PackageManager\#INSTALL_REASON_USER
  int getInstallReason() => jniAccessors.callMethodWithArgs(
      reference, _id_getInstallReason, jni.JniType.intType, []).integer;

  static final _id_getAppPackageName = jniAccessors.getMethodIDOf(
      _classRef, "getAppPackageName", "()Ljava/lang/String;");

  /// from: public java.lang.String getAppPackageName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the package name this session is working with. May be {@code null}
  /// if unknown.
  jni.JniString getAppPackageName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAppPackageName, jni.JniType.objectType, []).object);

  static final _id_getAppIcon = jniAccessors.getMethodIDOf(
      _classRef, "getAppIcon", "()Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getAppIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an icon representing the app being installed. May be {@code null}
  /// if unavailable.
  bitmap_.Bitmap getAppIcon() =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAppIcon, jni.JniType.objectType, []).object);

  static final _id_getAppLabel = jniAccessors.getMethodIDOf(
      _classRef, "getAppLabel", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAppLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a label representing the app being installed. May be {@code null}
  /// if unavailable.
  jni.JniObject getAppLabel() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAppLabel, jni.JniType.objectType, []).object);

  static final _id_createDetailsIntent = jniAccessors.getMethodIDOf(
      _classRef, "createDetailsIntent", "()Landroid/content/Intent;");

  /// from: public android.content.Intent createDetailsIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an Intent that can be started to view details about this install
  /// session. This may surface actions such as pause, resume, or cancel.
  ///
  /// In some cases, a matching Activity may not exist, so ensure you safeguard
  /// against this.
  ///@see PackageInstaller\#ACTION_SESSION_DETAILS
  ///@return This value may be {@code null}.
  intent_.Intent createDetailsIntent() =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_createDetailsIntent, jni.JniType.objectType, []).object);

  static final _id_getMode =
      jniAccessors.getMethodIDOf(_classRef, "getMode", "()I");

  /// from: public int getMode()
  ///
  /// Get the mode of the session as set in the constructor of the SessionParams.
  ///@return One of SessionParams\#MODE_FULL_INSTALL
  ///         or SessionParams\#MODE_INHERIT_EXISTING
  int getMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getMode, jni.JniType.intType, []).integer;

  static final _id_getInstallLocation =
      jniAccessors.getMethodIDOf(_classRef, "getInstallLocation", "()I");

  /// from: public int getInstallLocation()
  ///
  /// Get the value set in SessionParams\#setInstallLocation(int).
  int getInstallLocation() => jniAccessors.callMethodWithArgs(
      reference, _id_getInstallLocation, jni.JniType.intType, []).integer;

  static final _id_getSize =
      jniAccessors.getMethodIDOf(_classRef, "getSize", "()J");

  /// from: public long getSize()
  ///
  /// Get the value as set in SessionParams\#setSize(long).
  ///
  /// The value is a hint and does not have to match the actual size.
  int getSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getSize, jni.JniType.longType, []).long;

  static final _id_getOriginatingUri = jniAccessors.getMethodIDOf(
      _classRef, "getOriginatingUri", "()Landroid/net/Uri;");

  /// from: public android.net.Uri getOriginatingUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the value set in SessionParams\#setOriginatingUri(Uri).
  ///@return This value may be {@code null}.
  uri_.Uri getOriginatingUri() =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getOriginatingUri, jni.JniType.objectType, []).object);

  static final _id_getOriginatingUid =
      jniAccessors.getMethodIDOf(_classRef, "getOriginatingUid", "()I");

  /// from: public int getOriginatingUid()
  ///
  /// Get the value set in SessionParams\#setOriginatingUid(int).
  int getOriginatingUid() => jniAccessors.callMethodWithArgs(
      reference, _id_getOriginatingUid, jni.JniType.intType, []).integer;

  static final _id_getReferrerUri = jniAccessors.getMethodIDOf(
      _classRef, "getReferrerUri", "()Landroid/net/Uri;");

  /// from: public android.net.Uri getReferrerUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the value set in SessionParams\#setReferrerUri(Uri)
  ///@return This value may be {@code null}.
  uri_.Uri getReferrerUri() => uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getReferrerUri, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}

/// from: android.content.pm.PackageInstaller$SessionCallback
///
/// Events for observing session lifecycle.
///
/// A typical session lifecycle looks like this:
/// <ul>
/// <li>An installer creates a session to indicate pending app delivery. All
/// install details are available at this point.
/// <li>The installer opens the session to deliver APK data. Note that a
/// session may be opened and closed multiple times as network connectivity
/// changes. The installer may deliver periodic progress updates.
/// <li>The installer commits or abandons the session, resulting in the
/// session being finished.
/// </ul>
class PackageInstaller_SessionCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/content/pm/PackageInstaller\$SessionCallback");
  PackageInstaller_SessionCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  PackageInstaller_SessionCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onCreated =
      jniAccessors.getMethodIDOf(_classRef, "onCreated", "(I)V");

  /// from: public abstract void onCreated(int sessionId)
  ///
  /// New session has been created. Details about the session can be
  /// obtained from PackageInstaller\#getSessionInfo(int).
  void onCreated(int sessionId) => jniAccessors.callMethodWithArgs(
      reference, _id_onCreated, jni.JniType.voidType, [sessionId]).check();

  static final _id_onBadgingChanged =
      jniAccessors.getMethodIDOf(_classRef, "onBadgingChanged", "(I)V");

  /// from: public abstract void onBadgingChanged(int sessionId)
  ///
  /// Badging details for an existing session has changed. For example, the
  /// app icon or label has been updated.
  void onBadgingChanged(int sessionId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onBadgingChanged,
      jni.JniType.voidType,
      [sessionId]).check();

  static final _id_onActiveChanged =
      jniAccessors.getMethodIDOf(_classRef, "onActiveChanged", "(IZ)V");

  /// from: public abstract void onActiveChanged(int sessionId, boolean active)
  ///
  /// Active state for session has been changed.
  ///
  /// A session is considered active whenever there is ongoing forward
  /// progress being made, such as the installer holding an open
  /// Session instance while streaming data into place, or the
  /// system optimizing code as the result of
  /// Session\#commit(IntentSender).
  ///
  /// If the installer closes the Session without committing, the
  /// session is considered inactive until the installer opens the session
  /// again.
  void onActiveChanged(int sessionId, bool active) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActiveChanged,
          jni.JniType.voidType, [sessionId, active]).check();

  static final _id_onProgressChanged =
      jniAccessors.getMethodIDOf(_classRef, "onProgressChanged", "(IF)V");

  /// from: public abstract void onProgressChanged(int sessionId, float progress)
  ///
  /// Progress for given session has been updated.
  ///
  /// Note that this progress may not directly correspond to the value
  /// reported by
  /// PackageInstaller.Session\#setStagingProgress(float), as the
  /// system may carve out a portion of the overall progress to represent
  /// its own internal installation work.
  void onProgressChanged(int sessionId, double progress) =>
      jniAccessors.callMethodWithArgs(reference, _id_onProgressChanged,
          jni.JniType.voidType, [sessionId, progress]).check();

  static final _id_onFinished =
      jniAccessors.getMethodIDOf(_classRef, "onFinished", "(IZ)V");

  /// from: public abstract void onFinished(int sessionId, boolean success)
  ///
  /// Session has completely finished, either with success or failure.
  void onFinished(int sessionId, bool success) =>
      jniAccessors.callMethodWithArgs(reference, _id_onFinished,
          jni.JniType.voidType, [sessionId, success]).check();
}

/// from: android.content.pm.PackageInstaller$Session
///
/// An installation that is being actively staged. For an install to succeed,
/// all existing and new packages must have identical package names, version
/// codes, and signing certificates.
///
/// A session may contain any number of split packages. If the application
/// does not yet exist, this session must include a base package.
///
/// If an APK included in this session is already defined by the existing
/// installation (for example, the same split name), the APK in this session
/// will replace the existing APK.
class PackageInstaller_Session extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/pm/PackageInstaller\$Session");
  PackageInstaller_Session.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  PackageInstaller_Session()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setStagingProgress =
      jniAccessors.getMethodIDOf(_classRef, "setStagingProgress", "(F)V");

  /// from: public void setStagingProgress(float progress)
  ///
  /// Set current progress of staging this session. Valid values are
  /// anywhere between 0 and 1.
  ///
  /// Note that this progress may not directly correspond to the value
  /// reported by SessionCallback\#onProgressChanged(int, float), as
  /// the system may carve out a portion of the overall progress to
  /// represent its own internal installation work.
  void setStagingProgress(double progress) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setStagingProgress,
      jni.JniType.voidType,
      [progress]).check();

  static final _id_openWrite = jniAccessors.getMethodIDOf(
      _classRef, "openWrite", "(Ljava/lang/String;JJ)Ljava/io/OutputStream;");

  /// from: public java.io.OutputStream openWrite(java.lang.String name, long offsetBytes, long lengthBytes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a stream to write an APK file into the session.
  ///
  /// The returned stream will start writing data at the requested offset
  /// in the underlying file, which can be used to resume a partially
  /// written file. If a valid file length is specified, the system will
  /// preallocate the underlying disk space to optimize placement on disk.
  /// It's strongly recommended to provide a valid file length when known.
  ///
  /// You can write data into the returned stream, optionally call
  /// \#fsync(OutputStream) as needed to ensure bytes have been
  /// persisted to disk, and then close when finished. All streams must be
  /// closed before calling \#commit(IntentSender).
  ///@param name arbitrary, unique name of your choosing to identify the
  ///            APK being written. You can open a file again for
  ///            additional writes (such as after a reboot) by using the
  ///            same name. This name is only meaningful within the context
  ///            of a single install session.
  /// This value must never be {@code null}.
  ///@param offsetBytes offset into the file to begin writing at, or 0 to
  ///            start at the beginning of the file.
  ///@param lengthBytes total size of the file being written, used to
  ///            preallocate the underlying disk space, or -1 if unknown.
  ///            The system may clear various caches as needed to allocate
  ///            this space.
  ///@throws IOException if trouble opening the file for writing, such as
  ///             lack of disk space or unavailable media.
  ///@throws SecurityException if called after the session has been
  ///             sealed or abandoned
  ///@return This value will never be {@code null}.
  jni.JniObject openWrite(
          jni.JniString name, int offsetBytes, int lengthBytes) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_openWrite,
          jni.JniType.objectType,
          [name.reference, offsetBytes, lengthBytes]).object);

  static final _id_fsync = jniAccessors.getMethodIDOf(
      _classRef, "fsync", "(Ljava/io/OutputStream;)V");

  /// from: public void fsync(java.io.OutputStream out)
  ///
  /// Ensure that any outstanding data for given stream has been committed
  /// to disk. This is only valid for streams returned from
  /// \#openWrite(String, long, long).
  ///@param out This value must never be {@code null}.
  void fsync(jni.JniObject out) => jniAccessors.callMethodWithArgs(
      reference, _id_fsync, jni.JniType.voidType, [out.reference]).check();

  static final _id_getNames = jniAccessors.getMethodIDOf(
      _classRef, "getNames", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getNames()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return all APK names contained in this session.
  ///
  /// This returns all names which have been previously written through
  /// \#openWrite(String, long, long) as part of this session.
  ///@throws SecurityException if called after the session has been
  ///             committed or abandoned.
  ///@return This value will never be {@code null}.
  jni.JniObject getNames() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getNames, jni.JniType.objectType, []).object);

  static final _id_openRead = jniAccessors.getMethodIDOf(
      _classRef, "openRead", "(Ljava/lang/String;)Ljava/io/InputStream;");

  /// from: public java.io.InputStream openRead(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a stream to read an APK file from the session.
  ///
  /// This is only valid for names which have been previously written
  /// through \#openWrite(String, long, long) as part of this
  /// session. For example, this stream may be used to calculate a
  /// MessageDigest of a written APK before committing.
  ///@throws SecurityException if called after the session has been
  ///             committed or abandoned.
  ///@param name This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  jni.JniObject openRead(jni.JniString name) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_openRead, jni.JniType.objectType, [name.reference]).object);

  static final _id_removeSplit = jniAccessors.getMethodIDOf(
      _classRef, "removeSplit", "(Ljava/lang/String;)V");

  /// from: public void removeSplit(java.lang.String splitName)
  ///
  /// Removes a split.
  ///
  /// Split removals occur prior to adding new APKs. If upgrading a feature
  /// split, it is not expected nor desirable to remove the split prior to
  /// upgrading.
  ///
  /// When split removal is bundled with new APKs, the packageName must be
  /// identical.
  ///@param splitName This value must never be {@code null}.
  void removeSplit(jni.JniString splitName) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeSplit,
      jni.JniType.voidType,
      [splitName.reference]).check();

  static final _id_commit = jniAccessors.getMethodIDOf(
      _classRef, "commit", "(Landroid/content/IntentSender;)V");

  /// from: public void commit(android.content.IntentSender statusReceiver)
  ///
  /// Attempt to commit everything staged in this session. This may require
  /// user intervention, and so it may not happen immediately. The final
  /// result of the commit will be reported through the given callback.
  ///
  /// Once this method is called, the session is sealed and no additional
  /// mutations may be performed on the session. If the device reboots
  /// before the session has been finalized, you may commit the session again.
  ///
  /// If the installer is the device owner or the affiliated profile owner, there will be no
  /// user intervention.
  ///@throws SecurityException if streams opened through
  ///             \#openWrite(String, long, long) are still open.
  ///@see android.app.admin.DevicePolicyManager
  ///@param statusReceiver This value must never be {@code null}.
  void commit(intentsender_.IntentSender statusReceiver) =>
      jniAccessors.callMethodWithArgs(reference, _id_commit,
          jni.JniType.voidType, [statusReceiver.reference]).check();

  static final _id_transfer = jniAccessors.getMethodIDOf(
      _classRef, "transfer", "(Ljava/lang/String;)V");

  /// from: public void transfer(java.lang.String packageName)
  ///
  /// Transfer the session to a new owner.
  ///
  /// Only sessions that update the installing app can be transferred.
  ///
  /// After the transfer to a package with a different uid all method calls on the session
  /// will cause SecurityExceptions.
  ///
  /// Once this method is called, the session is sealed and no additional mutations beside
  /// committing it may be performed on the session.
  ///@param packageName The package of the new owner. Needs to hold the INSTALL_PACKAGES
  ///                    permission.
  ///
  /// This value must never be {@code null}.
  ///@throws PackageManager.NameNotFoundException if the new owner could not be found.
  ///@throws SecurityException if called after the session has been committed or abandoned.
  ///@throws SecurityException if the session does not update the original installer
  ///@throws SecurityException if streams opened through
  ///                           \#openWrite(String, long, long) are still open.
  void transfer(jni.JniString packageName) => jniAccessors.callMethodWithArgs(
      reference,
      _id_transfer,
      jni.JniType.voidType,
      [packageName.reference]).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Release this session object. You can open the session again if it
  /// hasn't been finalized.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_abandon =
      jniAccessors.getMethodIDOf(_classRef, "abandon", "()V");

  /// from: public void abandon()
  ///
  /// Completely abandon this session, destroying all staged data and
  /// rendering it invalid. Abandoned sessions will be reported to
  /// SessionCallback listeners as failures. This is equivalent to
  /// opening the session and calling Session\#abandon().
  void abandon() => jniAccessors.callMethodWithArgs(
      reference, _id_abandon, jni.JniType.voidType, []).check();
}
