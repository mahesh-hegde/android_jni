// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "ShortcutInfo.dart" as shortcutinfo_;

import "../IntentSender.dart" as intentsender_;

import "../Intent.dart" as intent_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.pm.ShortcutManager
///
/// The ShortcutManager performs operations on an app's set of _shortcuts_. The
/// ShortcutInfo class contains information about each of the shortcuts themselves.
///
/// An app's shortcuts represent specific tasks and actions that users can perform within your
/// app. When a user selects a shortcut in the currently-active launcher, your app opens an activity
/// other than the app's starting activity, provided that the currently-active launcher supports app
/// shortcuts.
///
///
/// The types of shortcuts that you create for your app depend on the app's key use cases. For
/// example, an email app may publish the "compose new email" shortcut, which allows the app to
/// directly open the compose activity.
///
///
/// <p class="note">__Note:__ Only main activities&mdash;activities that handle the
/// Intent\#ACTION_MAIN action and the Intent\#CATEGORY_LAUNCHER category&mdash;can
/// have shortcuts. If an app has multiple main activities, you need to define the set of shortcuts
/// for _each_ activity.
///
/// This page discusses the implementation details of the <code>ShortcutManager</code> class. For
/// definitions of key terms and guidance on performing operations on shortcuts within your app, see
/// the <a href="/guide/topics/ui/shortcuts.html">App Shortcuts</a> feature guide.
///
/// <h3>Shortcut characteristics</h3>
///
/// This section describes in-depth details about each shortcut type's usage and availability.
///
/// <p class="note">__Important security note:__ All shortcut information is stored in
/// <a href="/training/articles/direct-boot.html">credential encrypted storage</a>, so your app
/// cannot access a user's shortcuts until after they've unlocked the device.
///
/// <h4>Static and dynamic shortcuts</h4>
///
/// Static shortcuts and dynamic shortcuts are shown in a supported launcher when the user
/// performs a specific gesture. On currently-supported launchers, the gesture is a long-press on the
/// app's launcher icon, but the actual gesture may be different on other launcher apps.
///
/// The LauncherApps class provides APIs for launcher apps to access shortcuts.
///
/// <h4>Pinned shortcuts</h4>
///
/// Because pinned shortcuts appear in the launcher itself, they're always visible. A pinned
/// shortcut is removed from the launcher only in the following situations:
/// <ul>
///     <li>The user removes it.
///     <li>The publisher app associated with the shortcut is uninstalled.
///     <li>The user selects __Clear data__ from the publisher app's <i>Storage</i> screen, within
///     the system's __Settings__ app.
/// </ul>
///
/// Because the system performs
/// <a href="/guide/topics/ui/shortcuts.html\#backup-and-restore">backup and restore</a> on pinned
/// shortcuts automatically, these shortcuts' IDs should contain either stable, constant strings or
/// server-side identifiers, rather than identifiers generated locally that might not make sense on
/// other devices.
///
/// <h3>Shortcut display order</h3>
///
/// When the launcher displays an app's shortcuts, they should appear in the following order:
///
/// <ol>
///   <li>__Static shortcuts:__ Shortcuts whose ShortcutInfo\#isDeclaredInManifest() method
///   returns {@code true}.</li>
///   <li>__Dynamic shortcuts:__ Shortcuts whose ShortcutInfo\#isDynamic() method returns
///   {@code true}.</li>
/// </ol>
///
/// Within each shortcut type (static and dynamic), shortcuts are sorted in order of increasing
/// rank according to ShortcutInfo\#getRank().
///
///
/// <h4>Shortcut ranks</h4>
///
/// Shortcut ranks are non-negative, sequential integers that determine the order in which
/// shortcuts appear, assuming that the shortcuts are all in the same category. You can update ranks
/// of existing shortcuts when you call \#updateShortcuts(List),
/// \#addDynamicShortcuts(List), or \#setDynamicShortcuts(List).
///
/// <p class="note">__Note:__ Ranks are auto-adjusted so that they're unique for each type of
/// shortcut (static or dynamic). For example, if there are 3 dynamic shortcuts with ranks 0, 1 and
/// 2, adding another dynamic shortcut with a rank of 1 represents a request to place this shortcut
/// at the second position. In response, the third and fourth shortcuts move closer to the bottom of
/// the shortcut list, with their ranks changing to 2 and 3, respectively.
///
/// <h3>Options for static shortcuts</h3>
///
/// The following list includes descriptions for the different attributes within a static shortcut.
/// You must provide a value for {@code android:shortcutId} and {@code android:shortcutShortLabel};
/// all other values are optional.
///
/// <dl>
///   <dt>{@code android:shortcutId}</dt>
///   <dd>A string literal, which represents the shortcut when a {@code ShortcutManager} object
///   performs operations on it.
///
///   <p class="note">__Note: __You cannot set this attribute's value to a resource string, such
///   as <code>@string/foo</code>.
///
///   </dd>
///
///   <dt>{@code android:enabled}</dt>
///   <dd>Whether the user can interact with the shortcut from a supported launcher.
///
///   The default value is {@code true}. If you set it to {@code false}, you should also set
///   {@code android:shortcutDisabledMessage} to a message that explains why you've disabled the
///   shortcut. If you don't think you need to provide such a message, it's easiest to just remove
///   the shortcut from the XML file entirely, rather than changing the values of the shortcut's
///   {@code android:enabled} and {@code android:shortcutDisabledMessage} attributes.
///   </dd>
///
///   <dt>{@code android:icon}</dt>
///   <dd>The <a href="/topic/performance/graphics/index.html">bitmap</a> or
///   <a href="/guide/practices/ui_guidelines/icon_design_adaptive.html">adaptive icon</a> that the
///   launcher uses when displaying the shortcut to the user. This value can be either the path to an
///   image or the resource file that contains the image. Use adaptive icons whenever possible to
///   improve performance and consistency.
///
///   <p class="note">__Note: __Shortcut icons cannot include
///   <a href="/training/material/drawables.html\#DrawableTint">tints</a>.
///   </dd>
///
///   <dt>{@code android:shortcutShortLabel}</dt>
///   <dd>A concise phrase that describes the shortcut's purpose. For more information, see
///   ShortcutInfo.Builder\#setShortLabel(CharSequence).
///
///   <p class="note">__Note: __This attribute's value must be a resource string, such as
///   <code>@string/shortcut_short_label</code>.
///
///   </dd>
///
///   <dt>{@code android:shortcutLongLabel}</dt>
///   <dd>An extended phrase that describes the shortcut's purpose. If there's enough space, the
///   launcher displays this value instead of {@code android:shortcutShortLabel}. For more
///   information, see ShortcutInfo.Builder\#setLongLabel(CharSequence).
///
///   <p class="note">__Note: __This attribute's value must be a resource string, such as
///   <code>@string/shortcut_long_label</code>.
///
///   </dd>
///
///   <dt>{@code android:shortcutDisabledMessage}</dt>
///   <dd>The message that appears in a supported launcher when the user attempts to launch a
///   disabled shortcut. The message should explain to the user why the shortcut is now disabled.
///   This attribute's value has no effect if {@code android:enabled} is {@code true}.
///
///   <p class="note">__Note: __This attribute's value must be a resource string, such as
///   <code>@string/shortcut_disabled_message</code>.
///
///   </dd>
/// </dl>
///
/// <h3>Inner elements that define static shortcuts</h3>
///
/// The XML file that lists an app's static shortcuts supports the following elements inside each
/// {@code <shortcut>} element. You must include an {@code intent} inner element for each
/// static shortcut that you define.
///
///
/// <dl>
///   <dt>{@code intent}</dt>
///   <dd>The action that the system launches when the user selects the shortcut. This intent must
///   provide a value for the {@code android:action} attribute.
///
///   You can provide multiple intents for a single shortcut. If you do so, the last defined
///   activity is launched, and the other activities are placed in the
///   <a href="/guide/components/tasks-and-back-stack.html">back stack</a>. See
///   <a href="/guide/topics/ui/shortcuts.html\#static">Using Static Shortcuts</a> and the
///   android.app.TaskStackBuilder class reference for details.
///
///   <p class="note">__Note:__ This {@code intent} element cannot include string resources.
///
///   To learn more about how to configure intents, see
///   <a href="{@docRoot}guide/topics/ui/settings.html\#Intents">Using intents</a>.
///
///   </dd>
///
///   <dt>{@code categories}</dt>
///   <dd>Provides a grouping for the types of actions that your app's shortcuts perform, such as
///   creating new chat messages.
///
///   For a list of supported shortcut categories, see the ShortcutInfo class reference
///   for a list of supported shortcut categories.
///   </dd>
/// </dl>
///
/// <h3>Updating shortcuts</h3>
///
/// Each app's launcher icon can contain at most \#getMaxShortcutCountPerActivity() number
/// of static and dynamic shortcuts combined. There is no limit to the number of pinned shortcuts
/// that an app can create, though.
///
/// When a dynamic shortcut is pinned, even when the publisher removes it as a dynamic shortcut,
/// the pinned shortcut is still visible and launchable.  This allows an app to have more than
/// \#getMaxShortcutCountPerActivity() number of shortcuts.
///
/// As an example, suppose \#getMaxShortcutCountPerActivity() is 5:
/// <ol>
///     <li>A chat app publishes 5 dynamic shortcuts for the 5 most recent
///     conversations (c1, c2, ..., c5).
///
///     <li>The user pins all 5 of the shortcuts.
///
///     <li>Later, the user has started 3 additional conversations (c6, c7, and c8), so the publisher
///     app re-publishes its dynamic shortcuts. The new dynamic shortcut list is: c4, c5, ..., c8.
///     The publisher app has to remove c1, c2, and c3 because it can't have more than 5 dynamic
///     shortcuts. However, c1, c2, and c3 are still pinned shortcuts that the user can access and
///     launch.
///     At this point, the user can access a total of 8 shortcuts that link to activities in the
///     publisher app, including the 3 pinned shortcuts, even though an app can have at most 5
///     dynamic shortcuts.
///
///     <li>The app can use \#updateShortcuts(List) to update _any_ of the existing
///     8 shortcuts, when, for example, the chat peers' icons have changed.
///     The \#addDynamicShortcuts(List) and \#setDynamicShortcuts(List) methods
///     can also be used to update existing shortcuts with the same IDs, but they __cannot__ be
///     used for updating non-dynamic, pinned shortcuts because these 2 methods try to convert the
///     given lists of shortcuts to dynamic shortcuts.
/// </ol>
///
/// <h3>Shortcut intents</h3>
///
///
/// Dynamic shortcuts can be published with any set of Intent\#addFlags Intent flags.
/// Typically, Intent\#FLAG_ACTIVITY_CLEAR_TASK is specified, possibly along with other
/// flags; otherwise, if the app is already running, the app is simply brought to
/// the foreground, and the target activity might not appear.
///
/// Static shortcuts __cannot__ have custom intent flags.
/// The first intent of a static shortcut will always have Intent\#FLAG_ACTIVITY_NEW_TASK
/// and Intent\#FLAG_ACTIVITY_CLEAR_TASK set. This means, when the app is already running, all
/// the existing activities in your app are destroyed when a static shortcut is launched.
/// If this behavior is not desirable, you can use a _trampoline activity_, or an invisible
/// activity that starts another activity in Activity\#onCreate, then calls
/// Activity\#finish():
/// <ol>
///     <li>In the <code>AndroidManifest.xml</code> file, the trampoline activity should include the
///     attribute assignment {@code android:taskAffinity=""}.
///     <li>In the shortcuts resource file, the intent within the static shortcut should reference
///     the trampoline activity.
/// </ol>
///
/// <h3>Rate limiting</h3>
///
/// When <a href="/guide/topics/ui/shortcuts.html\#rate-limit">rate limiting</a> is active,
/// \#isRateLimitingActive() returns {@code true}.
///
/// Rate limiting is reset upon certain events, so even background apps can call these APIs until
/// the rate limit is reached again. These events include the following:
/// <ul>
///   <li>An app comes to the foreground.
///   <li>The system locale changes.
///   <li>The user performs the <a href="/guide/topics/ui/notifiers/notifications.html\#direct">inline
///   reply</a> action on a notification.
/// </ul>
///
/// <h3>Handling system locale changes</h3>
///
/// Apps should update dynamic and pinned shortcuts when they receive the
/// Intent\#ACTION_LOCALE_CHANGED broadcast, indicating that the system locale has changed.
/// When the system locale changes, <a href="/guide/topics/ui/shortcuts.html\#rate-limit">rate
/// limiting</a> is reset, so even background apps can add and update dynamic shortcuts until the
/// rate limit is reached again.
///
/// <h3>Retrieving class instances</h3>
/// <!-- Provides a heading for the content filled in by the @SystemService annotation below -->
class ShortcutManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/pm/ShortcutManager");
  ShortcutManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_setDynamicShortcuts = jniAccessors.getMethodIDOf(
      _classRef, "setDynamicShortcuts", "(Ljava/util/List;)Z");

  /// from: public boolean setDynamicShortcuts(java.util.List<android.content.pm.ShortcutInfo> shortcutInfoList)
  ///
  /// Publish the list of shortcuts.  All existing dynamic shortcuts from the caller app
  /// will be replaced.  If there are already pinned shortcuts with the same IDs,
  /// the mutable pinned shortcuts are updated.
  ///
  /// This API will be rate-limited.
  ///@param shortcutInfoList This value must never be {@code null}.
  ///@return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
  ///@throws IllegalArgumentException if \#getMaxShortcutCountPerActivity() is exceeded,
  /// or when trying to update immutable shortcuts.
  ///@throws IllegalStateException when the user is locked.
  bool setDynamicShortcuts(jni.JniObject shortcutInfoList) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDynamicShortcuts,
          jni.JniType.booleanType, [shortcutInfoList.reference]).boolean;

  static final _id_getDynamicShortcuts = jniAccessors.getMethodIDOf(
      _classRef, "getDynamicShortcuts", "()Ljava/util/List;");

  /// from: public java.util.List<android.content.pm.ShortcutInfo> getDynamicShortcuts()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return all dynamic shortcuts from the caller app.
  ///
  /// This API is intended to be used for examining what shortcuts are currently published.
  /// Re-publishing returned ShortcutInfos via APIs such as
  /// \#setDynamicShortcuts(List) may cause loss of information such as icons.
  ///@throws IllegalStateException when the user is locked.
  ///@return This value will never be {@code null}.
  jni.JniObject getDynamicShortcuts() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDynamicShortcuts, jni.JniType.objectType, []).object);

  static final _id_getManifestShortcuts = jniAccessors.getMethodIDOf(
      _classRef, "getManifestShortcuts", "()Ljava/util/List;");

  /// from: public java.util.List<android.content.pm.ShortcutInfo> getManifestShortcuts()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return all static (manifest) shortcuts from the caller app.
  ///
  /// This API is intended to be used for examining what shortcuts are currently published.
  /// Re-publishing returned ShortcutInfos via APIs such as
  /// \#setDynamicShortcuts(List) may cause loss of information such as icons.
  ///@throws IllegalStateException when the user is locked.
  ///@return This value will never be {@code null}.
  jni.JniObject getManifestShortcuts() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getManifestShortcuts, jni.JniType.objectType, []).object);

  static final _id_addDynamicShortcuts = jniAccessors.getMethodIDOf(
      _classRef, "addDynamicShortcuts", "(Ljava/util/List;)Z");

  /// from: public boolean addDynamicShortcuts(java.util.List<android.content.pm.ShortcutInfo> shortcutInfoList)
  ///
  /// Publish the list of dynamic shortcuts.  If there are already dynamic or pinned shortcuts with
  /// the same IDs, each mutable shortcut is updated.
  ///
  /// This API will be rate-limited.
  ///@param shortcutInfoList This value must never be {@code null}.
  ///@return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
  ///@throws IllegalArgumentException if \#getMaxShortcutCountPerActivity() is exceeded,
  /// or when trying to update immutable shortcuts.
  ///@throws IllegalStateException when the user is locked.
  bool addDynamicShortcuts(jni.JniObject shortcutInfoList) =>
      jniAccessors.callMethodWithArgs(reference, _id_addDynamicShortcuts,
          jni.JniType.booleanType, [shortcutInfoList.reference]).boolean;

  static final _id_removeDynamicShortcuts = jniAccessors.getMethodIDOf(
      _classRef, "removeDynamicShortcuts", "(Ljava/util/List;)V");

  /// from: public void removeDynamicShortcuts(java.util.List<java.lang.String> shortcutIds)
  ///
  /// Delete dynamic shortcuts by ID.
  ///@throws IllegalStateException when the user is locked.
  ///@param shortcutIds This value must never be {@code null}.
  void removeDynamicShortcuts(jni.JniObject shortcutIds) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeDynamicShortcuts,
          jni.JniType.voidType, [shortcutIds.reference]).check();

  static final _id_removeAllDynamicShortcuts =
      jniAccessors.getMethodIDOf(_classRef, "removeAllDynamicShortcuts", "()V");

  /// from: public void removeAllDynamicShortcuts()
  ///
  /// Delete all dynamic shortcuts from the caller app.
  ///@throws IllegalStateException when the user is locked.
  void removeAllDynamicShortcuts() => jniAccessors.callMethodWithArgs(reference,
      _id_removeAllDynamicShortcuts, jni.JniType.voidType, []).check();

  static final _id_getPinnedShortcuts = jniAccessors.getMethodIDOf(
      _classRef, "getPinnedShortcuts", "()Ljava/util/List;");

  /// from: public java.util.List<android.content.pm.ShortcutInfo> getPinnedShortcuts()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return all pinned shortcuts from the caller app.
  ///
  /// This API is intended to be used for examining what shortcuts are currently published.
  /// Re-publishing returned ShortcutInfos via APIs such as
  /// \#setDynamicShortcuts(List) may cause loss of information such as icons.
  ///@throws IllegalStateException when the user is locked.
  ///@return This value will never be {@code null}.
  jni.JniObject getPinnedShortcuts() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getPinnedShortcuts, jni.JniType.objectType, []).object);

  static final _id_updateShortcuts = jniAccessors.getMethodIDOf(
      _classRef, "updateShortcuts", "(Ljava/util/List;)Z");

  /// from: public boolean updateShortcuts(java.util.List<android.content.pm.ShortcutInfo> shortcutInfoList)
  ///
  /// Update all existing shortcuts with the same IDs.  Target shortcuts may be pinned and/or
  /// dynamic, but they must not be immutable.
  ///
  /// This API will be rate-limited.
  ///@param shortcutInfoList This value must never be {@code null}.
  ///@return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
  ///@throws IllegalArgumentException If trying to update immutable shortcuts.
  ///@throws IllegalStateException when the user is locked.
  bool updateShortcuts(jni.JniObject shortcutInfoList) =>
      jniAccessors.callMethodWithArgs(reference, _id_updateShortcuts,
          jni.JniType.booleanType, [shortcutInfoList.reference]).boolean;

  static final _id_disableShortcuts = jniAccessors.getMethodIDOf(
      _classRef, "disableShortcuts", "(Ljava/util/List;)V");

  /// from: public void disableShortcuts(java.util.List<java.lang.String> shortcutIds)
  ///
  /// Disable pinned shortcuts.  For more details, see the Javadoc for the ShortcutManager
  /// class.
  ///@throws IllegalArgumentException If trying to disable immutable shortcuts.
  ///@throws IllegalStateException when the user is locked.
  ///@param shortcutIds This value must never be {@code null}.
  void disableShortcuts(jni.JniObject shortcutIds) =>
      jniAccessors.callMethodWithArgs(reference, _id_disableShortcuts,
          jni.JniType.voidType, [shortcutIds.reference]).check();

  static final _id_disableShortcuts1 = jniAccessors.getMethodIDOf(_classRef,
      "disableShortcuts", "(Ljava/util/List;Ljava/lang/CharSequence;)V");

  /// from: public void disableShortcuts(java.util.List<java.lang.String> shortcutIds, java.lang.CharSequence disabledMessage)
  ///
  /// Disable pinned shortcuts, showing the user a custom error message when they try to select
  /// the disabled shortcuts.
  /// For more details, see the Javadoc for the ShortcutManager class.
  ///@throws IllegalArgumentException If trying to disable immutable shortcuts.
  ///@throws IllegalStateException when the user is locked.
  ///@param shortcutIds This value must never be {@code null}.
  void disableShortcuts1(
          jni.JniObject shortcutIds, jni.JniObject disabledMessage) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_disableShortcuts1,
          jni.JniType.voidType,
          [shortcutIds.reference, disabledMessage.reference]).check();

  static final _id_enableShortcuts = jniAccessors.getMethodIDOf(
      _classRef, "enableShortcuts", "(Ljava/util/List;)V");

  /// from: public void enableShortcuts(java.util.List<java.lang.String> shortcutIds)
  ///
  /// Re-enable pinned shortcuts that were previously disabled.  If the target shortcuts
  /// are already enabled, this method does nothing.
  ///@throws IllegalArgumentException If trying to enable immutable shortcuts.
  ///@throws IllegalStateException when the user is locked.
  ///@param shortcutIds This value must never be {@code null}.
  void enableShortcuts(jni.JniObject shortcutIds) =>
      jniAccessors.callMethodWithArgs(reference, _id_enableShortcuts,
          jni.JniType.voidType, [shortcutIds.reference]).check();

  static final _id_getMaxShortcutCountPerActivity = jniAccessors.getMethodIDOf(
      _classRef, "getMaxShortcutCountPerActivity", "()I");

  /// from: public int getMaxShortcutCountPerActivity()
  ///
  /// Return the maximum number of static and dynamic shortcuts that each launcher icon
  /// can have at a time.
  int getMaxShortcutCountPerActivity() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getMaxShortcutCountPerActivity,
      jni.JniType.intType, []).integer;

  static final _id_isRateLimitingActive =
      jniAccessors.getMethodIDOf(_classRef, "isRateLimitingActive", "()Z");

  /// from: public boolean isRateLimitingActive()
  ///
  /// Return {@code true} when rate-limiting is active for the caller app.
  ///
  /// See the class level javadoc for details.
  ///@throws IllegalStateException when the user is locked.
  bool isRateLimitingActive() => jniAccessors.callMethodWithArgs(
      reference, _id_isRateLimitingActive, jni.JniType.booleanType, []).boolean;

  static final _id_getIconMaxWidth =
      jniAccessors.getMethodIDOf(_classRef, "getIconMaxWidth", "()I");

  /// from: public int getIconMaxWidth()
  ///
  /// Return the max width for icons, in pixels.
  ///
  ///  Note that this method returns max width of icon's visible part. Hence, it does not take
  /// into account the inset introduced by AdaptiveIconDrawable. To calculate bitmap image
  /// to function as AdaptiveIconDrawable, multiply
  /// 1 + 2 * AdaptiveIconDrawable\#getExtraInsetFraction() to the returned size.
  int getIconMaxWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getIconMaxWidth, jni.JniType.intType, []).integer;

  static final _id_getIconMaxHeight =
      jniAccessors.getMethodIDOf(_classRef, "getIconMaxHeight", "()I");

  /// from: public int getIconMaxHeight()
  ///
  /// Return the max height for icons, in pixels.
  int getIconMaxHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getIconMaxHeight, jni.JniType.intType, []).integer;

  static final _id_reportShortcutUsed = jniAccessors.getMethodIDOf(
      _classRef, "reportShortcutUsed", "(Ljava/lang/String;)V");

  /// from: public void reportShortcutUsed(java.lang.String shortcutId)
  ///
  /// Apps that publish shortcuts should call this method whenever the user
  /// selects the shortcut containing the given ID or when the user completes
  /// an action in the app that is equivalent to selecting the shortcut.
  /// For more details, see the Javadoc for the ShortcutManager class
  ///
  /// The information is accessible via UsageStatsManager\#queryEvents
  /// Typically, launcher apps use this information to build a prediction model
  /// so that they can promote the shortcuts that are likely to be used at the moment.
  ///@throws IllegalStateException when the user is locked.
  void reportShortcutUsed(jni.JniString shortcutId) =>
      jniAccessors.callMethodWithArgs(reference, _id_reportShortcutUsed,
          jni.JniType.voidType, [shortcutId.reference]).check();

  static final _id_isRequestPinShortcutSupported = jniAccessors.getMethodIDOf(
      _classRef, "isRequestPinShortcutSupported", "()Z");

  /// from: public boolean isRequestPinShortcutSupported()
  ///
  /// Return {@code TRUE} if the app is running on a device whose default launcher supports
  /// \#requestPinShortcut(ShortcutInfo, IntentSender).
  ///
  /// The return value may change in subsequent calls if the user changes the default launcher
  /// app.
  ///
  /// __Note:__ See also the support library counterpart
  /// android.support.v4.content.pm.ShortcutManagerCompat\#isRequestPinShortcutSupported(
  /// Context), which supports Android versions lower than VERSION_CODES\#O using the
  /// legacy private intent {@code com.android.launcher.action.INSTALL_SHORTCUT}.
  ///@see \#requestPinShortcut(ShortcutInfo, IntentSender)
  bool isRequestPinShortcutSupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isRequestPinShortcutSupported,
      jni.JniType.booleanType, []).boolean;

  static final _id_requestPinShortcut = jniAccessors.getMethodIDOf(
      _classRef,
      "requestPinShortcut",
      "(Landroid/content/pm/ShortcutInfo;Landroid/content/IntentSender;)Z");

  /// from: public boolean requestPinShortcut(android.content.pm.ShortcutInfo shortcut, android.content.IntentSender resultIntent)
  ///
  /// Request to create a pinned shortcut.  The default launcher will receive this request and
  /// ask the user for approval.  If the user approves it, the shortcut will be created, and
  /// {@code resultIntent} will be sent. If a request is denied by the user, however, no response
  /// will be sent to the caller.
  ///
  /// Only apps with a foreground activity or a foreground service can call this method.
  /// Otherwise, it'll throw IllegalStateException.
  ///
  /// It's up to the launcher to decide how to handle previous pending requests when the same
  /// package calls this API multiple times in a row. One possible strategy is to ignore any
  /// previous requests.
  ///
  /// __Note:__ See also the support library counterpart
  /// android.support.v4.content.pm.ShortcutManagerCompat\#requestPinShortcut(
  /// Context, ShortcutInfoCompat, IntentSender),
  /// which supports Android versions lower than VERSION_CODES\#O using the
  /// legacy private intent {@code com.android.launcher.action.INSTALL_SHORTCUT}.
  ///@param shortcut Shortcut to pin.  If an app wants to pin an existing (either static
  ///     or dynamic) shortcut, then it only needs to have an ID. Although other fields don't have
  ///     to be set, the target shortcut must be enabled.
  ///
  ///     If it's a new shortcut, all the mandatory fields, such as a short label, must be
  ///     set.
  /// This value must never be {@code null}.
  ///@param resultIntent If not null, this intent will be sent when the shortcut is pinned.
  ///    Use android.app.PendingIntent\#getIntentSender() to create an IntentSender.
  ///    To avoid background execution limits, use an unexported, manifest-declared receiver.
  ///    For more details, see the overview documentation for the ShortcutManager class.
  ///
  /// This value may be {@code null}.
  ///@return {@code TRUE} if the launcher supports this feature.  Note the API will return without
  ///    waiting for the user to respond, so getting {@code TRUE} from this API does *not* mean
  ///    the shortcut was pinned successfully.  {@code FALSE} if the launcher doesn't support this
  ///    feature.
  ///@see \#isRequestPinShortcutSupported()
  ///@see IntentSender
  ///@see android.app.PendingIntent\#getIntentSender()
  ///@throws IllegalArgumentException if a shortcut with the same ID exists and is disabled.
  ///@throws IllegalStateException The caller doesn't have a foreground activity or a foreground
  /// service, or the device is locked.
  bool requestPinShortcut(shortcutinfo_.ShortcutInfo shortcut,
          intentsender_.IntentSender resultIntent) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestPinShortcut,
          jni.JniType.booleanType,
          [shortcut.reference, resultIntent.reference]).boolean;

  static final _id_createShortcutResultIntent = jniAccessors.getMethodIDOf(
      _classRef,
      "createShortcutResultIntent",
      "(Landroid/content/pm/ShortcutInfo;)Landroid/content/Intent;");

  /// from: public android.content.Intent createShortcutResultIntent(android.content.pm.ShortcutInfo shortcut)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an Intent which can be used by the default launcher to pin a shortcut containing the
  /// given ShortcutInfo. This method should be used by an Activity to set a result in
  /// response to Intent\#ACTION_CREATE_SHORTCUT.
  ///@param shortcut New shortcut to pin.  If an app wants to pin an existing (either dynamic
  ///     or manifest) shortcut, then it only needs to have an ID, and other fields don't have to
  ///     be set, in which case, the target shortcut must be enabled.
  ///     If it's a new shortcut, all the mandatory fields, such as a short label, must be
  ///     set.
  /// This value must never be {@code null}.
  ///@return The intent that should be set as the result for the calling activity, or
  ///     <code>null</code> if the current launcher doesn't support shortcuts.
  ///@see Intent\#ACTION_CREATE_SHORTCUT
  ///@throws IllegalArgumentException if a shortcut with the same ID exists and is disabled.
  intent_.Intent createShortcutResultIntent(
          shortcutinfo_.ShortcutInfo shortcut) =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createShortcutResultIntent,
          jni.JniType.objectType,
          [shortcut.reference]).object);
}
