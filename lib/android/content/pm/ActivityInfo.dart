// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "ComponentInfo.dart" as componentinfo_;

import "../../os/Parcelable.dart" as parcelable_;

import "../../util/Printer.dart" as printer_;

import "../../os/Parcel.dart" as parcel_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.pm.ActivityInfo
///
/// Information you can retrieve about a particular application
/// activity or receiver. This corresponds to information collected
/// from the AndroidManifest.xml's &lt;activity&gt; and
/// &lt;receiver&gt; tags.
class ActivityInfo extends componentinfo_.ComponentInfo {
  static final _classRef =
      jniAccessors.getClassOf("android/content/pm/ActivityInfo");
  ActivityInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int COLOR_MODE_DEFAULT
  ///
  /// Value for \#colorMode indicating that the activity should use the
  /// default color mode (sRGB, low dynamic range).
  ///@see android.R.attr\#colorMode
  static const COLOR_MODE_DEFAULT = 0;

  /// from: static public final int COLOR_MODE_HDR
  ///
  /// Value of \#colorMode indicating that the activity should use a
  /// high dynamic range if the presentation display supports it.
  ///@see android.R.attr\#colorMode
  static const COLOR_MODE_HDR = 2;

  /// from: static public final int COLOR_MODE_WIDE_COLOR_GAMUT
  ///
  /// Value of \#colorMode indicating that the activity should use a
  /// wide color gamut if the presentation display supports it.
  ///@see android.R.attr\#colorMode
  static const COLOR_MODE_WIDE_COLOR_GAMUT = 1;

  /// from: static public final int CONFIG_COLOR_MODE
  ///
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle the change to the display color gamut or dynamic
  /// range. Set from the android.R.attr\#configChanges attribute.
  static const CONFIG_COLOR_MODE = 16384;

  /// from: static public final int CONFIG_DENSITY
  ///
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle density changes. Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_DENSITY = 4096;

  /// from: static public final int CONFIG_FONT_SCALE
  ///
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the font scaling factor.  Set from the
  /// android.R.attr\#configChanges attribute.  This is
  /// not a core resource configuration, but a higher-level value, so its
  /// constant starts at the high bits.
  static const CONFIG_FONT_SCALE = 1073741824;

  /// from: static public final int CONFIG_KEYBOARD
  ///
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the keyboard type.  Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_KEYBOARD = 16;

  /// from: static public final int CONFIG_KEYBOARD_HIDDEN
  ///
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the keyboard or navigation being hidden/exposed.
  /// Note that inspite of the name, this applies to the changes to any
  /// hidden states: keyboard or navigation.
  /// Set from the android.R.attr\#configChanges attribute.
  static const CONFIG_KEYBOARD_HIDDEN = 32;

  /// from: static public final int CONFIG_LAYOUT_DIRECTION
  ///
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle the change to layout direction. Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_LAYOUT_DIRECTION = 8192;

  /// from: static public final int CONFIG_LOCALE
  ///
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the locale.  Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_LOCALE = 4;

  /// from: static public final int CONFIG_MCC
  ///
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the IMSI MCC.  Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_MCC = 1;

  /// from: static public final int CONFIG_MNC
  ///
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the IMSI MNC.  Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_MNC = 2;

  /// from: static public final int CONFIG_NAVIGATION
  ///
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the navigation type.  Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_NAVIGATION = 64;

  /// from: static public final int CONFIG_ORIENTATION
  ///
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the screen orientation.  Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_ORIENTATION = 128;

  /// from: static public final int CONFIG_SCREEN_LAYOUT
  ///
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the screen layout.  Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_SCREEN_LAYOUT = 256;

  /// from: static public final int CONFIG_SCREEN_SIZE
  ///
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle the screen size. Set from the
  /// android.R.attr\#configChanges attribute.  This will be
  /// set by default for applications that target an earlier version
  /// than android.os.Build.VERSION_CODES\#HONEYCOMB_MR2...
  /// __however__, you will not see the bit set here becomes some
  /// applications incorrectly compare \#configChanges against
  /// an absolute value rather than correctly masking out the bits
  /// they are interested in.  Please don't do that, thanks.
  static const CONFIG_SCREEN_SIZE = 1024;

  /// from: static public final int CONFIG_SMALLEST_SCREEN_SIZE
  ///
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle the smallest screen size. Set from the
  /// android.R.attr\#configChanges attribute.  This will be
  /// set by default for applications that target an earlier version
  /// than android.os.Build.VERSION_CODES\#HONEYCOMB_MR2...
  /// __however__, you will not see the bit set here becomes some
  /// applications incorrectly compare \#configChanges against
  /// an absolute value rather than correctly masking out the bits
  /// they are interested in.  Please don't do that, thanks.
  static const CONFIG_SMALLEST_SCREEN_SIZE = 2048;

  /// from: static public final int CONFIG_TOUCHSCREEN
  ///
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the touchscreen type.  Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_TOUCHSCREEN = 8;

  /// from: static public final int CONFIG_UI_MODE
  ///
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle the ui mode. Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_UI_MODE = 512;

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.ActivityInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int DOCUMENT_LAUNCH_ALWAYS
  ///
  /// Constant corresponding to <code>always</code> in
  /// the android.R.attr\#documentLaunchMode attribute.
  static const DOCUMENT_LAUNCH_ALWAYS = 2;

  /// from: static public final int DOCUMENT_LAUNCH_INTO_EXISTING
  ///
  /// Constant corresponding to <code>intoExisting</code> in
  /// the android.R.attr\#documentLaunchMode attribute.
  static const DOCUMENT_LAUNCH_INTO_EXISTING = 1;

  /// from: static public final int DOCUMENT_LAUNCH_NEVER
  ///
  /// Constant corresponding to <code>never</code> in
  /// the android.R.attr\#documentLaunchMode attribute.
  static const DOCUMENT_LAUNCH_NEVER = 3;

  /// from: static public final int DOCUMENT_LAUNCH_NONE
  ///
  /// Constant corresponding to <code>none</code> in
  /// the android.R.attr\#documentLaunchMode attribute.
  static const DOCUMENT_LAUNCH_NONE = 0;

  /// from: static public final int FLAG_ALLOW_TASK_REPARENTING
  ///
  /// Bit in \#flags that indicates that the activity can be moved
  /// between tasks based on its task affinity.  Set from the
  /// android.R.attr\#allowTaskReparenting attribute.
  static const FLAG_ALLOW_TASK_REPARENTING = 64;

  /// from: static public final int FLAG_ALWAYS_RETAIN_TASK_STATE
  ///
  /// Bit in \#flags indicating that, when the activity is the root
  /// of a task, that task's stack should never be cleared when it is
  /// relaunched from home.  Set from the
  /// android.R.attr\#alwaysRetainTaskState attribute.
  static const FLAG_ALWAYS_RETAIN_TASK_STATE = 8;

  /// from: static public final int FLAG_AUTO_REMOVE_FROM_RECENTS
  ///
  /// Bit in \#flags indicating that tasks started with this activity are to be
  /// removed from the recent list of tasks when the last activity in the task is finished.
  /// Corresponds to android.R.attr\#autoRemoveFromRecents
  static const FLAG_AUTO_REMOVE_FROM_RECENTS = 8192;

  /// from: static public final int FLAG_CLEAR_TASK_ON_LAUNCH
  ///
  /// Bit in \#flags indicating that, when the activity is the root
  /// of a task, that task's stack should be cleared each time the user
  /// re-launches it from home.  As a result, the user will always
  /// return to the original activity at the top of the task.
  /// This flag only applies to activities that
  /// are used to start the root of a new task.  Set from the
  /// android.R.attr\#clearTaskOnLaunch attribute.
  static const FLAG_CLEAR_TASK_ON_LAUNCH = 4;

  /// from: static public final int FLAG_ENABLE_VR_MODE
  ///
  /// Bit in \#flags indicating that this activity should be run with VR mode enabled.
  ///
  /// {@see android.app.Activity\#setVrMode(boolean)}.
  static const FLAG_ENABLE_VR_MODE = 32768;

  /// from: static public final int FLAG_EXCLUDE_FROM_RECENTS
  ///
  /// Bit in \#flags that indicates that the activity should not
  /// appear in the list of recently launched activities.  Set from the
  /// android.R.attr\#excludeFromRecents attribute.
  static const FLAG_EXCLUDE_FROM_RECENTS = 32;

  /// from: static public final int FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS
  ///
  /// Bit in \#flags indicating that, when a request to close system
  /// windows happens, this activity is finished.
  /// Set from the
  /// android.R.attr\#finishOnCloseSystemDialogs attribute.
  static const FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS = 256;

  /// from: static public final int FLAG_FINISH_ON_TASK_LAUNCH
  ///
  /// Bit in \#flags indicating that, when the activity's task is
  /// relaunched from home, this activity should be finished.
  /// Set from the
  /// android.R.attr\#finishOnTaskLaunch attribute.
  static const FLAG_FINISH_ON_TASK_LAUNCH = 2;

  /// from: static public final int FLAG_HARDWARE_ACCELERATED
  ///
  /// Value for \#flags: true when the application's rendering should
  /// be hardware accelerated.
  static const FLAG_HARDWARE_ACCELERATED = 512;

  /// from: static public final int FLAG_IMMERSIVE
  ///
  /// Bit in \#flags corresponding to an immersive activity
  /// that wishes not to be interrupted by notifications.
  /// Applications that hide the system notification bar with
  /// android.view.WindowManager.LayoutParams\#FLAG_FULLSCREEN
  /// may still be interrupted by high-priority notifications; for example, an
  /// incoming phone call may use
  /// android.app.Notification\#fullScreenIntent fullScreenIntent
  /// to present a full-screen in-call activity to the user, pausing the
  /// current activity as a side-effect. An activity with
  /// \#FLAG_IMMERSIVE set, however, will not be interrupted; the
  /// notification may be shown in some other way (such as a small floating
  /// "toast" window).
  ///
  /// Note that this flag will always reflect the Activity's
  /// <code>android:immersive</code> manifest definition, even if the Activity's
  /// immersive state is changed at runtime via
  /// android.app.Activity\#setImmersive(boolean).
  ///@see android.app.Notification\#FLAG_HIGH_PRIORITY
  ///@see android.app.Activity\#setImmersive(boolean)
  static const FLAG_IMMERSIVE = 2048;

  /// from: static public final int FLAG_MULTIPROCESS
  ///
  /// Bit in \#flags indicating whether this activity is able to
  /// run in multiple processes.  If
  /// true, the system may instantiate it in the some process as the
  /// process starting it in order to conserve resources.  If false, the
  /// default, it always runs in \#processName.  Set from the
  /// android.R.attr\#multiprocess attribute.
  static const FLAG_MULTIPROCESS = 1;

  /// from: static public final int FLAG_NO_HISTORY
  ///
  /// Bit in \#flags indicating that, when the user navigates away
  /// from an activity, it should be finished.
  /// Set from the
  /// android.R.attr\#noHistory attribute.
  static const FLAG_NO_HISTORY = 128;

  /// from: static public final int FLAG_RELINQUISH_TASK_IDENTITY
  ///
  /// Bit in \#flags: If set, a task rooted at this activity will have its
  /// baseIntent replaced by the activity immediately above this. Each activity may further
  /// relinquish its identity to the activity above it using this flag. Set from the
  /// android.R.attr\#relinquishTaskIdentity attribute.
  static const FLAG_RELINQUISH_TASK_IDENTITY = 4096;

  /// from: static public final int FLAG_RESUME_WHILE_PAUSING
  ///
  /// Bit in \#flags indicating that this activity can start is creation/resume
  /// while the previous activity is still pausing.  Corresponds to
  /// android.R.attr\#resumeWhilePausing
  static const FLAG_RESUME_WHILE_PAUSING = 16384;

  /// from: static public final int FLAG_SINGLE_USER
  ///
  /// Bit in \#flags: If set, a single instance of the receiver will
  /// run for all users on the device.  Set from the
  /// android.R.attr\#singleUser attribute.  Note that this flag is
  /// only relevant for ActivityInfo structures that are describing receiver
  /// components; it is not applied to activities.
  static const FLAG_SINGLE_USER = 1073741824;

  /// from: static public final int FLAG_STATE_NOT_NEEDED
  ///
  /// Bit in \#flags indicating that the activity's state
  /// is not required to be saved, so that if there is a failure the
  /// activity will not be removed from the activity stack.  Set from the
  /// android.R.attr\#stateNotNeeded attribute.
  static const FLAG_STATE_NOT_NEEDED = 16;

  /// from: static public final int LAUNCH_MULTIPLE
  ///
  /// Constant corresponding to <code>standard</code> in
  /// the android.R.attr\#launchMode attribute.
  static const LAUNCH_MULTIPLE = 0;

  /// from: static public final int LAUNCH_SINGLE_INSTANCE
  ///
  /// Constant corresponding to <code>singleInstance</code> in
  /// the android.R.attr\#launchMode attribute.
  static const LAUNCH_SINGLE_INSTANCE = 3;

  /// from: static public final int LAUNCH_SINGLE_TASK
  ///
  /// Constant corresponding to <code>singleTask</code> in
  /// the android.R.attr\#launchMode attribute.
  static const LAUNCH_SINGLE_TASK = 2;

  /// from: static public final int LAUNCH_SINGLE_TOP
  ///
  /// Constant corresponding to <code>singleTop</code> in
  /// the android.R.attr\#launchMode attribute.
  static const LAUNCH_SINGLE_TOP = 1;

  /// from: static public final int PERSIST_ACROSS_REBOOTS
  ///
  /// Constant corresponding to <code>persistAcrossReboots</code> in
  /// the android.R.attr\#persistableMode attribute.
  static const PERSIST_ACROSS_REBOOTS = 2;

  /// from: static public final int PERSIST_NEVER
  ///
  /// Constant corresponding to <code>doNotPersist</code> in
  /// the android.R.attr\#persistableMode attribute.
  static const PERSIST_NEVER = 1;

  /// from: static public final int PERSIST_ROOT_ONLY
  ///
  /// Constant corresponding to <code>persistRootOnly</code> in
  /// the android.R.attr\#persistableMode attribute.
  static const PERSIST_ROOT_ONLY = 0;

  /// from: static public final int SCREEN_ORIENTATION_BEHIND
  ///
  /// Constant corresponding to <code>behind</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_BEHIND = 3;

  /// from: static public final int SCREEN_ORIENTATION_FULL_SENSOR
  ///
  /// Constant corresponding to <code>fullSensor</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_FULL_SENSOR = 10;

  /// from: static public final int SCREEN_ORIENTATION_FULL_USER
  ///
  /// Constant corresponding to <code>fullUser</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_FULL_USER = 13;

  /// from: static public final int SCREEN_ORIENTATION_LANDSCAPE
  ///
  /// Constant corresponding to <code>landscape</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_LANDSCAPE = 0;

  /// from: static public final int SCREEN_ORIENTATION_LOCKED
  ///
  /// Constant corresponding to <code>locked</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_LOCKED = 14;

  /// from: static public final int SCREEN_ORIENTATION_NOSENSOR
  ///
  /// Constant corresponding to <code>nosensor</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_NOSENSOR = 5;

  /// from: static public final int SCREEN_ORIENTATION_PORTRAIT
  ///
  /// Constant corresponding to <code>portrait</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_PORTRAIT = 1;

  /// from: static public final int SCREEN_ORIENTATION_REVERSE_LANDSCAPE
  ///
  /// Constant corresponding to <code>reverseLandscape</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_REVERSE_LANDSCAPE = 8;

  /// from: static public final int SCREEN_ORIENTATION_REVERSE_PORTRAIT
  ///
  /// Constant corresponding to <code>reversePortrait</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_REVERSE_PORTRAIT = 9;

  /// from: static public final int SCREEN_ORIENTATION_SENSOR
  ///
  /// Constant corresponding to <code>sensor</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_SENSOR = 4;

  /// from: static public final int SCREEN_ORIENTATION_SENSOR_LANDSCAPE
  ///
  /// Constant corresponding to <code>sensorLandscape</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_SENSOR_LANDSCAPE = 6;

  /// from: static public final int SCREEN_ORIENTATION_SENSOR_PORTRAIT
  ///
  /// Constant corresponding to <code>sensorPortrait</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_SENSOR_PORTRAIT = 7;

  /// from: static public final int SCREEN_ORIENTATION_UNSPECIFIED
  ///
  /// Constant corresponding to <code>unspecified</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_UNSPECIFIED = -1;

  /// from: static public final int SCREEN_ORIENTATION_USER
  ///
  /// Constant corresponding to <code>user</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_USER = 2;

  /// from: static public final int SCREEN_ORIENTATION_USER_LANDSCAPE
  ///
  /// Constant corresponding to <code>userLandscape</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_USER_LANDSCAPE = 11;

  /// from: static public final int SCREEN_ORIENTATION_USER_PORTRAIT
  ///
  /// Constant corresponding to <code>userPortrait</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_USER_PORTRAIT = 12;

  /// from: static public final int UIOPTION_SPLIT_ACTION_BAR_WHEN_NARROW
  ///
  /// Flag for use with \#uiOptions.
  /// Indicates that the action bar should put all action items in a separate bar when
  /// the screen is narrow.
  /// This value corresponds to "splitActionBarWhenNarrow" for the \#uiOptions XML
  /// attribute.
  static const UIOPTION_SPLIT_ACTION_BAR_WHEN_NARROW = 1;

  static final _id_colorMode =
      jniAccessors.getFieldIDOf(_classRef, "colorMode", "I");

  /// from: public int colorMode
  ///
  /// The color mode requested by this activity. The target display may not be
  /// able to honor the request.
  ///
  /// Value is android.content.pm.ActivityInfo\#COLOR_MODE_DEFAULT, android.content.pm.ActivityInfo\#COLOR_MODE_WIDE_COLOR_GAMUT, or android.content.pm.ActivityInfo\#COLOR_MODE_HDR
  int get colorMode => jniAccessors
      .getField(reference, _id_colorMode, jni.JniType.intType)
      .integer;

  /// from: public int colorMode
  ///
  /// The color mode requested by this activity. The target display may not be
  /// able to honor the request.
  ///
  /// Value is android.content.pm.ActivityInfo\#COLOR_MODE_DEFAULT, android.content.pm.ActivityInfo\#COLOR_MODE_WIDE_COLOR_GAMUT, or android.content.pm.ActivityInfo\#COLOR_MODE_HDR
  set colorMode(int value) =>
      jniEnv.SetIntField(reference, _id_colorMode, value);

  static final _id_configChanges =
      jniAccessors.getFieldIDOf(_classRef, "configChanges", "I");

  /// from: public int configChanges
  ///
  /// Bit mask of kinds of configuration changes that this activity
  /// can handle itself (without being restarted by the system).
  /// Contains any combination of \#CONFIG_FONT_SCALE,
  /// \#CONFIG_MCC, \#CONFIG_MNC,
  /// \#CONFIG_LOCALE, \#CONFIG_TOUCHSCREEN,
  /// \#CONFIG_KEYBOARD, \#CONFIG_NAVIGATION,
  /// \#CONFIG_ORIENTATION, \#CONFIG_SCREEN_LAYOUT,
  /// \#CONFIG_DENSITY, \#CONFIG_LAYOUT_DIRECTION and
  /// \#CONFIG_COLOR_MODE.
  /// Set from the android.R.attr\#configChanges attribute.
  int get configChanges => jniAccessors
      .getField(reference, _id_configChanges, jni.JniType.intType)
      .integer;

  /// from: public int configChanges
  ///
  /// Bit mask of kinds of configuration changes that this activity
  /// can handle itself (without being restarted by the system).
  /// Contains any combination of \#CONFIG_FONT_SCALE,
  /// \#CONFIG_MCC, \#CONFIG_MNC,
  /// \#CONFIG_LOCALE, \#CONFIG_TOUCHSCREEN,
  /// \#CONFIG_KEYBOARD, \#CONFIG_NAVIGATION,
  /// \#CONFIG_ORIENTATION, \#CONFIG_SCREEN_LAYOUT,
  /// \#CONFIG_DENSITY, \#CONFIG_LAYOUT_DIRECTION and
  /// \#CONFIG_COLOR_MODE.
  /// Set from the android.R.attr\#configChanges attribute.
  set configChanges(int value) =>
      jniEnv.SetIntField(reference, _id_configChanges, value);

  static final _id_documentLaunchMode =
      jniAccessors.getFieldIDOf(_classRef, "documentLaunchMode", "I");

  /// from: public int documentLaunchMode
  ///
  /// The document launch mode style requested by the activity. From the
  /// android.R.attr\#documentLaunchMode attribute, one of
  /// \#DOCUMENT_LAUNCH_NONE, \#DOCUMENT_LAUNCH_INTO_EXISTING,
  /// \#DOCUMENT_LAUNCH_ALWAYS.
  ///
  /// Modes DOCUMENT_LAUNCH_ALWAYS
  /// and DOCUMENT_LAUNCH_INTO_EXISTING are equivalent to android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT Intent.FLAG_ACTIVITY_NEW_DOCUMENT with and without android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK Intent.FLAG_ACTIVITY_MULTIPLE_TASK respectively.
  int get documentLaunchMode => jniAccessors
      .getField(reference, _id_documentLaunchMode, jni.JniType.intType)
      .integer;

  /// from: public int documentLaunchMode
  ///
  /// The document launch mode style requested by the activity. From the
  /// android.R.attr\#documentLaunchMode attribute, one of
  /// \#DOCUMENT_LAUNCH_NONE, \#DOCUMENT_LAUNCH_INTO_EXISTING,
  /// \#DOCUMENT_LAUNCH_ALWAYS.
  ///
  /// Modes DOCUMENT_LAUNCH_ALWAYS
  /// and DOCUMENT_LAUNCH_INTO_EXISTING are equivalent to android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT Intent.FLAG_ACTIVITY_NEW_DOCUMENT with and without android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK Intent.FLAG_ACTIVITY_MULTIPLE_TASK respectively.
  set documentLaunchMode(int value) =>
      jniEnv.SetIntField(reference, _id_documentLaunchMode, value);

  static final _id_flags = jniAccessors.getFieldIDOf(_classRef, "flags", "I");

  /// from: public int flags
  ///
  /// Options that have been set in the activity declaration in the
  /// manifest.
  /// These include:
  /// \#FLAG_MULTIPROCESS,
  /// \#FLAG_FINISH_ON_TASK_LAUNCH, \#FLAG_CLEAR_TASK_ON_LAUNCH,
  /// \#FLAG_ALWAYS_RETAIN_TASK_STATE,
  /// \#FLAG_STATE_NOT_NEEDED, \#FLAG_EXCLUDE_FROM_RECENTS,
  /// \#FLAG_ALLOW_TASK_REPARENTING, \#FLAG_NO_HISTORY,
  /// \#FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS,
  /// \#FLAG_HARDWARE_ACCELERATED, \#FLAG_SINGLE_USER.
  int get flags =>
      jniAccessors.getField(reference, _id_flags, jni.JniType.intType).integer;

  /// from: public int flags
  ///
  /// Options that have been set in the activity declaration in the
  /// manifest.
  /// These include:
  /// \#FLAG_MULTIPROCESS,
  /// \#FLAG_FINISH_ON_TASK_LAUNCH, \#FLAG_CLEAR_TASK_ON_LAUNCH,
  /// \#FLAG_ALWAYS_RETAIN_TASK_STATE,
  /// \#FLAG_STATE_NOT_NEEDED, \#FLAG_EXCLUDE_FROM_RECENTS,
  /// \#FLAG_ALLOW_TASK_REPARENTING, \#FLAG_NO_HISTORY,
  /// \#FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS,
  /// \#FLAG_HARDWARE_ACCELERATED, \#FLAG_SINGLE_USER.
  set flags(int value) => jniEnv.SetIntField(reference, _id_flags, value);

  static final _id_launchMode =
      jniAccessors.getFieldIDOf(_classRef, "launchMode", "I");

  /// from: public int launchMode
  ///
  /// The launch mode style requested by the activity.  From the
  /// android.R.attr\#launchMode attribute, one of
  /// \#LAUNCH_MULTIPLE,
  /// \#LAUNCH_SINGLE_TOP, \#LAUNCH_SINGLE_TASK, or
  /// \#LAUNCH_SINGLE_INSTANCE.
  int get launchMode => jniAccessors
      .getField(reference, _id_launchMode, jni.JniType.intType)
      .integer;

  /// from: public int launchMode
  ///
  /// The launch mode style requested by the activity.  From the
  /// android.R.attr\#launchMode attribute, one of
  /// \#LAUNCH_MULTIPLE,
  /// \#LAUNCH_SINGLE_TOP, \#LAUNCH_SINGLE_TASK, or
  /// \#LAUNCH_SINGLE_INSTANCE.
  set launchMode(int value) =>
      jniEnv.SetIntField(reference, _id_launchMode, value);

  static final _id_maxRecents =
      jniAccessors.getFieldIDOf(_classRef, "maxRecents", "I");

  /// from: public int maxRecents
  ///
  /// The maximum number of tasks rooted at this activity that can be in the recent task list.
  /// Refer to android.R.attr\#maxRecents.
  int get maxRecents => jniAccessors
      .getField(reference, _id_maxRecents, jni.JniType.intType)
      .integer;

  /// from: public int maxRecents
  ///
  /// The maximum number of tasks rooted at this activity that can be in the recent task list.
  /// Refer to android.R.attr\#maxRecents.
  set maxRecents(int value) =>
      jniEnv.SetIntField(reference, _id_maxRecents, value);

  static final _id_parentActivityName = jniAccessors.getFieldIDOf(
      _classRef, "parentActivityName", "Ljava/lang/String;");

  /// from: public java.lang.String parentActivityName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If defined, the activity named here is the logical parent of this activity.
  jni.JniString get parentActivityName => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_parentActivityName, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String parentActivityName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If defined, the activity named here is the logical parent of this activity.
  set parentActivityName(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_parentActivityName, value.reference);

  static final _id_permission =
      jniAccessors.getFieldIDOf(_classRef, "permission", "Ljava/lang/String;");

  /// from: public java.lang.String permission
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Optional name of a permission required to be able to access this
  /// Activity.  From the "permission" attribute.
  jni.JniString get permission => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_permission, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String permission
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Optional name of a permission required to be able to access this
  /// Activity.  From the "permission" attribute.
  set permission(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_permission, value.reference);

  static final _id_persistableMode =
      jniAccessors.getFieldIDOf(_classRef, "persistableMode", "I");

  /// from: public int persistableMode
  ///
  /// Value indicating how this activity is to be persisted across
  /// reboots for restoring in the Recents list.
  /// android.R.attr\#persistableMode
  int get persistableMode => jniAccessors
      .getField(reference, _id_persistableMode, jni.JniType.intType)
      .integer;

  /// from: public int persistableMode
  ///
  /// Value indicating how this activity is to be persisted across
  /// reboots for restoring in the Recents list.
  /// android.R.attr\#persistableMode
  set persistableMode(int value) =>
      jniEnv.SetIntField(reference, _id_persistableMode, value);

  static final _id_screenOrientation =
      jniAccessors.getFieldIDOf(_classRef, "screenOrientation", "I");

  /// from: public int screenOrientation
  ///
  /// The preferred screen orientation this activity would like to run in.
  /// From the android.R.attr\#screenOrientation attribute, one of
  /// \#SCREEN_ORIENTATION_UNSPECIFIED,
  /// \#SCREEN_ORIENTATION_LANDSCAPE,
  /// \#SCREEN_ORIENTATION_PORTRAIT,
  /// \#SCREEN_ORIENTATION_USER,
  /// \#SCREEN_ORIENTATION_BEHIND,
  /// \#SCREEN_ORIENTATION_SENSOR,
  /// \#SCREEN_ORIENTATION_NOSENSOR,
  /// \#SCREEN_ORIENTATION_SENSOR_LANDSCAPE,
  /// \#SCREEN_ORIENTATION_SENSOR_PORTRAIT,
  /// \#SCREEN_ORIENTATION_REVERSE_LANDSCAPE,
  /// \#SCREEN_ORIENTATION_REVERSE_PORTRAIT,
  /// \#SCREEN_ORIENTATION_FULL_SENSOR,
  /// \#SCREEN_ORIENTATION_USER_LANDSCAPE,
  /// \#SCREEN_ORIENTATION_USER_PORTRAIT,
  /// \#SCREEN_ORIENTATION_FULL_USER,
  /// \#SCREEN_ORIENTATION_LOCKED,
  ///
  /// Value is android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSET, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_UNSPECIFIED, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_BEHIND, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_NOSENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_USER, or android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LOCKED
  int get screenOrientation => jniAccessors
      .getField(reference, _id_screenOrientation, jni.JniType.intType)
      .integer;

  /// from: public int screenOrientation
  ///
  /// The preferred screen orientation this activity would like to run in.
  /// From the android.R.attr\#screenOrientation attribute, one of
  /// \#SCREEN_ORIENTATION_UNSPECIFIED,
  /// \#SCREEN_ORIENTATION_LANDSCAPE,
  /// \#SCREEN_ORIENTATION_PORTRAIT,
  /// \#SCREEN_ORIENTATION_USER,
  /// \#SCREEN_ORIENTATION_BEHIND,
  /// \#SCREEN_ORIENTATION_SENSOR,
  /// \#SCREEN_ORIENTATION_NOSENSOR,
  /// \#SCREEN_ORIENTATION_SENSOR_LANDSCAPE,
  /// \#SCREEN_ORIENTATION_SENSOR_PORTRAIT,
  /// \#SCREEN_ORIENTATION_REVERSE_LANDSCAPE,
  /// \#SCREEN_ORIENTATION_REVERSE_PORTRAIT,
  /// \#SCREEN_ORIENTATION_FULL_SENSOR,
  /// \#SCREEN_ORIENTATION_USER_LANDSCAPE,
  /// \#SCREEN_ORIENTATION_USER_PORTRAIT,
  /// \#SCREEN_ORIENTATION_FULL_USER,
  /// \#SCREEN_ORIENTATION_LOCKED,
  ///
  /// Value is android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSET, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_UNSPECIFIED, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_BEHIND, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_NOSENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_USER, or android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LOCKED
  set screenOrientation(int value) =>
      jniEnv.SetIntField(reference, _id_screenOrientation, value);

  static final _id_softInputMode =
      jniAccessors.getFieldIDOf(_classRef, "softInputMode", "I");

  /// from: public int softInputMode
  ///
  /// The desired soft input mode for this activity's main window.
  /// Set from the android.R.attr\#windowSoftInputMode attribute
  /// in the activity's manifest.  May be any of the same values allowed
  /// for android.view.WindowManager.LayoutParams\#softInputMode WindowManager.LayoutParams.softInputMode.  If 0 (unspecified),
  /// the mode from the theme will be used.
  ///
  /// Value is either <code>0</code> or a combination of android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_UNSPECIFIED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_UNCHANGED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_HIDDEN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_ALWAYS_HIDDEN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_VISIBLE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_ALWAYS_VISIBLE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_UNSPECIFIED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_RESIZE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_PAN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_NOTHING, and android.view.WindowManager.LayoutParams\#SOFT_INPUT_IS_FORWARD_NAVIGATION
  int get softInputMode => jniAccessors
      .getField(reference, _id_softInputMode, jni.JniType.intType)
      .integer;

  /// from: public int softInputMode
  ///
  /// The desired soft input mode for this activity's main window.
  /// Set from the android.R.attr\#windowSoftInputMode attribute
  /// in the activity's manifest.  May be any of the same values allowed
  /// for android.view.WindowManager.LayoutParams\#softInputMode WindowManager.LayoutParams.softInputMode.  If 0 (unspecified),
  /// the mode from the theme will be used.
  ///
  /// Value is either <code>0</code> or a combination of android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_UNSPECIFIED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_UNCHANGED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_HIDDEN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_ALWAYS_HIDDEN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_VISIBLE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_ALWAYS_VISIBLE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_UNSPECIFIED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_RESIZE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_PAN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_NOTHING, and android.view.WindowManager.LayoutParams\#SOFT_INPUT_IS_FORWARD_NAVIGATION
  set softInputMode(int value) =>
      jniEnv.SetIntField(reference, _id_softInputMode, value);

  static final _id_targetActivity = jniAccessors.getFieldIDOf(
      _classRef, "targetActivity", "Ljava/lang/String;");

  /// from: public java.lang.String targetActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this is an activity alias, this is the real activity class to run
  /// for it.  Otherwise, this is null.
  jni.JniString get targetActivity => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_targetActivity, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String targetActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this is an activity alias, this is the real activity class to run
  /// for it.  Otherwise, this is null.
  set targetActivity(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_targetActivity, value.reference);

  static final _id_taskAffinity = jniAccessors.getFieldIDOf(
      _classRef, "taskAffinity", "Ljava/lang/String;");

  /// from: public java.lang.String taskAffinity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The affinity this activity has for another task in the system.  The
  /// string here is the name of the task, often the package name of the
  /// overall package.  If null, the activity has no affinity.  Set from the
  /// android.R.attr\#taskAffinity attribute.
  jni.JniString get taskAffinity => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_taskAffinity, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String taskAffinity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The affinity this activity has for another task in the system.  The
  /// string here is the name of the task, often the package name of the
  /// overall package.  If null, the activity has no affinity.  Set from the
  /// android.R.attr\#taskAffinity attribute.
  set taskAffinity(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_taskAffinity, value.reference);

  static final _id_theme = jniAccessors.getFieldIDOf(_classRef, "theme", "I");

  /// from: public int theme
  ///
  /// A style resource identifier (in the package's resources) of this
  /// activity's theme.  From the "theme" attribute or, if not set, 0.
  int get theme =>
      jniAccessors.getField(reference, _id_theme, jni.JniType.intType).integer;

  /// from: public int theme
  ///
  /// A style resource identifier (in the package's resources) of this
  /// activity's theme.  From the "theme" attribute or, if not set, 0.
  set theme(int value) => jniEnv.SetIntField(reference, _id_theme, value);

  static final _id_uiOptions =
      jniAccessors.getFieldIDOf(_classRef, "uiOptions", "I");

  /// from: public int uiOptions
  ///
  /// The desired extra UI options for this activity and its main window.
  /// Set from the android.R.attr\#uiOptions attribute in the
  /// activity's manifest.
  int get uiOptions => jniAccessors
      .getField(reference, _id_uiOptions, jni.JniType.intType)
      .integer;

  /// from: public int uiOptions
  ///
  /// The desired extra UI options for this activity and its main window.
  /// Set from the android.R.attr\#uiOptions attribute in the
  /// activity's manifest.
  set uiOptions(int value) =>
      jniEnv.SetIntField(reference, _id_uiOptions, value);

  static final _id_windowLayout = jniAccessors.getFieldIDOf(_classRef,
      "windowLayout", "Landroid/content/pm/ActivityInfo\$WindowLayout;");

  /// from: public android.content.pm.ActivityInfo.WindowLayout windowLayout
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Information about desired position and size of activity on the display when
  /// it is first started.
  ActivityInfo_WindowLayout get windowLayout =>
      ActivityInfo_WindowLayout.fromRef(jniAccessors
          .getField(reference, _id_windowLayout, jni.JniType.objectType)
          .object);

  /// from: public android.content.pm.ActivityInfo.WindowLayout windowLayout
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Information about desired position and size of activity on the display when
  /// it is first started.
  set windowLayout(ActivityInfo_WindowLayout value) =>
      jniEnv.SetObjectField(reference, _id_windowLayout, value.reference);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActivityInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor4 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/pm/ActivityInfo;)V");

  /// from: public void <init>(android.content.pm.ActivityInfo orig)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActivityInfo.ctor4(ActivityInfo orig)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor4, [orig.reference]).object);

  static final _id_getThemeResource =
      jniAccessors.getMethodIDOf(_classRef, "getThemeResource", "()I");

  /// from: public final int getThemeResource()
  ///
  /// Return the theme resource identifier to use for this activity.  If
  /// the activity defines a theme, that is used; else, the application
  /// theme is used.
  ///@return The theme associated with this activity.
  int getThemeResource() => jniAccessors.callMethodWithArgs(
      reference, _id_getThemeResource, jni.JniType.intType, []).integer;

  static final _id_dump = jniAccessors.getMethodIDOf(
      _classRef, "dump", "(Landroid/util/Printer;Ljava/lang/String;)V");

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  void dump(printer_.Printer pw, jni.JniString prefix) =>
      jniAccessors.callMethodWithArgs(reference, _id_dump, jni.JniType.voidType,
          [pw.reference, prefix.reference]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(parcel_.Parcel dest, int parcelableFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, parcelableFlags]).check();
}

/// from: android.content.pm.ActivityInfo$WindowLayout
///
/// Contains information about position and size of the activity on the display.
///
/// Used in freeform mode to set desired position when activity is first launched.
/// It describes how big the activity wants to be in both width and height,
/// the minimal allowed size, and the gravity to be applied.
///@attr ref android.R.styleable\#AndroidManifestLayout_defaultWidth
///@attr ref android.R.styleable\#AndroidManifestLayout_defaultHeight
///@attr ref android.R.styleable\#AndroidManifestLayout_gravity
///@attr ref android.R.styleable\#AndroidManifestLayout_minWidth
///@attr ref android.R.styleable\#AndroidManifestLayout_minHeight
class ActivityInfo_WindowLayout extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/pm/ActivityInfo\$WindowLayout");
  ActivityInfo_WindowLayout.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_gravity =
      jniAccessors.getFieldIDOf(_classRef, "gravity", "I");

  /// from: public final int gravity
  ///
  /// Gravity of activity.
  /// Currently android.view.Gravity\#TOP, android.view.Gravity\#BOTTOM,
  /// android.view.Gravity\#LEFT and android.view.Gravity\#RIGHT are supported.
  ///@attr ref android.R.styleable\#AndroidManifestLayout_gravity
  int get gravity => jniAccessors
      .getField(reference, _id_gravity, jni.JniType.intType)
      .integer;

  static final _id_height = jniAccessors.getFieldIDOf(_classRef, "height", "I");

  /// from: public final int height
  ///
  /// Height of activity in pixels.
  ///@attr ref android.R.styleable\#AndroidManifestLayout_defaultHeight
  int get height =>
      jniAccessors.getField(reference, _id_height, jni.JniType.intType).integer;

  static final _id_heightFraction =
      jniAccessors.getFieldIDOf(_classRef, "heightFraction", "F");

  /// from: public final float heightFraction
  ///
  /// Height of activity as a fraction of available display height.
  /// If both \#height and this value are set this one will be preferred.
  ///@attr ref android.R.styleable\#AndroidManifestLayout_defaultHeight
  double get heightFraction => jniAccessors
      .getField(reference, _id_heightFraction, jni.JniType.floatType)
      .float;

  static final _id_minHeight =
      jniAccessors.getFieldIDOf(_classRef, "minHeight", "I");

  /// from: public final int minHeight
  ///
  /// Minimal height of activity in pixels to be able to display its content.
  ///
  /// <strong>NOTE:</strong> A task's root activity value is applied to all additional
  /// activities launched in the task. That is if the root activity of a task set minimal
  /// height, then the system will set the same minimal height on all other activities in the
  /// task. It will also ignore any other minimal height attributes of non-root activities.
  ///@attr ref android.R.styleable\#AndroidManifestLayout_minHeight
  int get minHeight => jniAccessors
      .getField(reference, _id_minHeight, jni.JniType.intType)
      .integer;

  static final _id_minWidth =
      jniAccessors.getFieldIDOf(_classRef, "minWidth", "I");

  /// from: public final int minWidth
  ///
  /// Minimal width of activity in pixels to be able to display its content.
  ///
  /// <strong>NOTE:</strong> A task's root activity value is applied to all additional
  /// activities launched in the task. That is if the root activity of a task set minimal
  /// width, then the system will set the same minimal width on all other activities in the
  /// task. It will also ignore any other minimal width attributes of non-root activities.
  ///@attr ref android.R.styleable\#AndroidManifestLayout_minWidth
  int get minWidth => jniAccessors
      .getField(reference, _id_minWidth, jni.JniType.intType)
      .integer;

  static final _id_width = jniAccessors.getFieldIDOf(_classRef, "width", "I");

  /// from: public final int width
  ///
  /// Width of activity in pixels.
  ///@attr ref android.R.styleable\#AndroidManifestLayout_defaultWidth
  int get width =>
      jniAccessors.getField(reference, _id_width, jni.JniType.intType).integer;

  static final _id_widthFraction =
      jniAccessors.getFieldIDOf(_classRef, "widthFraction", "F");

  /// from: public final float widthFraction
  ///
  /// Width of activity as a fraction of available display width.
  /// If both \#width and this value are set this one will be preferred.
  ///@attr ref android.R.styleable\#AndroidManifestLayout_defaultWidth
  double get widthFraction => jniAccessors
      .getField(reference, _id_widthFraction, jni.JniType.floatType)
      .float;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(IFIFIII)V");

  /// from: public void <init>(int width, float widthFraction, int height, float heightFraction, int gravity, int minWidth, int minHeight)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ActivityInfo_WindowLayout(int width, double widthFraction, int height,
      double heightFraction, int gravity, int minWidth, int minHeight)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [
          width,
          widthFraction,
          height,
          heightFraction,
          gravity,
          minWidth,
          minHeight
        ]).object);
}
