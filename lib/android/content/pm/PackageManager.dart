// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "PackageInfo.dart" as packageinfo_;

import "VersionedPackage.dart" as versionedpackage_;

import "../Intent.dart" as intent_;

import "PermissionInfo.dart" as permissioninfo_;

import "PermissionGroupInfo.dart" as permissiongroupinfo_;

import "ApplicationInfo.dart" as applicationinfo_;

import "ActivityInfo.dart" as activityinfo_;

import "../ComponentName.dart" as componentname_;

import "ServiceInfo.dart" as serviceinfo_;

import "ProviderInfo.dart" as providerinfo_;

import "ChangedPackages.dart" as changedpackages_;

import "ResolveInfo.dart" as resolveinfo_;

import "InstrumentationInfo.dart" as instrumentationinfo_;

import "../../graphics/drawable/Drawable.dart" as drawable_;

import "../../os/UserHandle.dart" as userhandle_;

import "../../graphics/Rect.dart" as rect_;

import "../res/XmlResourceParser.dart" as xmlresourceparser_;

import "../res/Resources.dart" as resources_;

import "../IntentFilter.dart" as intentfilter_;

import "../../os/Bundle.dart" as bundle_;

import "PackageInstaller.dart" as packageinstaller_;

import "../../util/AndroidException.dart" as androidexception_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.pm.PackageManager
///
/// Class for retrieving various kinds of information related to the application
/// packages that are currently installed on the device.
///
/// You can find this class through Context\#getPackageManager.
class PackageManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/pm/PackageManager");
  PackageManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CERT_INPUT_RAW_X509
  ///
  /// Certificate input bytes: the input bytes represent an encoded X.509 Certificate which could
  /// be generated using an {@code CertificateFactory}
  static const CERT_INPUT_RAW_X509 = 0;

  /// from: static public final int CERT_INPUT_SHA256
  ///
  /// Certificate input bytes: the input bytes represent the SHA256 output of an encoded X.509
  /// Certificate.
  static const CERT_INPUT_SHA256 = 1;

  /// from: static public final int COMPONENT_ENABLED_STATE_DEFAULT
  ///
  /// Flag for \#setApplicationEnabledSetting(String, int, int) and
  /// \#setComponentEnabledSetting(ComponentName, int, int): This
  /// component or application is in its default enabled state (as specified in
  /// its manifest).
  ///
  /// Explicitly setting the component state to this value restores it's
  /// enabled state to whatever is set in the manifest.
  static const COMPONENT_ENABLED_STATE_DEFAULT = 0;

  /// from: static public final int COMPONENT_ENABLED_STATE_DISABLED
  ///
  /// Flag for \#setApplicationEnabledSetting(String, int, int)
  /// and \#setComponentEnabledSetting(ComponentName, int, int): This
  /// component or application has been explicitly disabled, regardless of
  /// what it has specified in its manifest.
  static const COMPONENT_ENABLED_STATE_DISABLED = 2;

  /// from: static public final int COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED
  ///
  /// Flag for \#setApplicationEnabledSetting(String, int, int) only: This
  /// application should be considered, until the point where the user actually
  /// wants to use it.  This means that it will not normally show up to the user
  /// (such as in the launcher), but various parts of the user interface can
  /// use \#GET_DISABLED_UNTIL_USED_COMPONENTS to still see it and allow
  /// the user to select it (as for example an IME, device admin, etc).  Such code,
  /// once the user has selected the app, should at that point also make it enabled.
  /// This option currently <strong>can not</strong> be used with
  /// \#setComponentEnabledSetting(ComponentName, int, int).
  static const COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED = 4;

  /// from: static public final int COMPONENT_ENABLED_STATE_DISABLED_USER
  ///
  /// Flag for \#setApplicationEnabledSetting(String, int, int) only: The
  /// user has explicitly disabled the application, regardless of what it has
  /// specified in its manifest.  Because this is due to the user's request,
  /// they may re-enable it if desired through the appropriate system UI.  This
  /// option currently <strong>cannot</strong> be used with
  /// \#setComponentEnabledSetting(ComponentName, int, int).
  static const COMPONENT_ENABLED_STATE_DISABLED_USER = 3;

  /// from: static public final int COMPONENT_ENABLED_STATE_ENABLED
  ///
  /// Flag for \#setApplicationEnabledSetting(String, int, int)
  /// and \#setComponentEnabledSetting(ComponentName, int, int): This
  /// component or application has been explictily enabled, regardless of
  /// what it has specified in its manifest.
  static const COMPONENT_ENABLED_STATE_ENABLED = 1;

  /// from: static public final int DONT_KILL_APP
  ///
  /// Flag parameter for
  /// \#setComponentEnabledSetting(android.content.ComponentName, int, int) to indicate
  /// that you don't want to kill the app containing the component.  Be careful when you set this
  /// since changing component states can make the containing application's behavior unpredictable.
  static const DONT_KILL_APP = 1;

  /// from: static public final java.lang.String EXTRA_VERIFICATION_ID
  ///
  /// Extra field name for the ID of a package pending verification. Passed to
  /// a package verifier and is used to call back to
  /// PackageManager\#verifyPendingInstall(int, int)
  static const EXTRA_VERIFICATION_ID =
      "android.content.pm.extra.VERIFICATION_ID";

  /// from: static public final java.lang.String EXTRA_VERIFICATION_RESULT
  ///
  /// Extra field name for the result of a verification, either
  /// \#VERIFICATION_ALLOW, or \#VERIFICATION_REJECT.
  /// Passed to package verifiers after a package is verified.
  static const EXTRA_VERIFICATION_RESULT =
      "android.content.pm.extra.VERIFICATION_RESULT";

  /// from: static public final java.lang.String FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device supports running activities on secondary displays.
  static const FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS =
      "android.software.activities_on_secondary_displays";

  /// from: static public final java.lang.String FEATURE_APP_WIDGETS
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports app widgets.
  static const FEATURE_APP_WIDGETS = "android.software.app_widgets";

  /// from: static public final java.lang.String FEATURE_AUDIO_LOW_LATENCY
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature: The device's
  /// audio pipeline is low-latency, more suitable for audio applications sensitive to delays or
  /// lag in sound input or output.
  static const FEATURE_AUDIO_LOW_LATENCY = "android.hardware.audio.low_latency";

  /// from: static public final java.lang.String FEATURE_AUDIO_OUTPUT
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes at least one form of audio
  /// output, as defined in the Android Compatibility Definition Document (CDD)
  /// <a href="https://source.android.com/compatibility/android-cdd\#7_8_audio">section 7.8 Audio</a>.
  static const FEATURE_AUDIO_OUTPUT = "android.hardware.audio.output";

  /// from: static public final java.lang.String FEATURE_AUDIO_PRO
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device has professional audio level of functionality and performance.
  static const FEATURE_AUDIO_PRO = "android.hardware.audio.pro";

  /// from: static public final java.lang.String FEATURE_AUTOFILL
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device supports autofill of user credentials, addresses, credit cards, etc
  /// via integration with android.service.autofill.AutofillService autofill
  /// providers.
  static const FEATURE_AUTOFILL = "android.software.autofill";

  /// from: static public final java.lang.String FEATURE_AUTOMOTIVE
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: This is a device dedicated to showing UI
  /// on a vehicle headunit. A headunit here is defined to be inside a
  /// vehicle that may or may not be moving. A headunit uses either a
  /// primary display in the center console and/or additional displays in
  /// the instrument cluster or elsewhere in the vehicle. Headunit display(s)
  /// have limited size and resolution. The user will likely be focused on
  /// driving so limiting driver distraction is a primary concern. User input
  /// can be a variety of hard buttons, touch, rotary controllers and even mouse-
  /// like interfaces.
  static const FEATURE_AUTOMOTIVE = "android.hardware.type.automotive";

  /// from: static public final java.lang.String FEATURE_BACKUP
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device can perform backup and restore operations on installed applications.
  static const FEATURE_BACKUP = "android.software.backup";

  /// from: static public final java.lang.String FEATURE_BLUETOOTH
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device is capable of communicating with
  /// other devices via Bluetooth.
  static const FEATURE_BLUETOOTH = "android.hardware.bluetooth";

  /// from: static public final java.lang.String FEATURE_BLUETOOTH_LE
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device is capable of communicating with
  /// other devices via Bluetooth Low Energy radio.
  static const FEATURE_BLUETOOTH_LE = "android.hardware.bluetooth_le";

  /// from: static public final java.lang.String FEATURE_CAMERA
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device has a camera facing away
  /// from the screen.
  static const FEATURE_CAMERA = "android.hardware.camera";

  /// from: static public final java.lang.String FEATURE_CAMERA_ANY
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device has at least one camera pointing in
  /// some direction, or can support an external camera being connected to it.
  static const FEATURE_CAMERA_ANY = "android.hardware.camera.any";

  /// from: static public final java.lang.String FEATURE_CAMERA_AR
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature: At least one
  /// of the cameras on the device supports the
  /// android.hardware.camera2.CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_MOTION_TRACKING MOTION_TRACKING capability level.
  static const FEATURE_CAMERA_AR = "android.hardware.camera.ar";

  /// from: static public final java.lang.String FEATURE_CAMERA_AUTOFOCUS
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device's camera supports auto-focus.
  static const FEATURE_CAMERA_AUTOFOCUS = "android.hardware.camera.autofocus";

  /// from: static public final java.lang.String FEATURE_CAMERA_CAPABILITY_MANUAL_POST_PROCESSING
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature: At least one
  /// of the cameras on the device supports the
  /// android.hardware.camera2.CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING manual post-processing
  /// capability level.
  static const FEATURE_CAMERA_CAPABILITY_MANUAL_POST_PROCESSING =
      "android.hardware.camera.capability.manual_post_processing";

  /// from: static public final java.lang.String FEATURE_CAMERA_CAPABILITY_MANUAL_SENSOR
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature: At least one
  /// of the cameras on the device supports the
  /// android.hardware.camera2.CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR manual sensor
  /// capability level.
  static const FEATURE_CAMERA_CAPABILITY_MANUAL_SENSOR =
      "android.hardware.camera.capability.manual_sensor";

  /// from: static public final java.lang.String FEATURE_CAMERA_CAPABILITY_RAW
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature: At least one
  /// of the cameras on the device supports the
  /// android.hardware.camera2.CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_RAW RAW
  /// capability level.
  static const FEATURE_CAMERA_CAPABILITY_RAW =
      "android.hardware.camera.capability.raw";

  /// from: static public final java.lang.String FEATURE_CAMERA_EXTERNAL
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device can support having an external camera connected to it.
  /// The external camera may not always be connected or available to applications to use.
  static const FEATURE_CAMERA_EXTERNAL = "android.hardware.camera.external";

  /// from: static public final java.lang.String FEATURE_CAMERA_FLASH
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device's camera supports flash.
  static const FEATURE_CAMERA_FLASH = "android.hardware.camera.flash";

  /// from: static public final java.lang.String FEATURE_CAMERA_FRONT
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device has a front facing camera.
  static const FEATURE_CAMERA_FRONT = "android.hardware.camera.front";

  /// from: static public final java.lang.String FEATURE_CAMERA_LEVEL_FULL
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature: At least one
  /// of the cameras on the device supports the
  /// android.hardware.camera2.CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL full hardware
  /// capability level.
  static const FEATURE_CAMERA_LEVEL_FULL = "android.hardware.camera.level.full";

  /// from: static public final java.lang.String FEATURE_CANT_SAVE_STATE
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports the
  /// android.R.attr\#cantSaveState API.
  static const FEATURE_CANT_SAVE_STATE = "android.software.cant_save_state";

  /// from: static public final java.lang.String FEATURE_COMPANION_DEVICE_SETUP
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device supports android.companion.CompanionDeviceManager\#associate associating
  /// with devices via android.companion.CompanionDeviceManager.
  static const FEATURE_COMPANION_DEVICE_SETUP =
      "android.software.companion_device_setup";

  /// from: static public final java.lang.String FEATURE_CONNECTION_SERVICE
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The Connection Service API is enabled on the device.
  static const FEATURE_CONNECTION_SERVICE =
      "android.software.connectionservice";

  /// from: static public final java.lang.String FEATURE_CONSUMER_IR
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device is capable of communicating with
  /// consumer IR devices.
  static const FEATURE_CONSUMER_IR = "android.hardware.consumerir";

  /// from: static public final java.lang.String FEATURE_DEVICE_ADMIN
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports device policy enforcement via device admins.
  static const FEATURE_DEVICE_ADMIN = "android.software.device_admin";

  /// from: static public final java.lang.String FEATURE_EMBEDDED
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: This is a device for IoT and may not have an UI. An embedded
  /// device is defined as a full stack Android device with or without a display and no
  /// user-installable apps.
  static const FEATURE_EMBEDDED = "android.hardware.type.embedded";

  /// from: static public final java.lang.String FEATURE_ETHERNET
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: This device supports ethernet.
  static const FEATURE_ETHERNET = "android.hardware.ethernet";

  /// from: static public final java.lang.String FEATURE_FAKETOUCH
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device does not have a touch screen, but
  /// does support touch emulation for basic events. For instance, the
  /// device might use a mouse or remote control to drive a cursor, and
  /// emulate basic touch pointer events like down, up, drag, etc. All
  /// devices that support android.hardware.touchscreen or a sub-feature are
  /// presumed to also support faketouch.
  static const FEATURE_FAKETOUCH = "android.hardware.faketouch";

  /// from: static public final java.lang.String FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device does not have a touch screen, but
  /// does support touch emulation for basic events that supports distinct
  /// tracking of two or more fingers.  This is an extension of
  /// \#FEATURE_FAKETOUCH for input devices with this capability.  Note
  /// that unlike a distinct multitouch screen as defined by
  /// \#FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT, these kinds of input
  /// devices will not actually provide full two-finger gestures since the
  /// input is being transformed to cursor movement on the screen.  That is,
  /// single finger gestures will move a cursor; two-finger swipes will
  /// result in single-finger touch events; other two-finger gestures will
  /// result in the corresponding two-finger touch event.
  static const FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT =
      "android.hardware.faketouch.multitouch.distinct";

  /// from: static public final java.lang.String FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device does not have a touch screen, but
  /// does support touch emulation for basic events that supports tracking
  /// a hand of fingers (5 or more fingers) fully independently.
  /// This is an extension of
  /// \#FEATURE_FAKETOUCH for input devices with this capability.  Note
  /// that unlike a multitouch screen as defined by
  /// \#FEATURE_TOUCHSCREEN_MULTITOUCH_JAZZHAND, not all two finger
  /// gestures can be detected due to the limitations described for
  /// \#FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT.
  static const FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND =
      "android.hardware.faketouch.multitouch.jazzhand";

  /// from: static public final java.lang.String FEATURE_FINGERPRINT
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device has biometric hardware to detect a fingerprint.
  static const FEATURE_FINGERPRINT = "android.hardware.fingerprint";

  /// from: static public final java.lang.String FEATURE_FREEFORM_WINDOW_MANAGEMENT
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports freeform window management.
  /// Windows have title bars and can be moved and resized.
  static const FEATURE_FREEFORM_WINDOW_MANAGEMENT =
      "android.software.freeform_window_management";

  /// from: static public final java.lang.String FEATURE_GAMEPAD
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device has all of the inputs necessary to be considered a compatible game controller, or
  /// includes a compatible game controller in the box.
  static const FEATURE_GAMEPAD = "android.hardware.gamepad";

  /// from: static public final java.lang.String FEATURE_HIFI_SENSORS
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports high fidelity sensor processing
  /// capabilities.
  static const FEATURE_HIFI_SENSORS = "android.hardware.sensor.hifi_sensors";

  /// from: static public final java.lang.String FEATURE_HOME_SCREEN
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports a home screen that is replaceable
  /// by third party applications.
  static const FEATURE_HOME_SCREEN = "android.software.home_screen";

  /// from: static public final java.lang.String FEATURE_INPUT_METHODS
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports adding new input methods implemented
  /// with the android.inputmethodservice.InputMethodService API.
  static const FEATURE_INPUT_METHODS = "android.software.input_methods";

  /// from: static public final java.lang.String FEATURE_LEANBACK
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports leanback UI. This is
  /// typically used in a living room television experience, but is a software
  /// feature unlike \#FEATURE_TELEVISION. Devices running with this
  /// feature will use resources associated with the "television" UI mode.
  static const FEATURE_LEANBACK = "android.software.leanback";

  /// from: static public final java.lang.String FEATURE_LEANBACK_ONLY
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports only leanback UI. Only
  /// applications designed for this experience should be run, though this is
  /// not enforced by the system.
  static const FEATURE_LEANBACK_ONLY = "android.software.leanback_only";

  /// from: static public final java.lang.String FEATURE_LIVE_TV
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports live TV and can display
  /// contents from TV inputs implemented with the
  /// android.media.tv.TvInputService API.
  static const FEATURE_LIVE_TV = "android.software.live_tv";

  /// from: static public final java.lang.String FEATURE_LIVE_WALLPAPER
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports live wallpapers.
  static const FEATURE_LIVE_WALLPAPER = "android.software.live_wallpaper";

  /// from: static public final java.lang.String FEATURE_LOCATION
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports one or more methods of
  /// reporting current location.
  static const FEATURE_LOCATION = "android.hardware.location";

  /// from: static public final java.lang.String FEATURE_LOCATION_GPS
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device has a Global Positioning System
  /// receiver and can report precise location.
  static const FEATURE_LOCATION_GPS = "android.hardware.location.gps";

  /// from: static public final java.lang.String FEATURE_LOCATION_NETWORK
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device can report location with coarse
  /// accuracy using a network-based geolocation system.
  static const FEATURE_LOCATION_NETWORK = "android.hardware.location.network";

  /// from: static public final java.lang.String FEATURE_MANAGED_USERS
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device supports creating secondary users and managed profiles via
  /// DevicePolicyManager.
  static const FEATURE_MANAGED_USERS = "android.software.managed_users";

  /// from: static public final java.lang.String FEATURE_MICROPHONE
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device can record audio via a
  /// microphone.
  static const FEATURE_MICROPHONE = "android.hardware.microphone";

  /// from: static public final java.lang.String FEATURE_MIDI
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device has a full implementation of the android.media.midi.* APIs.
  static const FEATURE_MIDI = "android.software.midi";

  /// from: static public final java.lang.String FEATURE_NFC
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device can communicate using Near-Field
  /// Communications (NFC).
  static const FEATURE_NFC = "android.hardware.nfc";

  /// from: static public final java.lang.String FEATURE_NFC_HOST_CARD_EMULATION
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports host-
  /// based NFC card emulation.
  static const FEATURE_NFC_HOST_CARD_EMULATION = "android.hardware.nfc.hce";

  /// from: static public final java.lang.String FEATURE_NFC_HOST_CARD_EMULATION_NFCF
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports host-
  /// based NFC-F card emulation.
  static const FEATURE_NFC_HOST_CARD_EMULATION_NFCF =
      "android.hardware.nfc.hcef";

  /// from: static public final java.lang.String FEATURE_OPENGLES_EXTENSION_PACK
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports the OpenGL ES
  /// <a href="http://www.khronos.org/registry/gles/extensions/ANDROID/ANDROID_extension_pack_es31a.txt">
  /// Android Extension Pack</a>.
  static const FEATURE_OPENGLES_EXTENSION_PACK =
      "android.hardware.opengles.aep";

  /// from: static public final java.lang.String FEATURE_PC
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: This is a device dedicated to be primarily used
  /// with keyboard, mouse or touchpad. This includes traditional desktop
  /// computers, laptops and variants such as convertibles or detachables.
  /// Due to the larger screen, the device will most likely use the
  /// \#FEATURE_FREEFORM_WINDOW_MANAGEMENT feature as well.
  static const FEATURE_PC = "android.hardware.type.pc";

  /// from: static public final java.lang.String FEATURE_PICTURE_IN_PICTURE
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device supports picture-in-picture multi-window mode.
  static const FEATURE_PICTURE_IN_PICTURE =
      "android.software.picture_in_picture";

  /// from: static public final java.lang.String FEATURE_PRINTING
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device supports printing.
  static const FEATURE_PRINTING = "android.software.print";

  /// from: static public final java.lang.String FEATURE_RAM_LOW
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device's
  /// ActivityManager\#isLowRamDevice() ActivityManager.isLowRamDevice() method returns
  /// true.
  static const FEATURE_RAM_LOW = "android.hardware.ram.low";

  /// from: static public final java.lang.String FEATURE_RAM_NORMAL
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device's
  /// ActivityManager\#isLowRamDevice() ActivityManager.isLowRamDevice() method returns
  /// false.
  static const FEATURE_RAM_NORMAL = "android.hardware.ram.normal";

  /// from: static public final java.lang.String FEATURE_SCREEN_LANDSCAPE
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports landscape orientation
  /// screens.  For backwards compatibility, you can assume that if neither
  /// this nor \#FEATURE_SCREEN_PORTRAIT is set then the device supports
  /// both portrait and landscape.
  static const FEATURE_SCREEN_LANDSCAPE = "android.hardware.screen.landscape";

  /// from: static public final java.lang.String FEATURE_SCREEN_PORTRAIT
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports portrait orientation
  /// screens.  For backwards compatibility, you can assume that if neither
  /// this nor \#FEATURE_SCREEN_LANDSCAPE is set then the device supports
  /// both portrait and landscape.
  static const FEATURE_SCREEN_PORTRAIT = "android.hardware.screen.portrait";

  /// from: static public final java.lang.String FEATURE_SECURELY_REMOVES_USERS
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device supports secure removal of users. When a user is deleted the data associated
  /// with that user is securely deleted and no longer available.
  static const FEATURE_SECURELY_REMOVES_USERS =
      "android.software.securely_removes_users";

  /// from: static public final java.lang.String FEATURE_SENSOR_ACCELEROMETER
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes an accelerometer.
  static const FEATURE_SENSOR_ACCELEROMETER =
      "android.hardware.sensor.accelerometer";

  /// from: static public final java.lang.String FEATURE_SENSOR_AMBIENT_TEMPERATURE
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes an ambient temperature sensor.
  static const FEATURE_SENSOR_AMBIENT_TEMPERATURE =
      "android.hardware.sensor.ambient_temperature";

  /// from: static public final java.lang.String FEATURE_SENSOR_BAROMETER
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a barometer (air
  /// pressure sensor.)
  static const FEATURE_SENSOR_BAROMETER = "android.hardware.sensor.barometer";

  /// from: static public final java.lang.String FEATURE_SENSOR_COMPASS
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a magnetometer (compass).
  static const FEATURE_SENSOR_COMPASS = "android.hardware.sensor.compass";

  /// from: static public final java.lang.String FEATURE_SENSOR_GYROSCOPE
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a gyroscope.
  static const FEATURE_SENSOR_GYROSCOPE = "android.hardware.sensor.gyroscope";

  /// from: static public final java.lang.String FEATURE_SENSOR_HEART_RATE
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a heart rate monitor.
  static const FEATURE_SENSOR_HEART_RATE = "android.hardware.sensor.heartrate";

  /// from: static public final java.lang.String FEATURE_SENSOR_HEART_RATE_ECG
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The heart rate sensor on this device is an Electrocardiogram.
  static const FEATURE_SENSOR_HEART_RATE_ECG =
      "android.hardware.sensor.heartrate.ecg";

  /// from: static public final java.lang.String FEATURE_SENSOR_LIGHT
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a light sensor.
  static const FEATURE_SENSOR_LIGHT = "android.hardware.sensor.light";

  /// from: static public final java.lang.String FEATURE_SENSOR_PROXIMITY
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a proximity sensor.
  static const FEATURE_SENSOR_PROXIMITY = "android.hardware.sensor.proximity";

  /// from: static public final java.lang.String FEATURE_SENSOR_RELATIVE_HUMIDITY
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a relative humidity sensor.
  static const FEATURE_SENSOR_RELATIVE_HUMIDITY =
      "android.hardware.sensor.relative_humidity";

  /// from: static public final java.lang.String FEATURE_SENSOR_STEP_COUNTER
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a hardware step counter.
  static const FEATURE_SENSOR_STEP_COUNTER =
      "android.hardware.sensor.stepcounter";

  /// from: static public final java.lang.String FEATURE_SENSOR_STEP_DETECTOR
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a hardware step detector.
  static const FEATURE_SENSOR_STEP_DETECTOR =
      "android.hardware.sensor.stepdetector";

  /// from: static public final java.lang.String FEATURE_SIP
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The SIP API is enabled on the device.
  static const FEATURE_SIP = "android.software.sip";

  /// from: static public final java.lang.String FEATURE_SIP_VOIP
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports SIP-based VOIP.
  static const FEATURE_SIP_VOIP = "android.software.sip.voip";

  /// from: static public final java.lang.String FEATURE_STRONGBOX_KEYSTORE
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device has a StrongBox hardware-backed Keystore.
  static const FEATURE_STRONGBOX_KEYSTORE =
      "android.hardware.strongbox_keystore";

  /// from: static public final java.lang.String FEATURE_TELEPHONY
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device has a telephony radio with data
  /// communication support.
  static const FEATURE_TELEPHONY = "android.hardware.telephony";

  /// from: static public final java.lang.String FEATURE_TELEPHONY_CDMA
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device has a CDMA telephony stack.
  static const FEATURE_TELEPHONY_CDMA = "android.hardware.telephony.cdma";

  /// from: static public final java.lang.String FEATURE_TELEPHONY_EUICC
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature: The device
  /// supports embedded subscriptions on eUICCs.
  static const FEATURE_TELEPHONY_EUICC = "android.hardware.telephony.euicc";

  /// from: static public final java.lang.String FEATURE_TELEPHONY_GSM
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device has a GSM telephony stack.
  static const FEATURE_TELEPHONY_GSM = "android.hardware.telephony.gsm";

  /// from: static public final java.lang.String FEATURE_TELEPHONY_MBMS
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature: The device
  /// supports cell-broadcast reception using the MBMS APIs.
  static const FEATURE_TELEPHONY_MBMS = "android.hardware.telephony.mbms";

  /// from: static public final java.lang.String FEATURE_TELEVISION
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: This is a device dedicated to showing UI
  /// on a television.  Television here is defined to be a typical living
  /// room television experience: displayed on a big screen, where the user
  /// is sitting far away from it, and the dominant form of input will be
  /// something like a DPAD, not through touch or mouse.
  ///@deprecated use \#FEATURE_LEANBACK instead.
  static const FEATURE_TELEVISION = "android.hardware.type.television";

  /// from: static public final java.lang.String FEATURE_TOUCHSCREEN
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device's display has a touch screen.
  static const FEATURE_TOUCHSCREEN = "android.hardware.touchscreen";

  /// from: static public final java.lang.String FEATURE_TOUCHSCREEN_MULTITOUCH
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device's touch screen supports
  /// multitouch sufficient for basic two-finger gesture detection.
  static const FEATURE_TOUCHSCREEN_MULTITOUCH =
      "android.hardware.touchscreen.multitouch";

  /// from: static public final java.lang.String FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device's touch screen is capable of
  /// tracking two or more fingers fully independently.
  static const FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT =
      "android.hardware.touchscreen.multitouch.distinct";

  /// from: static public final java.lang.String FEATURE_TOUCHSCREEN_MULTITOUCH_JAZZHAND
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device's touch screen is capable of
  /// tracking a full hand of fingers fully independently -- that is, 5 or
  /// more simultaneous independent pointers.
  static const FEATURE_TOUCHSCREEN_MULTITOUCH_JAZZHAND =
      "android.hardware.touchscreen.multitouch.jazzhand";

  /// from: static public final java.lang.String FEATURE_USB_ACCESSORY
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports connecting to USB accessories.
  static const FEATURE_USB_ACCESSORY = "android.hardware.usb.accessory";

  /// from: static public final java.lang.String FEATURE_USB_HOST
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports connecting to USB devices
  /// as the USB host.
  static const FEATURE_USB_HOST = "android.hardware.usb.host";

  /// from: static public final java.lang.String FEATURE_VERIFIED_BOOT
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device supports verified boot.
  static const FEATURE_VERIFIED_BOOT = "android.software.verified_boot";

  /// from: static public final java.lang.String FEATURE_VR_HEADTRACKING
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device implements headtracking suitable for a VR device.
  static const FEATURE_VR_HEADTRACKING = "android.hardware.vr.headtracking";

  /// from: static public final java.lang.String FEATURE_VR_MODE
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device implements an optimized mode for virtual reality (VR) applications that handles
  /// stereoscopic rendering of notifications, and disables most monocular system UI components
  /// while a VR application has user focus.
  /// Devices declaring this feature must include an application implementing a
  /// android.service.vr.VrListenerService that can be targeted by VR applications via
  /// android.app.Activity\#setVrModeEnabled.
  ///@deprecated use \#FEATURE_VR_MODE_HIGH_PERFORMANCE instead.
  static const FEATURE_VR_MODE = "android.software.vr.mode";

  /// from: static public final java.lang.String FEATURE_VR_MODE_HIGH_PERFORMANCE
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device implements an optimized mode for virtual reality (VR) applications that handles
  /// stereoscopic rendering of notifications, disables most monocular system UI components
  /// while a VR application has user focus and meets extra CDD requirements to provide a
  /// high-quality VR experience.
  /// Devices declaring this feature must include an application implementing a
  /// android.service.vr.VrListenerService that can be targeted by VR applications via
  /// android.app.Activity\#setVrModeEnabled.
  /// and must meet CDD requirements to provide a high-quality VR experience.
  static const FEATURE_VR_MODE_HIGH_PERFORMANCE =
      "android.hardware.vr.high_performance";

  /// from: static public final java.lang.String FEATURE_VULKAN_HARDWARE_COMPUTE
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature(String, int): If this feature is supported, the Vulkan native API
  /// will enumerate at least one {@code VkPhysicalDevice}, and the feature version will indicate
  /// what level of optional compute features that device supports beyond the Vulkan 1.0
  /// requirements.
  ///
  /// Compute level 0 indicates:
  /// <ul>
  /// <li>The {@code VK_KHR_variable_pointers} extension and
  ///     {@code VkPhysicalDeviceVariablePointerFeaturesKHR::variablePointers} feature are
  ///      supported.</li>
  /// <li>{@code VkPhysicalDeviceLimits::maxPerStageDescriptorStorageBuffers} is at least 16.</li>
  /// </ul>
  static const FEATURE_VULKAN_HARDWARE_COMPUTE =
      "android.hardware.vulkan.compute";

  /// from: static public final java.lang.String FEATURE_VULKAN_HARDWARE_LEVEL
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature(String, int): If this feature is supported, the Vulkan native API
  /// will enumerate at least one {@code VkPhysicalDevice}, and the feature version will indicate
  /// what level of optional hardware features limits it supports.
  ///
  /// Level 0 includes the base Vulkan requirements as well as:
  /// <ul><li>{@code VkPhysicalDeviceFeatures::textureCompressionETC2}</li></ul>
  ///
  /// Level 1 additionally includes:
  /// <ul>
  /// <li>{@code VkPhysicalDeviceFeatures::fullDrawIndexUint32}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::imageCubeArray}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::independentBlend}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::geometryShader}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::tessellationShader}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::sampleRateShading}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::textureCompressionASTC_LDR}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::fragmentStoresAndAtomics}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::shaderImageGatherExtended}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::shaderUniformBufferArrayDynamicIndexing}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::shaderSampledImageArrayDynamicIndexing}</li>
  /// </ul>
  static const FEATURE_VULKAN_HARDWARE_LEVEL = "android.hardware.vulkan.level";

  /// from: static public final java.lang.String FEATURE_VULKAN_HARDWARE_VERSION
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature(String, int): The version of this feature indicates the highest
  /// {@code VkPhysicalDeviceProperties::apiVersion} supported by the physical devices that support
  /// the hardware level indicated by \#FEATURE_VULKAN_HARDWARE_LEVEL. The feature version
  /// uses the same encoding as Vulkan version numbers:
  /// <ul>
  /// <li>Major version number in bits 31-22</li>
  /// <li>Minor version number in bits 21-12</li>
  /// <li>Patch version number in bits 11-0</li>
  /// </ul>
  /// A version of 1.1.0 or higher also indicates:
  /// <ul>
  /// <li>{@code SYNC_FD} external semaphore and fence handles are supported.</li>
  /// <li>{@code VkPhysicalDeviceSamplerYcbcrConversionFeatures::samplerYcbcrConversion} is
  ///     supported.</li>
  /// </ul>
  static const FEATURE_VULKAN_HARDWARE_VERSION =
      "android.hardware.vulkan.version";

  /// from: static public final java.lang.String FEATURE_WATCH
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: This is a device dedicated to showing UI
  /// on a watch. A watch here is defined to be a device worn on the body, perhaps on
  /// the wrist. The user is very close when interacting with the device.
  static const FEATURE_WATCH = "android.hardware.type.watch";

  /// from: static public final java.lang.String FEATURE_WEBVIEW
  ///
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device has a full implementation of the android.webkit.* APIs. Devices
  /// lacking this feature will not have a functioning WebView implementation.
  static const FEATURE_WEBVIEW = "android.software.webview";

  /// from: static public final java.lang.String FEATURE_WIFI
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports WiFi (802.11) networking.
  static const FEATURE_WIFI = "android.hardware.wifi";

  /// from: static public final java.lang.String FEATURE_WIFI_AWARE
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports Wi-Fi Aware.
  static const FEATURE_WIFI_AWARE = "android.hardware.wifi.aware";

  /// from: static public final java.lang.String FEATURE_WIFI_DIRECT
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports Wi-Fi Direct networking.
  static const FEATURE_WIFI_DIRECT = "android.hardware.wifi.direct";

  /// from: static public final java.lang.String FEATURE_WIFI_PASSPOINT
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports Wi-Fi Passpoint and all
  /// Passpoint related APIs in WifiManager are supported. Refer to
  /// WifiManager\#addOrUpdatePasspointConfiguration for more info.
  static const FEATURE_WIFI_PASSPOINT = "android.hardware.wifi.passpoint";

  /// from: static public final java.lang.String FEATURE_WIFI_RTT
  ///
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports Wi-Fi RTT (IEEE 802.11mc).
  static const FEATURE_WIFI_RTT = "android.hardware.wifi.rtt";

  /// from: static public final int GET_ACTIVITIES
  ///
  /// PackageInfo flag: return information about
  /// activities in the package in PackageInfo\#activities.
  static const GET_ACTIVITIES = 1;

  /// from: static public final int GET_CONFIGURATIONS
  ///
  /// PackageInfo flag: return information about
  /// hardware preferences in
  /// PackageInfo\#configPreferences PackageInfo.configPreferences,
  /// and requested features in PackageInfo\#reqFeatures and
  /// PackageInfo\#featureGroups.
  static const GET_CONFIGURATIONS = 16384;

  /// from: static public final int GET_DISABLED_COMPONENTS
  ///
  /// @deprecated replaced with \#MATCH_DISABLED_COMPONENTS
  static const GET_DISABLED_COMPONENTS = 512;

  /// from: static public final int GET_DISABLED_UNTIL_USED_COMPONENTS
  ///
  /// @deprecated replaced with \#MATCH_DISABLED_UNTIL_USED_COMPONENTS.
  static const GET_DISABLED_UNTIL_USED_COMPONENTS = 32768;

  /// from: static public final int GET_GIDS
  ///
  /// PackageInfo flag: return the
  /// PackageInfo\#gids group ids that are associated with an
  /// application.
  /// This applies for any API returning a PackageInfo class, either
  /// directly or nested inside of another.
  static const GET_GIDS = 256;

  /// from: static public final int GET_INSTRUMENTATION
  ///
  /// PackageInfo flag: return information about
  /// instrumentation in the package in
  /// PackageInfo\#instrumentation.
  static const GET_INSTRUMENTATION = 16;

  /// from: static public final int GET_INTENT_FILTERS
  ///
  /// PackageInfo flag: return information about the
  /// intent filters supported by the activity.
  static const GET_INTENT_FILTERS = 32;

  /// from: static public final int GET_META_DATA
  ///
  /// ComponentInfo flag: return the ComponentInfo\#metaData
  /// data android.os.Bundles that are associated with a component.
  /// This applies for any API returning a ComponentInfo subclass.
  static const GET_META_DATA = 128;

  /// from: static public final int GET_PERMISSIONS
  ///
  /// PackageInfo flag: return information about
  /// permissions in the package in
  /// PackageInfo\#permissions.
  static const GET_PERMISSIONS = 4096;

  /// from: static public final int GET_PROVIDERS
  ///
  /// PackageInfo flag: return information about
  /// content providers in the package in
  /// PackageInfo\#providers.
  static const GET_PROVIDERS = 8;

  /// from: static public final int GET_RECEIVERS
  ///
  /// PackageInfo flag: return information about
  /// intent receivers in the package in
  /// PackageInfo\#receivers.
  static const GET_RECEIVERS = 2;

  /// from: static public final int GET_RESOLVED_FILTER
  ///
  /// ResolveInfo flag: return the IntentFilter that
  /// was matched for a particular ResolveInfo in
  /// ResolveInfo\#filter.
  static const GET_RESOLVED_FILTER = 64;

  /// from: static public final int GET_SERVICES
  ///
  /// PackageInfo flag: return information about
  /// services in the package in PackageInfo\#services.
  static const GET_SERVICES = 4;

  /// from: static public final int GET_SHARED_LIBRARY_FILES
  ///
  /// ApplicationInfo flag: return the
  /// ApplicationInfo\#sharedLibraryFiles paths to the shared libraries
  /// that are associated with an application.
  /// This applies for any API returning an ApplicationInfo class, either
  /// directly or nested inside of another.
  static const GET_SHARED_LIBRARY_FILES = 1024;

  /// from: static public final int GET_SIGNATURES
  ///
  /// PackageInfo flag: return information about the
  /// signatures included in the package.
  ///@deprecated use {@code GET_SIGNING_CERTIFICATES} instead
  static const GET_SIGNATURES = 64;

  /// from: static public final int GET_SIGNING_CERTIFICATES
  ///
  /// PackageInfo flag: return the signing certificates associated with
  /// this package.  Each entry is a signing certificate that the package
  /// has proven it is authorized to use, usually a past signing certificate from
  /// which it has rotated.
  static const GET_SIGNING_CERTIFICATES = 134217728;

  /// from: static public final int GET_UNINSTALLED_PACKAGES
  ///
  /// @deprecated replaced with \#MATCH_UNINSTALLED_PACKAGES
  static const GET_UNINSTALLED_PACKAGES = 8192;

  /// from: static public final int GET_URI_PERMISSION_PATTERNS
  ///
  /// ProviderInfo flag: return the
  /// ProviderInfo\#uriPermissionPatterns URI permission patterns
  /// that are associated with a content provider.
  /// This applies for any API returning a ProviderInfo class, either
  /// directly or nested inside of another.
  static const GET_URI_PERMISSION_PATTERNS = 2048;

  /// from: static public final int INSTALL_REASON_DEVICE_RESTORE
  ///
  /// Code indicating that this package was installed as part of restoring from another device.
  static const INSTALL_REASON_DEVICE_RESTORE = 2;

  /// from: static public final int INSTALL_REASON_DEVICE_SETUP
  ///
  /// Code indicating that this package was installed as part of device setup.
  static const INSTALL_REASON_DEVICE_SETUP = 3;

  /// from: static public final int INSTALL_REASON_POLICY
  ///
  /// Code indicating that this package was installed due to enterprise policy.
  static const INSTALL_REASON_POLICY = 1;

  /// from: static public final int INSTALL_REASON_UNKNOWN
  ///
  /// Code indicating that the reason for installing this package is unknown.
  static const INSTALL_REASON_UNKNOWN = 0;

  /// from: static public final int INSTALL_REASON_USER
  ///
  /// Code indicating that the package installation was initiated by the user.
  static const INSTALL_REASON_USER = 4;

  /// from: static public final int MATCH_ALL
  ///
  /// Querying flag: if set and if the platform is doing any filtering of the
  /// results, then the filtering will not happen. This is a synonym for saying
  /// that all results should be returned.
  ///
  /// _This flag should be used with extreme care._
  static const MATCH_ALL = 131072;

  /// from: static public final int MATCH_DEFAULT_ONLY
  ///
  /// Resolution and querying flag: if set, only filters that support the
  /// android.content.Intent\#CATEGORY_DEFAULT will be considered for
  /// matching.  This is a synonym for including the CATEGORY_DEFAULT in your
  /// supplied Intent.
  static const MATCH_DEFAULT_ONLY = 65536;

  /// from: static public final int MATCH_DIRECT_BOOT_AWARE
  ///
  /// Querying flag: match components which are direct boot _aware_ in
  /// the returned info, regardless of the current user state.
  ///
  /// When neither \#MATCH_DIRECT_BOOT_AWARE nor
  /// \#MATCH_DIRECT_BOOT_UNAWARE are specified, the default behavior is
  /// to match only runnable components based on the user state. For example,
  /// when a user is started but credentials have not been presented yet, the
  /// user is running "locked" and only \#MATCH_DIRECT_BOOT_AWARE
  /// components are returned. Once the user credentials have been presented,
  /// the user is running "unlocked" and both \#MATCH_DIRECT_BOOT_AWARE
  /// and \#MATCH_DIRECT_BOOT_UNAWARE components are returned.
  ///@see UserManager\#isUserUnlocked()
  static const MATCH_DIRECT_BOOT_AWARE = 524288;

  /// from: static public final int MATCH_DIRECT_BOOT_UNAWARE
  ///
  /// Querying flag: match components which are direct boot _unaware_ in
  /// the returned info, regardless of the current user state.
  ///
  /// When neither \#MATCH_DIRECT_BOOT_AWARE nor
  /// \#MATCH_DIRECT_BOOT_UNAWARE are specified, the default behavior is
  /// to match only runnable components based on the user state. For example,
  /// when a user is started but credentials have not been presented yet, the
  /// user is running "locked" and only \#MATCH_DIRECT_BOOT_AWARE
  /// components are returned. Once the user credentials have been presented,
  /// the user is running "unlocked" and both \#MATCH_DIRECT_BOOT_AWARE
  /// and \#MATCH_DIRECT_BOOT_UNAWARE components are returned.
  ///@see UserManager\#isUserUnlocked()
  static const MATCH_DIRECT_BOOT_UNAWARE = 262144;

  /// from: static public final int MATCH_DISABLED_COMPONENTS
  ///
  /// PackageInfo flag: include disabled components in the returned info.
  static const MATCH_DISABLED_COMPONENTS = 512;

  /// from: static public final int MATCH_DISABLED_UNTIL_USED_COMPONENTS
  ///
  /// PackageInfo flag: include disabled components which are in
  /// that state only because of \#COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED
  /// in the returned info.  Note that if you set this flag, applications
  /// that are in this disabled state will be reported as enabled.
  static const MATCH_DISABLED_UNTIL_USED_COMPONENTS = 32768;

  /// from: static public final int MATCH_SYSTEM_ONLY
  ///
  /// Querying flag: include only components from applications that are marked
  /// with ApplicationInfo\#FLAG_SYSTEM.
  static const MATCH_SYSTEM_ONLY = 1048576;

  /// from: static public final int MATCH_UNINSTALLED_PACKAGES
  ///
  /// Flag parameter to retrieve some information about all applications (even
  /// uninstalled ones) which have data directories. This state could have
  /// resulted if applications have been deleted with flag
  /// {@code DONT_DELETE_DATA} with a possibility of being replaced or
  /// reinstalled in future.
  ///
  /// Note: this flag may cause less information about currently installed
  /// applications to be returned.
  static const MATCH_UNINSTALLED_PACKAGES = 8192;

  /// from: static public final long MAXIMUM_VERIFICATION_TIMEOUT
  ///
  /// Can be used as the {@code millisecondsToDelay} argument for
  /// PackageManager\#extendVerificationTimeout. This is the
  /// maximum time {@code PackageManager} waits for the verification
  /// agent to return (in milliseconds).
  static const MAXIMUM_VERIFICATION_TIMEOUT = 3600000;

  /// from: static public final int PERMISSION_DENIED
  ///
  /// Permission check result: this is returned by \#checkPermission
  /// if the permission has not been granted to the given package.
  static const PERMISSION_DENIED = -1;

  /// from: static public final int PERMISSION_GRANTED
  ///
  /// Permission check result: this is returned by \#checkPermission
  /// if the permission has been granted to the given package.
  static const PERMISSION_GRANTED = 0;

  /// from: static public final int SIGNATURE_FIRST_NOT_SIGNED
  ///
  /// Signature check result: this is returned by \#checkSignatures
  /// if the first package is not signed but the second is.
  static const SIGNATURE_FIRST_NOT_SIGNED = -1;

  /// from: static public final int SIGNATURE_MATCH
  ///
  /// Signature check result: this is returned by \#checkSignatures
  /// if all signatures on the two packages match.
  static const SIGNATURE_MATCH = 0;

  /// from: static public final int SIGNATURE_NEITHER_SIGNED
  ///
  /// Signature check result: this is returned by \#checkSignatures
  /// if neither of the two packages is signed.
  static const SIGNATURE_NEITHER_SIGNED = 1;

  /// from: static public final int SIGNATURE_NO_MATCH
  ///
  /// Signature check result: this is returned by \#checkSignatures
  /// if not all signatures on both packages match.
  static const SIGNATURE_NO_MATCH = -3;

  /// from: static public final int SIGNATURE_SECOND_NOT_SIGNED
  ///
  /// Signature check result: this is returned by \#checkSignatures
  /// if the second package is not signed but the first is.
  static const SIGNATURE_SECOND_NOT_SIGNED = -2;

  /// from: static public final int SIGNATURE_UNKNOWN_PACKAGE
  ///
  /// Signature check result: this is returned by \#checkSignatures
  /// if either of the packages are not valid.
  static const SIGNATURE_UNKNOWN_PACKAGE = -4;

  /// from: static public final int VERIFICATION_ALLOW
  ///
  /// Used as the {@code verificationCode} argument for
  /// PackageManager\#verifyPendingInstall to indicate that the calling
  /// package verifier allows the installation to proceed.
  static const VERIFICATION_ALLOW = 1;

  /// from: static public final int VERIFICATION_REJECT
  ///
  /// Used as the {@code verificationCode} argument for
  /// PackageManager\#verifyPendingInstall to indicate the calling
  /// package verifier does not vote to allow the installation to proceed.
  static const VERIFICATION_REJECT = -1;

  /// from: static public final int VERSION_CODE_HIGHEST
  ///
  /// Constant for specifying the highest installed package version code.
  static const VERSION_CODE_HIGHEST = -1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  PackageManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getPackageInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getPackageInfo",
      "(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;");

  /// from: public abstract android.content.pm.PackageInfo getPackageInfo(java.lang.String packageName, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve overall information about an application package that is
  /// installed on the system.
  ///@param packageName The full name (i.e. com.google.apps.contacts) of the
  ///            desired package.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_ACTIVITIES, android.content.pm.PackageManager\#GET_CONFIGURATIONS, android.content.pm.PackageManager\#GET_GIDS, android.content.pm.PackageManager\#GET_INSTRUMENTATION, android.content.pm.PackageManager\#GET_INTENT_FILTERS, android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_PERMISSIONS, android.content.pm.PackageManager\#GET_PROVIDERS, android.content.pm.PackageManager\#GET_RECEIVERS, android.content.pm.PackageManager\#GET_SERVICES, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#GET_SIGNATURES, android.content.pm.PackageManager\#GET_SIGNING_CERTIFICATES, android.content.pm.PackageManager\#GET_URI_PERMISSION_PATTERNS, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_FACTORY_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return A PackageInfo object containing information about the package. If
  ///         flag {@code MATCH_UNINSTALLED_PACKAGES} is set and if the package
  ///         is not found in the list of installed applications, the package
  ///         information is retrieved from the list of uninstalled
  ///         applications (which includes installed applications as well as
  ///         applications with data directory i.e. applications which had been
  ///         deleted with {@code DONT_DELETE_DATA} flag set).
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  packageinfo_.PackageInfo getPackageInfo(
          jni.JniString packageName, int flags) =>
      packageinfo_.PackageInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPackageInfo,
          jni.JniType.objectType,
          [packageName.reference, flags]).object);

  static final _id_getPackageInfo1 = jniAccessors.getMethodIDOf(
      _classRef,
      "getPackageInfo",
      "(Landroid/content/pm/VersionedPackage;I)Landroid/content/pm/PackageInfo;");

  /// from: public abstract android.content.pm.PackageInfo getPackageInfo(android.content.pm.VersionedPackage versionedPackage, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve overall information about an application package that is
  /// installed on the system. This method can be used for retrieving
  /// information about packages for which multiple versions can be installed
  /// at the time. Currently only packages hosting static shared libraries can
  /// have multiple installed versions. The method can also be used to get info
  /// for a package that has a single version installed by passing
  /// \#VERSION_CODE_HIGHEST in the VersionedPackage
  /// constructor.
  ///@param versionedPackage The versioned package for which to query.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_ACTIVITIES, android.content.pm.PackageManager\#GET_CONFIGURATIONS, android.content.pm.PackageManager\#GET_GIDS, android.content.pm.PackageManager\#GET_INSTRUMENTATION, android.content.pm.PackageManager\#GET_INTENT_FILTERS, android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_PERMISSIONS, android.content.pm.PackageManager\#GET_PROVIDERS, android.content.pm.PackageManager\#GET_RECEIVERS, android.content.pm.PackageManager\#GET_SERVICES, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#GET_SIGNATURES, android.content.pm.PackageManager\#GET_SIGNING_CERTIFICATES, android.content.pm.PackageManager\#GET_URI_PERMISSION_PATTERNS, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_FACTORY_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return A PackageInfo object containing information about the package. If
  ///         flag {@code MATCH_UNINSTALLED_PACKAGES} is set and if the package
  ///         is not found in the list of installed applications, the package
  ///         information is retrieved from the list of uninstalled
  ///         applications (which includes installed applications as well as
  ///         applications with data directory i.e. applications which had been
  ///         deleted with {@code DONT_DELETE_DATA} flag set).
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  packageinfo_.PackageInfo getPackageInfo1(
          versionedpackage_.VersionedPackage versionedPackage, int flags) =>
      packageinfo_.PackageInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPackageInfo1,
          jni.JniType.objectType,
          [versionedPackage.reference, flags]).object);

  static final _id_currentToCanonicalPackageNames = jniAccessors.getMethodIDOf(
      _classRef,
      "currentToCanonicalPackageNames",
      "([Ljava/lang/String;)[Ljava/lang/String;");

  /// from: public abstract java.lang.String[] currentToCanonicalPackageNames(java.lang.String[] names)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Map from the current package names in use on the device to whatever
  /// the current canonical name of that package is.
  ///@param names Array of current names to be mapped.
  ///@return Returns an array of the same size as the original, containing
  /// the canonical name for each package.
  jni.JniObject currentToCanonicalPackageNames(jni.JniObject names) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_currentToCanonicalPackageNames,
          jni.JniType.objectType,
          [names.reference]).object);

  static final _id_canonicalToCurrentPackageNames = jniAccessors.getMethodIDOf(
      _classRef,
      "canonicalToCurrentPackageNames",
      "([Ljava/lang/String;)[Ljava/lang/String;");

  /// from: public abstract java.lang.String[] canonicalToCurrentPackageNames(java.lang.String[] names)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Map from a packages canonical name to the current name in use on the device.
  ///@param names Array of new names to be mapped.
  ///@return Returns an array of the same size as the original, containing
  /// the current name for each package.
  jni.JniObject canonicalToCurrentPackageNames(jni.JniObject names) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_canonicalToCurrentPackageNames,
          jni.JniType.objectType,
          [names.reference]).object);

  static final _id_getLaunchIntentForPackage = jniAccessors.getMethodIDOf(
      _classRef,
      "getLaunchIntentForPackage",
      "(Ljava/lang/String;)Landroid/content/Intent;");

  /// from: public abstract android.content.Intent getLaunchIntentForPackage(java.lang.String packageName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a "good" intent to launch a front-door activity in a package.
  /// This is used, for example, to implement an "open" button when browsing
  /// through packages.  The current implementation looks first for a main
  /// activity in the category Intent\#CATEGORY_INFO, and next for a
  /// main activity in the category Intent\#CATEGORY_LAUNCHER. Returns
  /// <code>null</code> if neither are found.
  ///@param packageName The name of the package to inspect.
  ///
  /// This value must never be {@code null}.
  ///@return A fully-qualified Intent that can be used to launch the
  /// main activity in the package. Returns <code>null</code> if the package
  /// does not contain such an activity, or if _packageName_ is not
  /// recognized.
  intent_.Intent getLaunchIntentForPackage(jni.JniString packageName) =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getLaunchIntentForPackage,
          jni.JniType.objectType,
          [packageName.reference]).object);

  static final _id_getLeanbackLaunchIntentForPackage =
      jniAccessors.getMethodIDOf(_classRef, "getLeanbackLaunchIntentForPackage",
          "(Ljava/lang/String;)Landroid/content/Intent;");

  /// from: public abstract android.content.Intent getLeanbackLaunchIntentForPackage(java.lang.String packageName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a "good" intent to launch a front-door Leanback activity in a
  /// package, for use for example to implement an "open" button when browsing
  /// through packages. The current implementation will look for a main
  /// activity in the category Intent\#CATEGORY_LEANBACK_LAUNCHER, or
  /// return null if no main leanback activities are found.
  ///@param packageName The name of the package to inspect.
  /// This value must never be {@code null}.
  ///@return Returns either a fully-qualified Intent that can be used to launch
  ///         the main Leanback activity in the package, or null if the package
  ///         does not contain such an activity.
  intent_.Intent getLeanbackLaunchIntentForPackage(jni.JniString packageName) =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getLeanbackLaunchIntentForPackage,
          jni.JniType.objectType,
          [packageName.reference]).object);

  static final _id_getPackageGids = jniAccessors.getMethodIDOf(
      _classRef, "getPackageGids", "(Ljava/lang/String;)[I");

  /// from: public abstract int[] getPackageGids(java.lang.String packageName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an array of all of the POSIX secondary group IDs that have been
  /// assigned to the given package.
  ///
  /// Note that the same package may have different GIDs under different
  /// UserHandle on the same device.
  ///@param packageName The full name (i.e. com.google.apps.contacts) of the
  ///            desired package.
  /// This value must never be {@code null}.
  ///@return Returns an int array of the assigned GIDs, or null if there are
  ///         none.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  jni.JniObject getPackageGids(jni.JniString packageName) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPackageGids,
          jni.JniType.objectType,
          [packageName.reference]).object);

  static final _id_getPackageGids1 = jniAccessors.getMethodIDOf(
      _classRef, "getPackageGids", "(Ljava/lang/String;I)[I");

  /// from: public abstract int[] getPackageGids(java.lang.String packageName, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an array of all of the POSIX secondary group IDs that have been
  /// assigned to the given package.
  ///
  /// Note that the same package may have different GIDs under different
  /// UserHandle on the same device.
  ///@param packageName The full name (i.e. com.google.apps.contacts) of the
  ///            desired package.
  ///@param flags Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_ACTIVITIES, android.content.pm.PackageManager\#GET_CONFIGURATIONS, android.content.pm.PackageManager\#GET_GIDS, android.content.pm.PackageManager\#GET_INSTRUMENTATION, android.content.pm.PackageManager\#GET_INTENT_FILTERS, android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_PERMISSIONS, android.content.pm.PackageManager\#GET_PROVIDERS, android.content.pm.PackageManager\#GET_RECEIVERS, android.content.pm.PackageManager\#GET_SERVICES, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#GET_SIGNATURES, android.content.pm.PackageManager\#GET_SIGNING_CERTIFICATES, android.content.pm.PackageManager\#GET_URI_PERMISSION_PATTERNS, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_FACTORY_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return Returns an int array of the assigned gids, or null if there are
  ///         none.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  jni.JniObject getPackageGids1(jni.JniString packageName, int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPackageGids1,
          jni.JniType.objectType,
          [packageName.reference, flags]).object);

  static final _id_getPackageUid = jniAccessors.getMethodIDOf(
      _classRef, "getPackageUid", "(Ljava/lang/String;I)I");

  /// from: public abstract int getPackageUid(java.lang.String packageName, int flags)
  ///
  /// Return the UID associated with the given package name.
  ///
  /// Note that the same package will have different UIDs under different
  /// UserHandle on the same device.
  ///@param packageName The full name (i.e. com.google.apps.contacts) of the
  ///            desired package.
  ///@param flags Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_ACTIVITIES, android.content.pm.PackageManager\#GET_CONFIGURATIONS, android.content.pm.PackageManager\#GET_GIDS, android.content.pm.PackageManager\#GET_INSTRUMENTATION, android.content.pm.PackageManager\#GET_INTENT_FILTERS, android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_PERMISSIONS, android.content.pm.PackageManager\#GET_PROVIDERS, android.content.pm.PackageManager\#GET_RECEIVERS, android.content.pm.PackageManager\#GET_SERVICES, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#GET_SIGNATURES, android.content.pm.PackageManager\#GET_SIGNING_CERTIFICATES, android.content.pm.PackageManager\#GET_URI_PERMISSION_PATTERNS, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_FACTORY_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return Returns an integer UID who owns the given package name.
  ///@throws NameNotFoundException if a package with the given name can not be
  ///             found on the system.
  int getPackageUid(jni.JniString packageName, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_getPackageUid,
          jni.JniType.intType, [packageName.reference, flags]).integer;

  static final _id_getPermissionInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getPermissionInfo",
      "(Ljava/lang/String;I)Landroid/content/pm/PermissionInfo;");

  /// from: public abstract android.content.pm.PermissionInfo getPermissionInfo(java.lang.String name, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all of the information we know about a particular permission.
  ///@param name The fully qualified name (i.e. com.google.permission.LOGIN)
  ///            of the permission you are interested in.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or android.content.pm.PackageManager\#GET_META_DATA
  ///@return Returns a PermissionInfo containing information about the
  ///         permission.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  permissioninfo_.PermissionInfo getPermissionInfo(
          jni.JniString name, int flags) =>
      permissioninfo_.PermissionInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPermissionInfo,
          jni.JniType.objectType,
          [name.reference, flags]).object);

  static final _id_queryPermissionsByGroup = jniAccessors.getMethodIDOf(
      _classRef,
      "queryPermissionsByGroup",
      "(Ljava/lang/String;I)Ljava/util/List;");

  /// from: public abstract java.util.List<android.content.pm.PermissionInfo> queryPermissionsByGroup(java.lang.String group, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query for all of the permissions associated with a particular group.
  ///@param group The fully qualified name (i.e. com.google.permission.LOGIN)
  ///            of the permission group you are interested in. Use null to
  ///            find all of the permissions not associated with a group.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or android.content.pm.PackageManager\#GET_META_DATA
  ///@return Returns a list of PermissionInfo containing information
  ///         about all of the permissions in the given group.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  jni.JniObject queryPermissionsByGroup(jni.JniString group, int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryPermissionsByGroup,
          jni.JniType.objectType,
          [group.reference, flags]).object);

  static final _id_getPermissionGroupInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getPermissionGroupInfo",
      "(Ljava/lang/String;I)Landroid/content/pm/PermissionGroupInfo;");

  /// from: public abstract android.content.pm.PermissionGroupInfo getPermissionGroupInfo(java.lang.String name, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all of the information we know about a particular group of
  /// permissions.
  ///@param name The fully qualified name (i.e.
  ///            com.google.permission_group.APPS) of the permission you are
  ///            interested in.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or android.content.pm.PackageManager\#GET_META_DATA
  ///@return Returns a PermissionGroupInfo containing information
  ///         about the permission.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  permissiongroupinfo_.PermissionGroupInfo getPermissionGroupInfo(
          jni.JniString name, int flags) =>
      permissiongroupinfo_.PermissionGroupInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getPermissionGroupInfo,
              jni.JniType.objectType, [name.reference, flags]).object);

  static final _id_getAllPermissionGroups = jniAccessors.getMethodIDOf(
      _classRef, "getAllPermissionGroups", "(I)Ljava/util/List;");

  /// from: public abstract java.util.List<android.content.pm.PermissionGroupInfo> getAllPermissionGroups(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all of the known permission groups in the system.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or android.content.pm.PackageManager\#GET_META_DATA
  ///@return Returns a list of PermissionGroupInfo containing
  ///         information about all of the known permission groups.
  jni.JniObject getAllPermissionGroups(int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAllPermissionGroups, jni.JniType.objectType, [flags]).object);

  static final _id_getApplicationInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getApplicationInfo",
      "(Ljava/lang/String;I)Landroid/content/pm/ApplicationInfo;");

  /// from: public abstract android.content.pm.ApplicationInfo getApplicationInfo(java.lang.String packageName, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all of the information we know about a particular
  /// package/application.
  ///@param packageName The full name (i.e. com.google.apps.contacts) of an
  ///            application.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return An ApplicationInfo containing information about the
  ///         package. If flag {@code MATCH_UNINSTALLED_PACKAGES} is set and if
  ///         the package is not found in the list of installed applications,
  ///         the application information is retrieved from the list of
  ///         uninstalled applications (which includes installed applications
  ///         as well as applications with data directory i.e. applications
  ///         which had been deleted with {@code DONT_DELETE_DATA} flag set).
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  applicationinfo_.ApplicationInfo getApplicationInfo(
          jni.JniString packageName, int flags) =>
      applicationinfo_.ApplicationInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getApplicationInfo,
          jni.JniType.objectType,
          [packageName.reference, flags]).object);

  static final _id_getActivityInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getActivityInfo",
      "(Landroid/content/ComponentName;I)Landroid/content/pm/ActivityInfo;");

  /// from: public abstract android.content.pm.ActivityInfo getActivityInfo(android.content.ComponentName component, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all of the information we know about a particular activity
  /// class.
  ///@param component The full component name (i.e.
  ///            com.google.apps.contacts/com.google.apps.contacts.
  ///            ContactsList) of an Activity class.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return An ActivityInfo containing information about the
  ///         activity.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  activityinfo_.ActivityInfo getActivityInfo(
          componentname_.ComponentName component, int flags) =>
      activityinfo_.ActivityInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getActivityInfo,
          jni.JniType.objectType,
          [component.reference, flags]).object);

  static final _id_getReceiverInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getReceiverInfo",
      "(Landroid/content/ComponentName;I)Landroid/content/pm/ActivityInfo;");

  /// from: public abstract android.content.pm.ActivityInfo getReceiverInfo(android.content.ComponentName component, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all of the information we know about a particular receiver
  /// class.
  ///@param component The full component name (i.e.
  ///            com.google.apps.calendar/com.google.apps.calendar.
  ///            CalendarAlarm) of a Receiver class.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return An ActivityInfo containing information about the
  ///         receiver.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  activityinfo_.ActivityInfo getReceiverInfo(
          componentname_.ComponentName component, int flags) =>
      activityinfo_.ActivityInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getReceiverInfo,
          jni.JniType.objectType,
          [component.reference, flags]).object);

  static final _id_getServiceInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getServiceInfo",
      "(Landroid/content/ComponentName;I)Landroid/content/pm/ServiceInfo;");

  /// from: public abstract android.content.pm.ServiceInfo getServiceInfo(android.content.ComponentName component, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all of the information we know about a particular service class.
  ///@param component The full component name (i.e.
  ///            com.google.apps.media/com.google.apps.media.
  ///            BackgroundPlayback) of a Service class.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return A ServiceInfo object containing information about the
  ///         service.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  serviceinfo_.ServiceInfo getServiceInfo(
          componentname_.ComponentName component, int flags) =>
      serviceinfo_.ServiceInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getServiceInfo,
          jni.JniType.objectType,
          [component.reference, flags]).object);

  static final _id_getProviderInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getProviderInfo",
      "(Landroid/content/ComponentName;I)Landroid/content/pm/ProviderInfo;");

  /// from: public abstract android.content.pm.ProviderInfo getProviderInfo(android.content.ComponentName component, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all of the information we know about a particular content
  /// provider class.
  ///@param component The full component name (i.e.
  ///            com.google.providers.media/com.google.providers.media.
  ///            MediaProvider) of a ContentProvider class.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return A ProviderInfo object containing information about the
  ///         provider.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  providerinfo_.ProviderInfo getProviderInfo(
          componentname_.ComponentName component, int flags) =>
      providerinfo_.ProviderInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getProviderInfo,
          jni.JniType.objectType,
          [component.reference, flags]).object);

  static final _id_getInstalledPackages = jniAccessors.getMethodIDOf(
      _classRef, "getInstalledPackages", "(I)Ljava/util/List;");

  /// from: public abstract java.util.List<android.content.pm.PackageInfo> getInstalledPackages(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a List of all packages that are installed for the current user.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_ACTIVITIES, android.content.pm.PackageManager\#GET_CONFIGURATIONS, android.content.pm.PackageManager\#GET_GIDS, android.content.pm.PackageManager\#GET_INSTRUMENTATION, android.content.pm.PackageManager\#GET_INTENT_FILTERS, android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_PERMISSIONS, android.content.pm.PackageManager\#GET_PROVIDERS, android.content.pm.PackageManager\#GET_RECEIVERS, android.content.pm.PackageManager\#GET_SERVICES, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#GET_SIGNATURES, android.content.pm.PackageManager\#GET_SIGNING_CERTIFICATES, android.content.pm.PackageManager\#GET_URI_PERMISSION_PATTERNS, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_FACTORY_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return A List of PackageInfo objects, one for each installed package,
  ///         containing information about the package. In the unlikely case
  ///         there are no installed packages, an empty list is returned. If
  ///         flag {@code MATCH_UNINSTALLED_PACKAGES} is set, the package
  ///         information is retrieved from the list of uninstalled
  ///         applications (which includes installed applications as well as
  ///         applications with data directory i.e. applications which had been
  ///         deleted with {@code DONT_DELETE_DATA} flag set).
  jni.JniObject getInstalledPackages(int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getInstalledPackages, jni.JniType.objectType, [flags]).object);

  static final _id_getPackagesHoldingPermissions = jniAccessors.getMethodIDOf(
      _classRef,
      "getPackagesHoldingPermissions",
      "([Ljava/lang/String;I)Ljava/util/List;");

  /// from: public abstract java.util.List<android.content.pm.PackageInfo> getPackagesHoldingPermissions(java.lang.String[] permissions, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a List of all installed packages that are currently holding any of
  /// the given permissions.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_ACTIVITIES, android.content.pm.PackageManager\#GET_CONFIGURATIONS, android.content.pm.PackageManager\#GET_GIDS, android.content.pm.PackageManager\#GET_INSTRUMENTATION, android.content.pm.PackageManager\#GET_INTENT_FILTERS, android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_PERMISSIONS, android.content.pm.PackageManager\#GET_PROVIDERS, android.content.pm.PackageManager\#GET_RECEIVERS, android.content.pm.PackageManager\#GET_SERVICES, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#GET_SIGNATURES, android.content.pm.PackageManager\#GET_SIGNING_CERTIFICATES, android.content.pm.PackageManager\#GET_URI_PERMISSION_PATTERNS, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_FACTORY_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return A List of PackageInfo objects, one for each installed package
  ///         that holds any of the permissions that were provided, containing
  ///         information about the package. If no installed packages hold any
  ///         of the permissions, an empty list is returned. If flag
  ///         {@code MATCH_UNINSTALLED_PACKAGES} is set, the package
  ///         information is retrieved from the list of uninstalled
  ///         applications (which includes installed applications as well as
  ///         applications with data directory i.e. applications which had been
  ///         deleted with {@code DONT_DELETE_DATA} flag set).
  jni.JniObject getPackagesHoldingPermissions(
          jni.JniObject permissions, int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPackagesHoldingPermissions,
          jni.JniType.objectType,
          [permissions.reference, flags]).object);

  static final _id_checkPermission = jniAccessors.getMethodIDOf(
      _classRef, "checkPermission", "(Ljava/lang/String;Ljava/lang/String;)I");

  /// from: public abstract int checkPermission(java.lang.String permName, java.lang.String pkgName)
  ///
  /// Check whether a particular package has been granted a particular
  /// permission.
  ///@param permName The name of the permission you are checking for.
  ///@param pkgName The name of the package you are checking against.
  ///@return If the package has the permission, PERMISSION_GRANTED is
  /// returned.  If it does not have the permission, PERMISSION_DENIED
  /// is returned.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  ///@see \#PERMISSION_GRANTED
  ///@see \#PERMISSION_DENIED
  int checkPermission(jni.JniString permName, jni.JniString pkgName) =>
      jniAccessors.callMethodWithArgs(reference, _id_checkPermission,
          jni.JniType.intType, [permName.reference, pkgName.reference]).integer;

  static final _id_isPermissionRevokedByPolicy = jniAccessors.getMethodIDOf(
      _classRef,
      "isPermissionRevokedByPolicy",
      "(Ljava/lang/String;Ljava/lang/String;)Z");

  /// from: public abstract boolean isPermissionRevokedByPolicy(java.lang.String permName, java.lang.String pkgName)
  ///
  /// Checks whether a particular permissions has been revoked for a
  /// package by policy. Typically the device owner or the profile owner
  /// may apply such a policy. The user cannot grant policy revoked
  /// permissions, hence the only way for an app to get such a permission
  /// is by a policy change.
  ///@param permName The name of the permission you are checking for.
  /// This value must never be {@code null}.
  ///@param pkgName The name of the package you are checking against.
  ///
  /// This value must never be {@code null}.
  ///@return Whether the permission is restricted by policy.
  bool isPermissionRevokedByPolicy(
          jni.JniString permName, jni.JniString pkgName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isPermissionRevokedByPolicy,
          jni.JniType.booleanType,
          [permName.reference, pkgName.reference]).boolean;

  static final _id_addPermission = jniAccessors.getMethodIDOf(
      _classRef, "addPermission", "(Landroid/content/pm/PermissionInfo;)Z");

  /// from: public abstract boolean addPermission(android.content.pm.PermissionInfo info)
  ///
  /// Add a new dynamic permission to the system.  For this to work, your
  /// package must have defined a permission tree through the
  /// android.R.styleable\#AndroidManifestPermissionTree &lt;permission-tree&gt; tag in its manifest.  A package can only add
  /// permissions to trees that were defined by either its own package or
  /// another with the same user id; a permission is in a tree if it
  /// matches the name of the permission tree + ".": for example,
  /// "com.foo.bar" is a member of the permission tree "com.foo".
  ///
  /// It is good to make your permission tree name descriptive, because you
  /// are taking possession of that entire set of permission names.  Thus, it
  /// must be under a domain you control, with a suffix that will not match
  /// any normal permissions that may be declared in any applications that
  /// are part of that domain.
  ///
  /// New permissions must be added before
  /// any .apks are installed that use those permissions.  Permissions you
  /// add through this method are remembered across reboots of the device.
  /// If the given permission already exists, the info you supply here
  /// will be used to update it.
  ///@param info Description of the permission to be added.
  ///@return Returns true if a new permission was created, false if an
  /// existing one was updated.
  ///@throws SecurityException if you are not allowed to add the
  /// given permission name.
  ///@see \#removePermission(String)
  bool addPermission(permissioninfo_.PermissionInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_addPermission,
          jni.JniType.booleanType, [info.reference]).boolean;

  static final _id_addPermissionAsync = jniAccessors.getMethodIDOf(_classRef,
      "addPermissionAsync", "(Landroid/content/pm/PermissionInfo;)Z");

  /// from: public abstract boolean addPermissionAsync(android.content.pm.PermissionInfo info)
  ///
  /// Like \#addPermission(PermissionInfo) but asynchronously
  /// persists the package manager state after returning from the call,
  /// allowing it to return quicker and batch a series of adds at the
  /// expense of no guarantee the added permission will be retained if
  /// the device is rebooted before it is written.
  bool addPermissionAsync(permissioninfo_.PermissionInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_addPermissionAsync,
          jni.JniType.booleanType, [info.reference]).boolean;

  static final _id_removePermission = jniAccessors.getMethodIDOf(
      _classRef, "removePermission", "(Ljava/lang/String;)V");

  /// from: public abstract void removePermission(java.lang.String name)
  ///
  /// Removes a permission that was previously added with
  /// \#addPermission(PermissionInfo).  The same ownership rules apply
  /// -- you are only allowed to remove permissions that you are allowed
  /// to add.
  ///@param name The name of the permission to remove.
  ///@throws SecurityException if you are not allowed to remove the
  /// given permission name.
  ///@see \#addPermission(PermissionInfo)
  void removePermission(jni.JniString name) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removePermission,
      jni.JniType.voidType,
      [name.reference]).check();

  static final _id_checkSignatures = jniAccessors.getMethodIDOf(
      _classRef, "checkSignatures", "(Ljava/lang/String;Ljava/lang/String;)I");

  /// from: public abstract int checkSignatures(java.lang.String pkg1, java.lang.String pkg2)
  ///
  /// Compare the signatures of two packages to determine if the same
  /// signature appears in both of them.  If they do contain the same
  /// signature, then they are allowed special privileges when working
  /// with each other: they can share the same user-id, run instrumentation
  /// against each other, etc.
  ///@param pkg1 First package name whose signature will be compared.
  ///@param pkg2 Second package name whose signature will be compared.
  ///@return Returns an integer indicating whether all signatures on the
  /// two packages match. The value is >= 0 (\#SIGNATURE_MATCH) if
  /// all signatures match or < 0 if there is not a match (\#SIGNATURE_NO_MATCH or \#SIGNATURE_UNKNOWN_PACKAGE).
  ///
  /// Value is android.content.pm.PackageManager\#SIGNATURE_MATCH, android.content.pm.PackageManager\#SIGNATURE_NEITHER_SIGNED, android.content.pm.PackageManager\#SIGNATURE_FIRST_NOT_SIGNED, android.content.pm.PackageManager\#SIGNATURE_SECOND_NOT_SIGNED, android.content.pm.PackageManager\#SIGNATURE_NO_MATCH, or android.content.pm.PackageManager\#SIGNATURE_UNKNOWN_PACKAGE
  ///@see \#checkSignatures(int, int)
  int checkSignatures(jni.JniString pkg1, jni.JniString pkg2) =>
      jniAccessors.callMethodWithArgs(reference, _id_checkSignatures,
          jni.JniType.intType, [pkg1.reference, pkg2.reference]).integer;

  static final _id_checkSignatures1 =
      jniAccessors.getMethodIDOf(_classRef, "checkSignatures", "(II)I");

  /// from: public abstract int checkSignatures(int uid1, int uid2)
  ///
  /// Like \#checkSignatures(String, String), but takes UIDs of
  /// the two packages to be checked.  This can be useful, for example,
  /// when doing the check in an IPC, where the UID is the only identity
  /// available.  It is functionally identical to determining the package
  /// associated with the UIDs and checking their signatures.
  ///@param uid1 First UID whose signature will be compared.
  ///@param uid2 Second UID whose signature will be compared.
  ///@return Returns an integer indicating whether all signatures on the
  /// two packages match. The value is >= 0 (\#SIGNATURE_MATCH) if
  /// all signatures match or < 0 if there is not a match (\#SIGNATURE_NO_MATCH or \#SIGNATURE_UNKNOWN_PACKAGE).
  ///
  /// Value is android.content.pm.PackageManager\#SIGNATURE_MATCH, android.content.pm.PackageManager\#SIGNATURE_NEITHER_SIGNED, android.content.pm.PackageManager\#SIGNATURE_FIRST_NOT_SIGNED, android.content.pm.PackageManager\#SIGNATURE_SECOND_NOT_SIGNED, android.content.pm.PackageManager\#SIGNATURE_NO_MATCH, or android.content.pm.PackageManager\#SIGNATURE_UNKNOWN_PACKAGE
  ///@see \#checkSignatures(String, String)
  int checkSignatures1(int uid1, int uid2) => jniAccessors.callMethodWithArgs(
      reference,
      _id_checkSignatures1,
      jni.JniType.intType,
      [uid1, uid2]).integer;

  static final _id_getPackagesForUid = jniAccessors.getMethodIDOf(
      _classRef, "getPackagesForUid", "(I)[Ljava/lang/String;");

  /// from: public abstract java.lang.String[] getPackagesForUid(int uid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the names of all packages that are associated with a particular
  /// user id.  In most cases, this will be a single package name, the package
  /// that has been assigned that user id.  Where there are multiple packages
  /// sharing the same user id through the "sharedUserId" mechanism, all
  /// packages with that id will be returned.
  ///@param uid The user id for which you would like to retrieve the
  /// associated packages.
  ///@return Returns an array of one or more packages assigned to the user
  /// id, or null if there are no known packages with the given id.
  jni.JniObject getPackagesForUid(int uid) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getPackagesForUid, jni.JniType.objectType, [uid]).object);

  static final _id_getNameForUid = jniAccessors.getMethodIDOf(
      _classRef, "getNameForUid", "(I)Ljava/lang/String;");

  /// from: public abstract java.lang.String getNameForUid(int uid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the official name associated with a uid. This name is
  /// guaranteed to never change, though it is possible for the underlying
  /// uid to be changed.  That is, if you are storing information about
  /// uids in persistent storage, you should use the string returned
  /// by this function instead of the raw uid.
  ///@param uid The uid for which you would like to retrieve a name.
  ///@return Returns a unique name for the given uid, or null if the
  /// uid is not currently assigned.
  jni.JniString getNameForUid(int uid) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getNameForUid, jni.JniType.objectType, [uid]).object);

  static final _id_getInstalledApplications = jniAccessors.getMethodIDOf(
      _classRef, "getInstalledApplications", "(I)Ljava/util/List;");

  /// from: public abstract java.util.List<android.content.pm.ApplicationInfo> getInstalledApplications(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a List of all application packages that are installed for the
  /// current user. If flag GET_UNINSTALLED_PACKAGES has been set, a list of all
  /// applications including those deleted with {@code DONT_DELETE_DATA}
  /// (partially installed apps with data directory) will be returned.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return A List of ApplicationInfo objects, one for each installed
  ///         application. In the unlikely case there are no installed
  ///         packages, an empty list is returned. If flag
  ///         {@code MATCH_UNINSTALLED_PACKAGES} is set, the application
  ///         information is retrieved from the list of uninstalled
  ///         applications (which includes installed applications as well as
  ///         applications with data directory i.e. applications which had been
  ///         deleted with {@code DONT_DELETE_DATA} flag set).
  jni.JniObject getInstalledApplications(int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getInstalledApplications,
          jni.JniType.objectType,
          [flags]).object);

  static final _id_isInstantApp =
      jniAccessors.getMethodIDOf(_classRef, "isInstantApp", "()Z");

  /// from: public abstract boolean isInstantApp()
  ///
  /// Gets whether this application is an instant app.
  ///@return Whether caller is an instant app.
  ///@see \#isInstantApp(String)
  ///@see \#updateInstantAppCookie(byte[])
  ///@see \#getInstantAppCookie()
  ///@see \#getInstantAppCookieMaxBytes()
  bool isInstantApp() => jniAccessors.callMethodWithArgs(
      reference, _id_isInstantApp, jni.JniType.booleanType, []).boolean;

  static final _id_isInstantApp1 = jniAccessors.getMethodIDOf(
      _classRef, "isInstantApp", "(Ljava/lang/String;)Z");

  /// from: public abstract boolean isInstantApp(java.lang.String packageName)
  ///
  /// Gets whether the given package is an instant app.
  ///@param packageName The package to check
  ///@return Whether the given package is an instant app.
  ///@see \#isInstantApp()
  ///@see \#updateInstantAppCookie(byte[])
  ///@see \#getInstantAppCookie()
  ///@see \#getInstantAppCookieMaxBytes()
  ///@see \#clearInstantAppCookie()
  bool isInstantApp1(jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(reference, _id_isInstantApp1,
          jni.JniType.booleanType, [packageName.reference]).boolean;

  static final _id_getInstantAppCookieMaxBytes = jniAccessors.getMethodIDOf(
      _classRef, "getInstantAppCookieMaxBytes", "()I");

  /// from: public abstract int getInstantAppCookieMaxBytes()
  ///
  /// Gets the maximum size in bytes of the cookie data an instant app
  /// can store on the device.
  ///@return The max cookie size in bytes.
  ///@see \#isInstantApp()
  ///@see \#isInstantApp(String)
  ///@see \#updateInstantAppCookie(byte[])
  ///@see \#getInstantAppCookie()
  ///@see \#clearInstantAppCookie()
  int getInstantAppCookieMaxBytes() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getInstantAppCookieMaxBytes,
      jni.JniType.intType, []).integer;

  static final _id_getInstantAppCookie =
      jniAccessors.getMethodIDOf(_classRef, "getInstantAppCookie", "()[B");

  /// from: public abstract byte[] getInstantAppCookie()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the instant application cookie for this app. Non
  /// instant apps and apps that were instant but were upgraded
  /// to normal apps can still access this API. For instant apps
  /// this cookie is cached for some time after uninstall while for
  /// normal apps the cookie is deleted after the app is uninstalled.
  /// The cookie is always present while the app is installed.
  ///@return The cookie.
  ///
  /// This value will never be {@code null}.
  ///@see \#isInstantApp()
  ///@see \#isInstantApp(String)
  ///@see \#updateInstantAppCookie(byte[])
  ///@see \#getInstantAppCookieMaxBytes()
  ///@see \#clearInstantAppCookie()
  jni.JniObject getInstantAppCookie() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getInstantAppCookie, jni.JniType.objectType, []).object);

  static final _id_clearInstantAppCookie =
      jniAccessors.getMethodIDOf(_classRef, "clearInstantAppCookie", "()V");

  /// from: public abstract void clearInstantAppCookie()
  ///
  /// Clears the instant application cookie for the calling app.
  ///@see \#isInstantApp()
  ///@see \#isInstantApp(String)
  ///@see \#getInstantAppCookieMaxBytes()
  ///@see \#getInstantAppCookie()
  ///@see \#clearInstantAppCookie()
  void clearInstantAppCookie() => jniAccessors.callMethodWithArgs(
      reference, _id_clearInstantAppCookie, jni.JniType.voidType, []).check();

  static final _id_updateInstantAppCookie =
      jniAccessors.getMethodIDOf(_classRef, "updateInstantAppCookie", "([B)V");

  /// from: public abstract void updateInstantAppCookie(byte[] cookie)
  ///
  /// Updates the instant application cookie for the calling app. Non
  /// instant apps and apps that were instant but were upgraded
  /// to normal apps can still access this API. For instant apps
  /// this cookie is cached for some time after uninstall while for
  /// normal apps the cookie is deleted after the app is uninstalled.
  /// The cookie is always present while the app is installed. The
  /// cookie size is limited by \#getInstantAppCookieMaxBytes().
  /// Passing <code>null</code> or an empty array clears the cookie.
  ///
  ///
  ///@param cookie The cookie data.
  ///
  /// This value may be {@code null}.
  ///@see \#isInstantApp()
  ///@see \#isInstantApp(String)
  ///@see \#getInstantAppCookieMaxBytes()
  ///@see \#getInstantAppCookie()
  ///@see \#clearInstantAppCookie()
  ///@throws IllegalArgumentException if the array exceeds max cookie size.
  void updateInstantAppCookie(jni.JniObject cookie) =>
      jniAccessors.callMethodWithArgs(reference, _id_updateInstantAppCookie,
          jni.JniType.voidType, [cookie.reference]).check();

  static final _id_getSystemSharedLibraryNames = jniAccessors.getMethodIDOf(
      _classRef, "getSystemSharedLibraryNames", "()[Ljava/lang/String;");

  /// from: public abstract java.lang.String[] getSystemSharedLibraryNames()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a list of shared libraries that are available on the
  /// system.
  ///@return An array of shared library names that are
  /// available on the system, or null if none are installed.
  jni.JniObject getSystemSharedLibraryNames() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSystemSharedLibraryNames, jni.JniType.objectType, []).object);

  static final _id_getSharedLibraries = jniAccessors.getMethodIDOf(
      _classRef, "getSharedLibraries", "(I)Ljava/util/List;");

  /// from: public abstract java.util.List<android.content.pm.SharedLibraryInfo> getSharedLibraries(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a list of shared libraries on the device.
  ///@param flags To filter the libraries to return.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager.INSTALL_FORWARD_LOCK, android.content.pm.PackageManager.INSTALL_REPLACE_EXISTING, android.content.pm.PackageManager.INSTALL_ALLOW_TEST, android.content.pm.PackageManager.INSTALL_EXTERNAL, android.content.pm.PackageManager.INSTALL_INTERNAL, android.content.pm.PackageManager.INSTALL_FROM_ADB, android.content.pm.PackageManager.INSTALL_ALL_USERS, android.content.pm.PackageManager.INSTALL_ALLOW_DOWNGRADE, android.content.pm.PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS, android.content.pm.PackageManager.INSTALL_FORCE_VOLUME_UUID, android.content.pm.PackageManager.INSTALL_FORCE_PERMISSION_PROMPT, android.content.pm.PackageManager.INSTALL_INSTANT_APP, android.content.pm.PackageManager.INSTALL_DONT_KILL_APP, android.content.pm.PackageManager.INSTALL_FORCE_SDK, android.content.pm.PackageManager.INSTALL_FULL_APP, and android.content.pm.PackageManager.INSTALL_ALLOCATE_AGGRESSIVE
  ///@return The shared library list.
  ///
  /// This value will never be {@code null}.
  ///@see \#MATCH_UNINSTALLED_PACKAGES
  jni.JniObject getSharedLibraries(int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSharedLibraries, jni.JniType.objectType, [flags]).object);

  static final _id_getChangedPackages = jniAccessors.getMethodIDOf(_classRef,
      "getChangedPackages", "(I)Landroid/content/pm/ChangedPackages;");

  /// from: public abstract android.content.pm.ChangedPackages getChangedPackages(int sequenceNumber)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the names of the packages that have been changed
  /// [eg. added, removed or updated] since the given sequence
  /// number.
  /// If no packages have been changed, returns <code>null</code>.
  /// The sequence number starts at <code>0</code> and is
  /// reset every boot.
  ///@param sequenceNumber The first sequence number for which to retrieve package changes.
  /// Value is 0 or greater
  ///@see Settings.Global\#BOOT_COUNT
  changedpackages_.ChangedPackages getChangedPackages(int sequenceNumber) =>
      changedpackages_.ChangedPackages.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getChangedPackages,
          jni.JniType.objectType,
          [sequenceNumber]).object);

  static final _id_getSystemAvailableFeatures = jniAccessors.getMethodIDOf(
      _classRef,
      "getSystemAvailableFeatures",
      "()[Landroid/content/pm/FeatureInfo;");

  /// from: public abstract android.content.pm.FeatureInfo[] getSystemAvailableFeatures()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a list of features that are available on the
  /// system.
  ///@return An array of FeatureInfo classes describing the features
  /// that are available on the system, or null if there are none(!!).
  jni.JniObject getSystemAvailableFeatures() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSystemAvailableFeatures, jni.JniType.objectType, []).object);

  static final _id_hasSystemFeature = jniAccessors.getMethodIDOf(
      _classRef, "hasSystemFeature", "(Ljava/lang/String;)Z");

  /// from: public abstract boolean hasSystemFeature(java.lang.String name)
  ///
  /// Check whether the given feature name is one of the available features as
  /// returned by \#getSystemAvailableFeatures(). This tests for the
  /// presence of _any_ version of the given feature name; use
  /// \#hasSystemFeature(String, int) to check for a minimum version.
  ///@return Returns true if the devices supports the feature, else false.
  bool hasSystemFeature(jni.JniString name) => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasSystemFeature,
      jni.JniType.booleanType,
      [name.reference]).boolean;

  static final _id_hasSystemFeature1 = jniAccessors.getMethodIDOf(
      _classRef, "hasSystemFeature", "(Ljava/lang/String;I)Z");

  /// from: public abstract boolean hasSystemFeature(java.lang.String name, int version)
  ///
  /// Check whether the given feature name and version is one of the available
  /// features as returned by \#getSystemAvailableFeatures(). Since
  /// features are defined to always be backwards compatible, this returns true
  /// if the available feature version is greater than or equal to the
  /// requested version.
  ///@return Returns true if the devices supports the feature, else false.
  bool hasSystemFeature1(jni.JniString name, int version) =>
      jniAccessors.callMethodWithArgs(reference, _id_hasSystemFeature1,
          jni.JniType.booleanType, [name.reference, version]).boolean;

  static final _id_resolveActivity = jniAccessors.getMethodIDOf(
      _classRef,
      "resolveActivity",
      "(Landroid/content/Intent;I)Landroid/content/pm/ResolveInfo;");

  /// from: public abstract android.content.pm.ResolveInfo resolveActivity(android.content.Intent intent, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Determine the best action to perform for a given Intent. This is how
  /// Intent\#resolveActivity finds an activity if a class has not been
  /// explicitly specified.
  ///
  /// _Note:_ if using an implicit Intent (without an explicit
  /// ComponentName specified), be sure to consider whether to set the
  /// \#MATCH_DEFAULT_ONLY only flag. You need to do so to resolve the
  /// activity in the same way that
  /// android.content.Context\#startActivity(Intent) and
  /// android.content.Intent\#resolveActivity(PackageManager) Intent.resolveActivity(PackageManager) do.
  ///
  ///
  ///@param intent An intent containing all of the desired specification
  ///            (action, data, type, category, and/or component).
  ///@param flags Additional option flags to modify the data returned. The
  ///            most important is \#MATCH_DEFAULT_ONLY, to limit the
  ///            resolution to only those activities that support the
  ///            android.content.Intent\#CATEGORY_DEFAULT.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_RESOLVED_FILTER, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return Returns a ResolveInfo object containing the final activity intent
  ///         that was determined to be the best action. Returns null if no
  ///         matching activity was found. If multiple matching activities are
  ///         found and there is no default set, returns a ResolveInfo object
  ///         containing something else, such as the activity resolver.
  resolveinfo_.ResolveInfo resolveActivity(intent_.Intent intent, int flags) =>
      resolveinfo_.ResolveInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_resolveActivity,
          jni.JniType.objectType,
          [intent.reference, flags]).object);

  static final _id_queryIntentActivities = jniAccessors.getMethodIDOf(_classRef,
      "queryIntentActivities", "(Landroid/content/Intent;I)Ljava/util/List;");

  /// from: public abstract java.util.List<android.content.pm.ResolveInfo> queryIntentActivities(android.content.Intent intent, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all activities that can be performed for the given intent.
  ///@param intent The desired intent as per resolveActivity().
  ///@param flags Additional option flags to modify the data returned. The
  ///            most important is \#MATCH_DEFAULT_ONLY, to limit the
  ///            resolution to only those activities that support the
  ///            android.content.Intent\#CATEGORY_DEFAULT. Or, set
  ///            \#MATCH_ALL to prevent any filtering of the results.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_RESOLVED_FILTER, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return Returns a List of ResolveInfo objects containing one entry for
  ///         each matching activity, ordered from best to worst. In other
  ///         words, the first item is what would be returned by
  ///         \#resolveActivity. If there are no matching activities, an
  ///         empty list is returned.
  jni.JniObject queryIntentActivities(intent_.Intent intent, int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryIntentActivities,
          jni.JniType.objectType,
          [intent.reference, flags]).object);

  static final _id_queryIntentActivityOptions = jniAccessors.getMethodIDOf(
      _classRef,
      "queryIntentActivityOptions",
      "(Landroid/content/ComponentName;[Landroid/content/Intent;Landroid/content/Intent;I)Ljava/util/List;");

  /// from: public abstract java.util.List<android.content.pm.ResolveInfo> queryIntentActivityOptions(android.content.ComponentName caller, android.content.Intent[] specifics, android.content.Intent intent, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a set of activities that should be presented to the user as
  /// similar options. This is like \#queryIntentActivities, except it
  /// also allows you to supply a list of more explicit Intents that you would
  /// like to resolve to particular options, and takes care of returning the
  /// final ResolveInfo list in a reasonable order, with no duplicates, based
  /// on those inputs.
  ///@param caller The class name of the activity that is making the request.
  ///            This activity will never appear in the output list. Can be
  ///            null.
  /// This value may be {@code null}.
  ///@param specifics An array of Intents that should be resolved to the first
  ///            specific results. Can be null.
  /// This value may be {@code null}.
  ///@param intent The desired intent as per resolveActivity().
  ///@param flags Additional option flags to modify the data returned. The
  ///            most important is \#MATCH_DEFAULT_ONLY, to limit the
  ///            resolution to only those activities that support the
  ///            android.content.Intent\#CATEGORY_DEFAULT.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_RESOLVED_FILTER, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return Returns a List of ResolveInfo objects containing one entry for
  ///         each matching activity. The list is ordered first by all of the
  ///         intents resolved in <var>specifics</var> and then any additional
  ///         activities that can handle <var>intent</var> but did not get
  ///         included by one of the <var>specifics</var> intents. If there are
  ///         no matching activities, an empty list is returned.
  jni.JniObject queryIntentActivityOptions(componentname_.ComponentName caller,
          jni.JniObject specifics, intent_.Intent intent, int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_queryIntentActivityOptions, jni.JniType.objectType, [
        caller.reference,
        specifics.reference,
        intent.reference,
        flags
      ]).object);

  static final _id_queryBroadcastReceivers = jniAccessors.getMethodIDOf(
      _classRef,
      "queryBroadcastReceivers",
      "(Landroid/content/Intent;I)Ljava/util/List;");

  /// from: public abstract java.util.List<android.content.pm.ResolveInfo> queryBroadcastReceivers(android.content.Intent intent, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all receivers that can handle a broadcast of the given intent.
  ///@param intent The desired intent as per resolveActivity().
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_RESOLVED_FILTER, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return Returns a List of ResolveInfo objects containing one entry for
  ///         each matching receiver, ordered from best to worst. If there are
  ///         no matching receivers, an empty list or null is returned.
  jni.JniObject queryBroadcastReceivers(intent_.Intent intent, int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryBroadcastReceivers,
          jni.JniType.objectType,
          [intent.reference, flags]).object);

  static final _id_resolveService = jniAccessors.getMethodIDOf(
      _classRef,
      "resolveService",
      "(Landroid/content/Intent;I)Landroid/content/pm/ResolveInfo;");

  /// from: public abstract android.content.pm.ResolveInfo resolveService(android.content.Intent intent, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Determine the best service to handle for a given Intent.
  ///@param intent An intent containing all of the desired specification
  ///            (action, data, type, category, and/or component).
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_RESOLVED_FILTER, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return Returns a ResolveInfo object containing the final service intent
  ///         that was determined to be the best action. Returns null if no
  ///         matching service was found.
  resolveinfo_.ResolveInfo resolveService(intent_.Intent intent, int flags) =>
      resolveinfo_.ResolveInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_resolveService,
          jni.JniType.objectType,
          [intent.reference, flags]).object);

  static final _id_queryIntentServices = jniAccessors.getMethodIDOf(_classRef,
      "queryIntentServices", "(Landroid/content/Intent;I)Ljava/util/List;");

  /// from: public abstract java.util.List<android.content.pm.ResolveInfo> queryIntentServices(android.content.Intent intent, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all services that can match the given intent.
  ///@param intent The desired intent as per resolveService().
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_RESOLVED_FILTER, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return Returns a List of ResolveInfo objects containing one entry for
  ///         each matching service, ordered from best to worst. In other
  ///         words, the first item is what would be returned by
  ///         \#resolveService. If there are no matching services, an
  ///         empty list or null is returned.
  jni.JniObject queryIntentServices(intent_.Intent intent, int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryIntentServices,
          jni.JniType.objectType,
          [intent.reference, flags]).object);

  static final _id_queryIntentContentProviders = jniAccessors.getMethodIDOf(
      _classRef,
      "queryIntentContentProviders",
      "(Landroid/content/Intent;I)Ljava/util/List;");

  /// from: public abstract java.util.List<android.content.pm.ResolveInfo> queryIntentContentProviders(android.content.Intent intent, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all providers that can match the given intent.
  ///@param intent An intent containing all of the desired specification
  ///            (action, data, type, category, and/or component).
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_RESOLVED_FILTER, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return Returns a List of ResolveInfo objects containing one entry for
  ///         each matching provider, ordered from best to worst. If there are
  ///         no matching services, an empty list or null is returned.
  jni.JniObject queryIntentContentProviders(intent_.Intent intent, int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryIntentContentProviders,
          jni.JniType.objectType,
          [intent.reference, flags]).object);

  static final _id_resolveContentProvider = jniAccessors.getMethodIDOf(
      _classRef,
      "resolveContentProvider",
      "(Ljava/lang/String;I)Landroid/content/pm/ProviderInfo;");

  /// from: public abstract android.content.pm.ProviderInfo resolveContentProvider(java.lang.String name, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find a single content provider by its base path name.
  ///@param name The name of the provider to find.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return A ProviderInfo object containing information about the
  ///         provider. If a provider was not found, returns null.
  providerinfo_.ProviderInfo resolveContentProvider(
          jni.JniString name, int flags) =>
      providerinfo_.ProviderInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_resolveContentProvider,
          jni.JniType.objectType,
          [name.reference, flags]).object);

  static final _id_queryContentProviders = jniAccessors.getMethodIDOf(_classRef,
      "queryContentProviders", "(Ljava/lang/String;II)Ljava/util/List;");

  /// from: public abstract java.util.List<android.content.pm.ProviderInfo> queryContentProviders(java.lang.String processName, int uid, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve content provider information.
  ///
  /// _Note: unlike most other methods, an empty result set is indicated
  /// by a null return instead of an empty list._
  ///@param processName If non-null, limits the returned providers to only
  ///            those that are hosted by the given process. If null, all
  ///            content providers are returned.
  ///@param uid If <var>processName</var> is non-null, this is the required
  ///            uid owning the requested content providers.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return A list of ProviderInfo objects containing one entry for
  ///         each provider either matching <var>processName</var> or, if
  ///         <var>processName</var> is null, all known content providers.
  ///         _If there are no matching providers, null is returned._
  jni.JniObject queryContentProviders(
          jni.JniString processName, int uid, int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryContentProviders,
          jni.JniType.objectType,
          [processName.reference, uid, flags]).object);

  static final _id_getInstrumentationInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getInstrumentationInfo",
      "(Landroid/content/ComponentName;I)Landroid/content/pm/InstrumentationInfo;");

  /// from: public abstract android.content.pm.InstrumentationInfo getInstrumentationInfo(android.content.ComponentName className, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all of the information we know about a particular
  /// instrumentation class.
  ///@param className The full name (i.e.
  ///            com.google.apps.contacts.InstrumentList) of an Instrumentation
  ///            class.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or android.content.pm.PackageManager\#GET_META_DATA
  ///@return An InstrumentationInfo object containing information
  ///         about the instrumentation.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  instrumentationinfo_.InstrumentationInfo getInstrumentationInfo(
          componentname_.ComponentName className, int flags) =>
      instrumentationinfo_.InstrumentationInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getInstrumentationInfo,
              jni.JniType.objectType, [className.reference, flags]).object);

  static final _id_queryInstrumentation = jniAccessors.getMethodIDOf(_classRef,
      "queryInstrumentation", "(Ljava/lang/String;I)Ljava/util/List;");

  /// from: public abstract java.util.List<android.content.pm.InstrumentationInfo> queryInstrumentation(java.lang.String targetPackage, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve information about available instrumentation code. May be used to
  /// retrieve either all instrumentation code, or only the code targeting a
  /// particular package.
  ///@param targetPackage If null, all instrumentation is returned; only the
  ///            instrumentation targeting this package name is returned.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or android.content.pm.PackageManager\#GET_META_DATA
  ///@return A list of InstrumentationInfo objects containing one
  ///         entry for each matching instrumentation. If there are no
  ///         instrumentation available, returns an empty list.
  jni.JniObject queryInstrumentation(jni.JniString targetPackage, int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryInstrumentation,
          jni.JniType.objectType,
          [targetPackage.reference, flags]).object);

  static final _id_getDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "getDrawable",
      "(Ljava/lang/String;ILandroid/content/pm/ApplicationInfo;)Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getDrawable(java.lang.String packageName, int resid, android.content.pm.ApplicationInfo appInfo)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve an image from a package.  This is a low-level API used by
  /// the various package manager info structures (such as
  /// ComponentInfo to implement retrieval of their associated
  /// icon.
  ///@param packageName The name of the package that this icon is coming from.
  /// Cannot be null.
  ///@param resid The resource identifier of the desired image.  Cannot be 0.
  ///@param appInfo Overall information about <var>packageName</var>.  This
  /// may be null, in which case the application information will be retrieved
  /// for you if needed; if you already have this information around, it can
  /// be much more efficient to supply it here.
  ///@return Returns a Drawable holding the requested image.  Returns null if
  /// an image could not be found for any reason.
  drawable_.Drawable getDrawable(jni.JniString packageName, int resid,
          applicationinfo_.ApplicationInfo appInfo) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDrawable,
          jni.JniType.objectType,
          [packageName.reference, resid, appInfo.reference]).object);

  static final _id_getActivityIcon = jniAccessors.getMethodIDOf(
      _classRef,
      "getActivityIcon",
      "(Landroid/content/ComponentName;)Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getActivityIcon(android.content.ComponentName activityName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the icon associated with an activity.  Given the full name of
  /// an activity, retrieves the information about it and calls
  /// ComponentInfo\#loadIcon ComponentInfo.loadIcon() to return its icon.
  /// If the activity cannot be found, NameNotFoundException is thrown.
  ///@param activityName Name of the activity whose icon is to be retrieved.
  ///@return Returns the image of the icon, or the default activity icon if
  /// it could not be found.  Does not return null.
  ///@throws NameNotFoundException Thrown if the resources for the given
  /// activity could not be loaded.
  ///@see \#getActivityIcon(Intent)
  drawable_.Drawable getActivityIcon(
          componentname_.ComponentName activityName) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getActivityIcon,
          jni.JniType.objectType,
          [activityName.reference]).object);

  static final _id_getActivityIcon1 = jniAccessors.getMethodIDOf(
      _classRef,
      "getActivityIcon",
      "(Landroid/content/Intent;)Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getActivityIcon(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the icon associated with an Intent.  If intent.getClassName() is
  /// set, this simply returns the result of
  /// getActivityIcon(intent.getClassName()).  Otherwise it resolves the intent's
  /// component and returns the icon associated with the resolved component.
  /// If intent.getClassName() cannot be found or the Intent cannot be resolved
  /// to a component, NameNotFoundException is thrown.
  ///@param intent The intent for which you would like to retrieve an icon.
  ///@return Returns the image of the icon, or the default activity icon if
  /// it could not be found.  Does not return null.
  ///@throws NameNotFoundException Thrown if the resources for application
  /// matching the given intent could not be loaded.
  ///@see \#getActivityIcon(ComponentName)
  drawable_.Drawable getActivityIcon1(intent_.Intent intent) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getActivityIcon1,
          jni.JniType.objectType,
          [intent.reference]).object);

  static final _id_getActivityBanner = jniAccessors.getMethodIDOf(
      _classRef,
      "getActivityBanner",
      "(Landroid/content/ComponentName;)Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getActivityBanner(android.content.ComponentName activityName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the banner associated with an activity. Given the full name of
  /// an activity, retrieves the information about it and calls
  /// ComponentInfo\#loadIcon ComponentInfo.loadIcon() to return its
  /// banner. If the activity cannot be found, NameNotFoundException is thrown.
  ///@param activityName Name of the activity whose banner is to be retrieved.
  ///@return Returns the image of the banner, or null if the activity has no
  ///         banner specified.
  ///@throws NameNotFoundException Thrown if the resources for the given
  ///             activity could not be loaded.
  ///@see \#getActivityBanner(Intent)
  drawable_.Drawable getActivityBanner(
          componentname_.ComponentName activityName) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getActivityBanner,
          jni.JniType.objectType,
          [activityName.reference]).object);

  static final _id_getActivityBanner1 = jniAccessors.getMethodIDOf(
      _classRef,
      "getActivityBanner",
      "(Landroid/content/Intent;)Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getActivityBanner(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the banner associated with an Intent. If intent.getClassName()
  /// is set, this simply returns the result of
  /// getActivityBanner(intent.getClassName()). Otherwise it resolves the
  /// intent's component and returns the banner associated with the resolved
  /// component. If intent.getClassName() cannot be found or the Intent cannot
  /// be resolved to a component, NameNotFoundException is thrown.
  ///@param intent The intent for which you would like to retrieve a banner.
  ///@return Returns the image of the banner, or null if the activity has no
  ///         banner specified.
  ///@throws NameNotFoundException Thrown if the resources for application
  ///             matching the given intent could not be loaded.
  ///@see \#getActivityBanner(ComponentName)
  drawable_.Drawable getActivityBanner1(intent_.Intent intent) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getActivityBanner1,
          jni.JniType.objectType,
          [intent.reference]).object);

  static final _id_getDefaultActivityIcon = jniAccessors.getMethodIDOf(
      _classRef,
      "getDefaultActivityIcon",
      "()Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getDefaultActivityIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the generic icon for an activity that is used when no specific
  /// icon is defined.
  ///@return Drawable Image of the icon.
  drawable_.Drawable getDefaultActivityIcon() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDefaultActivityIcon, jni.JniType.objectType, []).object);

  static final _id_getApplicationIcon = jniAccessors.getMethodIDOf(
      _classRef,
      "getApplicationIcon",
      "(Landroid/content/pm/ApplicationInfo;)Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getApplicationIcon(android.content.pm.ApplicationInfo info)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the icon associated with an application.  If it has not defined
  /// an icon, the default app icon is returned.  Does not return null.
  ///@param info Information about application being queried.
  ///@return Returns the image of the icon, or the default application icon
  /// if it could not be found.
  ///@see \#getApplicationIcon(String)
  drawable_.Drawable getApplicationIcon(
          applicationinfo_.ApplicationInfo info) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getApplicationIcon,
          jni.JniType.objectType,
          [info.reference]).object);

  static final _id_getApplicationIcon1 = jniAccessors.getMethodIDOf(
      _classRef,
      "getApplicationIcon",
      "(Ljava/lang/String;)Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getApplicationIcon(java.lang.String packageName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the icon associated with an application.  Given the name of the
  /// application's package, retrieves the information about it and calls
  /// getApplicationIcon() to return its icon. If the application cannot be
  /// found, NameNotFoundException is thrown.
  ///@param packageName Name of the package whose application icon is to be
  ///                    retrieved.
  ///@return Returns the image of the icon, or the default application icon
  /// if it could not be found.  Does not return null.
  ///@throws NameNotFoundException Thrown if the resources for the given
  /// application could not be loaded.
  ///@see \#getApplicationIcon(ApplicationInfo)
  drawable_.Drawable getApplicationIcon1(jni.JniString packageName) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getApplicationIcon1,
          jni.JniType.objectType,
          [packageName.reference]).object);

  static final _id_getApplicationBanner = jniAccessors.getMethodIDOf(
      _classRef,
      "getApplicationBanner",
      "(Landroid/content/pm/ApplicationInfo;)Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getApplicationBanner(android.content.pm.ApplicationInfo info)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the banner associated with an application.
  ///@param info Information about application being queried.
  ///@return Returns the image of the banner or null if the application has no
  ///         banner specified.
  ///@see \#getApplicationBanner(String)
  drawable_.Drawable getApplicationBanner(
          applicationinfo_.ApplicationInfo info) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getApplicationBanner,
          jni.JniType.objectType,
          [info.reference]).object);

  static final _id_getApplicationBanner1 = jniAccessors.getMethodIDOf(
      _classRef,
      "getApplicationBanner",
      "(Ljava/lang/String;)Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getApplicationBanner(java.lang.String packageName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the banner associated with an application. Given the name of the
  /// application's package, retrieves the information about it and calls
  /// getApplicationIcon() to return its banner. If the application cannot be
  /// found, NameNotFoundException is thrown.
  ///@param packageName Name of the package whose application banner is to be
  ///            retrieved.
  ///@return Returns the image of the banner or null if the application has no
  ///         banner specified.
  ///@throws NameNotFoundException Thrown if the resources for the given
  ///             application could not be loaded.
  ///@see \#getApplicationBanner(ApplicationInfo)
  drawable_.Drawable getApplicationBanner1(jni.JniString packageName) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getApplicationBanner1,
          jni.JniType.objectType,
          [packageName.reference]).object);

  static final _id_getActivityLogo = jniAccessors.getMethodIDOf(
      _classRef,
      "getActivityLogo",
      "(Landroid/content/ComponentName;)Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getActivityLogo(android.content.ComponentName activityName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the logo associated with an activity. Given the full name of an
  /// activity, retrieves the information about it and calls
  /// ComponentInfo\#loadLogo ComponentInfo.loadLogo() to return its
  /// logo. If the activity cannot be found, NameNotFoundException is thrown.
  ///@param activityName Name of the activity whose logo is to be retrieved.
  ///@return Returns the image of the logo or null if the activity has no logo
  ///         specified.
  ///@throws NameNotFoundException Thrown if the resources for the given
  ///             activity could not be loaded.
  ///@see \#getActivityLogo(Intent)
  drawable_.Drawable getActivityLogo(
          componentname_.ComponentName activityName) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getActivityLogo,
          jni.JniType.objectType,
          [activityName.reference]).object);

  static final _id_getActivityLogo1 = jniAccessors.getMethodIDOf(
      _classRef,
      "getActivityLogo",
      "(Landroid/content/Intent;)Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getActivityLogo(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the logo associated with an Intent.  If intent.getClassName() is
  /// set, this simply returns the result of
  /// getActivityLogo(intent.getClassName()).  Otherwise it resolves the intent's
  /// component and returns the logo associated with the resolved component.
  /// If intent.getClassName() cannot be found or the Intent cannot be resolved
  /// to a component, NameNotFoundException is thrown.
  ///@param intent The intent for which you would like to retrieve a logo.
  ///@return Returns the image of the logo, or null if the activity has no
  /// logo specified.
  ///@throws NameNotFoundException Thrown if the resources for application
  /// matching the given intent could not be loaded.
  ///@see \#getActivityLogo(ComponentName)
  drawable_.Drawable getActivityLogo1(intent_.Intent intent) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getActivityLogo1,
          jni.JniType.objectType,
          [intent.reference]).object);

  static final _id_getApplicationLogo = jniAccessors.getMethodIDOf(
      _classRef,
      "getApplicationLogo",
      "(Landroid/content/pm/ApplicationInfo;)Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getApplicationLogo(android.content.pm.ApplicationInfo info)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the logo associated with an application.  If it has not specified
  /// a logo, this method returns null.
  ///@param info Information about application being queried.
  ///@return Returns the image of the logo, or null if no logo is specified
  /// by the application.
  ///@see \#getApplicationLogo(String)
  drawable_.Drawable getApplicationLogo(
          applicationinfo_.ApplicationInfo info) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getApplicationLogo,
          jni.JniType.objectType,
          [info.reference]).object);

  static final _id_getApplicationLogo1 = jniAccessors.getMethodIDOf(
      _classRef,
      "getApplicationLogo",
      "(Ljava/lang/String;)Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getApplicationLogo(java.lang.String packageName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the logo associated with an application.  Given the name of the
  /// application's package, retrieves the information about it and calls
  /// getApplicationLogo() to return its logo. If the application cannot be
  /// found, NameNotFoundException is thrown.
  ///@param packageName Name of the package whose application logo is to be
  ///                    retrieved.
  ///@return Returns the image of the logo, or null if no application logo
  /// has been specified.
  ///@throws NameNotFoundException Thrown if the resources for the given
  /// application could not be loaded.
  ///@see \#getApplicationLogo(ApplicationInfo)
  drawable_.Drawable getApplicationLogo1(jni.JniString packageName) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getApplicationLogo1,
          jni.JniType.objectType,
          [packageName.reference]).object);

  static final _id_getUserBadgedIcon = jniAccessors.getMethodIDOf(
      _classRef,
      "getUserBadgedIcon",
      "(Landroid/graphics/drawable/Drawable;Landroid/os/UserHandle;)Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getUserBadgedIcon(android.graphics.drawable.Drawable icon, android.os.UserHandle user)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If the target user is a managed profile, then this returns a badged copy of the given icon
  /// to be able to distinguish it from the original icon. For badging an arbitrary drawable use
  /// \#getUserBadgedDrawableForDensity(
  /// android.graphics.drawable.Drawable, UserHandle, android.graphics.Rect, int).
  ///
  /// If the original drawable is a BitmapDrawable and the backing bitmap is
  /// mutable as per android.graphics.Bitmap\#isMutable(), the badging
  /// is performed in place and the original drawable is returned.
  ///
  ///
  ///@param icon The icon to badge.
  ///@param user The target user.
  ///@return A drawable that combines the original icon and a badge as
  ///         determined by the system.
  drawable_.Drawable getUserBadgedIcon(
          drawable_.Drawable icon, userhandle_.UserHandle user) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getUserBadgedIcon,
          jni.JniType.objectType,
          [icon.reference, user.reference]).object);

  static final _id_getUserBadgedDrawableForDensity = jniAccessors.getMethodIDOf(
      _classRef,
      "getUserBadgedDrawableForDensity",
      "(Landroid/graphics/drawable/Drawable;Landroid/os/UserHandle;Landroid/graphics/Rect;I)Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getUserBadgedDrawableForDensity(android.graphics.drawable.Drawable drawable, android.os.UserHandle user, android.graphics.Rect badgeLocation, int badgeDensity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If the target user is a managed profile of the calling user or the caller
  /// is itself a managed profile, then this returns a badged copy of the given
  /// drawable allowing the user to distinguish it from the original drawable.
  /// The caller can specify the location in the bounds of the drawable to be
  /// badged where the badge should be applied as well as the density of the
  /// badge to be used.
  ///
  /// If the original drawable is a BitmapDrawable and the backing bitmap is
  /// mutable as per android.graphics.Bitmap\#isMutable(), the badging
  /// is performed in place and the original drawable is returned.
  ///
  ///
  ///@param drawable The drawable to badge.
  ///@param user The target user.
  ///@param badgeLocation Where in the bounds of the badged drawable to place
  ///         the badge. If it's {@code null}, the badge is applied on top of the entire
  ///         drawable being badged.
  ///@param badgeDensity The optional desired density for the badge as per
  ///         android.util.DisplayMetrics\#densityDpi. If it's not positive,
  ///         the density of the display is used.
  ///@return A drawable that combines the original drawable and a badge as
  ///         determined by the system.
  drawable_.Drawable getUserBadgedDrawableForDensity(
          drawable_.Drawable drawable,
          userhandle_.UserHandle user,
          rect_.Rect badgeLocation,
          int badgeDensity) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getUserBadgedDrawableForDensity, jni.JniType.objectType, [
        drawable.reference,
        user.reference,
        badgeLocation.reference,
        badgeDensity
      ]).object);

  static final _id_getUserBadgedLabel = jniAccessors.getMethodIDOf(
      _classRef,
      "getUserBadgedLabel",
      "(Ljava/lang/CharSequence;Landroid/os/UserHandle;)Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence getUserBadgedLabel(java.lang.CharSequence label, android.os.UserHandle user)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If the target user is a managed profile of the calling user or the caller
  /// is itself a managed profile, then this returns a copy of the label with
  /// badging for accessibility services like talkback. E.g. passing in "Email"
  /// and it might return "Work Email" for Email in the work profile.
  ///@param label The label to change.
  ///@param user The target user.
  ///@return A label that combines the original label and a badge as
  ///         determined by the system.
  jni.JniObject getUserBadgedLabel(
          jni.JniObject label, userhandle_.UserHandle user) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getUserBadgedLabel,
          jni.JniType.objectType,
          [label.reference, user.reference]).object);

  static final _id_getText = jniAccessors.getMethodIDOf(_classRef, "getText",
      "(Ljava/lang/String;ILandroid/content/pm/ApplicationInfo;)Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence getText(java.lang.String packageName, int resid, android.content.pm.ApplicationInfo appInfo)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve text from a package.  This is a low-level API used by
  /// the various package manager info structures (such as
  /// ComponentInfo to implement retrieval of their associated
  /// labels and other text.
  ///@param packageName The name of the package that this text is coming from.
  /// Cannot be null.
  ///@param resid The resource identifier of the desired text.  Cannot be 0.
  ///@param appInfo Overall information about <var>packageName</var>.  This
  /// may be null, in which case the application information will be retrieved
  /// for you if needed; if you already have this information around, it can
  /// be much more efficient to supply it here.
  ///@return Returns a CharSequence holding the requested text.  Returns null
  /// if the text could not be found for any reason.
  jni.JniObject getText(jni.JniString packageName, int resid,
          applicationinfo_.ApplicationInfo appInfo) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getText,
          jni.JniType.objectType,
          [packageName.reference, resid, appInfo.reference]).object);

  static final _id_getXml = jniAccessors.getMethodIDOf(_classRef, "getXml",
      "(Ljava/lang/String;ILandroid/content/pm/ApplicationInfo;)Landroid/content/res/XmlResourceParser;");

  /// from: public abstract android.content.res.XmlResourceParser getXml(java.lang.String packageName, int resid, android.content.pm.ApplicationInfo appInfo)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve an XML file from a package.  This is a low-level API used to
  /// retrieve XML meta data.
  ///@param packageName The name of the package that this xml is coming from.
  /// Cannot be null.
  ///@param resid The resource identifier of the desired xml.  Cannot be 0.
  ///@param appInfo Overall information about <var>packageName</var>.  This
  /// may be null, in which case the application information will be retrieved
  /// for you if needed; if you already have this information around, it can
  /// be much more efficient to supply it here.
  ///@return Returns an XmlPullParser allowing you to parse out the XML
  /// data.  Returns null if the xml resource could not be found for any
  /// reason.
  xmlresourceparser_.XmlResourceParser getXml(jni.JniString packageName,
          int resid, applicationinfo_.ApplicationInfo appInfo) =>
      xmlresourceparser_.XmlResourceParser.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getXml, jni.JniType.objectType,
              [packageName.reference, resid, appInfo.reference]).object);

  static final _id_getApplicationLabel = jniAccessors.getMethodIDOf(
      _classRef,
      "getApplicationLabel",
      "(Landroid/content/pm/ApplicationInfo;)Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence getApplicationLabel(android.content.pm.ApplicationInfo info)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the label to use for this application.
  ///@return Returns the label associated with this application, or null if
  /// it could not be found for any reason.
  ///@param info The application to get the label of.
  jni.JniObject getApplicationLabel(applicationinfo_.ApplicationInfo info) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getApplicationLabel,
          jni.JniType.objectType,
          [info.reference]).object);

  static final _id_getResourcesForActivity = jniAccessors.getMethodIDOf(
      _classRef,
      "getResourcesForActivity",
      "(Landroid/content/ComponentName;)Landroid/content/res/Resources;");

  /// from: public abstract android.content.res.Resources getResourcesForActivity(android.content.ComponentName activityName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the resources associated with an activity.  Given the full
  /// name of an activity, retrieves the information about it and calls
  /// getResources() to return its application's resources.  If the activity
  /// cannot be found, NameNotFoundException is thrown.
  ///@param activityName Name of the activity whose resources are to be
  ///                     retrieved.
  ///@return Returns the application's Resources.
  ///@throws NameNotFoundException Thrown if the resources for the given
  /// application could not be loaded.
  ///@see \#getResourcesForApplication(ApplicationInfo)
  resources_.Resources getResourcesForActivity(
          componentname_.ComponentName activityName) =>
      resources_.Resources.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getResourcesForActivity,
          jni.JniType.objectType,
          [activityName.reference]).object);

  static final _id_getResourcesForApplication = jniAccessors.getMethodIDOf(
      _classRef,
      "getResourcesForApplication",
      "(Landroid/content/pm/ApplicationInfo;)Landroid/content/res/Resources;");

  /// from: public abstract android.content.res.Resources getResourcesForApplication(android.content.pm.ApplicationInfo app)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the resources for an application.  Throws NameNotFoundException
  /// if the package is no longer installed.
  ///@param app Information about the desired application.
  ///@return Returns the application's Resources.
  ///@throws NameNotFoundException Thrown if the resources for the given
  /// application could not be loaded (most likely because it was uninstalled).
  resources_.Resources getResourcesForApplication(
          applicationinfo_.ApplicationInfo app) =>
      resources_.Resources.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getResourcesForApplication,
          jni.JniType.objectType,
          [app.reference]).object);

  static final _id_getResourcesForApplication1 = jniAccessors.getMethodIDOf(
      _classRef,
      "getResourcesForApplication",
      "(Ljava/lang/String;)Landroid/content/res/Resources;");

  /// from: public abstract android.content.res.Resources getResourcesForApplication(java.lang.String appPackageName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the resources associated with an application.  Given the full
  /// package name of an application, retrieves the information about it and
  /// calls getResources() to return its application's resources.  If the
  /// appPackageName cannot be found, NameNotFoundException is thrown.
  ///@param appPackageName Package name of the application whose resources
  ///                       are to be retrieved.
  ///@return Returns the application's Resources.
  ///@throws NameNotFoundException Thrown if the resources for the given
  /// application could not be loaded.
  ///@see \#getResourcesForApplication(ApplicationInfo)
  resources_.Resources getResourcesForApplication1(
          jni.JniString appPackageName) =>
      resources_.Resources.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getResourcesForApplication1,
          jni.JniType.objectType,
          [appPackageName.reference]).object);

  static final _id_getPackageArchiveInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getPackageArchiveInfo",
      "(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;");

  /// from: public android.content.pm.PackageInfo getPackageArchiveInfo(java.lang.String archiveFilePath, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve overall information about an application package defined in a
  /// package archive file
  ///@param archiveFilePath The path to the archive file
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_ACTIVITIES, android.content.pm.PackageManager\#GET_CONFIGURATIONS, android.content.pm.PackageManager\#GET_GIDS, android.content.pm.PackageManager\#GET_INSTRUMENTATION, android.content.pm.PackageManager\#GET_INTENT_FILTERS, android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_PERMISSIONS, android.content.pm.PackageManager\#GET_PROVIDERS, android.content.pm.PackageManager\#GET_RECEIVERS, android.content.pm.PackageManager\#GET_SERVICES, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#GET_SIGNATURES, android.content.pm.PackageManager\#GET_SIGNING_CERTIFICATES, android.content.pm.PackageManager\#GET_URI_PERMISSION_PATTERNS, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_FACTORY_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return A PackageInfo object containing information about the package
  ///         archive. If the package could not be parsed, returns null.
  packageinfo_.PackageInfo getPackageArchiveInfo(
          jni.JniString archiveFilePath, int flags) =>
      packageinfo_.PackageInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPackageArchiveInfo,
          jni.JniType.objectType,
          [archiveFilePath.reference, flags]).object);

  static final _id_verifyPendingInstall =
      jniAccessors.getMethodIDOf(_classRef, "verifyPendingInstall", "(II)V");

  /// from: public abstract void verifyPendingInstall(int id, int verificationCode)
  ///
  /// Allows a package listening to the
  /// Intent\#ACTION_PACKAGE_NEEDS_VERIFICATION package verification
  /// broadcast to respond to the package manager. The response must include
  /// the {@code verificationCode} which is one of
  /// PackageManager\#VERIFICATION_ALLOW or
  /// PackageManager\#VERIFICATION_REJECT.
  ///@param id pending package identifier as passed via the
  ///            PackageManager\#EXTRA_VERIFICATION_ID Intent extra.
  ///@param verificationCode either PackageManager\#VERIFICATION_ALLOW
  ///            or PackageManager\#VERIFICATION_REJECT.
  ///@throws SecurityException if the caller does not have the
  ///            PACKAGE_VERIFICATION_AGENT permission.
  void verifyPendingInstall(int id, int verificationCode) =>
      jniAccessors.callMethodWithArgs(reference, _id_verifyPendingInstall,
          jni.JniType.voidType, [id, verificationCode]).check();

  static final _id_extendVerificationTimeout = jniAccessors.getMethodIDOf(
      _classRef, "extendVerificationTimeout", "(IIJ)V");

  /// from: public abstract void extendVerificationTimeout(int id, int verificationCodeAtTimeout, long millisecondsToDelay)
  ///
  /// Allows a package listening to the
  /// Intent\#ACTION_PACKAGE_NEEDS_VERIFICATION package verification
  /// broadcast to extend the default timeout for a response and declare what
  /// action to perform after the timeout occurs. The response must include
  /// the {@code verificationCodeAtTimeout} which is one of
  /// PackageManager\#VERIFICATION_ALLOW or
  /// PackageManager\#VERIFICATION_REJECT.
  ///
  /// This method may only be called once per package id. Additional calls
  /// will have no effect.
  ///@param id pending package identifier as passed via the
  ///            PackageManager\#EXTRA_VERIFICATION_ID Intent extra.
  ///@param verificationCodeAtTimeout either
  ///            PackageManager\#VERIFICATION_ALLOW or
  ///            PackageManager\#VERIFICATION_REJECT. If
  ///            {@code verificationCodeAtTimeout} is neither
  ///            PackageManager\#VERIFICATION_ALLOW or
  ///            PackageManager\#VERIFICATION_REJECT, then
  ///            {@code verificationCodeAtTimeout} will default to
  ///            PackageManager\#VERIFICATION_REJECT.
  ///@param millisecondsToDelay the amount of time requested for the timeout.
  ///            Must be positive and less than
  ///            PackageManager\#MAXIMUM_VERIFICATION_TIMEOUT. If
  ///            {@code millisecondsToDelay} is out of bounds,
  ///            {@code millisecondsToDelay} will be set to the closest in
  ///            bounds value; namely, 0 or
  ///            PackageManager\#MAXIMUM_VERIFICATION_TIMEOUT.
  ///@throws SecurityException if the caller does not have the
  ///            PACKAGE_VERIFICATION_AGENT permission.
  void extendVerificationTimeout(
          int id, int verificationCodeAtTimeout, int millisecondsToDelay) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_extendVerificationTimeout,
          jni.JniType.voidType,
          [id, verificationCodeAtTimeout, millisecondsToDelay]).check();

  static final _id_setInstallerPackageName = jniAccessors.getMethodIDOf(
      _classRef,
      "setInstallerPackageName",
      "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public abstract void setInstallerPackageName(java.lang.String targetPackage, java.lang.String installerPackageName)
  ///
  /// Change the installer associated with a given package.  There are limitations
  /// on how the installer package can be changed; in particular:
  /// <ul>
  /// <li> A SecurityException will be thrown if <var>installerPackageName</var>
  /// is not signed with the same certificate as the calling application.
  /// <li> A SecurityException will be thrown if <var>targetPackage</var> already
  /// has an installer package, and that installer package is not signed with
  /// the same certificate as the calling application.
  /// </ul>
  ///@param targetPackage The installed package whose installer will be changed.
  ///@param installerPackageName The package name of the new installer.  May be
  /// null to clear the association.
  void setInstallerPackageName(
          jni.JniString targetPackage, jni.JniString installerPackageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setInstallerPackageName,
          jni.JniType.voidType,
          [targetPackage.reference, installerPackageName.reference]).check();

  static final _id_getInstallerPackageName = jniAccessors.getMethodIDOf(
      _classRef,
      "getInstallerPackageName",
      "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public abstract java.lang.String getInstallerPackageName(java.lang.String packageName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the package name of the application that installed a package. This identifies
  /// which market the package came from.
  ///@param packageName The name of the package to query
  ///@throws IllegalArgumentException if the given package name is not installed
  jni.JniString getInstallerPackageName(jni.JniString packageName) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getInstallerPackageName,
          jni.JniType.objectType,
          [packageName.reference]).object);

  static final _id_addPackageToPreferred = jniAccessors.getMethodIDOf(
      _classRef, "addPackageToPreferred", "(Ljava/lang/String;)V");

  /// from: public abstract void addPackageToPreferred(java.lang.String packageName)
  ///
  /// @deprecated This function no longer does anything; it was an old
  /// approach to managing preferred activities, which has been superseded
  /// by (and conflicts with) the modern activity-based preferences.
  void addPackageToPreferred(jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(reference, _id_addPackageToPreferred,
          jni.JniType.voidType, [packageName.reference]).check();

  static final _id_removePackageFromPreferred = jniAccessors.getMethodIDOf(
      _classRef, "removePackageFromPreferred", "(Ljava/lang/String;)V");

  /// from: public abstract void removePackageFromPreferred(java.lang.String packageName)
  ///
  /// @deprecated This function no longer does anything; it was an old
  /// approach to managing preferred activities, which has been superseded
  /// by (and conflicts with) the modern activity-based preferences.
  void removePackageFromPreferred(jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(reference, _id_removePackageFromPreferred,
          jni.JniType.voidType, [packageName.reference]).check();

  static final _id_getPreferredPackages = jniAccessors.getMethodIDOf(
      _classRef, "getPreferredPackages", "(I)Ljava/util/List;");

  /// from: public abstract java.util.List<android.content.pm.PackageInfo> getPreferredPackages(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the list of all currently configured preferred packages. The
  /// first package on the list is the most preferred, the last is the least
  /// preferred.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_ACTIVITIES, android.content.pm.PackageManager\#GET_CONFIGURATIONS, android.content.pm.PackageManager\#GET_GIDS, android.content.pm.PackageManager\#GET_INSTRUMENTATION, android.content.pm.PackageManager\#GET_INTENT_FILTERS, android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_PERMISSIONS, android.content.pm.PackageManager\#GET_PROVIDERS, android.content.pm.PackageManager\#GET_RECEIVERS, android.content.pm.PackageManager\#GET_SERVICES, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#GET_SIGNATURES, android.content.pm.PackageManager\#GET_SIGNING_CERTIFICATES, android.content.pm.PackageManager\#GET_URI_PERMISSION_PATTERNS, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_FACTORY_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return A List of PackageInfo objects, one for each preferred
  ///         application, in order of preference.
  jni.JniObject getPreferredPackages(int flags) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getPreferredPackages, jni.JniType.objectType, [flags]).object);

  static final _id_addPreferredActivity = jniAccessors.getMethodIDOf(
      _classRef,
      "addPreferredActivity",
      "(Landroid/content/IntentFilter;I[Landroid/content/ComponentName;Landroid/content/ComponentName;)V");

  /// from: public abstract void addPreferredActivity(android.content.IntentFilter filter, int match, android.content.ComponentName[] set, android.content.ComponentName activity)
  ///
  /// @deprecated This is a protected API that should not have been available
  /// to third party applications.  It is the platform's responsibility for
  /// assigning preferred activities and this cannot be directly modified.
  ///
  /// Add a new preferred activity mapping to the system.  This will be used
  /// to automatically select the given activity component when
  /// Context\#startActivity(Intent) Context.startActivity() finds
  /// multiple matching activities and also matches the given filter.
  ///@param filter The set of intents under which this activity will be
  /// made preferred.
  ///@param match The IntentFilter match category that this preference
  /// applies to.
  ///@param set The set of activities that the user was picking from when
  /// this preference was made.
  ///@param activity The component name of the activity that is to be
  /// preferred.
  void addPreferredActivity(intentfilter_.IntentFilter filter, int match,
          jni.JniObject set0, componentname_.ComponentName activity) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_addPreferredActivity, jni.JniType.voidType, [
        filter.reference,
        match,
        set0.reference,
        activity.reference
      ]).check();

  static final _id_clearPackagePreferredActivities = jniAccessors.getMethodIDOf(
      _classRef, "clearPackagePreferredActivities", "(Ljava/lang/String;)V");

  /// from: public abstract void clearPackagePreferredActivities(java.lang.String packageName)
  ///
  /// Remove all preferred activity mappings, previously added with
  /// \#addPreferredActivity, from the
  /// system whose activities are implemented in the given package name.
  /// An application can only clear its own package(s).
  ///@param packageName The name of the package whose preferred activity
  /// mappings are to be removed.
  void clearPackagePreferredActivities(jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_clearPackagePreferredActivities,
          jni.JniType.voidType,
          [packageName.reference]).check();

  static final _id_getPreferredActivities = jniAccessors.getMethodIDOf(
      _classRef,
      "getPreferredActivities",
      "(Ljava/util/List;Ljava/util/List;Ljava/lang/String;)I");

  /// from: public abstract int getPreferredActivities(java.util.List<android.content.IntentFilter> outFilters, java.util.List<android.content.ComponentName> outActivities, java.lang.String packageName)
  ///
  /// Retrieve all preferred activities, previously added with
  /// \#addPreferredActivity, that are
  /// currently registered with the system.
  ///@param outFilters A required list in which to place the filters of all of the
  /// preferred activities.
  /// This value must never be {@code null}.
  ///@param outActivities A required list in which to place the component names of
  /// all of the preferred activities.
  /// This value must never be {@code null}.
  ///@param packageName An optional package in which you would like to limit
  /// the list.  If null, all activities will be returned; if non-null, only
  /// those activities in the given package are returned.
  ///@return Returns the total number of registered preferred activities
  /// (the number of distinct IntentFilter records, not the number of unique
  /// activity components) that were found.
  int getPreferredActivities(jni.JniObject outFilters,
          jni.JniObject outActivities, jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_getPreferredActivities, jni.JniType.intType, [
        outFilters.reference,
        outActivities.reference,
        packageName.reference
      ]).integer;

  static final _id_setComponentEnabledSetting = jniAccessors.getMethodIDOf(
      _classRef,
      "setComponentEnabledSetting",
      "(Landroid/content/ComponentName;II)V");

  /// from: public abstract void setComponentEnabledSetting(android.content.ComponentName componentName, int newState, int flags)
  ///
  /// Set the enabled setting for a package component (activity, receiver, service, provider).
  /// This setting will override any enabled state which may have been set by the component in its
  /// manifest.
  ///@param componentName The component to enable
  ///@param newState The new enabled state for the component.
  /// Value is android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DEFAULT, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_ENABLED, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED_USER, or android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED
  ///@param flags Optional behavior flags.
  ///
  /// Value is either <code>0</code> or android.content.pm.PackageManager\#DONT_KILL_APP
  void setComponentEnabledSetting(componentname_.ComponentName componentName,
          int newState, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setComponentEnabledSetting,
          jni.JniType.voidType,
          [componentName.reference, newState, flags]).check();

  static final _id_getComponentEnabledSetting = jniAccessors.getMethodIDOf(
      _classRef,
      "getComponentEnabledSetting",
      "(Landroid/content/ComponentName;)I");

  /// from: public abstract int getComponentEnabledSetting(android.content.ComponentName componentName)
  ///
  /// Return the enabled setting for a package component (activity,
  /// receiver, service, provider).  This returns the last value set by
  /// \#setComponentEnabledSetting(ComponentName, int, int); in most
  /// cases this value will be \#COMPONENT_ENABLED_STATE_DEFAULT since
  /// the value originally specified in the manifest has not been modified.
  ///@param componentName The component to retrieve.
  ///@return Returns the current enabled state for the component.
  ///
  /// Value is android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DEFAULT, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_ENABLED, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED_USER, or android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED
  int getComponentEnabledSetting(componentname_.ComponentName componentName) =>
      jniAccessors.callMethodWithArgs(reference, _id_getComponentEnabledSetting,
          jni.JniType.intType, [componentName.reference]).integer;

  static final _id_setApplicationEnabledSetting = jniAccessors.getMethodIDOf(
      _classRef, "setApplicationEnabledSetting", "(Ljava/lang/String;II)V");

  /// from: public abstract void setApplicationEnabledSetting(java.lang.String packageName, int newState, int flags)
  ///
  /// Set the enabled setting for an application
  /// This setting will override any enabled state which may have been set by the application in
  /// its manifest.  It also overrides the enabled state set in the manifest for any of the
  /// application's components.  It does not override any enabled state set by
  /// \#setComponentEnabledSetting for any of the application's components.
  ///@param packageName The package name of the application to enable
  ///@param newState The new enabled state for the application.
  /// Value is android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DEFAULT, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_ENABLED, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED_USER, or android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED
  ///@param flags Optional behavior flags.
  ///
  /// Value is either <code>0</code> or android.content.pm.PackageManager\#DONT_KILL_APP
  void setApplicationEnabledSetting(
          jni.JniString packageName, int newState, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setApplicationEnabledSetting,
          jni.JniType.voidType,
          [packageName.reference, newState, flags]).check();

  static final _id_getApplicationEnabledSetting = jniAccessors.getMethodIDOf(
      _classRef, "getApplicationEnabledSetting", "(Ljava/lang/String;)I");

  /// from: public abstract int getApplicationEnabledSetting(java.lang.String packageName)
  ///
  /// Return the enabled setting for an application. This returns
  /// the last value set by
  /// \#setApplicationEnabledSetting(String, int, int); in most
  /// cases this value will be \#COMPONENT_ENABLED_STATE_DEFAULT since
  /// the value originally specified in the manifest has not been modified.
  ///@param packageName The package name of the application to retrieve.
  ///@return Returns the current enabled state for the application.
  /// Value is android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DEFAULT, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_ENABLED, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED_USER, or android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED
  ///@throws IllegalArgumentException if the named package does not exist.
  int getApplicationEnabledSetting(jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getApplicationEnabledSetting,
          jni.JniType.intType,
          [packageName.reference]).integer;

  static final _id_isSafeMode =
      jniAccessors.getMethodIDOf(_classRef, "isSafeMode", "()Z");

  /// from: public abstract boolean isSafeMode()
  ///
  /// Return whether the device has been booted into safe mode.
  bool isSafeMode() => jniAccessors.callMethodWithArgs(
      reference, _id_isSafeMode, jni.JniType.booleanType, []).boolean;

  static final _id_isPackageSuspended =
      jniAccessors.getMethodIDOf(_classRef, "isPackageSuspended", "()Z");

  /// from: public boolean isPackageSuspended()
  ///
  /// Apps can query this to know if they have been suspended. A system app with the permission
  /// {@code android.permission.SUSPEND_APPS} can put any app on the device into a suspended state.
  ///
  /// While in this state, the application's notifications will be hidden, any of its started
  /// activities will be stopped and it will not be able to show toasts or dialogs or ring the
  /// device. When the user tries to launch a suspended app, the system will, instead, show a
  /// dialog to the user informing them that they cannot use this app while it is suspended.
  ///
  /// When an app is put into this state, the broadcast action
  /// Intent\#ACTION_MY_PACKAGE_SUSPENDED will be delivered to any of its broadcast
  /// receivers that included this action in their intent-filters, _including manifest
  /// receivers._ Similarly, a broadcast action Intent\#ACTION_MY_PACKAGE_UNSUSPENDED
  /// is delivered when a previously suspended app is taken out of this state.
  ///
  ///
  ///@return {@code true} if the calling package has been suspended, {@code false} otherwise.
  ///@see \#getSuspendedPackageAppExtras()
  ///@see Intent\#ACTION_MY_PACKAGE_SUSPENDED
  ///@see Intent\#ACTION_MY_PACKAGE_UNSUSPENDED
  bool isPackageSuspended() => jniAccessors.callMethodWithArgs(
      reference, _id_isPackageSuspended, jni.JniType.booleanType, []).boolean;

  static final _id_getSuspendedPackageAppExtras = jniAccessors.getMethodIDOf(
      _classRef, "getSuspendedPackageAppExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getSuspendedPackageAppExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Bundle of extras that was meant to be sent to the calling app when it was
  /// suspended. An app with the permission {@code android.permission.SUSPEND_APPS} can supply this
  /// to the system at the time of suspending an app.
  ///
  /// This is the same Bundle that is sent along with the broadcast
  /// Intent\#ACTION_MY_PACKAGE_SUSPENDED, whenever the app is suspended. The contents of
  /// this Bundle are a contract between the suspended app and the suspending app.
  ///
  /// Note: These extras are optional, so if no extras were supplied to the system, this method
  /// will return {@code null}, even when the calling app has been suspended.
  ///@return A Bundle containing the extras for the app, or {@code null} if the
  /// package is not currently suspended.
  ///@see \#isPackageSuspended()
  ///@see Intent\#ACTION_MY_PACKAGE_UNSUSPENDED
  ///@see Intent\#ACTION_MY_PACKAGE_SUSPENDED
  ///@see Intent\#EXTRA_SUSPENDED_PACKAGE_EXTRAS
  bundle_.Bundle getSuspendedPackageAppExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSuspendedPackageAppExtras, jni.JniType.objectType, []).object);

  static final _id_setApplicationCategoryHint = jniAccessors.getMethodIDOf(
      _classRef, "setApplicationCategoryHint", "(Ljava/lang/String;I)V");

  /// from: public abstract void setApplicationCategoryHint(java.lang.String packageName, int categoryHint)
  ///
  /// Provide a hint of what the ApplicationInfo\#category value should
  /// be for the given package.
  ///
  /// This hint can only be set by the app which installed this package, as
  /// determined by \#getInstallerPackageName(String).
  ///@param packageName the package to change the category hint for.
  /// This value must never be {@code null}.
  ///@param categoryHint the category hint to set.
  ///
  /// Value is android.content.pm.ApplicationInfo\#CATEGORY_UNDEFINED, android.content.pm.ApplicationInfo\#CATEGORY_GAME, android.content.pm.ApplicationInfo\#CATEGORY_AUDIO, android.content.pm.ApplicationInfo\#CATEGORY_VIDEO, android.content.pm.ApplicationInfo\#CATEGORY_IMAGE, android.content.pm.ApplicationInfo\#CATEGORY_SOCIAL, android.content.pm.ApplicationInfo\#CATEGORY_NEWS, android.content.pm.ApplicationInfo\#CATEGORY_MAPS, or android.content.pm.ApplicationInfo\#CATEGORY_PRODUCTIVITY
  void setApplicationCategoryHint(
          jni.JniString packageName, int categoryHint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setApplicationCategoryHint,
          jni.JniType.voidType, [packageName.reference, categoryHint]).check();

  static final _id_getPackageInstaller = jniAccessors.getMethodIDOf(_classRef,
      "getPackageInstaller", "()Landroid/content/pm/PackageInstaller;");

  /// from: public abstract android.content.pm.PackageInstaller getPackageInstaller()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return interface that offers the ability to install, upgrade, and remove
  /// applications on the device.
  ///@return This value will never be {@code null}.
  packageinstaller_.PackageInstaller getPackageInstaller() =>
      packageinstaller_.PackageInstaller.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getPackageInstaller,
              jni.JniType.objectType, []).object);

  static final _id_canRequestPackageInstalls =
      jniAccessors.getMethodIDOf(_classRef, "canRequestPackageInstalls", "()Z");

  /// from: public abstract boolean canRequestPackageInstalls()
  ///
  /// Checks whether the calling package is allowed to request package installs through package
  /// installer. Apps are encouraged to call this API before launching the package installer via
  /// intent android.content.Intent\#ACTION_INSTALL_PACKAGE. Starting from Android O, the
  /// user can explicitly choose what external sources they trust to install apps on the device.
  /// If this API returns false, the install request will be blocked by the package installer and
  /// a dialog will be shown to the user with an option to launch settings to change their
  /// preference. An application must target Android O or higher and declare permission
  /// android.Manifest.permission\#REQUEST_INSTALL_PACKAGES in order to use this API.
  ///@return true if the calling package is trusted by the user to request install packages on
  /// the device, false otherwise.
  ///@see android.content.Intent\#ACTION_INSTALL_PACKAGE
  ///@see android.provider.Settings\#ACTION_MANAGE_UNKNOWN_APP_SOURCES
  bool canRequestPackageInstalls() => jniAccessors.callMethodWithArgs(reference,
      _id_canRequestPackageInstalls, jni.JniType.booleanType, []).boolean;

  static final _id_hasSigningCertificate = jniAccessors.getMethodIDOf(
      _classRef, "hasSigningCertificate", "(Ljava/lang/String;[BI)Z");

  /// from: public boolean hasSigningCertificate(java.lang.String packageName, byte[] certificate, int type)
  ///
  /// Searches the set of signing certificates by which the given package has proven to have been
  /// signed.  This should be used instead of {@code getPackageInfo} with {@code GET_SIGNATURES}
  /// since it takes into account the possibility of signing certificate rotation, except in the
  /// case of packages that are signed by multiple certificates, for which signing certificate
  /// rotation is not supported.  This method is analogous to using {@code getPackageInfo} with
  /// {@code GET_SIGNING_CERTIFICATES} and then searching through the resulting {@code
  /// signingInfo} field to see if the desired certificate is present.
  ///@param packageName package whose signing certificates to check
  ///@param certificate signing certificate for which to search
  ///@param type representation of the {@code certificate}
  /// Value is android.content.pm.PackageManager\#CERT_INPUT_RAW_X509, or android.content.pm.PackageManager\#CERT_INPUT_SHA256
  ///@return true if this package was or is signed by exactly the certificate {@code certificate}
  bool hasSigningCertificate(
          jni.JniString packageName, jni.JniObject certificate, int type) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_hasSigningCertificate,
          jni.JniType.booleanType,
          [packageName.reference, certificate.reference, type]).boolean;

  static final _id_hasSigningCertificate1 =
      jniAccessors.getMethodIDOf(_classRef, "hasSigningCertificate", "(I[BI)Z");

  /// from: public boolean hasSigningCertificate(int uid, byte[] certificate, int type)
  ///
  /// Searches the set of signing certificates by which the package(s) for the given uid has proven
  /// to have been signed.  For multiple packages sharing the same uid, this will return the
  /// signing certificates found in the signing history of the "newest" package, where "newest"
  /// indicates the package with the newest signing certificate in the shared uid group.  This
  /// method should be used instead of {@code getPackageInfo} with {@code GET_SIGNATURES}
  /// since it takes into account the possibility of signing certificate rotation, except in the
  /// case of packages that are signed by multiple certificates, for which signing certificate
  /// rotation is not supported. This method is analogous to using {@code getPackagesForUid}
  /// followed by {@code getPackageInfo} with {@code GET_SIGNING_CERTIFICATES}, selecting the
  /// {@code PackageInfo} of the newest-signed bpackage , and finally searching through the
  /// resulting {@code signingInfo} field to see if the desired certificate is there.
  ///@param uid uid whose signing certificates to check
  ///@param certificate signing certificate for which to search
  ///@param type representation of the {@code certificate}
  /// Value is android.content.pm.PackageManager\#CERT_INPUT_RAW_X509, or android.content.pm.PackageManager\#CERT_INPUT_SHA256
  ///@return true if this package was or is signed by exactly the certificate {@code certificate}
  bool hasSigningCertificate1(int uid, jni.JniObject certificate, int type) =>
      jniAccessors.callMethodWithArgs(reference, _id_hasSigningCertificate1,
          jni.JniType.booleanType, [uid, certificate.reference, type]).boolean;
}

/// from: android.content.pm.PackageManager$NameNotFoundException
///
/// This exception is thrown when a given package, application, or component
/// name cannot be found.
class PackageManager_NameNotFoundException
    extends androidexception_.AndroidException {
  static final _classRef = jniAccessors
      .getClassOf("android/content/pm/PackageManager\$NameNotFoundException");
  PackageManager_NameNotFoundException.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  PackageManager_NameNotFoundException()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  PackageManager_NameNotFoundException.ctor1(jni.JniString name)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [name.reference]).object);
}
