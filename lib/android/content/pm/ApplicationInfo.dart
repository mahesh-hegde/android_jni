// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "PackageItemInfo.dart" as packageiteminfo_;

import "../../os/Parcelable.dart" as parcelable_;

import "../Context.dart" as context_;

import "../../util/Printer.dart" as printer_;

import "../../os/Parcel.dart" as parcel_;

import "PackageManager.dart" as packagemanager_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.pm.ApplicationInfo
///
/// Information you can retrieve about a particular application.  This
/// corresponds to information collected from the AndroidManifest.xml's
/// &lt;application&gt; tag.
class ApplicationInfo extends packageiteminfo_.PackageItemInfo {
  static final _classRef =
      jniAccessors.getClassOf("android/content/pm/ApplicationInfo");
  ApplicationInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CATEGORY_AUDIO
  ///
  /// Category for apps which primarily work with audio or music, such as music
  /// players.
  ///@see \#category
  static const CATEGORY_AUDIO = 1;

  /// from: static public final int CATEGORY_GAME
  ///
  /// Category for apps which are primarily games.
  ///@see \#category
  static const CATEGORY_GAME = 0;

  /// from: static public final int CATEGORY_IMAGE
  ///
  /// Category for apps which primarily work with images or photos, such as
  /// camera or gallery apps.
  ///@see \#category
  static const CATEGORY_IMAGE = 3;

  /// from: static public final int CATEGORY_MAPS
  ///
  /// Category for apps which are primarily maps apps, such as navigation apps.
  ///@see \#category
  static const CATEGORY_MAPS = 6;

  /// from: static public final int CATEGORY_NEWS
  ///
  /// Category for apps which are primarily news apps, such as newspapers,
  /// magazines, or sports apps.
  ///@see \#category
  static const CATEGORY_NEWS = 5;

  /// from: static public final int CATEGORY_PRODUCTIVITY
  ///
  /// Category for apps which are primarily productivity apps, such as cloud
  /// storage or workplace apps.
  ///@see \#category
  static const CATEGORY_PRODUCTIVITY = 7;

  /// from: static public final int CATEGORY_SOCIAL
  ///
  /// Category for apps which are primarily social apps, such as messaging,
  /// communication, email, or social network apps.
  ///@see \#category
  static const CATEGORY_SOCIAL = 4;

  /// from: static public final int CATEGORY_UNDEFINED
  ///
  /// Value when category is undefined.
  ///@see \#category
  static const CATEGORY_UNDEFINED = -1;

  /// from: static public final int CATEGORY_VIDEO
  ///
  /// Category for apps which primarily work with video or movies, such as
  /// streaming video apps.
  ///@see \#category
  static const CATEGORY_VIDEO = 2;

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.ApplicationInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int FLAG_ALLOW_BACKUP
  ///
  /// Value for \#flags: set to <code>false</code> if the application does not wish
  /// to permit any OS-driven backups of its data; <code>true</code> otherwise.
  ///
  /// Comes from the
  /// android.R.styleable\#AndroidManifestApplication_allowBackup android:allowBackup
  /// attribute of the &lt;application&gt; tag.
  static const FLAG_ALLOW_BACKUP = 32768;

  /// from: static public final int FLAG_ALLOW_CLEAR_USER_DATA
  ///
  /// Value for \#flags: default value for the corresponding ActivityInfo flag.
  /// Comes from android.R.styleable\#AndroidManifestApplication_allowClearUserData android:allowClearUserData of the &lt;application&gt; tag.
  static const FLAG_ALLOW_CLEAR_USER_DATA = 64;

  /// from: static public final int FLAG_ALLOW_TASK_REPARENTING
  ///
  /// Value for \#flags: default value for the corresponding ActivityInfo flag.
  /// Comes from android.R.styleable\#AndroidManifestApplication_allowTaskReparenting android:allowTaskReparenting of the &lt;application&gt; tag.
  static const FLAG_ALLOW_TASK_REPARENTING = 32;

  /// from: static public final int FLAG_DEBUGGABLE
  ///
  /// Value for \#flags: set to true if this application would like to
  /// allow debugging of its
  /// code, even when installed on a non-development system.  Comes
  /// from android.R.styleable\#AndroidManifestApplication_debuggable android:debuggable of the &lt;application&gt; tag.
  static const FLAG_DEBUGGABLE = 2;

  /// from: static public final int FLAG_EXTERNAL_STORAGE
  ///
  /// Value for \#flags: Set to true if the application is
  /// currently installed on external/removable/unprotected storage.  Such
  /// applications may not be available if their storage is not currently
  /// mounted.  When the storage it is on is not available, it will look like
  /// the application has been uninstalled (its .apk is no longer available)
  /// but its persistent data is not removed.
  static const FLAG_EXTERNAL_STORAGE = 262144;

  /// from: static public final int FLAG_EXTRACT_NATIVE_LIBS
  ///
  /// When set installer extracts native libs from .apk files.
  static const FLAG_EXTRACT_NATIVE_LIBS = 268435456;

  /// from: static public final int FLAG_FACTORY_TEST
  ///
  /// Value for \#flags: set to true if this application holds the
  /// android.Manifest.permission\#FACTORY_TEST permission and the
  /// device is running in factory test mode.
  static const FLAG_FACTORY_TEST = 16;

  /// from: static public final int FLAG_FULL_BACKUP_ONLY
  ///
  /// Value for \#flags: {@code true} if the application asks that only
  /// full-data streaming backups of its data be performed even though it defines
  /// a android.app.backup.BackupAgent BackupAgent, which normally
  /// indicates that the app will manage its backed-up data via incremental
  /// key/value updates.
  static const FLAG_FULL_BACKUP_ONLY = 67108864;

  /// from: static public final int FLAG_HARDWARE_ACCELERATED
  ///
  /// Value for \#flags: {@code true} when the application's rendering
  /// should be hardware accelerated.
  static const FLAG_HARDWARE_ACCELERATED = 536870912;

  /// from: static public final int FLAG_HAS_CODE
  ///
  /// Value for \#flags: set to true if this application has code
  /// associated with it.  Comes
  /// from android.R.styleable\#AndroidManifestApplication_hasCode android:hasCode of the &lt;application&gt; tag.
  static const FLAG_HAS_CODE = 4;

  /// from: static public final int FLAG_INSTALLED
  ///
  /// Value for \#flags: true if the application is currently
  /// installed for the calling user.
  static const FLAG_INSTALLED = 8388608;

  /// from: static public final int FLAG_IS_DATA_ONLY
  ///
  /// Value for \#flags: true if the application only has its
  /// data installed; the application package itself does not currently
  /// exist on the device.
  static const FLAG_IS_DATA_ONLY = 16777216;

  /// from: static public final int FLAG_IS_GAME
  ///
  /// Value for \#flags: true if the application was declared to be a
  /// game, or false if it is a non-game application.
  ///@deprecated use \#CATEGORY_GAME instead.
  static const FLAG_IS_GAME = 33554432;

  /// from: static public final int FLAG_KILL_AFTER_RESTORE
  ///
  /// Value for \#flags: set to <code>false</code> if the application must be kept
  /// in memory following a full-system restore operation; <code>true</code> otherwise.
  /// Ordinarily, during a full system restore operation each application is shut down
  /// following execution of its agent's onRestore() method.  Setting this attribute to
  /// <code>false</code> prevents this.  Most applications will not need to set this attribute.
  ///
  /// If
  /// android.R.styleable\#AndroidManifestApplication_allowBackup android:allowBackup
  /// is set to <code>false</code> or no
  /// android.R.styleable\#AndroidManifestApplication_backupAgent android:backupAgent
  /// is specified, this flag will be ignored.
  ///
  /// Comes from the
  /// android.R.styleable\#AndroidManifestApplication_killAfterRestore android:killAfterRestore
  /// attribute of the &lt;application&gt; tag.
  static const FLAG_KILL_AFTER_RESTORE = 65536;

  /// from: static public final int FLAG_LARGE_HEAP
  ///
  /// Value for \#flags: true when the application has requested a
  /// large heap for its processes.  Corresponds to
  /// android.R.styleable\#AndroidManifestApplication_largeHeap android:largeHeap.
  static const FLAG_LARGE_HEAP = 1048576;

  /// from: static public final int FLAG_MULTIARCH
  ///
  /// Value for \#flags: true if code from this application will need to be
  /// loaded into other applications' processes. On devices that support multiple
  /// instruction sets, this implies the code might be loaded into a process that's
  /// using any of the devices supported instruction sets.
  ///
  ///  The system might treat such applications specially, for eg., by
  /// extracting the application's native libraries for all supported instruction
  /// sets or by compiling the application's dex code for all supported instruction
  /// sets.
  static const FLAG_MULTIARCH = -2147483648;

  /// from: static public final int FLAG_PERSISTENT
  ///
  /// Value for \#flags: set to true if this application is persistent.
  /// Comes from android.R.styleable\#AndroidManifestApplication_persistent android:persistent of the &lt;application&gt; tag.
  static const FLAG_PERSISTENT = 8;

  /// from: static public final int FLAG_RESIZEABLE_FOR_SCREENS
  ///
  /// Value for \#flags: true when the application knows how to adjust
  /// its UI for different screen sizes.  Corresponds to
  /// android.R.styleable\#AndroidManifestSupportsScreens_resizeable android:resizeable.
  static const FLAG_RESIZEABLE_FOR_SCREENS = 4096;

  /// from: static public final int FLAG_RESTORE_ANY_VERSION
  ///
  /// Value for \#flags: Set to <code>true</code> if the application's backup
  /// agent claims to be able to handle restore data even "from the future,"
  /// i.e. from versions of the application with a versionCode greater than
  /// the one currently installed on the device.  <i>Use with caution!</i>  By default
  /// this attribute is <code>false</code> and the Backup Manager will ensure that data
  /// from "future" versions of the application are never supplied during a restore operation.
  ///
  /// If
  /// android.R.styleable\#AndroidManifestApplication_allowBackup android:allowBackup
  /// is set to <code>false</code> or no
  /// android.R.styleable\#AndroidManifestApplication_backupAgent android:backupAgent
  /// is specified, this flag will be ignored.
  ///
  /// Comes from the
  /// android.R.styleable\#AndroidManifestApplication_restoreAnyVersion android:restoreAnyVersion
  /// attribute of the &lt;application&gt; tag.
  static const FLAG_RESTORE_ANY_VERSION = 131072;

  /// from: static public final int FLAG_STOPPED
  ///
  /// Value for \#flags: true if this application's package is in
  /// the stopped state.
  static const FLAG_STOPPED = 2097152;

  /// from: static public final int FLAG_SUPPORTS_LARGE_SCREENS
  ///
  /// Value for \#flags: true when the application's window can be
  /// increased in size for larger screens.  Corresponds to
  /// android.R.styleable\#AndroidManifestSupportsScreens_largeScreens android:largeScreens.
  static const FLAG_SUPPORTS_LARGE_SCREENS = 2048;

  /// from: static public final int FLAG_SUPPORTS_NORMAL_SCREENS
  ///
  /// Value for \#flags: true when the application's window can be
  /// displayed on normal screens.  Corresponds to
  /// android.R.styleable\#AndroidManifestSupportsScreens_normalScreens android:normalScreens.
  static const FLAG_SUPPORTS_NORMAL_SCREENS = 1024;

  /// from: static public final int FLAG_SUPPORTS_RTL
  ///
  /// Value for \#flags: true  when the application is willing to support
  /// RTL (right to left). All activities will inherit this value.
  ///
  /// Set from the android.R.attr\#supportsRtl attribute in the
  /// activity's manifest.
  ///
  /// Default value is false (no support for RTL).
  static const FLAG_SUPPORTS_RTL = 4194304;

  /// from: static public final int FLAG_SUPPORTS_SCREEN_DENSITIES
  ///
  /// Value for \#flags: true when the application knows how to
  /// accomodate different screen densities.  Corresponds to
  /// android.R.styleable\#AndroidManifestSupportsScreens_anyDensity android:anyDensity.
  static const FLAG_SUPPORTS_SCREEN_DENSITIES = 8192;

  /// from: static public final int FLAG_SUPPORTS_SMALL_SCREENS
  ///
  /// Value for \#flags: true when the application's window can be
  /// reduced in size for smaller screens.  Corresponds to
  /// android.R.styleable\#AndroidManifestSupportsScreens_smallScreens android:smallScreens.
  static const FLAG_SUPPORTS_SMALL_SCREENS = 512;

  /// from: static public final int FLAG_SUPPORTS_XLARGE_SCREENS
  ///
  /// Value for \#flags: true when the application's window can be
  /// increased in size for extra large screens.  Corresponds to
  /// android.R.styleable\#AndroidManifestSupportsScreens_xlargeScreens android:xlargeScreens.
  static const FLAG_SUPPORTS_XLARGE_SCREENS = 524288;

  /// from: static public final int FLAG_SUSPENDED
  ///
  /// Value for \#flags: true if this application's package is in
  /// the suspended state.
  static const FLAG_SUSPENDED = 1073741824;

  /// from: static public final int FLAG_SYSTEM
  ///
  /// Value for \#flags: if set, this application is installed in the
  /// device's system image.
  static const FLAG_SYSTEM = 1;

  /// from: static public final int FLAG_TEST_ONLY
  ///
  /// Value for \#flags: this is set if the application has specified
  /// android.R.styleable\#AndroidManifestApplication_testOnly android:testOnly to be true.
  static const FLAG_TEST_ONLY = 256;

  /// from: static public final int FLAG_UPDATED_SYSTEM_APP
  ///
  /// Value for \#flags: this is set if this application has been
  /// installed as an update to a built-in system application.
  static const FLAG_UPDATED_SYSTEM_APP = 128;

  /// from: static public final int FLAG_USES_CLEARTEXT_TRAFFIC
  ///
  /// Value for \#flags: {@code true} if the application may use cleartext network traffic
  /// (e.g., HTTP rather than HTTPS; WebSockets rather than WebSockets Secure; XMPP, IMAP, STMP
  /// without STARTTLS or TLS). If {@code false}, the app declares that it does not intend to use
  /// cleartext network traffic, in which case platform components (e.g., HTTP stacks,
  /// {@code DownloadManager}, {@code MediaPlayer}) will refuse app's requests to use cleartext
  /// traffic. Third-party libraries are encouraged to honor this flag as well.
  ///
  /// NOTE: {@code WebView} honors this flag for applications targeting API level 26 and up.
  ///
  /// This flag is ignored on Android N and above if an Android Network Security Config is
  /// present.
  ///
  /// This flag comes from
  /// android.R.styleable\#AndroidManifestApplication_usesCleartextTraffic android:usesCleartextTraffic of the &lt;application&gt; tag.
  static const FLAG_USES_CLEARTEXT_TRAFFIC = 134217728;

  /// from: static public final int FLAG_VM_SAFE_MODE
  ///
  /// Value for \#flags: set to true if this application would like to
  /// request the VM to operate under the safe mode. Comes from
  /// android.R.styleable\#AndroidManifestApplication_vmSafeMode android:vmSafeMode of the &lt;application&gt; tag.
  static const FLAG_VM_SAFE_MODE = 16384;

  static final _id_appComponentFactory = jniAccessors.getFieldIDOf(
      _classRef, "appComponentFactory", "Ljava/lang/String;");

  /// from: public java.lang.String appComponentFactory
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The factory of this package, as specified by the &lt;manifest&gt;
  /// tag's android.R.styleable\#AndroidManifestApplication_appComponentFactory
  /// attribute.
  jni.JniString get appComponentFactory => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_appComponentFactory, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String appComponentFactory
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The factory of this package, as specified by the &lt;manifest&gt;
  /// tag's android.R.styleable\#AndroidManifestApplication_appComponentFactory
  /// attribute.
  set appComponentFactory(jni.JniString value) => jniEnv.SetObjectField(
      reference, _id_appComponentFactory, value.reference);

  static final _id_backupAgentName = jniAccessors.getFieldIDOf(
      _classRef, "backupAgentName", "Ljava/lang/String;");

  /// from: public java.lang.String backupAgentName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Class implementing the Application's backup functionality.  From
  /// the "backupAgent" attribute.  This is an optional attribute and
  /// will be null if the application does not specify it in its manifest.
  ///
  /// If android:allowBackup is set to false, this attribute is ignored.
  jni.JniString get backupAgentName => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_backupAgentName, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String backupAgentName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Class implementing the Application's backup functionality.  From
  /// the "backupAgent" attribute.  This is an optional attribute and
  /// will be null if the application does not specify it in its manifest.
  ///
  /// If android:allowBackup is set to false, this attribute is ignored.
  set backupAgentName(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_backupAgentName, value.reference);

  static final _id_category =
      jniAccessors.getFieldIDOf(_classRef, "category", "I");

  /// from: public int category
  ///
  /// The category of this app. Categories are used to cluster multiple apps
  /// together into meaningful groups, such as when summarizing battery,
  /// network, or disk usage. Apps should only define this value when they fit
  /// well into one of the specific categories.
  ///
  /// Set from the android.R.attr\#appCategory attribute in the
  /// manifest. If the manifest doesn't define a category, this value may have
  /// been provided by the installer via
  /// PackageManager\#setApplicationCategoryHint(String, int).
  ///
  /// Value is android.content.pm.ApplicationInfo\#CATEGORY_UNDEFINED, android.content.pm.ApplicationInfo\#CATEGORY_GAME, android.content.pm.ApplicationInfo\#CATEGORY_AUDIO, android.content.pm.ApplicationInfo\#CATEGORY_VIDEO, android.content.pm.ApplicationInfo\#CATEGORY_IMAGE, android.content.pm.ApplicationInfo\#CATEGORY_SOCIAL, android.content.pm.ApplicationInfo\#CATEGORY_NEWS, android.content.pm.ApplicationInfo\#CATEGORY_MAPS, or android.content.pm.ApplicationInfo\#CATEGORY_PRODUCTIVITY
  int get category => jniAccessors
      .getField(reference, _id_category, jni.JniType.intType)
      .integer;

  /// from: public int category
  ///
  /// The category of this app. Categories are used to cluster multiple apps
  /// together into meaningful groups, such as when summarizing battery,
  /// network, or disk usage. Apps should only define this value when they fit
  /// well into one of the specific categories.
  ///
  /// Set from the android.R.attr\#appCategory attribute in the
  /// manifest. If the manifest doesn't define a category, this value may have
  /// been provided by the installer via
  /// PackageManager\#setApplicationCategoryHint(String, int).
  ///
  /// Value is android.content.pm.ApplicationInfo\#CATEGORY_UNDEFINED, android.content.pm.ApplicationInfo\#CATEGORY_GAME, android.content.pm.ApplicationInfo\#CATEGORY_AUDIO, android.content.pm.ApplicationInfo\#CATEGORY_VIDEO, android.content.pm.ApplicationInfo\#CATEGORY_IMAGE, android.content.pm.ApplicationInfo\#CATEGORY_SOCIAL, android.content.pm.ApplicationInfo\#CATEGORY_NEWS, android.content.pm.ApplicationInfo\#CATEGORY_MAPS, or android.content.pm.ApplicationInfo\#CATEGORY_PRODUCTIVITY
  set category(int value) => jniEnv.SetIntField(reference, _id_category, value);

  static final _id_className =
      jniAccessors.getFieldIDOf(_classRef, "className", "Ljava/lang/String;");

  /// from: public java.lang.String className
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Class implementing the Application object.  From the "class"
  /// attribute.
  jni.JniString get className => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_className, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String className
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Class implementing the Application object.  From the "class"
  /// attribute.
  set className(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_className, value.reference);

  static final _id_compatibleWidthLimitDp =
      jniAccessors.getFieldIDOf(_classRef, "compatibleWidthLimitDp", "I");

  /// from: public int compatibleWidthLimitDp
  ///
  /// The maximum smallest screen width the application is designed for.  If 0,
  /// nothing has been specified.  Comes from
  /// android.R.styleable\#AndroidManifestSupportsScreens_compatibleWidthLimitDp android:compatibleWidthLimitDp attribute of the &lt;supports-screens&gt; tag.
  int get compatibleWidthLimitDp => jniAccessors
      .getField(reference, _id_compatibleWidthLimitDp, jni.JniType.intType)
      .integer;

  /// from: public int compatibleWidthLimitDp
  ///
  /// The maximum smallest screen width the application is designed for.  If 0,
  /// nothing has been specified.  Comes from
  /// android.R.styleable\#AndroidManifestSupportsScreens_compatibleWidthLimitDp android:compatibleWidthLimitDp attribute of the &lt;supports-screens&gt; tag.
  set compatibleWidthLimitDp(int value) =>
      jniEnv.SetIntField(reference, _id_compatibleWidthLimitDp, value);

  static final _id_dataDir =
      jniAccessors.getFieldIDOf(_classRef, "dataDir", "Ljava/lang/String;");

  /// from: public java.lang.String dataDir
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Full path to the default directory assigned to the package for its
  /// persistent data.
  jni.JniString get dataDir => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_dataDir, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String dataDir
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Full path to the default directory assigned to the package for its
  /// persistent data.
  set dataDir(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_dataDir, value.reference);

  static final _id_descriptionRes =
      jniAccessors.getFieldIDOf(_classRef, "descriptionRes", "I");

  /// from: public int descriptionRes
  ///
  /// A style resource identifier (in the package's resources) of the
  /// description of an application.  From the "description" attribute
  /// or, if not set, 0.
  int get descriptionRes => jniAccessors
      .getField(reference, _id_descriptionRes, jni.JniType.intType)
      .integer;

  /// from: public int descriptionRes
  ///
  /// A style resource identifier (in the package's resources) of the
  /// description of an application.  From the "description" attribute
  /// or, if not set, 0.
  set descriptionRes(int value) =>
      jniEnv.SetIntField(reference, _id_descriptionRes, value);

  static final _id_deviceProtectedDataDir = jniAccessors.getFieldIDOf(
      _classRef, "deviceProtectedDataDir", "Ljava/lang/String;");

  /// from: public java.lang.String deviceProtectedDataDir
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Full path to the device-protected directory assigned to the package for
  /// its persistent data.
  ///@see Context\#createDeviceProtectedStorageContext()
  jni.JniString get deviceProtectedDataDir => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_deviceProtectedDataDir, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String deviceProtectedDataDir
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Full path to the device-protected directory assigned to the package for
  /// its persistent data.
  ///@see Context\#createDeviceProtectedStorageContext()
  set deviceProtectedDataDir(jni.JniString value) => jniEnv.SetObjectField(
      reference, _id_deviceProtectedDataDir, value.reference);

  static final _id_enabled =
      jniAccessors.getFieldIDOf(_classRef, "enabled", "Z");

  /// from: public boolean enabled
  ///
  /// When false, indicates that all components within this application are
  /// considered disabled, regardless of their individually set enabled status.
  bool get enabled => jniAccessors
      .getField(reference, _id_enabled, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean enabled
  ///
  /// When false, indicates that all components within this application are
  /// considered disabled, regardless of their individually set enabled status.
  set enabled(bool value) =>
      jniEnv.SetBooleanField(reference, _id_enabled, value ? 1 : 0);

  static final _id_flags = jniAccessors.getFieldIDOf(_classRef, "flags", "I");

  /// from: public int flags
  ///
  /// Flags associated with the application.  Any combination of
  /// \#FLAG_SYSTEM, \#FLAG_DEBUGGABLE, \#FLAG_HAS_CODE,
  /// \#FLAG_PERSISTENT, \#FLAG_FACTORY_TEST, and
  /// \#FLAG_ALLOW_TASK_REPARENTING
  /// \#FLAG_ALLOW_CLEAR_USER_DATA, \#FLAG_UPDATED_SYSTEM_APP,
  /// \#FLAG_TEST_ONLY, \#FLAG_SUPPORTS_SMALL_SCREENS,
  /// \#FLAG_SUPPORTS_NORMAL_SCREENS,
  /// \#FLAG_SUPPORTS_LARGE_SCREENS, \#FLAG_SUPPORTS_XLARGE_SCREENS,
  /// \#FLAG_RESIZEABLE_FOR_SCREENS,
  /// \#FLAG_SUPPORTS_SCREEN_DENSITIES, \#FLAG_VM_SAFE_MODE,
  /// \#FLAG_ALLOW_BACKUP, \#FLAG_KILL_AFTER_RESTORE,
  /// \#FLAG_RESTORE_ANY_VERSION, \#FLAG_EXTERNAL_STORAGE,
  /// \#FLAG_LARGE_HEAP, \#FLAG_STOPPED,
  /// \#FLAG_SUPPORTS_RTL, \#FLAG_INSTALLED,
  /// \#FLAG_IS_DATA_ONLY, \#FLAG_IS_GAME,
  /// \#FLAG_FULL_BACKUP_ONLY, \#FLAG_USES_CLEARTEXT_TRAFFIC,
  /// \#FLAG_MULTIARCH.
  int get flags =>
      jniAccessors.getField(reference, _id_flags, jni.JniType.intType).integer;

  /// from: public int flags
  ///
  /// Flags associated with the application.  Any combination of
  /// \#FLAG_SYSTEM, \#FLAG_DEBUGGABLE, \#FLAG_HAS_CODE,
  /// \#FLAG_PERSISTENT, \#FLAG_FACTORY_TEST, and
  /// \#FLAG_ALLOW_TASK_REPARENTING
  /// \#FLAG_ALLOW_CLEAR_USER_DATA, \#FLAG_UPDATED_SYSTEM_APP,
  /// \#FLAG_TEST_ONLY, \#FLAG_SUPPORTS_SMALL_SCREENS,
  /// \#FLAG_SUPPORTS_NORMAL_SCREENS,
  /// \#FLAG_SUPPORTS_LARGE_SCREENS, \#FLAG_SUPPORTS_XLARGE_SCREENS,
  /// \#FLAG_RESIZEABLE_FOR_SCREENS,
  /// \#FLAG_SUPPORTS_SCREEN_DENSITIES, \#FLAG_VM_SAFE_MODE,
  /// \#FLAG_ALLOW_BACKUP, \#FLAG_KILL_AFTER_RESTORE,
  /// \#FLAG_RESTORE_ANY_VERSION, \#FLAG_EXTERNAL_STORAGE,
  /// \#FLAG_LARGE_HEAP, \#FLAG_STOPPED,
  /// \#FLAG_SUPPORTS_RTL, \#FLAG_INSTALLED,
  /// \#FLAG_IS_DATA_ONLY, \#FLAG_IS_GAME,
  /// \#FLAG_FULL_BACKUP_ONLY, \#FLAG_USES_CLEARTEXT_TRAFFIC,
  /// \#FLAG_MULTIARCH.
  set flags(int value) => jniEnv.SetIntField(reference, _id_flags, value);

  static final _id_largestWidthLimitDp =
      jniAccessors.getFieldIDOf(_classRef, "largestWidthLimitDp", "I");

  /// from: public int largestWidthLimitDp
  ///
  /// The maximum smallest screen width the application will work on.  If 0,
  /// nothing has been specified.  Comes from
  /// android.R.styleable\#AndroidManifestSupportsScreens_largestWidthLimitDp android:largestWidthLimitDp attribute of the &lt;supports-screens&gt; tag.
  int get largestWidthLimitDp => jniAccessors
      .getField(reference, _id_largestWidthLimitDp, jni.JniType.intType)
      .integer;

  /// from: public int largestWidthLimitDp
  ///
  /// The maximum smallest screen width the application will work on.  If 0,
  /// nothing has been specified.  Comes from
  /// android.R.styleable\#AndroidManifestSupportsScreens_largestWidthLimitDp android:largestWidthLimitDp attribute of the &lt;supports-screens&gt; tag.
  set largestWidthLimitDp(int value) =>
      jniEnv.SetIntField(reference, _id_largestWidthLimitDp, value);

  static final _id_manageSpaceActivityName = jniAccessors.getFieldIDOf(
      _classRef, "manageSpaceActivityName", "Ljava/lang/String;");

  /// from: public java.lang.String manageSpaceActivityName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Class implementing the Application's manage space
  /// functionality.  From the "manageSpaceActivity"
  /// attribute. This is an optional attribute and will be null if
  /// applications don't specify it in their manifest
  jni.JniString get manageSpaceActivityName =>
      jni.JniString.fromRef(jniAccessors
          .getField(
              reference, _id_manageSpaceActivityName, jni.JniType.objectType)
          .object);

  /// from: public java.lang.String manageSpaceActivityName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Class implementing the Application's manage space
  /// functionality.  From the "manageSpaceActivity"
  /// attribute. This is an optional attribute and will be null if
  /// applications don't specify it in their manifest
  set manageSpaceActivityName(jni.JniString value) => jniEnv.SetObjectField(
      reference, _id_manageSpaceActivityName, value.reference);

  static final _id_minSdkVersion =
      jniAccessors.getFieldIDOf(_classRef, "minSdkVersion", "I");

  /// from: public int minSdkVersion
  ///
  /// The minimum SDK version this application can run on. It will not run
  /// on earlier versions.
  int get minSdkVersion => jniAccessors
      .getField(reference, _id_minSdkVersion, jni.JniType.intType)
      .integer;

  /// from: public int minSdkVersion
  ///
  /// The minimum SDK version this application can run on. It will not run
  /// on earlier versions.
  set minSdkVersion(int value) =>
      jniEnv.SetIntField(reference, _id_minSdkVersion, value);

  static final _id_nativeLibraryDir = jniAccessors.getFieldIDOf(
      _classRef, "nativeLibraryDir", "Ljava/lang/String;");

  /// from: public java.lang.String nativeLibraryDir
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Full path to the directory where native JNI libraries are stored.
  jni.JniString get nativeLibraryDir => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_nativeLibraryDir, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String nativeLibraryDir
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Full path to the directory where native JNI libraries are stored.
  set nativeLibraryDir(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_nativeLibraryDir, value.reference);

  static final _id_permission =
      jniAccessors.getFieldIDOf(_classRef, "permission", "Ljava/lang/String;");

  /// from: public java.lang.String permission
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Optional name of a permission required to be able to access this
  /// application's components.  From the "permission" attribute.
  jni.JniString get permission => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_permission, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String permission
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Optional name of a permission required to be able to access this
  /// application's components.  From the "permission" attribute.
  set permission(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_permission, value.reference);

  static final _id_processName =
      jniAccessors.getFieldIDOf(_classRef, "processName", "Ljava/lang/String;");

  /// from: public java.lang.String processName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The name of the process this application should run in.  From the
  /// "process" attribute or, if not set, the same as
  /// <var>packageName</var>.
  jni.JniString get processName => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_processName, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String processName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The name of the process this application should run in.  From the
  /// "process" attribute or, if not set, the same as
  /// <var>packageName</var>.
  set processName(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_processName, value.reference);

  static final _id_publicSourceDir = jniAccessors.getFieldIDOf(
      _classRef, "publicSourceDir", "Ljava/lang/String;");

  /// from: public java.lang.String publicSourceDir
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Full path to the publicly available parts of \#sourceDir,
  /// including resources and manifest. This may be different from
  /// \#sourceDir if an application is forward locked.
  jni.JniString get publicSourceDir => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_publicSourceDir, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String publicSourceDir
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Full path to the publicly available parts of \#sourceDir,
  /// including resources and manifest. This may be different from
  /// \#sourceDir if an application is forward locked.
  set publicSourceDir(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_publicSourceDir, value.reference);

  static final _id_requiresSmallestWidthDp =
      jniAccessors.getFieldIDOf(_classRef, "requiresSmallestWidthDp", "I");

  /// from: public int requiresSmallestWidthDp
  ///
  /// The required smallest screen width the application can run on.  If 0,
  /// nothing has been specified.  Comes from
  /// android.R.styleable\#AndroidManifestSupportsScreens_requiresSmallestWidthDp android:requiresSmallestWidthDp attribute of the &lt;supports-screens&gt; tag.
  int get requiresSmallestWidthDp => jniAccessors
      .getField(reference, _id_requiresSmallestWidthDp, jni.JniType.intType)
      .integer;

  /// from: public int requiresSmallestWidthDp
  ///
  /// The required smallest screen width the application can run on.  If 0,
  /// nothing has been specified.  Comes from
  /// android.R.styleable\#AndroidManifestSupportsScreens_requiresSmallestWidthDp android:requiresSmallestWidthDp attribute of the &lt;supports-screens&gt; tag.
  set requiresSmallestWidthDp(int value) =>
      jniEnv.SetIntField(reference, _id_requiresSmallestWidthDp, value);

  static final _id_sharedLibraryFiles = jniAccessors.getFieldIDOf(
      _classRef, "sharedLibraryFiles", "[Ljava/lang/String;");

  /// from: public java.lang.String[] sharedLibraryFiles
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Paths to all shared libraries this application is linked against.  This
  /// field is only set if the PackageManager\#GET_SHARED_LIBRARY_FILES PackageManager.GET_SHARED_LIBRARY_FILES flag was used when retrieving
  /// the structure.
  jni.JniObject get sharedLibraryFiles => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_sharedLibraryFiles, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String[] sharedLibraryFiles
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Paths to all shared libraries this application is linked against.  This
  /// field is only set if the PackageManager\#GET_SHARED_LIBRARY_FILES PackageManager.GET_SHARED_LIBRARY_FILES flag was used when retrieving
  /// the structure.
  set sharedLibraryFiles(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_sharedLibraryFiles, value.reference);

  static final _id_sourceDir =
      jniAccessors.getFieldIDOf(_classRef, "sourceDir", "Ljava/lang/String;");

  /// from: public java.lang.String sourceDir
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Full path to the base APK for this application.
  jni.JniString get sourceDir => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_sourceDir, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String sourceDir
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Full path to the base APK for this application.
  set sourceDir(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_sourceDir, value.reference);

  static final _id_splitNames =
      jniAccessors.getFieldIDOf(_classRef, "splitNames", "[Ljava/lang/String;");

  /// from: public java.lang.String[] splitNames
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The names of all installed split APKs, ordered lexicographically.
  jni.JniObject get splitNames => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_splitNames, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String[] splitNames
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The names of all installed split APKs, ordered lexicographically.
  set splitNames(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_splitNames, value.reference);

  static final _id_splitPublicSourceDirs = jniAccessors.getFieldIDOf(
      _classRef, "splitPublicSourceDirs", "[Ljava/lang/String;");

  /// from: public java.lang.String[] splitPublicSourceDirs
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Full path to the publicly available parts of \#splitSourceDirs,
  /// including resources and manifest. This may be different from
  /// \#splitSourceDirs if an application is forward locked.
  ///@see \#splitSourceDirs
  jni.JniObject get splitPublicSourceDirs => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_splitPublicSourceDirs, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String[] splitPublicSourceDirs
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Full path to the publicly available parts of \#splitSourceDirs,
  /// including resources and manifest. This may be different from
  /// \#splitSourceDirs if an application is forward locked.
  ///@see \#splitSourceDirs
  set splitPublicSourceDirs(jni.JniObject value) => jniEnv.SetObjectField(
      reference, _id_splitPublicSourceDirs, value.reference);

  static final _id_splitSourceDirs = jniAccessors.getFieldIDOf(
      _classRef, "splitSourceDirs", "[Ljava/lang/String;");

  /// from: public java.lang.String[] splitSourceDirs
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Full paths to zero or more split APKs, indexed by the same order as \#splitNames.
  jni.JniObject get splitSourceDirs => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_splitSourceDirs, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String[] splitSourceDirs
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Full paths to zero or more split APKs, indexed by the same order as \#splitNames.
  set splitSourceDirs(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_splitSourceDirs, value.reference);

  static final _id_storageUuid =
      jniAccessors.getFieldIDOf(_classRef, "storageUuid", "Ljava/util/UUID;");

  /// from: public java.util.UUID storageUuid
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// UUID of the storage volume on which this application is being hosted. For
  /// apps hosted on the default internal storage at
  /// Environment\#getDataDirectory(), the UUID value is
  /// StorageManager\#UUID_DEFAULT.
  jni.JniObject get storageUuid => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_storageUuid, jni.JniType.objectType)
      .object);

  /// from: public java.util.UUID storageUuid
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// UUID of the storage volume on which this application is being hosted. For
  /// apps hosted on the default internal storage at
  /// Environment\#getDataDirectory(), the UUID value is
  /// StorageManager\#UUID_DEFAULT.
  set storageUuid(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_storageUuid, value.reference);

  static final _id_targetSdkVersion =
      jniAccessors.getFieldIDOf(_classRef, "targetSdkVersion", "I");

  /// from: public int targetSdkVersion
  ///
  /// The minimum SDK version this application targets.  It may run on earlier
  /// versions, but it knows how to work with any new behavior added at this
  /// version.  Will be android.os.Build.VERSION_CODES\#CUR_DEVELOPMENT
  /// if this is a development build and the app is targeting that.  You should
  /// compare that this number is >= the SDK version number at which your
  /// behavior was introduced.
  int get targetSdkVersion => jniAccessors
      .getField(reference, _id_targetSdkVersion, jni.JniType.intType)
      .integer;

  /// from: public int targetSdkVersion
  ///
  /// The minimum SDK version this application targets.  It may run on earlier
  /// versions, but it knows how to work with any new behavior added at this
  /// version.  Will be android.os.Build.VERSION_CODES\#CUR_DEVELOPMENT
  /// if this is a development build and the app is targeting that.  You should
  /// compare that this number is >= the SDK version number at which your
  /// behavior was introduced.
  set targetSdkVersion(int value) =>
      jniEnv.SetIntField(reference, _id_targetSdkVersion, value);

  static final _id_taskAffinity = jniAccessors.getFieldIDOf(
      _classRef, "taskAffinity", "Ljava/lang/String;");

  /// from: public java.lang.String taskAffinity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Default task affinity of all activities in this application. See
  /// ActivityInfo\#taskAffinity for more information.  This comes
  /// from the "taskAffinity" attribute.
  jni.JniString get taskAffinity => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_taskAffinity, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String taskAffinity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Default task affinity of all activities in this application. See
  /// ActivityInfo\#taskAffinity for more information.  This comes
  /// from the "taskAffinity" attribute.
  set taskAffinity(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_taskAffinity, value.reference);

  static final _id_theme = jniAccessors.getFieldIDOf(_classRef, "theme", "I");

  /// from: public int theme
  ///
  /// A style resource identifier (in the package's resources) of the
  /// default visual theme of the application.  From the "theme" attribute
  /// or, if not set, 0.
  int get theme =>
      jniAccessors.getField(reference, _id_theme, jni.JniType.intType).integer;

  /// from: public int theme
  ///
  /// A style resource identifier (in the package's resources) of the
  /// default visual theme of the application.  From the "theme" attribute
  /// or, if not set, 0.
  set theme(int value) => jniEnv.SetIntField(reference, _id_theme, value);

  static final _id_uiOptions =
      jniAccessors.getFieldIDOf(_classRef, "uiOptions", "I");

  /// from: public int uiOptions
  ///
  /// The default extra UI options for activities in this application.
  /// Set from the android.R.attr\#uiOptions attribute in the
  /// activity's manifest.
  int get uiOptions => jniAccessors
      .getField(reference, _id_uiOptions, jni.JniType.intType)
      .integer;

  /// from: public int uiOptions
  ///
  /// The default extra UI options for activities in this application.
  /// Set from the android.R.attr\#uiOptions attribute in the
  /// activity's manifest.
  set uiOptions(int value) =>
      jniEnv.SetIntField(reference, _id_uiOptions, value);

  static final _id_uid = jniAccessors.getFieldIDOf(_classRef, "uid", "I");

  /// from: public int uid
  ///
  /// The kernel user-ID that has been assigned to this application;
  /// currently this is not a unique ID (multiple applications can have
  /// the same uid).
  int get uid =>
      jniAccessors.getField(reference, _id_uid, jni.JniType.intType).integer;

  /// from: public int uid
  ///
  /// The kernel user-ID that has been assigned to this application;
  /// currently this is not a unique ID (multiple applications can have
  /// the same uid).
  set uid(int value) => jniEnv.SetIntField(reference, _id_uid, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ApplicationInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/pm/ApplicationInfo;)V");

  /// from: public void <init>(android.content.pm.ApplicationInfo orig)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ApplicationInfo.ctor3(ApplicationInfo orig)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor3, [orig.reference]).object);

  static final _id_getCategoryTitle = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getCategoryTitle",
      "(Landroid/content/Context;I)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getCategoryTitle(android.content.Context context, int category)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a concise, localized title for the given
  /// ApplicationInfo\#category value, or {@code null} for unknown
  /// values such as \#CATEGORY_UNDEFINED.
  ///@see \#category
  ///@param category Value is android.content.pm.ApplicationInfo\#CATEGORY_UNDEFINED, android.content.pm.ApplicationInfo\#CATEGORY_GAME, android.content.pm.ApplicationInfo\#CATEGORY_AUDIO, android.content.pm.ApplicationInfo\#CATEGORY_VIDEO, android.content.pm.ApplicationInfo\#CATEGORY_IMAGE, android.content.pm.ApplicationInfo\#CATEGORY_SOCIAL, android.content.pm.ApplicationInfo\#CATEGORY_NEWS, android.content.pm.ApplicationInfo\#CATEGORY_MAPS, or android.content.pm.ApplicationInfo\#CATEGORY_PRODUCTIVITY
  static jni.JniObject getCategoryTitle(
          context_.Context context, int category) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getCategoryTitle,
          jni.JniType.objectType,
          [context.reference, category]).object);

  static final _id_dump = jniAccessors.getMethodIDOf(
      _classRef, "dump", "(Landroid/util/Printer;Ljava/lang/String;)V");

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  void dump(printer_.Printer pw, jni.JniString prefix) =>
      jniAccessors.callMethodWithArgs(reference, _id_dump, jni.JniType.voidType,
          [pw.reference, prefix.reference]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(parcel_.Parcel dest, int parcelableFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, parcelableFlags]).check();

  static final _id_loadDescription = jniAccessors.getMethodIDOf(
      _classRef,
      "loadDescription",
      "(Landroid/content/pm/PackageManager;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence loadDescription(android.content.pm.PackageManager pm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the textual description of the application.  This
  /// will call back on the given PackageManager to load the description from
  /// the application.
  ///@param pm A PackageManager from which the label can be loaded; usually
  /// the PackageManager from which you originally retrieved this item.
  ///@return Returns a CharSequence containing the application's description.
  /// If there is no description, null is returned.
  jni.JniObject loadDescription(packagemanager_.PackageManager pm) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_loadDescription, jni.JniType.objectType, [pm.reference]).object);

  static final _id_isVirtualPreload =
      jniAccessors.getMethodIDOf(_classRef, "isVirtualPreload", "()Z");

  /// from: public boolean isVirtualPreload()
  ///
  /// Returns whether or not this application was installed as a virtual preload.
  bool isVirtualPreload() => jniAccessors.callMethodWithArgs(
      reference, _id_isVirtualPreload, jni.JniType.booleanType, []).boolean;
}

/// from: android.content.pm.ApplicationInfo$DisplayNameComparator
class ApplicationInfo_DisplayNameComparator extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/content/pm/ApplicationInfo\$DisplayNameComparator");
  ApplicationInfo_DisplayNameComparator.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/pm/PackageManager;)V");

  /// from: public void <init>(android.content.pm.PackageManager pm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ApplicationInfo_DisplayNameComparator(packagemanager_.PackageManager pm)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [pm.reference]).object);

  static final _id_compare = jniAccessors.getMethodIDOf(_classRef, "compare",
      "(Landroid/content/pm/ApplicationInfo;Landroid/content/pm/ApplicationInfo;)I");

  /// from: public final int compare(android.content.pm.ApplicationInfo aa, android.content.pm.ApplicationInfo ab)
  int compare(ApplicationInfo aa, ApplicationInfo ab) =>
      jniAccessors.callMethodWithArgs(reference, _id_compare,
          jni.JniType.intType, [aa.reference, ab.reference]).integer;
}
