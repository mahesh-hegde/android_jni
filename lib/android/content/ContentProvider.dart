// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Context.dart" as context_;

import "res/Configuration.dart" as configuration_;

import "../database/Cursor.dart" as cursor_;

import "../net/Uri.dart" as uri_;

import "../os/CancellationSignal.dart" as cancellationsignal_;

import "../os/Bundle.dart" as bundle_;

import "ContentValues.dart" as contentvalues_;

import "../os/ParcelFileDescriptor.dart" as parcelfiledescriptor_;

import "res/AssetFileDescriptor.dart" as assetfiledescriptor_;

import "pm/ProviderInfo.dart" as providerinfo_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.ContentProvider
///
/// Content providers are one of the primary building blocks of Android applications, providing
/// content to applications. They encapsulate data and provide it to applications through the single
/// ContentResolver interface. A content provider is only required if you need to share
/// data between multiple applications. For example, the contacts data is used by multiple
/// applications and must be stored in a content provider. If you don't need to share data amongst
/// multiple applications you can use a database directly via
/// android.database.sqlite.SQLiteDatabase.
///
/// When a request is made via
/// a ContentResolver the system inspects the authority of the given URI and passes the
/// request to the content provider registered with the authority. The content provider can interpret
/// the rest of the URI however it wants. The UriMatcher class is helpful for parsing
/// URIs.
///
///
/// The primary methods that need to be implemented are:
/// <ul>
///   <li>\#onCreate which is called to initialize the provider</li>
///   <li>\#query which returns data to the caller</li>
///   <li>\#insert which inserts new data into the content provider</li>
///   <li>\#update which updates existing data in the content provider</li>
///   <li>\#delete which deletes data from the content provider</li>
///   <li>\#getType which returns the MIME type of data in the content provider</li>
/// </ul>
///
///
/// <p class="caution">Data access methods (such as \#insert and
/// \#update) may be called from many threads at once, and must be thread-safe.
/// Other methods (such as \#onCreate) are only called from the application
/// main thread, and must avoid performing lengthy operations.  See the method
/// descriptions for their expected thread behavior.
///
///
/// Requests to ContentResolver are automatically forwarded to the appropriate
/// ContentProvider instance, so subclasses don't have to worry about the details of
/// cross-process calls.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using content providers, read the
/// <a href="{@docRoot}guide/topics/providers/content-providers.html">Content Providers</a>
/// developer guide.
///
class ContentProvider extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/ContentProvider");
  ContentProvider.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a ContentProvider instance.  Content providers must be
  /// <a href="{@docRoot}guide/topics/manifest/provider-element.html">declared
  /// in the manifest</a>, accessed with ContentResolver, and created
  /// automatically by the system, so applications usually do not create
  /// ContentProvider instances directly.
  ///
  /// At construction time, the object is uninitialized, and most fields and
  /// methods are unavailable.  Subclasses should initialize themselves in
  /// \#onCreate, not the constructor.
  ///
  /// Content providers are created on the application main thread at
  /// application launch time.  The constructor must not perform lengthy
  /// operations, or application startup will be delayed.
  ContentProvider()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getContext = jniAccessors.getMethodIDOf(
      _classRef, "getContext", "()Landroid/content/Context;");

  /// from: public final android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the Context this provider is running in.  Only available once
  /// \#onCreate has been called -- this will return {@code null} in the
  /// constructor.
  context_.Context getContext() =>
      context_.Context.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getContext, jni.JniType.objectType, []).object);

  static final _id_getCallingPackage = jniAccessors.getMethodIDOf(
      _classRef, "getCallingPackage", "()Ljava/lang/String;");

  /// from: public final java.lang.String getCallingPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the package name of the caller that initiated the request being
  /// processed on the current thread. The returned package will have been
  /// verified to belong to the calling UID. Returns {@code null} if not
  /// currently processing a request.
  ///
  /// This will always return {@code null} when processing
  /// \#getType(Uri) or \#getStreamTypes(Uri, String) requests.
  ///@see Binder\#getCallingUid()
  ///@see Context\#grantUriPermission(String, Uri, int)
  ///@throws SecurityException if the calling package doesn't belong to the
  ///             calling UID.
  jni.JniString getCallingPackage() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCallingPackage, jni.JniType.objectType, []).object);

  static final _id_setReadPermission = jniAccessors.getMethodIDOf(
      _classRef, "setReadPermission", "(Ljava/lang/String;)V");

  /// from: protected final void setReadPermission(java.lang.String permission)
  ///
  /// Change the permission required to read data from the content
  /// provider.  This is normally set for you from its manifest information
  /// when the provider is first created.
  ///@param permission Name of the permission required for read-only access.
  ///
  /// This value may be {@code null}.
  void setReadPermission(jni.JniString permission) =>
      jniAccessors.callMethodWithArgs(reference, _id_setReadPermission,
          jni.JniType.voidType, [permission.reference]).check();

  static final _id_getReadPermission = jniAccessors.getMethodIDOf(
      _classRef, "getReadPermission", "()Ljava/lang/String;");

  /// from: public final java.lang.String getReadPermission()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the name of the permission required for read-only access to
  /// this content provider.  This method can be called from multiple
  /// threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///@return This value may be {@code null}.
  jni.JniString getReadPermission() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getReadPermission, jni.JniType.objectType, []).object);

  static final _id_setWritePermission = jniAccessors.getMethodIDOf(
      _classRef, "setWritePermission", "(Ljava/lang/String;)V");

  /// from: protected final void setWritePermission(java.lang.String permission)
  ///
  /// Change the permission required to read and write data in the content
  /// provider.  This is normally set for you from its manifest information
  /// when the provider is first created.
  ///@param permission Name of the permission required for read/write access.
  ///
  /// This value may be {@code null}.
  void setWritePermission(jni.JniString permission) =>
      jniAccessors.callMethodWithArgs(reference, _id_setWritePermission,
          jni.JniType.voidType, [permission.reference]).check();

  static final _id_getWritePermission = jniAccessors.getMethodIDOf(
      _classRef, "getWritePermission", "()Ljava/lang/String;");

  /// from: public final java.lang.String getWritePermission()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the name of the permission required for read/write access to
  /// this content provider.  This method can be called from multiple
  /// threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///@return This value may be {@code null}.
  jni.JniString getWritePermission() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getWritePermission, jni.JniType.objectType, []).object);

  static final _id_setPathPermissions = jniAccessors.getMethodIDOf(_classRef,
      "setPathPermissions", "([Landroid/content/pm/PathPermission;)V");

  /// from: protected final void setPathPermissions(android.content.pm.PathPermission[] permissions)
  ///
  /// Change the path-based permission required to read and/or write data in
  /// the content provider.  This is normally set for you from its manifest
  /// information when the provider is first created.
  ///@param permissions Array of path permission descriptions.
  ///
  /// This value may be {@code null}.
  void setPathPermissions(jni.JniObject permissions) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPathPermissions,
          jni.JniType.voidType, [permissions.reference]).check();

  static final _id_getPathPermissions = jniAccessors.getMethodIDOf(_classRef,
      "getPathPermissions", "()[Landroid/content/pm/PathPermission;");

  /// from: public final android.content.pm.PathPermission[] getPathPermissions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the path-based permissions required for read and/or write access to
  /// this content provider.  This method can be called from multiple
  /// threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///@return This value may be {@code null}.
  jni.JniObject getPathPermissions() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getPathPermissions, jni.JniType.objectType, []).object);

  static final _id_onCreate =
      jniAccessors.getMethodIDOf(_classRef, "onCreate", "()Z");

  /// from: public abstract boolean onCreate()
  ///
  /// Implement this to initialize your content provider on startup.
  /// This method is called for all registered content providers on the
  /// application main thread at application launch time.  It must not perform
  /// lengthy operations, or application startup will be delayed.
  ///
  /// You should defer nontrivial initialization (such as opening,
  /// upgrading, and scanning databases) until the content provider is used
  /// (via \#query, \#insert, etc).  Deferred initialization
  /// keeps application startup fast, avoids unnecessary work if the provider
  /// turns out not to be needed, and stops database errors (such as a full
  /// disk) from halting application launch.
  ///
  /// If you use SQLite, android.database.sqlite.SQLiteOpenHelper
  /// is a helpful utility class that makes it easy to manage databases,
  /// and will automatically defer opening until first use.  If you do use
  /// SQLiteOpenHelper, make sure to avoid calling
  /// android.database.sqlite.SQLiteOpenHelper\#getReadableDatabase or
  /// android.database.sqlite.SQLiteOpenHelper\#getWritableDatabase
  /// from this method.  (Instead, override
  /// android.database.sqlite.SQLiteOpenHelper\#onOpen to initialize the
  /// database when it is first opened.)
  ///@return true if the provider was successfully loaded, false otherwise
  bool onCreate() => jniAccessors.callMethodWithArgs(
      reference, _id_onCreate, jni.JniType.booleanType, []).boolean;

  static final _id_onConfigurationChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onConfigurationChanged",
      "(Landroid/content/res/Configuration;)V");

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  ///
  /// {@inheritDoc}
  /// This method is always called on the application main thread, and must
  /// not perform lengthy operations.
  ///
  /// The default content provider implementation does nothing.
  /// Override this method to take appropriate action.
  /// (Content providers do not usually care about things like screen
  /// orientation, but may want to know about locale changes.)
  void onConfigurationChanged(configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConfigurationChanged,
          jni.JniType.voidType, [newConfig.reference]).check();

  static final _id_onLowMemory =
      jniAccessors.getMethodIDOf(_classRef, "onLowMemory", "()V");

  /// from: public void onLowMemory()
  ///
  /// {@inheritDoc}
  /// This method is always called on the application main thread, and must
  /// not perform lengthy operations.
  ///
  /// The default content provider implementation does nothing.
  /// Subclasses may override this method to take appropriate action.
  void onLowMemory() => jniAccessors.callMethodWithArgs(
      reference, _id_onLowMemory, jni.JniType.voidType, []).check();

  static final _id_onTrimMemory =
      jniAccessors.getMethodIDOf(_classRef, "onTrimMemory", "(I)V");

  /// from: public void onTrimMemory(int level)
  void onTrimMemory(int level) => jniAccessors.callMethodWithArgs(
      reference, _id_onTrimMemory, jni.JniType.voidType, [level]).check();

  static final _id_query = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public abstract android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement this to handle query requests from clients.
  ///
  /// Apps targeting android.os.Build.VERSION_CODES\#O or higher should override
  /// \#query(Uri, String[], Bundle, CancellationSignal) and provide a stub
  /// implementation of this method.
  ///
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  /// Example client call:
  /// <pre>// Request a specific record.
  /// Cursor managedCursor = managedQuery(
  ///      ContentUris.withAppendedId(Contacts.People.CONTENT_URI, 2),
  ///      projection,    // Which columns to return.
  ///      null,          // WHERE clause.
  ///      null,          // WHERE clause value substitution
  ///      People.NAME + " ASC");   // Sort order.</pre>
  /// Example implementation:
  /// <pre>// SQLiteQueryBuilder is a helper class that creates the
  /// // proper SQL syntax for us.
  /// SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();
  ///
  /// // Set the table we're querying.
  /// qBuilder.setTables(DATABASE_TABLE_NAME);
  ///
  /// // If the query ends in a specific record number, we're
  /// // being asked for a specific record, so set the
  /// // WHERE clause in our query.
  /// if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){
  ///  qBuilder.appendWhere("_id=" + uri.getPathLeafId());
  /// }
  ///
  /// // Make the query.
  /// Cursor c = qBuilder.query(mDb,
  ///      projection,
  ///      selection,
  ///      selectionArgs,
  ///      groupBy,
  ///      having,
  ///      sortOrder);
  /// c.setNotificationUri(getContext().getContentResolver(), uri);
  /// return c;</pre>
  ///@param uri The URI to query. This will be the full URI sent by the client;
  ///      if the client is requesting a specific record, the URI will end in a record number
  ///      that the implementation should parse and add to a WHERE or HAVING clause, specifying
  ///      that _id value.
  /// This value must never be {@code null}.
  ///@param projection The list of columns to put into the cursor. If
  ///      {@code null} all columns are included.
  /// This value may be {@code null}.
  ///@param selection A selection criteria to apply when filtering rows.
  ///      If {@code null} then all rows are included.
  /// This value may be {@code null}.
  ///@param selectionArgs You may include ?s in selection, which will be replaced by
  ///      the values from selectionArgs, in order that they appear in the selection.
  ///      The values will be bound as Strings.
  /// This value may be {@code null}.
  ///@param sortOrder How the rows in the cursor should be sorted.
  ///      If {@code null} then the provider is free to define the sort order.
  /// This value may be {@code null}.
  ///@return a Cursor or {@code null}.
  cursor_.Cursor query(
          uri_.Uri uri,
          jni.JniObject projection,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString sortOrder) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query, jni.JniType.objectType, [
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference
      ]).object);

  static final _id_query1 = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement this to handle query requests from clients with support for cancellation.
  ///
  /// Apps targeting android.os.Build.VERSION_CODES\#O or higher should override
  /// \#query(Uri, String[], Bundle, CancellationSignal) instead of this method.
  ///
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  /// Example client call:
  /// <pre>// Request a specific record.
  /// Cursor managedCursor = managedQuery(
  ///     ContentUris.withAppendedId(Contacts.People.CONTENT_URI, 2),
  ///     projection,    // Which columns to return.
  ///     null,          // WHERE clause.
  ///     null,          // WHERE clause value substitution
  ///     People.NAME + " ASC");   // Sort order.</pre>
  /// Example implementation:
  /// <pre>// SQLiteQueryBuilder is a helper class that creates the
  /// // proper SQL syntax for us.
  /// SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();
  ///
  /// // Set the table we're querying.
  /// qBuilder.setTables(DATABASE_TABLE_NAME);
  ///
  /// // If the query ends in a specific record number, we're
  /// // being asked for a specific record, so set the
  /// // WHERE clause in our query.
  /// if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){
  /// qBuilder.appendWhere("_id=" + uri.getPathLeafId());
  /// }
  ///
  /// // Make the query.
  /// Cursor c = qBuilder.query(mDb,
  ///     projection,
  ///     selection,
  ///     selectionArgs,
  ///     groupBy,
  ///     having,
  ///     sortOrder);
  /// c.setNotificationUri(getContext().getContentResolver(), uri);
  /// return c;</pre>
  ///
  /// If you implement this method then you must also implement the version of
  /// \#query(Uri, String[], String, String[], String) that does not take a cancellation
  /// signal to ensure correct operation on older versions of the Android Framework in
  /// which the cancellation signal overload was not available.
  ///@param uri The URI to query. This will be the full URI sent by the client;
  ///      if the client is requesting a specific record, the URI will end in a record number
  ///      that the implementation should parse and add to a WHERE or HAVING clause, specifying
  ///      that _id value.
  /// This value must never be {@code null}.
  ///@param projection The list of columns to put into the cursor. If
  ///      {@code null} all columns are included.
  /// This value may be {@code null}.
  ///@param selection A selection criteria to apply when filtering rows.
  ///      If {@code null} then all rows are included.
  /// This value may be {@code null}.
  ///@param selectionArgs You may include ?s in selection, which will be replaced by
  ///      the values from selectionArgs, in order that they appear in the selection.
  ///      The values will be bound as Strings.
  /// This value may be {@code null}.
  ///@param sortOrder How the rows in the cursor should be sorted.
  ///      If {@code null} then the provider is free to define the sort order.
  /// This value may be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress, or {@code null} if none.
  /// If the operation is canceled, then android.os.OperationCanceledException will be thrown
  /// when the query is executed.
  /// This value may be {@code null}.
  ///@return a Cursor or {@code null}.
  cursor_.Cursor query1(
          uri_.Uri uri,
          jni.JniObject projection,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString sortOrder,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query1, jni.JniType.objectType, [
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference,
        cancellationSignal.reference
      ]).object);

  static final _id_query2 = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/net/Uri;[Ljava/lang/String;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, android.os.Bundle queryArgs, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement this to handle query requests where the arguments are packed into a Bundle.
  /// Arguments may include traditional SQL style query arguments. When present these
  /// should be handled  according to the contract established in
  /// {@link \#query(Uri, String[], String, String[], String, CancellationSignal).
  ///
  /// Traditional SQL arguments can be found in the bundle using the following keys:
  /// <li>ContentResolver\#QUERY_ARG_SQL_SELECTION
  /// <li>ContentResolver\#QUERY_ARG_SQL_SELECTION_ARGS
  /// <li>ContentResolver\#QUERY_ARG_SQL_SORT_ORDER
  ///
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  ///
  /// Example client call:
  /// <pre>// Request 20 records starting at row index 30.
  ///  Bundle queryArgs = new Bundle();
  ///  queryArgs.putInt(ContentResolver.QUERY_ARG_OFFSET, 30);
  ///  queryArgs.putInt(ContentResolver.QUERY_ARG_LIMIT, 20);
  ///
  ///  Cursor cursor = getContentResolver().query(
  ///           contentUri,    // Content Uri is specific to individual content providers.
  ///           projection,    // String[] describing which columns to return.
  ///           queryArgs,     // Query arguments.
  ///           null);         // Cancellation signal.</pre>
  ///
  /// Example implementation:
  /// <pre>
  ///
  ///   int recordsetSize = 0x1000;  // Actual value is implementation specific.
  ///   queryArgs = queryArgs != null ? queryArgs : Bundle.EMPTY;  // ensure queryArgs is non-null
  ///
  ///   int offset = queryArgs.getInt(ContentResolver.QUERY_ARG_OFFSET, 0);
  ///   int limit = queryArgs.getInt(ContentResolver.QUERY_ARG_LIMIT, Integer.MIN_VALUE);
  ///
  ///   MatrixCursor c = new MatrixCursor(PROJECTION, limit);
  ///
  ///   // Calculate the number of items to include in the cursor.
  ///   int numItems = MathUtils.constrain(recordsetSize - offset, 0, limit);
  ///
  ///   // Build the paged result set....
  ///   for (int i = offset; i < offset + numItems; i++) {
  ///       // populate row from your data.
  ///   }
  ///
  ///   Bundle extras = new Bundle();
  ///   c.setExtras(extras);
  ///
  ///   // Any QUERY_ARG_* key may be included if honored.
  ///   // In an actual implementation, include only keys that are both present in queryArgs
  ///   // and reflected in the Cursor output. For example, if QUERY_ARG_OFFSET were included
  ///   // in queryArgs, but was ignored because it contained an invalid value (like \u2013273),
  ///   // then QUERY_ARG_OFFSET should be omitted.
  ///   extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[] {
  ///       ContentResolver.QUERY_ARG_OFFSET,
  ///       ContentResolver.QUERY_ARG_LIMIT
  ///   });
  ///
  ///   extras.putInt(ContentResolver.EXTRA_TOTAL_COUNT, recordsetSize);
  ///
  ///   cursor.setNotificationUri(getContext().getContentResolver(), uri);
  ///
  ///   return cursor;</pre>
  ///
  ///@see \#query(Uri, String[], String, String[], String, CancellationSignal) for
  ///     implementation details.
  ///@param uri The URI to query. This will be the full URI sent by the client.
  ///@param projection The list of columns to put into the cursor.
  ///            If {@code null} provide a default set of columns.
  ///@param queryArgs A Bundle containing all additional information necessary for the query.
  ///            Values in the Bundle may include SQL style arguments.
  ///@param cancellationSignal A signal to cancel the operation in progress,
  ///            or {@code null}.
  ///@return a Cursor or {@code null}.
  ///@param uri This value must never be {@code null}.
  ///@param projection This value may be {@code null}.
  ///@param queryArgs This value may be {@code null}.
  ///@param cancellationSignal This value may be {@code null}.
  cursor_.Cursor query2(
          uri_.Uri uri,
          jni.JniObject projection,
          bundle_.Bundle queryArgs,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query2, jni.JniType.objectType, [
        uri.reference,
        projection.reference,
        queryArgs.reference,
        cancellationSignal.reference
      ]).object);

  static final _id_getType = jniAccessors.getMethodIDOf(
      _classRef, "getType", "(Landroid/net/Uri;)Ljava/lang/String;");

  /// from: public abstract java.lang.String getType(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement this to handle requests for the MIME type of the data at the
  /// given URI.  The returned MIME type should start with
  /// <code>vnd.android.cursor.item</code> for a single record,
  /// or <code>vnd.android.cursor.dir/</code> for multiple items.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  /// Note that there are no permissions needed for an application to
  /// access this information; if your content provider requires read and/or
  /// write permissions, or is not exported, all applications can still call
  /// this method regardless of their access permissions.  This allows them
  /// to retrieve the MIME type for a URI when dispatching intents.
  ///@param uri the URI to query.
  /// This value must never be {@code null}.
  ///@return a MIME type string, or {@code null} if there is no type.
  jni.JniString getType(uri_.Uri uri) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getType, jni.JniType.objectType, [uri.reference]).object);

  static final _id_canonicalize = jniAccessors.getMethodIDOf(
      _classRef, "canonicalize", "(Landroid/net/Uri;)Landroid/net/Uri;");

  /// from: public android.net.Uri canonicalize(android.net.Uri url)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement this to support canonicalization of URIs that refer to your
  /// content provider.  A canonical URI is one that can be transported across
  /// devices, backup/restore, and other contexts, and still be able to refer
  /// to the same data item.  Typically this is implemented by adding query
  /// params to the URI allowing the content provider to verify that an incoming
  /// canonical URI references the same data as it was originally intended for and,
  /// if it doesn't, to find that data (if it exists) in the current environment.
  ///
  /// For example, if the content provider holds people and a normal URI in it
  /// is created with a row index into that people database, the cananical representation
  /// may have an additional query param at the end which specifies the name of the
  /// person it is intended for.  Later calls into the provider with that URI will look
  /// up the row of that URI's base index and, if it doesn't match or its entry's
  /// name doesn't match the name in the query param, perform a query on its database
  /// to find the correct row to operate on.
  ///
  ///
  /// If you implement support for canonical URIs, __all__ incoming calls with
  /// URIs (including this one) must perform this verification and recovery of any
  /// canonical URIs they receive.  In addition, you must also implement
  /// \#uncanonicalize to strip the canonicalization of any of these URIs.
  ///
  ///
  /// The default implementation of this method returns null, indicating that
  /// canonical URIs are not supported.
  ///
  ///@param url The Uri to canonicalize.
  ///
  /// This value must never be {@code null}.
  ///@return Return the canonical representation of <var>url</var>, or null if
  /// canonicalization of that Uri is not supported.
  uri_.Uri canonicalize(uri_.Uri url) =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_canonicalize, jni.JniType.objectType, [url.reference]).object);

  static final _id_uncanonicalize = jniAccessors.getMethodIDOf(
      _classRef, "uncanonicalize", "(Landroid/net/Uri;)Landroid/net/Uri;");

  /// from: public android.net.Uri uncanonicalize(android.net.Uri url)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Remove canonicalization from canonical URIs previously returned by
  /// \#canonicalize.  For example, if your implementation is to add
  /// a query param to canonicalize a URI, this method can simply trip any
  /// query params on the URI.  The default implementation always returns the
  /// same <var>url</var> that was passed in.
  ///@param url The Uri to remove any canonicalization from.
  ///
  /// This value must never be {@code null}.
  ///@return Return the non-canonical representation of <var>url</var>, return
  /// the <var>url</var> as-is if there is nothing to do, or return null if
  /// the data identified by the canonical representation can not be found in
  /// the current environment.
  uri_.Uri uncanonicalize(uri_.Uri url) =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_uncanonicalize, jni.JniType.objectType, [url.reference]).object);

  static final _id_refresh = jniAccessors.getMethodIDOf(_classRef, "refresh",
      "(Landroid/net/Uri;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Z");

  /// from: public boolean refresh(android.net.Uri uri, android.os.Bundle args, android.os.CancellationSignal cancellationSignal)
  ///
  /// Implement this to support refresh of content identified by {@code uri}. By default, this
  /// method returns false; providers who wish to implement this should return true to signal the
  /// client that the provider has tried refreshing with its own implementation.
  ///
  /// This allows clients to request an explicit refresh of content identified by {@code uri}.
  ///
  /// Client code should only invoke this method when there is a strong indication (such as a user
  /// initiated pull to refresh gesture) that the content is stale.
  ///
  /// Remember to send ContentResolver\#notifyChange(Uri, android.database.ContentObserver)
  /// notifications when content changes.
  ///@param uri The Uri identifying the data to refresh.
  ///@param args Additional options from the client. The definitions of these are specific to the
  ///            content provider being called.
  /// This value may be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress, or {@code null} if
  ///            none. For example, if you called refresh on a particular uri, you should call
  ///            CancellationSignal\#throwIfCanceled() to check whether the client has
  ///            canceled the refresh request.
  /// This value may be {@code null}.
  ///@return true if the provider actually tried refreshing.
  bool refresh(uri_.Uri uri, bundle_.Bundle args,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_refresh, jni.JniType.booleanType, [
        uri.reference,
        args.reference,
        cancellationSignal.reference
      ]).boolean;

  static final _id_insert = jniAccessors.getMethodIDOf(_classRef, "insert",
      "(Landroid/net/Uri;Landroid/content/ContentValues;)Landroid/net/Uri;");

  /// from: public abstract android.net.Uri insert(android.net.Uri uri, android.content.ContentValues values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement this to handle requests to insert a new row.
  /// As a courtesy, call ContentResolver\#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()
  /// after inserting.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///@param uri The content:// URI of the insertion request. This must not be {@code null}.
  /// This value must never be {@code null}.
  ///@param values A set of column_name/value pairs to add to the database.
  ///     This must not be {@code null}.
  /// This value may be {@code null}.
  ///@return The URI for the newly inserted item.
  uri_.Uri insert(uri_.Uri uri, contentvalues_.ContentValues values) =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(reference, _id_insert,
          jni.JniType.objectType, [uri.reference, values.reference]).object);

  static final _id_bulkInsert = jniAccessors.getMethodIDOf(_classRef,
      "bulkInsert", "(Landroid/net/Uri;[Landroid/content/ContentValues;)I");

  /// from: public int bulkInsert(android.net.Uri uri, android.content.ContentValues[] values)
  ///
  /// Override this to handle requests to insert a set of new rows, or the
  /// default implementation will iterate over the values and call
  /// \#insert on each of them.
  /// As a courtesy, call ContentResolver\#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()
  /// after inserting.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///@param uri The content:// URI of the insertion request.
  /// This value must never be {@code null}.
  ///@param values An array of sets of column_name/value pairs to add to the database.
  ///    This must not be {@code null}.
  /// This value must never be {@code null}.
  ///@return The number of values that were inserted.
  int bulkInsert(uri_.Uri uri, jni.JniObject values) =>
      jniAccessors.callMethodWithArgs(reference, _id_bulkInsert,
          jni.JniType.intType, [uri.reference, values.reference]).integer;

  static final _id_delete1 = jniAccessors.getMethodIDOf(_classRef, "delete",
      "(Landroid/net/Uri;Ljava/lang/String;[Ljava/lang/String;)I");

  /// from: public abstract int delete(android.net.Uri uri, java.lang.String selection, java.lang.String[] selectionArgs)
  ///
  /// Implement this to handle requests to delete one or more rows.
  /// The implementation should apply the selection clause when performing
  /// deletion, allowing the operation to affect multiple rows in a directory.
  /// As a courtesy, call ContentResolver\#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()
  /// after deleting.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  /// The implementation is responsible for parsing out a row ID at the end
  /// of the URI, if a specific row is being deleted. That is, the client would
  /// pass in <code>content://contacts/people/22</code> and the implementation is
  /// responsible for parsing the record number (22) when creating a SQL statement.
  ///@param uri The full URI to query, including a row ID (if a specific record is requested).
  /// This value must never be {@code null}.
  ///@param selection An optional restriction to apply to rows when deleting.
  /// This value may be {@code null}.
  ///@param selectionArgs This value may be {@code null}.
  ///@return The number of rows affected.
  ///@throws SQLException
  int delete1(
          uri_.Uri uri, jni.JniString selection, jni.JniObject selectionArgs) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_delete1, jni.JniType.intType, [
        uri.reference,
        selection.reference,
        selectionArgs.reference
      ]).integer;

  static final _id_update = jniAccessors.getMethodIDOf(_classRef, "update",
      "(Landroid/net/Uri;Landroid/content/ContentValues;Ljava/lang/String;[Ljava/lang/String;)I");

  /// from: public abstract int update(android.net.Uri uri, android.content.ContentValues values, java.lang.String selection, java.lang.String[] selectionArgs)
  ///
  /// Implement this to handle requests to update one or more rows.
  /// The implementation should update all rows matching the selection
  /// to set the columns according to the provided values map.
  /// As a courtesy, call ContentResolver\#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()
  /// after updating.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///@param uri The URI to query. This can potentially have a record ID if this
  /// is an update request for a specific record.
  /// This value must never be {@code null}.
  ///@param values A set of column_name/value pairs to update in the database.
  ///     This must not be {@code null}.
  /// This value may be {@code null}.
  ///@param selection An optional filter to match rows to update.
  /// This value may be {@code null}.
  ///@param selectionArgs This value may be {@code null}.
  ///@return the number of rows affected.
  int update(uri_.Uri uri, contentvalues_.ContentValues values,
          jni.JniString selection, jni.JniObject selectionArgs) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_update, jni.JniType.intType, [
        uri.reference,
        values.reference,
        selection.reference,
        selectionArgs.reference
      ]).integer;

  static final _id_openFile = jniAccessors.getMethodIDOf(_classRef, "openFile",
      "(Landroid/net/Uri;Ljava/lang/String;)Landroid/os/ParcelFileDescriptor;");

  /// from: public android.os.ParcelFileDescriptor openFile(android.net.Uri uri, java.lang.String mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Override this to handle requests to open a file blob.
  /// The default implementation always throws FileNotFoundException.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  /// This method returns a ParcelFileDescriptor, which is returned directly
  /// to the caller.  This way large data (such as images and documents) can be
  /// returned without copying the content.
  ///
  /// The returned ParcelFileDescriptor is owned by the caller, so it is
  /// their responsibility to close it when done.  That is, the implementation
  /// of this method should create a new ParcelFileDescriptor for each call.
  ///
  /// If opened with the exclusive "r" or "w" modes, the returned
  /// ParcelFileDescriptor can be a pipe or socket pair to enable streaming
  /// of data. Opening with the "rw" or "rwt" modes implies a file on disk that
  /// supports seeking.
  ///
  /// If you need to detect when the returned ParcelFileDescriptor has been
  /// closed, or if the remote process has crashed or encountered some other
  /// error, you can use ParcelFileDescriptor\#open(File, int,
  /// android.os.Handler, android.os.ParcelFileDescriptor.OnCloseListener),
  /// ParcelFileDescriptor\#createReliablePipe(), or
  /// ParcelFileDescriptor\#createReliableSocketPair().
  ///
  /// If you need to return a large file that isn't backed by a real file on
  /// disk, such as a file on a network share or cloud storage service,
  /// consider using
  /// StorageManager\#openProxyFileDescriptor(int, android.os.ProxyFileDescriptorCallback, android.os.Handler)
  /// which will let you to stream the content on-demand.
  ///
  /// <p class="note">For use in Intents, you will want to implement \#getType
  /// to return the appropriate MIME type for the data returned here with
  /// the same URI.  This will allow intent resolution to automatically determine the data MIME
  /// type and select the appropriate matching targets as part of its operation.
  ///
  ///
  /// <p class="note">For better interoperability with other applications, it is recommended
  /// that for any URIs that can be opened, you also support queries on them
  /// containing at least the columns specified by android.provider.OpenableColumns.
  /// You may also want to support other common columns if you have additional meta-data
  /// to supply, such as android.provider.MediaStore.MediaColumns\#DATE_ADDED
  /// in android.provider.MediaStore.MediaColumns.
  ///
  ///@param uri The URI whose file is to be opened.
  /// This value must never be {@code null}.
  ///@param mode Access mode for the file.  May be "r" for read-only access,
  /// "rw" for read and write access, or "rwt" for read and write access
  /// that truncates any existing file.
  ///
  /// This value must never be {@code null}.
  ///@return Returns a new ParcelFileDescriptor which you can use to access
  /// the file.
  ///
  /// This value may be {@code null}.
  ///@throws FileNotFoundException Throws FileNotFoundException if there is
  /// no file associated with the given URI or the mode is invalid.
  ///@throws SecurityException Throws SecurityException if the caller does
  /// not have permission to access the file.
  ///@see \#openAssetFile(Uri, String)
  ///@see \#openFileHelper(Uri, String)
  ///@see \#getType(android.net.Uri)
  ///@see ParcelFileDescriptor\#parseMode(String)
  parcelfiledescriptor_.ParcelFileDescriptor openFile(
          uri_.Uri uri, jni.JniString mode) =>
      parcelfiledescriptor_.ParcelFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openFile, jni.JniType.objectType,
              [uri.reference, mode.reference]).object);

  static final _id_openFile1 = jniAccessors.getMethodIDOf(_classRef, "openFile",
      "(Landroid/net/Uri;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/os/ParcelFileDescriptor;");

  /// from: public android.os.ParcelFileDescriptor openFile(android.net.Uri uri, java.lang.String mode, android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Override this to handle requests to open a file blob.
  /// The default implementation always throws FileNotFoundException.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  /// This method returns a ParcelFileDescriptor, which is returned directly
  /// to the caller.  This way large data (such as images and documents) can be
  /// returned without copying the content.
  ///
  /// The returned ParcelFileDescriptor is owned by the caller, so it is
  /// their responsibility to close it when done.  That is, the implementation
  /// of this method should create a new ParcelFileDescriptor for each call.
  ///
  /// If opened with the exclusive "r" or "w" modes, the returned
  /// ParcelFileDescriptor can be a pipe or socket pair to enable streaming
  /// of data. Opening with the "rw" or "rwt" modes implies a file on disk that
  /// supports seeking.
  ///
  /// If you need to detect when the returned ParcelFileDescriptor has been
  /// closed, or if the remote process has crashed or encountered some other
  /// error, you can use ParcelFileDescriptor\#open(File, int,
  /// android.os.Handler, android.os.ParcelFileDescriptor.OnCloseListener),
  /// ParcelFileDescriptor\#createReliablePipe(), or
  /// ParcelFileDescriptor\#createReliableSocketPair().
  ///
  /// <p class="note">For use in Intents, you will want to implement \#getType
  /// to return the appropriate MIME type for the data returned here with
  /// the same URI.  This will allow intent resolution to automatically determine the data MIME
  /// type and select the appropriate matching targets as part of its operation.
  ///
  ///
  /// <p class="note">For better interoperability with other applications, it is recommended
  /// that for any URIs that can be opened, you also support queries on them
  /// containing at least the columns specified by android.provider.OpenableColumns.
  /// You may also want to support other common columns if you have additional meta-data
  /// to supply, such as android.provider.MediaStore.MediaColumns\#DATE_ADDED
  /// in android.provider.MediaStore.MediaColumns.
  ///
  ///@param uri The URI whose file is to be opened.
  /// This value must never be {@code null}.
  ///@param mode Access mode for the file. May be "r" for read-only access,
  ///            "w" for write-only access, "rw" for read and write access, or
  ///            "rwt" for read and write access that truncates any existing
  ///            file.
  /// This value must never be {@code null}.
  ///@param signal A signal to cancel the operation in progress, or
  ///            {@code null} if none. For example, if you are downloading a
  ///            file from the network to service a "rw" mode request, you
  ///            should periodically call
  ///            CancellationSignal\#throwIfCanceled() to check whether
  ///            the client has canceled the request and abort the download.
  ///
  /// This value may be {@code null}.
  ///@return Returns a new ParcelFileDescriptor which you can use to access
  /// the file.
  ///@throws FileNotFoundException Throws FileNotFoundException if there is
  /// no file associated with the given URI or the mode is invalid.
  ///@throws SecurityException Throws SecurityException if the caller does
  /// not have permission to access the file.
  ///@see \#openAssetFile(Uri, String)
  ///@see \#openFileHelper(Uri, String)
  ///@see \#getType(android.net.Uri)
  ///@see ParcelFileDescriptor\#parseMode(String)
  parcelfiledescriptor_.ParcelFileDescriptor openFile1(uri_.Uri uri,
          jni.JniString mode, cancellationsignal_.CancellationSignal signal) =>
      parcelfiledescriptor_.ParcelFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openFile1, jni.JniType.objectType,
              [uri.reference, mode.reference, signal.reference]).object);

  static final _id_openAssetFile = jniAccessors.getMethodIDOf(
      _classRef,
      "openAssetFile",
      "(Landroid/net/Uri;Ljava/lang/String;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public android.content.res.AssetFileDescriptor openAssetFile(android.net.Uri uri, java.lang.String mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This is like \#openFile, but can be implemented by providers
  /// that need to be able to return sub-sections of files, often assets
  /// inside of their .apk.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  /// If you implement this, your clients must be able to deal with such
  /// file slices, either directly with
  /// ContentResolver\#openAssetFileDescriptor, or by using the higher-level
  /// ContentResolver\#openInputStream ContentResolver.openInputStream
  /// or ContentResolver\#openOutputStream ContentResolver.openOutputStream
  /// methods.
  ///
  /// The returned AssetFileDescriptor can be a pipe or socket pair to enable
  /// streaming of data.
  ///
  /// <p class="note">If you are implementing this to return a full file, you
  /// should create the AssetFileDescriptor with
  /// AssetFileDescriptor\#UNKNOWN_LENGTH to be compatible with
  /// applications that cannot handle sub-sections of files.
  ///
  ///
  /// <p class="note">For use in Intents, you will want to implement \#getType
  /// to return the appropriate MIME type for the data returned here with
  /// the same URI.  This will allow intent resolution to automatically determine the data MIME
  /// type and select the appropriate matching targets as part of its operation.
  ///
  ///
  /// <p class="note">For better interoperability with other applications, it is recommended
  /// that for any URIs that can be opened, you also support queries on them
  /// containing at least the columns specified by android.provider.OpenableColumns.
  ///
  ///@param uri The URI whose file is to be opened.
  /// This value must never be {@code null}.
  ///@param mode Access mode for the file.  May be "r" for read-only access,
  /// "w" for write-only access (erasing whatever data is currently in
  /// the file), "wa" for write-only access to append to any existing data,
  /// "rw" for read and write access on any existing data, and "rwt" for read
  /// and write access that truncates any existing file.
  ///
  /// This value must never be {@code null}.
  ///@return Returns a new AssetFileDescriptor which you can use to access
  /// the file.
  ///
  /// This value may be {@code null}.
  ///@throws FileNotFoundException Throws FileNotFoundException if there is
  /// no file associated with the given URI or the mode is invalid.
  ///@throws SecurityException Throws SecurityException if the caller does
  /// not have permission to access the file.
  ///@see \#openFile(Uri, String)
  ///@see \#openFileHelper(Uri, String)
  ///@see \#getType(android.net.Uri)
  assetfiledescriptor_.AssetFileDescriptor openAssetFile(
          uri_.Uri uri, jni.JniString mode) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openAssetFile,
              jni.JniType.objectType, [uri.reference, mode.reference]).object);

  static final _id_openAssetFile1 = jniAccessors.getMethodIDOf(
      _classRef,
      "openAssetFile",
      "(Landroid/net/Uri;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public android.content.res.AssetFileDescriptor openAssetFile(android.net.Uri uri, java.lang.String mode, android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This is like \#openFile, but can be implemented by providers
  /// that need to be able to return sub-sections of files, often assets
  /// inside of their .apk.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  /// If you implement this, your clients must be able to deal with such
  /// file slices, either directly with
  /// ContentResolver\#openAssetFileDescriptor, or by using the higher-level
  /// ContentResolver\#openInputStream ContentResolver.openInputStream
  /// or ContentResolver\#openOutputStream ContentResolver.openOutputStream
  /// methods.
  ///
  /// The returned AssetFileDescriptor can be a pipe or socket pair to enable
  /// streaming of data.
  ///
  /// <p class="note">If you are implementing this to return a full file, you
  /// should create the AssetFileDescriptor with
  /// AssetFileDescriptor\#UNKNOWN_LENGTH to be compatible with
  /// applications that cannot handle sub-sections of files.
  ///
  ///
  /// <p class="note">For use in Intents, you will want to implement \#getType
  /// to return the appropriate MIME type for the data returned here with
  /// the same URI.  This will allow intent resolution to automatically determine the data MIME
  /// type and select the appropriate matching targets as part of its operation.
  ///
  ///
  /// <p class="note">For better interoperability with other applications, it is recommended
  /// that for any URIs that can be opened, you also support queries on them
  /// containing at least the columns specified by android.provider.OpenableColumns.
  ///
  ///@param uri The URI whose file is to be opened.
  /// This value must never be {@code null}.
  ///@param mode Access mode for the file.  May be "r" for read-only access,
  /// "w" for write-only access (erasing whatever data is currently in
  /// the file), "wa" for write-only access to append to any existing data,
  /// "rw" for read and write access on any existing data, and "rwt" for read
  /// and write access that truncates any existing file.
  /// This value must never be {@code null}.
  ///@param signal A signal to cancel the operation in progress, or
  ///            {@code null} if none. For example, if you are downloading a
  ///            file from the network to service a "rw" mode request, you
  ///            should periodically call
  ///            CancellationSignal\#throwIfCanceled() to check whether
  ///            the client has canceled the request and abort the download.
  ///
  /// This value may be {@code null}.
  ///@return Returns a new AssetFileDescriptor which you can use to access
  /// the file.
  ///@throws FileNotFoundException Throws FileNotFoundException if there is
  /// no file associated with the given URI or the mode is invalid.
  ///@throws SecurityException Throws SecurityException if the caller does
  /// not have permission to access the file.
  ///@see \#openFile(Uri, String)
  ///@see \#openFileHelper(Uri, String)
  ///@see \#getType(android.net.Uri)
  assetfiledescriptor_.AssetFileDescriptor openAssetFile1(uri_.Uri uri,
          jni.JniString mode, cancellationsignal_.CancellationSignal signal) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(
              reference,
              _id_openAssetFile1,
              jni.JniType.objectType,
              [uri.reference, mode.reference, signal.reference]).object);

  static final _id_openFileHelper = jniAccessors.getMethodIDOf(
      _classRef,
      "openFileHelper",
      "(Landroid/net/Uri;Ljava/lang/String;)Landroid/os/ParcelFileDescriptor;");

  /// from: protected final android.os.ParcelFileDescriptor openFileHelper(android.net.Uri uri, java.lang.String mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for subclasses that wish to implement \#openFile
  /// by looking up a column named "_data" at the given URI.
  ///@param uri The URI to be opened.
  /// This value must never be {@code null}.
  ///@param mode The file mode.  May be "r" for read-only access,
  /// "w" for write-only access (erasing whatever data is currently in
  /// the file), "wa" for write-only access to append to any existing data,
  /// "rw" for read and write access on any existing data, and "rwt" for read
  /// and write access that truncates any existing file.
  ///
  /// This value must never be {@code null}.
  ///@return Returns a new ParcelFileDescriptor that can be used by the
  /// client to access the file.
  ///
  /// This value will never be {@code null}.
  parcelfiledescriptor_.ParcelFileDescriptor openFileHelper(
          uri_.Uri uri, jni.JniString mode) =>
      parcelfiledescriptor_.ParcelFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openFileHelper,
              jni.JniType.objectType, [uri.reference, mode.reference]).object);

  static final _id_getStreamTypes = jniAccessors.getMethodIDOf(
      _classRef,
      "getStreamTypes",
      "(Landroid/net/Uri;Ljava/lang/String;)[Ljava/lang/String;");

  /// from: public java.lang.String[] getStreamTypes(android.net.Uri uri, java.lang.String mimeTypeFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a client to determine the types of data streams that this
  /// content provider supports for the given URI.  The default implementation
  /// returns {@code null}, meaning no types.  If your content provider stores data
  /// of a particular type, return that MIME type if it matches the given
  /// mimeTypeFilter.  If it can perform type conversions, return an array
  /// of all supported MIME types that match mimeTypeFilter.
  ///@param uri The data in the content provider being queried.
  /// This value must never be {@code null}.
  ///@param mimeTypeFilter The type of data the client desires.  May be
  /// a pattern, such as *&\#47;* to retrieve all possible data types.
  /// This value must never be {@code null}.
  ///@return Returns {@code null} if there are no possible data streams for the
  /// given mimeTypeFilter.  Otherwise returns an array of all available
  /// concrete MIME types.
  ///@see \#getType(Uri)
  ///@see \#openTypedAssetFile(Uri, String, Bundle)
  ///@see ClipDescription\#compareMimeTypes(String, String)
  jni.JniObject getStreamTypes(uri_.Uri uri, jni.JniString mimeTypeFilter) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getStreamTypes,
          jni.JniType.objectType,
          [uri.reference, mimeTypeFilter.reference]).object);

  static final _id_openTypedAssetFile = jniAccessors.getMethodIDOf(
      _classRef,
      "openTypedAssetFile",
      "(Landroid/net/Uri;Ljava/lang/String;Landroid/os/Bundle;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public android.content.res.AssetFileDescriptor openTypedAssetFile(android.net.Uri uri, java.lang.String mimeTypeFilter, android.os.Bundle opts)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a client to open a read-only stream containing data of a
  /// particular MIME type.  This is like \#openAssetFile(Uri, String),
  /// except the file can only be read-only and the content provider may
  /// perform data conversions to generate data of the desired type.
  ///
  /// The default implementation compares the given mimeType against the
  /// result of \#getType(Uri) and, if they match, simply calls
  /// \#openAssetFile(Uri, String).
  ///
  /// See ClipData for examples of the use and implementation
  /// of this method.
  ///
  /// The returned AssetFileDescriptor can be a pipe or socket pair to enable
  /// streaming of data.
  ///
  /// <p class="note">For better interoperability with other applications, it is recommended
  /// that for any URIs that can be opened, you also support queries on them
  /// containing at least the columns specified by android.provider.OpenableColumns.
  /// You may also want to support other common columns if you have additional meta-data
  /// to supply, such as android.provider.MediaStore.MediaColumns\#DATE_ADDED
  /// in android.provider.MediaStore.MediaColumns.
  ///
  ///@param uri The data in the content provider being queried.
  /// This value must never be {@code null}.
  ///@param mimeTypeFilter The type of data the client desires.  May be
  /// a pattern, such as *&\#47;*, if the caller does not have specific type
  /// requirements; in this case the content provider will pick its best
  /// type matching the pattern.
  /// This value must never be {@code null}.
  ///@param opts Additional options from the client.  The definitions of
  /// these are specific to the content provider being called.
  ///
  /// This value may be {@code null}.
  ///@return Returns a new AssetFileDescriptor from which the client can
  /// read data of the desired type.
  ///
  /// This value may be {@code null}.
  ///@throws FileNotFoundException Throws FileNotFoundException if there is
  /// no file associated with the given URI or the mode is invalid.
  ///@throws SecurityException Throws SecurityException if the caller does
  /// not have permission to access the data.
  ///@throws IllegalArgumentException Throws IllegalArgumentException if the
  /// content provider does not support the requested MIME type.
  ///@see \#getStreamTypes(Uri, String)
  ///@see \#openAssetFile(Uri, String)
  ///@see ClipDescription\#compareMimeTypes(String, String)
  assetfiledescriptor_.AssetFileDescriptor openTypedAssetFile(
          uri_.Uri uri, jni.JniString mimeTypeFilter, bundle_.Bundle opts) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_openTypedAssetFile, jni.JniType.objectType, [
        uri.reference,
        mimeTypeFilter.reference,
        opts.reference
      ]).object);

  static final _id_openTypedAssetFile1 = jniAccessors.getMethodIDOf(
      _classRef,
      "openTypedAssetFile",
      "(Landroid/net/Uri;Ljava/lang/String;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Landroid/content/res/AssetFileDescriptor;");

  /// from: public android.content.res.AssetFileDescriptor openTypedAssetFile(android.net.Uri uri, java.lang.String mimeTypeFilter, android.os.Bundle opts, android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a client to open a read-only stream containing data of a
  /// particular MIME type.  This is like \#openAssetFile(Uri, String),
  /// except the file can only be read-only and the content provider may
  /// perform data conversions to generate data of the desired type.
  ///
  /// The default implementation compares the given mimeType against the
  /// result of \#getType(Uri) and, if they match, simply calls
  /// \#openAssetFile(Uri, String).
  ///
  /// See ClipData for examples of the use and implementation
  /// of this method.
  ///
  /// The returned AssetFileDescriptor can be a pipe or socket pair to enable
  /// streaming of data.
  ///
  /// <p class="note">For better interoperability with other applications, it is recommended
  /// that for any URIs that can be opened, you also support queries on them
  /// containing at least the columns specified by android.provider.OpenableColumns.
  /// You may also want to support other common columns if you have additional meta-data
  /// to supply, such as android.provider.MediaStore.MediaColumns\#DATE_ADDED
  /// in android.provider.MediaStore.MediaColumns.
  ///
  ///@param uri The data in the content provider being queried.
  /// This value must never be {@code null}.
  ///@param mimeTypeFilter The type of data the client desires.  May be
  /// a pattern, such as *&\#47;*, if the caller does not have specific type
  /// requirements; in this case the content provider will pick its best
  /// type matching the pattern.
  /// This value must never be {@code null}.
  ///@param opts Additional options from the client.  The definitions of
  /// these are specific to the content provider being called.
  /// This value may be {@code null}.
  ///@param signal A signal to cancel the operation in progress, or
  ///            {@code null} if none. For example, if you are downloading a
  ///            file from the network to service a "rw" mode request, you
  ///            should periodically call
  ///            CancellationSignal\#throwIfCanceled() to check whether
  ///            the client has canceled the request and abort the download.
  ///
  /// This value may be {@code null}.
  ///@return Returns a new AssetFileDescriptor from which the client can
  /// read data of the desired type.
  ///@throws FileNotFoundException Throws FileNotFoundException if there is
  /// no file associated with the given URI or the mode is invalid.
  ///@throws SecurityException Throws SecurityException if the caller does
  /// not have permission to access the data.
  ///@throws IllegalArgumentException Throws IllegalArgumentException if the
  /// content provider does not support the requested MIME type.
  ///@see \#getStreamTypes(Uri, String)
  ///@see \#openAssetFile(Uri, String)
  ///@see ClipDescription\#compareMimeTypes(String, String)
  assetfiledescriptor_.AssetFileDescriptor openTypedAssetFile1(
          uri_.Uri uri,
          jni.JniString mimeTypeFilter,
          bundle_.Bundle opts,
          cancellationsignal_.CancellationSignal signal) =>
      assetfiledescriptor_.AssetFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_openTypedAssetFile1, jni.JniType.objectType, [
        uri.reference,
        mimeTypeFilter.reference,
        opts.reference,
        signal.reference
      ]).object);

  static final _id_isTemporary =
      jniAccessors.getMethodIDOf(_classRef, "isTemporary", "()Z");

  /// from: protected boolean isTemporary()
  ///
  /// Returns true if this instance is a temporary content provider.
  ///@return true if this instance is a temporary content provider
  bool isTemporary() => jniAccessors.callMethodWithArgs(
      reference, _id_isTemporary, jni.JniType.booleanType, []).boolean;

  static final _id_attachInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "attachInfo",
      "(Landroid/content/Context;Landroid/content/pm/ProviderInfo;)V");

  /// from: public void attachInfo(android.content.Context context, android.content.pm.ProviderInfo info)
  ///
  /// After being instantiated, this is called to tell the content provider
  /// about itself.
  ///@param context The context this provider is running in
  ///@param info Registered information about this content provider
  void attachInfo(context_.Context context, providerinfo_.ProviderInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_attachInfo,
          jni.JniType.voidType, [context.reference, info.reference]).check();

  static final _id_applyBatch = jniAccessors.getMethodIDOf(
      _classRef,
      "applyBatch",
      "(Ljava/util/ArrayList;)[Landroid/content/ContentProviderResult;");

  /// from: public android.content.ContentProviderResult[] applyBatch(java.util.ArrayList<android.content.ContentProviderOperation> operations)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Override this to handle requests to perform a batch of operations, or the
  /// default implementation will iterate over the operations and call
  /// ContentProviderOperation\#apply on each of them.
  /// If all calls to ContentProviderOperation\#apply succeed
  /// then a ContentProviderResult array with as many
  /// elements as there were operations will be returned.  If any of the calls
  /// fail, it is up to the implementation how many of the others take effect.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///@param operations the operations to apply
  /// This value must never be {@code null}.
  ///@return the results of the applications
  /// This value will never be {@code null}.
  ///@throws OperationApplicationException thrown if any operation fails.
  ///@see ContentProviderOperation\#apply
  jni.JniObject applyBatch(jni.JniObject operations) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_applyBatch,
          jni.JniType.objectType,
          [operations.reference]).object);

  static final _id_call = jniAccessors.getMethodIDOf(_classRef, "call",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/os/Bundle;)Landroid/os/Bundle;");

  /// from: public android.os.Bundle call(java.lang.String method, java.lang.String arg, android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call a provider-defined method.  This can be used to implement
  /// interfaces that are cheaper and/or unnatural for a table-like
  /// model.
  ///
  /// <p class="note"><strong>WARNING:</strong> The framework does no permission checking
  /// on this entry into the content provider besides the basic ability for the application
  /// to get access to the provider at all.  For example, it has no idea whether the call
  /// being executed may read or write data in the provider, so can't enforce those
  /// individual permissions.  Any implementation of this method <strong>must</strong>
  /// do its own permission checks on incoming calls to make sure they are allowed.
  ///
  ///@param method method name to call.  Opaque to framework, but should not be {@code null}.
  /// This value must never be {@code null}.
  ///@param arg provider-defined String argument.  May be {@code null}.
  /// This value may be {@code null}.
  ///@param extras provider-defined Bundle argument.  May be {@code null}.
  /// This value may be {@code null}.
  ///@return provider-defined return value.  May be {@code null}, which is also
  ///   the default for providers which don't implement any call methods.
  bundle_.Bundle call(
          jni.JniString method, jni.JniString arg, bundle_.Bundle extras) =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_call,
          jni.JniType.objectType,
          [method.reference, arg.reference, extras.reference]).object);

  static final _id_shutdown =
      jniAccessors.getMethodIDOf(_classRef, "shutdown", "()V");

  /// from: public void shutdown()
  ///
  /// Implement this to shut down the ContentProvider instance. You can then
  /// invoke this method in unit tests.
  ///
  ///
  /// Android normally handles ContentProvider startup and shutdown
  /// automatically. You do not need to start up or shut down a
  /// ContentProvider. When you invoke a test method on a ContentProvider,
  /// however, a ContentProvider instance is started and keeps running after
  /// the test finishes, even if a succeeding test instantiates another
  /// ContentProvider. A conflict develops because the two instances are
  /// usually running against the same underlying data source (for example, an
  /// sqlite database).
  ///
  ///
  ///
  /// Implementing shutDown() avoids this conflict by providing a way to
  /// terminate the ContentProvider. This method can also prevent memory leaks
  /// from multiple instantiations of the ContentProvider, and it can ensure
  /// unit test isolation by allowing you to completely clean up the test
  /// fixture before moving on to the next test.
  ///
  ///
  void shutdown() => jniAccessors.callMethodWithArgs(
      reference, _id_shutdown, jni.JniType.voidType, []).check();

  static final _id_dump = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: public void dump(java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Print the Provider's state into the given stream.  This gets invoked if
  /// you run "adb shell dumpsys activity provider &lt;provider_component_name&gt;".
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer The PrintWriter to which you should dump your state.  This will be
  /// closed for you after you return.
  ///@param args additional arguments to the dump request.
  void dump(jni.JniObject fd, jni.JniObject writer, jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(reference, _id_dump, jni.JniType.voidType,
          [fd.reference, writer.reference, args.reference]).check();
}

/// from: android.content.ContentProvider$PipeDataWriter
///
/// Interface to write a stream of data to a pipe.  Use with
/// ContentProvider\#openPipeHelper.
class ContentProvider_PipeDataWriter extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/content/ContentProvider\$PipeDataWriter");
  ContentProvider_PipeDataWriter.fromRef(jni.JObject ref) : super.fromRef(ref);
}
