// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "res/Configuration.dart" as configuration_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.content.ComponentCallbacks
///
/// The set of callback APIs that are common to all application components
/// (android.app.Activity, android.app.Service,
/// ContentProvider, and android.app.Application).
///
/// <p class="note"><strong>Note:</strong> You should also implement the ComponentCallbacks2 interface, which provides the ComponentCallbacks2\#onTrimMemory callback to help your app manage its memory usage more
/// effectively.
///
class ComponentCallbacks extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/content/ComponentCallbacks");
  ComponentCallbacks.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onConfigurationChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onConfigurationChanged",
      "(Landroid/content/res/Configuration;)V");

  /// from: public abstract void onConfigurationChanged(android.content.res.Configuration newConfig)
  ///
  /// Called by the system when the device configuration changes while your
  /// component is running.  Note that, unlike activities, other components
  /// are never restarted when a configuration changes: they must always deal
  /// with the results of the change, such as by re-retrieving resources.
  ///
  /// At the time that this function has been called, your Resources
  /// object will have been updated to return resource values matching the
  /// new configuration.
  ///
  /// For more information, read <a href="{@docRoot}guide/topics/resources/runtime-changes.html">Handling Runtime Changes</a>.
  ///@param newConfig The new device configuration.
  void onConfigurationChanged(configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConfigurationChanged,
          jni.JniType.voidType, [newConfig.reference]).check();

  static final _id_onLowMemory =
      jniAccessors.getMethodIDOf(_classRef, "onLowMemory", "()V");

  /// from: public abstract void onLowMemory()
  ///
  /// This is called when the overall system is running low on memory, and
  /// actively running processes should trim their memory usage.  While
  /// the exact point at which this will be called is not defined, generally
  /// it will happen when all background process have been killed.
  /// That is, before reaching the point of killing processes hosting
  /// service and foreground UI that we would like to avoid killing.
  ///
  /// You should implement this method to release
  /// any caches or other unnecessary resources you may be holding on to.
  /// The system will perform a garbage collection for you after returning from this method.
  /// Preferably, you should implement ComponentCallbacks2\#onTrimMemory from
  /// ComponentCallbacks2 to incrementally unload your resources based on various
  /// levels of memory demands.  That API is available for API level 14 and higher, so you should
  /// only use this \#onLowMemory method as a fallback for older versions, which can be
  /// treated the same as ComponentCallbacks2\#onTrimMemory with the ComponentCallbacks2\#TRIM_MEMORY_COMPLETE level.
  ///
  void onLowMemory() => jniAccessors.callMethodWithArgs(
      reference, _id_onLowMemory, jni.JniType.voidType, []).check();
}
