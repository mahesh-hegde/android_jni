// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.TrafficStats
///
/// Class that provides network traffic statistics. These statistics include
/// bytes transmitted and received and network packets transmitted and received,
/// over all interfaces, over the mobile interface, and on a per-UID basis.
///
/// These statistics may not be available on all platforms. If the statistics are
/// not supported by this device, \#UNSUPPORTED will be returned.
///
/// Note that the statistics returned by this class reset and start from zero
/// after every reboot. To access more robust historical network statistics data,
/// use NetworkStatsManager instead.
class TrafficStats extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/net/TrafficStats");
  TrafficStats.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int UNSUPPORTED
  ///
  /// The return value to indicate that the device does not support the statistic.
  static const UNSUPPORTED = -1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  TrafficStats()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setThreadStatsTag =
      jniAccessors.getStaticMethodIDOf(_classRef, "setThreadStatsTag", "(I)V");

  /// from: static public void setThreadStatsTag(int tag)
  ///
  /// Set active tag to use when accounting Socket traffic originating
  /// from the current thread. Only one active tag per thread is supported.
  ///
  /// Changes only take effect during subsequent calls to
  /// \#tagSocket(Socket).
  ///
  /// Tags between {@code 0xFFFFFF00} and {@code 0xFFFFFFFF} are reserved and
  /// used internally by system services like DownloadManager when
  /// performing traffic on behalf of an application.
  ///@see \#clearThreadStatsTag()
  static void setThreadStatsTag(int tag) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_setThreadStatsTag,
          jni.JniType.voidType, [tag]).check();

  static final _id_getAndSetThreadStatsTag = jniAccessors.getStaticMethodIDOf(
      _classRef, "getAndSetThreadStatsTag", "(I)I");

  /// from: static public int getAndSetThreadStatsTag(int tag)
  ///
  /// Set active tag to use when accounting Socket traffic originating
  /// from the current thread. Only one active tag per thread is supported.
  ///
  /// Changes only take effect during subsequent calls to
  /// \#tagSocket(Socket).
  ///
  /// Tags between {@code 0xFFFFFF00} and {@code 0xFFFFFFFF} are reserved and
  /// used internally by system services like DownloadManager when
  /// performing traffic on behalf of an application.
  ///@return the current tag for the calling thread, which can be used to
  ///         restore any existing values after a nested operation is finished
  static int getAndSetThreadStatsTag(int tag) =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getAndSetThreadStatsTag, jni.JniType.intType, [tag]).integer;

  static final _id_getThreadStatsTag =
      jniAccessors.getStaticMethodIDOf(_classRef, "getThreadStatsTag", "()I");

  /// from: static public int getThreadStatsTag()
  ///
  /// Get the active tag used when accounting Socket traffic originating
  /// from the current thread. Only one active tag per thread is supported.
  /// \#tagSocket(Socket).
  ///@see \#setThreadStatsTag(int)
  static int getThreadStatsTag() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getThreadStatsTag, jni.JniType.intType, []).integer;

  static final _id_clearThreadStatsTag =
      jniAccessors.getStaticMethodIDOf(_classRef, "clearThreadStatsTag", "()V");

  /// from: static public void clearThreadStatsTag()
  ///
  /// Clear any active tag set to account Socket traffic originating
  /// from the current thread.
  ///@see \#setThreadStatsTag(int)
  static void clearThreadStatsTag() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_clearThreadStatsTag, jni.JniType.voidType, []).check();

  static final _id_setThreadStatsUid =
      jniAccessors.getStaticMethodIDOf(_classRef, "setThreadStatsUid", "(I)V");

  /// from: static public void setThreadStatsUid(int uid)
  ///
  /// Set specific UID to use when accounting Socket traffic
  /// originating from the current thread. Designed for use when performing an
  /// operation on behalf of another application, or when another application
  /// is performing operations on your behalf.
  ///
  /// Any app can _accept_ blame for traffic performed on a socket
  /// originally created by another app by calling this method with the
  /// android.system.Os\#getuid() value. However, only apps holding the
  /// {@code android.Manifest.permission\#UPDATE_DEVICE_STATS} permission may
  /// _assign_ blame to another UIDs.
  ///
  /// Changes only take effect during subsequent calls to
  /// \#tagSocket(Socket).
  static void setThreadStatsUid(int uid) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_setThreadStatsUid,
          jni.JniType.voidType, [uid]).check();

  static final _id_getThreadStatsUid =
      jniAccessors.getStaticMethodIDOf(_classRef, "getThreadStatsUid", "()I");

  /// from: static public int getThreadStatsUid()
  ///
  /// Get the active UID used when accounting Socket traffic originating
  /// from the current thread. Only one active tag per thread is supported.
  /// \#tagSocket(Socket).
  ///@see \#setThreadStatsUid(int)
  static int getThreadStatsUid() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getThreadStatsUid, jni.JniType.intType, []).integer;

  static final _id_clearThreadStatsUid =
      jniAccessors.getStaticMethodIDOf(_classRef, "clearThreadStatsUid", "()V");

  /// from: static public void clearThreadStatsUid()
  ///
  /// Clear any active UID set to account Socket traffic originating
  /// from the current thread.
  ///@see \#setThreadStatsUid(int)
  static void clearThreadStatsUid() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_clearThreadStatsUid, jni.JniType.voidType, []).check();

  static final _id_tagSocket = jniAccessors.getStaticMethodIDOf(
      _classRef, "tagSocket", "(Ljava/net/Socket;)V");

  /// from: static public void tagSocket(java.net.Socket socket)
  ///
  /// Tag the given Socket with any statistics parameters active for
  /// the current thread. Subsequent calls always replace any existing
  /// parameters. When finished, call \#untagSocket(Socket) to remove
  /// statistics parameters.
  ///@see \#setThreadStatsTag(int)
  static void tagSocket(jni.JniObject socket) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_tagSocket,
          jni.JniType.voidType, [socket.reference]).check();

  static final _id_untagSocket = jniAccessors.getStaticMethodIDOf(
      _classRef, "untagSocket", "(Ljava/net/Socket;)V");

  /// from: static public void untagSocket(java.net.Socket socket)
  ///
  /// Remove any statistics parameters from the given Socket.
  static void untagSocket(jni.JniObject socket) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_untagSocket,
          jni.JniType.voidType, [socket.reference]).check();

  static final _id_tagDatagramSocket = jniAccessors.getStaticMethodIDOf(
      _classRef, "tagDatagramSocket", "(Ljava/net/DatagramSocket;)V");

  /// from: static public void tagDatagramSocket(java.net.DatagramSocket socket)
  ///
  /// Tag the given DatagramSocket with any statistics parameters
  /// active for the current thread. Subsequent calls always replace any
  /// existing parameters. When finished, call
  /// \#untagDatagramSocket(DatagramSocket) to remove statistics
  /// parameters.
  ///@see \#setThreadStatsTag(int)
  static void tagDatagramSocket(jni.JniObject socket) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_tagDatagramSocket,
          jni.JniType.voidType, [socket.reference]).check();

  static final _id_untagDatagramSocket = jniAccessors.getStaticMethodIDOf(
      _classRef, "untagDatagramSocket", "(Ljava/net/DatagramSocket;)V");

  /// from: static public void untagDatagramSocket(java.net.DatagramSocket socket)
  ///
  /// Remove any statistics parameters from the given DatagramSocket.
  static void untagDatagramSocket(jni.JniObject socket) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_untagDatagramSocket,
          jni.JniType.voidType, [socket.reference]).check();

  static final _id_tagFileDescriptor = jniAccessors.getStaticMethodIDOf(
      _classRef, "tagFileDescriptor", "(Ljava/io/FileDescriptor;)V");

  /// from: static public void tagFileDescriptor(java.io.FileDescriptor fd)
  ///
  /// Tag the given FileDescriptor socket with any statistics
  /// parameters active for the current thread. Subsequent calls always replace
  /// any existing parameters. When finished, call
  /// \#untagFileDescriptor(FileDescriptor) to remove statistics
  /// parameters.
  ///@see \#setThreadStatsTag(int)
  static void tagFileDescriptor(jni.JniObject fd) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_tagFileDescriptor,
          jni.JniType.voidType, [fd.reference]).check();

  static final _id_untagFileDescriptor = jniAccessors.getStaticMethodIDOf(
      _classRef, "untagFileDescriptor", "(Ljava/io/FileDescriptor;)V");

  /// from: static public void untagFileDescriptor(java.io.FileDescriptor fd)
  ///
  /// Remove any statistics parameters from the given FileDescriptor
  /// socket.
  static void untagFileDescriptor(jni.JniObject fd) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_untagFileDescriptor,
          jni.JniType.voidType, [fd.reference]).check();

  static final _id_incrementOperationCount = jniAccessors.getStaticMethodIDOf(
      _classRef, "incrementOperationCount", "(I)V");

  /// from: static public void incrementOperationCount(int operationCount)
  ///
  /// Increment count of network operations performed under the accounting tag
  /// currently active on the calling thread. This can be used to derive
  /// bytes-per-operation.
  ///@param operationCount Number of operations to increment count by.
  static void incrementOperationCount(int operationCount) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_incrementOperationCount,
          jni.JniType.voidType,
          [operationCount]).check();

  static final _id_incrementOperationCount1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "incrementOperationCount", "(II)V");

  /// from: static public void incrementOperationCount(int tag, int operationCount)
  ///
  /// Increment count of network operations performed under the given
  /// accounting tag. This can be used to derive bytes-per-operation.
  ///@param tag Accounting tag used in \#setThreadStatsTag(int).
  ///@param operationCount Number of operations to increment count by.
  static void incrementOperationCount1(int tag, int operationCount) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_incrementOperationCount1,
          jni.JniType.voidType,
          [tag, operationCount]).check();

  static final _id_getMobileTxPackets =
      jniAccessors.getStaticMethodIDOf(_classRef, "getMobileTxPackets", "()J");

  /// from: static public long getMobileTxPackets()
  ///
  /// Return number of packets transmitted across mobile networks since device
  /// boot. Counts packets across all mobile network interfaces, and always
  /// increases monotonically since device boot. Statistics are measured at the
  /// network layer, so they include both TCP and UDP usage.
  ///
  /// Before android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2, this may
  /// return \#UNSUPPORTED on devices where statistics aren't available.
  static int getMobileTxPackets() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getMobileTxPackets, jni.JniType.longType, []).long;

  static final _id_getMobileRxPackets =
      jniAccessors.getStaticMethodIDOf(_classRef, "getMobileRxPackets", "()J");

  /// from: static public long getMobileRxPackets()
  ///
  /// Return number of packets received across mobile networks since device
  /// boot. Counts packets across all mobile network interfaces, and always
  /// increases monotonically since device boot. Statistics are measured at the
  /// network layer, so they include both TCP and UDP usage.
  ///
  /// Before android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2, this may
  /// return \#UNSUPPORTED on devices where statistics aren't available.
  static int getMobileRxPackets() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getMobileRxPackets, jni.JniType.longType, []).long;

  static final _id_getMobileTxBytes =
      jniAccessors.getStaticMethodIDOf(_classRef, "getMobileTxBytes", "()J");

  /// from: static public long getMobileTxBytes()
  ///
  /// Return number of bytes transmitted across mobile networks since device
  /// boot. Counts packets across all mobile network interfaces, and always
  /// increases monotonically since device boot. Statistics are measured at the
  /// network layer, so they include both TCP and UDP usage.
  ///
  /// Before android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2, this may
  /// return \#UNSUPPORTED on devices where statistics aren't available.
  static int getMobileTxBytes() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getMobileTxBytes, jni.JniType.longType, []).long;

  static final _id_getMobileRxBytes =
      jniAccessors.getStaticMethodIDOf(_classRef, "getMobileRxBytes", "()J");

  /// from: static public long getMobileRxBytes()
  ///
  /// Return number of bytes received across mobile networks since device boot.
  /// Counts packets across all mobile network interfaces, and always increases
  /// monotonically since device boot. Statistics are measured at the network
  /// layer, so they include both TCP and UDP usage.
  ///
  /// Before android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2, this may
  /// return \#UNSUPPORTED on devices where statistics aren't available.
  static int getMobileRxBytes() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getMobileRxBytes, jni.JniType.longType, []).long;

  static final _id_getTotalTxPackets =
      jniAccessors.getStaticMethodIDOf(_classRef, "getTotalTxPackets", "()J");

  /// from: static public long getTotalTxPackets()
  ///
  /// Return number of packets transmitted since device boot. Counts packets
  /// across all network interfaces, and always increases monotonically since
  /// device boot. Statistics are measured at the network layer, so they
  /// include both TCP and UDP usage.
  ///
  /// Before android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2, this may
  /// return \#UNSUPPORTED on devices where statistics aren't available.
  static int getTotalTxPackets() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getTotalTxPackets, jni.JniType.longType, []).long;

  static final _id_getTotalRxPackets =
      jniAccessors.getStaticMethodIDOf(_classRef, "getTotalRxPackets", "()J");

  /// from: static public long getTotalRxPackets()
  ///
  /// Return number of packets received since device boot. Counts packets
  /// across all network interfaces, and always increases monotonically since
  /// device boot. Statistics are measured at the network layer, so they
  /// include both TCP and UDP usage.
  ///
  /// Before android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2, this may
  /// return \#UNSUPPORTED on devices where statistics aren't available.
  static int getTotalRxPackets() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getTotalRxPackets, jni.JniType.longType, []).long;

  static final _id_getTotalTxBytes =
      jniAccessors.getStaticMethodIDOf(_classRef, "getTotalTxBytes", "()J");

  /// from: static public long getTotalTxBytes()
  ///
  /// Return number of bytes transmitted since device boot. Counts packets
  /// across all network interfaces, and always increases monotonically since
  /// device boot. Statistics are measured at the network layer, so they
  /// include both TCP and UDP usage.
  ///
  /// Before android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2, this may
  /// return \#UNSUPPORTED on devices where statistics aren't available.
  static int getTotalTxBytes() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getTotalTxBytes, jni.JniType.longType, []).long;

  static final _id_getTotalRxBytes =
      jniAccessors.getStaticMethodIDOf(_classRef, "getTotalRxBytes", "()J");

  /// from: static public long getTotalRxBytes()
  ///
  /// Return number of bytes received since device boot. Counts packets across
  /// all network interfaces, and always increases monotonically since device
  /// boot. Statistics are measured at the network layer, so they include both
  /// TCP and UDP usage.
  ///
  /// Before android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2, this may
  /// return \#UNSUPPORTED on devices where statistics aren't available.
  static int getTotalRxBytes() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getTotalRxBytes, jni.JniType.longType, []).long;

  static final _id_getUidTxBytes =
      jniAccessors.getStaticMethodIDOf(_classRef, "getUidTxBytes", "(I)J");

  /// from: static public long getUidTxBytes(int uid)
  ///
  /// Return number of bytes transmitted by the given UID since device boot.
  /// Counts packets across all network interfaces, and always increases
  /// monotonically since device boot. Statistics are measured at the network
  /// layer, so they include both TCP and UDP usage.
  ///
  /// Before android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2, this may
  /// return \#UNSUPPORTED on devices where statistics aren't available.
  ///
  /// Starting in android.os.Build.VERSION_CODES\#N this will only
  /// report traffic statistics for the calling UID. It will return
  /// \#UNSUPPORTED for all other UIDs for privacy reasons. To access
  /// historical network statistics belonging to other UIDs, use
  /// NetworkStatsManager.
  ///@see android.os.Process\#myUid()
  ///@see android.content.pm.ApplicationInfo\#uid
  static int getUidTxBytes(int uid) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getUidTxBytes, jni.JniType.longType, [uid]).long;

  static final _id_getUidRxBytes =
      jniAccessors.getStaticMethodIDOf(_classRef, "getUidRxBytes", "(I)J");

  /// from: static public long getUidRxBytes(int uid)
  ///
  /// Return number of bytes received by the given UID since device boot.
  /// Counts packets across all network interfaces, and always increases
  /// monotonically since device boot. Statistics are measured at the network
  /// layer, so they include both TCP and UDP usage.
  ///
  /// Before android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2, this may return
  /// \#UNSUPPORTED on devices where statistics aren't available.
  ///
  /// Starting in android.os.Build.VERSION_CODES\#N this will only
  /// report traffic statistics for the calling UID. It will return
  /// \#UNSUPPORTED for all other UIDs for privacy reasons. To access
  /// historical network statistics belonging to other UIDs, use
  /// NetworkStatsManager.
  ///@see android.os.Process\#myUid()
  ///@see android.content.pm.ApplicationInfo\#uid
  static int getUidRxBytes(int uid) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getUidRxBytes, jni.JniType.longType, [uid]).long;

  static final _id_getUidTxPackets =
      jniAccessors.getStaticMethodIDOf(_classRef, "getUidTxPackets", "(I)J");

  /// from: static public long getUidTxPackets(int uid)
  ///
  /// Return number of packets transmitted by the given UID since device boot.
  /// Counts packets across all network interfaces, and always increases
  /// monotonically since device boot. Statistics are measured at the network
  /// layer, so they include both TCP and UDP usage.
  ///
  /// Before android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2, this may return
  /// \#UNSUPPORTED on devices where statistics aren't available.
  ///
  /// Starting in android.os.Build.VERSION_CODES\#N this will only
  /// report traffic statistics for the calling UID. It will return
  /// \#UNSUPPORTED for all other UIDs for privacy reasons. To access
  /// historical network statistics belonging to other UIDs, use
  /// NetworkStatsManager.
  ///@see android.os.Process\#myUid()
  ///@see android.content.pm.ApplicationInfo\#uid
  static int getUidTxPackets(int uid) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getUidTxPackets, jni.JniType.longType, [uid]).long;

  static final _id_getUidRxPackets =
      jniAccessors.getStaticMethodIDOf(_classRef, "getUidRxPackets", "(I)J");

  /// from: static public long getUidRxPackets(int uid)
  ///
  /// Return number of packets received by the given UID since device boot.
  /// Counts packets across all network interfaces, and always increases
  /// monotonically since device boot. Statistics are measured at the network
  /// layer, so they include both TCP and UDP usage.
  ///
  /// Before android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2, this may return
  /// \#UNSUPPORTED on devices where statistics aren't available.
  ///
  /// Starting in android.os.Build.VERSION_CODES\#N this will only
  /// report traffic statistics for the calling UID. It will return
  /// \#UNSUPPORTED for all other UIDs for privacy reasons. To access
  /// historical network statistics belonging to other UIDs, use
  /// NetworkStatsManager.
  ///@see android.os.Process\#myUid()
  ///@see android.content.pm.ApplicationInfo\#uid
  static int getUidRxPackets(int uid) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getUidRxPackets, jni.JniType.longType, [uid]).long;

  static final _id_getUidTcpTxBytes =
      jniAccessors.getStaticMethodIDOf(_classRef, "getUidTcpTxBytes", "(I)J");

  /// from: static public long getUidTcpTxBytes(int uid)
  ///
  /// @deprecated Starting in android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2,
  ///             transport layer statistics are no longer available, and will
  ///             always return \#UNSUPPORTED.
  ///@see \#getUidTxBytes(int)
  static int getUidTcpTxBytes(int uid) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getUidTcpTxBytes, jni.JniType.longType, [uid]).long;

  static final _id_getUidTcpRxBytes =
      jniAccessors.getStaticMethodIDOf(_classRef, "getUidTcpRxBytes", "(I)J");

  /// from: static public long getUidTcpRxBytes(int uid)
  ///
  /// @deprecated Starting in android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2,
  ///             transport layer statistics are no longer available, and will
  ///             always return \#UNSUPPORTED.
  ///@see \#getUidRxBytes(int)
  static int getUidTcpRxBytes(int uid) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getUidTcpRxBytes, jni.JniType.longType, [uid]).long;

  static final _id_getUidUdpTxBytes =
      jniAccessors.getStaticMethodIDOf(_classRef, "getUidUdpTxBytes", "(I)J");

  /// from: static public long getUidUdpTxBytes(int uid)
  ///
  /// @deprecated Starting in android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2,
  ///             transport layer statistics are no longer available, and will
  ///             always return \#UNSUPPORTED.
  ///@see \#getUidTxBytes(int)
  static int getUidUdpTxBytes(int uid) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getUidUdpTxBytes, jni.JniType.longType, [uid]).long;

  static final _id_getUidUdpRxBytes =
      jniAccessors.getStaticMethodIDOf(_classRef, "getUidUdpRxBytes", "(I)J");

  /// from: static public long getUidUdpRxBytes(int uid)
  ///
  /// @deprecated Starting in android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2,
  ///             transport layer statistics are no longer available, and will
  ///             always return \#UNSUPPORTED.
  ///@see \#getUidRxBytes(int)
  static int getUidUdpRxBytes(int uid) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getUidUdpRxBytes, jni.JniType.longType, [uid]).long;

  static final _id_getUidTcpTxSegments = jniAccessors.getStaticMethodIDOf(
      _classRef, "getUidTcpTxSegments", "(I)J");

  /// from: static public long getUidTcpTxSegments(int uid)
  ///
  /// @deprecated Starting in android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2,
  ///             transport layer statistics are no longer available, and will
  ///             always return \#UNSUPPORTED.
  ///@see \#getUidTxPackets(int)
  static int getUidTcpTxSegments(int uid) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getUidTcpTxSegments, jni.JniType.longType, [uid]).long;

  static final _id_getUidTcpRxSegments = jniAccessors.getStaticMethodIDOf(
      _classRef, "getUidTcpRxSegments", "(I)J");

  /// from: static public long getUidTcpRxSegments(int uid)
  ///
  /// @deprecated Starting in android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2,
  ///             transport layer statistics are no longer available, and will
  ///             always return \#UNSUPPORTED.
  ///@see \#getUidRxPackets(int)
  static int getUidTcpRxSegments(int uid) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getUidTcpRxSegments, jni.JniType.longType, [uid]).long;

  static final _id_getUidUdpTxPackets =
      jniAccessors.getStaticMethodIDOf(_classRef, "getUidUdpTxPackets", "(I)J");

  /// from: static public long getUidUdpTxPackets(int uid)
  ///
  /// @deprecated Starting in android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2,
  ///             transport layer statistics are no longer available, and will
  ///             always return \#UNSUPPORTED.
  ///@see \#getUidTxPackets(int)
  static int getUidUdpTxPackets(int uid) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getUidUdpTxPackets, jni.JniType.longType, [uid]).long;

  static final _id_getUidUdpRxPackets =
      jniAccessors.getStaticMethodIDOf(_classRef, "getUidUdpRxPackets", "(I)J");

  /// from: static public long getUidUdpRxPackets(int uid)
  ///
  /// @deprecated Starting in android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2,
  ///             transport layer statistics are no longer available, and will
  ///             always return \#UNSUPPORTED.
  ///@see \#getUidRxPackets(int)
  static int getUidUdpRxPackets(int uid) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getUidUdpRxPackets, jni.JniType.longType, [uid]).long;
}
