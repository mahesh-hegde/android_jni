// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.http.HttpResponseCache
///
/// Caches HTTP and HTTPS responses to the filesystem so they may be reused,
/// saving time and bandwidth. This class supports java.net.HttpURLConnection and javax.net.ssl.HttpsURLConnection;
/// there is no platform-provided cache for {@code DefaultHttpClient} or
/// {@code AndroidHttpClient}. Installation and instances are thread
/// safe.
///
/// <h3>Installing an HTTP response cache</h3>
/// Enable caching of all of your application's HTTP requests by installing the
/// cache at application startup. For example, this code installs a 10 MiB cache
/// in the android.content.Context\#getCacheDir() application-specific
/// cache directory of the filesystem}: <pre>   {@code
///   protected void onCreate(Bundle savedInstanceState) {
///       ...
///
///       try {
///           File httpCacheDir = new File(context.getCacheDir(), "http");
///           long httpCacheSize = 10 * 1024 * 1024; // 10 MiB
///           HttpResponseCache.install(httpCacheDir, httpCacheSize);
///       } catch (IOException e) {
///           Log.i(TAG, "HTTP response cache installation failed:" + e);
///       }
///   }
///
///   protected void onStop() {
///       ...
///
///       HttpResponseCache cache = HttpResponseCache.getInstalled();
///       if (cache != null) {
///           cache.flush();
///       }
///   }}</pre>
/// This cache will evict entries as necessary to keep its size from exceeding
/// 10 MiB. The best cache size is application specific and depends on the size
/// and frequency of the files being downloaded. Increasing the limit may improve
/// the hit rate, but it may also just waste filesystem space!
///
/// For some applications it may be preferable to create the cache in the
/// external storage directory. <strong>There are no access controls on the
/// external storage directory so it should not be used for caches that could
/// contain private data.</strong> Although it often has more free space,
/// external storage is optional and&\#8212;even if available&\#8212;can disappear
/// during use. Retrieve the external cache directory using android.content.Context\#getExternalCacheDir(). If this method returns null,
/// your application should fall back to either not caching or caching on
/// non-external storage. If the external storage is removed during use, the
/// cache hit rate will drop to zero and ongoing cache reads will fail.
///
/// Flushing the cache forces its data to the filesystem. This ensures that
/// all responses written to the cache will be readable the next time the
/// activity starts.
///
/// <h3>Cache Optimization</h3>
/// To measure cache effectiveness, this class tracks three statistics:
/// <ul>
///     <li><strong>\#getRequestCount() Request Count:</strong> the number
///         of HTTP requests issued since this cache was created.
///     <li><strong>\#getNetworkCount() Network Count:</strong> the
///         number of those requests that required network use.
///     <li><strong>\#getHitCount() Hit Count:</strong> the number of
///         those requests whose responses were served by the cache.
/// </ul>
/// Sometimes a request will result in a conditional cache hit. If the cache
/// contains a stale copy of the response, the client will issue a conditional
/// {@code GET}. The server will then send either the updated response if it has
/// changed, or a short 'not modified' response if the client's copy is still
/// valid. Such responses increment both the network count and hit count.
///
/// The best way to improve the cache hit rate is by configuring the web
/// server to return cacheable responses. Although this client honors all <a href="http://www.ietf.org/rfc/rfc2616.txt">HTTP/1.1 (RFC 2068)</a> cache
/// headers, it doesn't cache partial responses.
///
/// <h3>Force a Network Response</h3>
/// In some situations, such as after a user clicks a 'refresh' button, it may be
/// necessary to skip the cache, and fetch data directly from the server. To force
/// a full refresh, add the {@code no-cache} directive: <pre>   {@code
///         connection.addRequestProperty("Cache-Control", "no-cache");
/// }</pre>
/// If it is only necessary to force a cached response to be validated by the
/// server, use the more efficient {@code max-age=0} instead: <pre>   {@code
///         connection.addRequestProperty("Cache-Control", "max-age=0");
/// }</pre>
///
/// <h3>Force a Cache Response</h3>
/// Sometimes you'll want to show resources if they are available immediately,
/// but not otherwise. This can be used so your application can show
/// <i>something</i> while waiting for the latest data to be downloaded. To
/// restrict a request to locally-cached resources, add the {@code
/// only-if-cached} directive: <pre>   {@code
///     try {
///         connection.addRequestProperty("Cache-Control", "only-if-cached");
///         InputStream cached = connection.getInputStream();
///         // the resource was cached! show it
///     } catch (FileNotFoundException e) {
///         // the resource was not cached
///     }
/// }</pre>
/// This technique works even better in situations where a stale response is
/// better than no response. To permit stale cached responses, use the {@code
/// max-stale} directive with the maximum staleness in seconds: <pre>   {@code
///         int maxStale = 60 * 60 * 24 * 28; // tolerate 4-weeks stale
///         connection.addRequestProperty("Cache-Control", "max-stale=" + maxStale);
/// }</pre>
///
/// <h3>Working With Earlier Releases</h3>
/// This class was added in Android 4.0 (Ice Cream Sandwich). Use reflection to
/// enable the response cache without impacting earlier releases: <pre>   {@code
///       try {
///           File httpCacheDir = new File(context.getCacheDir(), "http");
///           long httpCacheSize = 10 * 1024 * 1024; // 10 MiB
///           Class.forName("android.net.http.HttpResponseCache")
///                   .getMethod("install", File.class, long.class)
///                   .invoke(null, httpCacheDir, httpCacheSize);
///       } catch (Exception httpResponseCacheNotAvailable) {
///       }}</pre>
class HttpResponseCache extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/http/HttpResponseCache");
  HttpResponseCache.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getInstalled = jniAccessors.getStaticMethodIDOf(
      _classRef, "getInstalled", "()Landroid/net/http/HttpResponseCache;");

  /// from: static public android.net.http.HttpResponseCache getInstalled()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the currently-installed {@code HttpResponseCache}, or null if
  /// there is no cache installed or it is not a {@code HttpResponseCache}.
  static HttpResponseCache getInstalled() =>
      HttpResponseCache.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getInstalled, jni.JniType.objectType, []).object);

  static final _id_install = jniAccessors.getStaticMethodIDOf(_classRef,
      "install", "(Ljava/io/File;J)Landroid/net/http/HttpResponseCache;");

  /// from: synchronized static public android.net.http.HttpResponseCache install(java.io.File directory, long maxSize)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new HTTP response cache and sets it as the system default cache.
  ///@param directory the directory to hold cache data.
  ///@param maxSize the maximum size of the cache in bytes.
  ///@return the newly-installed cache
  ///@throws IOException if {@code directory} cannot be used for this cache.
  ///     Most applications should respond to this exception by logging a
  ///     warning.
  static HttpResponseCache install(jni.JniObject directory, int maxSize) =>
      HttpResponseCache.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_install,
          jni.JniType.objectType,
          [directory.reference, maxSize]).object);

  static final _id_get0 = jniAccessors.getMethodIDOf(_classRef, "get",
      "(Ljava/net/URI;Ljava/lang/String;Ljava/util/Map;)Ljava/net/CacheResponse;");

  /// from: public java.net.CacheResponse get(java.net.URI uri, java.lang.String requestMethod, java.util.Map<java.lang.String,java.util.List<java.lang.String>> requestHeaders)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get0(jni.JniObject uri, jni.JniString requestMethod,
          jni.JniObject requestHeaders) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_get0, jni.JniType.objectType, [
        uri.reference,
        requestMethod.reference,
        requestHeaders.reference
      ]).object);

  static final _id_put = jniAccessors.getMethodIDOf(_classRef, "put",
      "(Ljava/net/URI;Ljava/net/URLConnection;)Ljava/net/CacheRequest;");

  /// from: public java.net.CacheRequest put(java.net.URI uri, java.net.URLConnection urlConnection)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject put(jni.JniObject uri, jni.JniObject urlConnection) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_put,
          jni.JniType.objectType,
          [uri.reference, urlConnection.reference]).object);

  static final _id_size = jniAccessors.getMethodIDOf(_classRef, "size", "()J");

  /// from: public long size()
  ///
  /// Returns the number of bytes currently being used to store the values in
  /// this cache. This may be greater than the \#maxSize if a background
  /// deletion is pending. {@code -1} is returned if the size cannot be determined.
  int size() => jniAccessors
      .callMethodWithArgs(reference, _id_size, jni.JniType.longType, []).long;

  static final _id_maxSize =
      jniAccessors.getMethodIDOf(_classRef, "maxSize", "()J");

  /// from: public long maxSize()
  ///
  /// Returns the maximum number of bytes that this cache should use to store
  /// its data.
  int maxSize() => jniAccessors.callMethodWithArgs(
      reference, _id_maxSize, jni.JniType.longType, []).long;

  static final _id_flush =
      jniAccessors.getMethodIDOf(_classRef, "flush", "()V");

  /// from: public void flush()
  ///
  /// Force buffered operations to the filesystem. This ensures that responses
  /// written to the cache will be available the next time the cache is opened,
  /// even if this process is killed.
  void flush() => jniAccessors.callMethodWithArgs(
      reference, _id_flush, jni.JniType.voidType, []).check();

  static final _id_getNetworkCount =
      jniAccessors.getMethodIDOf(_classRef, "getNetworkCount", "()I");

  /// from: public int getNetworkCount()
  ///
  /// Returns the number of HTTP requests that required the network to either
  /// supply a response or validate a locally cached response.
  int getNetworkCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getNetworkCount, jni.JniType.intType, []).integer;

  static final _id_getHitCount =
      jniAccessors.getMethodIDOf(_classRef, "getHitCount", "()I");

  /// from: public int getHitCount()
  ///
  /// Returns the number of HTTP requests whose response was provided by the
  /// cache. This may include conditional {@code GET} requests that were
  /// validated over the network.
  int getHitCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getHitCount, jni.JniType.intType, []).integer;

  static final _id_getRequestCount =
      jniAccessors.getMethodIDOf(_classRef, "getRequestCount", "()I");

  /// from: public int getRequestCount()
  ///
  /// Returns the total number of HTTP requests that were made. This includes
  /// both client requests and requests that were made on the client's behalf
  /// to handle a redirects and retries.
  int getRequestCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getRequestCount, jni.JniType.intType, []).integer;

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Uninstalls the cache and releases any active resources. Stored contents
  /// will remain on the filesystem.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_delete1 =
      jniAccessors.getMethodIDOf(_classRef, "delete", "()V");

  /// from: public void delete()
  ///
  /// Uninstalls the cache and deletes all of its stored contents.
  void delete1() => jniAccessors.callMethodWithArgs(
      reference, _id_delete1, jni.JniType.voidType, []).check();
}
