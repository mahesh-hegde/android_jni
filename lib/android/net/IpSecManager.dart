// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "IpSecTransform.dart" as ipsectransform_;

import "../util/AndroidException.dart" as androidexception_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.IpSecManager
///
/// This class contains methods for managing IPsec sessions. Once configured, the kernel will apply
/// confidentiality (encryption) and integrity (authentication) to IP traffic.
///
/// Note that not all aspects of IPsec are permitted by this API. Applications may create
/// transport mode security associations and apply them to individual sockets. Applications looking
/// to create a VPN should use VpnService.
///@see <a href="https://tools.ietf.org/html/rfc4301">RFC 4301, Security Architecture for the
///     Internet Protocol</a>
class IpSecManager extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/net/IpSecManager");
  IpSecManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DIRECTION_IN
  ///
  /// Used when applying a transform to direct traffic through an IpSecTransform
  /// towards the host.
  ///
  /// See \#applyTransportModeTransform(Socket, int, IpSecTransform).
  static const DIRECTION_IN = 0;

  /// from: static public final int DIRECTION_OUT
  ///
  /// Used when applying a transform to direct traffic through an IpSecTransform
  /// away from the host.
  ///
  /// See \#applyTransportModeTransform(Socket, int, IpSecTransform).
  static const DIRECTION_OUT = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  IpSecManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_allocateSecurityParameterIndex = jniAccessors.getMethodIDOf(
      _classRef,
      "allocateSecurityParameterIndex",
      "(Ljava/net/InetAddress;)Landroid/net/IpSecManager\$SecurityParameterIndex;");

  /// from: public android.net.IpSecManager.SecurityParameterIndex allocateSecurityParameterIndex(java.net.InetAddress destinationAddress)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Reserve a random SPI for traffic bound to or from the specified destination address.
  ///
  /// If successful, this SPI is guaranteed available until released by a call to SecurityParameterIndex\#close().
  ///@param destinationAddress the destination address for traffic bearing the requested SPI.
  ///     For inbound traffic, the destination should be an address currently assigned on-device.
  /// This value must never be {@code null}.
  ///@return the reserved SecurityParameterIndex
  /// This value will never be {@code null}.
  ///@throws \#ResourceUnavailableException indicating that too many SPIs are
  ///     currently allocated for this user
  IpSecManager_SecurityParameterIndex allocateSecurityParameterIndex(
          jni.JniObject destinationAddress) =>
      IpSecManager_SecurityParameterIndex.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_allocateSecurityParameterIndex,
              jni.JniType.objectType, [destinationAddress.reference]).object);

  static final _id_allocateSecurityParameterIndex1 = jniAccessors.getMethodIDOf(
      _classRef,
      "allocateSecurityParameterIndex",
      "(Ljava/net/InetAddress;I)Landroid/net/IpSecManager\$SecurityParameterIndex;");

  /// from: public android.net.IpSecManager.SecurityParameterIndex allocateSecurityParameterIndex(java.net.InetAddress destinationAddress, int requestedSpi)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Reserve the requested SPI for traffic bound to or from the specified destination address.
  ///
  /// If successful, this SPI is guaranteed available until released by a call to SecurityParameterIndex\#close().
  ///@param destinationAddress the destination address for traffic bearing the requested SPI.
  ///     For inbound traffic, the destination should be an address currently assigned on-device.
  /// This value must never be {@code null}.
  ///@param requestedSpi the requested SPI. The range 1-255 is reserved and may not be used. See
  ///     RFC 4303 Section 2.1.
  ///@return the reserved SecurityParameterIndex
  /// This value will never be {@code null}.
  ///@throws \#ResourceUnavailableException indicating that too many SPIs are
  ///     currently allocated for this user
  ///@throws \#SpiUnavailableException indicating that the requested SPI could not be
  ///     reserved
  IpSecManager_SecurityParameterIndex allocateSecurityParameterIndex1(
          jni.JniObject destinationAddress, int requestedSpi) =>
      IpSecManager_SecurityParameterIndex.fromRef(jniAccessors
          .callMethodWithArgs(
              reference,
              _id_allocateSecurityParameterIndex1,
              jni.JniType.objectType,
              [destinationAddress.reference, requestedSpi]).object);

  static final _id_applyTransportModeTransform = jniAccessors.getMethodIDOf(
      _classRef,
      "applyTransportModeTransform",
      "(Ljava/net/Socket;ILandroid/net/IpSecTransform;)V");

  /// from: public void applyTransportModeTransform(java.net.Socket socket, int direction, android.net.IpSecTransform transform)
  ///
  /// Apply an IPsec transform to a stream socket.
  ///
  /// This applies transport mode encapsulation to the given socket. Once applied, I/O on the
  /// socket will be encapsulated according to the parameters of the {@code IpSecTransform}. When
  /// the transform is removed from the socket by calling \#removeTransportModeTransforms,
  /// unprotected traffic can resume on that socket.
  ///
  /// For security reasons, the destination address of any traffic on the socket must match the
  /// remote {@code InetAddress} of the {@code IpSecTransform}. Attempts to send traffic to any
  /// other IP address will result in an IOException. In addition, reads and writes on the socket
  /// will throw IOException if the user deactivates the transform (by calling IpSecTransform\#close()) without calling \#removeTransportModeTransforms.
  ///
  /// Note that when applied to TCP sockets, calling IpSecTransform\#close() on an
  /// applied transform before completion of graceful shutdown may result in the shutdown sequence
  /// failing to complete. As such, applications requiring graceful shutdown MUST close the socket
  /// prior to deactivating the applied transform. Socket closure may be performed asynchronously
  /// (in batches), so the returning of a close function does not guarantee shutdown of a socket.
  /// Setting an SO_LINGER timeout results in socket closure being performed synchronously, and is
  /// sufficient to ensure shutdown.
  ///
  /// Specifically, if the transform is deactivated (by calling IpSecTransform\#close()),
  /// prior to the socket being closed, the standard [FIN - FIN/ACK - ACK], or the reset [RST]
  /// packets are dropped due to the lack of a valid Transform. Similarly, if a socket without the
  /// SO_LINGER option set is closed, the delayed/batched FIN packets may be dropped.
  ///
  /// <h4>Rekey Procedure</h4>
  ///
  /// When applying a new tranform to a socket in the outbound direction, the previous transform
  /// will be removed and the new transform will take effect immediately, sending all traffic on
  /// the new transform; however, when applying a transform in the inbound direction, traffic
  /// on the old transform will continue to be decrypted and delivered until that transform is
  /// deallocated by calling IpSecTransform\#close(). This overlap allows lossless rekey
  /// procedures where both transforms are valid until both endpoints are using the new transform
  /// and all in-flight packets have been received.
  ///@param socket a stream socket
  /// This value must never be {@code null}.
  ///@param direction the direction in which the transform should be applied
  /// Value is android.net.IpSecManager\#DIRECTION_IN, or android.net.IpSecManager\#DIRECTION_OUT
  ///@param transform a transport mode {@code IpSecTransform}
  /// This value must never be {@code null}.
  ///@throws IOException indicating that the transform could not be applied
  void applyTransportModeTransform(jni.JniObject socket, int direction,
          ipsectransform_.IpSecTransform transform) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_applyTransportModeTransform,
          jni.JniType.voidType,
          [socket.reference, direction, transform.reference]).check();

  static final _id_applyTransportModeTransform1 = jniAccessors.getMethodIDOf(
      _classRef,
      "applyTransportModeTransform",
      "(Ljava/net/DatagramSocket;ILandroid/net/IpSecTransform;)V");

  /// from: public void applyTransportModeTransform(java.net.DatagramSocket socket, int direction, android.net.IpSecTransform transform)
  ///
  /// Apply an IPsec transform to a datagram socket.
  ///
  /// This applies transport mode encapsulation to the given socket. Once applied, I/O on the
  /// socket will be encapsulated according to the parameters of the {@code IpSecTransform}. When
  /// the transform is removed from the socket by calling \#removeTransportModeTransforms,
  /// unprotected traffic can resume on that socket.
  ///
  /// For security reasons, the destination address of any traffic on the socket must match the
  /// remote {@code InetAddress} of the {@code IpSecTransform}. Attempts to send traffic to any
  /// other IP address will result in an IOException. In addition, reads and writes on the socket
  /// will throw IOException if the user deactivates the transform (by calling IpSecTransform\#close()) without calling \#removeTransportModeTransforms.
  ///
  /// <h4>Rekey Procedure</h4>
  ///
  /// When applying a new tranform to a socket in the outbound direction, the previous transform
  /// will be removed and the new transform will take effect immediately, sending all traffic on
  /// the new transform; however, when applying a transform in the inbound direction, traffic
  /// on the old transform will continue to be decrypted and delivered until that transform is
  /// deallocated by calling IpSecTransform\#close(). This overlap allows lossless rekey
  /// procedures where both transforms are valid until both endpoints are using the new transform
  /// and all in-flight packets have been received.
  ///@param socket a datagram socket
  /// This value must never be {@code null}.
  ///@param direction the direction in which the transform should be applied
  /// Value is android.net.IpSecManager\#DIRECTION_IN, or android.net.IpSecManager\#DIRECTION_OUT
  ///@param transform a transport mode {@code IpSecTransform}
  /// This value must never be {@code null}.
  ///@throws IOException indicating that the transform could not be applied
  void applyTransportModeTransform1(jni.JniObject socket, int direction,
          ipsectransform_.IpSecTransform transform) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_applyTransportModeTransform1,
          jni.JniType.voidType,
          [socket.reference, direction, transform.reference]).check();

  static final _id_applyTransportModeTransform2 = jniAccessors.getMethodIDOf(
      _classRef,
      "applyTransportModeTransform",
      "(Ljava/io/FileDescriptor;ILandroid/net/IpSecTransform;)V");

  /// from: public void applyTransportModeTransform(java.io.FileDescriptor socket, int direction, android.net.IpSecTransform transform)
  ///
  /// Apply an IPsec transform to a socket.
  ///
  /// This applies transport mode encapsulation to the given socket. Once applied, I/O on the
  /// socket will be encapsulated according to the parameters of the {@code IpSecTransform}. When
  /// the transform is removed from the socket by calling \#removeTransportModeTransforms,
  /// unprotected traffic can resume on that socket.
  ///
  /// For security reasons, the destination address of any traffic on the socket must match the
  /// remote {@code InetAddress} of the {@code IpSecTransform}. Attempts to send traffic to any
  /// other IP address will result in an IOException. In addition, reads and writes on the socket
  /// will throw IOException if the user deactivates the transform (by calling IpSecTransform\#close()) without calling \#removeTransportModeTransforms.
  ///
  /// Note that when applied to TCP sockets, calling IpSecTransform\#close() on an
  /// applied transform before completion of graceful shutdown may result in the shutdown sequence
  /// failing to complete. As such, applications requiring graceful shutdown MUST close the socket
  /// prior to deactivating the applied transform. Socket closure may be performed asynchronously
  /// (in batches), so the returning of a close function does not guarantee shutdown of a socket.
  /// Setting an SO_LINGER timeout results in socket closure being performed synchronously, and is
  /// sufficient to ensure shutdown.
  ///
  /// Specifically, if the transform is deactivated (by calling IpSecTransform\#close()),
  /// prior to the socket being closed, the standard [FIN - FIN/ACK - ACK], or the reset [RST]
  /// packets are dropped due to the lack of a valid Transform. Similarly, if a socket without the
  /// SO_LINGER option set is closed, the delayed/batched FIN packets may be dropped.
  ///
  /// <h4>Rekey Procedure</h4>
  ///
  /// When applying a new tranform to a socket in the outbound direction, the previous transform
  /// will be removed and the new transform will take effect immediately, sending all traffic on
  /// the new transform; however, when applying a transform in the inbound direction, traffic
  /// on the old transform will continue to be decrypted and delivered until that transform is
  /// deallocated by calling IpSecTransform\#close(). This overlap allows lossless rekey
  /// procedures where both transforms are valid until both endpoints are using the new transform
  /// and all in-flight packets have been received.
  ///@param socket a socket file descriptor
  /// This value must never be {@code null}.
  ///@param direction the direction in which the transform should be applied
  /// Value is android.net.IpSecManager\#DIRECTION_IN, or android.net.IpSecManager\#DIRECTION_OUT
  ///@param transform a transport mode {@code IpSecTransform}
  /// This value must never be {@code null}.
  ///@throws IOException indicating that the transform could not be applied
  void applyTransportModeTransform2(jni.JniObject socket, int direction,
          ipsectransform_.IpSecTransform transform) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_applyTransportModeTransform2,
          jni.JniType.voidType,
          [socket.reference, direction, transform.reference]).check();

  static final _id_removeTransportModeTransforms = jniAccessors.getMethodIDOf(
      _classRef, "removeTransportModeTransforms", "(Ljava/net/Socket;)V");

  /// from: public void removeTransportModeTransforms(java.net.Socket socket)
  ///
  /// Remove an IPsec transform from a stream socket.
  ///
  /// Once removed, traffic on the socket will not be encrypted. Removing transforms from a
  /// socket allows the socket to be reused for communication in the clear.
  ///
  /// If an {@code IpSecTransform} object applied to this socket was deallocated by calling
  /// IpSecTransform\#close(), then communication on the socket will fail until this method
  /// is called.
  ///@param socket a socket that previously had a transform applied to it
  /// This value must never be {@code null}.
  ///@throws IOException indicating that the transform could not be removed from the socket
  void removeTransportModeTransforms(jni.JniObject socket) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeTransportModeTransforms,
          jni.JniType.voidType,
          [socket.reference]).check();

  static final _id_removeTransportModeTransforms1 = jniAccessors.getMethodIDOf(
      _classRef,
      "removeTransportModeTransforms",
      "(Ljava/net/DatagramSocket;)V");

  /// from: public void removeTransportModeTransforms(java.net.DatagramSocket socket)
  ///
  /// Remove an IPsec transform from a datagram socket.
  ///
  /// Once removed, traffic on the socket will not be encrypted. Removing transforms from a
  /// socket allows the socket to be reused for communication in the clear.
  ///
  /// If an {@code IpSecTransform} object applied to this socket was deallocated by calling
  /// IpSecTransform\#close(), then communication on the socket will fail until this method
  /// is called.
  ///@param socket a socket that previously had a transform applied to it
  /// This value must never be {@code null}.
  ///@throws IOException indicating that the transform could not be removed from the socket
  void removeTransportModeTransforms1(jni.JniObject socket) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeTransportModeTransforms1,
          jni.JniType.voidType,
          [socket.reference]).check();

  static final _id_removeTransportModeTransforms2 = jniAccessors.getMethodIDOf(
      _classRef,
      "removeTransportModeTransforms",
      "(Ljava/io/FileDescriptor;)V");

  /// from: public void removeTransportModeTransforms(java.io.FileDescriptor socket)
  ///
  /// Remove an IPsec transform from a socket.
  ///
  /// Once removed, traffic on the socket will not be encrypted. Removing transforms from a
  /// socket allows the socket to be reused for communication in the clear.
  ///
  /// If an {@code IpSecTransform} object applied to this socket was deallocated by calling
  /// IpSecTransform\#close(), then communication on the socket will fail until this method
  /// is called.
  ///@param socket a socket that previously had a transform applied to it
  /// This value must never be {@code null}.
  ///@throws IOException indicating that the transform could not be removed from the socket
  void removeTransportModeTransforms2(jni.JniObject socket) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeTransportModeTransforms2,
          jni.JniType.voidType,
          [socket.reference]).check();

  static final _id_openUdpEncapsulationSocket = jniAccessors.getMethodIDOf(
      _classRef,
      "openUdpEncapsulationSocket",
      "(I)Landroid/net/IpSecManager\$UdpEncapsulationSocket;");

  /// from: public android.net.IpSecManager.UdpEncapsulationSocket openUdpEncapsulationSocket(int port)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a socket for UDP encapsulation and bind to the given port.
  ///
  /// See UdpEncapsulationSocket for the proper way to close the returned socket.
  ///@param port a local UDP port
  ///@return a socket that is bound to the given port
  /// This value will never be {@code null}.
  ///@throws IOException indicating that the socket could not be opened or bound
  ///@throws ResourceUnavailableException indicating that too many encapsulation sockets are open
  IpSecManager_UdpEncapsulationSocket openUdpEncapsulationSocket(int port) =>
      IpSecManager_UdpEncapsulationSocket.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openUdpEncapsulationSocket,
              jni.JniType.objectType, [port]).object);

  static final _id_openUdpEncapsulationSocket1 = jniAccessors.getMethodIDOf(
      _classRef,
      "openUdpEncapsulationSocket",
      "()Landroid/net/IpSecManager\$UdpEncapsulationSocket;");

  /// from: public android.net.IpSecManager.UdpEncapsulationSocket openUdpEncapsulationSocket()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a socket for UDP encapsulation.
  ///
  /// See UdpEncapsulationSocket for the proper way to close the returned socket.
  ///
  /// The local port of the returned socket can be obtained by calling UdpEncapsulationSocket\#getPort().
  ///@return a socket that is bound to a local port
  /// This value will never be {@code null}.
  ///@throws IOException indicating that the socket could not be opened or bound
  ///@throws ResourceUnavailableException indicating that too many encapsulation sockets are open
  IpSecManager_UdpEncapsulationSocket openUdpEncapsulationSocket1() =>
      IpSecManager_UdpEncapsulationSocket.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_openUdpEncapsulationSocket1,
              jni.JniType.objectType, []).object);
}

/// from: android.net.IpSecManager$UdpEncapsulationSocket
///
/// This class provides access to a UDP encapsulation Socket.
///
/// {@code UdpEncapsulationSocket} wraps a system-provided datagram socket intended for IKEv2
/// signalling and UDP encapsulated IPsec traffic. Instances can be obtained by calling IpSecManager\#openUdpEncapsulationSocket. The provided socket cannot be re-bound by the
/// caller. The caller should not close the {@code FileDescriptor} returned by \#getFileDescriptor, but should use \#close instead.
///
/// Allowing the user to close or unbind a UDP encapsulation socket could impact the traffic
/// of the next user who binds to that port. To prevent this scenario, these sockets are held
/// open by the system so that they may only be closed by calling \#close or when the user
/// process exits.
class IpSecManager_UdpEncapsulationSocket extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/net/IpSecManager\$UdpEncapsulationSocket");
  IpSecManager_UdpEncapsulationSocket.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  IpSecManager_UdpEncapsulationSocket()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getFileDescriptor = jniAccessors.getMethodIDOf(
      _classRef, "getFileDescriptor", "()Ljava/io/FileDescriptor;");

  /// from: public java.io.FileDescriptor getFileDescriptor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the encapsulation socket's file descriptor.
  jni.JniObject getFileDescriptor() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFileDescriptor, jni.JniType.objectType, []).object);

  static final _id_getPort =
      jniAccessors.getMethodIDOf(_classRef, "getPort", "()I");

  /// from: public int getPort()
  ///
  /// Get the bound port of the wrapped socket.
  int getPort() => jniAccessors.callMethodWithArgs(
      reference, _id_getPort, jni.JniType.intType, []).integer;

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Close this socket.
  ///
  /// This closes the wrapped socket. Open encapsulation sockets count against a user's
  /// resource limits, and forgetting to close them eventually will result in ResourceUnavailableException being thrown.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  ///
  /// Check that the socket was closed properly.
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.net.IpSecManager$SpiUnavailableException
///
/// Thrown to indicate that a requested SPI is in use.
///
/// The combination of remote {@code InetAddress} and SPI must be unique across all apps on
/// one device. If this error is encountered, a new SPI is required before a transform may be
/// created. This error can be avoided by calling IpSecManager\#allocateSecurityParameterIndex.
class IpSecManager_SpiUnavailableException
    extends androidexception_.AndroidException {
  static final _classRef = jniAccessors
      .getClassOf("android/net/IpSecManager\$SpiUnavailableException");
  IpSecManager_SpiUnavailableException.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor4 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;I)V");

  /// from: void <init>(java.lang.String msg, int spi)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct an exception indicating that a transform with the given SPI is already in use
  /// or otherwise unavailable.
  ///@param msg description indicating the colliding SPI
  ///@param spi the SPI that could not be used due to a collision
  IpSecManager_SpiUnavailableException.ctor4(jni.JniString msg, int spi)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor4, [msg.reference, spi]).object);

  static final _id_getSpi =
      jniAccessors.getMethodIDOf(_classRef, "getSpi", "()I");

  /// from: public int getSpi()
  ///
  /// Get the SPI that caused a collision.
  int getSpi() => jniAccessors.callMethodWithArgs(
      reference, _id_getSpi, jni.JniType.intType, []).integer;
}

/// from: android.net.IpSecManager$SecurityParameterIndex
///
/// This class represents a reserved SPI.
///
/// Objects of this type are used to track reserved security parameter indices. They can be
/// obtained by calling IpSecManager\#allocateSecurityParameterIndex and must be released
/// by calling \#close() when they are no longer needed.
class IpSecManager_SecurityParameterIndex extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/net/IpSecManager\$SecurityParameterIndex");
  IpSecManager_SecurityParameterIndex.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  IpSecManager_SecurityParameterIndex()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getSpi =
      jniAccessors.getMethodIDOf(_classRef, "getSpi", "()I");

  /// from: public int getSpi()
  ///
  /// Get the underlying SPI held by this object.
  int getSpi() => jniAccessors.callMethodWithArgs(
      reference, _id_getSpi, jni.JniType.intType, []).integer;

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Release an SPI that was previously reserved.
  ///
  /// Release an SPI for use by other users in the system. If a SecurityParameterIndex is
  /// applied to an IpSecTransform, it will become unusable for future transforms but should
  /// still be closed to ensure system resources are released.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  ///
  /// Check that the SPI was closed properly.
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.net.IpSecManager$ResourceUnavailableException
///
/// Thrown to indicate that an IPsec resource is unavailable.
///
/// This could apply to resources such as sockets, SecurityParameterIndex, IpSecTransform, or other system resources. If this exception is thrown, users should release
/// allocated objects of the type requested.
class IpSecManager_ResourceUnavailableException
    extends androidexception_.AndroidException {
  static final _classRef = jniAccessors
      .getClassOf("android/net/IpSecManager\$ResourceUnavailableException");
  IpSecManager_ResourceUnavailableException.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: void <init>(java.lang.String msg)
  /// The returned object must be deleted after use, by calling the `delete` method.
  IpSecManager_ResourceUnavailableException.ctor1(jni.JniString msg)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [msg.reference]).object);
}
