// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../content/Context.dart" as context_;

import "SipProfile.dart" as sipprofile_;

import "SipSession.dart" as sipsession_;

import "../../os/Message.dart" as message_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.sip.SipAudioCall
///
/// Handles an Internet audio call over SIP. You can instantiate this class with SipManager,
/// using SipManager\#makeAudioCall makeAudioCall() and  SipManager\#takeAudioCall takeAudioCall().
///
/// <p class="note"><strong>Note:</strong> Using this class require the
///   android.Manifest.permission\#INTERNET and
///   android.Manifest.permission\#USE_SIP permissions. In addition, \#startAudio requires the
///   android.Manifest.permission\#RECORD_AUDIO,
///   android.Manifest.permission\#ACCESS_WIFI_STATE, and
///   android.Manifest.permission\#WAKE_LOCK permissions; and \#setSpeakerMode setSpeakerMode() requires the
///   android.Manifest.permission\#MODIFY_AUDIO_SETTINGS permission.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using SIP, read the
/// <a href="{@docRoot}guide/topics/network/sip.html">Session Initiation Protocol</a>
/// developer guide.
///
/// </div>
class SipAudioCall extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/sip/SipAudioCall");
  SipAudioCall.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/net/sip/SipProfile;)V");

  /// from: public void <init>(android.content.Context context, android.net.sip.SipProfile localProfile)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a call object with the local SIP profile.
  ///@param context the context for accessing system services such as
  ///        ringtone, audio, WIFI etc
  SipAudioCall(context_.Context context, sipprofile_.SipProfile localProfile)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [context.reference, localProfile.reference]).object);

  static final _id_setListener = jniAccessors.getMethodIDOf(
      _classRef, "setListener", "(Landroid/net/sip/SipAudioCall\$Listener;)V");

  /// from: public void setListener(android.net.sip.SipAudioCall.Listener listener)
  ///
  /// Sets the listener to listen to the audio call events. The method calls
  /// \#setListener setListener(listener, false).
  ///@param listener to listen to the audio call events of this object
  ///@see \#setListener(Listener, boolean)
  void setListener(SipAudioCall_Listener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setListener1 = jniAccessors.getMethodIDOf(
      _classRef, "setListener", "(Landroid/net/sip/SipAudioCall\$Listener;Z)V");

  /// from: public void setListener(android.net.sip.SipAudioCall.Listener listener, boolean callbackImmediately)
  ///
  /// Sets the listener to listen to the audio call events. A
  /// SipAudioCall can only hold one listener at a time. Subsequent
  /// calls to this method override the previous listener.
  ///@param listener to listen to the audio call events of this object
  ///@param callbackImmediately set to true if the caller wants to be called
  ///      back immediately on the current state
  void setListener1(SipAudioCall_Listener listener, bool callbackImmediately) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setListener1,
          jni.JniType.voidType,
          [listener.reference, callbackImmediately]).check();

  static final _id_isInCall =
      jniAccessors.getMethodIDOf(_classRef, "isInCall", "()Z");

  /// from: public boolean isInCall()
  ///
  /// Checks if the call is established.
  ///@return true if the call is established
  bool isInCall() => jniAccessors.callMethodWithArgs(
      reference, _id_isInCall, jni.JniType.booleanType, []).boolean;

  static final _id_isOnHold =
      jniAccessors.getMethodIDOf(_classRef, "isOnHold", "()Z");

  /// from: public boolean isOnHold()
  ///
  /// Checks if the call is on hold.
  ///@return true if the call is on hold
  bool isOnHold() => jniAccessors.callMethodWithArgs(
      reference, _id_isOnHold, jni.JniType.booleanType, []).boolean;

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Closes this object. This object is not usable after being closed.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_getLocalProfile = jniAccessors.getMethodIDOf(
      _classRef, "getLocalProfile", "()Landroid/net/sip/SipProfile;");

  /// from: public android.net.sip.SipProfile getLocalProfile()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the local SIP profile.
  ///@return the local SIP profile
  sipprofile_.SipProfile getLocalProfile() =>
      sipprofile_.SipProfile.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLocalProfile, jni.JniType.objectType, []).object);

  static final _id_getPeerProfile = jniAccessors.getMethodIDOf(
      _classRef, "getPeerProfile", "()Landroid/net/sip/SipProfile;");

  /// from: public android.net.sip.SipProfile getPeerProfile()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the peer's SIP profile.
  ///@return the peer's SIP profile
  sipprofile_.SipProfile getPeerProfile() =>
      sipprofile_.SipProfile.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPeerProfile, jni.JniType.objectType, []).object);

  static final _id_getState =
      jniAccessors.getMethodIDOf(_classRef, "getState", "()I");

  /// from: public int getState()
  ///
  /// Gets the state of the SipSession that carries this call.
  /// The value returned must be one of the states in SipSession.State.
  ///@return the session state
  int getState() => jniAccessors.callMethodWithArgs(
      reference, _id_getState, jni.JniType.intType, []).integer;

  static final _id_attachCall = jniAccessors.getMethodIDOf(_classRef,
      "attachCall", "(Landroid/net/sip/SipSession;Ljava/lang/String;)V");

  /// from: public void attachCall(android.net.sip.SipSession session, java.lang.String sessionDescription)
  ///
  /// Attaches an incoming call to this call object.
  ///@param session the session that receives the incoming call
  ///@param sessionDescription the session description of the incoming call
  ///@throws SipException if the SIP service fails to attach this object to
  ///        the session or VOIP API is not supported by the device
  ///@see SipManager\#isVoipSupported
  void attachCall(
          sipsession_.SipSession session, jni.JniString sessionDescription) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_attachCall,
          jni.JniType.voidType,
          [session.reference, sessionDescription.reference]).check();

  static final _id_makeCall = jniAccessors.getMethodIDOf(_classRef, "makeCall",
      "(Landroid/net/sip/SipProfile;Landroid/net/sip/SipSession;I)V");

  /// from: public void makeCall(android.net.sip.SipProfile peerProfile, android.net.sip.SipSession sipSession, int timeout)
  ///
  /// Initiates an audio call to the specified profile. The attempt will be
  /// timed out if the call is not established within {@code timeout} seconds
  /// and Listener\#onError onError(SipAudioCall, SipErrorCode.TIME_OUT, String)
  /// will be called.
  ///@param peerProfile the SIP profile to make the call to
  ///@param sipSession the SipSession for carrying out the call
  ///@param timeout the timeout value in seconds. Default value (defined by
  ///        SIP protocol) is used if {@code timeout} is zero or negative.
  ///@see Listener\#onError
  ///@throws SipException if the SIP service fails to create a session for the
  ///        call or VOIP API is not supported by the device
  ///@see SipManager\#isVoipSupported
  void makeCall(sipprofile_.SipProfile peerProfile,
          sipsession_.SipSession sipSession, int timeout) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_makeCall,
          jni.JniType.voidType,
          [peerProfile.reference, sipSession.reference, timeout]).check();

  static final _id_endCall =
      jniAccessors.getMethodIDOf(_classRef, "endCall", "()V");

  /// from: public void endCall()
  ///
  /// Ends a call.
  ///@throws SipException if the SIP service fails to end the call
  void endCall() => jniAccessors.callMethodWithArgs(
      reference, _id_endCall, jni.JniType.voidType, []).check();

  static final _id_holdCall =
      jniAccessors.getMethodIDOf(_classRef, "holdCall", "(I)V");

  /// from: public void holdCall(int timeout)
  ///
  /// Puts a call on hold.  When succeeds, Listener\#onCallHeld is
  /// called. The attempt will be timed out if the call is not established
  /// within {@code timeout} seconds and
  /// Listener\#onError onError(SipAudioCall, SipErrorCode.TIME_OUT, String)
  /// will be called.
  ///@param timeout the timeout value in seconds. Default value (defined by
  ///        SIP protocol) is used if {@code timeout} is zero or negative.
  ///@see Listener\#onError
  ///@throws SipException if the SIP service fails to hold the call
  void holdCall(int timeout) => jniAccessors.callMethodWithArgs(
      reference, _id_holdCall, jni.JniType.voidType, [timeout]).check();

  static final _id_answerCall =
      jniAccessors.getMethodIDOf(_classRef, "answerCall", "(I)V");

  /// from: public void answerCall(int timeout)
  ///
  /// Answers a call. The attempt will be timed out if the call is not
  /// established within {@code timeout} seconds and
  /// Listener\#onError onError(SipAudioCall, SipErrorCode.TIME_OUT, String)
  /// will be called.
  ///@param timeout the timeout value in seconds. Default value (defined by
  ///        SIP protocol) is used if {@code timeout} is zero or negative.
  ///@see Listener\#onError
  ///@throws SipException if the SIP service fails to answer the call
  void answerCall(int timeout) => jniAccessors.callMethodWithArgs(
      reference, _id_answerCall, jni.JniType.voidType, [timeout]).check();

  static final _id_continueCall =
      jniAccessors.getMethodIDOf(_classRef, "continueCall", "(I)V");

  /// from: public void continueCall(int timeout)
  ///
  /// Continues a call that's on hold. When succeeds,
  /// Listener\#onCallEstablished is called. The attempt will be timed
  /// out if the call is not established within {@code timeout} seconds and
  /// Listener\#onError onError(SipAudioCall, SipErrorCode.TIME_OUT, String)
  /// will be called.
  ///@param timeout the timeout value in seconds. Default value (defined by
  ///        SIP protocol) is used if {@code timeout} is zero or negative.
  ///@see Listener\#onError
  ///@throws SipException if the SIP service fails to unhold the call
  void continueCall(int timeout) => jniAccessors.callMethodWithArgs(
      reference, _id_continueCall, jni.JniType.voidType, [timeout]).check();

  static final _id_toggleMute =
      jniAccessors.getMethodIDOf(_classRef, "toggleMute", "()V");

  /// from: public void toggleMute()
  ///
  /// Toggles mute.
  void toggleMute() => jniAccessors.callMethodWithArgs(
      reference, _id_toggleMute, jni.JniType.voidType, []).check();

  static final _id_isMuted =
      jniAccessors.getMethodIDOf(_classRef, "isMuted", "()Z");

  /// from: public boolean isMuted()
  ///
  /// Checks if the call is muted.
  ///@return true if the call is muted
  bool isMuted() => jniAccessors.callMethodWithArgs(
      reference, _id_isMuted, jni.JniType.booleanType, []).boolean;

  static final _id_setSpeakerMode =
      jniAccessors.getMethodIDOf(_classRef, "setSpeakerMode", "(Z)V");

  /// from: public void setSpeakerMode(boolean speakerMode)
  ///
  /// Puts the device to speaker mode.
  /// <p class="note"><strong>Note:</strong> Requires the
  ///   android.Manifest.permission\#MODIFY_AUDIO_SETTINGS permission.
  ///
  ///@param speakerMode set true to enable speaker mode; false to disable
  void setSpeakerMode(bool speakerMode) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSpeakerMode,
      jni.JniType.voidType,
      [speakerMode]).check();

  static final _id_sendDtmf =
      jniAccessors.getMethodIDOf(_classRef, "sendDtmf", "(I)V");

  /// from: public void sendDtmf(int code)
  ///
  /// Sends a DTMF code. According to <a href="http://tools.ietf.org/html/rfc2833">RFC 2883</a>,
  /// event 0--9 maps to decimal
  /// value 0--9, '*' to 10, '\#' to 11, event 'A'--'D' to 12--15, and event
  /// flash to 16. Currently, event flash is not supported.
  ///@param code the DTMF code to send. Value 0 to 15 (inclusive) are valid
  ///        inputs.
  void sendDtmf(int code) => jniAccessors.callMethodWithArgs(
      reference, _id_sendDtmf, jni.JniType.voidType, [code]).check();

  static final _id_sendDtmf1 = jniAccessors.getMethodIDOf(
      _classRef, "sendDtmf", "(ILandroid/os/Message;)V");

  /// from: public void sendDtmf(int code, android.os.Message result)
  ///
  /// Sends a DTMF code. According to <a href="http://tools.ietf.org/html/rfc2833">RFC 2883</a>,
  /// event 0--9 maps to decimal
  /// value 0--9, '*' to 10, '\#' to 11, event 'A'--'D' to 12--15, and event
  /// flash to 16. Currently, event flash is not supported.
  ///@param code the DTMF code to send. Value 0 to 15 (inclusive) are valid
  ///        inputs.
  ///@param result the result message to send when done
  void sendDtmf1(int code, message_.Message result) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendDtmf1,
          jni.JniType.voidType, [code, result.reference]).check();

  static final _id_startAudio =
      jniAccessors.getMethodIDOf(_classRef, "startAudio", "()V");

  /// from: public void startAudio()
  ///
  /// Starts the audio for the established call. This method should be called
  /// after Listener\#onCallEstablished is called.
  /// <p class="note"><strong>Note:</strong> Requires the
  ///   android.Manifest.permission\#RECORD_AUDIO,
  ///   android.Manifest.permission\#ACCESS_WIFI_STATE and
  ///   android.Manifest.permission\#WAKE_LOCK permissions.
  ///
  void startAudio() => jniAccessors.callMethodWithArgs(
      reference, _id_startAudio, jni.JniType.voidType, []).check();
}

/// from: android.net.sip.SipAudioCall$Listener
///
/// Listener for events relating to a SIP call, such as when a call is being
/// recieved ("on ringing") or a call is outgoing ("on calling").
/// Many of these events are also received by SipSession.Listener.
///
class SipAudioCall_Listener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/sip/SipAudioCall\$Listener");
  SipAudioCall_Listener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  SipAudioCall_Listener()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onReadyToCall = jniAccessors.getMethodIDOf(
      _classRef, "onReadyToCall", "(Landroid/net/sip/SipAudioCall;)V");

  /// from: public void onReadyToCall(android.net.sip.SipAudioCall call)
  ///
  /// Called when the call object is ready to make another call.
  /// The default implementation calls \#onChanged.
  ///@param call the call object that is ready to make another call
  void onReadyToCall(SipAudioCall call) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onReadyToCall,
      jni.JniType.voidType,
      [call.reference]).check();

  static final _id_onCalling = jniAccessors.getMethodIDOf(
      _classRef, "onCalling", "(Landroid/net/sip/SipAudioCall;)V");

  /// from: public void onCalling(android.net.sip.SipAudioCall call)
  ///
  /// Called when a request is sent out to initiate a new call.
  /// The default implementation calls \#onChanged.
  ///@param call the call object that carries out the audio call
  void onCalling(SipAudioCall call) => jniAccessors.callMethodWithArgs(
      reference, _id_onCalling, jni.JniType.voidType, [call.reference]).check();

  static final _id_onRinging = jniAccessors.getMethodIDOf(
      _classRef,
      "onRinging",
      "(Landroid/net/sip/SipAudioCall;Landroid/net/sip/SipProfile;)V");

  /// from: public void onRinging(android.net.sip.SipAudioCall call, android.net.sip.SipProfile caller)
  ///
  /// Called when a new call comes in.
  /// The default implementation calls \#onChanged.
  ///@param call the call object that carries out the audio call
  ///@param caller the SIP profile of the caller
  void onRinging(SipAudioCall call, sipprofile_.SipProfile caller) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRinging,
          jni.JniType.voidType, [call.reference, caller.reference]).check();

  static final _id_onRingingBack = jniAccessors.getMethodIDOf(
      _classRef, "onRingingBack", "(Landroid/net/sip/SipAudioCall;)V");

  /// from: public void onRingingBack(android.net.sip.SipAudioCall call)
  ///
  /// Called when a RINGING response is received for the INVITE request
  /// sent. The default implementation calls \#onChanged.
  ///@param call the call object that carries out the audio call
  void onRingingBack(SipAudioCall call) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onRingingBack,
      jni.JniType.voidType,
      [call.reference]).check();

  static final _id_onCallEstablished = jniAccessors.getMethodIDOf(
      _classRef, "onCallEstablished", "(Landroid/net/sip/SipAudioCall;)V");

  /// from: public void onCallEstablished(android.net.sip.SipAudioCall call)
  ///
  /// Called when the session is established.
  /// The default implementation calls \#onChanged.
  ///@param call the call object that carries out the audio call
  void onCallEstablished(SipAudioCall call) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onCallEstablished,
      jni.JniType.voidType,
      [call.reference]).check();

  static final _id_onCallEnded = jniAccessors.getMethodIDOf(
      _classRef, "onCallEnded", "(Landroid/net/sip/SipAudioCall;)V");

  /// from: public void onCallEnded(android.net.sip.SipAudioCall call)
  ///
  /// Called when the session is terminated.
  /// The default implementation calls \#onChanged.
  ///@param call the call object that carries out the audio call
  void onCallEnded(SipAudioCall call) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onCallEnded,
      jni.JniType.voidType,
      [call.reference]).check();

  static final _id_onCallBusy = jniAccessors.getMethodIDOf(
      _classRef, "onCallBusy", "(Landroid/net/sip/SipAudioCall;)V");

  /// from: public void onCallBusy(android.net.sip.SipAudioCall call)
  ///
  /// Called when the peer is busy during session initialization.
  /// The default implementation calls \#onChanged.
  ///@param call the call object that carries out the audio call
  void onCallBusy(SipAudioCall call) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onCallBusy,
      jni.JniType.voidType,
      [call.reference]).check();

  static final _id_onCallHeld = jniAccessors.getMethodIDOf(
      _classRef, "onCallHeld", "(Landroid/net/sip/SipAudioCall;)V");

  /// from: public void onCallHeld(android.net.sip.SipAudioCall call)
  ///
  /// Called when the call is on hold.
  /// The default implementation calls \#onChanged.
  ///@param call the call object that carries out the audio call
  void onCallHeld(SipAudioCall call) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onCallHeld,
      jni.JniType.voidType,
      [call.reference]).check();

  static final _id_onError = jniAccessors.getMethodIDOf(_classRef, "onError",
      "(Landroid/net/sip/SipAudioCall;ILjava/lang/String;)V");

  /// from: public void onError(android.net.sip.SipAudioCall call, int errorCode, java.lang.String errorMessage)
  ///
  /// Called when an error occurs. The default implementation is no op.
  ///@param call the call object that carries out the audio call
  ///@param errorCode error code of this error
  ///@param errorMessage error message
  ///@see SipErrorCode
  void onError(SipAudioCall call, int errorCode, jni.JniString errorMessage) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onError,
          jni.JniType.voidType,
          [call.reference, errorCode, errorMessage.reference]).check();

  static final _id_onChanged = jniAccessors.getMethodIDOf(
      _classRef, "onChanged", "(Landroid/net/sip/SipAudioCall;)V");

  /// from: public void onChanged(android.net.sip.SipAudioCall call)
  ///
  /// Called when an event occurs and the corresponding callback is not
  /// overridden. The default implementation is no op. Error events are
  /// not re-directed to this callback and are handled in \#onError.
  void onChanged(SipAudioCall call) => jniAccessors.callMethodWithArgs(
      reference, _id_onChanged, jni.JniType.voidType, [call.reference]).check();
}
