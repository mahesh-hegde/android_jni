// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "PublishDiscoverySession.dart" as publishdiscoverysession_;

import "SubscribeDiscoverySession.dart" as subscribediscoverysession_;

import "PeerHandle.dart" as peerhandle_;
import "../../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.wifi.aware.DiscoverySessionCallback
///
/// Base class for Aware session events callbacks. Should be extended by
/// applications wanting notifications. The callbacks are set when a
/// publish or subscribe session is created using
/// WifiAwareSession\#publish(PublishConfig, DiscoverySessionCallback,
/// android.os.Handler) or
/// WifiAwareSession\#subscribe(SubscribeConfig, DiscoverySessionCallback,
/// android.os.Handler).
///
/// A single callback is set at session creation - it cannot be replaced.
class DiscoverySessionCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/net/wifi/aware/DiscoverySessionCallback");
  DiscoverySessionCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  DiscoverySessionCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onPublishStarted = jniAccessors.getMethodIDOf(
      _classRef,
      "onPublishStarted",
      "(Landroid/net/wifi/aware/PublishDiscoverySession;)V");

  /// from: public void onPublishStarted(android.net.wifi.aware.PublishDiscoverySession session)
  ///
  /// Called when a publish operation is started successfully in response to a
  /// WifiAwareSession\#publish(PublishConfig, DiscoverySessionCallback,
  /// android.os.Handler) operation.
  ///@param session The PublishDiscoverySession used to control the
  ///            discovery session.
  ///
  /// This value must never be {@code null}.
  void onPublishStarted(
          publishdiscoverysession_.PublishDiscoverySession session) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPublishStarted,
          jni.JniType.voidType, [session.reference]).check();

  static final _id_onSubscribeStarted = jniAccessors.getMethodIDOf(
      _classRef,
      "onSubscribeStarted",
      "(Landroid/net/wifi/aware/SubscribeDiscoverySession;)V");

  /// from: public void onSubscribeStarted(android.net.wifi.aware.SubscribeDiscoverySession session)
  ///
  /// Called when a subscribe operation is started successfully in response to a
  /// WifiAwareSession\#subscribe(SubscribeConfig, DiscoverySessionCallback,
  /// android.os.Handler) operation.
  ///@param session The SubscribeDiscoverySession used to control the
  ///            discovery session.
  ///
  /// This value must never be {@code null}.
  void onSubscribeStarted(
          subscribediscoverysession_.SubscribeDiscoverySession session) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSubscribeStarted,
          jni.JniType.voidType, [session.reference]).check();

  static final _id_onSessionConfigUpdated =
      jniAccessors.getMethodIDOf(_classRef, "onSessionConfigUpdated", "()V");

  /// from: public void onSessionConfigUpdated()
  ///
  /// Called when a publish or subscribe discovery session configuration update request
  /// succeeds. Called in response to
  /// PublishDiscoverySession\#updatePublish(PublishConfig) or
  /// SubscribeDiscoverySession\#updateSubscribe(SubscribeConfig).
  void onSessionConfigUpdated() => jniAccessors.callMethodWithArgs(
      reference, _id_onSessionConfigUpdated, jni.JniType.voidType, []).check();

  static final _id_onSessionConfigFailed =
      jniAccessors.getMethodIDOf(_classRef, "onSessionConfigFailed", "()V");

  /// from: public void onSessionConfigFailed()
  ///
  /// Called when a publish or subscribe discovery session cannot be created:
  /// WifiAwareSession\#publish(PublishConfig, DiscoverySessionCallback,
  /// android.os.Handler) or
  /// WifiAwareSession\#subscribe(SubscribeConfig, DiscoverySessionCallback,
  /// android.os.Handler), or when a configuration update fails:
  /// PublishDiscoverySession\#updatePublish(PublishConfig) or
  /// SubscribeDiscoverySession\#updateSubscribe(SubscribeConfig).
  ///
  ///     For discovery session updates failure leaves the session running with its previous
  ///     configuration - the discovery session is not terminated.
  void onSessionConfigFailed() => jniAccessors.callMethodWithArgs(
      reference, _id_onSessionConfigFailed, jni.JniType.voidType, []).check();

  static final _id_onSessionTerminated =
      jniAccessors.getMethodIDOf(_classRef, "onSessionTerminated", "()V");

  /// from: public void onSessionTerminated()
  ///
  /// Called when a discovery session (publish or subscribe) terminates. Termination may be due
  /// to user-request (either directly through DiscoverySession\#close() or
  /// application-specified expiration, e.g. PublishConfig.Builder\#setTtlSec(int)
  /// or SubscribeConfig.Builder\#setTtlSec(int)).
  void onSessionTerminated() => jniAccessors.callMethodWithArgs(
      reference, _id_onSessionTerminated, jni.JniType.voidType, []).check();

  static final _id_onServiceDiscovered = jniAccessors.getMethodIDOf(
      _classRef,
      "onServiceDiscovered",
      "(Landroid/net/wifi/aware/PeerHandle;[BLjava/util/List;)V");

  /// from: public void onServiceDiscovered(android.net.wifi.aware.PeerHandle peerHandle, byte[] serviceSpecificInfo, java.util.List<byte[]> matchFilter)
  ///
  /// Called when a discovery (publish or subscribe) operation results in a
  /// service discovery.
  ///
  /// Note that this method and
  /// \#onServiceDiscoveredWithinRange(PeerHandle, byte[], List, int) may be called
  /// multiple times per service discovery.
  ///@param peerHandle An opaque handle to the peer matching our discovery operation.
  ///@param serviceSpecificInfo The service specific information (arbitrary
  ///            byte array) provided by the peer as part of its discovery
  ///            configuration.
  ///@param matchFilter The filter which resulted in this service discovery. For
  /// PublishConfig\#PUBLISH_TYPE_UNSOLICITED,
  /// SubscribeConfig\#SUBSCRIBE_TYPE_PASSIVE discovery sessions this is the publisher's
  ///                    match filter. For PublishConfig\#PUBLISH_TYPE_SOLICITED,
  ///                    SubscribeConfig\#SUBSCRIBE_TYPE_ACTIVE discovery sessions this
  ///                    is the subscriber's match filter.
  void onServiceDiscovered(peerhandle_.PeerHandle peerHandle,
          jni.JniObject serviceSpecificInfo, jni.JniObject matchFilter) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onServiceDiscovered, jni.JniType.voidType, [
        peerHandle.reference,
        serviceSpecificInfo.reference,
        matchFilter.reference
      ]).check();

  static final _id_onServiceDiscoveredWithinRange = jniAccessors.getMethodIDOf(
      _classRef,
      "onServiceDiscoveredWithinRange",
      "(Landroid/net/wifi/aware/PeerHandle;[BLjava/util/List;I)V");

  /// from: public void onServiceDiscoveredWithinRange(android.net.wifi.aware.PeerHandle peerHandle, byte[] serviceSpecificInfo, java.util.List<byte[]> matchFilter, int distanceMm)
  ///
  /// Called when a discovery (publish or subscribe) operation results in a
  /// service discovery. Called when a Subscribe service was configured with a range requirement
  /// SubscribeConfig.Builder\#setMinDistanceMm(int) and/or
  /// SubscribeConfig.Builder\#setMaxDistanceMm(int) and the Publish service was configured
  /// with PublishConfig.Builder\#setRangingEnabled(boolean).
  ///
  /// If either Publisher or Subscriber does not enable Ranging, or if Ranging is temporarily
  /// disabled by the underlying device, service discovery proceeds without ranging and the
  /// \#onServiceDiscovered(PeerHandle, byte[], List) is called.
  ///
  /// Note that this method and \#onServiceDiscovered(PeerHandle, byte[], List) may be
  /// called multiple times per service discovery.
  ///@param peerHandle An opaque handle to the peer matching our discovery operation.
  ///@param serviceSpecificInfo The service specific information (arbitrary
  ///            byte array) provided by the peer as part of its discovery
  ///            configuration.
  ///@param matchFilter The filter which resulted in this service discovery. For
  /// PublishConfig\#PUBLISH_TYPE_UNSOLICITED,
  /// SubscribeConfig\#SUBSCRIBE_TYPE_PASSIVE discovery sessions this is the publisher's
  ///                    match filter. For PublishConfig\#PUBLISH_TYPE_SOLICITED,
  ///                    SubscribeConfig\#SUBSCRIBE_TYPE_ACTIVE discovery sessions this
  ///                    is the subscriber's match filter.
  ///@param distanceMm The measured distance to the Publisher in mm. Note: the measured distance
  ///                   may be negative for very close devices.
  void onServiceDiscoveredWithinRange(
          peerhandle_.PeerHandle peerHandle,
          jni.JniObject serviceSpecificInfo,
          jni.JniObject matchFilter,
          int distanceMm) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onServiceDiscoveredWithinRange, jni.JniType.voidType, [
        peerHandle.reference,
        serviceSpecificInfo.reference,
        matchFilter.reference,
        distanceMm
      ]).check();

  static final _id_onMessageSendSucceeded =
      jniAccessors.getMethodIDOf(_classRef, "onMessageSendSucceeded", "(I)V");

  /// from: public void onMessageSendSucceeded(int messageId)
  ///
  /// Called in response to
  /// DiscoverySession\#sendMessage(PeerHandle, int, byte[])
  /// when a message is transmitted successfully - i.e. when it was received successfully by the
  /// peer (corresponds to an ACK being received).
  ///
  /// Note that either this callback or
  /// DiscoverySessionCallback\#onMessageSendFailed(int) will be
  /// received - never both.
  ///@param messageId The arbitrary message ID specified when sending the message.
  void onMessageSendSucceeded(int messageId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onMessageSendSucceeded,
      jni.JniType.voidType,
      [messageId]).check();

  static final _id_onMessageSendFailed =
      jniAccessors.getMethodIDOf(_classRef, "onMessageSendFailed", "(I)V");

  /// from: public void onMessageSendFailed(int messageId)
  ///
  /// Called when message transmission initiated with
  /// DiscoverySession\#sendMessage(PeerHandle, int, byte[]) fails. E.g. when no ACK is
  /// received from the peer.
  ///
  /// Note that either this callback or
  /// DiscoverySessionCallback\#onMessageSendSucceeded(int) will be received
  /// - never both.
  ///@param messageId The arbitrary message ID specified when sending the message.
  void onMessageSendFailed(int messageId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onMessageSendFailed,
      jni.JniType.voidType,
      [messageId]).check();

  static final _id_onMessageReceived = jniAccessors.getMethodIDOf(_classRef,
      "onMessageReceived", "(Landroid/net/wifi/aware/PeerHandle;[B)V");

  /// from: public void onMessageReceived(android.net.wifi.aware.PeerHandle peerHandle, byte[] message)
  ///
  /// Called when a message is received from a discovery session peer - in response to the
  /// peer's DiscoverySession\#sendMessage(PeerHandle, int, byte[]).
  ///@param peerHandle An opaque handle to the peer matching our discovery operation.
  ///@param message A byte array containing the message.
  void onMessageReceived(
          peerhandle_.PeerHandle peerHandle, jni.JniObject message) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onMessageReceived,
          jni.JniType.voidType,
          [peerHandle.reference, message.reference]).check();
}
