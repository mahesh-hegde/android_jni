// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Characteristics.dart" as characteristics_;

import "AttachCallback.dart" as attachcallback_;

import "../../../os/Handler.dart" as handler_;

import "IdentityChangedListener.dart" as identitychangedlistener_;
import "../../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.wifi.aware.WifiAwareManager
///
/// This class provides the primary API for managing Wi-Fi Aware operations:
/// discovery and peer-to-peer data connections.
///
/// The class provides access to:
/// <ul>
/// <li>Initialize a Aware cluster (peer-to-peer synchronization). Refer to
/// \#attach(AttachCallback, Handler).
/// <li>Create discovery sessions (publish or subscribe sessions). Refer to
/// WifiAwareSession\#publish(PublishConfig, DiscoverySessionCallback, Handler) and
/// WifiAwareSession\#subscribe(SubscribeConfig, DiscoverySessionCallback, Handler).
/// <li>Create a Aware network specifier to be used with
/// ConnectivityManager\#requestNetwork(NetworkRequest, ConnectivityManager.NetworkCallback)
/// to set-up a Aware connection with a peer. Refer to
/// DiscoverySession\#createNetworkSpecifierOpen(PeerHandle),
/// DiscoverySession\#createNetworkSpecifierPassphrase(PeerHandle, String),
/// WifiAwareSession\#createNetworkSpecifierOpen(int, byte[]), and
/// WifiAwareSession\#createNetworkSpecifierPassphrase(int, byte[], String).
/// </ul>
///
///     Aware may not be usable when Wi-Fi is disabled (and other conditions). To validate that
///     the functionality is available use the \#isAvailable() function. To track
///     changes in Aware usability register for the \#ACTION_WIFI_AWARE_STATE_CHANGED
///     broadcast. Note that this broadcast is not sticky - you should register for it and then
///     check the above API to avoid a race condition.
///
///     An application must use \#attach(AttachCallback, Handler) to initialize a
///     Aware cluster - before making any other Aware operation. Aware cluster membership is a
///     device-wide operation - the API guarantees that the device is in a cluster or joins a
///     Aware cluster (or starts one if none can be found). Information about attach success (or
///     failure) are returned in callbacks of AttachCallback. Proceed with Aware
///     discovery or connection setup only after receiving confirmation that Aware attach
///     succeeded - AttachCallback\#onAttached(WifiAwareSession). When an
///     application is finished using Aware it __must__ use the
///     WifiAwareSession\#close() API to indicate to the Aware service that the device
///     may detach from the Aware cluster. The device will actually disable Aware once the last
///     application detaches.
///
///     Once a Aware attach is confirmed use the
///     WifiAwareSession\#publish(PublishConfig, DiscoverySessionCallback, Handler)
///     or
///     WifiAwareSession\#subscribe(SubscribeConfig, DiscoverySessionCallback,
///     Handler) to create publish or subscribe Aware discovery sessions. Events are called on the
///     provided callback object DiscoverySessionCallback. Specifically, the
///     DiscoverySessionCallback\#onPublishStarted(PublishDiscoverySession)
///     and
///     DiscoverySessionCallback\#onSubscribeStarted(
///SubscribeDiscoverySession)
///     return PublishDiscoverySession and
///     SubscribeDiscoverySession
///     objects respectively on which additional session operations can be performed, e.g. updating
///     the session PublishDiscoverySession\#updatePublish(PublishConfig) and
///     SubscribeDiscoverySession\#updateSubscribe(SubscribeConfig). Sessions can
///     also be used to send messages using the
///     DiscoverySession\#sendMessage(PeerHandle, int, byte[]) APIs. When an
///     application is finished with a discovery session it __must__ terminate it using the
///     DiscoverySession\#close() API.
///
///    Creating connections between Aware devices is managed by the standard
///    ConnectivityManager\#requestNetwork(NetworkRequest,
///    ConnectivityManager.NetworkCallback).
///    The NetworkRequest object should be constructed with:
///    <ul>
///        <li>NetworkRequest.Builder\#addTransportType(int) of
///        android.net.NetworkCapabilities\#TRANSPORT_WIFI_AWARE.
///        <li>NetworkRequest.Builder\#setNetworkSpecifier(String) using
///        WifiAwareSession\#createNetworkSpecifierOpen(int, byte[]),
///        WifiAwareSession\#createNetworkSpecifierPassphrase(int, byte[], String),
///        DiscoverySession\#createNetworkSpecifierOpen(PeerHandle), or
///        DiscoverySession\#createNetworkSpecifierPassphrase(PeerHandle, String).
///    </ul>
class WifiAwareManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/wifi/aware/WifiAwareManager");
  WifiAwareManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_WIFI_AWARE_STATE_CHANGED
  ///
  /// Broadcast intent action to indicate that the state of Wi-Fi Aware availability has changed.
  /// Use the \#isAvailable() to query the current status.
  /// This broadcast is __not__ sticky, use the \#isAvailable() API after registering
  /// the broadcast to check the current state of Wi-Fi Aware.
  /// Note: The broadcast is only delivered to registered receivers - no manifest registered
  /// components will be launched.
  static const ACTION_WIFI_AWARE_STATE_CHANGED =
      "android.net.wifi.aware.action.WIFI_AWARE_STATE_CHANGED";

  /// from: static public final int WIFI_AWARE_DATA_PATH_ROLE_INITIATOR
  ///
  /// Connection creation role is that of INITIATOR. Used to create a network specifier string
  /// when requesting a Aware network.
  ///@see DiscoverySession\#createNetworkSpecifierOpen(PeerHandle)
  ///@see DiscoverySession\#createNetworkSpecifierPassphrase(PeerHandle, String)
  ///@see WifiAwareSession\#createNetworkSpecifierOpen(int, byte[])
  ///@see WifiAwareSession\#createNetworkSpecifierPassphrase(int, byte[], String)
  static const WIFI_AWARE_DATA_PATH_ROLE_INITIATOR = 0;

  /// from: static public final int WIFI_AWARE_DATA_PATH_ROLE_RESPONDER
  ///
  /// Connection creation role is that of RESPONDER. Used to create a network specifier string
  /// when requesting a Aware network.
  ///@see DiscoverySession\#createNetworkSpecifierOpen(PeerHandle)
  ///@see DiscoverySession\#createNetworkSpecifierPassphrase(PeerHandle, String)
  ///@see WifiAwareSession\#createNetworkSpecifierOpen(int, byte[])
  ///@see WifiAwareSession\#createNetworkSpecifierPassphrase(int, byte[], String)
  static const WIFI_AWARE_DATA_PATH_ROLE_RESPONDER = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WifiAwareManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_isAvailable =
      jniAccessors.getMethodIDOf(_classRef, "isAvailable", "()Z");

  /// from: public boolean isAvailable()
  ///
  /// Returns the current status of Aware API: whether or not Aware is available. To track
  /// changes in the state of Aware API register for the
  /// \#ACTION_WIFI_AWARE_STATE_CHANGED broadcast.
  ///@return A boolean indicating whether the app can use the Aware API at this time (true) or
  /// not (false).
  bool isAvailable() => jniAccessors.callMethodWithArgs(
      reference, _id_isAvailable, jni.JniType.booleanType, []).boolean;

  static final _id_getCharacteristics = jniAccessors.getMethodIDOf(_classRef,
      "getCharacteristics", "()Landroid/net/wifi/aware/Characteristics;");

  /// from: public android.net.wifi.aware.Characteristics getCharacteristics()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the characteristics of the Wi-Fi Aware interface: a set of parameters which specify
  /// limitations on configurations, e.g.&nbsp;the maximum service name length.
  ///@return An object specifying configuration limitations of Aware.
  characteristics_.Characteristics getCharacteristics() =>
      characteristics_.Characteristics.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCharacteristics,
          jni.JniType.objectType, []).object);

  static final _id_attach = jniAccessors.getMethodIDOf(_classRef, "attach",
      "(Landroid/net/wifi/aware/AttachCallback;Landroid/os/Handler;)V");

  /// from: public void attach(android.net.wifi.aware.AttachCallback attachCallback, android.os.Handler handler)
  ///
  /// Attach to the Wi-Fi Aware service - enabling the application to create discovery sessions or
  /// create connections to peers. The device will attach to an existing cluster if it can find
  /// one or create a new cluster (if it is the first to enable Aware in its vicinity). Results
  /// (e.g. successful attach to a cluster) are provided to the {@code attachCallback} object.
  /// An application __must__ call WifiAwareSession\#close() when done with the
  /// Wi-Fi Aware object.
  ///
  /// Note: a Aware cluster is a shared resource - if the device is already attached to a cluster
  /// then this function will simply indicate success immediately using the same {@code
  /// attachCallback}.
  ///@param attachCallback A callback for attach events, extended from
  /// AttachCallback.
  /// This value must never be {@code null}.
  ///@param handler The Handler on whose thread to execute the callbacks of the {@code
  /// attachCallback} object. If a null is provided then the application's main thread will be
  ///                used.
  ///
  /// This value may be {@code null}.
  void attach(attachcallback_.AttachCallback attachCallback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_attach,
          jni.JniType.voidType,
          [attachCallback.reference, handler.reference]).check();

  static final _id_attach1 = jniAccessors.getMethodIDOf(_classRef, "attach",
      "(Landroid/net/wifi/aware/AttachCallback;Landroid/net/wifi/aware/IdentityChangedListener;Landroid/os/Handler;)V");

  /// from: public void attach(android.net.wifi.aware.AttachCallback attachCallback, android.net.wifi.aware.IdentityChangedListener identityChangedListener, android.os.Handler handler)
  ///
  /// Attach to the Wi-Fi Aware service - enabling the application to create discovery sessions or
  /// create connections to peers. The device will attach to an existing cluster if it can find
  /// one or create a new cluster (if it is the first to enable Aware in its vicinity). Results
  /// (e.g. successful attach to a cluster) are provided to the {@code attachCallback} object.
  /// An application __must__ call WifiAwareSession\#close() when done with the
  /// Wi-Fi Aware object.
  ///
  /// Note: a Aware cluster is a shared resource - if the device is already attached to a cluster
  /// then this function will simply indicate success immediately using the same {@code
  /// attachCallback}.
  ///
  /// This version of the API attaches a listener to receive the MAC address of the Aware interface
  /// on startup and whenever it is updated (it is randomized at regular intervals for privacy).
  /// The application must have the android.Manifest.permission\#ACCESS_COARSE_LOCATION
  /// permission to execute this attach request. Otherwise, use the
  /// \#attach(AttachCallback, Handler) version. Note that aside from permission
  /// requirements this listener will wake up the host at regular intervals causing higher power
  /// consumption, do not use it unless the information is necessary (e.g. for OOB discovery).
  ///@param attachCallback A callback for attach events, extended from
  /// AttachCallback.
  /// This value must never be {@code null}.
  ///@param identityChangedListener A listener for changed identity, extended from
  /// IdentityChangedListener.
  /// This value must never be {@code null}.
  ///@param handler The Handler on whose thread to execute the callbacks of the {@code
  /// attachCallback} and {@code identityChangedListener} objects. If a null is provided then the
  ///                application's main thread will be used.
  ///
  /// This value may be {@code null}.
  void attach1(
          attachcallback_.AttachCallback attachCallback,
          identitychangedlistener_.IdentityChangedListener
              identityChangedListener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_attach1, jni.JniType.voidType, [
        attachCallback.reference,
        identityChangedListener.reference,
        handler.reference
      ]).check();
}
