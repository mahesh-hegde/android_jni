// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "WifiAwareManager.dart" as wifiawaremanager_;

import "../../../os/Binder.dart" as binder_;

import "PublishConfig.dart" as publishconfig_;

import "DiscoverySessionCallback.dart" as discoverysessioncallback_;

import "../../../os/Handler.dart" as handler_;

import "SubscribeConfig.dart" as subscribeconfig_;

import "../../NetworkSpecifier.dart" as networkspecifier_;
import "../../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.wifi.aware.WifiAwareSession
///
/// This class represents a Wi-Fi Aware session - an attachment to the Wi-Fi Aware service through
/// which the app can execute discovery operations.
class WifiAwareSession extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/wifi/aware/WifiAwareSession");
  WifiAwareSession.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/net/wifi/aware/WifiAwareManager;Landroid/os/Binder;I)V");

  /// from: void <init>(android.net.wifi.aware.WifiAwareManager manager, android.os.Binder binder, int clientId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  WifiAwareSession(wifiawaremanager_.WifiAwareManager manager,
      binder_.Binder binder, int clientId)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [manager.reference, binder.reference, clientId]).object);

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Destroy the Wi-Fi Aware service session and, if no other applications are attached to Aware,
  /// also disable Aware. This method destroys all outstanding operations - i.e. all publish and
  /// subscribes are terminated, and any outstanding data-links are shut-down. However, it is
  /// good practice to destroy these discovery sessions and connections explicitly before a
  /// session-wide destroy.
  ///
  /// An application may re-attach after a destroy using
  /// WifiAwareManager\#attach(AttachCallback, Handler) .
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  ///
  /// @hide
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_publish = jniAccessors.getMethodIDOf(_classRef, "publish",
      "(Landroid/net/wifi/aware/PublishConfig;Landroid/net/wifi/aware/DiscoverySessionCallback;Landroid/os/Handler;)V");

  /// from: public void publish(android.net.wifi.aware.PublishConfig publishConfig, android.net.wifi.aware.DiscoverySessionCallback callback, android.os.Handler handler)
  ///
  /// Issue a request to the Aware service to create a new Aware publish discovery session, using
  /// the specified {@code publishConfig} configuration. The results of the publish operation
  /// are routed to the callbacks of DiscoverySessionCallback:
  /// <ul>
  ///     <li>
  ///     DiscoverySessionCallback\#onPublishStarted(
  ///PublishDiscoverySession)
  ///     is called when the publish session is created and provides a handle to the session.
  ///     Further operations on the publish session can be executed on that object.
  ///     <li>DiscoverySessionCallback\#onSessionConfigFailed() is called if the
  ///     publish operation failed.
  /// </ul>
  ///
  /// Other results of the publish session operations will also be routed to callbacks
  /// on the {@code callback} object. The resulting publish session can be modified using
  /// PublishDiscoverySession\#updatePublish(PublishConfig).
  ///
  ///      An application must use the DiscoverySession\#close() to
  ///      terminate the publish discovery session once it isn't needed. This will free
  ///      resources as well terminate any on-air transmissions.
  /// The application must have the android.Manifest.permission\#ACCESS_COARSE_LOCATION
  /// permission to start a publish discovery session.
  ///@param publishConfig The PublishConfig specifying the
  ///            configuration of the requested publish session.
  /// This value must never be {@code null}.
  ///@param callback A DiscoverySessionCallback derived object to be used for
  ///                 session event callbacks.
  /// This value must never be {@code null}.
  ///@param handler The Handler on whose thread to execute the callbacks of the {@code
  /// callback} object. If a null is provided then the application's main thread will be used.
  ///
  /// This value may be {@code null}.
  void publish(
          publishconfig_.PublishConfig publishConfig,
          discoverysessioncallback_.DiscoverySessionCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_publish, jni.JniType.voidType, [
        publishConfig.reference,
        callback.reference,
        handler.reference
      ]).check();

  static final _id_subscribe = jniAccessors.getMethodIDOf(
      _classRef,
      "subscribe",
      "(Landroid/net/wifi/aware/SubscribeConfig;Landroid/net/wifi/aware/DiscoverySessionCallback;Landroid/os/Handler;)V");

  /// from: public void subscribe(android.net.wifi.aware.SubscribeConfig subscribeConfig, android.net.wifi.aware.DiscoverySessionCallback callback, android.os.Handler handler)
  ///
  /// Issue a request to the Aware service to create a new Aware subscribe discovery session, using
  /// the specified {@code subscribeConfig} configuration. The results of the subscribe
  /// operation are routed to the callbacks of DiscoverySessionCallback:
  /// <ul>
  ///     <li>
  ///  DiscoverySessionCallback\#onSubscribeStarted(
  ///SubscribeDiscoverySession)
  ///     is called when the subscribe session is created and provides a handle to the session.
  ///     Further operations on the subscribe session can be executed on that object.
  ///     <li>DiscoverySessionCallback\#onSessionConfigFailed() is called if the
  ///     subscribe operation failed.
  /// </ul>
  ///
  /// Other results of the subscribe session operations will also be routed to callbacks
  /// on the {@code callback} object. The resulting subscribe session can be modified using
  /// SubscribeDiscoverySession\#updateSubscribe(SubscribeConfig).
  ///
  ///      An application must use the DiscoverySession\#close() to
  ///      terminate the subscribe discovery session once it isn't needed. This will free
  ///      resources as well terminate any on-air transmissions.
  /// The application must have the android.Manifest.permission\#ACCESS_COARSE_LOCATION
  /// permission to start a subscribe discovery session.
  ///@param subscribeConfig The SubscribeConfig specifying the
  ///            configuration of the requested subscribe session.
  /// This value must never be {@code null}.
  ///@param callback A DiscoverySessionCallback derived object to be used for
  ///                 session event callbacks.
  /// This value must never be {@code null}.
  ///@param handler The Handler on whose thread to execute the callbacks of the {@code
  /// callback} object. If a null is provided then the application's main thread will be used.
  ///
  /// This value may be {@code null}.
  void subscribe(
          subscribeconfig_.SubscribeConfig subscribeConfig,
          discoverysessioncallback_.DiscoverySessionCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_subscribe, jni.JniType.voidType, [
        subscribeConfig.reference,
        callback.reference,
        handler.reference
      ]).check();

  static final _id_createNetworkSpecifierOpen = jniAccessors.getMethodIDOf(
      _classRef,
      "createNetworkSpecifierOpen",
      "(I[B)Landroid/net/NetworkSpecifier;");

  /// from: public android.net.NetworkSpecifier createNetworkSpecifierOpen(int role, byte[] peer)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a android.net.NetworkRequest.Builder\#setNetworkSpecifier(NetworkSpecifier) for
  /// an unencrypted WiFi Aware connection (link) to the specified peer. The
  /// android.net.NetworkRequest.Builder\#addTransportType(int) should be set to
  /// android.net.NetworkCapabilities\#TRANSPORT_WIFI_AWARE.
  ///
  ///     This API is targeted for applications which can obtain the peer MAC address using OOB
  ///     (out-of-band) discovery. Aware discovery does not provide the MAC address of the peer -
  ///     when using Aware discovery use the alternative network specifier method -
  ///     DiscoverySession\#createNetworkSpecifierOpen(PeerHandle).
  ///
  /// To set up an encrypted link use the
  /// \#createNetworkSpecifierPassphrase(int, byte[], String) API.
  ///@param role The role of this device:
  ///              WifiAwareManager\#WIFI_AWARE_DATA_PATH_ROLE_INITIATOR or
  ///              WifiAwareManager\#WIFI_AWARE_DATA_PATH_ROLE_RESPONDER
  /// Value is android.net.wifi.aware.WifiAwareManager\#WIFI_AWARE_DATA_PATH_ROLE_INITIATOR, or android.net.wifi.aware.WifiAwareManager\#WIFI_AWARE_DATA_PATH_ROLE_RESPONDER
  ///@param peer The MAC address of the peer's Aware discovery interface. On a RESPONDER this
  ///              value is used to gate the acceptance of a connection request from only that
  ///              peer.
  ///
  /// This value must never be {@code null}.
  ///@return A NetworkSpecifier to be used to construct
  /// android.net.NetworkRequest.Builder\#setNetworkSpecifier(NetworkSpecifier) to pass to
  /// android.net.ConnectivityManager\#requestNetwork(android.net.NetworkRequest,
  /// android.net.ConnectivityManager.NetworkCallback)
  /// [or other varieties of that API].
  networkspecifier_.NetworkSpecifier createNetworkSpecifierOpen(
          int role, jni.JniObject peer) =>
      networkspecifier_.NetworkSpecifier.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_createNetworkSpecifierOpen,
              jni.JniType.objectType, [role, peer.reference]).object);

  static final _id_createNetworkSpecifierPassphrase =
      jniAccessors.getMethodIDOf(_classRef, "createNetworkSpecifierPassphrase",
          "(I[BLjava/lang/String;)Landroid/net/NetworkSpecifier;");

  /// from: public android.net.NetworkSpecifier createNetworkSpecifierPassphrase(int role, byte[] peer, java.lang.String passphrase)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a android.net.NetworkRequest.Builder\#setNetworkSpecifier(NetworkSpecifier) for
  /// an encrypted WiFi Aware connection (link) to the specified peer. The
  /// android.net.NetworkRequest.Builder\#addTransportType(int) should be set to
  /// android.net.NetworkCapabilities\#TRANSPORT_WIFI_AWARE.
  ///
  ///     This API is targeted for applications which can obtain the peer MAC address using OOB
  ///     (out-of-band) discovery. Aware discovery does not provide the MAC address of the peer -
  ///     when using Aware discovery use the alternative network specifier method -
  ///     DiscoverySession\#createNetworkSpecifierPassphrase(PeerHandle, String).
  ///@param role The role of this device:
  ///              WifiAwareManager\#WIFI_AWARE_DATA_PATH_ROLE_INITIATOR or
  ///              WifiAwareManager\#WIFI_AWARE_DATA_PATH_ROLE_RESPONDER
  /// Value is android.net.wifi.aware.WifiAwareManager\#WIFI_AWARE_DATA_PATH_ROLE_INITIATOR, or android.net.wifi.aware.WifiAwareManager\#WIFI_AWARE_DATA_PATH_ROLE_RESPONDER
  ///@param peer The MAC address of the peer's Aware discovery interface. On a RESPONDER this
  ///              value is used to gate the acceptance of a connection request from only that
  ///              peer.
  /// This value must never be {@code null}.
  ///@param passphrase The passphrase to be used to encrypt the link. The PMK is generated from
  ///                   the passphrase. Use \#createNetworkSpecifierOpen(int, byte[]) to
  ///                   specify an open (unencrypted) link.
  ///
  /// This value must never be {@code null}.
  ///@return A NetworkSpecifier to be used to construct
  /// android.net.NetworkRequest.Builder\#setNetworkSpecifier(NetworkSpecifier) to pass to
  /// android.net.ConnectivityManager\#requestNetwork(android.net.NetworkRequest,
  /// android.net.ConnectivityManager.NetworkCallback)
  /// [or other varieties of that API].
  networkspecifier_.NetworkSpecifier createNetworkSpecifierPassphrase(
          int role, jni.JniObject peer, jni.JniString passphrase) =>
      networkspecifier_.NetworkSpecifier.fromRef(jniAccessors
          .callMethodWithArgs(
              reference,
              _id_createNetworkSpecifierPassphrase,
              jni.JniType.objectType,
              [role, peer.reference, passphrase.reference]).object);
}
