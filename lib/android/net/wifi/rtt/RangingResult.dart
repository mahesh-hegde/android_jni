// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../os/Parcelable.dart" as parcelable_;

import "../../MacAddress.dart" as macaddress_;

import "../aware/PeerHandle.dart" as peerhandle_;

import "../../../os/Parcel.dart" as parcel_;
import "../../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.wifi.rtt.RangingResult
///
/// Ranging result for a request started by
/// WifiRttManager\#startRanging(RangingRequest, java.util.concurrent.Executor, RangingResultCallback).
/// Results are returned in RangingResultCallback\#onRangingResults(List).
///
/// A ranging result is the distance measurement result for a single device specified in the
/// RangingRequest.
class RangingResult extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/wifi/rtt/RangingResult");
  RangingResult.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.net.wifi.rtt.RangingResult> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int STATUS_FAIL
  ///
  /// Individual range request status, \#getStatus(). Indicates ranging operation failed
  /// and the distance value is invalid.
  static const STATUS_FAIL = 1;

  /// from: static public final int STATUS_RESPONDER_DOES_NOT_SUPPORT_IEEE80211MC
  ///
  /// Individual range request status, \#getStatus(). Indicates that the ranging operation
  /// failed because the specified peer does not support IEEE 802.11mc RTT operations. Support by
  /// an Access Point can be confirmed using
  /// android.net.wifi.ScanResult\#is80211mcResponder().
  ///
  /// On such a failure, the individual result fields of RangingResult such as
  /// RangingResult\#getDistanceMm() are invalid.
  static const STATUS_RESPONDER_DOES_NOT_SUPPORT_IEEE80211MC = 2;

  /// from: static public final int STATUS_SUCCESS
  ///
  /// Individual range request status, \#getStatus(). Indicates ranging operation was
  /// successful and distance value is valid.
  static const STATUS_SUCCESS = 0;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(ILandroid/net/MacAddress;IIIII[B[BJ)V");

  /// from: void <init>(int status, android.net.MacAddress mac, int distanceMm, int distanceStdDevMm, int rssi, int numAttemptedMeasurements, int numSuccessfulMeasurements, byte[] lci, byte[] lcr, long timestamp)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  RangingResult(
      int status,
      macaddress_.MacAddress mac,
      int distanceMm,
      int distanceStdDevMm,
      int rssi,
      int numAttemptedMeasurements,
      int numSuccessfulMeasurements,
      jni.JniObject lci,
      jni.JniObject lcr,
      int timestamp)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [
          status,
          mac.reference,
          distanceMm,
          distanceStdDevMm,
          rssi,
          numAttemptedMeasurements,
          numSuccessfulMeasurements,
          lci.reference,
          lcr.reference,
          timestamp
        ]).object);

  static final _id_getStatus =
      jniAccessors.getMethodIDOf(_classRef, "getStatus", "()I");

  /// from: public int getStatus()
  ///
  /// @return The status of ranging measurement: \#STATUS_SUCCESS in case of success, and
  /// \#STATUS_FAIL in case of failure.
  ///
  /// Value is android.net.wifi.rtt.RangingResult\#STATUS_SUCCESS, android.net.wifi.rtt.RangingResult\#STATUS_FAIL, or android.net.wifi.rtt.RangingResult\#STATUS_RESPONDER_DOES_NOT_SUPPORT_IEEE80211MC
  int getStatus() => jniAccessors.callMethodWithArgs(
      reference, _id_getStatus, jni.JniType.intType, []).integer;

  static final _id_getMacAddress = jniAccessors.getMethodIDOf(
      _classRef, "getMacAddress", "()Landroid/net/MacAddress;");

  /// from: public android.net.MacAddress getMacAddress()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The MAC address of the device whose range measurement was requested. Will correspond
  /// to the MAC address of the device in the RangingRequest.
  ///
  /// Will return a {@code null} for results corresponding to requests issued using a {@code
  /// PeerHandle}, i.e. using the RangingRequest.Builder\#addWifiAwarePeer(PeerHandle) API.
  macaddress_.MacAddress getMacAddress() =>
      macaddress_.MacAddress.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMacAddress, jni.JniType.objectType, []).object);

  static final _id_getPeerHandle = jniAccessors.getMethodIDOf(
      _classRef, "getPeerHandle", "()Landroid/net/wifi/aware/PeerHandle;");

  /// from: public android.net.wifi.aware.PeerHandle getPeerHandle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The PeerHandle of the device whose reange measurement was requested. Will correspond
  /// to the PeerHandle of the devices requested using
  /// RangingRequest.Builder\#addWifiAwarePeer(PeerHandle).
  ///
  /// Will return a {@code null} for results corresponding to requests issued using a MAC address.
  peerhandle_.PeerHandle getPeerHandle() =>
      peerhandle_.PeerHandle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPeerHandle, jni.JniType.objectType, []).object);

  static final _id_getDistanceMm =
      jniAccessors.getMethodIDOf(_classRef, "getDistanceMm", "()I");

  /// from: public int getDistanceMm()
  ///
  /// @return The distance (in mm) to the device specified by \#getMacAddress() or
  /// \#getPeerHandle().
  ///
  /// Note: the measured distance may be negative for very close devices.
  ///
  /// Only valid if \#getStatus() returns \#STATUS_SUCCESS, otherwise will throw an
  /// exception.
  int getDistanceMm() => jniAccessors.callMethodWithArgs(
      reference, _id_getDistanceMm, jni.JniType.intType, []).integer;

  static final _id_getDistanceStdDevMm =
      jniAccessors.getMethodIDOf(_classRef, "getDistanceStdDevMm", "()I");

  /// from: public int getDistanceStdDevMm()
  ///
  /// @return The standard deviation of the measured distance (in mm) to the device specified by
  /// \#getMacAddress() or \#getPeerHandle(). The standard deviation is calculated
  /// over the measurements executed in a single RTT burst. The number of measurements is returned
  /// by \#getNumSuccessfulMeasurements() - 0 successful measurements indicate that the
  /// standard deviation is not valid (a valid standard deviation requires at least 2 data points).
  ///
  /// Only valid if \#getStatus() returns \#STATUS_SUCCESS, otherwise will throw an
  /// exception.
  int getDistanceStdDevMm() => jniAccessors.callMethodWithArgs(
      reference, _id_getDistanceStdDevMm, jni.JniType.intType, []).integer;

  static final _id_getRssi =
      jniAccessors.getMethodIDOf(_classRef, "getRssi", "()I");

  /// from: public int getRssi()
  ///
  /// @return The average RSSI, in units of dBm, observed during the RTT measurement.
  ///
  /// Only valid if \#getStatus() returns \#STATUS_SUCCESS, otherwise will throw an
  /// exception.
  int getRssi() => jniAccessors.callMethodWithArgs(
      reference, _id_getRssi, jni.JniType.intType, []).integer;

  static final _id_getNumAttemptedMeasurements = jniAccessors.getMethodIDOf(
      _classRef, "getNumAttemptedMeasurements", "()I");

  /// from: public int getNumAttemptedMeasurements()
  ///
  /// @return The number of attempted measurements used in the RTT exchange resulting in this set
  /// of results. The number of successful measurements is returned by
  /// \#getNumSuccessfulMeasurements() which at most, if there are no errors, will be 1 less
  /// that the number of attempted measurements.
  ///
  /// Only valid if \#getStatus() returns \#STATUS_SUCCESS, otherwise will throw an
  /// exception.
  int getNumAttemptedMeasurements() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getNumAttemptedMeasurements,
      jni.JniType.intType, []).integer;

  static final _id_getNumSuccessfulMeasurements = jniAccessors.getMethodIDOf(
      _classRef, "getNumSuccessfulMeasurements", "()I");

  /// from: public int getNumSuccessfulMeasurements()
  ///
  /// @return The number of successful measurements used to calculate the distance and standard
  /// deviation. If the number of successful measurements if 1 then then standard deviation,
  /// returned by \#getDistanceStdDevMm(), is not valid (a 0 is returned for the standard
  /// deviation).
  ///
  /// The total number of measurement attempts is returned by
  /// \#getNumAttemptedMeasurements(). The number of successful measurements will be at
  /// most 1 less then the number of attempted measurements.
  ///
  /// Only valid if \#getStatus() returns \#STATUS_SUCCESS, otherwise will throw an
  /// exception.
  int getNumSuccessfulMeasurements() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getNumSuccessfulMeasurements,
      jni.JniType.intType, []).integer;

  static final _id_getRangingTimestampMillis =
      jniAccessors.getMethodIDOf(_classRef, "getRangingTimestampMillis", "()J");

  /// from: public long getRangingTimestampMillis()
  ///
  /// @return The timestamp at which the ranging operation was performed. The timestamp is in
  /// milliseconds since boot, including time spent in sleep, corresponding to values provided by
  /// android.os.SystemClock\#elapsedRealtime().
  ///
  /// Only valid if \#getStatus() returns \#STATUS_SUCCESS, otherwise will throw an
  /// exception.
  int getRangingTimestampMillis() => jniAccessors.callMethodWithArgs(
      reference, _id_getRangingTimestampMillis, jni.JniType.longType, []).long;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}
