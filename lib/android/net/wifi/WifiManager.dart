// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "WifiConfiguration.dart" as wificonfiguration_;

import "hotspot2/PasspointConfiguration.dart" as passpointconfiguration_;

import "WifiInfo.dart" as wifiinfo_;

import "../DhcpInfo.dart" as dhcpinfo_;

import "../../os/Handler.dart" as handler_;

import "WpsInfo.dart" as wpsinfo_;

import "../../os/WorkSource.dart" as worksource_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.wifi.WifiManager
///
/// This class provides the primary API for managing all aspects of Wi-Fi
/// connectivity.
///
/// On releases before android.os.Build.VERSION_CODES\#N, this object
/// should only be obtained from an {@linkplain Context\#getApplicationContext() application context}, and not from any other derived context to avoid memory
/// leaks within the calling process.
///
/// It deals with several categories of items:
///
///
/// <ul>
/// <li>The list of configured networks. The list can be viewed and updated, and
/// attributes of individual entries can be modified.</li>
/// <li>The currently active Wi-Fi network, if any. Connectivity can be
/// established or torn down, and dynamic information about the state of the
/// network can be queried.</li>
/// <li>Results of access point scans, containing enough information to make
/// decisions about what access point to connect to.</li>
/// <li>It defines the names of various Intent actions that are broadcast upon
/// any sort of change in Wi-Fi state.
/// </ul>
///
/// This is the API to use when performing Wi-Fi specific operations. To perform
/// operations that pertain to network connectivity at an abstract level, use
/// android.net.ConnectivityManager.
///
///
class WifiManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/wifi/WifiManager");
  WifiManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_PICK_WIFI_NETWORK
  ///
  /// Activity Action: Pick a Wi-Fi network to connect to.
  /// Input: Nothing.
  /// Output: Nothing.
  static const ACTION_PICK_WIFI_NETWORK = "android.net.wifi.PICK_WIFI_NETWORK";

  /// from: static public final java.lang.String ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE
  ///
  /// Activity Action: Show a system activity that allows the user to enable
  /// scans to be available even with Wi-Fi turned off.
  ///
  /// Notification of the result of this activity is posted using the
  /// android.app.Activity\#onActivityResult callback. The
  /// <code>resultCode</code>
  /// will be android.app.Activity\#RESULT_OK if scan always mode has
  /// been turned on or android.app.Activity\#RESULT_CANCELED if the user
  /// has rejected the request or an error has occurred.
  static const ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE =
      "android.net.wifi.action.REQUEST_SCAN_ALWAYS_AVAILABLE";

  /// from: static public final int ERROR_AUTHENTICATING
  ///
  /// The error code if there was a problem authenticating.
  ///@deprecated This is no longer supported.
  static const ERROR_AUTHENTICATING = 1;

  /// from: static public final java.lang.String EXTRA_BSSID
  ///
  /// The lookup key for a String giving the BSSID of the access point to which
  /// we are connected. No longer used.
  static const EXTRA_BSSID = "bssid";

  /// from: static public final java.lang.String EXTRA_NETWORK_INFO
  ///
  /// The lookup key for a android.net.NetworkInfo object associated with the
  /// Wi-Fi network. Retrieve with
  /// android.content.Intent\#getParcelableExtra(String).
  static const EXTRA_NETWORK_INFO = "networkInfo";

  /// from: static public final java.lang.String EXTRA_NEW_RSSI
  ///
  /// The lookup key for an {@code int} giving the new RSSI in dBm.
  static const EXTRA_NEW_RSSI = "newRssi";

  /// from: static public final java.lang.String EXTRA_NEW_STATE
  ///
  /// The lookup key for a SupplicantState describing the new state
  /// Retrieve with
  /// android.content.Intent\#getParcelableExtra(String).
  ///@deprecated This is no longer supported.
  static const EXTRA_NEW_STATE = "newState";

  /// from: static public final java.lang.String EXTRA_PREVIOUS_WIFI_STATE
  ///
  /// The previous Wi-Fi state.
  ///@see \#EXTRA_WIFI_STATE
  static const EXTRA_PREVIOUS_WIFI_STATE = "previous_wifi_state";

  /// from: static public final java.lang.String EXTRA_RESULTS_UPDATED
  ///
  /// Lookup key for a {@code boolean} extra in intent \#SCAN_RESULTS_AVAILABLE_ACTION
  /// representing if the scan was successful or not.
  /// Scans may fail for multiple reasons, these may include:
  /// <ol>
  /// <li>An app requested too many scans in a certain period of time.
  /// This may lead to additional scan request rejections via "scan throttling" for both
  /// foreground and background apps.
  /// Note: Apps holding android.Manifest.permission.NETWORK_SETTINGS permission are
  /// exempted from scan throttling.
  /// </li>
  /// <li>The device is idle and scanning is disabled.</li>
  /// <li>Wifi hardware reported a scan failure.</li>
  /// </ol>
  ///@return true scan was successful, results are updated
  ///@return false scan was not successful, results haven't been updated since previous scan
  static const EXTRA_RESULTS_UPDATED = "resultsUpdated";

  /// from: static public final java.lang.String EXTRA_SUPPLICANT_CONNECTED
  ///
  /// The lookup key for a boolean that indicates whether a connection to
  /// the supplicant daemon has been gained or lost. {@code true} means
  /// a connection now exists.
  /// Retrieve it with android.content.Intent\#getBooleanExtra(String,boolean).
  ///@deprecated This is no longer supported.
  static const EXTRA_SUPPLICANT_CONNECTED = "connected";

  /// from: static public final java.lang.String EXTRA_SUPPLICANT_ERROR
  ///
  /// The lookup key for a SupplicantState describing the supplicant
  /// error code if any
  /// Retrieve with
  /// android.content.Intent\#getIntExtra(String, int).
  ///@see \#ERROR_AUTHENTICATING
  ///@deprecated This is no longer supported.
  static const EXTRA_SUPPLICANT_ERROR = "supplicantError";

  /// from: static public final java.lang.String EXTRA_WIFI_INFO
  ///
  /// The lookup key for a android.net.wifi.WifiInfo object giving the
  /// information about the access point to which we are connected.
  /// No longer used.
  static const EXTRA_WIFI_INFO = "wifiInfo";

  /// from: static public final java.lang.String EXTRA_WIFI_STATE
  ///
  /// The lookup key for an int that indicates whether Wi-Fi is enabled,
  /// disabled, enabling, disabling, or unknown.  Retrieve it with
  /// android.content.Intent\#getIntExtra(String,int).
  ///@see \#WIFI_STATE_DISABLED
  ///@see \#WIFI_STATE_DISABLING
  ///@see \#WIFI_STATE_ENABLED
  ///@see \#WIFI_STATE_ENABLING
  ///@see \#WIFI_STATE_UNKNOWN
  static const EXTRA_WIFI_STATE = "wifi_state";

  /// from: static public final java.lang.String NETWORK_IDS_CHANGED_ACTION
  ///
  /// The network IDs of the configured networks could have changed.
  static const NETWORK_IDS_CHANGED_ACTION =
      "android.net.wifi.NETWORK_IDS_CHANGED";

  /// from: static public final java.lang.String NETWORK_STATE_CHANGED_ACTION
  ///
  /// Broadcast intent action indicating that the state of Wi-Fi connectivity
  /// has changed. An extra provides the new state
  /// in the form of a android.net.NetworkInfo object.
  ///@see \#EXTRA_NETWORK_INFO
  static const NETWORK_STATE_CHANGED_ACTION = "android.net.wifi.STATE_CHANGE";

  /// from: static public final java.lang.String RSSI_CHANGED_ACTION
  ///
  /// The RSSI (signal strength) has changed.
  ///@see \#EXTRA_NEW_RSSI
  static const RSSI_CHANGED_ACTION = "android.net.wifi.RSSI_CHANGED";

  /// from: static public final java.lang.String SCAN_RESULTS_AVAILABLE_ACTION
  ///
  /// An access point scan has completed, and results are available.
  /// Call \#getScanResults() to obtain the results.
  /// The broadcast intent may contain an extra field with the key \#EXTRA_RESULTS_UPDATED
  /// and a {@code boolean} value indicating if the scan was successful.
  static const SCAN_RESULTS_AVAILABLE_ACTION = "android.net.wifi.SCAN_RESULTS";

  /// from: static public final java.lang.String SUPPLICANT_CONNECTION_CHANGE_ACTION
  ///
  /// Broadcast intent action indicating that a connection to the supplicant has
  /// been established (and it is now possible
  /// to perform Wi-Fi operations) or the connection to the supplicant has been
  /// lost. One extra provides the connection state as a boolean, where {@code true}
  /// means CONNECTED.
  ///@deprecated This is no longer supported.
  ///@see \#EXTRA_SUPPLICANT_CONNECTED
  static const SUPPLICANT_CONNECTION_CHANGE_ACTION =
      "android.net.wifi.supplicant.CONNECTION_CHANGE";

  /// from: static public final java.lang.String SUPPLICANT_STATE_CHANGED_ACTION
  ///
  /// Broadcast intent action indicating that the state of establishing a connection to
  /// an access point has changed.One extra provides the new
  /// SupplicantState. Note that the supplicant state is Wi-Fi specific, and
  /// is not generally the most useful thing to look at if you are just interested in
  /// the overall state of connectivity.
  ///@see \#EXTRA_NEW_STATE
  ///@see \#EXTRA_SUPPLICANT_ERROR
  ///@deprecated This is no longer supported.
  static const SUPPLICANT_STATE_CHANGED_ACTION =
      "android.net.wifi.supplicant.STATE_CHANGE";

  /// from: static public final int WIFI_MODE_FULL
  ///
  /// In this Wi-Fi lock mode, Wi-Fi will be kept active,
  /// and will behave normally, i.e., it will attempt to automatically
  /// establish a connection to a remembered access point that is
  /// within range, and will do periodic scans if there are remembered
  /// access points but none are in range.
  static const WIFI_MODE_FULL = 1;

  /// from: static public final int WIFI_MODE_FULL_HIGH_PERF
  ///
  /// In this Wi-Fi lock mode, Wi-Fi will be kept active as in mode
  /// \#WIFI_MODE_FULL but it operates at high performance
  /// with minimum packet loss and low packet latency even when
  /// the device screen is off. This mode will consume more power
  /// and hence should be used only when there is a need for such
  /// an active connection.
  ///
  /// An example use case is when a voice connection needs to be
  /// kept active even after the device screen goes off. Holding the
  /// regular \#WIFI_MODE_FULL lock will keep the wifi
  /// connection active, but the connection can be lossy.
  /// Holding a \#WIFI_MODE_FULL_HIGH_PERF lock for the
  /// duration of the voice call will improve the call quality.
  ///
  /// When there is no support from the hardware, this lock mode
  /// will have the same behavior as \#WIFI_MODE_FULL
  static const WIFI_MODE_FULL_HIGH_PERF = 3;

  /// from: static public final int WIFI_MODE_SCAN_ONLY
  ///
  /// In this Wi-Fi lock mode, Wi-Fi will be kept active,
  /// but the only operation that will be supported is initiation of
  /// scans, and the subsequent reporting of scan results. No attempts
  /// will be made to automatically connect to remembered access points,
  /// nor will periodic scans be automatically performed looking for
  /// remembered access points. Scans must be explicitly requested by
  /// an application in this mode.
  static const WIFI_MODE_SCAN_ONLY = 2;

  /// from: static public final java.lang.String WIFI_STATE_CHANGED_ACTION
  ///
  /// Broadcast intent action indicating that Wi-Fi has been enabled, disabled,
  /// enabling, disabling, or unknown. One extra provides this state as an int.
  /// Another extra provides the previous state, if available.
  ///@see \#EXTRA_WIFI_STATE
  ///@see \#EXTRA_PREVIOUS_WIFI_STATE
  static const WIFI_STATE_CHANGED_ACTION =
      "android.net.wifi.WIFI_STATE_CHANGED";

  /// from: static public final int WIFI_STATE_DISABLED
  ///
  /// Wi-Fi is disabled.
  ///@see \#WIFI_STATE_CHANGED_ACTION
  ///@see \#getWifiState()
  static const WIFI_STATE_DISABLED = 1;

  /// from: static public final int WIFI_STATE_DISABLING
  ///
  /// Wi-Fi is currently being disabled. The state will change to \#WIFI_STATE_DISABLED if
  /// it finishes successfully.
  ///@see \#WIFI_STATE_CHANGED_ACTION
  ///@see \#getWifiState()
  static const WIFI_STATE_DISABLING = 0;

  /// from: static public final int WIFI_STATE_ENABLED
  ///
  /// Wi-Fi is enabled.
  ///@see \#WIFI_STATE_CHANGED_ACTION
  ///@see \#getWifiState()
  static const WIFI_STATE_ENABLED = 3;

  /// from: static public final int WIFI_STATE_ENABLING
  ///
  /// Wi-Fi is currently being enabled. The state will change to \#WIFI_STATE_ENABLED if
  /// it finishes successfully.
  ///@see \#WIFI_STATE_CHANGED_ACTION
  ///@see \#getWifiState()
  static const WIFI_STATE_ENABLING = 2;

  /// from: static public final int WIFI_STATE_UNKNOWN
  ///
  /// Wi-Fi is in an unknown state. This state will occur when an error happens while enabling
  /// or disabling.
  ///@see \#WIFI_STATE_CHANGED_ACTION
  ///@see \#getWifiState()
  static const WIFI_STATE_UNKNOWN = 4;

  /// from: static public final int WPS_AUTH_FAILURE
  ///
  /// Authentication failure on WPS
  ///@deprecated This is deprecated
  static const WPS_AUTH_FAILURE = 6;

  /// from: static public final int WPS_OVERLAP_ERROR
  ///
  /// WPS overlap detected
  ///@deprecated This is deprecated
  static const WPS_OVERLAP_ERROR = 3;

  /// from: static public final int WPS_TIMED_OUT
  ///
  /// WPS timed out
  ///@deprecated This is deprecated
  static const WPS_TIMED_OUT = 7;

  /// from: static public final int WPS_TKIP_ONLY_PROHIBITED
  ///
  /// TKIP only prohibited
  ///@deprecated This is deprecated
  static const WPS_TKIP_ONLY_PROHIBITED = 5;

  /// from: static public final int WPS_WEP_PROHIBITED
  ///
  /// WEP on WPS is prohibited
  ///@deprecated This is deprecated
  static const WPS_WEP_PROHIBITED = 4;

  static final _id_getConfiguredNetworks = jniAccessors.getMethodIDOf(
      _classRef, "getConfiguredNetworks", "()Ljava/util/List;");

  /// from: public java.util.List<android.net.wifi.WifiConfiguration> getConfiguredNetworks()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a list of all the networks configured for the current foreground
  /// user.
  /// Not all fields of WifiConfiguration are returned. Only the following
  /// fields are filled in:
  /// <ul>
  /// <li>networkId</li>
  /// <li>SSID</li>
  /// <li>BSSID</li>
  /// <li>priority</li>
  /// <li>allowedProtocols</li>
  /// <li>allowedKeyManagement</li>
  /// <li>allowedAuthAlgorithms</li>
  /// <li>allowedPairwiseCiphers</li>
  /// <li>allowedGroupCiphers</li>
  /// </ul>
  ///@return a list of network configurations in the form of a list
  /// of WifiConfiguration objects.
  jni.JniObject getConfiguredNetworks() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getConfiguredNetworks, jni.JniType.objectType, []).object);

  static final _id_addNetwork = jniAccessors.getMethodIDOf(
      _classRef, "addNetwork", "(Landroid/net/wifi/WifiConfiguration;)I");

  /// from: public int addNetwork(android.net.wifi.WifiConfiguration config)
  ///
  /// Add a new network description to the set of configured networks.
  /// The {@code networkId} field of the supplied configuration object
  /// is ignored.
  /// <p/>
  /// The new network will be marked DISABLED by default. To enable it,
  /// called \#enableNetwork.
  ///@param config the set of variables that describe the configuration,
  ///            contained in a WifiConfiguration object.
  ///            If the WifiConfiguration has an Http Proxy set
  ///            the calling app must be System, or be provisioned as the Profile or Device Owner.
  ///@return the ID of the newly created network description. This is used in
  ///         other operations to specified the network to be acted upon.
  ///         Returns {@code -1} on failure.
  int addNetwork(wificonfiguration_.WifiConfiguration config) =>
      jniAccessors.callMethodWithArgs(reference, _id_addNetwork,
          jni.JniType.intType, [config.reference]).integer;

  static final _id_updateNetwork = jniAccessors.getMethodIDOf(
      _classRef, "updateNetwork", "(Landroid/net/wifi/WifiConfiguration;)I");

  /// from: public int updateNetwork(android.net.wifi.WifiConfiguration config)
  ///
  /// Update the network description of an existing configured network.
  ///@param config the set of variables that describe the configuration,
  ///            contained in a WifiConfiguration object. It may
  ///            be sparse, so that only the items that are being changed
  ///            are non-<code>null</code>. The {@code networkId} field
  ///            must be set to the ID of the existing network being updated.
  ///            If the WifiConfiguration has an Http Proxy set
  ///            the calling app must be System, or be provisioned as the Profile or Device Owner.
  ///@return Returns the {@code networkId} of the supplied
  ///         {@code WifiConfiguration} on success.
  ///         <br/>
  ///         Returns {@code -1} on failure, including when the {@code networkId}
  ///         field of the {@code WifiConfiguration} does not refer to an
  ///         existing network.
  int updateNetwork(wificonfiguration_.WifiConfiguration config) =>
      jniAccessors.callMethodWithArgs(reference, _id_updateNetwork,
          jni.JniType.intType, [config.reference]).integer;

  static final _id_addOrUpdatePasspointConfiguration =
      jniAccessors.getMethodIDOf(_classRef, "addOrUpdatePasspointConfiguration",
          "(Landroid/net/wifi/hotspot2/PasspointConfiguration;)V");

  /// from: public void addOrUpdatePasspointConfiguration(android.net.wifi.hotspot2.PasspointConfiguration config)
  ///
  /// Add or update a Passpoint configuration.  The configuration provides a credential
  /// for connecting to Passpoint networks that are operated by the Passpoint
  /// service provider specified in the configuration.
  ///
  /// Each configuration is uniquely identified by its FQDN (Fully Qualified Domain
  /// Name).  In the case when there is an existing configuration with the same
  /// FQDN, the new configuration will replace the existing configuration.
  ///@param config The Passpoint configuration to be added
  ///@throws IllegalArgumentException if configuration is invalid
  ///@throws UnsupportedOperationException if Passpoint is not enabled on the device.
  void addOrUpdatePasspointConfiguration(
          passpointconfiguration_.PasspointConfiguration config) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOrUpdatePasspointConfiguration,
          jni.JniType.voidType,
          [config.reference]).check();

  static final _id_removePasspointConfiguration = jniAccessors.getMethodIDOf(
      _classRef, "removePasspointConfiguration", "(Ljava/lang/String;)V");

  /// from: public void removePasspointConfiguration(java.lang.String fqdn)
  ///
  /// Remove the Passpoint configuration identified by its FQDN (Fully Qualified Domain Name).
  ///@param fqdn The FQDN of the Passpoint configuration to be removed
  ///@throws IllegalArgumentException if no configuration is associated with the given FQDN.
  ///@throws UnsupportedOperationException if Passpoint is not enabled on the device.
  void removePasspointConfiguration(jni.JniString fqdn) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removePasspointConfiguration,
          jni.JniType.voidType,
          [fqdn.reference]).check();

  static final _id_getPasspointConfigurations = jniAccessors.getMethodIDOf(
      _classRef, "getPasspointConfigurations", "()Ljava/util/List;");

  /// from: public java.util.List<android.net.wifi.hotspot2.PasspointConfiguration> getPasspointConfigurations()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the list of installed Passpoint configurations.
  ///
  /// An empty list will be returned when no configurations are installed.
  ///@return A list of PasspointConfiguration
  ///@throws UnsupportedOperationException if Passpoint is not enabled on the device.
  jni.JniObject getPasspointConfigurations() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getPasspointConfigurations, jni.JniType.objectType, []).object);

  static final _id_removeNetwork =
      jniAccessors.getMethodIDOf(_classRef, "removeNetwork", "(I)Z");

  /// from: public boolean removeNetwork(int netId)
  ///
  /// Remove the specified network from the list of configured networks.
  /// This may result in the asynchronous delivery of state change
  /// events.
  ///
  /// Applications are not allowed to remove networks created by other
  /// applications.
  ///@param netId the ID of the network as returned by \#addNetwork or \#getConfiguredNetworks.
  ///@return {@code true} if the operation succeeded
  bool removeNetwork(int netId) => jniAccessors.callMethodWithArgs(
      reference, _id_removeNetwork, jni.JniType.booleanType, [netId]).boolean;

  static final _id_enableNetwork =
      jniAccessors.getMethodIDOf(_classRef, "enableNetwork", "(IZ)Z");

  /// from: public boolean enableNetwork(int netId, boolean attemptConnect)
  ///
  /// Allow a previously configured network to be associated with. If
  /// <code>attemptConnect</code> is true, an attempt to connect to the selected
  /// network is initiated. This may result in the asynchronous delivery
  /// of state change events.
  ///
  /// __Note:__ If an application's target SDK version is
  /// android.os.Build.VERSION_CODES\#LOLLIPOP or newer, network
  /// communication may not use Wi-Fi even if Wi-Fi is connected; traffic may
  /// instead be sent through another network, such as cellular data,
  /// Bluetooth tethering, or Ethernet. For example, traffic will never use a
  /// Wi-Fi network that does not provide Internet access (e.g. a wireless
  /// printer), if another network that does offer Internet access (e.g.
  /// cellular data) is available. Applications that need to ensure that their
  /// network traffic uses Wi-Fi should use APIs such as
  /// Network\#bindSocket(java.net.Socket),
  /// Network\#openConnection(java.net.URL), or
  /// ConnectivityManager\#bindProcessToNetwork to do so.
  ///
  /// Applications are not allowed to enable networks created by other
  /// applications.
  ///@param netId the ID of the network as returned by \#addNetwork or \#getConfiguredNetworks.
  ///@param attemptConnect The way to select a particular network to connect to is specify
  ///        {@code true} for this parameter.
  ///@return {@code true} if the operation succeeded
  bool enableNetwork(int netId, bool attemptConnect) =>
      jniAccessors.callMethodWithArgs(reference, _id_enableNetwork,
          jni.JniType.booleanType, [netId, attemptConnect]).boolean;

  static final _id_disableNetwork =
      jniAccessors.getMethodIDOf(_classRef, "disableNetwork", "(I)Z");

  /// from: public boolean disableNetwork(int netId)
  ///
  /// Disable a configured network. The specified network will not be
  /// a candidate for associating. This may result in the asynchronous
  /// delivery of state change events.
  ///
  /// Applications are not allowed to disable networks created by other
  /// applications.
  ///@param netId the ID of the network as returned by \#addNetwork or \#getConfiguredNetworks.
  ///@return {@code true} if the operation succeeded
  bool disableNetwork(int netId) => jniAccessors.callMethodWithArgs(
      reference, _id_disableNetwork, jni.JniType.booleanType, [netId]).boolean;

  static final _id_disconnect =
      jniAccessors.getMethodIDOf(_classRef, "disconnect", "()Z");

  /// from: public boolean disconnect()
  ///
  /// Disassociate from the currently active access point. This may result
  /// in the asynchronous delivery of state change events.
  ///@return {@code true} if the operation succeeded
  bool disconnect() => jniAccessors.callMethodWithArgs(
      reference, _id_disconnect, jni.JniType.booleanType, []).boolean;

  static final _id_reconnect =
      jniAccessors.getMethodIDOf(_classRef, "reconnect", "()Z");

  /// from: public boolean reconnect()
  ///
  /// Reconnect to the currently active access point, if we are currently
  /// disconnected. This may result in the asynchronous delivery of state
  /// change events.
  ///@return {@code true} if the operation succeeded
  bool reconnect() => jniAccessors.callMethodWithArgs(
      reference, _id_reconnect, jni.JniType.booleanType, []).boolean;

  static final _id_reassociate =
      jniAccessors.getMethodIDOf(_classRef, "reassociate", "()Z");

  /// from: public boolean reassociate()
  ///
  /// Reconnect to the currently active access point, even if we are already
  /// connected. This may result in the asynchronous delivery of state
  /// change events.
  ///@return {@code true} if the operation succeeded
  bool reassociate() => jniAccessors.callMethodWithArgs(
      reference, _id_reassociate, jni.JniType.booleanType, []).boolean;

  static final _id_pingSupplicant =
      jniAccessors.getMethodIDOf(_classRef, "pingSupplicant", "()Z");

  /// from: public boolean pingSupplicant()
  ///
  /// Check that the supplicant daemon is responding to requests.
  ///@return {@code true} if we were able to communicate with the supplicant and
  /// it returned the expected response to the PING message.
  ///@deprecated Will return the output of \#isWifiEnabled() instead.
  bool pingSupplicant() => jniAccessors.callMethodWithArgs(
      reference, _id_pingSupplicant, jni.JniType.booleanType, []).boolean;

  static final _id_is5GHzBandSupported =
      jniAccessors.getMethodIDOf(_classRef, "is5GHzBandSupported", "()Z");

  /// from: public boolean is5GHzBandSupported()
  ///
  /// @return true if this adapter supports 5 GHz band
  bool is5GHzBandSupported() => jniAccessors.callMethodWithArgs(
      reference, _id_is5GHzBandSupported, jni.JniType.booleanType, []).boolean;

  static final _id_isP2pSupported =
      jniAccessors.getMethodIDOf(_classRef, "isP2pSupported", "()Z");

  /// from: public boolean isP2pSupported()
  ///
  /// @return true if this adapter supports WifiP2pManager (Wi-Fi Direct)
  bool isP2pSupported() => jniAccessors.callMethodWithArgs(
      reference, _id_isP2pSupported, jni.JniType.booleanType, []).boolean;

  static final _id_isDeviceToApRttSupported =
      jniAccessors.getMethodIDOf(_classRef, "isDeviceToApRttSupported", "()Z");

  /// from: public boolean isDeviceToApRttSupported()
  ///
  /// @return true if this adapter supports Device-to-AP RTT
  bool isDeviceToApRttSupported() => jniAccessors.callMethodWithArgs(reference,
      _id_isDeviceToApRttSupported, jni.JniType.booleanType, []).boolean;

  static final _id_isPreferredNetworkOffloadSupported = jniAccessors
      .getMethodIDOf(_classRef, "isPreferredNetworkOffloadSupported", "()Z");

  /// from: public boolean isPreferredNetworkOffloadSupported()
  ///
  /// @return true if this adapter supports offloaded connectivity scan
  bool isPreferredNetworkOffloadSupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isPreferredNetworkOffloadSupported,
      jni.JniType.booleanType, []).boolean;

  static final _id_isTdlsSupported =
      jniAccessors.getMethodIDOf(_classRef, "isTdlsSupported", "()Z");

  /// from: public boolean isTdlsSupported()
  ///
  /// @return true if this adapter supports Tunnel Directed Link Setup
  bool isTdlsSupported() => jniAccessors.callMethodWithArgs(
      reference, _id_isTdlsSupported, jni.JniType.booleanType, []).boolean;

  static final _id_isEnhancedPowerReportingSupported = jniAccessors
      .getMethodIDOf(_classRef, "isEnhancedPowerReportingSupported", "()Z");

  /// from: public boolean isEnhancedPowerReportingSupported()
  ///
  /// @return true if this adapter supports advanced power/performance counters
  bool isEnhancedPowerReportingSupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isEnhancedPowerReportingSupported,
      jni.JniType.booleanType, []).boolean;

  static final _id_startScan =
      jniAccessors.getMethodIDOf(_classRef, "startScan", "()Z");

  /// from: public boolean startScan()
  ///
  /// Request a scan for access points. Returns immediately. The availability
  /// of the results is made known later by means of an asynchronous event sent
  /// on completion of the scan.
  ///
  /// To initiate a Wi-Fi scan, declare the
  /// android.Manifest.permission\#CHANGE_WIFI_STATE
  /// permission in the manifest, and perform these steps:
  ///
  ///
  /// <ol style="1">
  /// <li>Invoke the following method:
  /// {@code ((WifiManager) getSystemService(WIFI_SERVICE)).startScan()}</li>
  /// <li>
  /// Register a BroadcastReceiver to listen to
  /// {@code SCAN_RESULTS_AVAILABLE_ACTION}.</li>
  /// <li>When a broadcast is received, call:
  /// {@code ((WifiManager) getSystemService(WIFI_SERVICE)).getScanResults()}</li>
  /// </ol>
  ///@return {@code true} if the operation succeeded, i.e., the scan was initiated.
  ///@deprecated The ability for apps to trigger scan requests will be removed in a future
  /// release.
  bool startScan() => jniAccessors.callMethodWithArgs(
      reference, _id_startScan, jni.JniType.booleanType, []).boolean;

  static final _id_getConnectionInfo = jniAccessors.getMethodIDOf(
      _classRef, "getConnectionInfo", "()Landroid/net/wifi/WifiInfo;");

  /// from: public android.net.wifi.WifiInfo getConnectionInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return dynamic information about the current Wi-Fi connection, if any is active.
  ///
  /// In the connected state, access to the SSID and BSSID requires
  /// the same permissions as \#getScanResults. If such access is not allowed,
  /// WifiInfo\#getSSID will return {@code "<unknown ssid>"} and
  /// WifiInfo\#getBSSID will return {@code "02:00:00:00:00:00"}.
  ///@return the Wi-Fi information, contained in WifiInfo.
  wifiinfo_.WifiInfo getConnectionInfo() =>
      wifiinfo_.WifiInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getConnectionInfo, jni.JniType.objectType, []).object);

  static final _id_getScanResults = jniAccessors.getMethodIDOf(
      _classRef, "getScanResults", "()Ljava/util/List;");

  /// from: public java.util.List<android.net.wifi.ScanResult> getScanResults()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the results of the latest access point scan.
  ///@return the list of access points found in the most recent scan. An app must hold
  /// android.Manifest.permission\#ACCESS_COARSE_LOCATION ACCESS_COARSE_LOCATION or
  /// android.Manifest.permission\#ACCESS_FINE_LOCATION ACCESS_FINE_LOCATION permission
  /// in order to get valid results.  If there is a remote exception (e.g., either a communication
  /// problem with the system service or an exception within the framework) an empty list will be
  /// returned.
  jni.JniObject getScanResults() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getScanResults, jni.JniType.objectType, []).object);

  static final _id_isScanAlwaysAvailable =
      jniAccessors.getMethodIDOf(_classRef, "isScanAlwaysAvailable", "()Z");

  /// from: public boolean isScanAlwaysAvailable()
  ///
  /// Check if scanning is always available.
  ///
  /// If this return {@code true}, apps can issue \#startScan and fetch scan results
  /// even when Wi-Fi is turned off.
  ///
  /// To change this setting, see \#ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE.
  bool isScanAlwaysAvailable() => jniAccessors.callMethodWithArgs(reference,
      _id_isScanAlwaysAvailable, jni.JniType.booleanType, []).boolean;

  static final _id_saveConfiguration =
      jniAccessors.getMethodIDOf(_classRef, "saveConfiguration", "()Z");

  /// from: public boolean saveConfiguration()
  ///
  /// Tell the device to persist the current list of configured networks.
  ///
  /// Note: It is possible for this method to change the network IDs of
  /// existing networks. You should assume the network IDs can be different
  /// after calling this method.
  ///@return {@code false} Will always return true.
  ///@deprecated There is no need to call this method -
  /// \#addNetwork(WifiConfiguration), \#updateNetwork(WifiConfiguration)
  /// and \#removeNetwork(int) already persist the configurations automatically.
  bool saveConfiguration() => jniAccessors.callMethodWithArgs(
      reference, _id_saveConfiguration, jni.JniType.booleanType, []).boolean;

  static final _id_getDhcpInfo = jniAccessors.getMethodIDOf(
      _classRef, "getDhcpInfo", "()Landroid/net/DhcpInfo;");

  /// from: public android.net.DhcpInfo getDhcpInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the DHCP-assigned addresses from the last successful DHCP request,
  /// if any.
  ///@return the DHCP information
  dhcpinfo_.DhcpInfo getDhcpInfo() =>
      dhcpinfo_.DhcpInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDhcpInfo, jni.JniType.objectType, []).object);

  static final _id_setWifiEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setWifiEnabled", "(Z)Z");

  /// from: public boolean setWifiEnabled(boolean enabled)
  ///
  /// Enable or disable Wi-Fi.
  ///
  /// Applications must have the android.Manifest.permission\#CHANGE_WIFI_STATE
  /// permission to toggle wifi.
  ///@param enabled {@code true} to enable, {@code false} to disable.
  ///@return {@code false} if the request cannot be satisfied; {@code true} indicates that wifi is
  ///         either already in the requested state, or in progress toward the requested state.
  ///@throws  java.lang.SecurityException if the caller is missing required permissions.
  bool setWifiEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setWifiEnabled,
      jni.JniType.booleanType,
      [enabled]).boolean;

  static final _id_getWifiState =
      jniAccessors.getMethodIDOf(_classRef, "getWifiState", "()I");

  /// from: public int getWifiState()
  ///
  /// Gets the Wi-Fi enabled state.
  ///@return One of \#WIFI_STATE_DISABLED,
  ///         \#WIFI_STATE_DISABLING, \#WIFI_STATE_ENABLED,
  ///         \#WIFI_STATE_ENABLING, \#WIFI_STATE_UNKNOWN
  ///@see \#isWifiEnabled()
  int getWifiState() => jniAccessors.callMethodWithArgs(
      reference, _id_getWifiState, jni.JniType.intType, []).integer;

  static final _id_isWifiEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isWifiEnabled", "()Z");

  /// from: public boolean isWifiEnabled()
  ///
  /// Return whether Wi-Fi is enabled or disabled.
  ///@return {@code true} if Wi-Fi is enabled
  ///@see \#getWifiState()
  bool isWifiEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isWifiEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_calculateSignalLevel = jniAccessors.getStaticMethodIDOf(
      _classRef, "calculateSignalLevel", "(II)I");

  /// from: static public int calculateSignalLevel(int rssi, int numLevels)
  ///
  /// Calculates the level of the signal. This should be used any time a signal
  /// is being shown.
  ///@param rssi The power of the signal measured in RSSI.
  ///@param numLevels The number of levels to consider in the calculated
  ///            level.
  ///@return A level of the signal, given in the range of 0 to numLevels-1
  ///         (both inclusive).
  static int calculateSignalLevel(int rssi, int numLevels) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_calculateSignalLevel,
          jni.JniType.intType, [rssi, numLevels]).integer;

  static final _id_compareSignalLevel = jniAccessors.getStaticMethodIDOf(
      _classRef, "compareSignalLevel", "(II)I");

  /// from: static public int compareSignalLevel(int rssiA, int rssiB)
  ///
  /// Compares two signal strengths.
  ///@param rssiA The power of the first signal measured in RSSI.
  ///@param rssiB The power of the second signal measured in RSSI.
  ///@return Returns <0 if the first signal is weaker than the second signal,
  ///         0 if the two signals have the same strength, and >0 if the first
  ///         signal is stronger than the second signal.
  static int compareSignalLevel(int rssiA, int rssiB) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_compareSignalLevel,
          jni.JniType.intType, [rssiA, rssiB]).integer;

  static final _id_startLocalOnlyHotspot = jniAccessors.getMethodIDOf(
      _classRef,
      "startLocalOnlyHotspot",
      "(Landroid/net/wifi/WifiManager\$LocalOnlyHotspotCallback;Landroid/os/Handler;)V");

  /// from: public void startLocalOnlyHotspot(android.net.wifi.WifiManager.LocalOnlyHotspotCallback callback, android.os.Handler handler)
  ///
  /// Request a local only hotspot that an application can use to communicate between co-located
  /// devices connected to the created WiFi hotspot.  The network created by this method will not
  /// have Internet access.  Each application can make a single request for the hotspot, but
  /// multiple applications could be requesting the hotspot at the same time.  When multiple
  /// applications have successfully registered concurrently, they will be sharing the underlying
  /// hotspot. LocalOnlyHotspotCallback\#onStarted(LocalOnlyHotspotReservation) is called
  /// when the hotspot is ready for use by the application.
  ///
  /// Each application can make a single active call to this method. The LocalOnlyHotspotCallback\#onStarted(LocalOnlyHotspotReservation) callback supplies the
  /// requestor with a LocalOnlyHotspotReservation that contains a
  /// WifiConfiguration with the SSID, security type and credentials needed to connect
  /// to the hotspot.  Communicating this information is up to the application.
  ///
  /// If the LocalOnlyHotspot cannot be created, the LocalOnlyHotspotCallback\#onFailed(int)
  /// method will be called. Example failures include errors bringing up the network or if
  /// there is an incompatible operating mode.  For example, if the user is currently using Wifi
  /// Tethering to provide an upstream to another device, LocalOnlyHotspot will not start due to
  /// an incompatible mode. The possible error codes include:
  /// LocalOnlyHotspotCallback\#ERROR_NO_CHANNEL,
  /// LocalOnlyHotspotCallback\#ERROR_GENERIC,
  /// LocalOnlyHotspotCallback\#ERROR_INCOMPATIBLE_MODE and
  /// LocalOnlyHotspotCallback\#ERROR_TETHERING_DISALLOWED.
  ///
  /// Internally, requests will be tracked to prevent the hotspot from being torn down while apps
  /// are still using it.  The LocalOnlyHotspotReservation object passed in the  LocalOnlyHotspotCallback\#onStarted(LocalOnlyHotspotReservation) call should be closed when
  /// the LocalOnlyHotspot is no longer needed using LocalOnlyHotspotReservation\#close().
  /// Since the hotspot may be shared among multiple applications, removing the final registered
  /// application request will trigger the hotspot teardown.  This means that applications should
  /// not listen to broadcasts containing wifi state to determine if the hotspot was stopped after
  /// they are done using it. Additionally, once LocalOnlyHotspotReservation\#close() is
  /// called, applications will not receive callbacks of any kind.
  ///
  /// Applications should be aware that the user may also stop the LocalOnlyHotspot through the
  /// Settings UI; it is not guaranteed to stay up as long as there is a requesting application.
  /// The requestors will be notified of this case via
  /// LocalOnlyHotspotCallback\#onStopped().  Other cases may arise where the hotspot is
  /// torn down (Emergency mode, etc).  Application developers should be aware that it can stop
  /// unexpectedly, but they will receive a notification if they have properly registered.
  ///
  /// Applications should also be aware that this network will be shared with other applications.
  /// Applications are responsible for protecting their data on this network (e.g., TLS).
  ///
  /// Applications need to have the following permissions to start LocalOnlyHotspot: android.Manifest.permission\#CHANGE_WIFI_STATE and android.Manifest.permission\#ACCESS_COARSE_LOCATION ACCESS_COARSE_LOCATION.  Callers without
  /// the permissions will trigger a java.lang.SecurityException.
  ///
  ///@param callback LocalOnlyHotspotCallback for the application to receive updates about
  /// operating status.
  ///@param handler Handler to be used for callbacks.  If the caller passes a null Handler, the
  /// main thread will be used.
  ///
  /// This value may be {@code null}.
  void startLocalOnlyHotspot(WifiManager_LocalOnlyHotspotCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_startLocalOnlyHotspot,
          jni.JniType.voidType,
          [callback.reference, handler.reference]).check();

  static final _id_setTdlsEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setTdlsEnabled", "(Ljava/net/InetAddress;Z)V");

  /// from: public void setTdlsEnabled(java.net.InetAddress remoteIPAddress, boolean enable)
  ///
  /// Enable/Disable TDLS on a specific local route.
  ///
  ///
  /// TDLS enables two wireless endpoints to talk to each other directly
  /// without going through the access point that is managing the local
  /// network. It saves bandwidth and improves quality of the link.
  ///
  ///
  ///
  /// This API enables/disables the option of using TDLS. If enabled, the
  /// underlying hardware is free to use TDLS or a hop through the access
  /// point. If disabled, existing TDLS session is torn down and
  /// hardware is restricted to use access point for transferring wireless
  /// packets. Default value for all routes is 'disabled', meaning restricted
  /// to use access point for transferring packets.
  ///
  ///
  ///@param remoteIPAddress IP address of the endpoint to setup TDLS with
  ///@param enable true = setup and false = tear down TDLS
  void setTdlsEnabled(jni.JniObject remoteIPAddress, bool enable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTdlsEnabled,
          jni.JniType.voidType, [remoteIPAddress.reference, enable]).check();

  static final _id_setTdlsEnabledWithMacAddress = jniAccessors.getMethodIDOf(
      _classRef, "setTdlsEnabledWithMacAddress", "(Ljava/lang/String;Z)V");

  /// from: public void setTdlsEnabledWithMacAddress(java.lang.String remoteMacAddress, boolean enable)
  ///
  /// Similar to \#setTdlsEnabled(InetAddress, boolean), except
  /// this version allows you to specify remote endpoint with a MAC address.
  ///@param remoteMacAddress MAC address of the remote endpoint such as 00:00:0c:9f:f2:ab
  ///@param enable true = setup and false = tear down TDLS
  void setTdlsEnabledWithMacAddress(
          jni.JniString remoteMacAddress, bool enable) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setTdlsEnabledWithMacAddress,
          jni.JniType.voidType,
          [remoteMacAddress.reference, enable]).check();

  static final _id_startWps = jniAccessors.getMethodIDOf(_classRef, "startWps",
      "(Landroid/net/wifi/WpsInfo;Landroid/net/wifi/WifiManager\$WpsCallback;)V");

  /// from: public void startWps(android.net.wifi.WpsInfo config, android.net.wifi.WifiManager.WpsCallback listener)
  ///
  /// WPS suport has been deprecated from Client mode and this method will immediately trigger
  /// WpsCallback\#onFailed(int) with a generic error.
  ///@param config WPS configuration (does not support WpsInfo\#LABEL)
  ///@param listener for callbacks on success or failure. Can be null.
  ///@throws IllegalStateException if the WifiManager instance needs to be initialized again
  ///@deprecated This API is deprecated
  void startWps(wpsinfo_.WpsInfo config, WifiManager_WpsCallback listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_startWps,
          jni.JniType.voidType, [config.reference, listener.reference]).check();

  static final _id_cancelWps = jniAccessors.getMethodIDOf(
      _classRef, "cancelWps", "(Landroid/net/wifi/WifiManager\$WpsCallback;)V");

  /// from: public void cancelWps(android.net.wifi.WifiManager.WpsCallback listener)
  ///
  /// WPS support has been deprecated from Client mode and this method will immediately trigger
  /// WpsCallback\#onFailed(int) with a generic error.
  ///@param listener for callbacks on success or failure. Can be null.
  ///@throws IllegalStateException if the WifiManager instance needs to be initialized again
  ///@deprecated This API is deprecated
  void cancelWps(WifiManager_WpsCallback listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_cancelWps,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_createWifiLock = jniAccessors.getMethodIDOf(
      _classRef,
      "createWifiLock",
      "(ILjava/lang/String;)Landroid/net/wifi/WifiManager\$WifiLock;");

  /// from: public android.net.wifi.WifiManager.WifiLock createWifiLock(int lockType, java.lang.String tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new WifiLock.
  ///@param lockType the type of lock to create. See \#WIFI_MODE_FULL,
  /// \#WIFI_MODE_FULL_HIGH_PERF and \#WIFI_MODE_SCAN_ONLY for
  /// descriptions of the types of Wi-Fi locks.
  ///@param tag a tag for the WifiLock to identify it in debugging messages.  This string is
  ///            never shown to the user under normal conditions, but should be descriptive
  ///            enough to identify your application and the specific WifiLock within it, if it
  ///            holds multiple WifiLocks.
  ///@return a new, unacquired WifiLock with the given tag.
  ///@see WifiLock
  WifiManager_WifiLock createWifiLock(int lockType, jni.JniString tag) =>
      WifiManager_WifiLock.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createWifiLock,
          jni.JniType.objectType,
          [lockType, tag.reference]).object);

  static final _id_createWifiLock1 = jniAccessors.getMethodIDOf(
      _classRef,
      "createWifiLock",
      "(Ljava/lang/String;)Landroid/net/wifi/WifiManager\$WifiLock;");

  /// from: public android.net.wifi.WifiManager.WifiLock createWifiLock(java.lang.String tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new WifiLock.
  ///@param tag a tag for the WifiLock to identify it in debugging messages.  This string is
  ///            never shown to the user under normal conditions, but should be descriptive
  ///            enough to identify your application and the specific WifiLock within it, if it
  ///            holds multiple WifiLocks.
  ///@return a new, unacquired WifiLock with the given tag.
  ///@see WifiLock
  WifiManager_WifiLock createWifiLock1(jni.JniString tag) =>
      WifiManager_WifiLock.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_createWifiLock1, jni.JniType.objectType, [tag.reference]).object);

  static final _id_createMulticastLock = jniAccessors.getMethodIDOf(
      _classRef,
      "createMulticastLock",
      "(Ljava/lang/String;)Landroid/net/wifi/WifiManager\$MulticastLock;");

  /// from: public android.net.wifi.WifiManager.MulticastLock createMulticastLock(java.lang.String tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new MulticastLock
  ///@param tag a tag for the MulticastLock to identify it in debugging
  ///            messages.  This string is never shown to the user under
  ///            normal conditions, but should be descriptive enough to
  ///            identify your application and the specific MulticastLock
  ///            within it, if it holds multiple MulticastLocks.
  ///@return a new, unacquired MulticastLock with the given tag.
  ///@see MulticastLock
  WifiManager_MulticastLock createMulticastLock(jni.JniString tag) =>
      WifiManager_MulticastLock.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createMulticastLock,
          jni.JniType.objectType,
          [tag.reference]).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}

/// from: android.net.wifi.WifiManager$WpsCallback
///
/// Interface for callback invocation on a start WPS action
///@deprecated This is deprecated
class WifiManager_WpsCallback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/wifi/WifiManager\$WpsCallback");
  WifiManager_WpsCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WifiManager_WpsCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onStarted = jniAccessors.getMethodIDOf(
      _classRef, "onStarted", "(Ljava/lang/String;)V");

  /// from: public abstract void onStarted(java.lang.String pin)
  ///
  /// WPS start succeeded
  ///@deprecated This API is deprecated
  void onStarted(jni.JniString pin) => jniAccessors.callMethodWithArgs(
      reference, _id_onStarted, jni.JniType.voidType, [pin.reference]).check();

  static final _id_onSucceeded =
      jniAccessors.getMethodIDOf(_classRef, "onSucceeded", "()V");

  /// from: public abstract void onSucceeded()
  ///
  /// WPS operation completed successfully
  ///@deprecated This API is deprecated
  void onSucceeded() => jniAccessors.callMethodWithArgs(
      reference, _id_onSucceeded, jni.JniType.voidType, []).check();

  static final _id_onFailed =
      jniAccessors.getMethodIDOf(_classRef, "onFailed", "(I)V");

  /// from: public abstract void onFailed(int reason)
  ///
  /// WPS operation failed
  ///@param reason The reason for failure could be one of
  /// \#WPS_TKIP_ONLY_PROHIBITED, \#WPS_OVERLAP_ERROR,
  /// \#WPS_WEP_PROHIBITED, \#WPS_TIMED_OUT or \#WPS_AUTH_FAILURE
  /// and some generic errors.
  ///@deprecated This API is deprecated
  void onFailed(int reason) => jniAccessors.callMethodWithArgs(
      reference, _id_onFailed, jni.JniType.voidType, [reason]).check();
}

/// from: android.net.wifi.WifiManager$WifiLock
///
/// Allows an application to keep the Wi-Fi radio awake.
/// Normally the Wi-Fi radio may turn off when the user has not used the device in a while.
/// Acquiring a WifiLock will keep the radio on until the lock is released.  Multiple
/// applications may hold WifiLocks, and the radio will only be allowed to turn off when no
/// WifiLocks are held in any application.
///
/// Before using a WifiLock, consider carefully if your application requires Wi-Fi access, or
/// could function over a mobile network, if available.  A program that needs to download large
/// files should hold a WifiLock to ensure that the download will complete, but a program whose
/// network usage is occasional or low-bandwidth should not hold a WifiLock to avoid adversely
/// affecting battery life.
///
/// Note that WifiLocks cannot override the user-level "Wi-Fi Enabled" setting, nor Airplane
/// Mode.  They simply keep the radio from turning off when Wi-Fi is already on but the device
/// is idle.
///
/// Any application using a WifiLock must request the {@code android.permission.WAKE_LOCK}
/// permission in an {@code <uses-permission>} element of the application's manifest.
class WifiManager_WifiLock extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/wifi/WifiManager\$WifiLock");
  WifiManager_WifiLock.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_acquire =
      jniAccessors.getMethodIDOf(_classRef, "acquire", "()V");

  /// from: public void acquire()
  ///
  /// Locks the Wi-Fi radio on until \#release is called.
  ///
  /// If this WifiLock is reference-counted, each call to {@code acquire} will increment the
  /// reference count, and the radio will remain locked as long as the reference count is
  /// above zero.
  ///
  /// If this WifiLock is not reference-counted, the first call to {@code acquire} will lock
  /// the radio, but subsequent calls will be ignored.  Only one call to \#release
  /// will be required, regardless of the number of times that {@code acquire} is called.
  void acquire() => jniAccessors.callMethodWithArgs(
      reference, _id_acquire, jni.JniType.voidType, []).check();

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public void release()
  ///
  /// Unlocks the Wi-Fi radio, allowing it to turn off when the device is idle.
  ///
  /// If this WifiLock is reference-counted, each call to {@code release} will decrement the
  /// reference count, and the radio will be unlocked only when the reference count reaches
  /// zero.  If the reference count goes below zero (that is, if {@code release} is called
  /// a greater number of times than \#acquire), an exception is thrown.
  ///
  /// If this WifiLock is not reference-counted, the first call to {@code release} (after
  /// the radio was locked using \#acquire) will unlock the radio, and subsequent
  /// calls will be ignored.
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_setReferenceCounted =
      jniAccessors.getMethodIDOf(_classRef, "setReferenceCounted", "(Z)V");

  /// from: public void setReferenceCounted(boolean refCounted)
  ///
  /// Controls whether this is a reference-counted or non-reference-counted WifiLock.
  ///
  /// Reference-counted WifiLocks keep track of the number of calls to \#acquire and
  /// \#release, and only allow the radio to sleep when every call to \#acquire
  /// has been balanced with a call to \#release.  Non-reference-counted WifiLocks
  /// lock the radio whenever \#acquire is called and it is unlocked, and unlock the
  /// radio whenever \#release is called and it is locked.
  ///@param refCounted true if this WifiLock should keep a reference count
  void setReferenceCounted(bool refCounted) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setReferenceCounted,
      jni.JniType.voidType,
      [refCounted]).check();

  static final _id_isHeld =
      jniAccessors.getMethodIDOf(_classRef, "isHeld", "()Z");

  /// from: public boolean isHeld()
  ///
  /// Checks whether this WifiLock is currently held.
  ///@return true if this WifiLock is held, false otherwise
  bool isHeld() => jniAccessors.callMethodWithArgs(
      reference, _id_isHeld, jni.JniType.booleanType, []).boolean;

  static final _id_setWorkSource = jniAccessors.getMethodIDOf(
      _classRef, "setWorkSource", "(Landroid/os/WorkSource;)V");

  /// from: public void setWorkSource(android.os.WorkSource ws)
  void setWorkSource(worksource_.WorkSource ws) =>
      jniAccessors.callMethodWithArgs(reference, _id_setWorkSource,
          jni.JniType.voidType, [ws.reference]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}

/// from: android.net.wifi.WifiManager$MulticastLock
///
/// Allows an application to receive Wifi Multicast packets.
/// Normally the Wifi stack filters out packets not explicitly
/// addressed to this device.  Acquring a MulticastLock will
/// cause the stack to receive packets addressed to multicast
/// addresses.  Processing these extra packets can cause a noticeable
/// battery drain and should be disabled when not needed.
class WifiManager_MulticastLock extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/wifi/WifiManager\$MulticastLock");
  WifiManager_MulticastLock.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_acquire =
      jniAccessors.getMethodIDOf(_classRef, "acquire", "()V");

  /// from: public void acquire()
  ///
  /// Locks Wifi Multicast on until \#release is called.
  ///
  /// If this MulticastLock is reference-counted each call to
  /// {@code acquire} will increment the reference count, and the
  /// wifi interface will receive multicast packets as long as the
  /// reference count is above zero.
  ///
  /// If this MulticastLock is not reference-counted, the first call to
  /// {@code acquire} will turn on the multicast packets, but subsequent
  /// calls will be ignored.  Only one call to \#release will
  /// be required, regardless of the number of times that {@code acquire}
  /// is called.
  ///
  /// Note that other applications may also lock Wifi Multicast on.
  /// Only they can relinquish their lock.
  ///
  /// Also note that applications cannot leave Multicast locked on.
  /// When an app exits or crashes, any Multicast locks will be released.
  void acquire() => jniAccessors.callMethodWithArgs(
      reference, _id_acquire, jni.JniType.voidType, []).check();

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public void release()
  ///
  /// Unlocks Wifi Multicast, restoring the filter of packets
  /// not addressed specifically to this device and saving power.
  ///
  /// If this MulticastLock is reference-counted, each call to
  /// {@code release} will decrement the reference count, and the
  /// multicast packets will only stop being received when the reference
  /// count reaches zero.  If the reference count goes below zero (that
  /// is, if {@code release} is called a greater number of times than
  /// \#acquire), an exception is thrown.
  ///
  /// If this MulticastLock is not reference-counted, the first call to
  /// {@code release} (after the radio was multicast locked using
  /// \#acquire) will unlock the multicast, and subsequent calls
  /// will be ignored.
  ///
  /// Note that if any other Wifi Multicast Locks are still outstanding
  /// this {@code release} call will not have an immediate effect.  Only
  /// when all applications have released all their Multicast Locks will
  /// the Multicast filter be turned back on.
  ///
  /// Also note that when an app exits or crashes all of its Multicast
  /// Locks will be automatically released.
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_setReferenceCounted =
      jniAccessors.getMethodIDOf(_classRef, "setReferenceCounted", "(Z)V");

  /// from: public void setReferenceCounted(boolean refCounted)
  ///
  /// Controls whether this is a reference-counted or non-reference-
  /// counted MulticastLock.
  ///
  /// Reference-counted MulticastLocks keep track of the number of calls
  /// to \#acquire and \#release, and only stop the
  /// reception of multicast packets when every call to \#acquire
  /// has been balanced with a call to \#release.  Non-reference-
  /// counted MulticastLocks allow the reception of multicast packets
  /// whenever \#acquire is called and stop accepting multicast
  /// packets whenever \#release is called.
  ///@param refCounted true if this MulticastLock should keep a reference
  /// count
  void setReferenceCounted(bool refCounted) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setReferenceCounted,
      jni.JniType.voidType,
      [refCounted]).check();

  static final _id_isHeld =
      jniAccessors.getMethodIDOf(_classRef, "isHeld", "()Z");

  /// from: public boolean isHeld()
  ///
  /// Checks whether this MulticastLock is currently held.
  ///@return true if this MulticastLock is held, false otherwise
  bool isHeld() => jniAccessors.callMethodWithArgs(
      reference, _id_isHeld, jni.JniType.booleanType, []).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}

/// from: android.net.wifi.WifiManager$LocalOnlyHotspotReservation
///
/// LocalOnlyHotspotReservation that contains the WifiConfiguration for the active
/// LocalOnlyHotspot request.
///
/// Applications requesting LocalOnlyHotspot for sharing will receive an instance of the
/// LocalOnlyHotspotReservation in the
/// LocalOnlyHotspotCallback\#onStarted(LocalOnlyHotspotReservation) call.  This
/// reservation contains the relevant WifiConfiguration.
/// When an application is done with the LocalOnlyHotspot, they should call LocalOnlyHotspotReservation\#close().  Once this happens, the application will not receive
/// any further callbacks. If the LocalOnlyHotspot is stopped due to a
/// user triggered mode change, applications will be notified via the LocalOnlyHotspotCallback\#onStopped() callback.
class WifiManager_LocalOnlyHotspotReservation extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/net/wifi/WifiManager\$LocalOnlyHotspotReservation");
  WifiManager_LocalOnlyHotspotReservation.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_getWifiConfiguration = jniAccessors.getMethodIDOf(_classRef,
      "getWifiConfiguration", "()Landroid/net/wifi/WifiConfiguration;");

  /// from: public android.net.wifi.WifiConfiguration getWifiConfiguration()
  /// The returned object must be deleted after use, by calling the `delete` method.
  wificonfiguration_.WifiConfiguration getWifiConfiguration() =>
      wificonfiguration_.WifiConfiguration.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getWifiConfiguration,
              jni.JniType.objectType, []).object);

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}

/// from: android.net.wifi.WifiManager$LocalOnlyHotspotCallback
///
/// Callback class for applications to receive updates about the LocalOnlyHotspot status.
class WifiManager_LocalOnlyHotspotCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/net/wifi/WifiManager\$LocalOnlyHotspotCallback");
  WifiManager_LocalOnlyHotspotCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final int ERROR_GENERIC
  static const ERROR_GENERIC = 2;

  /// from: static public final int ERROR_INCOMPATIBLE_MODE
  static const ERROR_INCOMPATIBLE_MODE = 3;

  /// from: static public final int ERROR_NO_CHANNEL
  static const ERROR_NO_CHANNEL = 1;

  /// from: static public final int ERROR_TETHERING_DISALLOWED
  static const ERROR_TETHERING_DISALLOWED = 4;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WifiManager_LocalOnlyHotspotCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onStarted = jniAccessors.getMethodIDOf(
      _classRef,
      "onStarted",
      "(Landroid/net/wifi/WifiManager\$LocalOnlyHotspotReservation;)V");

  /// from: public void onStarted(android.net.wifi.WifiManager.LocalOnlyHotspotReservation reservation)
  ///
  /// LocalOnlyHotspot start succeeded.
  void onStarted(WifiManager_LocalOnlyHotspotReservation reservation) =>
      jniAccessors.callMethodWithArgs(reference, _id_onStarted,
          jni.JniType.voidType, [reservation.reference]).check();

  static final _id_onStopped =
      jniAccessors.getMethodIDOf(_classRef, "onStopped", "()V");

  /// from: public void onStopped()
  ///
  /// LocalOnlyHotspot stopped.
  ///
  /// The LocalOnlyHotspot can be disabled at any time by the user.  When this happens,
  /// applications will be notified that it was stopped. This will not be invoked when an
  /// application calls LocalOnlyHotspotReservation\#close().
  void onStopped() => jniAccessors.callMethodWithArgs(
      reference, _id_onStopped, jni.JniType.voidType, []).check();

  static final _id_onFailed =
      jniAccessors.getMethodIDOf(_classRef, "onFailed", "(I)V");

  /// from: public void onFailed(int reason)
  ///
  /// LocalOnlyHotspot failed to start.
  ///
  /// Applications can attempt to call
  /// WifiManager\#startLocalOnlyHotspot(LocalOnlyHotspotCallback, Handler) again at
  /// a later time.
  ///
  ///@param reason The reason for failure could be one of: \#ERROR_TETHERING_DISALLOWED, \#ERROR_INCOMPATIBLE_MODE,
  /// \#ERROR_NO_CHANNEL, or \#ERROR_GENERIC.
  void onFailed(int reason) => jniAccessors.callMethodWithArgs(
      reference, _id_onFailed, jni.JniType.voidType, [reason]).check();
}
