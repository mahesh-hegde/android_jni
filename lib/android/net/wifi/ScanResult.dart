// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/Parcel.dart" as parcel_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.wifi.ScanResult
///
/// Describes information about a detected access point. In addition
/// to the attributes described here, the supplicant keeps track of
/// {@code quality}, {@code noise}, and {@code maxbitrate} attributes,
/// but does not currently report them to external clients.
class ScanResult extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/wifi/ScanResult");
  ScanResult.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_BSSID =
      jniAccessors.getFieldIDOf(_classRef, "BSSID", "Ljava/lang/String;");

  /// from: public java.lang.String BSSID
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The address of the access point.
  jni.JniString get BSSID => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_BSSID, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String BSSID
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The address of the access point.
  set BSSID(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_BSSID, value.reference);

  /// from: static public final int CHANNEL_WIDTH_160MHZ
  ///
  /// AP Channel bandwidth is 160 MHZ
  static const CHANNEL_WIDTH_160MHZ = 3;

  /// from: static public final int CHANNEL_WIDTH_20MHZ
  ///
  /// AP Channel bandwidth is 20 MHZ
  static const CHANNEL_WIDTH_20MHZ = 0;

  /// from: static public final int CHANNEL_WIDTH_40MHZ
  ///
  /// AP Channel bandwidth is 40 MHZ
  static const CHANNEL_WIDTH_40MHZ = 1;

  /// from: static public final int CHANNEL_WIDTH_80MHZ
  ///
  /// AP Channel bandwidth is 80 MHZ
  static const CHANNEL_WIDTH_80MHZ = 2;

  /// from: static public final int CHANNEL_WIDTH_80MHZ_PLUS_MHZ
  ///
  /// AP Channel bandwidth is 160 MHZ, but 80MHZ + 80MHZ
  static const CHANNEL_WIDTH_80MHZ_PLUS_MHZ = 4;

  static final _id_SSID =
      jniAccessors.getFieldIDOf(_classRef, "SSID", "Ljava/lang/String;");

  /// from: public java.lang.String SSID
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The network name.
  jni.JniString get SSID => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_SSID, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String SSID
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The network name.
  set SSID(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_SSID, value.reference);

  static final _id_capabilities = jniAccessors.getFieldIDOf(
      _classRef, "capabilities", "Ljava/lang/String;");

  /// from: public java.lang.String capabilities
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Describes the authentication, key management, and encryption schemes
  /// supported by the access point.
  jni.JniString get capabilities => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_capabilities, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String capabilities
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Describes the authentication, key management, and encryption schemes
  /// supported by the access point.
  set capabilities(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_capabilities, value.reference);

  static final _id_centerFreq0 =
      jniAccessors.getFieldIDOf(_classRef, "centerFreq0", "I");

  /// from: public int centerFreq0
  ///
  /// Not used if the AP bandwidth is 20 MHz
  /// If the AP use 40, 80 or 160 MHz, this is the center frequency (in MHz)
  /// if the AP use 80 + 80 MHz, this is the center frequency of the first segment (in MHz)
  int get centerFreq0 => jniAccessors
      .getField(reference, _id_centerFreq0, jni.JniType.intType)
      .integer;

  /// from: public int centerFreq0
  ///
  /// Not used if the AP bandwidth is 20 MHz
  /// If the AP use 40, 80 or 160 MHz, this is the center frequency (in MHz)
  /// if the AP use 80 + 80 MHz, this is the center frequency of the first segment (in MHz)
  set centerFreq0(int value) =>
      jniEnv.SetIntField(reference, _id_centerFreq0, value);

  static final _id_centerFreq1 =
      jniAccessors.getFieldIDOf(_classRef, "centerFreq1", "I");

  /// from: public int centerFreq1
  ///
  /// Only used if the AP bandwidth is 80 + 80 MHz
  /// if the AP use 80 + 80 MHz, this is the center frequency of the second segment (in MHz)
  int get centerFreq1 => jniAccessors
      .getField(reference, _id_centerFreq1, jni.JniType.intType)
      .integer;

  /// from: public int centerFreq1
  ///
  /// Only used if the AP bandwidth is 80 + 80 MHz
  /// if the AP use 80 + 80 MHz, this is the center frequency of the second segment (in MHz)
  set centerFreq1(int value) =>
      jniEnv.SetIntField(reference, _id_centerFreq1, value);

  static final _id_channelWidth =
      jniAccessors.getFieldIDOf(_classRef, "channelWidth", "I");

  /// from: public int channelWidth
  ///
  /// AP Channel bandwidth; one of \#CHANNEL_WIDTH_20MHZ, \#CHANNEL_WIDTH_40MHZ,
  /// \#CHANNEL_WIDTH_80MHZ, \#CHANNEL_WIDTH_160MHZ
  /// or \#CHANNEL_WIDTH_80MHZ_PLUS_MHZ.
  int get channelWidth => jniAccessors
      .getField(reference, _id_channelWidth, jni.JniType.intType)
      .integer;

  /// from: public int channelWidth
  ///
  /// AP Channel bandwidth; one of \#CHANNEL_WIDTH_20MHZ, \#CHANNEL_WIDTH_40MHZ,
  /// \#CHANNEL_WIDTH_80MHZ, \#CHANNEL_WIDTH_160MHZ
  /// or \#CHANNEL_WIDTH_80MHZ_PLUS_MHZ.
  set channelWidth(int value) =>
      jniEnv.SetIntField(reference, _id_channelWidth, value);

  static final _id_frequency =
      jniAccessors.getFieldIDOf(_classRef, "frequency", "I");

  /// from: public int frequency
  ///
  /// The primary 20 MHz frequency (in MHz) of the channel over which the client is communicating
  /// with the access point.
  int get frequency => jniAccessors
      .getField(reference, _id_frequency, jni.JniType.intType)
      .integer;

  /// from: public int frequency
  ///
  /// The primary 20 MHz frequency (in MHz) of the channel over which the client is communicating
  /// with the access point.
  set frequency(int value) =>
      jniEnv.SetIntField(reference, _id_frequency, value);

  static final _id_level = jniAccessors.getFieldIDOf(_classRef, "level", "I");

  /// from: public int level
  ///
  /// The detected signal level in dBm, also known as the RSSI.
  ///
  /// Use android.net.wifi.WifiManager\#calculateSignalLevel to convert this number into
  /// an absolute signal level which can be displayed to a user.
  int get level =>
      jniAccessors.getField(reference, _id_level, jni.JniType.intType).integer;

  /// from: public int level
  ///
  /// The detected signal level in dBm, also known as the RSSI.
  ///
  /// Use android.net.wifi.WifiManager\#calculateSignalLevel to convert this number into
  /// an absolute signal level which can be displayed to a user.
  set level(int value) => jniEnv.SetIntField(reference, _id_level, value);

  static final _id_operatorFriendlyName = jniAccessors.getFieldIDOf(
      _classRef, "operatorFriendlyName", "Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence operatorFriendlyName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates Passpoint operator name published by access point.
  jni.JniObject get operatorFriendlyName => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_operatorFriendlyName, jni.JniType.objectType)
      .object);

  /// from: public java.lang.CharSequence operatorFriendlyName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates Passpoint operator name published by access point.
  set operatorFriendlyName(jni.JniObject value) => jniEnv.SetObjectField(
      reference, _id_operatorFriendlyName, value.reference);

  static final _id_timestamp =
      jniAccessors.getFieldIDOf(_classRef, "timestamp", "J");

  /// from: public long timestamp
  ///
  /// timestamp in microseconds (since boot) when
  /// this result was last seen.
  int get timestamp => jniAccessors
      .getField(reference, _id_timestamp, jni.JniType.longType)
      .long;

  /// from: public long timestamp
  ///
  /// timestamp in microseconds (since boot) when
  /// this result was last seen.
  set timestamp(int value) =>
      jniEnv.SetLongField(reference, _id_timestamp, value);

  static final _id_venueName = jniAccessors.getFieldIDOf(
      _classRef, "venueName", "Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence venueName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates venue name (such as 'San Francisco Airport') published by access point; only
  /// available on Passpoint network and if published by access point.
  jni.JniObject get venueName => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_venueName, jni.JniType.objectType)
      .object);

  /// from: public java.lang.CharSequence venueName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates venue name (such as 'San Francisco Airport') published by access point; only
  /// available on Passpoint network and if published by access point.
  set venueName(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_venueName, value.reference);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// empty scan result
  ///
  /// {@hide }
  ScanResult()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_is80211mcResponder =
      jniAccessors.getMethodIDOf(_classRef, "is80211mcResponder", "()Z");

  /// from: public boolean is80211mcResponder()
  bool is80211mcResponder() => jniAccessors.callMethodWithArgs(
      reference, _id_is80211mcResponder, jni.JniType.booleanType, []).boolean;

  static final _id_isPasspointNetwork =
      jniAccessors.getMethodIDOf(_classRef, "isPasspointNetwork", "()Z");

  /// from: public boolean isPasspointNetwork()
  bool isPasspointNetwork() => jniAccessors.callMethodWithArgs(
      reference, _id_isPasspointNetwork, jni.JniType.booleanType, []).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  ///
  /// Implement the Parcelable interface {@hide }
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  ///
  /// Implement the Parcelable interface {@hide }
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}
