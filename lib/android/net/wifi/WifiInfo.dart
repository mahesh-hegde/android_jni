// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "SupplicantState.dart" as supplicantstate_;

import "../NetworkInfo.dart" as networkinfo_;

import "../../os/Parcel.dart" as parcel_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.wifi.WifiInfo
///
/// Describes the state of any Wifi connection that is active or
/// is in the process of being set up.
class WifiInfo extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/net/wifi/WifiInfo");
  WifiInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String FREQUENCY_UNITS
  ///
  /// Frequency in MHz
  static const FREQUENCY_UNITS = "MHz";

  /// from: static public final java.lang.String LINK_SPEED_UNITS
  ///
  /// Link speed in Mbps
  static const LINK_SPEED_UNITS = "Mbps";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  WifiInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getSSID =
      jniAccessors.getMethodIDOf(_classRef, "getSSID", "()Ljava/lang/String;");

  /// from: public java.lang.String getSSID()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the service set identifier (SSID) of the current 802.11 network.
  /// If the SSID can be decoded as UTF-8, it will be returned surrounded by double
  /// quotation marks. Otherwise, it is returned as a string of hex digits. The
  /// SSID may be &lt;unknown ssid&gt; if there is no network currently connected,
  /// or if the caller has insufficient permissions to access the SSID.
  ///
  /// Prior to android.os.Build.VERSION_CODES\#JELLY_BEAN_MR1, this method
  /// always returned the SSID with no quotes around it.
  ///@return the SSID
  jni.JniString getSSID() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSSID, jni.JniType.objectType, []).object);

  static final _id_getBSSID =
      jniAccessors.getMethodIDOf(_classRef, "getBSSID", "()Ljava/lang/String;");

  /// from: public java.lang.String getBSSID()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the basic service set identifier (BSSID) of the current access point.
  /// The BSSID may be {@code null} if there is no network currently connected.
  ///@return the BSSID, in the form of a six-byte MAC address: {@code XX:XX:XX:XX:XX:XX}
  jni.JniString getBSSID() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBSSID, jni.JniType.objectType, []).object);

  static final _id_getRssi =
      jniAccessors.getMethodIDOf(_classRef, "getRssi", "()I");

  /// from: public int getRssi()
  ///
  /// Returns the received signal strength indicator of the current 802.11
  /// network, in dBm.
  ///
  /// Use android.net.wifi.WifiManager\#calculateSignalLevel to convert this number into
  /// an absolute signal level which can be displayed to a user.
  ///@return the RSSI.
  int getRssi() => jniAccessors.callMethodWithArgs(
      reference, _id_getRssi, jni.JniType.intType, []).integer;

  static final _id_getLinkSpeed =
      jniAccessors.getMethodIDOf(_classRef, "getLinkSpeed", "()I");

  /// from: public int getLinkSpeed()
  ///
  /// Returns the current link speed in \#LINK_SPEED_UNITS.
  ///@return the link speed.
  ///@see \#LINK_SPEED_UNITS
  int getLinkSpeed() => jniAccessors.callMethodWithArgs(
      reference, _id_getLinkSpeed, jni.JniType.intType, []).integer;

  static final _id_getFrequency =
      jniAccessors.getMethodIDOf(_classRef, "getFrequency", "()I");

  /// from: public int getFrequency()
  ///
  /// Returns the current frequency in \#FREQUENCY_UNITS.
  ///@return the frequency.
  ///@see \#FREQUENCY_UNITS
  int getFrequency() => jniAccessors.callMethodWithArgs(
      reference, _id_getFrequency, jni.JniType.intType, []).integer;

  static final _id_getMacAddress = jniAccessors.getMethodIDOf(
      _classRef, "getMacAddress", "()Ljava/lang/String;");

  /// from: public java.lang.String getMacAddress()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getMacAddress() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMacAddress, jni.JniType.objectType, []).object);

  static final _id_getNetworkId =
      jniAccessors.getMethodIDOf(_classRef, "getNetworkId", "()I");

  /// from: public int getNetworkId()
  ///
  /// Each configured network has a unique small integer ID, used to identify
  /// the network when performing operations on the supplicant. This method
  /// returns the ID for the currently connected network.
  ///@return the network ID, or -1 if there is no currently connected network
  int getNetworkId() => jniAccessors.callMethodWithArgs(
      reference, _id_getNetworkId, jni.JniType.intType, []).integer;

  static final _id_getSupplicantState = jniAccessors.getMethodIDOf(
      _classRef, "getSupplicantState", "()Landroid/net/wifi/SupplicantState;");

  /// from: public android.net.wifi.SupplicantState getSupplicantState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the detailed state of the supplicant's negotiation with an
  /// access point, in the form of a SupplicantState SupplicantState object.
  ///@return the current SupplicantState SupplicantState
  supplicantstate_.SupplicantState getSupplicantState() =>
      supplicantstate_.SupplicantState.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSupplicantState,
          jni.JniType.objectType, []).object);

  static final _id_getIpAddress =
      jniAccessors.getMethodIDOf(_classRef, "getIpAddress", "()I");

  /// from: public int getIpAddress()
  int getIpAddress() => jniAccessors.callMethodWithArgs(
      reference, _id_getIpAddress, jni.JniType.intType, []).integer;

  static final _id_getHiddenSSID =
      jniAccessors.getMethodIDOf(_classRef, "getHiddenSSID", "()Z");

  /// from: public boolean getHiddenSSID()
  ///
  /// @return {@code true} if this network does not broadcast its SSID, so an
  /// SSID-specific probe request must be used for scans.
  bool getHiddenSSID() => jniAccessors.callMethodWithArgs(
      reference, _id_getHiddenSSID, jni.JniType.booleanType, []).boolean;

  static final _id_getDetailedStateOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getDetailedStateOf",
      "(Landroid/net/wifi/SupplicantState;)Landroid/net/NetworkInfo\$DetailedState;");

  /// from: static public android.net.NetworkInfo.DetailedState getDetailedStateOf(android.net.wifi.SupplicantState suppState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Map a supplicant state into a fine-grained network connectivity state.
  ///@param suppState the supplicant state
  ///@return the corresponding DetailedState
  static networkinfo_.NetworkInfo_DetailedState getDetailedStateOf(
          supplicantstate_.SupplicantState suppState) =>
      networkinfo_.NetworkInfo_DetailedState.fromRef(jniAccessors
          .callStaticMethodWithArgs(_classRef, _id_getDetailedStateOf,
              jni.JniType.objectType, [suppState.reference]).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  ///
  /// Implement the Parcelable interface {@hide }
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  ///
  /// Implement the Parcelable interface {@hide }
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}
