// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/Parcelable.dart" as parcelable_;

import "../../os/Parcel.dart" as parcel_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.wifi.WifiEnterpriseConfig
///
/// Enterprise configuration details for Wi-Fi. Stores details about the EAP method
/// and any associated credentials.
class WifiEnterpriseConfig extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/wifi/WifiEnterpriseConfig");
  WifiEnterpriseConfig.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.net.wifi.WifiEnterpriseConfig> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WifiEnterpriseConfig()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/net/wifi/WifiEnterpriseConfig;)V");

  /// from: public void <init>(android.net.wifi.WifiEnterpriseConfig source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copy constructor.
  /// This copies over all the fields verbatim (does not ignore masked password fields).
  ///@param source Source WifiEnterpriseConfig object.
  WifiEnterpriseConfig.ctor1(WifiEnterpriseConfig source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [source.reference]).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_setEapMethod =
      jniAccessors.getMethodIDOf(_classRef, "setEapMethod", "(I)V");

  /// from: public void setEapMethod(int eapMethod)
  ///
  /// Set the EAP authentication method.
  ///@param eapMethod is one Eap\#PEAP, Eap\#TLS, Eap\#TTLS or
  ///                   Eap\#PWD
  ///@throws IllegalArgumentException on an invalid eap method
  void setEapMethod(int eapMethod) => jniAccessors.callMethodWithArgs(
      reference, _id_setEapMethod, jni.JniType.voidType, [eapMethod]).check();

  static final _id_getEapMethod =
      jniAccessors.getMethodIDOf(_classRef, "getEapMethod", "()I");

  /// from: public int getEapMethod()
  ///
  /// Get the eap method.
  ///@return eap method configured
  int getEapMethod() => jniAccessors.callMethodWithArgs(
      reference, _id_getEapMethod, jni.JniType.intType, []).integer;

  static final _id_setPhase2Method =
      jniAccessors.getMethodIDOf(_classRef, "setPhase2Method", "(I)V");

  /// from: public void setPhase2Method(int phase2Method)
  ///
  /// Set Phase 2 authentication method. Sets the inner authentication method to be used in
  /// phase 2 after setting up a secure channel
  ///@param phase2Method is the inner authentication method and can be one of Phase2\#NONE,
  ///                     Phase2\#PAP, Phase2\#MSCHAP, Phase2\#MSCHAPV2,
  ///                     Phase2\#GTC
  ///@throws IllegalArgumentException on an invalid phase2 method
  void setPhase2Method(int phase2Method) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setPhase2Method,
      jni.JniType.voidType,
      [phase2Method]).check();

  static final _id_getPhase2Method =
      jniAccessors.getMethodIDOf(_classRef, "getPhase2Method", "()I");

  /// from: public int getPhase2Method()
  ///
  /// Get the phase 2 authentication method.
  ///@return a phase 2 method defined at Phase2
  int getPhase2Method() => jniAccessors.callMethodWithArgs(
      reference, _id_getPhase2Method, jni.JniType.intType, []).integer;

  static final _id_setIdentity = jniAccessors.getMethodIDOf(
      _classRef, "setIdentity", "(Ljava/lang/String;)V");

  /// from: public void setIdentity(java.lang.String identity)
  ///
  /// Set the identity
  ///@param identity
  void setIdentity(jni.JniString identity) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setIdentity,
      jni.JniType.voidType,
      [identity.reference]).check();

  static final _id_getIdentity = jniAccessors.getMethodIDOf(
      _classRef, "getIdentity", "()Ljava/lang/String;");

  /// from: public java.lang.String getIdentity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the identity
  ///@return the identity
  jni.JniString getIdentity() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIdentity, jni.JniType.objectType, []).object);

  static final _id_setAnonymousIdentity = jniAccessors.getMethodIDOf(
      _classRef, "setAnonymousIdentity", "(Ljava/lang/String;)V");

  /// from: public void setAnonymousIdentity(java.lang.String anonymousIdentity)
  ///
  /// Set anonymous identity. This is used as the unencrypted identity with
  /// certain EAP types
  ///@param anonymousIdentity the anonymous identity
  void setAnonymousIdentity(jni.JniString anonymousIdentity) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAnonymousIdentity,
          jni.JniType.voidType, [anonymousIdentity.reference]).check();

  static final _id_getAnonymousIdentity = jniAccessors.getMethodIDOf(
      _classRef, "getAnonymousIdentity", "()Ljava/lang/String;");

  /// from: public java.lang.String getAnonymousIdentity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the anonymous identity
  ///@return anonymous identity
  jni.JniString getAnonymousIdentity() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAnonymousIdentity, jni.JniType.objectType, []).object);

  static final _id_setPassword = jniAccessors.getMethodIDOf(
      _classRef, "setPassword", "(Ljava/lang/String;)V");

  /// from: public void setPassword(java.lang.String password)
  ///
  /// Set the password.
  ///@param password the password
  void setPassword(jni.JniString password) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setPassword,
      jni.JniType.voidType,
      [password.reference]).check();

  static final _id_getPassword = jniAccessors.getMethodIDOf(
      _classRef, "getPassword", "()Ljava/lang/String;");

  /// from: public java.lang.String getPassword()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the password.
  ///
  /// Returns locally set password value. For networks fetched from
  /// framework, returns "*".
  jni.JniString getPassword() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPassword, jni.JniType.objectType, []).object);

  static final _id_setCaCertificate = jniAccessors.getMethodIDOf(
      _classRef, "setCaCertificate", "(Ljava/security/cert/X509Certificate;)V");

  /// from: public void setCaCertificate(java.security.cert.X509Certificate cert)
  ///
  /// Specify a X.509 certificate that identifies the server.
  ///
  /// A default name is automatically assigned to the certificate and used
  /// with this configuration. The framework takes care of installing the
  /// certificate when the config is saved and removing the certificate when
  /// the config is removed.
  ///@param cert X.509 CA certificate
  /// This value may be {@code null}.
  ///@throws IllegalArgumentException if not a CA certificate
  void setCaCertificate(jni.JniObject cert) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setCaCertificate,
      jni.JniType.voidType,
      [cert.reference]).check();

  static final _id_getCaCertificate = jniAccessors.getMethodIDOf(
      _classRef, "getCaCertificate", "()Ljava/security/cert/X509Certificate;");

  /// from: public java.security.cert.X509Certificate getCaCertificate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get CA certificate. If multiple CA certificates are configured previously,
  /// return the first one.
  ///@return X.509 CA certificate
  ///
  /// This value may be {@code null}.
  jni.JniObject getCaCertificate() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCaCertificate, jni.JniType.objectType, []).object);

  static final _id_setCaCertificates = jniAccessors.getMethodIDOf(_classRef,
      "setCaCertificates", "([Ljava/security/cert/X509Certificate;)V");

  /// from: public void setCaCertificates(java.security.cert.X509Certificate[] certs)
  ///
  /// Specify a list of X.509 certificates that identifies the server. The validation
  /// passes if the CA of server certificate matches one of the given certificates.
  ///
  /// Default names are automatically assigned to the certificates and used
  /// with this configuration. The framework takes care of installing the
  /// certificates when the config is saved and removing the certificates when
  /// the config is removed.
  ///@param certs X.509 CA certificates
  /// This value may be {@code null}.
  ///@throws IllegalArgumentException if any of the provided certificates is
  ///     not a CA certificate
  void setCaCertificates(jni.JniObject certs) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCaCertificates,
          jni.JniType.voidType, [certs.reference]).check();

  static final _id_getCaCertificates = jniAccessors.getMethodIDOf(_classRef,
      "getCaCertificates", "()[Ljava/security/cert/X509Certificate;");

  /// from: public java.security.cert.X509Certificate[] getCaCertificates()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get CA certificates.
  ///@return This value may be {@code null}.
  jni.JniObject getCaCertificates() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCaCertificates, jni.JniType.objectType, []).object);

  static final _id_setClientKeyEntry = jniAccessors.getMethodIDOf(
      _classRef,
      "setClientKeyEntry",
      "(Ljava/security/PrivateKey;Ljava/security/cert/X509Certificate;)V");

  /// from: public void setClientKeyEntry(java.security.PrivateKey privateKey, java.security.cert.X509Certificate clientCertificate)
  ///
  /// Specify a private key and client certificate for client authorization.
  ///
  /// A default name is automatically assigned to the key entry and used
  /// with this configuration.  The framework takes care of installing the
  /// key entry when the config is saved and removing the key entry when
  /// the config is removed.
  ///@param privateKey a PrivateKey instance for the end certificate.
  ///@param clientCertificate an X509Certificate representing the end certificate.
  ///@throws IllegalArgumentException for an invalid key or certificate.
  void setClientKeyEntry(
          jni.JniObject privateKey, jni.JniObject clientCertificate) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setClientKeyEntry,
          jni.JniType.voidType,
          [privateKey.reference, clientCertificate.reference]).check();

  static final _id_setClientKeyEntryWithCertificateChain =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setClientKeyEntryWithCertificateChain",
          "(Ljava/security/PrivateKey;[Ljava/security/cert/X509Certificate;)V");

  /// from: public void setClientKeyEntryWithCertificateChain(java.security.PrivateKey privateKey, java.security.cert.X509Certificate[] clientCertificateChain)
  ///
  /// Specify a private key and client certificate chain for client authorization.
  ///
  /// A default name is automatically assigned to the key entry and used
  /// with this configuration.  The framework takes care of installing the
  /// key entry when the config is saved and removing the key entry when
  /// the config is removed.
  ///@param privateKey a PrivateKey instance for the end certificate.
  ///@param clientCertificateChain an array of X509Certificate instances which starts with
  ///         end certificate and continues with additional CA certificates necessary to
  ///         link the end certificate with some root certificate known by the authenticator.
  ///@throws IllegalArgumentException for an invalid key or certificate.
  void setClientKeyEntryWithCertificateChain(
          jni.JniObject privateKey, jni.JniObject clientCertificateChain) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setClientKeyEntryWithCertificateChain,
          jni.JniType.voidType,
          [privateKey.reference, clientCertificateChain.reference]).check();

  static final _id_getClientCertificate = jniAccessors.getMethodIDOf(_classRef,
      "getClientCertificate", "()Ljava/security/cert/X509Certificate;");

  /// from: public java.security.cert.X509Certificate getClientCertificate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get client certificate
  ///@return X.509 client certificate
  jni.JniObject getClientCertificate() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getClientCertificate, jni.JniType.objectType, []).object);

  static final _id_getClientCertificateChain = jniAccessors.getMethodIDOf(
      _classRef,
      "getClientCertificateChain",
      "()[Ljava/security/cert/X509Certificate;");

  /// from: public java.security.cert.X509Certificate[] getClientCertificateChain()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the complete client certificate chain in the same order as it was last supplied.
  ///
  /// If the chain was last supplied by a call to
  /// \#setClientKeyEntry(java.security.PrivateKey, java.security.cert.X509Certificate)
  /// with a non-null * certificate instance, a single-element array containing the certificate
  /// will be * returned. If \#setClientKeyEntryWithCertificateChain(
  /// java.security.PrivateKey, java.security.cert.X509Certificate[]) was last called with a
  /// non-empty array, this array will be returned in the same order as it was supplied.
  /// Otherwise, {@code null} will be returned.
  ///@return X.509 client certificates
  jni.JniObject getClientCertificateChain() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getClientCertificateChain, jni.JniType.objectType, []).object);

  static final _id_setSubjectMatch = jniAccessors.getMethodIDOf(
      _classRef, "setSubjectMatch", "(Ljava/lang/String;)V");

  /// from: public void setSubjectMatch(java.lang.String subjectMatch)
  ///
  /// Set subject match (deprecated). This is the substring to be matched against the subject of
  /// the authentication server certificate.
  ///@param subjectMatch substring to be matched
  ///@deprecated in favor of altSubjectMatch
  void setSubjectMatch(jni.JniString subjectMatch) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSubjectMatch,
          jni.JniType.voidType, [subjectMatch.reference]).check();

  static final _id_getSubjectMatch = jniAccessors.getMethodIDOf(
      _classRef, "getSubjectMatch", "()Ljava/lang/String;");

  /// from: public java.lang.String getSubjectMatch()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get subject match (deprecated)
  ///@return the subject match string
  ///@deprecated in favor of altSubjectMatch
  jni.JniString getSubjectMatch() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSubjectMatch, jni.JniType.objectType, []).object);

  static final _id_setAltSubjectMatch = jniAccessors.getMethodIDOf(
      _classRef, "setAltSubjectMatch", "(Ljava/lang/String;)V");

  /// from: public void setAltSubjectMatch(java.lang.String altSubjectMatch)
  ///
  /// Set alternate subject match. This is the substring to be matched against the
  /// alternate subject of the authentication server certificate.
  ///@param altSubjectMatch substring to be matched, for example
  ///                     DNS:server.example.com;EMAIL:server@example.com
  void setAltSubjectMatch(jni.JniString altSubjectMatch) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAltSubjectMatch,
          jni.JniType.voidType, [altSubjectMatch.reference]).check();

  static final _id_getAltSubjectMatch = jniAccessors.getMethodIDOf(
      _classRef, "getAltSubjectMatch", "()Ljava/lang/String;");

  /// from: public java.lang.String getAltSubjectMatch()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get alternate subject match
  ///@return the alternate subject match string
  jni.JniString getAltSubjectMatch() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAltSubjectMatch, jni.JniType.objectType, []).object);

  static final _id_setDomainSuffixMatch = jniAccessors.getMethodIDOf(
      _classRef, "setDomainSuffixMatch", "(Ljava/lang/String;)V");

  /// from: public void setDomainSuffixMatch(java.lang.String domain)
  ///
  /// Set the domain_suffix_match directive on wpa_supplicant. This is the parameter to use
  /// for Hotspot 2.0 defined matching of AAA server certs per WFA HS2.0 spec, section 7.3.3.2,
  /// second paragraph.
  ///
  /// From wpa_supplicant documentation:
  /// Constraint for server domain name. If set, this FQDN is used as a suffix match requirement
  /// for the AAAserver certificate in SubjectAltName dNSName element(s). If a matching dNSName is
  /// found, this constraint is met.
  /// Suffix match here means that the host/domain name is compared one label at a time starting
  /// from the top-level domain and all the labels in domain_suffix_match shall be included in the
  /// certificate. The certificate may include additional sub-level labels in addition to the
  /// required labels.
  /// For example, domain_suffix_match=example.com would match test.example.com but would not
  /// match test-example.com.
  ///@param domain The domain value
  void setDomainSuffixMatch(jni.JniString domain) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDomainSuffixMatch,
          jni.JniType.voidType, [domain.reference]).check();

  static final _id_getDomainSuffixMatch = jniAccessors.getMethodIDOf(
      _classRef, "getDomainSuffixMatch", "()Ljava/lang/String;");

  /// from: public java.lang.String getDomainSuffixMatch()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the domain_suffix_match value. See setDomSuffixMatch.
  ///@return The domain value.
  jni.JniString getDomainSuffixMatch() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDomainSuffixMatch, jni.JniType.objectType, []).object);

  static final _id_setRealm = jniAccessors.getMethodIDOf(
      _classRef, "setRealm", "(Ljava/lang/String;)V");

  /// from: public void setRealm(java.lang.String realm)
  ///
  /// Set realm for Passpoint credential; realm identifies a set of networks where your
  /// Passpoint credential can be used
  ///@param realm the realm
  void setRealm(jni.JniString realm) => jniAccessors.callMethodWithArgs(
      reference, _id_setRealm, jni.JniType.voidType, [realm.reference]).check();

  static final _id_getRealm =
      jniAccessors.getMethodIDOf(_classRef, "getRealm", "()Ljava/lang/String;");

  /// from: public java.lang.String getRealm()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get realm for Passpoint credential; see \#setRealm(String) for more information
  ///@return the realm
  jni.JniString getRealm() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRealm, jni.JniType.objectType, []).object);

  static final _id_setPlmn =
      jniAccessors.getMethodIDOf(_classRef, "setPlmn", "(Ljava/lang/String;)V");

  /// from: public void setPlmn(java.lang.String plmn)
  ///
  /// Set plmn (Public Land Mobile Network) of the provider of Passpoint credential
  ///@param plmn the plmn value derived from mcc (mobile country code) & mnc (mobile network code)
  void setPlmn(jni.JniString plmn) => jniAccessors.callMethodWithArgs(
      reference, _id_setPlmn, jni.JniType.voidType, [plmn.reference]).check();

  static final _id_getPlmn =
      jniAccessors.getMethodIDOf(_classRef, "getPlmn", "()Ljava/lang/String;");

  /// from: public java.lang.String getPlmn()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get plmn (Public Land Mobile Network) for Passpoint credential; see \#setPlmn (String) for more information
  ///@return the plmn
  jni.JniString getPlmn() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPlmn, jni.JniType.objectType, []).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.net.wifi.WifiEnterpriseConfig$Phase2
///
/// The inner authentication method used
class WifiEnterpriseConfig_Phase2 extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/wifi/WifiEnterpriseConfig\$Phase2");
  WifiEnterpriseConfig_Phase2.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int AKA
  ///
  /// EAP-Authentication and Key Agreement [RFC-4187]
  static const AKA = 6;

  /// from: static public final int AKA_PRIME
  ///
  /// EAP-Authentication and Key Agreement Prime [RFC-5448]
  static const AKA_PRIME = 7;

  /// from: static public final int GTC
  ///
  /// Generic Token Card
  static const GTC = 4;

  /// from: static public final int MSCHAP
  ///
  /// Microsoft Challenge Handshake Authentication Protocol
  static const MSCHAP = 2;

  /// from: static public final int MSCHAPV2
  ///
  /// Microsoft Challenge Handshake Authentication Protocol v2
  static const MSCHAPV2 = 3;

  /// from: static public final int NONE
  static const NONE = 0;

  /// from: static public final int PAP
  ///
  /// Password Authentication Protocol
  static const PAP = 1;

  /// from: static public final int SIM
  ///
  /// EAP-Subscriber Identity Module [RFC-4186]
  static const SIM = 5;
}

/// from: android.net.wifi.WifiEnterpriseConfig$Eap
///
/// The Extensible Authentication Protocol method used
class WifiEnterpriseConfig_Eap extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/wifi/WifiEnterpriseConfig\$Eap");
  WifiEnterpriseConfig_Eap.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int AKA
  ///
  /// EAP-Authentication and Key Agreement [RFC-4187]
  static const AKA = 5;

  /// from: static public final int AKA_PRIME
  ///
  /// EAP-Authentication and Key Agreement Prime [RFC-5448]
  static const AKA_PRIME = 6;

  /// from: static public final int NONE
  ///
  /// No EAP method used. Represents an empty config
  static const NONE = -1;

  /// from: static public final int PEAP
  ///
  /// Protected EAP
  static const PEAP = 0;

  /// from: static public final int PWD
  ///
  /// EAP-Password
  static const PWD = 3;

  /// from: static public final int SIM
  ///
  /// EAP-Subscriber Identity Module [RFC-4186]
  static const SIM = 4;

  /// from: static public final int TLS
  ///
  /// EAP-Transport Layer Security
  static const TLS = 1;

  /// from: static public final int TTLS
  ///
  /// EAP-Tunneled Transport Layer Security
  static const TTLS = 2;

  /// from: static public final int UNAUTH_TLS
  ///
  /// Hotspot 2.0 r2 OSEN
  static const UNAUTH_TLS = 7;
}
