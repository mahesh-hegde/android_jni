// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "RtpStream.dart" as rtpstream_;

import "AudioGroup.dart" as audiogroup_;

import "AudioCodec.dart" as audiocodec_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.rtp.AudioStream
///
/// An AudioStream is a RtpStream which carrys audio payloads over
/// Real-time Transport Protocol (RTP). Two different classes are developed in
/// order to support various usages such as audio conferencing. An AudioStream
/// represents a remote endpoint which consists of a network mapping and a
/// configured AudioCodec. On the other side, An AudioGroup
/// represents a local endpoint which mixes all the AudioStreams and optionally
/// interacts with the speaker and the microphone at the same time. The simplest
/// usage includes one for each endpoints. For other combinations, developers
/// should be aware of the limitations described in AudioGroup.
///
/// An AudioStream becomes busy when it joins an AudioGroup. In this case most
/// of the setter methods are disabled. This is designed to ease the task of
/// managing native resources. One can always make an AudioStream leave its
/// AudioGroup by calling \#join(AudioGroup) with {@code null} and put it
/// back after the modification is done.
///
///
/// <p class="note">Using this class requires
/// android.Manifest.permission\#INTERNET permission.
///
///@see RtpStream
///@see AudioGroup
class AudioStream extends rtpstream_.RtpStream {
  static final _classRef =
      jniAccessors.getClassOf("android/net/rtp/AudioStream");
  AudioStream.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/net/InetAddress;)V");

  /// from: public void <init>(java.net.InetAddress address)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an AudioStream on the given local address. Note that the local
  /// port is assigned automatically to conform with RFC 3550.
  ///@param address The network address of the local host to bind to.
  ///@throws SocketException if the address cannot be bound or a problem
  ///     occurs during binding.
  AudioStream(jni.JniObject address)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [address.reference]).object);

  static final _id_isBusy =
      jniAccessors.getMethodIDOf(_classRef, "isBusy", "()Z");

  /// from: public final boolean isBusy()
  ///
  /// Returns {@code true} if the stream has already joined an
  /// AudioGroup.
  bool isBusy() => jniAccessors.callMethodWithArgs(
      reference, _id_isBusy, jni.JniType.booleanType, []).boolean;

  static final _id_getGroup = jniAccessors.getMethodIDOf(
      _classRef, "getGroup", "()Landroid/net/rtp/AudioGroup;");

  /// from: public android.net.rtp.AudioGroup getGroup()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the joined AudioGroup.
  audiogroup_.AudioGroup getGroup() =>
      audiogroup_.AudioGroup.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getGroup, jni.JniType.objectType, []).object);

  static final _id_join = jniAccessors.getMethodIDOf(
      _classRef, "join", "(Landroid/net/rtp/AudioGroup;)V");

  /// from: public void join(android.net.rtp.AudioGroup group)
  ///
  /// Joins an AudioGroup. Each stream can join only one group at a
  /// time. The group can be changed by passing a different one or removed
  /// by calling this method with {@code null}.
  ///@param group The AudioGroup to join or {@code null} to leave.
  ///@throws IllegalStateException if the stream is not properly configured.
  ///@see AudioGroup
  void join(audiogroup_.AudioGroup group) => jniAccessors.callMethodWithArgs(
      reference, _id_join, jni.JniType.voidType, [group.reference]).check();

  static final _id_getCodec = jniAccessors.getMethodIDOf(
      _classRef, "getCodec", "()Landroid/net/rtp/AudioCodec;");

  /// from: public android.net.rtp.AudioCodec getCodec()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the AudioCodec, or {@code null} if it is not set.
  ///@see \#setCodec(AudioCodec)
  audiocodec_.AudioCodec getCodec() =>
      audiocodec_.AudioCodec.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCodec, jni.JniType.objectType, []).object);

  static final _id_setCodec = jniAccessors.getMethodIDOf(
      _classRef, "setCodec", "(Landroid/net/rtp/AudioCodec;)V");

  /// from: public void setCodec(android.net.rtp.AudioCodec codec)
  ///
  /// Sets the AudioCodec.
  ///@param codec The AudioCodec to be used.
  ///@throws IllegalArgumentException if its type is used by DTMF.
  ///@throws IllegalStateException if the stream is busy.
  void setCodec(audiocodec_.AudioCodec codec) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCodec,
          jni.JniType.voidType, [codec.reference]).check();

  static final _id_getDtmfType =
      jniAccessors.getMethodIDOf(_classRef, "getDtmfType", "()I");

  /// from: public int getDtmfType()
  ///
  /// Returns the RTP payload type for dual-tone multi-frequency (DTMF) digits,
  /// or {@code -1} if it is not enabled.
  ///@see \#setDtmfType(int)
  int getDtmfType() => jniAccessors.callMethodWithArgs(
      reference, _id_getDtmfType, jni.JniType.intType, []).integer;

  static final _id_setDtmfType =
      jniAccessors.getMethodIDOf(_classRef, "setDtmfType", "(I)V");

  /// from: public void setDtmfType(int type)
  ///
  /// Sets the RTP payload type for dual-tone multi-frequency (DTMF) digits.
  /// The primary usage is to send digits to the remote gateway to perform
  /// certain tasks, such as second-stage dialing. According to RFC 2833, the
  /// RTP payload type for DTMF is assigned dynamically, so it must be in the
  /// range of 96 and 127. One can use {@code -1} to disable DTMF and free up
  /// the previous assigned type. This method cannot be called when the stream
  /// already joined an AudioGroup.
  ///@param type The RTP payload type to be used or {@code -1} to disable it.
  ///@throws IllegalArgumentException if the type is invalid or used by codec.
  ///@throws IllegalStateException if the stream is busy.
  ///@see AudioGroup\#sendDtmf(int)
  void setDtmfType(int type) => jniAccessors.callMethodWithArgs(
      reference, _id_setDtmfType, jni.JniType.voidType, [type]).check();
}
