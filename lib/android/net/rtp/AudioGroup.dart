// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.rtp.AudioGroup
///
/// An AudioGroup is an audio hub for the speaker, the microphone, and
/// AudioStreams. Each of these components can be logically turned on
/// or off by calling \#setMode(int) or RtpStream\#setMode(int).
/// The AudioGroup will go through these components and process them one by one
/// within its execution loop. The loop consists of four steps. First, for each
/// AudioStream not in RtpStream\#MODE_SEND_ONLY, decodes its incoming
/// packets and stores in its buffer. Then, if the microphone is enabled,
/// processes the recorded audio and stores in its buffer. Third, if the speaker
/// is enabled, mixes all AudioStream buffers and plays back. Finally, for each
/// AudioStream not in RtpStream\#MODE_RECEIVE_ONLY, mixes all other
/// buffers and sends back the encoded packets. An AudioGroup does nothing if
/// there is no AudioStream in it.
///
/// Few things must be noticed before using these classes. The performance is
/// highly related to the system load and the network bandwidth. Usually a
/// simpler AudioCodec costs fewer CPU cycles but requires more network
/// bandwidth, and vise versa. Using two AudioStreams at the same time doubles
/// not only the load but also the bandwidth. The condition varies from one
/// device to another, and developers should choose the right combination in
/// order to get the best result.
///
///
/// It is sometimes useful to keep multiple AudioGroups at the same time. For
/// example, a Voice over IP (VoIP) application might want to put a conference
/// call on hold in order to make a new call but still allow people in the
/// conference call talking to each other. This can be done easily using two
/// AudioGroups, but there are some limitations. Since the speaker and the
/// microphone are globally shared resources, only one AudioGroup at a time is
/// allowed to run in a mode other than \#MODE_ON_HOLD. The others will
/// be unable to acquire these resources and fail silently.
///
///
/// <p class="note">Using this class requires
/// android.Manifest.permission\#RECORD_AUDIO permission. Developers
/// should set the audio mode to AudioManager\#MODE_IN_COMMUNICATION
/// using AudioManager\#setMode(int) and change it back when none of
/// the AudioGroups is in use.
///
///@see AudioStream
class AudioGroup extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/rtp/AudioGroup");
  AudioGroup.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int MODE_ECHO_SUPPRESSION
  ///
  /// This mode is similar to \#MODE_NORMAL except the echo suppression
  /// is enabled. It should be only used when the speaker phone is on.
  static const MODE_ECHO_SUPPRESSION = 3;

  /// from: static public final int MODE_MUTED
  ///
  /// This mode is similar to \#MODE_NORMAL except the microphone is
  /// disabled.
  static const MODE_MUTED = 1;

  /// from: static public final int MODE_NORMAL
  ///
  /// This mode indicates that the speaker, the microphone, and all
  /// AudioStreams in the group are enabled. First, the packets
  /// received from the streams are decoded and mixed with the audio recorded
  /// from the microphone. Then, the results are played back to the speaker,
  /// encoded and sent back to each stream.
  static const MODE_NORMAL = 2;

  /// from: static public final int MODE_ON_HOLD
  ///
  /// This mode is similar to \#MODE_NORMAL except the speaker and
  /// the microphone are both disabled.
  static const MODE_ON_HOLD = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an empty AudioGroup.
  AudioGroup()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getStreams = jniAccessors.getMethodIDOf(
      _classRef, "getStreams", "()[Landroid/net/rtp/AudioStream;");

  /// from: public android.net.rtp.AudioStream[] getStreams()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the AudioStreams in this group.
  jni.JniObject getStreams() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getStreams, jni.JniType.objectType, []).object);

  static final _id_getMode =
      jniAccessors.getMethodIDOf(_classRef, "getMode", "()I");

  /// from: public int getMode()
  ///
  /// Returns the current mode.
  int getMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getMode, jni.JniType.intType, []).integer;

  static final _id_setMode =
      jniAccessors.getMethodIDOf(_classRef, "setMode", "(I)V");

  /// from: public void setMode(int mode)
  ///
  /// Changes the current mode. It must be one of \#MODE_ON_HOLD,
  /// \#MODE_MUTED, \#MODE_NORMAL, and
  /// \#MODE_ECHO_SUPPRESSION.
  ///@param mode The mode to change to.
  ///@throws IllegalArgumentException if the mode is invalid.
  void setMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setMode, jni.JniType.voidType, [mode]).check();

  static final _id_sendDtmf =
      jniAccessors.getMethodIDOf(_classRef, "sendDtmf", "(I)V");

  /// from: public void sendDtmf(int event)
  ///
  /// Sends a DTMF digit to every AudioStream in this group. Currently
  /// only event {@code 0} to {@code 15} are supported.
  ///@throws IllegalArgumentException if the event is invalid.
  void sendDtmf(int event) => jniAccessors.callMethodWithArgs(
      reference, _id_sendDtmf, jni.JniType.voidType, [event]).check();

  static final _id_clear =
      jniAccessors.getMethodIDOf(_classRef, "clear", "()V");

  /// from: public void clear()
  ///
  /// Removes every AudioStream in this group.
  void clear() => jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}
