// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.rtp.RtpStream
///
/// RtpStream represents the base class of streams which send and receive network
/// packets with media payloads over Real-time Transport Protocol (RTP).
///
/// <p class="note">Using this class requires
/// android.Manifest.permission\#INTERNET permission.
///
class RtpStream extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/net/rtp/RtpStream");
  RtpStream.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int MODE_NORMAL
  ///
  /// This mode indicates that the stream sends and receives packets at the
  /// same time. This is the initial mode for new streams.
  static const MODE_NORMAL = 0;

  /// from: static public final int MODE_RECEIVE_ONLY
  ///
  /// This mode indicates that the stream only receives packets.
  static const MODE_RECEIVE_ONLY = 2;

  /// from: static public final int MODE_SEND_ONLY
  ///
  /// This mode indicates that the stream only sends packets.
  static const MODE_SEND_ONLY = 1;

  static final _id_getLocalAddress = jniAccessors.getMethodIDOf(
      _classRef, "getLocalAddress", "()Ljava/net/InetAddress;");

  /// from: public java.net.InetAddress getLocalAddress()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the network address of the local host.
  jni.JniObject getLocalAddress() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLocalAddress, jni.JniType.objectType, []).object);

  static final _id_getLocalPort =
      jniAccessors.getMethodIDOf(_classRef, "getLocalPort", "()I");

  /// from: public int getLocalPort()
  ///
  /// Returns the network port of the local host.
  int getLocalPort() => jniAccessors.callMethodWithArgs(
      reference, _id_getLocalPort, jni.JniType.intType, []).integer;

  static final _id_getRemoteAddress = jniAccessors.getMethodIDOf(
      _classRef, "getRemoteAddress", "()Ljava/net/InetAddress;");

  /// from: public java.net.InetAddress getRemoteAddress()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the network address of the remote host or {@code null} if the
  /// stream is not associated.
  jni.JniObject getRemoteAddress() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRemoteAddress, jni.JniType.objectType, []).object);

  static final _id_getRemotePort =
      jniAccessors.getMethodIDOf(_classRef, "getRemotePort", "()I");

  /// from: public int getRemotePort()
  ///
  /// Returns the network port of the remote host or {@code -1} if the stream
  /// is not associated.
  int getRemotePort() => jniAccessors.callMethodWithArgs(
      reference, _id_getRemotePort, jni.JniType.intType, []).integer;

  static final _id_isBusy =
      jniAccessors.getMethodIDOf(_classRef, "isBusy", "()Z");

  /// from: public boolean isBusy()
  ///
  /// Returns {@code true} if the stream is busy. In this case most of the
  /// setter methods are disabled. This method is intended to be overridden
  /// by subclasses.
  bool isBusy() => jniAccessors.callMethodWithArgs(
      reference, _id_isBusy, jni.JniType.booleanType, []).boolean;

  static final _id_getMode =
      jniAccessors.getMethodIDOf(_classRef, "getMode", "()I");

  /// from: public int getMode()
  ///
  /// Returns the current mode.
  int getMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getMode, jni.JniType.intType, []).integer;

  static final _id_setMode =
      jniAccessors.getMethodIDOf(_classRef, "setMode", "(I)V");

  /// from: public void setMode(int mode)
  ///
  /// Changes the current mode. It must be one of \#MODE_NORMAL,
  /// \#MODE_SEND_ONLY, and \#MODE_RECEIVE_ONLY.
  ///@param mode The mode to change to.
  ///@throws IllegalArgumentException if the mode is invalid.
  ///@throws IllegalStateException if the stream is busy.
  ///@see \#isBusy()
  void setMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setMode, jni.JniType.voidType, [mode]).check();

  static final _id_associate = jniAccessors.getMethodIDOf(
      _classRef, "associate", "(Ljava/net/InetAddress;I)V");

  /// from: public void associate(java.net.InetAddress address, int port)
  ///
  /// Associates with a remote host. This defines the destination of the
  /// outgoing packets.
  ///@param address The network address of the remote host.
  ///@param port The network port of the remote host.
  ///@throws IllegalArgumentException if the address is not supported or the
  ///     port is invalid.
  ///@throws IllegalStateException if the stream is busy.
  ///@see \#isBusy()
  void associate(jni.JniObject address, int port) =>
      jniAccessors.callMethodWithArgs(reference, _id_associate,
          jni.JniType.voidType, [address.reference, port]).check();

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public void release()
  ///
  /// Releases allocated resources. The stream becomes inoperable after calling
  /// this method.
  ///@throws IllegalStateException if the stream is busy.
  ///@see \#isBusy()
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}
