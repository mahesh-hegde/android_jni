// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "SSLSessionCache.dart" as sslsessioncache_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.SSLCertificateSocketFactory
///
/// SSLSocketFactory implementation with several extra features:
///
/// <ul>
/// <li>Timeout specification for SSL handshake operations
/// <li>Hostname verification in most cases (see WARNINGs below)
/// <li>Optional SSL session caching with SSLSessionCache
/// <li>Optionally bypass all SSL certificate checks
/// </ul>
///
/// The handshake timeout does not apply to actual TCP socket connection.
/// If you want a connection timeout as well, use \#createSocket()
/// and Socket\#connect(SocketAddress, int), after which you
/// must verify the identity of the server you are connected to.
///
/// <p class="caution">__Most SSLSocketFactory implementations do not
/// verify the server's identity, allowing man-in-the-middle attacks.__
/// This implementation does check the server's certificate hostname, but only
/// for createSocket variants that specify a hostname.  When using methods that
/// use InetAddress or which return an unconnected socket, you MUST
/// verify the server's identity yourself to ensure a secure connection.
///
/// Refer to
/// <a href="https://developer.android.com/training/articles/security-gms-provider.html">
/// Updating Your Security Provider to Protect Against SSL Exploits</a>
/// for further information.
///
///
/// One way to verify the server's identity is to use
/// HttpsURLConnection\#getDefaultHostnameVerifier() to get a
/// HostnameVerifier to verify the certificate hostname.
///
/// On development devices, "setprop socket.relaxsslcheck yes" bypasses all
/// SSL certificate and hostname checks for testing purposes.  This setting
/// requires root access.
class SSLCertificateSocketFactory extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/SSLCertificateSocketFactory");
  SSLCertificateSocketFactory.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int handshakeTimeoutMillis)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Use \#getDefault(int) instead.
  SSLCertificateSocketFactory(int handshakeTimeoutMillis)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [handshakeTimeoutMillis]).object);

  static final _id_getDefault = jniAccessors.getStaticMethodIDOf(
      _classRef, "getDefault", "(I)Ljavax/net/SocketFactory;");

  /// from: static public javax.net.SocketFactory getDefault(int handshakeTimeoutMillis)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a new socket factory instance with an optional handshake timeout.
  ///@param handshakeTimeoutMillis to use for SSL connection handshake, or 0
  ///         for none.  The socket timeout is reset to 0 after the handshake.
  ///@return a new SSLSocketFactory with the specified parameters
  static jni.JniObject getDefault(int handshakeTimeoutMillis) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getDefault,
          jni.JniType.objectType,
          [handshakeTimeoutMillis]).object);

  static final _id_getDefault1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getDefault",
      "(ILandroid/net/SSLSessionCache;)Ljavax/net/ssl/SSLSocketFactory;");

  /// from: static public javax.net.ssl.SSLSocketFactory getDefault(int handshakeTimeoutMillis, android.net.SSLSessionCache cache)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a new socket factory instance with an optional handshake timeout
  /// and SSL session cache.
  ///@param handshakeTimeoutMillis to use for SSL connection handshake, or 0
  ///         for none.  The socket timeout is reset to 0 after the handshake.
  ///@param cache The SSLSessionCache to use, or null for no cache.
  ///@return a new SSLSocketFactory with the specified parameters
  static jni.JniObject getDefault1(
          int handshakeTimeoutMillis, sslsessioncache_.SSLSessionCache cache) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getDefault1,
          jni.JniType.objectType,
          [handshakeTimeoutMillis, cache.reference]).object);

  static final _id_getInsecure = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getInsecure",
      "(ILandroid/net/SSLSessionCache;)Ljavax/net/ssl/SSLSocketFactory;");

  /// from: static public javax.net.ssl.SSLSocketFactory getInsecure(int handshakeTimeoutMillis, android.net.SSLSessionCache cache)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a new instance of a socket factory with all SSL security checks
  /// disabled, using an optional handshake timeout and SSL session cache.
  ///
  /// <p class="caution">__Warning:__ Sockets created using this factory
  /// are vulnerable to man-in-the-middle attacks!
  ///
  ///@param handshakeTimeoutMillis to use for SSL connection handshake, or 0
  ///         for none.  The socket timeout is reset to 0 after the handshake.
  ///@param cache The SSLSessionCache to use, or null for no cache.
  ///@return an insecure SSLSocketFactory with the specified parameters
  static jni.JniObject getInsecure(
          int handshakeTimeoutMillis, sslsessioncache_.SSLSessionCache cache) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getInsecure,
          jni.JniType.objectType,
          [handshakeTimeoutMillis, cache.reference]).object);

  static final _id_setTrustManagers = jniAccessors.getMethodIDOf(
      _classRef, "setTrustManagers", "([Ljavax/net/ssl/TrustManager;)V");

  /// from: public void setTrustManagers(javax.net.ssl.TrustManager[] trustManager)
  ///
  /// Sets the TrustManagers to be used for connections made by this factory.
  void setTrustManagers(jni.JniObject trustManager) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTrustManagers,
          jni.JniType.voidType, [trustManager.reference]).check();

  static final _id_setNpnProtocols =
      jniAccessors.getMethodIDOf(_classRef, "setNpnProtocols", "([[B)V");

  /// from: public void setNpnProtocols(byte[][] npnProtocols)
  ///
  /// Sets the <a href="http://technotes.googlecode.com/git/nextprotoneg.html">Next
  /// Protocol Negotiation (NPN)</a> protocols that this peer is interested in.
  ///
  /// For servers this is the sequence of protocols to advertise as
  /// supported, in order of preference. This list is sent unencrypted to
  /// all clients that support NPN.
  ///
  /// For clients this is a list of supported protocols to match against the
  /// server's list. If there is no protocol supported by both client and
  /// server then the first protocol in the client's list will be selected.
  /// The order of the client's protocols is otherwise insignificant.
  ///@param npnProtocols a non-empty list of protocol byte arrays. All arrays
  ///     must be non-empty and of length less than 256.
  void setNpnProtocols(jni.JniObject npnProtocols) =>
      jniAccessors.callMethodWithArgs(reference, _id_setNpnProtocols,
          jni.JniType.voidType, [npnProtocols.reference]).check();

  static final _id_getNpnSelectedProtocol = jniAccessors.getMethodIDOf(
      _classRef, "getNpnSelectedProtocol", "(Ljava/net/Socket;)[B");

  /// from: public byte[] getNpnSelectedProtocol(java.net.Socket socket)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the <a href="http://technotes.googlecode.com/git/nextprotoneg.html">Next
  /// Protocol Negotiation (NPN)</a> protocol selected by client and server, or
  /// null if no protocol was negotiated.
  ///@param socket a socket created by this factory.
  ///@throws IllegalArgumentException if the socket was not created by this factory.
  jni.JniObject getNpnSelectedProtocol(jni.JniObject socket) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getNpnSelectedProtocol,
          jni.JniType.objectType,
          [socket.reference]).object);

  static final _id_setKeyManagers = jniAccessors.getMethodIDOf(
      _classRef, "setKeyManagers", "([Ljavax/net/ssl/KeyManager;)V");

  /// from: public void setKeyManagers(javax.net.ssl.KeyManager[] keyManagers)
  ///
  /// Sets the KeyManagers to be used for connections made by this factory.
  void setKeyManagers(jni.JniObject keyManagers) =>
      jniAccessors.callMethodWithArgs(reference, _id_setKeyManagers,
          jni.JniType.voidType, [keyManagers.reference]).check();

  static final _id_setUseSessionTickets = jniAccessors.getMethodIDOf(
      _classRef, "setUseSessionTickets", "(Ljava/net/Socket;Z)V");

  /// from: public void setUseSessionTickets(java.net.Socket socket, boolean useSessionTickets)
  ///
  /// Enables <a href="http://tools.ietf.org/html/rfc5077\#section-3.2">session ticket</a>
  /// support on the given socket.
  ///@param socket a socket created by this factory
  ///@param useSessionTickets {@code true} to enable session ticket support on this socket.
  ///@throws IllegalArgumentException if the socket was not created by this factory.
  void setUseSessionTickets(jni.JniObject socket, bool useSessionTickets) =>
      jniAccessors.callMethodWithArgs(reference, _id_setUseSessionTickets,
          jni.JniType.voidType, [socket.reference, useSessionTickets]).check();

  static final _id_setHostname = jniAccessors.getMethodIDOf(
      _classRef, "setHostname", "(Ljava/net/Socket;Ljava/lang/String;)V");

  /// from: public void setHostname(java.net.Socket socket, java.lang.String hostName)
  ///
  /// Turns on <a href="http://tools.ietf.org/html/rfc6066\#section-3">Server
  /// Name Indication (SNI)</a> on a given socket.
  ///@param socket a socket created by this factory.
  ///@param hostName the desired SNI hostname, null to disable.
  ///@throws IllegalArgumentException if the socket was not created by this factory.
  void setHostname(jni.JniObject socket, jni.JniString hostName) =>
      jniAccessors.callMethodWithArgs(reference, _id_setHostname,
          jni.JniType.voidType, [socket.reference, hostName.reference]).check();

  static final _id_createSocket = jniAccessors.getMethodIDOf(
      _classRef,
      "createSocket",
      "(Ljava/net/Socket;Ljava/lang/String;IZ)Ljava/net/Socket;");

  /// from: public java.net.Socket createSocket(java.net.Socket k, java.lang.String host, int port, boolean close)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  ///
  /// This method verifies the peer's certificate hostname after connecting
  /// (unless created with \#getInsecure(int, SSLSessionCache)).
  jni.JniObject createSocket(
          jni.JniObject k, jni.JniString host, int port, bool close) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createSocket,
          jni.JniType.objectType,
          [k.reference, host.reference, port, close]).object);

  static final _id_createSocket1 = jniAccessors.getMethodIDOf(
      _classRef, "createSocket", "()Ljava/net/Socket;");

  /// from: public java.net.Socket createSocket()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new socket which is not connected to any remote host.
  /// You must use Socket\#connect to connect the socket.
  ///
  /// <p class="caution">__Warning:__ Hostname verification is not performed
  /// with this method.  You MUST verify the server's identity after connecting
  /// the socket to avoid man-in-the-middle attacks.
  ///
  jni.JniObject createSocket1() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createSocket1, jni.JniType.objectType, []).object);

  static final _id_createSocket2 = jniAccessors.getMethodIDOf(
      _classRef,
      "createSocket",
      "(Ljava/net/InetAddress;ILjava/net/InetAddress;I)Ljava/net/Socket;");

  /// from: public java.net.Socket createSocket(java.net.InetAddress addr, int port, java.net.InetAddress localAddr, int localPort)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  ///
  /// <p class="caution">__Warning:__ Hostname verification is not performed
  /// with this method.  You MUST verify the server's identity after connecting
  /// the socket to avoid man-in-the-middle attacks.
  ///
  jni.JniObject createSocket2(jni.JniObject addr, int port,
          jni.JniObject localAddr, int localPort) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createSocket2,
          jni.JniType.objectType,
          [addr.reference, port, localAddr.reference, localPort]).object);

  static final _id_createSocket3 = jniAccessors.getMethodIDOf(
      _classRef, "createSocket", "(Ljava/net/InetAddress;I)Ljava/net/Socket;");

  /// from: public java.net.Socket createSocket(java.net.InetAddress addr, int port)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  ///
  /// <p class="caution">__Warning:__ Hostname verification is not performed
  /// with this method.  You MUST verify the server's identity after connecting
  /// the socket to avoid man-in-the-middle attacks.
  ///
  jni.JniObject createSocket3(jni.JniObject addr, int port) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createSocket3,
          jni.JniType.objectType,
          [addr.reference, port]).object);

  static final _id_createSocket4 = jniAccessors.getMethodIDOf(
      _classRef,
      "createSocket",
      "(Ljava/lang/String;ILjava/net/InetAddress;I)Ljava/net/Socket;");

  /// from: public java.net.Socket createSocket(java.lang.String host, int port, java.net.InetAddress localAddr, int localPort)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  ///
  /// This method verifies the peer's certificate hostname after connecting
  /// (unless created with \#getInsecure(int, SSLSessionCache)).
  jni.JniObject createSocket4(jni.JniString host, int port,
          jni.JniObject localAddr, int localPort) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createSocket4,
          jni.JniType.objectType,
          [host.reference, port, localAddr.reference, localPort]).object);

  static final _id_createSocket5 = jniAccessors.getMethodIDOf(
      _classRef, "createSocket", "(Ljava/lang/String;I)Ljava/net/Socket;");

  /// from: public java.net.Socket createSocket(java.lang.String host, int port)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  ///
  /// This method verifies the peer's certificate hostname after connecting
  /// (unless created with \#getInsecure(int, SSLSessionCache)).
  jni.JniObject createSocket5(jni.JniString host, int port) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createSocket5,
          jni.JniType.objectType,
          [host.reference, port]).object);

  static final _id_getDefaultCipherSuites = jniAccessors.getMethodIDOf(
      _classRef, "getDefaultCipherSuites", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getDefaultCipherSuites()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getDefaultCipherSuites() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDefaultCipherSuites, jni.JniType.objectType, []).object);

  static final _id_getSupportedCipherSuites = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedCipherSuites", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getSupportedCipherSuites()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getSupportedCipherSuites() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedCipherSuites, jni.JniType.objectType, []).object);
}
