// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.NetworkInfo
///
/// Describes the status of a network interface.
/// Use ConnectivityManager\#getActiveNetworkInfo() to get an instance that represents
/// the current network connection.
class NetworkInfo extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/net/NetworkInfo");
  NetworkInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.net.NetworkInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/net/NetworkInfo;)V");

  /// from: void <init>(android.net.NetworkInfo source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@hide }
  NetworkInfo(NetworkInfo source)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [source.reference]).object);

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "()I");

  /// from: public int getType()
  ///
  /// Reports the type of network to which the
  /// info in this {@code NetworkInfo} pertains.
  ///@return one of ConnectivityManager\#TYPE_MOBILE, ConnectivityManager\#TYPE_WIFI, ConnectivityManager\#TYPE_WIMAX, ConnectivityManager\#TYPE_ETHERNET,  ConnectivityManager\#TYPE_BLUETOOTH, or other
  /// types defined by ConnectivityManager.
  ///@deprecated Callers should switch to checking NetworkCapabilities\#hasTransport
  ///             instead with one of the NetworkCapabilities\#TRANSPORT_* constants :
  ///             \#getType and \#getTypeName cannot account for networks using
  ///             multiple transports. Note that generally apps should not care about transport;
  ///             NetworkCapabilities\#NET_CAPABILITY_NOT_METERED and
  ///             NetworkCapabilities\#getLinkDownstreamBandwidthKbps are calls that
  ///             apps concerned with meteredness or bandwidth should be looking at, as they
  ///             offer this information with much better accuracy.
  int getType() => jniAccessors.callMethodWithArgs(
      reference, _id_getType, jni.JniType.intType, []).integer;

  static final _id_getSubtype =
      jniAccessors.getMethodIDOf(_classRef, "getSubtype", "()I");

  /// from: public int getSubtype()
  ///
  /// Return a network-type-specific integer describing the subtype
  /// of the network.
  ///@return the network subtype
  int getSubtype() => jniAccessors.callMethodWithArgs(
      reference, _id_getSubtype, jni.JniType.intType, []).integer;

  static final _id_getTypeName = jniAccessors.getMethodIDOf(
      _classRef, "getTypeName", "()Ljava/lang/String;");

  /// from: public java.lang.String getTypeName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a human-readable name describe the type of the network,
  /// for example "WIFI" or "MOBILE".
  ///@return the name of the network type
  ///@deprecated Callers should switch to checking NetworkCapabilities\#hasTransport
  ///             instead with one of the NetworkCapabilities\#TRANSPORT_* constants :
  ///             \#getType and \#getTypeName cannot account for networks using
  ///             multiple transports. Note that generally apps should not care about transport;
  ///             NetworkCapabilities\#NET_CAPABILITY_NOT_METERED and
  ///             NetworkCapabilities\#getLinkDownstreamBandwidthKbps are calls that
  ///             apps concerned with meteredness or bandwidth should be looking at, as they
  ///             offer this information with much better accuracy.
  jni.JniString getTypeName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTypeName, jni.JniType.objectType, []).object);

  static final _id_getSubtypeName = jniAccessors.getMethodIDOf(
      _classRef, "getSubtypeName", "()Ljava/lang/String;");

  /// from: public java.lang.String getSubtypeName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a human-readable name describing the subtype of the network.
  ///@return the name of the network subtype
  jni.JniString getSubtypeName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSubtypeName, jni.JniType.objectType, []).object);

  static final _id_isConnectedOrConnecting =
      jniAccessors.getMethodIDOf(_classRef, "isConnectedOrConnecting", "()Z");

  /// from: public boolean isConnectedOrConnecting()
  ///
  /// Indicates whether network connectivity exists or is in the process
  /// of being established. This is good for applications that need to
  /// do anything related to the network other than read or write data.
  /// For the latter, call \#isConnected() instead, which guarantees
  /// that the network is fully usable.
  ///@return {@code true} if network connectivity exists or is in the process
  /// of being established, {@code false} otherwise.
  ///@deprecated Apps should instead use the
  ///             android.net.ConnectivityManager.NetworkCallback API to
  ///             learn about connectivity changes.
  ///             ConnectivityManager\#registerDefaultNetworkCallback and
  ///             ConnectivityManager\#registerNetworkCallback. These will
  ///             give a more accurate picture of the connectivity state of
  ///             the device and let apps react more easily and quickly to changes.
  bool isConnectedOrConnecting() => jniAccessors.callMethodWithArgs(reference,
      _id_isConnectedOrConnecting, jni.JniType.booleanType, []).boolean;

  static final _id_isConnected =
      jniAccessors.getMethodIDOf(_classRef, "isConnected", "()Z");

  /// from: public boolean isConnected()
  ///
  /// Indicates whether network connectivity exists and it is possible to establish
  /// connections and pass data.
  /// Always call this before attempting to perform data transactions.
  ///@return {@code true} if network connectivity exists, {@code false} otherwise.
  bool isConnected() => jniAccessors.callMethodWithArgs(
      reference, _id_isConnected, jni.JniType.booleanType, []).boolean;

  static final _id_isAvailable =
      jniAccessors.getMethodIDOf(_classRef, "isAvailable", "()Z");

  /// from: public boolean isAvailable()
  ///
  /// Indicates whether network connectivity is possible. A network is unavailable
  /// when a persistent or semi-persistent condition prevents the possibility
  /// of connecting to that network. Examples include
  /// <ul>
  /// <li>The device is out of the coverage area for any network of this type.</li>
  /// <li>The device is on a network other than the home network (i.e., roaming), and
  /// data roaming has been disabled.</li>
  /// <li>The device's radio is turned off, e.g., because airplane mode is enabled.</li>
  /// </ul>
  /// Since Android L, this always returns {@code true}, because the system only
  /// returns info for available networks.
  ///@return {@code true} if the network is available, {@code false} otherwise
  ///@deprecated Apps should instead use the
  ///             android.net.ConnectivityManager.NetworkCallback API to
  ///             learn about connectivity changes.
  ///             ConnectivityManager\#registerDefaultNetworkCallback and
  ///             ConnectivityManager\#registerNetworkCallback. These will
  ///             give a more accurate picture of the connectivity state of
  ///             the device and let apps react more easily and quickly to changes.
  bool isAvailable() => jniAccessors.callMethodWithArgs(
      reference, _id_isAvailable, jni.JniType.booleanType, []).boolean;

  static final _id_isFailover =
      jniAccessors.getMethodIDOf(_classRef, "isFailover", "()Z");

  /// from: public boolean isFailover()
  ///
  /// Indicates whether the current attempt to connect to the network
  /// resulted from the ConnectivityManager trying to fail over to this
  /// network following a disconnect from another network.
  ///@return {@code true} if this is a failover attempt, {@code false}
  /// otherwise.
  ///@deprecated This field is not populated in recent Android releases,
  ///             and does not make a lot of sense in a multi-network world.
  bool isFailover() => jniAccessors.callMethodWithArgs(
      reference, _id_isFailover, jni.JniType.booleanType, []).boolean;

  static final _id_isRoaming =
      jniAccessors.getMethodIDOf(_classRef, "isRoaming", "()Z");

  /// from: public boolean isRoaming()
  ///
  /// Indicates whether the device is currently roaming on this network. When
  /// {@code true}, it suggests that use of data on this network may incur
  /// extra costs.
  ///@return {@code true} if roaming is in effect, {@code false} otherwise.
  ///@deprecated Callers should switch to checking
  ///             NetworkCapabilities\#NET_CAPABILITY_NOT_ROAMING
  ///             instead, since that handles more complex situations, such as
  ///             VPNs.
  bool isRoaming() => jniAccessors.callMethodWithArgs(
      reference, _id_isRoaming, jni.JniType.booleanType, []).boolean;

  static final _id_getState = jniAccessors.getMethodIDOf(
      _classRef, "getState", "()Landroid/net/NetworkInfo\$State;");

  /// from: public android.net.NetworkInfo.State getState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Reports the current coarse-grained state of the network.
  ///@return the coarse-grained state
  ///@deprecated Apps should instead use the
  ///             android.net.ConnectivityManager.NetworkCallback API to
  ///             learn about connectivity changes.
  ///             ConnectivityManager\#registerDefaultNetworkCallback and
  ///             ConnectivityManager\#registerNetworkCallback. These will
  ///             give a more accurate picture of the connectivity state of
  ///             the device and let apps react more easily and quickly to changes.
  NetworkInfo_State getState() =>
      NetworkInfo_State.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getState, jni.JniType.objectType, []).object);

  static final _id_getDetailedState = jniAccessors.getMethodIDOf(_classRef,
      "getDetailedState", "()Landroid/net/NetworkInfo\$DetailedState;");

  /// from: public android.net.NetworkInfo.DetailedState getDetailedState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Reports the current fine-grained state of the network.
  ///@return the fine-grained state
  NetworkInfo_DetailedState getDetailedState() =>
      NetworkInfo_DetailedState.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDetailedState, jni.JniType.objectType, []).object);

  static final _id_getReason = jniAccessors.getMethodIDOf(
      _classRef, "getReason", "()Ljava/lang/String;");

  /// from: public java.lang.String getReason()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Report the reason an attempt to establish connectivity failed,
  /// if one is available.
  ///@return the reason for failure, or null if not available
  ///@deprecated This method does not have a consistent contract that could make it useful
  ///             to callers.
  jni.JniString getReason() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getReason, jni.JniType.objectType, []).object);

  static final _id_getExtraInfo = jniAccessors.getMethodIDOf(
      _classRef, "getExtraInfo", "()Ljava/lang/String;");

  /// from: public java.lang.String getExtraInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Report the extra information about the network state, if any was
  /// provided by the lower networking layers.
  ///@return the extra information, or null if not available
  jni.JniString getExtraInfo() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtraInfo, jni.JniType.objectType, []).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}

/// from: android.net.NetworkInfo$State
///
/// Coarse-grained network state. This is probably what most applications should
/// use, rather than android.net.NetworkInfo.DetailedState DetailedState.
/// The mapping between the two is as follows:
/// <br/><br/>
/// <table>
/// <tr><td>__Detailed state__</td><td>__Coarse-grained state__</td></tr>
/// <tr><td><code>IDLE</code></td><td><code>DISCONNECTED</code></td></tr>
/// <tr><td><code>SCANNING</code></td><td><code>DISCONNECTED</code></td></tr>
/// <tr><td><code>CONNECTING</code></td><td><code>CONNECTING</code></td></tr>
/// <tr><td><code>AUTHENTICATING</code></td><td><code>CONNECTING</code></td></tr>
/// <tr><td><code>OBTAINING_IPADDR</code></td><td><code>CONNECTING</code></td></tr>
/// <tr><td><code>VERIFYING_POOR_LINK</code></td><td><code>CONNECTING</code></td></tr>
/// <tr><td><code>CAPTIVE_PORTAL_CHECK</code></td><td><code>CONNECTING</code></td></tr>
/// <tr><td><code>CONNECTED</code></td><td><code>CONNECTED</code></td></tr>
/// <tr><td><code>SUSPENDED</code></td><td><code>SUSPENDED</code></td></tr>
/// <tr><td><code>DISCONNECTING</code></td><td><code>DISCONNECTING</code></td></tr>
/// <tr><td><code>DISCONNECTED</code></td><td><code>DISCONNECTED</code></td></tr>
/// <tr><td><code>FAILED</code></td><td><code>DISCONNECTED</code></td></tr>
/// <tr><td><code>BLOCKED</code></td><td><code>DISCONNECTED</code></td></tr>
/// </table>
class NetworkInfo_State extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/NetworkInfo\$State");
  NetworkInfo_State.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/net/NetworkInfo\$State;");

  /// from: static public android.net.NetworkInfo.State[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/net/NetworkInfo\$State;");

  /// from: static public android.net.NetworkInfo.State valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static NetworkInfo_State valueOf(jni.JniString name) =>
      NetworkInfo_State.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  NetworkInfo_State()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.net.NetworkInfo$DetailedState
///
/// The fine-grained state of a network connection. This level of detail
/// is probably of interest to few applications. Most should use
/// android.net.NetworkInfo.State State instead.
class NetworkInfo_DetailedState extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/NetworkInfo\$DetailedState");
  NetworkInfo_DetailedState.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/net/NetworkInfo\$DetailedState;");

  /// from: static public android.net.NetworkInfo.DetailedState[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/net/NetworkInfo\$DetailedState;");

  /// from: static public android.net.NetworkInfo.DetailedState valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static NetworkInfo_DetailedState valueOf(jni.JniString name) =>
      NetworkInfo_DetailedState.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  NetworkInfo_DetailedState()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
