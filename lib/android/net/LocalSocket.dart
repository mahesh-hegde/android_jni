// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "LocalSocketAddress.dart" as localsocketaddress_;

import "Credentials.dart" as credentials_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.LocalSocket
///
/// Creates a (non-server) socket in the UNIX-domain namespace. The interface
/// here is not entirely unlike that of java.net.Socket. This class and the streams
/// returned from it may be used from multiple threads.
class LocalSocket extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/net/LocalSocket");
  LocalSocket.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int SOCKET_DGRAM
  ///
  /// Datagram socket type
  static const SOCKET_DGRAM = 1;

  /// from: static public final int SOCKET_SEQPACKET
  ///
  /// Sequential packet socket type
  static const SOCKET_SEQPACKET = 3;

  /// from: static public final int SOCKET_STREAM
  ///
  /// Stream socket type
  static const SOCKET_STREAM = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a AF_LOCAL/UNIX domain stream socket.
  LocalSocket()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int sockType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a AF_LOCAL/UNIX domain stream socket with given socket type
  ///@param sockType either \#SOCKET_DGRAM, \#SOCKET_STREAM
  /// or \#SOCKET_SEQPACKET
  LocalSocket.ctor1(int sockType)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [sockType]).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_connect = jniAccessors.getMethodIDOf(
      _classRef, "connect", "(Landroid/net/LocalSocketAddress;)V");

  /// from: public void connect(android.net.LocalSocketAddress endpoint)
  ///
  /// Connects this socket to an endpoint. May only be called on an instance
  /// that has not yet been connected.
  ///@param endpoint endpoint address
  ///@throws IOException if socket is in invalid state or the address does
  /// not exist.
  void connect(localsocketaddress_.LocalSocketAddress endpoint) =>
      jniAccessors.callMethodWithArgs(reference, _id_connect,
          jni.JniType.voidType, [endpoint.reference]).check();

  static final _id_bind = jniAccessors.getMethodIDOf(
      _classRef, "bind", "(Landroid/net/LocalSocketAddress;)V");

  /// from: public void bind(android.net.LocalSocketAddress bindpoint)
  ///
  /// Binds this socket to an endpoint name. May only be called on an instance
  /// that has not yet been bound.
  ///@param bindpoint endpoint address
  ///@throws IOException
  void bind(localsocketaddress_.LocalSocketAddress bindpoint) =>
      jniAccessors.callMethodWithArgs(reference, _id_bind, jni.JniType.voidType,
          [bindpoint.reference]).check();

  static final _id_getLocalSocketAddress = jniAccessors.getMethodIDOf(
      _classRef, "getLocalSocketAddress", "()Landroid/net/LocalSocketAddress;");

  /// from: public android.net.LocalSocketAddress getLocalSocketAddress()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the name that this socket is bound to, if any.
  ///@return Local address or null if anonymous
  localsocketaddress_.LocalSocketAddress getLocalSocketAddress() =>
      localsocketaddress_.LocalSocketAddress.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getLocalSocketAddress,
              jni.JniType.objectType, []).object);

  static final _id_getInputStream = jniAccessors.getMethodIDOf(
      _classRef, "getInputStream", "()Ljava/io/InputStream;");

  /// from: public java.io.InputStream getInputStream()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the input stream for this instance.
  ///@return input stream
  ///@throws IOException if socket has been closed or cannot be created.
  jni.JniObject getInputStream() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getInputStream, jni.JniType.objectType, []).object);

  static final _id_getOutputStream = jniAccessors.getMethodIDOf(
      _classRef, "getOutputStream", "()Ljava/io/OutputStream;");

  /// from: public java.io.OutputStream getOutputStream()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the output stream for this instance.
  ///@return output stream
  ///@throws IOException if socket has been closed or cannot be created.
  jni.JniObject getOutputStream() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getOutputStream, jni.JniType.objectType, []).object);

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Closes the socket.
  ///@throws IOException
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_shutdownInput =
      jniAccessors.getMethodIDOf(_classRef, "shutdownInput", "()V");

  /// from: public void shutdownInput()
  ///
  /// Shuts down the input side of the socket.
  ///@throws IOException
  void shutdownInput() => jniAccessors.callMethodWithArgs(
      reference, _id_shutdownInput, jni.JniType.voidType, []).check();

  static final _id_shutdownOutput =
      jniAccessors.getMethodIDOf(_classRef, "shutdownOutput", "()V");

  /// from: public void shutdownOutput()
  ///
  /// Shuts down the output side of the socket.
  ///@throws IOException
  void shutdownOutput() => jniAccessors.callMethodWithArgs(
      reference, _id_shutdownOutput, jni.JniType.voidType, []).check();

  static final _id_setReceiveBufferSize =
      jniAccessors.getMethodIDOf(_classRef, "setReceiveBufferSize", "(I)V");

  /// from: public void setReceiveBufferSize(int size)
  void setReceiveBufferSize(int size) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setReceiveBufferSize,
      jni.JniType.voidType,
      [size]).check();

  static final _id_getReceiveBufferSize =
      jniAccessors.getMethodIDOf(_classRef, "getReceiveBufferSize", "()I");

  /// from: public int getReceiveBufferSize()
  int getReceiveBufferSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getReceiveBufferSize, jni.JniType.intType, []).integer;

  static final _id_setSoTimeout =
      jniAccessors.getMethodIDOf(_classRef, "setSoTimeout", "(I)V");

  /// from: public void setSoTimeout(int n)
  void setSoTimeout(int n) => jniAccessors.callMethodWithArgs(
      reference, _id_setSoTimeout, jni.JniType.voidType, [n]).check();

  static final _id_getSoTimeout =
      jniAccessors.getMethodIDOf(_classRef, "getSoTimeout", "()I");

  /// from: public int getSoTimeout()
  int getSoTimeout() => jniAccessors.callMethodWithArgs(
      reference, _id_getSoTimeout, jni.JniType.intType, []).integer;

  static final _id_setSendBufferSize =
      jniAccessors.getMethodIDOf(_classRef, "setSendBufferSize", "(I)V");

  /// from: public void setSendBufferSize(int n)
  void setSendBufferSize(int n) => jniAccessors.callMethodWithArgs(
      reference, _id_setSendBufferSize, jni.JniType.voidType, [n]).check();

  static final _id_getSendBufferSize =
      jniAccessors.getMethodIDOf(_classRef, "getSendBufferSize", "()I");

  /// from: public int getSendBufferSize()
  int getSendBufferSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getSendBufferSize, jni.JniType.intType, []).integer;

  static final _id_getRemoteSocketAddress = jniAccessors.getMethodIDOf(
      _classRef,
      "getRemoteSocketAddress",
      "()Landroid/net/LocalSocketAddress;");

  /// from: public android.net.LocalSocketAddress getRemoteSocketAddress()
  /// The returned object must be deleted after use, by calling the `delete` method.
  localsocketaddress_.LocalSocketAddress getRemoteSocketAddress() =>
      localsocketaddress_.LocalSocketAddress.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getRemoteSocketAddress,
              jni.JniType.objectType, []).object);

  static final _id_isConnected =
      jniAccessors.getMethodIDOf(_classRef, "isConnected", "()Z");

  /// from: synchronized public boolean isConnected()
  bool isConnected() => jniAccessors.callMethodWithArgs(
      reference, _id_isConnected, jni.JniType.booleanType, []).boolean;

  static final _id_isClosed =
      jniAccessors.getMethodIDOf(_classRef, "isClosed", "()Z");

  /// from: public boolean isClosed()
  bool isClosed() => jniAccessors.callMethodWithArgs(
      reference, _id_isClosed, jni.JniType.booleanType, []).boolean;

  static final _id_isBound =
      jniAccessors.getMethodIDOf(_classRef, "isBound", "()Z");

  /// from: synchronized public boolean isBound()
  bool isBound() => jniAccessors.callMethodWithArgs(
      reference, _id_isBound, jni.JniType.booleanType, []).boolean;

  static final _id_isOutputShutdown =
      jniAccessors.getMethodIDOf(_classRef, "isOutputShutdown", "()Z");

  /// from: public boolean isOutputShutdown()
  bool isOutputShutdown() => jniAccessors.callMethodWithArgs(
      reference, _id_isOutputShutdown, jni.JniType.booleanType, []).boolean;

  static final _id_isInputShutdown =
      jniAccessors.getMethodIDOf(_classRef, "isInputShutdown", "()Z");

  /// from: public boolean isInputShutdown()
  bool isInputShutdown() => jniAccessors.callMethodWithArgs(
      reference, _id_isInputShutdown, jni.JniType.booleanType, []).boolean;

  static final _id_connect1 = jniAccessors.getMethodIDOf(
      _classRef, "connect", "(Landroid/net/LocalSocketAddress;I)V");

  /// from: public void connect(android.net.LocalSocketAddress endpoint, int timeout)
  void connect1(localsocketaddress_.LocalSocketAddress endpoint, int timeout) =>
      jniAccessors.callMethodWithArgs(reference, _id_connect1,
          jni.JniType.voidType, [endpoint.reference, timeout]).check();

  static final _id_setFileDescriptorsForSend = jniAccessors.getMethodIDOf(
      _classRef, "setFileDescriptorsForSend", "([Ljava/io/FileDescriptor;)V");

  /// from: public void setFileDescriptorsForSend(java.io.FileDescriptor[] fds)
  ///
  /// Enqueues a set of file descriptors to send to the peer. The queue
  /// is one deep. The file descriptors will be sent with the next write
  /// of normal data, and will be delivered in a single ancillary message.
  /// See "man 7 unix" SCM_RIGHTS on a desktop Linux machine.
  ///@param fds non-null; file descriptors to send.
  void setFileDescriptorsForSend(jni.JniObject fds) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFileDescriptorsForSend,
          jni.JniType.voidType, [fds.reference]).check();

  static final _id_getAncillaryFileDescriptors = jniAccessors.getMethodIDOf(
      _classRef, "getAncillaryFileDescriptors", "()[Ljava/io/FileDescriptor;");

  /// from: public java.io.FileDescriptor[] getAncillaryFileDescriptors()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves a set of file descriptors that a peer has sent through
  /// an ancillary message. This method retrieves the most recent set sent,
  /// and then returns null until a new set arrives.
  /// File descriptors may only be passed along with regular data, so this
  /// method can only return a non-null after a read operation.
  ///@return null or file descriptor array
  ///@throws IOException
  jni.JniObject getAncillaryFileDescriptors() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAncillaryFileDescriptors, jni.JniType.objectType, []).object);

  static final _id_getPeerCredentials = jniAccessors.getMethodIDOf(
      _classRef, "getPeerCredentials", "()Landroid/net/Credentials;");

  /// from: public android.net.Credentials getPeerCredentials()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the credentials of this socket's peer. Only valid on
  /// connected sockets.
  ///@return non-null; peer credentials
  ///@throws IOException
  credentials_.Credentials getPeerCredentials() =>
      credentials_.Credentials.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPeerCredentials,
          jni.JniType.objectType, []).object);

  static final _id_getFileDescriptor = jniAccessors.getMethodIDOf(
      _classRef, "getFileDescriptor", "()Ljava/io/FileDescriptor;");

  /// from: public java.io.FileDescriptor getFileDescriptor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns file descriptor or null if not yet open/already closed
  ///@return fd or null
  jni.JniObject getFileDescriptor() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFileDescriptor, jni.JniType.objectType, []).object);
}
