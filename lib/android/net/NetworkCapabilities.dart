// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.NetworkCapabilities
///
/// Representation of the capabilities of an active network. Instances are
/// typically obtained through
/// NetworkCallback\#onCapabilitiesChanged(Network, NetworkCapabilities)
/// or ConnectivityManager\#getNetworkCapabilities(Network).
///
/// This replaces the old ConnectivityManager\#TYPE_MOBILE method of
/// network selection. Rather than indicate a need for Wi-Fi because an
/// application needs high bandwidth and risk obsolescence when a new, fast
/// network appears (like LTE), the application should specify it needs high
/// bandwidth. Similarly if an application needs an unmetered network for a bulk
/// transfer it can specify that rather than assuming all cellular based
/// connections are metered and all Wi-Fi based connections are not.
class NetworkCapabilities extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/NetworkCapabilities");
  NetworkCapabilities.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.net.NetworkCapabilities> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int NET_CAPABILITY_CAPTIVE_PORTAL
  ///
  /// Indicates that this network was found to have a captive portal in place last time it was
  /// probed.
  static const NET_CAPABILITY_CAPTIVE_PORTAL = 17;

  /// from: static public final int NET_CAPABILITY_CBS
  ///
  /// Indicates this is a network that has the ability to reach the carrier's
  /// CBS servers, used for carrier specific services.
  static const NET_CAPABILITY_CBS = 5;

  /// from: static public final int NET_CAPABILITY_DUN
  ///
  /// Indicates this is a network that has the ability to reach the carrier's
  /// DUN or tethering gateway.
  static const NET_CAPABILITY_DUN = 2;

  /// from: static public final int NET_CAPABILITY_EIMS
  ///
  /// Indicates this is a network that has the ability to reach a carrier's
  /// Emergency IMS servers or other services, used for network signaling
  /// during emergency calls.
  static const NET_CAPABILITY_EIMS = 10;

  /// from: static public final int NET_CAPABILITY_FOREGROUND
  ///
  /// Indicates that this network is available for use by apps, and not a network that is being
  /// kept up in the background to facilitate fast network switching.
  static const NET_CAPABILITY_FOREGROUND = 19;

  /// from: static public final int NET_CAPABILITY_FOTA
  ///
  /// Indicates this is a network that has the ability to reach the carrier's
  /// FOTA portal, used for over the air updates.
  static const NET_CAPABILITY_FOTA = 3;

  /// from: static public final int NET_CAPABILITY_IA
  ///
  /// Indicates this is a network that has the ability to reach a carrier's
  /// Initial Attach servers.
  static const NET_CAPABILITY_IA = 7;

  /// from: static public final int NET_CAPABILITY_IMS
  ///
  /// Indicates this is a network that has the ability to reach the carrier's
  /// IMS servers, used for network registration and signaling.
  static const NET_CAPABILITY_IMS = 4;

  /// from: static public final int NET_CAPABILITY_INTERNET
  ///
  /// Indicates that this network should be able to reach the internet.
  static const NET_CAPABILITY_INTERNET = 12;

  /// from: static public final int NET_CAPABILITY_MMS
  ///
  /// Indicates this is a network that has the ability to reach the
  /// carrier's MMSC for sending and receiving MMS messages.
  static const NET_CAPABILITY_MMS = 0;

  /// from: static public final int NET_CAPABILITY_NOT_CONGESTED
  ///
  /// Indicates that this network is not congested.
  ///
  /// When a network is congested, applications should defer network traffic
  /// that can be done at a later time, such as uploading analytics.
  static const NET_CAPABILITY_NOT_CONGESTED = 20;

  /// from: static public final int NET_CAPABILITY_NOT_METERED
  ///
  /// Indicates that this network is unmetered.
  static const NET_CAPABILITY_NOT_METERED = 11;

  /// from: static public final int NET_CAPABILITY_NOT_RESTRICTED
  ///
  /// Indicates that this network is available for general use.  If this is not set
  /// applications should not attempt to communicate on this network.  Note that this
  /// is simply informative and not enforcement - enforcement is handled via other means.
  /// Set by default.
  static const NET_CAPABILITY_NOT_RESTRICTED = 13;

  /// from: static public final int NET_CAPABILITY_NOT_ROAMING
  ///
  /// Indicates that this network is not roaming.
  static const NET_CAPABILITY_NOT_ROAMING = 18;

  /// from: static public final int NET_CAPABILITY_NOT_SUSPENDED
  ///
  /// Indicates that this network is not currently suspended.
  ///
  /// When a network is suspended, the network's IP addresses and any connections
  /// established on the network remain valid, but the network is temporarily unable
  /// to transfer data. This can happen, for example, if a cellular network experiences
  /// a temporary loss of signal, such as when driving through a tunnel, etc.
  /// A network with this capability is not suspended, so is expected to be able to
  /// transfer data.
  static const NET_CAPABILITY_NOT_SUSPENDED = 21;

  /// from: static public final int NET_CAPABILITY_NOT_VPN
  ///
  /// Indicates that this network is not a VPN.  This capability is set by default and should be
  /// explicitly cleared for VPN networks.
  static const NET_CAPABILITY_NOT_VPN = 15;

  /// from: static public final int NET_CAPABILITY_RCS
  ///
  /// Indicates this is a network that has the ability to reach a carrier's
  /// RCS servers, used for Rich Communication Services.
  static const NET_CAPABILITY_RCS = 8;

  /// from: static public final int NET_CAPABILITY_SUPL
  ///
  /// Indicates this is a network that has the ability to reach the carrier's
  /// SUPL server, used to retrieve GPS information.
  static const NET_CAPABILITY_SUPL = 1;

  /// from: static public final int NET_CAPABILITY_TRUSTED
  ///
  /// Indicates that the user has indicated implicit trust of this network.  This
  /// generally means it's a sim-selected carrier, a plugged in ethernet, a paired
  /// BT device or a wifi the user asked to connect to.  Untrusted networks
  /// are probably limited to unknown wifi AP.  Set by default.
  static const NET_CAPABILITY_TRUSTED = 14;

  /// from: static public final int NET_CAPABILITY_VALIDATED
  ///
  /// Indicates that connectivity on this network was successfully validated. For example, for a
  /// network with NET_CAPABILITY_INTERNET, it means that Internet connectivity was successfully
  /// detected.
  static const NET_CAPABILITY_VALIDATED = 16;

  /// from: static public final int NET_CAPABILITY_WIFI_P2P
  ///
  /// Indicates this is a network that has the ability to reach a Wi-Fi direct
  /// peer.
  static const NET_CAPABILITY_WIFI_P2P = 6;

  /// from: static public final int NET_CAPABILITY_XCAP
  ///
  /// Indicates this is a network that has the ability to reach a carrier's
  /// XCAP servers, used for configuration and control.
  static const NET_CAPABILITY_XCAP = 9;

  /// from: static public final int TRANSPORT_BLUETOOTH
  ///
  /// Indicates this network uses a Bluetooth transport.
  static const TRANSPORT_BLUETOOTH = 2;

  /// from: static public final int TRANSPORT_CELLULAR
  ///
  /// Indicates this network uses a Cellular transport.
  static const TRANSPORT_CELLULAR = 0;

  /// from: static public final int TRANSPORT_ETHERNET
  ///
  /// Indicates this network uses an Ethernet transport.
  static const TRANSPORT_ETHERNET = 3;

  /// from: static public final int TRANSPORT_LOWPAN
  ///
  /// Indicates this network uses a LoWPAN transport.
  static const TRANSPORT_LOWPAN = 6;

  /// from: static public final int TRANSPORT_VPN
  ///
  /// Indicates this network uses a VPN transport.
  static const TRANSPORT_VPN = 4;

  /// from: static public final int TRANSPORT_WIFI
  ///
  /// Indicates this network uses a Wi-Fi transport.
  static const TRANSPORT_WIFI = 1;

  /// from: static public final int TRANSPORT_WIFI_AWARE
  ///
  /// Indicates this network uses a Wi-Fi Aware transport.
  static const TRANSPORT_WIFI_AWARE = 5;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/net/NetworkCapabilities;)V");

  /// from: public void <init>(android.net.NetworkCapabilities nc)
  /// The returned object must be deleted after use, by calling the `delete` method.
  NetworkCapabilities(NetworkCapabilities nc)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [nc.reference]).object);

  static final _id_hasCapability =
      jniAccessors.getMethodIDOf(_classRef, "hasCapability", "(I)Z");

  /// from: public boolean hasCapability(int capability)
  ///
  /// Tests for the presence of a capability on this instance.
  ///@param capability the capabilities to be tested for.
  /// Value is android.net.NetworkCapabilities\#NET_CAPABILITY_MMS, android.net.NetworkCapabilities\#NET_CAPABILITY_SUPL, android.net.NetworkCapabilities\#NET_CAPABILITY_DUN, android.net.NetworkCapabilities\#NET_CAPABILITY_FOTA, android.net.NetworkCapabilities\#NET_CAPABILITY_IMS, android.net.NetworkCapabilities\#NET_CAPABILITY_CBS, android.net.NetworkCapabilities\#NET_CAPABILITY_WIFI_P2P, android.net.NetworkCapabilities\#NET_CAPABILITY_IA, android.net.NetworkCapabilities\#NET_CAPABILITY_RCS, android.net.NetworkCapabilities\#NET_CAPABILITY_XCAP, android.net.NetworkCapabilities\#NET_CAPABILITY_EIMS, android.net.NetworkCapabilities\#NET_CAPABILITY_NOT_METERED, android.net.NetworkCapabilities\#NET_CAPABILITY_INTERNET, android.net.NetworkCapabilities\#NET_CAPABILITY_NOT_RESTRICTED, android.net.NetworkCapabilities\#NET_CAPABILITY_TRUSTED, android.net.NetworkCapabilities\#NET_CAPABILITY_NOT_VPN, android.net.NetworkCapabilities\#NET_CAPABILITY_VALIDATED, android.net.NetworkCapabilities\#NET_CAPABILITY_CAPTIVE_PORTAL, android.net.NetworkCapabilities\#NET_CAPABILITY_NOT_ROAMING, android.net.NetworkCapabilities\#NET_CAPABILITY_FOREGROUND, android.net.NetworkCapabilities\#NET_CAPABILITY_NOT_CONGESTED, android.net.NetworkCapabilities\#NET_CAPABILITY_NOT_SUSPENDED, or android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID
  ///@return {@code true} if set on this instance.
  bool hasCapability(int capability) => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasCapability,
      jni.JniType.booleanType,
      [capability]).boolean;

  static final _id_hasTransport =
      jniAccessors.getMethodIDOf(_classRef, "hasTransport", "(I)Z");

  /// from: public boolean hasTransport(int transportType)
  ///
  /// Tests for the presence of a transport on this instance.
  ///@param transportType the transport type to be tested for.
  /// Value is android.net.NetworkCapabilities\#TRANSPORT_CELLULAR, android.net.NetworkCapabilities\#TRANSPORT_WIFI, android.net.NetworkCapabilities\#TRANSPORT_BLUETOOTH, android.net.NetworkCapabilities\#TRANSPORT_ETHERNET, android.net.NetworkCapabilities\#TRANSPORT_VPN, android.net.NetworkCapabilities\#TRANSPORT_WIFI_AWARE, or android.net.NetworkCapabilities\#TRANSPORT_LOWPAN
  ///@return {@code true} if set on this instance.
  bool hasTransport(int transportType) => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasTransport,
      jni.JniType.booleanType,
      [transportType]).boolean;

  static final _id_getLinkUpstreamBandwidthKbps = jniAccessors.getMethodIDOf(
      _classRef, "getLinkUpstreamBandwidthKbps", "()I");

  /// from: public int getLinkUpstreamBandwidthKbps()
  ///
  /// Retrieves the upstream bandwidth for this network in Kbps.  This always only refers to
  /// the estimated first hop transport bandwidth.
  ///@return The estimated first hop upstream (device to network) bandwidth.
  int getLinkUpstreamBandwidthKbps() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getLinkUpstreamBandwidthKbps,
      jni.JniType.intType, []).integer;

  static final _id_getLinkDownstreamBandwidthKbps = jniAccessors.getMethodIDOf(
      _classRef, "getLinkDownstreamBandwidthKbps", "()I");

  /// from: public int getLinkDownstreamBandwidthKbps()
  ///
  /// Retrieves the downstream bandwidth for this network in Kbps.  This always only refers to
  /// the estimated first hop transport bandwidth.
  ///@return The estimated first hop downstream (network to device) bandwidth.
  int getLinkDownstreamBandwidthKbps() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getLinkDownstreamBandwidthKbps,
      jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
