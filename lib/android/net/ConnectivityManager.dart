// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "NetworkInfo.dart" as networkinfo_;

import "Network.dart" as network_;

import "LinkProperties.dart" as linkproperties_;

import "NetworkCapabilities.dart" as networkcapabilities_;

import "ProxyInfo.dart" as proxyinfo_;

import "NetworkRequest.dart" as networkrequest_;

import "../os/Handler.dart" as handler_;

import "../app/PendingIntent.dart" as pendingintent_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.net.ConnectivityManager
///
/// Class that answers queries about the state of network connectivity. It also
/// notifies applications when network connectivity changes.
///
/// The primary responsibilities of this class are to:
/// <ol>
/// <li>Monitor network connections (Wi-Fi, GPRS, UMTS, etc.)</li>
/// <li>Send broadcast intents when network connectivity changes</li>
/// <li>Attempt to "fail over" to another network when connectivity to a network
/// is lost</li>
/// <li>Provide an API that allows applications to query the coarse-grained or fine-grained
/// state of the available networks</li>
/// <li>Provide an API that allows applications to request and select networks for their data
/// traffic</li>
/// </ol>
class ConnectivityManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/net/ConnectivityManager");
  ConnectivityManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_BACKGROUND_DATA_SETTING_CHANGED
  ///
  /// Broadcast Action: The setting for background data usage has changed
  /// values. Use \#getBackgroundDataSetting() to get the current value.
  ///
  /// If an application uses the network in the background, it should listen
  /// for this broadcast and stop using the background data if the value is
  /// {@code false}.
  ///
  ///@deprecated As of VERSION_CODES\#ICE_CREAM_SANDWICH, availability
  ///             of background data depends on several combined factors, and
  ///             this broadcast is no longer sent. Instead, when background
  ///             data is unavailable, \#getActiveNetworkInfo() will now
  ///             appear disconnected. During first boot after a platform
  ///             upgrade, this broadcast will be sent once if
  ///             \#getBackgroundDataSetting() was {@code false} before
  ///             the upgrade.
  static const ACTION_BACKGROUND_DATA_SETTING_CHANGED =
      "android.net.conn.BACKGROUND_DATA_SETTING_CHANGED";

  /// from: static public final java.lang.String ACTION_CAPTIVE_PORTAL_SIGN_IN
  ///
  /// The device has connected to a network that has presented a captive
  /// portal, which is blocking Internet connectivity. The user was presented
  /// with a notification that network sign in is required,
  /// and the user invoked the notification's action indicating they
  /// desire to sign in to the network. Apps handling this activity should
  /// facilitate signing in to the network. This action includes a
  /// Network typed extra called \#EXTRA_NETWORK that represents
  /// the network presenting the captive portal; all communication with the
  /// captive portal must be done using this {@code Network} object.
  /// <p/>
  /// This activity includes a CaptivePortal extra named
  /// \#EXTRA_CAPTIVE_PORTAL that can be used to indicate different
  /// outcomes of the captive portal sign in to the system:
  /// <ul>
  /// <li> When the app handling this action believes the user has signed in to
  /// the network and the captive portal has been dismissed, the app should
  /// call CaptivePortal\#reportCaptivePortalDismissed so the system can
  /// reevaluate the network. If reevaluation finds the network no longer
  /// subject to a captive portal, the network may become the default active
  /// data network. </li>
  /// <li> When the app handling this action believes the user explicitly wants
  /// to ignore the captive portal and the network, the app should call
  /// CaptivePortal\#ignoreNetwork. </li>
  /// </ul>
  static const ACTION_CAPTIVE_PORTAL_SIGN_IN =
      "android.net.conn.CAPTIVE_PORTAL";

  /// from: static public final java.lang.String ACTION_RESTRICT_BACKGROUND_CHANGED
  ///
  /// A change in the background metered network activity restriction has occurred.
  ///
  /// Applications should call \#getRestrictBackgroundStatus() to check if the restriction
  /// applies to them.
  ///
  /// This is only sent to registered receivers, not manifest receivers.
  static const ACTION_RESTRICT_BACKGROUND_CHANGED =
      "android.net.conn.RESTRICT_BACKGROUND_CHANGED";

  /// from: static public final java.lang.String CONNECTIVITY_ACTION
  ///
  /// A change in network connectivity has occurred. A default connection has either
  /// been established or lost. The NetworkInfo for the affected network is
  /// sent as an extra; it should be consulted to see what kind of
  /// connectivity event occurred.
  /// <p/>
  /// Apps targeting Android 7.0 (API level 24) and higher do not receive this
  /// broadcast if they declare the broadcast receiver in their manifest. Apps
  /// will still receive broadcasts if they register their
  /// android.content.BroadcastReceiver with
  /// android.content.Context\#registerReceiver Context.registerReceiver()
  /// and that context is still valid.
  /// <p/>
  /// If this is a connection that was the result of failing over from a
  /// disconnected network, then the FAILOVER_CONNECTION boolean extra is
  /// set to true.
  /// <p/>
  /// For a loss of connectivity, if the connectivity manager is attempting
  /// to connect (or has already connected) to another network, the
  /// NetworkInfo for the new network is also passed as an extra. This lets
  /// any receivers of the broadcast know that they should not necessarily
  /// tell the user that no data traffic will be possible. Instead, the
  /// receiver should expect another broadcast soon, indicating either that
  /// the failover attempt succeeded (and so there is still overall data
  /// connectivity), or that the failover attempt failed, meaning that all
  /// connectivity has been lost.
  /// <p/>
  /// For a disconnect event, the boolean extra EXTRA_NO_CONNECTIVITY
  /// is set to {@code true} if there are no connected networks at all.
  ///@deprecated apps should use the more versatile \#requestNetwork,
  ///             \#registerNetworkCallback or \#registerDefaultNetworkCallback
  ///             functions instead for faster and more detailed updates about the network
  ///             changes they care about.
  static const CONNECTIVITY_ACTION = "android.net.conn.CONNECTIVITY_CHANGE";

  /// from: static public final int DEFAULT_NETWORK_PREFERENCE
  ///
  /// If you want to set the default network preference,you can directly
  /// change the networkAttributes array in framework's config.xml.
  ///@deprecated Since we support so many more networks now, the single
  ///             network default network preference can't really express
  ///             the hierarchy.  Instead, the default is defined by the
  ///             networkAttributes in config.xml.  You can determine
  ///             the current value by calling \#getNetworkPreference()
  ///             from an App.
  static const DEFAULT_NETWORK_PREFERENCE = 1;

  /// from: static public final java.lang.String EXTRA_CAPTIVE_PORTAL
  ///
  /// The lookup key for a CaptivePortal object included with the
  /// \#ACTION_CAPTIVE_PORTAL_SIGN_IN intent.  The {@code CaptivePortal}
  /// object can be used to either indicate to the system that the captive
  /// portal has been dismissed or that the user does not want to pursue
  /// signing in to captive portal.  Retrieve it with
  /// android.content.Intent\#getParcelableExtra(String).
  static const EXTRA_CAPTIVE_PORTAL = "android.net.extra.CAPTIVE_PORTAL";

  /// from: static public final java.lang.String EXTRA_CAPTIVE_PORTAL_URL
  ///
  /// Key for passing a URL to the captive portal login activity.
  static const EXTRA_CAPTIVE_PORTAL_URL =
      "android.net.extra.CAPTIVE_PORTAL_URL";

  /// from: static public final java.lang.String EXTRA_EXTRA_INFO
  ///
  /// The lookup key for a string that provides optionally supplied
  /// extra information about the network state. The information
  /// may be passed up from the lower networking layers, and its
  /// meaning may be specific to a particular network type. Retrieve
  /// it with android.content.Intent\#getStringExtra(String).
  static const EXTRA_EXTRA_INFO = "extraInfo";

  /// from: static public final java.lang.String EXTRA_IS_FAILOVER
  ///
  /// The lookup key for a boolean that indicates whether a connect event
  /// is for a network to which the connectivity manager was failing over
  /// following a disconnect on another network.
  /// Retrieve it with android.content.Intent\#getBooleanExtra(String,boolean).
  static const EXTRA_IS_FAILOVER = "isFailover";

  /// from: static public final java.lang.String EXTRA_NETWORK
  ///
  /// The lookup key for a Network object included with the intent after
  /// successfully finding a network for the applications request.  Retrieve it with
  /// android.content.Intent\#getParcelableExtra(String).
  ///
  /// Note that if you intend to invoke Network\#openConnection(java.net.URL)
  /// then you must get a ConnectivityManager instance before doing so.
  static const EXTRA_NETWORK = "android.net.extra.NETWORK";

  /// from: static public final java.lang.String EXTRA_NETWORK_INFO
  ///
  /// The lookup key for a NetworkInfo object. Retrieve with
  /// android.content.Intent\#getParcelableExtra(String).
  ///@deprecated Since NetworkInfo can vary based on UID, applications
  ///             should always obtain network information through
  ///             \#getActiveNetworkInfo().
  ///@see \#EXTRA_NETWORK_TYPE
  static const EXTRA_NETWORK_INFO = "networkInfo";

  /// from: static public final java.lang.String EXTRA_NETWORK_REQUEST
  ///
  /// The lookup key for a NetworkRequest object included with the intent after
  /// successfully finding a network for the applications request.  Retrieve it with
  /// android.content.Intent\#getParcelableExtra(String).
  static const EXTRA_NETWORK_REQUEST = "android.net.extra.NETWORK_REQUEST";

  /// from: static public final java.lang.String EXTRA_NETWORK_TYPE
  ///
  /// Network type which triggered a \#CONNECTIVITY_ACTION broadcast.
  ///@see android.content.Intent\#getIntExtra(String, int)
  static const EXTRA_NETWORK_TYPE = "networkType";

  /// from: static public final java.lang.String EXTRA_NO_CONNECTIVITY
  ///
  /// The lookup key for a boolean that indicates whether there is a
  /// complete lack of connectivity, i.e., no network is available.
  /// Retrieve it with android.content.Intent\#getBooleanExtra(String,boolean).
  static const EXTRA_NO_CONNECTIVITY = "noConnectivity";

  /// from: static public final java.lang.String EXTRA_OTHER_NETWORK_INFO
  ///
  /// The lookup key for a NetworkInfo object. This is supplied when
  /// there is another network that it may be possible to connect to. Retrieve with
  /// android.content.Intent\#getParcelableExtra(String).
  static const EXTRA_OTHER_NETWORK_INFO = "otherNetwork";

  /// from: static public final java.lang.String EXTRA_REASON
  ///
  /// The lookup key for a string that indicates why an attempt to connect
  /// to a network failed. The string has no particular structure. It is
  /// intended to be used in notifications presented to users. Retrieve
  /// it with android.content.Intent\#getStringExtra(String).
  static const EXTRA_REASON = "reason";

  /// from: static public final int MULTIPATH_PREFERENCE_HANDOVER
  ///
  /// It is acceptable to briefly use multipath data to provide seamless connectivity for
  /// time-sensitive user-facing operations when the system default network is temporarily
  /// unresponsive. The amount of data should be limited (less than one megabyte for every call to
  /// this method), and the operation should be infrequent to ensure that data usage is limited.
  ///
  /// An example of such an operation might be a time-sensitive foreground activity, such as a
  /// voice command, that the user is performing while walking out of range of a Wi-Fi network.
  static const MULTIPATH_PREFERENCE_HANDOVER = 1;

  /// from: static public final int MULTIPATH_PREFERENCE_PERFORMANCE
  ///
  /// It is acceptable to use metered data to improve network latency and performance.
  static const MULTIPATH_PREFERENCE_PERFORMANCE = 4;

  /// from: static public final int MULTIPATH_PREFERENCE_RELIABILITY
  ///
  /// It is acceptable to use small amounts of multipath data on an ongoing basis to provide
  /// a backup channel for traffic that is primarily going over another network.
  ///
  /// An example might be maintaining backup connections to peers or servers for the purpose of
  /// fast fallback if the default network is temporarily unresponsive or disconnects. The traffic
  /// on backup paths should be negligible compared to the traffic on the main path.
  static const MULTIPATH_PREFERENCE_RELIABILITY = 2;

  /// from: static public final int RESTRICT_BACKGROUND_STATUS_DISABLED
  ///
  /// Device is not restricting metered network activity while application is running on
  /// background.
  static const RESTRICT_BACKGROUND_STATUS_DISABLED = 1;

  /// from: static public final int RESTRICT_BACKGROUND_STATUS_ENABLED
  ///
  /// Device is restricting metered network activity while application is running on background.
  ///
  /// In this state, application should not try to use the network while running on background,
  /// because it would be denied.
  static const RESTRICT_BACKGROUND_STATUS_ENABLED = 3;

  /// from: static public final int RESTRICT_BACKGROUND_STATUS_WHITELISTED
  ///
  /// Device is restricting metered network activity while application is running on background,
  /// but application is allowed to bypass it.
  ///
  /// In this state, application should take action to mitigate metered network access.
  /// For example, a music streaming application should switch to a low-bandwidth bitrate.
  static const RESTRICT_BACKGROUND_STATUS_WHITELISTED = 2;

  /// from: static public final int TYPE_BLUETOOTH
  ///
  /// A Bluetooth data connection.
  ///@deprecated Applications should instead use NetworkCapabilities\#hasTransport or
  ///         \#requestNetwork(NetworkRequest, NetworkCallback) to request an
  ///         appropriate network. {@see NetworkCapabilities} for supported transports.
  static const TYPE_BLUETOOTH = 7;

  /// from: static public final int TYPE_DUMMY
  ///
  /// Dummy data connection.  This should not be used on shipping devices.
  ///@deprecated This is not used any more.
  static const TYPE_DUMMY = 8;

  /// from: static public final int TYPE_ETHERNET
  ///
  /// An Ethernet data connection.
  ///@deprecated Applications should instead use NetworkCapabilities\#hasTransport or
  ///         \#requestNetwork(NetworkRequest, NetworkCallback) to request an
  ///         appropriate network. {@see NetworkCapabilities} for supported transports.
  static const TYPE_ETHERNET = 9;

  /// from: static public final int TYPE_MOBILE
  ///
  /// A Mobile data connection. Devices may support more than one.
  ///@deprecated Applications should instead use NetworkCapabilities\#hasTransport or
  ///         \#requestNetwork(NetworkRequest, NetworkCallback) to request an
  ///         appropriate network. {@see NetworkCapabilities} for supported transports.
  static const TYPE_MOBILE = 0;

  /// from: static public final int TYPE_MOBILE_DUN
  ///
  /// A DUN-specific Mobile data connection.  This network type may use the
  /// same network interface as \#TYPE_MOBILE or it may use a different
  /// one.  This is sometimes by the system when setting up an upstream connection
  /// for tethering so that the carrier is aware of DUN traffic.
  ///@deprecated Applications should instead use NetworkCapabilities\#hasCapability or
  ///         \#requestNetwork(NetworkRequest, NetworkCallback) to request a network that
  ///         provides the NetworkCapabilities\#NET_CAPABILITY_DUN capability.
  static const TYPE_MOBILE_DUN = 4;

  /// from: static public final int TYPE_MOBILE_HIPRI
  ///
  /// A High Priority Mobile data connection.  This network type uses the
  /// same network interface as \#TYPE_MOBILE but the routing setup
  /// is different.
  ///@deprecated Applications should instead use NetworkCapabilities\#hasTransport or
  ///         \#requestNetwork(NetworkRequest, NetworkCallback) to request an
  ///         appropriate network. {@see NetworkCapabilities} for supported transports.
  static const TYPE_MOBILE_HIPRI = 5;

  /// from: static public final int TYPE_MOBILE_MMS
  ///
  /// An MMS-specific Mobile data connection.  This network type may use the
  /// same network interface as \#TYPE_MOBILE or it may use a different
  /// one.  This is used by applications needing to talk to the carrier's
  /// Multimedia Messaging Service servers.
  ///@deprecated Applications should instead use NetworkCapabilities\#hasCapability or
  ///         \#requestNetwork(NetworkRequest, NetworkCallback) to request a network that
  ///         provides the NetworkCapabilities\#NET_CAPABILITY_MMS capability.
  static const TYPE_MOBILE_MMS = 2;

  /// from: static public final int TYPE_MOBILE_SUPL
  ///
  /// A SUPL-specific Mobile data connection.  This network type may use the
  /// same network interface as \#TYPE_MOBILE or it may use a different
  /// one.  This is used by applications needing to talk to the carrier's
  /// Secure User Plane Location servers for help locating the device.
  ///@deprecated Applications should instead use NetworkCapabilities\#hasCapability or
  ///         \#requestNetwork(NetworkRequest, NetworkCallback) to request a network that
  ///         provides the NetworkCapabilities\#NET_CAPABILITY_SUPL capability.
  static const TYPE_MOBILE_SUPL = 3;

  /// from: static public final int TYPE_VPN
  ///
  /// A virtual network using one or more native bearers.
  /// It may or may not be providing security services.
  ///@deprecated Applications should use NetworkCapabilities\#TRANSPORT_VPN instead.
  static const TYPE_VPN = 17;

  /// from: static public final int TYPE_WIFI
  ///
  /// A WIFI data connection. Devices may support more than one.
  ///@deprecated Applications should instead use NetworkCapabilities\#hasTransport or
  ///         \#requestNetwork(NetworkRequest, NetworkCallback) to request an
  ///         appropriate network. {@see NetworkCapabilities} for supported transports.
  static const TYPE_WIFI = 1;

  /// from: static public final int TYPE_WIMAX
  ///
  /// A WiMAX data connection.
  ///@deprecated Applications should instead use NetworkCapabilities\#hasTransport or
  ///         \#requestNetwork(NetworkRequest, NetworkCallback) to request an
  ///         appropriate network. {@see NetworkCapabilities} for supported transports.
  static const TYPE_WIMAX = 6;

  static final _id_isNetworkTypeValid =
      jniAccessors.getStaticMethodIDOf(_classRef, "isNetworkTypeValid", "(I)Z");

  /// from: static public boolean isNetworkTypeValid(int networkType)
  ///
  /// Tests if a given integer represents a valid network type.
  ///@param networkType the type to be tested
  ///@return a boolean.  {@code true} if the type is valid, else {@code false}
  ///@deprecated All APIs accepting a network type are deprecated. There should be no need to
  ///             validate a network type.
  static bool isNetworkTypeValid(int networkType) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isNetworkTypeValid,
          jni.JniType.booleanType, [networkType]).boolean;

  static final _id_setNetworkPreference =
      jniAccessors.getMethodIDOf(_classRef, "setNetworkPreference", "(I)V");

  /// from: public void setNetworkPreference(int preference)
  ///
  /// Specifies the preferred network type.  When the device has more
  /// than one type available the preferred network type will be used.
  ///@param preference the network type to prefer over all others.  It is
  ///         unspecified what happens to the old preferred network in the
  ///         overall ordering.
  ///@deprecated Functionality has been removed as it no longer makes sense,
  ///             with many more than two networks - we'd need an array to express
  ///             preference.  Instead we use dynamic network properties of
  ///             the networks to describe their precedence.
  void setNetworkPreference(int preference) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setNetworkPreference,
      jni.JniType.voidType,
      [preference]).check();

  static final _id_getNetworkPreference =
      jniAccessors.getMethodIDOf(_classRef, "getNetworkPreference", "()I");

  /// from: public int getNetworkPreference()
  ///
  /// Retrieves the current preferred network type.
  ///
  /// Requires android.Manifest.permission\#ACCESS_NETWORK_STATE
  ///@return an integer representing the preferred network type
  ///@deprecated Functionality has been removed as it no longer makes sense,
  ///             with many more than two networks - we'd need an array to express
  ///             preference.  Instead we use dynamic network properties of
  ///             the networks to describe their precedence.
  int getNetworkPreference() => jniAccessors.callMethodWithArgs(
      reference, _id_getNetworkPreference, jni.JniType.intType, []).integer;

  static final _id_getActiveNetworkInfo = jniAccessors.getMethodIDOf(
      _classRef, "getActiveNetworkInfo", "()Landroid/net/NetworkInfo;");

  /// from: public android.net.NetworkInfo getActiveNetworkInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns details about the currently active default data network. When
  /// connected, this network is the default route for outgoing connections.
  /// You should always check NetworkInfo\#isConnected() before initiating
  /// network traffic. This may return {@code null} when there is no default
  /// network.
  /// Note that if the default network is a VPN, this method will return the
  /// NetworkInfo for one of its underlying networks instead, or null if the
  /// VPN agent did not specify any. Apps interested in learning about VPNs
  /// should use \#getNetworkInfo(android.net.Network) instead.
  ///
  /// Requires android.Manifest.permission\#ACCESS_NETWORK_STATE
  ///@return a NetworkInfo object for the current default network
  ///        or {@code null} if no default network is currently active
  networkinfo_.NetworkInfo getActiveNetworkInfo() =>
      networkinfo_.NetworkInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getActiveNetworkInfo,
          jni.JniType.objectType, []).object);

  static final _id_getActiveNetwork = jniAccessors.getMethodIDOf(
      _classRef, "getActiveNetwork", "()Landroid/net/Network;");

  /// from: public android.net.Network getActiveNetwork()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Network object corresponding to the currently active
  /// default data network.  In the event that the current active default data
  /// network disconnects, the returned {@code Network} object will no longer
  /// be usable.  This will return {@code null} when there is no default
  /// network.
  ///
  /// Requires android.Manifest.permission\#ACCESS_NETWORK_STATE
  ///@return a Network object for the current default network or
  ///        {@code null} if no default network is currently active
  network_.Network getActiveNetwork() =>
      network_.Network.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getActiveNetwork, jni.JniType.objectType, []).object);

  static final _id_getNetworkInfo = jniAccessors.getMethodIDOf(
      _classRef, "getNetworkInfo", "(I)Landroid/net/NetworkInfo;");

  /// from: public android.net.NetworkInfo getNetworkInfo(int networkType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns connection status information about a particular
  /// network type.
  ///
  /// Requires android.Manifest.permission\#ACCESS_NETWORK_STATE
  ///@param networkType integer specifying which networkType in
  ///        which you're interested.
  ///@return a NetworkInfo object for the requested
  ///        network type or {@code null} if the type is not
  ///        supported by the device. If {@code networkType} is
  ///        TYPE_VPN and a VPN is active for the calling app,
  ///        then this method will try to return one of the
  ///        underlying networks for the VPN or null if the
  ///        VPN agent didn't specify any.
  ///@deprecated This method does not support multiple connected networks
  ///             of the same type. Use \#getAllNetworks and
  ///             \#getNetworkInfo(android.net.Network) instead.
  networkinfo_.NetworkInfo getNetworkInfo(int networkType) =>
      networkinfo_.NetworkInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getNetworkInfo,
          jni.JniType.objectType,
          [networkType]).object);

  static final _id_getNetworkInfo1 = jniAccessors.getMethodIDOf(_classRef,
      "getNetworkInfo", "(Landroid/net/Network;)Landroid/net/NetworkInfo;");

  /// from: public android.net.NetworkInfo getNetworkInfo(android.net.Network network)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns connection status information about a particular
  /// Network.
  ///
  /// Requires android.Manifest.permission\#ACCESS_NETWORK_STATE
  ///@param network Network specifying which network
  ///        in which you're interested.
  ///@return a NetworkInfo object for the requested
  ///        network or {@code null} if the {@code Network}
  ///        is not valid.
  networkinfo_.NetworkInfo getNetworkInfo1(network_.Network network) =>
      networkinfo_.NetworkInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getNetworkInfo1,
          jni.JniType.objectType,
          [network.reference]).object);

  static final _id_getAllNetworkInfo = jniAccessors.getMethodIDOf(
      _classRef, "getAllNetworkInfo", "()[Landroid/net/NetworkInfo;");

  /// from: public android.net.NetworkInfo[] getAllNetworkInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns connection status information about all network
  /// types supported by the device.
  ///
  /// Requires android.Manifest.permission\#ACCESS_NETWORK_STATE
  ///@return an array of NetworkInfo objects.  Check each
  /// NetworkInfo\#getType for which type each applies.
  ///@deprecated This method does not support multiple connected networks
  ///             of the same type. Use \#getAllNetworks and
  ///             \#getNetworkInfo(android.net.Network) instead.
  jni.JniObject getAllNetworkInfo() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAllNetworkInfo, jni.JniType.objectType, []).object);

  static final _id_getAllNetworks = jniAccessors.getMethodIDOf(
      _classRef, "getAllNetworks", "()[Landroid/net/Network;");

  /// from: public android.net.Network[] getAllNetworks()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an array of all Network currently tracked by the
  /// framework.
  ///
  /// Requires android.Manifest.permission\#ACCESS_NETWORK_STATE
  ///@return an array of Network objects.
  jni.JniObject getAllNetworks() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAllNetworks, jni.JniType.objectType, []).object);

  static final _id_getLinkProperties = jniAccessors.getMethodIDOf(
      _classRef,
      "getLinkProperties",
      "(Landroid/net/Network;)Landroid/net/LinkProperties;");

  /// from: public android.net.LinkProperties getLinkProperties(android.net.Network network)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the LinkProperties for the given Network.  This
  /// will return {@code null} if the network is unknown.
  ///
  /// Requires android.Manifest.permission\#ACCESS_NETWORK_STATE
  ///@param network The Network object identifying the network in question.
  ///@return The LinkProperties for the network, or {@code null}.
  linkproperties_.LinkProperties getLinkProperties(network_.Network network) =>
      linkproperties_.LinkProperties.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getLinkProperties,
          jni.JniType.objectType,
          [network.reference]).object);

  static final _id_getNetworkCapabilities = jniAccessors.getMethodIDOf(
      _classRef,
      "getNetworkCapabilities",
      "(Landroid/net/Network;)Landroid/net/NetworkCapabilities;");

  /// from: public android.net.NetworkCapabilities getNetworkCapabilities(android.net.Network network)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the android.net.NetworkCapabilities for the given Network.  This
  /// will return {@code null} if the network is unknown.
  ///
  /// Requires android.Manifest.permission\#ACCESS_NETWORK_STATE
  ///@param network The Network object identifying the network in question.
  ///@return The android.net.NetworkCapabilities for the network, or {@code null}.
  networkcapabilities_.NetworkCapabilities getNetworkCapabilities(
          network_.Network network) =>
      networkcapabilities_.NetworkCapabilities.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getNetworkCapabilities,
              jni.JniType.objectType, [network.reference]).object);

  static final _id_getBackgroundDataSetting =
      jniAccessors.getMethodIDOf(_classRef, "getBackgroundDataSetting", "()Z");

  /// from: public boolean getBackgroundDataSetting()
  ///
  /// Returns the value of the setting for background data usage. If false,
  /// applications should not use the network if the application is not in the
  /// foreground. Developers should respect this setting, and check the value
  /// of this before performing any background data operations.
  ///
  /// All applications that have background services that use the network
  /// should listen to \#ACTION_BACKGROUND_DATA_SETTING_CHANGED.
  ///
  ///@deprecated As of VERSION_CODES\#ICE_CREAM_SANDWICH, availability of
  /// background data depends on several combined factors, and this method will
  /// always return {@code true}. Instead, when background data is unavailable,
  /// \#getActiveNetworkInfo() will now appear disconnected.
  ///@return Whether background data usage is allowed.
  bool getBackgroundDataSetting() => jniAccessors.callMethodWithArgs(reference,
      _id_getBackgroundDataSetting, jni.JniType.booleanType, []).boolean;

  static final _id_addDefaultNetworkActiveListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addDefaultNetworkActiveListener",
      "(Landroid/net/ConnectivityManager\$OnNetworkActiveListener;)V");

  /// from: public void addDefaultNetworkActiveListener(android.net.ConnectivityManager.OnNetworkActiveListener l)
  ///
  /// Start listening to reports when the system's default data network is active, meaning it is
  /// a good time to perform network traffic.  Use \#isDefaultNetworkActive()
  /// to determine the current state of the system's default network after registering the
  /// listener.
  ///
  /// If the process default network has been set with
  /// ConnectivityManager\#bindProcessToNetwork this function will not
  /// reflect the process's default, but the system default.
  ///@param l The listener to be told when the network is active.
  void addDefaultNetworkActiveListener(
          ConnectivityManager_OnNetworkActiveListener l) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addDefaultNetworkActiveListener,
          jni.JniType.voidType,
          [l.reference]).check();

  static final _id_removeDefaultNetworkActiveListener =
      jniAccessors.getMethodIDOf(
          _classRef,
          "removeDefaultNetworkActiveListener",
          "(Landroid/net/ConnectivityManager\$OnNetworkActiveListener;)V");

  /// from: public void removeDefaultNetworkActiveListener(android.net.ConnectivityManager.OnNetworkActiveListener l)
  ///
  /// Remove network active listener previously registered with
  /// \#addDefaultNetworkActiveListener.
  ///@param l Previously registered listener.
  void removeDefaultNetworkActiveListener(
          ConnectivityManager_OnNetworkActiveListener l) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeDefaultNetworkActiveListener,
          jni.JniType.voidType,
          [l.reference]).check();

  static final _id_isDefaultNetworkActive =
      jniAccessors.getMethodIDOf(_classRef, "isDefaultNetworkActive", "()Z");

  /// from: public boolean isDefaultNetworkActive()
  ///
  /// Return whether the data network is currently active.  An active network means that
  /// it is currently in a high power state for performing data transmission.  On some
  /// types of networks, it may be expensive to move and stay in such a state, so it is
  /// more power efficient to batch network traffic together when the radio is already in
  /// this state.  This method tells you whether right now is currently a good time to
  /// initiate network traffic, as the network is already active.
  bool isDefaultNetworkActive() => jniAccessors.callMethodWithArgs(reference,
      _id_isDefaultNetworkActive, jni.JniType.booleanType, []).boolean;

  static final _id_reportBadNetwork = jniAccessors.getMethodIDOf(
      _classRef, "reportBadNetwork", "(Landroid/net/Network;)V");

  /// from: public void reportBadNetwork(android.net.Network network)
  ///
  /// Report a problem network to the framework.  This provides a hint to the system
  /// that there might be connectivity problems on this network and may cause
  /// the framework to re-evaluate network connectivity and/or switch to another
  /// network.
  ///@param network The Network the application was attempting to use
  ///                or {@code null} to indicate the current default network.
  ///@deprecated Use \#reportNetworkConnectivity which allows reporting both
  ///             working and non-working connectivity.
  void reportBadNetwork(network_.Network network) =>
      jniAccessors.callMethodWithArgs(reference, _id_reportBadNetwork,
          jni.JniType.voidType, [network.reference]).check();

  static final _id_reportNetworkConnectivity = jniAccessors.getMethodIDOf(
      _classRef, "reportNetworkConnectivity", "(Landroid/net/Network;Z)V");

  /// from: public void reportNetworkConnectivity(android.net.Network network, boolean hasConnectivity)
  ///
  /// Report to the framework whether a network has working connectivity.
  /// This provides a hint to the system that a particular network is providing
  /// working connectivity or not.  In response the framework may re-evaluate
  /// the network's connectivity and might take further action thereafter.
  ///@param network The Network the application was attempting to use
  ///                or {@code null} to indicate the current default network.
  ///@param hasConnectivity {@code true} if the application was able to successfully access the
  ///                        Internet using {@code network} or {@code false} if not.
  void reportNetworkConnectivity(
          network_.Network network, bool hasConnectivity) =>
      jniAccessors.callMethodWithArgs(reference, _id_reportNetworkConnectivity,
          jni.JniType.voidType, [network.reference, hasConnectivity]).check();

  static final _id_getDefaultProxy = jniAccessors.getMethodIDOf(
      _classRef, "getDefaultProxy", "()Landroid/net/ProxyInfo;");

  /// from: public android.net.ProxyInfo getDefaultProxy()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the current default HTTP proxy settings.  If a global proxy is set it will be returned,
  /// otherwise if this process is bound to a Network using
  /// \#bindProcessToNetwork then that {@code Network}'s proxy is returned, otherwise
  /// the default network's proxy is returned.
  ///@return the ProxyInfo for the current HTTP proxy, or {@code null} if no
  ///        HTTP proxy is active.
  proxyinfo_.ProxyInfo getDefaultProxy() =>
      proxyinfo_.ProxyInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDefaultProxy, jni.JniType.objectType, []).object);

  static final _id_isActiveNetworkMetered =
      jniAccessors.getMethodIDOf(_classRef, "isActiveNetworkMetered", "()Z");

  /// from: public boolean isActiveNetworkMetered()
  ///
  /// Returns if the currently active data network is metered. A network is
  /// classified as metered when the user is sensitive to heavy data usage on
  /// that connection due to monetary costs, data limitations or
  /// battery/performance issues. You should check this before doing large
  /// data transfers, and warn the user or delay the operation until another
  /// network is available.
  ///
  /// Requires android.Manifest.permission\#ACCESS_NETWORK_STATE
  ///@return {@code true} if large transfers should be avoided, otherwise
  ///        {@code false}.
  bool isActiveNetworkMetered() => jniAccessors.callMethodWithArgs(reference,
      _id_isActiveNetworkMetered, jni.JniType.booleanType, []).boolean;

  static final _id_requestNetwork = jniAccessors.getMethodIDOf(
      _classRef,
      "requestNetwork",
      "(Landroid/net/NetworkRequest;Landroid/net/ConnectivityManager\$NetworkCallback;)V");

  /// from: public void requestNetwork(android.net.NetworkRequest request, android.net.ConnectivityManager.NetworkCallback networkCallback)
  ///
  /// Request a network to satisfy a set of android.net.NetworkCapabilities.
  ///
  /// This NetworkRequest will live until released via
  /// \#unregisterNetworkCallback(NetworkCallback) or the calling application exits. A
  /// version of the method which takes a timeout is
  /// \#requestNetwork(NetworkRequest, NetworkCallback, int).
  /// Status of the request can be followed by listening to the various
  /// callbacks described in NetworkCallback.  The Network
  /// can be used to direct traffic to the network.
  /// It is presently unsupported to request a network with mutable
  /// NetworkCapabilities such as
  /// NetworkCapabilities\#NET_CAPABILITY_VALIDATED or
  /// NetworkCapabilities\#NET_CAPABILITY_CAPTIVE_PORTAL
  /// as these {@code NetworkCapabilities} represent states that a particular
  /// network may never attain, and whether a network will attain these states
  /// is unknown prior to bringing up the network so the framework does not
  /// know how to go about satisfing a request with these capabilities.
  ///
  /// This method requires the caller to hold either the
  /// android.Manifest.permission\#CHANGE_NETWORK_STATE permission
  /// or the ability to modify system settings as determined by
  /// android.provider.Settings.System\#canWrite.
  ///
  ///@param request NetworkRequest describing this request.
  ///@param networkCallback The NetworkCallback to be utilized for this request. Note
  ///                        the callback must not be shared - it uniquely specifies this request.
  ///                        The callback is invoked on the default internal Handler.
  ///@throws IllegalArgumentException if {@code request} specifies any mutable
  ///         {@code NetworkCapabilities}.
  void requestNetwork(networkrequest_.NetworkRequest request,
          ConnectivityManager_NetworkCallback networkCallback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestNetwork,
          jni.JniType.voidType,
          [request.reference, networkCallback.reference]).check();

  static final _id_requestNetwork1 = jniAccessors.getMethodIDOf(
      _classRef,
      "requestNetwork",
      "(Landroid/net/NetworkRequest;Landroid/net/ConnectivityManager\$NetworkCallback;Landroid/os/Handler;)V");

  /// from: public void requestNetwork(android.net.NetworkRequest request, android.net.ConnectivityManager.NetworkCallback networkCallback, android.os.Handler handler)
  ///
  /// Request a network to satisfy a set of android.net.NetworkCapabilities.
  ///
  /// This NetworkRequest will live until released via
  /// \#unregisterNetworkCallback(NetworkCallback) or the calling application exits. A
  /// version of the method which takes a timeout is
  /// \#requestNetwork(NetworkRequest, NetworkCallback, int).
  /// Status of the request can be followed by listening to the various
  /// callbacks described in NetworkCallback.  The Network
  /// can be used to direct traffic to the network.
  /// It is presently unsupported to request a network with mutable
  /// NetworkCapabilities such as
  /// NetworkCapabilities\#NET_CAPABILITY_VALIDATED or
  /// NetworkCapabilities\#NET_CAPABILITY_CAPTIVE_PORTAL
  /// as these {@code NetworkCapabilities} represent states that a particular
  /// network may never attain, and whether a network will attain these states
  /// is unknown prior to bringing up the network so the framework does not
  /// know how to go about satisfing a request with these capabilities.
  ///
  /// This method requires the caller to hold either the
  /// android.Manifest.permission\#CHANGE_NETWORK_STATE permission
  /// or the ability to modify system settings as determined by
  /// android.provider.Settings.System\#canWrite.
  ///
  ///@param request NetworkRequest describing this request.
  ///@param networkCallback The NetworkCallback to be utilized for this request. Note
  ///                        the callback must not be shared - it uniquely specifies this request.
  ///@param handler Handler to specify the thread upon which the callback will be invoked.
  ///@throws IllegalArgumentException if {@code request} specifies any mutable
  ///         {@code NetworkCapabilities}.
  void requestNetwork1(
          networkrequest_.NetworkRequest request,
          ConnectivityManager_NetworkCallback networkCallback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_requestNetwork1, jni.JniType.voidType, [
        request.reference,
        networkCallback.reference,
        handler.reference
      ]).check();

  static final _id_requestNetwork2 = jniAccessors.getMethodIDOf(
      _classRef,
      "requestNetwork",
      "(Landroid/net/NetworkRequest;Landroid/net/ConnectivityManager\$NetworkCallback;I)V");

  /// from: public void requestNetwork(android.net.NetworkRequest request, android.net.ConnectivityManager.NetworkCallback networkCallback, int timeoutMs)
  ///
  /// Request a network to satisfy a set of android.net.NetworkCapabilities, limited
  /// by a timeout.
  ///
  /// This function behaves identically to the non-timed-out version
  /// \#requestNetwork(NetworkRequest, NetworkCallback), but if a suitable network
  /// is not found within the given time (in milliseconds) the
  /// NetworkCallback\#onUnavailable() callback is called. The request can still be
  /// released normally by calling \#unregisterNetworkCallback(NetworkCallback) but does
  /// not have to be released if timed-out (it is automatically released). Unregistering a
  /// request that timed out is not an error.
  ///
  /// Do not use this method to poll for the existence of specific networks (e.g. with a small
  /// timeout) - \#registerNetworkCallback(NetworkRequest, NetworkCallback) is provided
  /// for that purpose. Calling this method will attempt to bring up the requested network.
  ///
  /// This method requires the caller to hold either the
  /// android.Manifest.permission\#CHANGE_NETWORK_STATE permission
  /// or the ability to modify system settings as determined by
  /// android.provider.Settings.System\#canWrite.
  ///
  ///@param request NetworkRequest describing this request.
  ///@param networkCallback The NetworkCallback to be utilized for this request. Note
  ///                        the callback must not be shared - it uniquely specifies this request.
  ///@param timeoutMs The time in milliseconds to attempt looking for a suitable network
  ///                  before NetworkCallback\#onUnavailable() is called. The timeout must
  ///                  be a positive value (i.e. >0).
  void requestNetwork2(networkrequest_.NetworkRequest request,
          ConnectivityManager_NetworkCallback networkCallback, int timeoutMs) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestNetwork2,
          jni.JniType.voidType,
          [request.reference, networkCallback.reference, timeoutMs]).check();

  static final _id_requestNetwork3 = jniAccessors.getMethodIDOf(
      _classRef,
      "requestNetwork",
      "(Landroid/net/NetworkRequest;Landroid/net/ConnectivityManager\$NetworkCallback;Landroid/os/Handler;I)V");

  /// from: public void requestNetwork(android.net.NetworkRequest request, android.net.ConnectivityManager.NetworkCallback networkCallback, android.os.Handler handler, int timeoutMs)
  ///
  /// Request a network to satisfy a set of android.net.NetworkCapabilities, limited
  /// by a timeout.
  ///
  /// This function behaves identically to the non-timedout version, but if a suitable
  /// network is not found within the given time (in milliseconds) the
  /// NetworkCallback\#onUnavailable callback is called. The request can still be
  /// released normally by calling \#unregisterNetworkCallback(NetworkCallback) but does
  /// not have to be released if timed-out (it is automatically released). Unregistering a
  /// request that timed out is not an error.
  ///
  /// Do not use this method to poll for the existence of specific networks (e.g. with a small
  /// timeout) - \#registerNetworkCallback(NetworkRequest, NetworkCallback) is provided
  /// for that purpose. Calling this method will attempt to bring up the requested network.
  ///
  /// This method requires the caller to hold either the
  /// android.Manifest.permission\#CHANGE_NETWORK_STATE permission
  /// or the ability to modify system settings as determined by
  /// android.provider.Settings.System\#canWrite.
  ///
  ///@param request NetworkRequest describing this request.
  ///@param networkCallback The NetworkCallback to be utilized for this request. Note
  ///                        the callback must not be shared - it uniquely specifies this request.
  ///@param handler Handler to specify the thread upon which the callback will be invoked.
  ///@param timeoutMs The time in milliseconds to attempt looking for a suitable network
  ///                  before NetworkCallback\#onUnavailable is called.
  void requestNetwork3(
          networkrequest_.NetworkRequest request,
          ConnectivityManager_NetworkCallback networkCallback,
          handler_.Handler handler,
          int timeoutMs) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_requestNetwork3, jni.JniType.voidType, [
        request.reference,
        networkCallback.reference,
        handler.reference,
        timeoutMs
      ]).check();

  static final _id_requestNetwork4 = jniAccessors.getMethodIDOf(
      _classRef,
      "requestNetwork",
      "(Landroid/net/NetworkRequest;Landroid/app/PendingIntent;)V");

  /// from: public void requestNetwork(android.net.NetworkRequest request, android.app.PendingIntent operation)
  ///
  /// Request a network to satisfy a set of android.net.NetworkCapabilities.
  ///
  /// This function behaves identically to the version that takes a NetworkCallback, but instead
  /// of NetworkCallback a PendingIntent is used.  This means
  /// the request may outlive the calling application and get called back when a suitable
  /// network is found.
  ///
  /// The operation is an Intent broadcast that goes to a broadcast receiver that
  /// you registered with Context\#registerReceiver or through the
  /// &lt;receiver&gt; tag in an AndroidManifest.xml file
  ///
  /// The operation Intent is delivered with two extras, a Network typed
  /// extra called \#EXTRA_NETWORK and a NetworkRequest
  /// typed extra called \#EXTRA_NETWORK_REQUEST containing
  /// the original requests parameters.  It is important to create a new,
  /// NetworkCallback based request before completing the processing of the
  /// Intent to reserve the network or it will be released shortly after the Intent
  /// is processed.
  ///
  /// If there is already a request for this Intent registered (with the equality of
  /// two Intents defined by Intent\#filterEquals), then it will be removed and
  /// replaced by this one, effectively releasing the previous NetworkRequest.
  ///
  /// The request may be released normally by calling
  /// \#releaseNetworkRequest(android.app.PendingIntent).
  /// It is presently unsupported to request a network with either
  /// NetworkCapabilities\#NET_CAPABILITY_VALIDATED or
  /// NetworkCapabilities\#NET_CAPABILITY_CAPTIVE_PORTAL
  /// as these {@code NetworkCapabilities} represent states that a particular
  /// network may never attain, and whether a network will attain these states
  /// is unknown prior to bringing up the network so the framework does not
  /// know how to go about satisfing a request with these capabilities.
  ///
  /// This method requires the caller to hold either the
  /// android.Manifest.permission\#CHANGE_NETWORK_STATE permission
  /// or the ability to modify system settings as determined by
  /// android.provider.Settings.System\#canWrite.
  ///
  ///@param request NetworkRequest describing this request.
  ///@param operation Action to perform when the network is available (corresponds
  ///                  to the NetworkCallback\#onAvailable call.  Typically
  ///                  comes from PendingIntent\#getBroadcast. Cannot be null.
  ///@throws IllegalArgumentException if {@code request} contains either
  ///         NetworkCapabilities\#NET_CAPABILITY_VALIDATED or
  ///         NetworkCapabilities\#NET_CAPABILITY_CAPTIVE_PORTAL.
  void requestNetwork4(networkrequest_.NetworkRequest request,
          pendingintent_.PendingIntent operation) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestNetwork4,
          jni.JniType.voidType,
          [request.reference, operation.reference]).check();

  static final _id_releaseNetworkRequest = jniAccessors.getMethodIDOf(
      _classRef, "releaseNetworkRequest", "(Landroid/app/PendingIntent;)V");

  /// from: public void releaseNetworkRequest(android.app.PendingIntent operation)
  ///
  /// Removes a request made via \#requestNetwork(NetworkRequest, android.app.PendingIntent)
  ///
  /// This method has the same behavior as
  /// \#unregisterNetworkCallback(android.app.PendingIntent) with respect to
  /// releasing network resources and disconnecting.
  ///@param operation A PendingIntent equal (as defined by Intent\#filterEquals) to the
  ///                  PendingIntent passed to
  ///                  \#requestNetwork(NetworkRequest, android.app.PendingIntent) with the
  ///                  corresponding NetworkRequest you'd like to remove. Cannot be null.
  void releaseNetworkRequest(pendingintent_.PendingIntent operation) =>
      jniAccessors.callMethodWithArgs(reference, _id_releaseNetworkRequest,
          jni.JniType.voidType, [operation.reference]).check();

  static final _id_registerNetworkCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerNetworkCallback",
      "(Landroid/net/NetworkRequest;Landroid/net/ConnectivityManager\$NetworkCallback;)V");

  /// from: public void registerNetworkCallback(android.net.NetworkRequest request, android.net.ConnectivityManager.NetworkCallback networkCallback)
  ///
  /// Registers to receive notifications about all networks which satisfy the given
  /// NetworkRequest.  The callbacks will continue to be called until
  /// either the application exits or link \#unregisterNetworkCallback(NetworkCallback)} is called.
  ///
  /// Requires android.Manifest.permission\#ACCESS_NETWORK_STATE
  ///@param request NetworkRequest describing this request.
  ///@param networkCallback The NetworkCallback that the system will call as suitable
  ///                        networks change state.
  ///                        The callback is invoked on the default internal Handler.
  void registerNetworkCallback(networkrequest_.NetworkRequest request,
          ConnectivityManager_NetworkCallback networkCallback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerNetworkCallback,
          jni.JniType.voidType,
          [request.reference, networkCallback.reference]).check();

  static final _id_registerNetworkCallback1 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerNetworkCallback",
      "(Landroid/net/NetworkRequest;Landroid/net/ConnectivityManager\$NetworkCallback;Landroid/os/Handler;)V");

  /// from: public void registerNetworkCallback(android.net.NetworkRequest request, android.net.ConnectivityManager.NetworkCallback networkCallback, android.os.Handler handler)
  ///
  /// Registers to receive notifications about all networks which satisfy the given
  /// NetworkRequest.  The callbacks will continue to be called until
  /// either the application exits or link \#unregisterNetworkCallback(NetworkCallback)} is called.
  ///
  /// Requires android.Manifest.permission\#ACCESS_NETWORK_STATE
  ///@param request NetworkRequest describing this request.
  ///@param networkCallback The NetworkCallback that the system will call as suitable
  ///                        networks change state.
  ///@param handler Handler to specify the thread upon which the callback will be invoked.
  void registerNetworkCallback1(
          networkrequest_.NetworkRequest request,
          ConnectivityManager_NetworkCallback networkCallback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_registerNetworkCallback1, jni.JniType.voidType, [
        request.reference,
        networkCallback.reference,
        handler.reference
      ]).check();

  static final _id_registerNetworkCallback2 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerNetworkCallback",
      "(Landroid/net/NetworkRequest;Landroid/app/PendingIntent;)V");

  /// from: public void registerNetworkCallback(android.net.NetworkRequest request, android.app.PendingIntent operation)
  ///
  /// Registers a PendingIntent to be sent when a network is available which satisfies the given
  /// NetworkRequest.
  ///
  /// This function behaves identically to the version that takes a NetworkCallback, but instead
  /// of NetworkCallback a PendingIntent is used.  This means
  /// the request may outlive the calling application and get called back when a suitable
  /// network is found.
  ///
  /// The operation is an Intent broadcast that goes to a broadcast receiver that
  /// you registered with Context\#registerReceiver or through the
  /// &lt;receiver&gt; tag in an AndroidManifest.xml file
  ///
  /// The operation Intent is delivered with two extras, a Network typed
  /// extra called \#EXTRA_NETWORK and a NetworkRequest
  /// typed extra called \#EXTRA_NETWORK_REQUEST containing
  /// the original requests parameters.
  ///
  /// If there is already a request for this Intent registered (with the equality of
  /// two Intents defined by Intent\#filterEquals), then it will be removed and
  /// replaced by this one, effectively releasing the previous NetworkRequest.
  ///
  /// The request may be released normally by calling
  /// \#unregisterNetworkCallback(android.app.PendingIntent).
  /// Requires android.Manifest.permission\#ACCESS_NETWORK_STATE
  ///@param request NetworkRequest describing this request.
  ///@param operation Action to perform when the network is available (corresponds
  ///                  to the NetworkCallback\#onAvailable call.  Typically
  ///                  comes from PendingIntent\#getBroadcast. Cannot be null.
  void registerNetworkCallback2(networkrequest_.NetworkRequest request,
          pendingintent_.PendingIntent operation) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerNetworkCallback2,
          jni.JniType.voidType,
          [request.reference, operation.reference]).check();

  static final _id_registerDefaultNetworkCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerDefaultNetworkCallback",
      "(Landroid/net/ConnectivityManager\$NetworkCallback;)V");

  /// from: public void registerDefaultNetworkCallback(android.net.ConnectivityManager.NetworkCallback networkCallback)
  ///
  /// Registers to receive notifications about changes in the system default network. The callbacks
  /// will continue to be called until either the application exits or
  /// \#unregisterNetworkCallback(NetworkCallback) is called.
  ///
  /// Requires android.Manifest.permission\#ACCESS_NETWORK_STATE
  ///@param networkCallback The NetworkCallback that the system will call as the
  ///                        system default network changes.
  ///                        The callback is invoked on the default internal Handler.
  void registerDefaultNetworkCallback(
          ConnectivityManager_NetworkCallback networkCallback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerDefaultNetworkCallback,
          jni.JniType.voidType,
          [networkCallback.reference]).check();

  static final _id_registerDefaultNetworkCallback1 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerDefaultNetworkCallback",
      "(Landroid/net/ConnectivityManager\$NetworkCallback;Landroid/os/Handler;)V");

  /// from: public void registerDefaultNetworkCallback(android.net.ConnectivityManager.NetworkCallback networkCallback, android.os.Handler handler)
  ///
  /// Registers to receive notifications about changes in the system default network. The callbacks
  /// will continue to be called until either the application exits or
  /// \#unregisterNetworkCallback(NetworkCallback) is called.
  ///
  /// Requires android.Manifest.permission\#ACCESS_NETWORK_STATE
  ///@param networkCallback The NetworkCallback that the system will call as the
  ///                        system default network changes.
  ///@param handler Handler to specify the thread upon which the callback will be invoked.
  void registerDefaultNetworkCallback1(
          ConnectivityManager_NetworkCallback networkCallback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerDefaultNetworkCallback1,
          jni.JniType.voidType,
          [networkCallback.reference, handler.reference]).check();

  static final _id_requestBandwidthUpdate = jniAccessors.getMethodIDOf(
      _classRef, "requestBandwidthUpdate", "(Landroid/net/Network;)Z");

  /// from: public boolean requestBandwidthUpdate(android.net.Network network)
  ///
  /// Requests bandwidth update for a given Network and returns whether the update request
  /// is accepted by ConnectivityService. Once accepted, ConnectivityService will poll underlying
  /// network connection for updated bandwidth information. The caller will be notified via
  /// ConnectivityManager.NetworkCallback if there is an update. Notice that this
  /// method assumes that the caller has previously called
  /// \#registerNetworkCallback(NetworkRequest, NetworkCallback) to listen for network
  /// changes.
  ///@param network Network specifying which network you're interested.
  ///@return {@code true} on success, {@code false} if the Network is no longer valid.
  bool requestBandwidthUpdate(network_.Network network) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestBandwidthUpdate,
          jni.JniType.booleanType, [network.reference]).boolean;

  static final _id_unregisterNetworkCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterNetworkCallback",
      "(Landroid/net/ConnectivityManager\$NetworkCallback;)V");

  /// from: public void unregisterNetworkCallback(android.net.ConnectivityManager.NetworkCallback networkCallback)
  ///
  /// Unregisters a {@code NetworkCallback} and possibly releases networks originating from
  /// \#requestNetwork(NetworkRequest, NetworkCallback) and
  /// \#registerNetworkCallback(NetworkRequest, NetworkCallback) calls.
  /// If the given {@code NetworkCallback} had previously been used with
  /// {@code \#requestNetwork}, any networks that had been connected to only to satisfy that request
  /// will be disconnected.
  ///
  /// Notifications that would have triggered that {@code NetworkCallback} will immediately stop
  /// triggering it as soon as this call returns.
  ///@param networkCallback The NetworkCallback used when making the request.
  void unregisterNetworkCallback(
          ConnectivityManager_NetworkCallback networkCallback) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterNetworkCallback,
          jni.JniType.voidType, [networkCallback.reference]).check();

  static final _id_unregisterNetworkCallback1 = jniAccessors.getMethodIDOf(
      _classRef, "unregisterNetworkCallback", "(Landroid/app/PendingIntent;)V");

  /// from: public void unregisterNetworkCallback(android.app.PendingIntent operation)
  ///
  /// Unregisters a callback previously registered via
  /// \#registerNetworkCallback(NetworkRequest, android.app.PendingIntent).
  ///@param operation A PendingIntent equal (as defined by Intent\#filterEquals) to the
  ///                  PendingIntent passed to
  ///                  \#registerNetworkCallback(NetworkRequest, android.app.PendingIntent).
  ///                  Cannot be null.
  void unregisterNetworkCallback1(pendingintent_.PendingIntent operation) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterNetworkCallback1,
          jni.JniType.voidType, [operation.reference]).check();

  static final _id_getMultipathPreference = jniAccessors.getMethodIDOf(
      _classRef, "getMultipathPreference", "(Landroid/net/Network;)I");

  /// from: public int getMultipathPreference(android.net.Network network)
  ///
  /// Provides a hint to the calling application on whether it is desirable to use the
  /// multinetwork APIs (e.g., Network\#openConnection, Network\#bindSocket, etc.)
  /// for multipath data transfer on this network when it is not the system default network.
  /// Applications desiring to use multipath network protocols should call this method before
  /// each such operation.
  ///
  /// Requires android.Manifest.permission\#ACCESS_NETWORK_STATE
  ///@param network The network on which the application desires to use multipath data.
  ///                If {@code null}, this method will return the a preference that will generally
  ///                apply to metered networks.
  ///@return a bitwise OR of zero or more of the  {@code MULTIPATH_PREFERENCE_*} constants.
  ///
  /// Value is either <code>0</code> or a combination of android.net.ConnectivityManager\#MULTIPATH_PREFERENCE_HANDOVER, android.net.ConnectivityManager\#MULTIPATH_PREFERENCE_RELIABILITY, and android.net.ConnectivityManager\#MULTIPATH_PREFERENCE_PERFORMANCE
  int getMultipathPreference(network_.Network network) =>
      jniAccessors.callMethodWithArgs(reference, _id_getMultipathPreference,
          jni.JniType.intType, [network.reference]).integer;

  static final _id_bindProcessToNetwork = jniAccessors.getMethodIDOf(
      _classRef, "bindProcessToNetwork", "(Landroid/net/Network;)Z");

  /// from: public boolean bindProcessToNetwork(android.net.Network network)
  ///
  /// Binds the current process to {@code network}.  All Sockets created in the future
  /// (and not explicitly bound via a bound SocketFactory from
  /// Network\#getSocketFactory() Network.getSocketFactory()) will be bound to
  /// {@code network}.  All host name resolutions will be limited to {@code network} as well.
  /// Note that if {@code network} ever disconnects, all Sockets created in this way will cease to
  /// work and all host name resolutions will fail.  This is by design so an application doesn't
  /// accidentally use Sockets it thinks are still bound to a particular Network.
  /// To clear binding pass {@code null} for {@code network}.  Using individually bound
  /// Sockets created by Network.getSocketFactory().createSocket() and
  /// performing network-specific host name resolutions via
  /// Network\#getAllByName Network.getAllByName is preferred to calling
  /// {@code bindProcessToNetwork}.
  ///@param network The Network to bind the current process to, or {@code null} to clear
  ///                the current binding.
  ///@return {@code true} on success, {@code false} if the Network is no longer valid.
  bool bindProcessToNetwork(network_.Network network) =>
      jniAccessors.callMethodWithArgs(reference, _id_bindProcessToNetwork,
          jni.JniType.booleanType, [network.reference]).boolean;

  static final _id_setProcessDefaultNetwork = jniAccessors.getStaticMethodIDOf(
      _classRef, "setProcessDefaultNetwork", "(Landroid/net/Network;)Z");

  /// from: static public boolean setProcessDefaultNetwork(android.net.Network network)
  ///
  /// Binds the current process to {@code network}.  All Sockets created in the future
  /// (and not explicitly bound via a bound SocketFactory from
  /// Network\#getSocketFactory() Network.getSocketFactory()) will be bound to
  /// {@code network}.  All host name resolutions will be limited to {@code network} as well.
  /// Note that if {@code network} ever disconnects, all Sockets created in this way will cease to
  /// work and all host name resolutions will fail.  This is by design so an application doesn't
  /// accidentally use Sockets it thinks are still bound to a particular Network.
  /// To clear binding pass {@code null} for {@code network}.  Using individually bound
  /// Sockets created by Network.getSocketFactory().createSocket() and
  /// performing network-specific host name resolutions via
  /// Network\#getAllByName Network.getAllByName is preferred to calling
  /// {@code setProcessDefaultNetwork}.
  ///@param network The Network to bind the current process to, or {@code null} to clear
  ///                the current binding.
  ///@return {@code true} on success, {@code false} if the Network is no longer valid.
  ///@deprecated This function can throw IllegalStateException.  Use
  ///             \#bindProcessToNetwork instead.  {@code bindProcessToNetwork}
  ///             is a direct replacement.
  static bool setProcessDefaultNetwork(network_.Network network) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_setProcessDefaultNetwork,
          jni.JniType.booleanType,
          [network.reference]).boolean;

  static final _id_getBoundNetworkForProcess = jniAccessors.getMethodIDOf(
      _classRef, "getBoundNetworkForProcess", "()Landroid/net/Network;");

  /// from: public android.net.Network getBoundNetworkForProcess()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Network currently bound to this process via
  /// \#bindProcessToNetwork, or {@code null} if no Network is explicitly bound.
  ///@return {@code Network} to which this process is bound, or {@code null}.
  network_.Network getBoundNetworkForProcess() =>
      network_.Network.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getBoundNetworkForProcess, jni.JniType.objectType, []).object);

  static final _id_getProcessDefaultNetwork = jniAccessors.getStaticMethodIDOf(
      _classRef, "getProcessDefaultNetwork", "()Landroid/net/Network;");

  /// from: static public android.net.Network getProcessDefaultNetwork()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Network currently bound to this process via
  /// \#bindProcessToNetwork, or {@code null} if no Network is explicitly bound.
  ///@return {@code Network} to which this process is bound, or {@code null}.
  ///@deprecated Using this function can lead to other functions throwing
  ///             IllegalStateException.  Use \#getBoundNetworkForProcess instead.
  ///             {@code getBoundNetworkForProcess} is a direct replacement.
  static network_.Network getProcessDefaultNetwork() =>
      network_.Network.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getProcessDefaultNetwork, jni.JniType.objectType, []).object);

  static final _id_getRestrictBackgroundStatus = jniAccessors.getMethodIDOf(
      _classRef, "getRestrictBackgroundStatus", "()I");

  /// from: public int getRestrictBackgroundStatus()
  ///
  /// Determines if the calling application is subject to metered network restrictions while
  /// running on background.
  ///@return \#RESTRICT_BACKGROUND_STATUS_DISABLED,
  /// \#RESTRICT_BACKGROUND_STATUS_ENABLED,
  /// or \#RESTRICT_BACKGROUND_STATUS_WHITELISTED
  ///
  /// Value is android.net.ConnectivityManager\#RESTRICT_BACKGROUND_STATUS_DISABLED, android.net.ConnectivityManager\#RESTRICT_BACKGROUND_STATUS_WHITELISTED, or android.net.ConnectivityManager\#RESTRICT_BACKGROUND_STATUS_ENABLED
  int getRestrictBackgroundStatus() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getRestrictBackgroundStatus,
      jni.JniType.intType, []).integer;

  static final _id_getNetworkWatchlistConfigHash = jniAccessors.getMethodIDOf(
      _classRef, "getNetworkWatchlistConfigHash", "()[B");

  /// from: public byte[] getNetworkWatchlistConfigHash()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The network watchlist is a list of domains and IP addresses that are associated with
  /// potentially harmful apps. This method returns the SHA-256 of the watchlist config file
  /// currently used by the system for validation purposes.
  ///@return Hash of network watchlist config file. Null if config does not exist.
  jni.JniObject getNetworkWatchlistConfigHash() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getNetworkWatchlistConfigHash,
          jni.JniType.objectType, []).object);
}

/// from: android.net.ConnectivityManager$OnNetworkActiveListener
///
/// Callback for use with ConnectivityManager\#addDefaultNetworkActiveListener
/// to find out when the system default network has gone in to a high power state.
class ConnectivityManager_OnNetworkActiveListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/net/ConnectivityManager\$OnNetworkActiveListener");
  ConnectivityManager_OnNetworkActiveListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onNetworkActive =
      jniAccessors.getMethodIDOf(_classRef, "onNetworkActive", "()V");

  /// from: public abstract void onNetworkActive()
  ///
  /// Called on the main thread of the process to report that the current data network
  /// has become active, and it is now a good time to perform any pending network
  /// operations.  Note that this listener only tells you when the network becomes
  /// active; if at any other time you want to know whether it is active (and thus okay
  /// to initiate network traffic), you can retrieve its instantaneous state with
  /// ConnectivityManager\#isDefaultNetworkActive.
  void onNetworkActive() => jniAccessors.callMethodWithArgs(
      reference, _id_onNetworkActive, jni.JniType.voidType, []).check();
}

/// from: android.net.ConnectivityManager$NetworkCallback
///
/// Base class for {@code NetworkRequest} callbacks. Used for notifications about network
/// changes. Should be extended by applications wanting notifications.
///
/// A {@code NetworkCallback} is registered by calling
/// \#requestNetwork(NetworkRequest, NetworkCallback),
/// \#registerNetworkCallback(NetworkRequest, NetworkCallback),
/// or \#registerDefaultNetworkCallback(NetworkCallback). A {@code NetworkCallback} is
/// unregistered by calling \#unregisterNetworkCallback(NetworkCallback).
/// A {@code NetworkCallback} should be registered at most once at any time.
/// A {@code NetworkCallback} that has been unregistered can be registered again.
class ConnectivityManager_NetworkCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/net/ConnectivityManager\$NetworkCallback");
  ConnectivityManager_NetworkCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ConnectivityManager_NetworkCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onAvailable = jniAccessors.getMethodIDOf(
      _classRef, "onAvailable", "(Landroid/net/Network;)V");

  /// from: public void onAvailable(android.net.Network network)
  ///
  /// Called when the framework connects and has declared a new network ready for use.
  /// This callback may be called more than once if the Network that is
  /// satisfying the request changes. This will always immediately be followed by a
  /// call to \#onCapabilitiesChanged(Network, NetworkCapabilities) then by a
  /// call to \#onLinkPropertiesChanged(Network, LinkProperties).
  ///@param network The Network of the satisfying network.
  void onAvailable(network_.Network network) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onAvailable,
      jni.JniType.voidType,
      [network.reference]).check();

  static final _id_onLosing = jniAccessors.getMethodIDOf(
      _classRef, "onLosing", "(Landroid/net/Network;I)V");

  /// from: public void onLosing(android.net.Network network, int maxMsToLive)
  ///
  /// Called when the network is about to be disconnected.  Often paired with an
  /// NetworkCallback\#onAvailable call with the new replacement network
  /// for graceful handover.  This may not be called if we have a hard loss
  /// (loss without warning).  This may be followed by either a
  /// NetworkCallback\#onLost call or a
  /// NetworkCallback\#onAvailable call for this network depending
  /// on whether we lose or regain it.
  ///@param network The Network that is about to be disconnected.
  ///@param maxMsToLive The time in ms the framework will attempt to keep the
  ///                     network connected.  Note that the network may suffer a
  ///                     hard loss at any time.
  void onLosing(network_.Network network, int maxMsToLive) =>
      jniAccessors.callMethodWithArgs(reference, _id_onLosing,
          jni.JniType.voidType, [network.reference, maxMsToLive]).check();

  static final _id_onLost = jniAccessors.getMethodIDOf(
      _classRef, "onLost", "(Landroid/net/Network;)V");

  /// from: public void onLost(android.net.Network network)
  ///
  /// Called when the framework has a hard loss of the network or when the
  /// graceful failure ends.
  ///@param network The Network lost.
  void onLost(network_.Network network) => jniAccessors.callMethodWithArgs(
      reference, _id_onLost, jni.JniType.voidType, [network.reference]).check();

  static final _id_onUnavailable =
      jniAccessors.getMethodIDOf(_classRef, "onUnavailable", "()V");

  /// from: public void onUnavailable()
  ///
  /// Called if no network is found in the timeout time specified in
  /// \#requestNetwork(NetworkRequest, NetworkCallback, int) call. This callback is not
  /// called for the version of \#requestNetwork(NetworkRequest, NetworkCallback)
  /// without timeout. When this callback is invoked the associated
  /// NetworkRequest will have already been removed and released, as if
  /// \#unregisterNetworkCallback(NetworkCallback) had been called.
  void onUnavailable() => jniAccessors.callMethodWithArgs(
      reference, _id_onUnavailable, jni.JniType.voidType, []).check();

  static final _id_onCapabilitiesChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onCapabilitiesChanged",
      "(Landroid/net/Network;Landroid/net/NetworkCapabilities;)V");

  /// from: public void onCapabilitiesChanged(android.net.Network network, android.net.NetworkCapabilities networkCapabilities)
  ///
  /// Called when the network the framework connected to for this request
  /// changes capabilities but still satisfies the stated need.
  ///@param network The Network whose capabilities have changed.
  ///@param networkCapabilities The new android.net.NetworkCapabilities for this
  ///                            network.
  void onCapabilitiesChanged(network_.Network network,
          networkcapabilities_.NetworkCapabilities networkCapabilities) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCapabilitiesChanged,
          jni.JniType.voidType,
          [network.reference, networkCapabilities.reference]).check();

  static final _id_onLinkPropertiesChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onLinkPropertiesChanged",
      "(Landroid/net/Network;Landroid/net/LinkProperties;)V");

  /// from: public void onLinkPropertiesChanged(android.net.Network network, android.net.LinkProperties linkProperties)
  ///
  /// Called when the network the framework connected to for this request
  /// changes LinkProperties.
  ///@param network The Network whose link properties have changed.
  ///@param linkProperties The new LinkProperties for this network.
  void onLinkPropertiesChanged(network_.Network network,
          linkproperties_.LinkProperties linkProperties) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onLinkPropertiesChanged,
          jni.JniType.voidType,
          [network.reference, linkProperties.reference]).check();
}
