// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../app/Service.dart" as service_;

import "../../os/IBinder.dart" as ibinder_;

import "../../content/Intent.dart" as intent_;

import "../../os/Bundle.dart" as bundle_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.nfc.cardemulation.HostNfcFService
///
/// HostNfcFService is a convenience Service class that can be
/// extended to emulate an NFC-F card inside an Android service component.
///
/// <h3>NFC Protocols</h3>
/// Cards emulated by this class are based on the NFC-Forum NFC-F
/// protocol (based on the JIS-X 6319-4 specification.)
///
///
/// <h3>System Code and NFCID2 registration</h3>
/// A HostNfcFService HostNfcFService service can register
/// exactly one System Code and one NFCID2. For details about the use of
/// System Code and NFCID2, see the NFC Forum Digital specification.
///
/// To statically register a System Code and NFCID2 with the service, a \#SERVICE_META_DATA
/// entry must be included in the declaration of the service.
///
/// All HostNfcFService HostNfcFService declarations in the manifest must require the
/// android.Manifest.permission\#BIND_NFC_SERVICE permission
/// in their &lt;service&gt; tag, to ensure that only the platform can bind to your service.
///
///
/// An example of a HostNfcFService manifest declaration is shown below:
///
/// <pre> &lt;service android:name=".MyHostNfcFService" android:exported="true" android:permission="android.permission.BIND_NFC_SERVICE"&gt;
///     &lt;intent-filter&gt;
///         &lt;action android:name="android.nfc.cardemulation.action.HOST_NFCF_SERVICE"/&gt;
///     &lt;/intent-filter&gt;
///     &lt;meta-data android:name="android.nfc.cardemulation.host_nfcf_service" android:resource="@xml/nfcfservice"/&gt;
/// &lt;/service&gt;</pre>
///
/// This meta-data tag points to an nfcfservice.xml file.
/// An example of this file with a System Code and NFCID2 declaration is shown below:
/// <pre>
/// &lt;host-nfcf-service xmlns:android="http://schemas.android.com/apk/res/android"
///           android:description="@string/servicedesc"&gt;
///       &lt;system-code-filter android:name="4000"/&gt;
///       &lt;nfcid2-filter android:name="02FE000000000000"/&gt;
///        &lt;t3tPmm-filter android:name="FFFFFFFFFFFFFFFF"/&gt;
/// &lt;/host-nfcf-service&gt;
/// </pre>
///
/// The android.R.styleable\#HostNfcFService &lt;host-nfcf-service&gt; is required
/// to contain a
/// android.R.styleable\#HostApduService_description &lt;android:description&gt;
/// attribute that contains a user-friendly description of the service that may be shown in UI.
/// The android.R.styleable\#HostNfcFService &lt;host-nfcf-service&gt; must
/// contain:
/// <ul>
/// <li>Exactly one android.R.styleable\#SystemCodeFilter &lt;system-code-filter&gt; tag.</li>
/// <li>Exactly one android.R.styleable\#Nfcid2Filter &lt;nfcid2-filter&gt; tag.</li>
/// <li>Zero or one android.R.styleable\#T3tPmmFilter &lt;t3tPmm-filter&gt; tag.</li>
/// </ul>
///
///
///
/// Alternatively, the System Code and NFCID2 can be dynamically registererd for a service
/// by using the NfcFCardEmulation\#registerSystemCodeForService(ComponentName, String) and
/// NfcFCardEmulation\#setNfcid2ForService(ComponentName, String) methods.
///
///
///
/// <h3>Service selection</h3>
/// When a remote NFC devices wants to communicate with your service, it
/// sends a SENSF_REQ command to the NFC controller, requesting a System Code.
/// If a NfcFCardEmulation NfcFCardEmulation service has registered
/// this system code and has been enabled by the foreground application, the
/// NFC controller will respond with the NFCID2 that is registered for this service.
/// The reader can then continue data exchange with this service by using the NFCID2.
///
///
/// <h3>Data exchange</h3>
/// After service selection, all frames addressed to the NFCID2 of this service will
/// be sent through \#processNfcFPacket(byte[], Bundle), until the NFC link is
/// broken.
///
/// When the NFC link is broken, \#onDeactivated(int) will be called.
///
class HostNfcFService extends service_.Service {
  static final _classRef =
      jniAccessors.getClassOf("android/nfc/cardemulation/HostNfcFService");
  HostNfcFService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DEACTIVATION_LINK_LOSS
  ///
  /// Reason for \#onDeactivated(int).
  /// Indicates deactivation was due to the NFC link
  /// being lost.
  static const DEACTIVATION_LINK_LOSS = 0;

  /// from: static public final java.lang.String SERVICE_INTERFACE
  ///
  /// The Intent action that must be declared as handled by the service.
  static const SERVICE_INTERFACE =
      "android.nfc.cardemulation.action.HOST_NFCF_SERVICE";

  /// from: static public final java.lang.String SERVICE_META_DATA
  ///
  /// The name of the meta-data element that contains
  /// more information about this service.
  static const SERVICE_META_DATA =
      "android.nfc.cardemulation.host_nfcf_service";

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  HostNfcFService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public final android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);

  static final _id_sendResponsePacket =
      jniAccessors.getMethodIDOf(_classRef, "sendResponsePacket", "([B)V");

  /// from: public final void sendResponsePacket(byte[] responsePacket)
  ///
  /// Sends a response packet back to the remote device.
  ///
  /// Note: this method may be called from any thread and will not block.
  ///@param responsePacket A byte-array containing the response packet.
  void sendResponsePacket(jni.JniObject responsePacket) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendResponsePacket,
          jni.JniType.voidType, [responsePacket.reference]).check();

  static final _id_processNfcFPacket = jniAccessors.getMethodIDOf(
      _classRef, "processNfcFPacket", "([BLandroid/os/Bundle;)[B");

  /// from: public abstract byte[] processNfcFPacket(byte[] commandPacket, android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method will be called when a NFC-F packet has been received
  /// from a remote device. A response packet can be provided directly
  /// by returning a byte-array in this method. Note that in general
  /// response packets must be sent as quickly as possible, given the fact
  /// that the user is likely holding his device over an NFC reader
  /// when this method is called.
  ///
  /// <p class="note">This method is running on the main thread of your application.
  /// If you cannot return a response packet immediately, return null
  /// and use the \#sendResponsePacket(byte[]) method later.
  ///@param commandPacket The NFC-F packet that was received from the remote device
  ///@param extras A bundle containing extra data. May be null.
  ///@return a byte-array containing the response packet, or null if no
  ///         response packet can be sent at this point.
  jni.JniObject processNfcFPacket(
          jni.JniObject commandPacket, bundle_.Bundle extras) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_processNfcFPacket,
          jni.JniType.objectType,
          [commandPacket.reference, extras.reference]).object);

  static final _id_onDeactivated =
      jniAccessors.getMethodIDOf(_classRef, "onDeactivated", "(I)V");

  /// from: public abstract void onDeactivated(int reason)
  ///
  /// This method will be called in following possible scenarios:
  /// <li>The NFC link has been lost
  ///@param reason \#DEACTIVATION_LINK_LOSS
  void onDeactivated(int reason) => jniAccessors.callMethodWithArgs(
      reference, _id_onDeactivated, jni.JniType.voidType, [reason]).check();
}
