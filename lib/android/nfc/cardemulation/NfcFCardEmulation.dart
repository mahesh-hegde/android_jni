// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../NfcAdapter.dart" as nfcadapter_;

import "../../content/ComponentName.dart" as componentname_;

import "../../app/Activity.dart" as activity_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.nfc.cardemulation.NfcFCardEmulation
///
/// This class can be used to query the state of
/// NFC-F card emulation services.
///
/// For a general introduction into NFC card emulation,
/// please read the <a href="{@docRoot}guide/topics/connectivity/nfc/hce.html">
/// NFC card emulation developer guide</a>.
///
///
/// <p class="note">Use of this class requires the
/// PackageManager\#FEATURE_NFC_HOST_CARD_EMULATION_NFCF
/// to be present on the device.
class NfcFCardEmulation extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/nfc/cardemulation/NfcFCardEmulation");
  NfcFCardEmulation.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getInstance = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getInstance",
      "(Landroid/nfc/NfcAdapter;)Landroid/nfc/cardemulation/NfcFCardEmulation;");

  /// from: synchronized static public android.nfc.cardemulation.NfcFCardEmulation getInstance(android.nfc.NfcAdapter adapter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Helper to get an instance of this class.
  ///@param adapter A reference to an NfcAdapter object.
  ///@return
  static NfcFCardEmulation getInstance(nfcadapter_.NfcAdapter adapter) =>
      NfcFCardEmulation.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getInstance, jni.JniType.objectType, [adapter.reference]).object);

  static final _id_getSystemCodeForService = jniAccessors.getMethodIDOf(
      _classRef,
      "getSystemCodeForService",
      "(Landroid/content/ComponentName;)Ljava/lang/String;");

  /// from: public java.lang.String getSystemCodeForService(android.content.ComponentName service)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the current System Code for the specified service.
  ///
  /// Before calling \#registerSystemCodeForService(ComponentName, String),
  /// the System Code contained in the Manifest file is returned. After calling
  /// \#registerSystemCodeForService(ComponentName, String), the System Code
  /// registered there is returned. After calling
  /// \#unregisterSystemCodeForService(ComponentName), "null" is returned.
  ///@param service The component name of the service
  ///@return the current System Code
  jni.JniString getSystemCodeForService(componentname_.ComponentName service) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSystemCodeForService,
          jni.JniType.objectType,
          [service.reference]).object);

  static final _id_registerSystemCodeForService = jniAccessors.getMethodIDOf(
      _classRef,
      "registerSystemCodeForService",
      "(Landroid/content/ComponentName;Ljava/lang/String;)Z");

  /// from: public boolean registerSystemCodeForService(android.content.ComponentName service, java.lang.String systemCode)
  ///
  /// Registers a System Code for the specified service.
  ///
  /// The System Code must be in range from "4000" to "4FFF" (excluding "4*FF").
  ///
  /// If a System Code was previously registered for this service
  /// (either statically through the manifest, or dynamically by using this API),
  /// it will be replaced with this one.
  ///
  /// Even if the same System Code is already registered for another service,
  /// this method succeeds in registering the System Code.
  ///
  /// Note that you can only register a System Code for a service that
  /// is running under the same UID as the caller of this API. Typically
  /// this means you need to call this from the same
  /// package as the service itself, though UIDs can also
  /// be shared between packages using shared UIDs.
  ///@param service The component name of the service
  ///@param systemCode The System Code to be registered
  ///@return whether the registration was successful.
  bool registerSystemCodeForService(
          componentname_.ComponentName service, jni.JniString systemCode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerSystemCodeForService,
          jni.JniType.booleanType,
          [service.reference, systemCode.reference]).boolean;

  static final _id_unregisterSystemCodeForService = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterSystemCodeForService",
      "(Landroid/content/ComponentName;)Z");

  /// from: public boolean unregisterSystemCodeForService(android.content.ComponentName service)
  ///
  /// Removes a registered System Code for the specified service.
  ///@param service The component name of the service
  ///@return whether the System Code was successfully removed.
  bool unregisterSystemCodeForService(componentname_.ComponentName service) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterSystemCodeForService,
          jni.JniType.booleanType,
          [service.reference]).boolean;

  static final _id_getNfcid2ForService = jniAccessors.getMethodIDOf(
      _classRef,
      "getNfcid2ForService",
      "(Landroid/content/ComponentName;)Ljava/lang/String;");

  /// from: public java.lang.String getNfcid2ForService(android.content.ComponentName service)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the current NFCID2 for the specified service.
  ///
  /// Before calling \#setNfcid2ForService(ComponentName, String),
  /// the NFCID2 contained in the Manifest file is returned. If "random" is specified
  /// in the Manifest file, a random number assigned by the system at installation time
  /// is returned. After setting an NFCID2
  /// with \#setNfcid2ForService(ComponentName, String), this NFCID2 is returned.
  ///@param service The component name of the service
  ///@return the current NFCID2
  jni.JniString getNfcid2ForService(componentname_.ComponentName service) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getNfcid2ForService,
          jni.JniType.objectType,
          [service.reference]).object);

  static final _id_setNfcid2ForService = jniAccessors.getMethodIDOf(
      _classRef,
      "setNfcid2ForService",
      "(Landroid/content/ComponentName;Ljava/lang/String;)Z");

  /// from: public boolean setNfcid2ForService(android.content.ComponentName service, java.lang.String nfcid2)
  ///
  /// Set a NFCID2 for the specified service.
  ///
  /// The NFCID2 must be in range from "02FE000000000000" to "02FEFFFFFFFFFFFF".
  ///
  /// If a NFCID2 was previously set for this service
  /// (either statically through the manifest, or dynamically by using this API),
  /// it will be replaced.
  ///
  /// Note that you can only set the NFCID2 for a service that
  /// is running under the same UID as the caller of this API. Typically
  /// this means you need to call this from the same
  /// package as the service itself, though UIDs can also
  /// be shared between packages using shared UIDs.
  ///@param service The component name of the service
  ///@param nfcid2 The NFCID2 to be registered
  ///@return whether the setting was successful.
  bool setNfcid2ForService(
          componentname_.ComponentName service, jni.JniString nfcid2) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setNfcid2ForService,
          jni.JniType.booleanType,
          [service.reference, nfcid2.reference]).boolean;

  static final _id_enableService = jniAccessors.getMethodIDOf(
      _classRef,
      "enableService",
      "(Landroid/app/Activity;Landroid/content/ComponentName;)Z");

  /// from: public boolean enableService(android.app.Activity activity, android.content.ComponentName service)
  ///
  /// Allows a foreground application to specify which card emulation service
  /// should be enabled while a specific Activity is in the foreground.
  ///
  /// The specified HCE-F service is only enabled when the corresponding application is
  /// in the foreground and this method has been called. When the application is moved to
  /// the background, \#disableService(Activity) is called, or
  /// NFCID2 or System Code is replaced, the HCE-F service is disabled.
  ///
  /// The specified Activity must currently be in resumed state. A good
  /// paradigm is to call this method in your Activity\#onResume, and to call
  /// \#disableService(Activity) in your Activity\#onPause.
  ///
  /// Note that this preference is not persisted by the OS, and hence must be
  /// called every time the Activity is resumed.
  ///@param activity The activity which prefers this service to be invoked
  ///@param service The service to be preferred while this activity is in the foreground
  ///@return whether the registration was successful
  bool enableService(
          activity_.Activity activity, componentname_.ComponentName service) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_enableService,
          jni.JniType.booleanType,
          [activity.reference, service.reference]).boolean;

  static final _id_disableService = jniAccessors.getMethodIDOf(
      _classRef, "disableService", "(Landroid/app/Activity;)Z");

  /// from: public boolean disableService(android.app.Activity activity)
  ///
  /// Disables the service for the specified Activity.
  ///
  /// Note that the specified Activity must still be in resumed
  /// state at the time of this call. A good place to call this method
  /// is in your Activity\#onPause implementation.
  ///@param activity The activity which the service was registered for
  ///@return true when successful
  bool disableService(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_disableService,
          jni.JniType.booleanType, [activity.reference]).boolean;
}
