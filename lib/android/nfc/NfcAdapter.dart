// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../app/Activity.dart" as activity_;

import "NdefMessage.dart" as ndefmessage_;

import "../app/PendingIntent.dart" as pendingintent_;

import "../os/Bundle.dart" as bundle_;

import "Tag.dart" as tag_;

import "../os/Handler.dart" as handler_;

import "NfcEvent.dart" as nfcevent_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.nfc.NfcAdapter
///
/// Represents the local NFC adapter.
///
/// Use the helper \#getDefaultAdapter(Context) to get the default NFC
/// adapter for this Android device.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using NFC, read the
/// <a href="{@docRoot}guide/topics/nfc/index.html">Near Field Communication</a> developer guide.
///
/// To perform basic file sharing between devices, read
/// <a href="{@docRoot}training/beam-files/index.html">Sharing Files with NFC</a>.
/// </div>
class NfcAdapter extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/nfc/NfcAdapter");
  NfcAdapter.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_ADAPTER_STATE_CHANGED
  ///
  /// Broadcast Action: The state of the local NFC adapter has been
  /// changed.
  /// For example, NFC has been turned on or off.
  /// Always contains the extra field \#EXTRA_ADAPTER_STATE
  static const ACTION_ADAPTER_STATE_CHANGED =
      "android.nfc.action.ADAPTER_STATE_CHANGED";

  /// from: static public final java.lang.String ACTION_NDEF_DISCOVERED
  ///
  /// Intent to start an activity when a tag with NDEF payload is discovered.
  ///
  /// The system inspects the first NdefRecord in the first NdefMessage and
  /// looks for a URI, SmartPoster, or MIME record. If a URI or SmartPoster record is found the
  /// intent will contain the URI in its data field. If a MIME record is found the intent will
  /// contain the MIME type in its type field. This allows activities to register
  /// IntentFilters targeting specific content on tags. Activities should register the
  /// most specific intent filters possible to avoid the activity chooser dialog, which can
  /// disrupt the interaction with the tag as the user interacts with the screen.
  ///
  /// If the tag has an NDEF payload this intent is started before
  /// \#ACTION_TECH_DISCOVERED. If any activities respond to this intent neither
  /// \#ACTION_TECH_DISCOVERED or \#ACTION_TAG_DISCOVERED will be started.
  ///
  /// The MIME type or data URI of this intent are normalized before dispatch -
  /// so that MIME, URI scheme and URI host are always lower-case.
  static const ACTION_NDEF_DISCOVERED = "android.nfc.action.NDEF_DISCOVERED";

  /// from: static public final java.lang.String ACTION_TAG_DISCOVERED
  ///
  /// Intent to start an activity when a tag is discovered.
  ///
  /// This intent will not be started when a tag is discovered if any activities respond to
  /// \#ACTION_NDEF_DISCOVERED or \#ACTION_TECH_DISCOVERED for the current tag.
  static const ACTION_TAG_DISCOVERED = "android.nfc.action.TAG_DISCOVERED";

  /// from: static public final java.lang.String ACTION_TECH_DISCOVERED
  ///
  /// Intent to start an activity when a tag is discovered and activities are registered for the
  /// specific technologies on the tag.
  ///
  /// To receive this intent an activity must include an intent filter
  /// for this action and specify the desired tech types in a
  /// manifest <code>meta-data</code> entry. Here is an example manfiest entry:
  /// <pre>
  /// &lt;activity android:name=".nfc.TechFilter" android:label="NFC/TechFilter"&gt;
  ///     &lt;!-- Add a technology filter --&gt;
  ///     &lt;intent-filter&gt;
  ///         &lt;action android:name="android.nfc.action.TECH_DISCOVERED" /&gt;
  ///     &lt;/intent-filter&gt;
  ///
  ///     &lt;meta-data android:name="android.nfc.action.TECH_DISCOVERED"
  ///         android:resource="@xml/filter_nfc"
  ///     /&gt;
  /// &lt;/activity&gt;</pre>
  ///
  /// The meta-data XML file should contain one or more <code>tech-list</code> entries
  /// each consisting or one or more <code>tech</code> entries. The <code>tech</code> entries refer
  /// to the qualified class name implementing the technology, for example "android.nfc.tech.NfcA".
  ///
  /// A tag matches if any of the
  /// <code>tech-list</code> sets is a subset of Tag\#getTechList() Tag.getTechList(). Each
  /// of the <code>tech-list</code>s is considered independently and the
  /// activity is considered a match is any single <code>tech-list</code> matches the tag that was
  /// discovered. This provides AND and OR semantics for filtering desired techs. Here is an
  /// example that will match any tag using NfcF or any tag using NfcA,
  /// MifareClassic, and Ndef:
  ///
  /// <pre>
  /// &lt;resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2"&gt;
  ///     &lt;!-- capture anything using NfcF --&gt;
  ///     &lt;tech-list&gt;
  ///         &lt;tech&gt;android.nfc.tech.NfcF&lt;/tech&gt;
  ///     &lt;/tech-list&gt;
  ///
  ///     &lt;!-- OR --&gt;
  ///
  ///     &lt;!-- capture all MIFARE Classics with NDEF payloads --&gt;
  ///     &lt;tech-list&gt;
  ///         &lt;tech&gt;android.nfc.tech.NfcA&lt;/tech&gt;
  ///         &lt;tech&gt;android.nfc.tech.MifareClassic&lt;/tech&gt;
  ///         &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt;
  ///     &lt;/tech-list&gt;
  /// &lt;/resources&gt;</pre>
  ///
  /// This intent is started after \#ACTION_NDEF_DISCOVERED and before
  /// \#ACTION_TAG_DISCOVERED. If any activities respond to \#ACTION_NDEF_DISCOVERED
  /// this intent will not be started. If any activities respond to this intent
  /// \#ACTION_TAG_DISCOVERED will not be started.
  static const ACTION_TECH_DISCOVERED = "android.nfc.action.TECH_DISCOVERED";

  /// from: static public final java.lang.String ACTION_TRANSACTION_DETECTED
  ///
  /// Broadcast Action: Intent to notify an application that an transaction event has occurred
  /// on the Secure Element.
  ///
  /// This intent will only be sent if the application has requested permission for
  /// android.Manifest.permission\#NFC_TRANSACTION_EVENT and if the application has the
  /// necessary access to Secure Element which witnessed the particular event.
  ///
  /// Requires android.Manifest.permission\#NFC_TRANSACTION_EVENT
  static const ACTION_TRANSACTION_DETECTED =
      "android.nfc.action.TRANSACTION_DETECTED";

  /// from: static public final java.lang.String EXTRA_ADAPTER_STATE
  ///
  /// Used as an int extra field in \#ACTION_ADAPTER_STATE_CHANGED
  /// intents to request the current power state. Possible values are:
  /// \#STATE_OFF,
  /// \#STATE_TURNING_ON,
  /// \#STATE_ON,
  /// \#STATE_TURNING_OFF,
  static const EXTRA_ADAPTER_STATE = "android.nfc.extra.ADAPTER_STATE";

  /// from: static public final java.lang.String EXTRA_AID
  ///
  /// Mandatory byte[] extra field in \#ACTION_TRANSACTION_DETECTED
  static const EXTRA_AID = "android.nfc.extra.AID";

  /// from: static public final java.lang.String EXTRA_DATA
  ///
  /// Optional byte[] extra field in \#ACTION_TRANSACTION_DETECTED
  static const EXTRA_DATA = "android.nfc.extra.DATA";

  /// from: static public final java.lang.String EXTRA_ID
  ///
  /// Optional extra containing a byte array containing the ID of the discovered tag for
  /// the \#ACTION_NDEF_DISCOVERED, \#ACTION_TECH_DISCOVERED, and
  /// \#ACTION_TAG_DISCOVERED intents.
  static const EXTRA_ID = "android.nfc.extra.ID";

  /// from: static public final java.lang.String EXTRA_NDEF_MESSAGES
  ///
  /// Extra containing an array of NdefMessage present on the discovered tag.
  /// This extra is mandatory for \#ACTION_NDEF_DISCOVERED intents,
  /// and optional for \#ACTION_TECH_DISCOVERED, and
  /// \#ACTION_TAG_DISCOVERED intents.
  /// When this extra is present there will always be at least one
  /// NdefMessage element. Most NDEF tags have only one NDEF message,
  /// but we use an array for future compatibility.
  static const EXTRA_NDEF_MESSAGES = "android.nfc.extra.NDEF_MESSAGES";

  /// from: static public final java.lang.String EXTRA_READER_PRESENCE_CHECK_DELAY
  ///
  /// Int Extra for use with \#enableReaderMode(Activity, ReaderCallback, int, Bundle).
  ///
  /// Setting this integer extra allows the calling application to specify
  /// the delay that the platform will use for performing presence checks
  /// on any discovered tag.
  static const EXTRA_READER_PRESENCE_CHECK_DELAY = "presence";

  /// from: static public final java.lang.String EXTRA_SECURE_ELEMENT_NAME
  ///
  /// Mandatory String extra field in \#ACTION_TRANSACTION_DETECTED
  /// Indicates the Secure Element on which the transaction occurred.
  /// eSE1...eSEn for Embedded Secure Elements, SIM1...SIMn for UICC, etc.
  static const EXTRA_SECURE_ELEMENT_NAME =
      "android.nfc.extra.SECURE_ELEMENT_NAME";

  /// from: static public final java.lang.String EXTRA_TAG
  ///
  /// Mandatory extra containing the Tag that was discovered for the
  /// \#ACTION_NDEF_DISCOVERED, \#ACTION_TECH_DISCOVERED, and
  /// \#ACTION_TAG_DISCOVERED intents.
  static const EXTRA_TAG = "android.nfc.extra.TAG";

  /// from: static public final int FLAG_READER_NFC_A
  ///
  /// Flag for use with \#enableReaderMode(Activity, ReaderCallback, int, Bundle).
  ///
  /// Setting this flag enables polling for Nfc-A technology.
  static const FLAG_READER_NFC_A = 1;

  /// from: static public final int FLAG_READER_NFC_B
  ///
  /// Flag for use with \#enableReaderMode(Activity, ReaderCallback, int, Bundle).
  ///
  /// Setting this flag enables polling for Nfc-B technology.
  static const FLAG_READER_NFC_B = 2;

  /// from: static public final int FLAG_READER_NFC_BARCODE
  ///
  /// Flag for use with \#enableReaderMode(Activity, ReaderCallback, int, Bundle).
  ///
  /// Setting this flag enables polling for NfcBarcode technology.
  static const FLAG_READER_NFC_BARCODE = 16;

  /// from: static public final int FLAG_READER_NFC_F
  ///
  /// Flag for use with \#enableReaderMode(Activity, ReaderCallback, int, Bundle).
  ///
  /// Setting this flag enables polling for Nfc-F technology.
  static const FLAG_READER_NFC_F = 4;

  /// from: static public final int FLAG_READER_NFC_V
  ///
  /// Flag for use with \#enableReaderMode(Activity, ReaderCallback, int, Bundle).
  ///
  /// Setting this flag enables polling for Nfc-V (ISO15693) technology.
  static const FLAG_READER_NFC_V = 8;

  /// from: static public final int FLAG_READER_NO_PLATFORM_SOUNDS
  ///
  /// Flag for use with \#enableReaderMode(Activity, ReaderCallback, int, Bundle).
  ///
  /// Setting this flag allows the caller to prevent the
  /// platform from playing sounds when it discovers a tag.
  static const FLAG_READER_NO_PLATFORM_SOUNDS = 256;

  /// from: static public final int FLAG_READER_SKIP_NDEF_CHECK
  ///
  /// Flag for use with \#enableReaderMode(Activity, ReaderCallback, int, Bundle).
  ///
  /// Setting this flag allows the caller to prevent the
  /// platform from performing an NDEF check on the tags it
  /// finds.
  static const FLAG_READER_SKIP_NDEF_CHECK = 128;

  /// from: static public final int STATE_OFF
  static const STATE_OFF = 1;

  /// from: static public final int STATE_ON
  static const STATE_ON = 3;

  /// from: static public final int STATE_TURNING_OFF
  static const STATE_TURNING_OFF = 4;

  /// from: static public final int STATE_TURNING_ON
  static const STATE_TURNING_ON = 2;

  static final _id_getDefaultAdapter = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getDefaultAdapter",
      "(Landroid/content/Context;)Landroid/nfc/NfcAdapter;");

  /// from: static public android.nfc.NfcAdapter getDefaultAdapter(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Helper to get the default NFC Adapter.
  ///
  /// Most Android devices will only have one NFC Adapter (NFC Controller).
  ///
  /// This helper is the equivalent of:
  /// <pre>
  /// NfcManager manager = (NfcManager) context.getSystemService(Context.NFC_SERVICE);
  /// NfcAdapter adapter = manager.getDefaultAdapter();</pre>
  ///@param context the calling application's context
  ///@return the default NFC adapter, or null if no NFC adapter exists
  static NfcAdapter getDefaultAdapter(context_.Context context) =>
      NfcAdapter.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getDefaultAdapter,
          jni.JniType.objectType,
          [context.reference]).object);

  static final _id_isEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isEnabled", "()Z");

  /// from: public boolean isEnabled()
  ///
  /// Return true if this NFC Adapter has any features enabled.
  ///
  /// If this method returns false, the NFC hardware is guaranteed not to
  /// generate or respond to any NFC communication over its NFC radio.
  /// Applications can use this to check if NFC is enabled. Applications
  /// can request Settings UI allowing the user to toggle NFC using:
  /// <pre>startActivity(new Intent(Settings.ACTION_NFC_SETTINGS))</pre>
  ///@see android.provider.Settings\#ACTION_NFC_SETTINGS
  ///@return true if this NFC Adapter has any features enabled
  bool isEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setBeamPushUris = jniAccessors.getMethodIDOf(_classRef,
      "setBeamPushUris", "([Landroid/net/Uri;Landroid/app/Activity;)V");

  /// from: public void setBeamPushUris(android.net.Uri[] uris, android.app.Activity activity)
  ///
  /// Set one or more Uris to send using Android Beam (TM). Every
  /// Uri you provide must have either scheme 'file' or scheme 'content'.
  ///
  /// For the data provided through this method, Android Beam tries to
  /// switch to alternate transports such as Bluetooth to achieve a fast
  /// transfer speed. Hence this method is very suitable
  /// for transferring large files such as pictures or songs.
  ///
  /// The receiving side will store the content of each Uri in
  /// a file and present a notification to the user to open the file
  /// with a android.content.Intent with action
  /// android.content.Intent\#ACTION_VIEW.
  /// If multiple URIs are sent, the android.content.Intent will refer
  /// to the first of the stored files.
  ///
  /// This method may be called at any time before Activity\#onDestroy,
  /// but the URI(s) are only made available for Android Beam when the
  /// specified activity(s) are in resumed (foreground) state. The recommended
  /// approach is to call this method during your Activity's
  /// Activity\#onCreate - see sample
  /// code below. This method does not immediately perform any I/O or blocking work,
  /// so is safe to call on your main thread.
  ///
  /// \#setBeamPushUris and \#setBeamPushUrisCallback
  /// have priority over both \#setNdefPushMessage and
  /// \#setNdefPushMessageCallback.
  ///
  /// If \#setBeamPushUris is called with a null Uri array,
  /// and/or \#setBeamPushUrisCallback is called with a null callback,
  /// then the Uri push will be completely disabled for the specified activity(s).
  ///
  /// Code example:
  /// <pre>
  /// protected void onCreate(Bundle savedInstanceState) {
  ///     super.onCreate(savedInstanceState);
  ///     NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
  ///     if (nfcAdapter == null) return;  // NFC not available on this device
  ///     nfcAdapter.setBeamPushUris(new Uri[] {uri1, uri2}, this);
  /// }</pre>
  /// And that is it. Only one call per activity is necessary. The Android
  /// OS will automatically release its references to the Uri(s) and the
  /// Activity object when it is destroyed if you follow this pattern.
  ///
  /// If your Activity wants to dynamically supply Uri(s),
  /// then set a callback using \#setBeamPushUrisCallback instead
  /// of using this method.
  ///
  /// <p class="note">Do not pass in an Activity that has already been through
  /// Activity\#onDestroy. This is guaranteed if you call this API
  /// during Activity\#onCreate.
  ///
  /// <p class="note">If this device does not support alternate transports
  /// such as Bluetooth or WiFI, calling this method does nothing.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param uris an array of Uri(s) to push over Android Beam
  ///@param activity activity for which the Uri(s) will be pushed
  ///@throws UnsupportedOperationException if FEATURE_NFC is unavailable.
  void setBeamPushUris(jni.JniObject uris, activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_setBeamPushUris,
          jni.JniType.voidType, [uris.reference, activity.reference]).check();

  static final _id_setBeamPushUrisCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "setBeamPushUrisCallback",
      "(Landroid/nfc/NfcAdapter\$CreateBeamUrisCallback;Landroid/app/Activity;)V");

  /// from: public void setBeamPushUrisCallback(android.nfc.NfcAdapter.CreateBeamUrisCallback callback, android.app.Activity activity)
  ///
  /// Set a callback that will dynamically generate one or more Uris
  /// to send using Android Beam (TM). Every Uri the callback provides
  /// must have either scheme 'file' or scheme 'content'.
  ///
  /// For the data provided through this callback, Android Beam tries to
  /// switch to alternate transports such as Bluetooth to achieve a fast
  /// transfer speed. Hence this method is very suitable
  /// for transferring large files such as pictures or songs.
  ///
  /// The receiving side will store the content of each Uri in
  /// a file and present a notification to the user to open the file
  /// with a android.content.Intent with action
  /// android.content.Intent\#ACTION_VIEW.
  /// If multiple URIs are sent, the android.content.Intent will refer
  /// to the first of the stored files.
  ///
  /// This method may be called at any time before Activity\#onDestroy,
  /// but the URI(s) are only made available for Android Beam when the
  /// specified activity(s) are in resumed (foreground) state. The recommended
  /// approach is to call this method during your Activity's
  /// Activity\#onCreate - see sample
  /// code below. This method does not immediately perform any I/O or blocking work,
  /// so is safe to call on your main thread.
  ///
  /// \#setBeamPushUris and \#setBeamPushUrisCallback
  /// have priority over both \#setNdefPushMessage and
  /// \#setNdefPushMessageCallback.
  ///
  /// If \#setBeamPushUris is called with a null Uri array,
  /// and/or \#setBeamPushUrisCallback is called with a null callback,
  /// then the Uri push will be completely disabled for the specified activity(s).
  ///
  /// Code example:
  /// <pre>
  /// protected void onCreate(Bundle savedInstanceState) {
  ///     super.onCreate(savedInstanceState);
  ///     NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
  ///     if (nfcAdapter == null) return;  // NFC not available on this device
  ///     nfcAdapter.setBeamPushUrisCallback(callback, this);
  /// }</pre>
  /// And that is it. Only one call per activity is necessary. The Android
  /// OS will automatically release its references to the Uri(s) and the
  /// Activity object when it is destroyed if you follow this pattern.
  ///
  /// <p class="note">Do not pass in an Activity that has already been through
  /// Activity\#onDestroy. This is guaranteed if you call this API
  /// during Activity\#onCreate.
  ///
  /// <p class="note">If this device does not support alternate transports
  /// such as Bluetooth or WiFI, calling this method does nothing.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param callback callback, or null to disable
  ///@param activity activity for which the Uri(s) will be pushed
  ///@throws UnsupportedOperationException if FEATURE_NFC is unavailable.
  void setBeamPushUrisCallback(NfcAdapter_CreateBeamUrisCallback callback,
          activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setBeamPushUrisCallback,
          jni.JniType.voidType,
          [callback.reference, activity.reference]).check();

  static final _id_setNdefPushMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "setNdefPushMessage",
      "(Landroid/nfc/NdefMessage;Landroid/app/Activity;[Landroid/app/Activity;)V");

  /// from: public void setNdefPushMessage(android.nfc.NdefMessage message, android.app.Activity activity, android.app.Activity[] activities)
  ///
  /// Set a static NdefMessage to send using Android Beam (TM).
  ///
  /// This method may be called at any time before Activity\#onDestroy,
  /// but the NDEF message is only made available for NDEF push when the
  /// specified activity(s) are in resumed (foreground) state. The recommended
  /// approach is to call this method during your Activity's
  /// Activity\#onCreate - see sample
  /// code below. This method does not immediately perform any I/O or blocking work,
  /// so is safe to call on your main thread.
  ///
  /// Only one NDEF message can be pushed by the currently resumed activity.
  /// If both \#setNdefPushMessage and
  /// \#setNdefPushMessageCallback are set, then
  /// the callback will take priority.
  ///
  /// If neither \#setNdefPushMessage or
  /// \#setNdefPushMessageCallback have been called for your activity, then
  /// the Android OS may choose to send a default NDEF message on your behalf,
  /// such as a URI for your application.
  ///
  /// If \#setNdefPushMessage is called with a null NDEF message,
  /// and/or \#setNdefPushMessageCallback is called with a null callback,
  /// then NDEF push will be completely disabled for the specified activity(s).
  /// This also disables any default NDEF message the Android OS would have
  /// otherwise sent on your behalf for those activity(s).
  ///
  /// If you want to prevent the Android OS from sending default NDEF
  /// messages completely (for all activities), you can include a
  /// {@code <meta-data>} element inside the {@code <application>}
  /// element of your AndroidManifest.xml file, like this:
  /// <pre>
  /// &lt;application ...>
  ///     &lt;meta-data android:name="android.nfc.disable_beam_default"
  ///         android:value="true" />
  /// &lt;/application></pre>
  ///
  /// The API allows for multiple activities to be specified at a time,
  /// but it is strongly recommended to just register one at a time,
  /// and to do so during the activity's Activity\#onCreate. For example:
  /// <pre>
  /// protected void onCreate(Bundle savedInstanceState) {
  ///     super.onCreate(savedInstanceState);
  ///     NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
  ///     if (nfcAdapter == null) return;  // NFC not available on this device
  ///     nfcAdapter.setNdefPushMessage(ndefMessage, this);
  /// }</pre>
  /// And that is it. Only one call per activity is necessary. The Android
  /// OS will automatically release its references to the NDEF message and the
  /// Activity object when it is destroyed if you follow this pattern.
  ///
  /// If your Activity wants to dynamically generate an NDEF message,
  /// then set a callback using \#setNdefPushMessageCallback instead
  /// of a static message.
  ///
  /// <p class="note">Do not pass in an Activity that has already been through
  /// Activity\#onDestroy. This is guaranteed if you call this API
  /// during Activity\#onCreate.
  ///
  /// <p class="note">For sending large content such as pictures and songs,
  /// consider using \#setBeamPushUris, which switches to alternate transports
  /// such as Bluetooth to achieve a fast transfer rate.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param message NDEF message to push over NFC, or null to disable
  ///@param activity activity for which the NDEF message will be pushed
  ///@param activities optional additional activities, however we strongly recommend
  ///        to only register one at a time, and to do so in that activity's
  ///        Activity\#onCreate
  ///@throws UnsupportedOperationException if FEATURE_NFC is unavailable.
  void setNdefPushMessage(ndefmessage_.NdefMessage message,
          activity_.Activity activity, jni.JniObject activities) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setNdefPushMessage, jni.JniType.voidType, [
        message.reference,
        activity.reference,
        activities.reference
      ]).check();

  static final _id_setNdefPushMessageCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "setNdefPushMessageCallback",
      "(Landroid/nfc/NfcAdapter\$CreateNdefMessageCallback;Landroid/app/Activity;[Landroid/app/Activity;)V");

  /// from: public void setNdefPushMessageCallback(android.nfc.NfcAdapter.CreateNdefMessageCallback callback, android.app.Activity activity, android.app.Activity[] activities)
  ///
  /// Set a callback that dynamically generates NDEF messages to send using Android Beam (TM).
  ///
  /// This method may be called at any time before Activity\#onDestroy,
  /// but the NDEF message callback can only occur when the
  /// specified activity(s) are in resumed (foreground) state. The recommended
  /// approach is to call this method during your Activity's
  /// Activity\#onCreate - see sample
  /// code below. This method does not immediately perform any I/O or blocking work,
  /// so is safe to call on your main thread.
  ///
  /// Only one NDEF message can be pushed by the currently resumed activity.
  /// If both \#setNdefPushMessage and
  /// \#setNdefPushMessageCallback are set, then
  /// the callback will take priority.
  ///
  /// If neither \#setNdefPushMessage or
  /// \#setNdefPushMessageCallback have been called for your activity, then
  /// the Android OS may choose to send a default NDEF message on your behalf,
  /// such as a URI for your application.
  ///
  /// If \#setNdefPushMessage is called with a null NDEF message,
  /// and/or \#setNdefPushMessageCallback is called with a null callback,
  /// then NDEF push will be completely disabled for the specified activity(s).
  /// This also disables any default NDEF message the Android OS would have
  /// otherwise sent on your behalf for those activity(s).
  ///
  /// If you want to prevent the Android OS from sending default NDEF
  /// messages completely (for all activities), you can include a
  /// {@code <meta-data>} element inside the {@code <application>}
  /// element of your AndroidManifest.xml file, like this:
  /// <pre>
  /// &lt;application ...>
  ///     &lt;meta-data android:name="android.nfc.disable_beam_default"
  ///         android:value="true" />
  /// &lt;/application></pre>
  ///
  /// The API allows for multiple activities to be specified at a time,
  /// but it is strongly recommended to just register one at a time,
  /// and to do so during the activity's Activity\#onCreate. For example:
  /// <pre>
  /// protected void onCreate(Bundle savedInstanceState) {
  ///     super.onCreate(savedInstanceState);
  ///     NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
  ///     if (nfcAdapter == null) return;  // NFC not available on this device
  ///     nfcAdapter.setNdefPushMessageCallback(callback, this);
  /// }</pre>
  /// And that is it. Only one call per activity is necessary. The Android
  /// OS will automatically release its references to the callback and the
  /// Activity object when it is destroyed if you follow this pattern.
  ///
  /// <p class="note">Do not pass in an Activity that has already been through
  /// Activity\#onDestroy. This is guaranteed if you call this API
  /// during Activity\#onCreate.
  /// <p class="note">For sending large content such as pictures and songs,
  /// consider using \#setBeamPushUris, which switches to alternate transports
  /// such as Bluetooth to achieve a fast transfer rate.
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param callback callback, or null to disable
  ///@param activity activity for which the NDEF message will be pushed
  ///@param activities optional additional activities, however we strongly recommend
  ///        to only register one at a time, and to do so in that activity's
  ///        Activity\#onCreate
  ///@throws UnsupportedOperationException if FEATURE_NFC is unavailable.
  void setNdefPushMessageCallback(NfcAdapter_CreateNdefMessageCallback callback,
          activity_.Activity activity, jni.JniObject activities) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setNdefPushMessageCallback, jni.JniType.voidType, [
        callback.reference,
        activity.reference,
        activities.reference
      ]).check();

  static final _id_setOnNdefPushCompleteCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnNdefPushCompleteCallback",
      "(Landroid/nfc/NfcAdapter\$OnNdefPushCompleteCallback;Landroid/app/Activity;[Landroid/app/Activity;)V");

  /// from: public void setOnNdefPushCompleteCallback(android.nfc.NfcAdapter.OnNdefPushCompleteCallback callback, android.app.Activity activity, android.app.Activity[] activities)
  ///
  /// Set a callback on successful Android Beam (TM).
  ///
  /// This method may be called at any time before Activity\#onDestroy,
  /// but the callback can only occur when the
  /// specified activity(s) are in resumed (foreground) state. The recommended
  /// approach is to call this method during your Activity's
  /// Activity\#onCreate - see sample
  /// code below. This method does not immediately perform any I/O or blocking work,
  /// so is safe to call on your main thread.
  ///
  /// The API allows for multiple activities to be specified at a time,
  /// but it is strongly recommended to just register one at a time,
  /// and to do so during the activity's Activity\#onCreate. For example:
  /// <pre>
  /// protected void onCreate(Bundle savedInstanceState) {
  ///     super.onCreate(savedInstanceState);
  ///     NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
  ///     if (nfcAdapter == null) return;  // NFC not available on this device
  ///     nfcAdapter.setOnNdefPushCompleteCallback(callback, this);
  /// }</pre>
  /// And that is it. Only one call per activity is necessary. The Android
  /// OS will automatically release its references to the callback and the
  /// Activity object when it is destroyed if you follow this pattern.
  ///
  /// <p class="note">Do not pass in an Activity that has already been through
  /// Activity\#onDestroy. This is guaranteed if you call this API
  /// during Activity\#onCreate.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param callback callback, or null to disable
  ///@param activity activity for which the NDEF message will be pushed
  ///@param activities optional additional activities, however we strongly recommend
  ///        to only register one at a time, and to do so in that activity's
  ///        Activity\#onCreate
  ///@throws UnsupportedOperationException if FEATURE_NFC is unavailable.
  void setOnNdefPushCompleteCallback(
          NfcAdapter_OnNdefPushCompleteCallback callback,
          activity_.Activity activity,
          jni.JniObject activities) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setOnNdefPushCompleteCallback, jni.JniType.voidType, [
        callback.reference,
        activity.reference,
        activities.reference
      ]).check();

  static final _id_enableForegroundDispatch = jniAccessors.getMethodIDOf(
      _classRef,
      "enableForegroundDispatch",
      "(Landroid/app/Activity;Landroid/app/PendingIntent;[Landroid/content/IntentFilter;[[Ljava/lang/String;)V");

  /// from: public void enableForegroundDispatch(android.app.Activity activity, android.app.PendingIntent intent, android.content.IntentFilter[] filters, java.lang.String[][] techLists)
  ///
  /// Enable foreground dispatch to the given Activity.
  ///
  /// This will give give priority to the foreground activity when
  /// dispatching a discovered Tag to an application.
  ///
  /// If any IntentFilters are provided to this method they are used to match dispatch Intents
  /// for both the NfcAdapter\#ACTION_NDEF_DISCOVERED and
  /// NfcAdapter\#ACTION_TAG_DISCOVERED. Since NfcAdapter\#ACTION_TECH_DISCOVERED
  /// relies on meta data outside of the IntentFilter matching for that dispatch Intent is handled
  /// by passing in the tech lists separately. Each first level entry in the tech list represents
  /// an array of technologies that must all be present to match. If any of the first level sets
  /// match then the dispatch is routed through the given PendingIntent. In other words, the second
  /// level is ANDed together and the first level entries are ORed together.
  ///
  /// If you pass {@code null} for both the {@code filters} and {@code techLists} parameters
  /// that acts a wild card and will cause the foreground activity to receive all tags via the
  /// NfcAdapter\#ACTION_TAG_DISCOVERED intent.
  ///
  /// This method must be called from the main thread, and only when the activity is in the
  /// foreground (resumed). Also, activities must call \#disableForegroundDispatch before
  /// the completion of their Activity\#onPause callback to disable foreground dispatch
  /// after it has been enabled.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param activity the Activity to dispatch to
  ///@param intent the PendingIntent to start for the dispatch
  ///@param filters the IntentFilters to override dispatching for, or null to always dispatch
  ///@param techLists the tech lists used to perform matching for dispatching of the
  ///      NfcAdapter\#ACTION_TECH_DISCOVERED intent
  ///@throws IllegalStateException if the Activity is not currently in the foreground
  ///@throws UnsupportedOperationException if FEATURE_NFC is unavailable.
  void enableForegroundDispatch(
          activity_.Activity activity,
          pendingintent_.PendingIntent intent,
          jni.JniObject filters,
          jni.JniObject techLists) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_enableForegroundDispatch, jni.JniType.voidType, [
        activity.reference,
        intent.reference,
        filters.reference,
        techLists.reference
      ]).check();

  static final _id_disableForegroundDispatch = jniAccessors.getMethodIDOf(
      _classRef, "disableForegroundDispatch", "(Landroid/app/Activity;)V");

  /// from: public void disableForegroundDispatch(android.app.Activity activity)
  ///
  /// Disable foreground dispatch to the given activity.
  ///
  /// After calling \#enableForegroundDispatch, an activity
  /// must call this method before its Activity\#onPause callback
  /// completes.
  ///
  /// This method must be called from the main thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param activity the Activity to disable dispatch to
  ///@throws IllegalStateException if the Activity has already been paused
  ///@throws UnsupportedOperationException if FEATURE_NFC is unavailable.
  void disableForegroundDispatch(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_disableForegroundDispatch,
          jni.JniType.voidType, [activity.reference]).check();

  static final _id_enableReaderMode = jniAccessors.getMethodIDOf(
      _classRef,
      "enableReaderMode",
      "(Landroid/app/Activity;Landroid/nfc/NfcAdapter\$ReaderCallback;ILandroid/os/Bundle;)V");

  /// from: public void enableReaderMode(android.app.Activity activity, android.nfc.NfcAdapter.ReaderCallback callback, int flags, android.os.Bundle extras)
  ///
  /// Limit the NFC controller to reader mode while this Activity is in the foreground.
  ///
  /// In this mode the NFC controller will only act as an NFC tag reader/writer,
  /// thus disabling any peer-to-peer (Android Beam) and card-emulation modes of
  /// the NFC adapter on this device.
  ///
  /// Use \#FLAG_READER_SKIP_NDEF_CHECK to prevent the platform from
  /// performing any NDEF checks in reader mode. Note that this will prevent the
  /// Ndef tag technology from being enumerated on the tag, and that
  /// NDEF-based tag dispatch will not be functional.
  ///
  /// For interacting with tags that are emulated on another Android device
  /// using Android's host-based card-emulation, the recommended flags are
  /// \#FLAG_READER_NFC_A and \#FLAG_READER_SKIP_NDEF_CHECK.
  ///@param activity the Activity that requests the adapter to be in reader mode
  ///@param callback the callback to be called when a tag is discovered
  ///@param flags Flags indicating poll technologies and other optional parameters
  ///@param extras Additional extras for configuring reader mode.
  ///@throws UnsupportedOperationException if FEATURE_NFC is unavailable.
  void enableReaderMode(
          activity_.Activity activity,
          NfcAdapter_ReaderCallback callback,
          int flags,
          bundle_.Bundle extras) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_enableReaderMode, jni.JniType.voidType, [
        activity.reference,
        callback.reference,
        flags,
        extras.reference
      ]).check();

  static final _id_disableReaderMode = jniAccessors.getMethodIDOf(
      _classRef, "disableReaderMode", "(Landroid/app/Activity;)V");

  /// from: public void disableReaderMode(android.app.Activity activity)
  ///
  /// Restore the NFC adapter to normal mode of operation: supporting
  /// peer-to-peer (Android Beam), card emulation, and polling for
  /// all supported tag technologies.
  ///@param activity the Activity that currently has reader mode enabled
  ///@throws UnsupportedOperationException if FEATURE_NFC is unavailable.
  void disableReaderMode(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_disableReaderMode,
          jni.JniType.voidType, [activity.reference]).check();

  static final _id_invokeBeam = jniAccessors.getMethodIDOf(
      _classRef, "invokeBeam", "(Landroid/app/Activity;)Z");

  /// from: public boolean invokeBeam(android.app.Activity activity)
  ///
  /// Manually invoke Android Beam to share data.
  ///
  /// The Android Beam animation is normally only shown when two NFC-capable
  /// devices come into range.
  /// By calling this method, an Activity can invoke the Beam animation directly
  /// even if no other NFC device is in range yet. The Beam animation will then
  /// prompt the user to tap another NFC-capable device to complete the data
  /// transfer.
  ///
  /// The main advantage of using this method is that it avoids the need for the
  /// user to tap the screen to complete the transfer, as this method already
  /// establishes the direction of the transfer and the consent of the user to
  /// share data. Callers are responsible for making sure that the user has
  /// consented to sharing data on NFC tap.
  ///
  /// Note that to use this method, the passed in Activity must have already
  /// set data to share over Beam by using method calls such as
  /// \#setNdefPushMessageCallback or
  /// \#setBeamPushUrisCallback.
  ///@param activity the current foreground Activity that has registered data to share
  ///@return whether the Beam animation was successfully invoked
  ///@throws UnsupportedOperationException if FEATURE_NFC is unavailable.
  bool invokeBeam(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_invokeBeam,
          jni.JniType.booleanType, [activity.reference]).boolean;

  static final _id_enableForegroundNdefPush = jniAccessors.getMethodIDOf(
      _classRef,
      "enableForegroundNdefPush",
      "(Landroid/app/Activity;Landroid/nfc/NdefMessage;)V");

  /// from: public void enableForegroundNdefPush(android.app.Activity activity, android.nfc.NdefMessage message)
  ///
  /// Enable NDEF message push over NFC while this Activity is in the foreground.
  ///
  /// You must explicitly call this method every time the activity is
  /// resumed, and you must call \#disableForegroundNdefPush before
  /// your activity completes Activity\#onPause.
  ///
  /// Strongly recommend to use the new \#setNdefPushMessage
  /// instead: it automatically hooks into your activity life-cycle,
  /// so you do not need to call enable/disable in your onResume/onPause.
  ///
  /// For NDEF push to function properly the other NFC device must
  /// support either NFC Forum's SNEP (Simple Ndef Exchange Protocol), or
  /// Android's "com.android.npp" (Ndef Push Protocol). This was optional
  /// on Gingerbread level Android NFC devices, but SNEP is mandatory on
  /// Ice-Cream-Sandwich and beyond.
  ///
  /// This method must be called from the main thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param activity foreground activity
  ///@param message a NDEF Message to push over NFC
  ///@throws IllegalStateException if the activity is not currently in the foreground
  ///@throws UnsupportedOperationException if FEATURE_NFC is unavailable.
  ///@deprecated use \#setNdefPushMessage instead
  void enableForegroundNdefPush(
          activity_.Activity activity, ndefmessage_.NdefMessage message) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_enableForegroundNdefPush,
          jni.JniType.voidType,
          [activity.reference, message.reference]).check();

  static final _id_disableForegroundNdefPush = jniAccessors.getMethodIDOf(
      _classRef, "disableForegroundNdefPush", "(Landroid/app/Activity;)V");

  /// from: public void disableForegroundNdefPush(android.app.Activity activity)
  ///
  /// Disable NDEF message push over P2P.
  ///
  /// After calling \#enableForegroundNdefPush, an activity
  /// must call this method before its Activity\#onPause callback
  /// completes.
  ///
  /// Strongly recommend to use the new \#setNdefPushMessage
  /// instead: it automatically hooks into your activity life-cycle,
  /// so you do not need to call enable/disable in your onResume/onPause.
  ///
  /// This method must be called from the main thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param activity the Foreground activity
  ///@throws IllegalStateException if the Activity has already been paused
  ///@throws UnsupportedOperationException if FEATURE_NFC is unavailable.
  ///@deprecated use \#setNdefPushMessage instead
  void disableForegroundNdefPush(activity_.Activity activity) =>
      jniAccessors.callMethodWithArgs(reference, _id_disableForegroundNdefPush,
          jni.JniType.voidType, [activity.reference]).check();

  static final _id_isNdefPushEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isNdefPushEnabled", "()Z");

  /// from: public boolean isNdefPushEnabled()
  ///
  /// Return true if the NDEF Push (Android Beam) feature is enabled.
  /// This function will return true only if both NFC is enabled, and the
  /// NDEF Push feature is enabled.
  /// Note that if NFC is enabled but NDEF Push is disabled then this
  /// device can still <i>receive</i> NDEF messages, it just cannot send them.
  /// Applications cannot directly toggle the NDEF Push feature, but they
  /// can request Settings UI allowing the user to toggle NDEF Push using
  /// <code>startActivity(new Intent(Settings.ACTION_NFCSHARING_SETTINGS))</code>
  /// Example usage in an Activity that requires NDEF Push:
  /// <pre>
  /// protected void onResume() {
  ///     super.onResume();
  ///     if (!nfcAdapter.isEnabled()) {
  ///         startActivity(new Intent(Settings.ACTION_NFC_SETTINGS));
  ///     } else if (!nfcAdapter.isNdefPushEnabled()) {
  ///         startActivity(new Intent(Settings.ACTION_NFCSHARING_SETTINGS));
  ///     }
  /// }</pre>
  ///@see android.provider.Settings\#ACTION_NFCSHARING_SETTINGS
  ///@return true if NDEF Push feature is enabled
  ///@throws UnsupportedOperationException if FEATURE_NFC is unavailable.
  bool isNdefPushEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isNdefPushEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_ignore = jniAccessors.getMethodIDOf(_classRef, "ignore",
      "(Landroid/nfc/Tag;ILandroid/nfc/NfcAdapter\$OnTagRemovedListener;Landroid/os/Handler;)Z");

  /// from: public boolean ignore(android.nfc.Tag tag, int debounceMs, android.nfc.NfcAdapter.OnTagRemovedListener tagRemovedListener, android.os.Handler handler)
  ///
  /// Signals that you are no longer interested in communicating with an NFC tag
  /// for as long as it remains in range.
  ///
  /// All future attempted communication to this tag will fail with IOException.
  /// The NFC controller will be put in a low-power polling mode, allowing the device
  /// to save power in cases where it's "attached" to a tag all the time (e.g. a tag in
  /// car dock).
  ///
  /// Additionally the debounceMs parameter allows you to specify for how long the tag needs
  /// to have gone out of range, before it will be dispatched again.
  ///
  /// Note: the NFC controller typically polls at a pretty slow interval (100 - 500 ms).
  /// This means that if the tag repeatedly goes in and out of range (for example, in
  /// case of a flaky connection), and the controller happens to poll every time the
  /// tag is out of range, it *will* re-dispatch the tag after debounceMs, despite the tag
  /// having been "in range" during the interval.
  ///
  /// Note 2: if a tag with another UID is detected after this API is called, its effect
  /// will be cancelled; if this tag shows up before the amount of time specified in
  /// debounceMs, it will be dispatched again.
  ///
  /// Note 3: some tags have a random UID, in which case this API won't work reliably.
  ///@param tag the android.nfc.Tag Tag to ignore.
  ///@param debounceMs minimum amount of time the tag needs to be out of range before being
  ///                   dispatched again.
  ///@param tagRemovedListener listener to be called when the tag is removed from the field.
  ///                           Note that this will only be called if the tag has been out of range
  ///                           for at least debounceMs, or if another tag came into range before
  ///                           debounceMs. May be null in case you don't want a callback.
  ///@param handler the android.os.Handler Handler that will be used for delivering
  ///                the callback. if the handler is null, then the thread used for delivering
  ///                the callback is unspecified.
  ///@return false if the tag couldn't be found (or has already gone out of range), true otherwise
  bool ignore(
          tag_.Tag tag,
          int debounceMs,
          NfcAdapter_OnTagRemovedListener tagRemovedListener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_ignore, jni.JniType.booleanType, [
        tag.reference,
        debounceMs,
        tagRemovedListener.reference,
        handler.reference
      ]).boolean;
}

/// from: android.nfc.NfcAdapter$ReaderCallback
///
/// A callback to be invoked when the system finds a tag while the foreground activity is
/// operating in reader mode.
/// Register your {@code ReaderCallback} implementation with NfcAdapter\#enableReaderMode and disable it with NfcAdapter\#disableReaderMode.
///@see NfcAdapter\#enableReaderMode
class NfcAdapter_ReaderCallback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/nfc/NfcAdapter\$ReaderCallback");
  NfcAdapter_ReaderCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onTagDiscovered = jniAccessors.getMethodIDOf(
      _classRef, "onTagDiscovered", "(Landroid/nfc/Tag;)V");

  /// from: public abstract void onTagDiscovered(android.nfc.Tag tag)
  void onTagDiscovered(tag_.Tag tag) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onTagDiscovered,
      jni.JniType.voidType,
      [tag.reference]).check();
}

/// from: android.nfc.NfcAdapter$OnTagRemovedListener
///
/// A callback that is invoked when a tag is removed from the field.
///@see NfcAdapter\#ignore
class NfcAdapter_OnTagRemovedListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/nfc/NfcAdapter\$OnTagRemovedListener");
  NfcAdapter_OnTagRemovedListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onTagRemoved =
      jniAccessors.getMethodIDOf(_classRef, "onTagRemoved", "()V");

  /// from: public abstract void onTagRemoved()
  void onTagRemoved() => jniAccessors.callMethodWithArgs(
      reference, _id_onTagRemoved, jni.JniType.voidType, []).check();
}

/// from: android.nfc.NfcAdapter$OnNdefPushCompleteCallback
///
/// A callback to be invoked when the system successfully delivers your NdefMessage
/// to another device.
///@see \#setOnNdefPushCompleteCallback
class NfcAdapter_OnNdefPushCompleteCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/nfc/NfcAdapter\$OnNdefPushCompleteCallback");
  NfcAdapter_OnNdefPushCompleteCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onNdefPushComplete = jniAccessors.getMethodIDOf(
      _classRef, "onNdefPushComplete", "(Landroid/nfc/NfcEvent;)V");

  /// from: public abstract void onNdefPushComplete(android.nfc.NfcEvent event)
  ///
  /// Called on successful NDEF push.
  ///
  /// This callback is usually made on a binder thread (not the UI thread).
  ///@param event NfcEvent with the NfcEvent\#nfcAdapter field set
  ///@see \#setNdefPushMessageCallback
  void onNdefPushComplete(nfcevent_.NfcEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onNdefPushComplete,
          jni.JniType.voidType, [event.reference]).check();
}

/// from: android.nfc.NfcAdapter$CreateNdefMessageCallback
///
/// A callback to be invoked when another NFC device capable of NDEF push (Android Beam)
/// is within range.
/// Implement this interface and pass it to NfcAdapter\#setNdefPushMessageCallback setNdefPushMessageCallback() in order to create an
/// NdefMessage at the moment that another device is within range for NFC. Using this
/// callback allows you to create a message with data that might vary based on the
/// content currently visible to the user. Alternatively, you can call \#setNdefPushMessage setNdefPushMessage() if the NdefMessage always contains the
/// same data.
class NfcAdapter_CreateNdefMessageCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/nfc/NfcAdapter\$CreateNdefMessageCallback");
  NfcAdapter_CreateNdefMessageCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_createNdefMessage = jniAccessors.getMethodIDOf(_classRef,
      "createNdefMessage", "(Landroid/nfc/NfcEvent;)Landroid/nfc/NdefMessage;");

  /// from: public abstract android.nfc.NdefMessage createNdefMessage(android.nfc.NfcEvent event)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called to provide a NdefMessage to push.
  ///
  /// This callback is usually made on a binder thread (not the UI thread).
  ///
  /// Called when this device is in range of another device
  /// that might support NDEF push. It allows the application to
  /// create the NDEF message only when it is required.
  ///
  /// NDEF push cannot occur until this method returns, so do not
  /// block for too long.
  ///
  /// The Android operating system will usually show a system UI
  /// on top of your activity during this time, so do not try to request
  /// input from the user to complete the callback, or provide custom NDEF
  /// push UI. The user probably will not see it.
  ///@param event NfcEvent with the NfcEvent\#nfcAdapter field set
  ///@return NDEF message to push, or null to not provide a message
  ndefmessage_.NdefMessage createNdefMessage(nfcevent_.NfcEvent event) =>
      ndefmessage_.NdefMessage.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createNdefMessage,
          jni.JniType.objectType,
          [event.reference]).object);
}

/// from: android.nfc.NfcAdapter$CreateBeamUrisCallback
class NfcAdapter_CreateBeamUrisCallback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/nfc/NfcAdapter\$CreateBeamUrisCallback");
  NfcAdapter_CreateBeamUrisCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_createBeamUris = jniAccessors.getMethodIDOf(_classRef,
      "createBeamUris", "(Landroid/nfc/NfcEvent;)[Landroid/net/Uri;");

  /// from: public abstract android.net.Uri[] createBeamUris(android.nfc.NfcEvent event)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject createBeamUris(nfcevent_.NfcEvent event) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createBeamUris,
          jni.JniType.objectType,
          [event.reference]).object);
}
