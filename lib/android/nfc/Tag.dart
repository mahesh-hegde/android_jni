// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.nfc.Tag
///
/// Represents an NFC tag that has been discovered.
///
/// Tag is an immutable object that represents the state of a NFC tag at
/// the time of discovery. It can be used as a handle to TagTechnology classes
/// to perform advanced operations, or directly queried for its ID via \#getId and the
/// set of technologies it contains via \#getTechList. Arrays passed to and
/// returned by this class are _not_ cloned, so be careful not to modify them.
///
/// A new tag object is created every time a tag is discovered (comes into range), even
/// if it is the same physical tag. If a tag is removed and then returned into range, then
/// only the most recent tag object can be successfully used to create a TagTechnology.
///
/// <h3>Tag Dispatch</h3>
/// When a tag is discovered, a Tag object is created and passed to a
/// single activity via the NfcAdapter\#EXTRA_TAG extra in an
/// android.content.Intent via Context\#startActivity. A four stage dispatch is used
/// to select the
/// most appropriate activity to handle the tag. The Android OS executes each stage in order,
/// and completes dispatch as soon as a single matching activity is found. If there are multiple
/// matching activities found at any one stage then the Android activity chooser dialog is shown
/// to allow the user to select the activity to receive the tag.
///
/// The Tag dispatch mechanism was designed to give a high probability of dispatching
/// a tag to the correct activity without showing the user an activity chooser dialog.
/// This is important for NFC interactions because they are very transient -- if a user has to
/// move the Android device to choose an application then the connection will likely be broken.
///
/// <h4>1. Foreground activity dispatch</h4>
/// A foreground activity that has called
/// NfcAdapter\#enableForegroundDispatch NfcAdapter.enableForegroundDispatch() is
/// given priority. See the documentation on
/// NfcAdapter\#enableForegroundDispatch NfcAdapter.enableForegroundDispatch() for
/// its usage.
/// <h4>2. NDEF data dispatch</h4>
/// If the tag contains NDEF data the system inspects the first NdefRecord in the first
/// NdefMessage. If the record is a URI, SmartPoster, or MIME data
/// Context\#startActivity is called with NfcAdapter\#ACTION_NDEF_DISCOVERED. For URI
/// and SmartPoster records the URI is put into the intent's data field. For MIME records the MIME
/// type is put in the intent's type field. This allows activities to register to be launched only
/// when data they know how to handle is present on a tag. This is the preferred method of handling
/// data on a tag since NDEF data can be stored on many types of tags and doesn't depend on a
/// specific tag technology.
/// See NfcAdapter\#ACTION_NDEF_DISCOVERED for more detail. If the tag does not contain
/// NDEF data, or if no activity is registered
/// for NfcAdapter\#ACTION_NDEF_DISCOVERED with a matching data URI or MIME type then dispatch
/// moves to stage 3.
/// <h4>3. Tag Technology dispatch</h4>
/// Context\#startActivity is called with NfcAdapter\#ACTION_TECH_DISCOVERED to
/// dispatch the tag to an activity that can handle the technologies present on the tag.
/// Technologies are defined as sub-classes of TagTechnology, see the package
/// android.nfc.tech. The Android OS looks for an activity that can handle one or
/// more technologies in the tag. See NfcAdapter\#ACTION_TECH_DISCOVERED for more detail.
/// <h4>4. Fall-back dispatch</h4>
/// If no activity has been matched then Context\#startActivity is called with
/// NfcAdapter\#ACTION_TAG_DISCOVERED. This is intended as a fall-back mechanism.
/// See NfcAdapter\#ACTION_TAG_DISCOVERED.
///
/// <h3>NFC Tag Background</h3>
/// An NFC tag is a passive NFC device, powered by the NFC field of this Android device while
/// it is in range. Tag's can come in many forms, such as stickers, cards, key fobs, or
/// even embedded in a more sophisticated device.
///
/// Tags can have a wide range of capabilities. Simple tags just offer read/write semantics,
/// and contain some one time
/// programmable areas to make read-only. More complex tags offer math operations
/// and per-sector access control and authentication. The most sophisticated tags
/// contain operating environments allowing complex interactions with the
/// code executing on the tag. Use TagTechnology classes to access a broad
/// range of capabilities available in NFC tags.
///
class Tag extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/nfc/Tag");
  Tag.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.nfc.Tag> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_getId =
      jniAccessors.getMethodIDOf(_classRef, "getId", "()[B");

  /// from: public byte[] getId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the Tag Identifier (if it has one).
  /// The tag identifier is a low level serial number, used for anti-collision
  /// and identification.
  ///  Most tags have a stable unique identifier
  /// (UID), but some tags will generate a random ID every time they are discovered
  /// (RID), and there are some tags with no ID at all (the byte array will be zero-sized).
  ///  The size and format of an ID is specific to the RF technology used by the tag.
  ///  This function retrieves the ID as determined at discovery time, and does not
  /// perform any further RF communication or block.
  ///@return ID as byte array, never null
  jni.JniObject getId() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getId, jni.JniType.objectType, []).object);

  static final _id_getTechList = jniAccessors.getMethodIDOf(
      _classRef, "getTechList", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getTechList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the technologies available in this tag, as fully qualified class names.
  ///
  /// A technology is an implementation of the TagTechnology interface,
  /// and can be instantiated by calling the static <code>get(Tag)</code>
  /// method on the implementation with this Tag. The TagTechnology
  /// object can then be used to perform advanced, technology-specific operations on a tag.
  ///
  /// Android defines a mandatory set of technologies that must be correctly
  /// enumerated by all Android NFC devices, and an optional
  /// set of proprietary technologies.
  /// See TagTechnology for more details.
  ///
  /// The ordering of the returned array is undefined and should not be relied upon.
  ///@return an array of fully-qualified TagTechnology class-names.
  jni.JniObject getTechList() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTechList, jni.JniType.objectType, []).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Human-readable description of the tag, for debugging.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}
