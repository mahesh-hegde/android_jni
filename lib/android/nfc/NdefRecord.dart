// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../net/Uri.dart" as uri_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.nfc.NdefRecord
///
/// Represents an immutable NDEF Record.
///
/// NDEF (NFC Data Exchange Format) is a light-weight binary format,
/// used to encapsulate typed data. It is specified by the NFC Forum,
/// for transmission and storage with NFC, however it is transport agnostic.
///
/// NDEF defines messages and records. An NDEF Record contains
/// typed data, such as MIME-type media, a URI, or a custom
/// application payload. An NDEF Message is a container for
/// one or more NDEF Records.
///
/// This class represents logical (complete) NDEF Records, and can not be
/// used to represent chunked (partial) NDEF Records. However
/// NdefMessage\#NdefMessage(byte[]) can be used to parse a message
/// containing chunked records, and will return a message with unchunked
/// (complete) records.
///
/// A logical NDEF Record always contains a 3-bit TNF (Type Name Field)
/// that provides high level typing for the rest of the record. The
/// remaining fields are variable length and not always present:
/// <ul>
/// <li>_type_: detailed typing for the payload</li>
/// <li>_id_: identifier meta-data, not commonly used</li>
/// <li>_payload_: the actual payload</li>
/// </ul>
///
/// Helpers such as NdefRecord\#createUri, NdefRecord\#createMime
/// and NdefRecord\#createExternal are included to create well-formatted
/// NDEF Records with correctly set tnf, type, id and payload fields, please
/// use these helpers whenever possible.
///
/// Use the constructor \#NdefRecord(short, byte[], byte[], byte[])
/// if you know what you are doing and what to set the fields individually.
/// Only basic validation is performed with this constructor, so it is possible
/// to create records that do not confirm to the strict NFC Forum
/// specifications.
///
/// The binary representation of an NDEF Record includes additional flags to
/// indicate location with an NDEF message, provide support for chunking of
/// NDEF records, and to pack optional fields. This class does not expose
/// those details. To write an NDEF Record as binary you must first put it
/// into an NdefMessage, then call NdefMessage\#toByteArray().
/// <p class="note">
/// NdefMessage and NdefRecord implementations are
/// always available, even on Android devices that do not have NFC hardware.
/// <p class="note">
/// NdefRecords are intended to be immutable (and thread-safe),
/// however they may contain mutable fields. So take care not to modify
/// mutable fields passed into constructors, or modify mutable fields
/// obtained by getter methods, unless such modification is explicitly
/// marked as safe.
///@see NfcAdapter\#ACTION_NDEF_DISCOVERED
///@see NdefMessage
class NdefRecord extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/nfc/NdefRecord");
  NdefRecord.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.nfc.NdefRecord> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_RTD_ALTERNATIVE_CARRIER = jniAccessors.getStaticFieldIDOf(
      _classRef, "RTD_ALTERNATIVE_CARRIER", "[B");

  /// from: static public final byte[] RTD_ALTERNATIVE_CARRIER
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// RTD Alternative Carrier type. For use with {@literal TNF_WELL_KNOWN}.
  ///@see \#TNF_WELL_KNOWN
  static jni.JniObject get RTD_ALTERNATIVE_CARRIER =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_RTD_ALTERNATIVE_CARRIER, jni.JniType.objectType)
          .object);

  static final _id_RTD_HANDOVER_CARRIER =
      jniAccessors.getStaticFieldIDOf(_classRef, "RTD_HANDOVER_CARRIER", "[B");

  /// from: static public final byte[] RTD_HANDOVER_CARRIER
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// RTD Handover Carrier type. For use with {@literal TNF_WELL_KNOWN}.
  ///@see \#TNF_WELL_KNOWN
  static jni.JniObject get RTD_HANDOVER_CARRIER =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_RTD_HANDOVER_CARRIER, jni.JniType.objectType)
          .object);

  static final _id_RTD_HANDOVER_REQUEST =
      jniAccessors.getStaticFieldIDOf(_classRef, "RTD_HANDOVER_REQUEST", "[B");

  /// from: static public final byte[] RTD_HANDOVER_REQUEST
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// RTD Handover Request type. For use with {@literal TNF_WELL_KNOWN}.
  ///@see \#TNF_WELL_KNOWN
  static jni.JniObject get RTD_HANDOVER_REQUEST =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_RTD_HANDOVER_REQUEST, jni.JniType.objectType)
          .object);

  static final _id_RTD_HANDOVER_SELECT =
      jniAccessors.getStaticFieldIDOf(_classRef, "RTD_HANDOVER_SELECT", "[B");

  /// from: static public final byte[] RTD_HANDOVER_SELECT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// RTD Handover Select type. For use with {@literal TNF_WELL_KNOWN}.
  ///@see \#TNF_WELL_KNOWN
  static jni.JniObject get RTD_HANDOVER_SELECT => jni.JniObject.fromRef(
      jniAccessors
          .getStaticField(
              _classRef, _id_RTD_HANDOVER_SELECT, jni.JniType.objectType)
          .object);

  static final _id_RTD_SMART_POSTER =
      jniAccessors.getStaticFieldIDOf(_classRef, "RTD_SMART_POSTER", "[B");

  /// from: static public final byte[] RTD_SMART_POSTER
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// RTD Smart Poster type. For use with {@literal TNF_WELL_KNOWN}.
  ///@see \#TNF_WELL_KNOWN
  static jni.JniObject get RTD_SMART_POSTER =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_RTD_SMART_POSTER, jni.JniType.objectType)
          .object);

  static final _id_RTD_TEXT =
      jniAccessors.getStaticFieldIDOf(_classRef, "RTD_TEXT", "[B");

  /// from: static public final byte[] RTD_TEXT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// RTD Text type. For use with {@literal TNF_WELL_KNOWN}.
  ///@see \#TNF_WELL_KNOWN
  static jni.JniObject get RTD_TEXT => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_RTD_TEXT, jni.JniType.objectType)
      .object);

  static final _id_RTD_URI =
      jniAccessors.getStaticFieldIDOf(_classRef, "RTD_URI", "[B");

  /// from: static public final byte[] RTD_URI
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// RTD URI type. For use with {@literal TNF_WELL_KNOWN}.
  ///@see \#TNF_WELL_KNOWN
  static jni.JniObject get RTD_URI => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_RTD_URI, jni.JniType.objectType)
      .object);

  /// from: static public final short TNF_ABSOLUTE_URI
  ///
  /// Indicates the type field contains an absolute-URI
  /// BNF construct defined by RFC 3986.
  /// When creating new records prefer \#createUri,
  /// since it offers more compact URI encoding
  /// ({@literal \#RTD_URI} allows compression of common URI prefixes).
  ///@see \#createUri
  static const TNF_ABSOLUTE_URI = 3;

  /// from: static public final short TNF_EMPTY
  ///
  /// Indicates the record is empty.
  /// Type, id and payload fields are empty in a {@literal TNF_EMPTY} record.
  static const TNF_EMPTY = 0;

  /// from: static public final short TNF_EXTERNAL_TYPE
  ///
  /// Indicates the type field contains an external type name.
  /// Used to encode custom payloads. When creating new records
  /// use the helper \#createExternal.
  /// The external-type RTD format is specified in NFCForum-TS-RTD_1.0.
  ///
  /// Note this TNF should not be used with RTD_TEXT or RTD_URI constants.
  /// Those are well known RTD constants, not external RTD constants.
  ///@see \#createExternal
  static const TNF_EXTERNAL_TYPE = 4;

  /// from: static public final short TNF_MIME_MEDIA
  ///
  /// Indicates the type field contains a media-type BNF
  /// construct, defined by RFC 2046.
  /// Use this with MIME type names such as {@literal "image/jpeg"}, or
  /// using the helper \#createMime.
  ///@see \#createMime
  static const TNF_MIME_MEDIA = 2;

  /// from: static public final short TNF_UNCHANGED
  ///
  /// Indicates the payload is an intermediate or final chunk of a chunked
  /// NDEF Record.
  /// {@literal TNF_UNCHANGED} can not be used with this class
  /// since all NdefRecords are already unchunked, however they
  /// may appear in the binary format.
  static const TNF_UNCHANGED = 6;

  /// from: static public final short TNF_UNKNOWN
  ///
  /// Indicates the payload type is unknown.
  /// NFC Forum explains this should be treated similarly to the
  /// "application/octet-stream" MIME type. The payload
  /// type is not explicitly encoded within the record.
  ///
  /// The type field is empty in an {@literal TNF_UNKNOWN} record.
  static const TNF_UNKNOWN = 5;

  /// from: static public final short TNF_WELL_KNOWN
  ///
  /// Indicates the type field contains a well-known RTD type name.
  /// Use this tnf with RTD types such as \#RTD_TEXT, \#RTD_URI.
  ///
  /// The RTD type name format is specified in NFCForum-TS-RTD_1.0.
  ///@see \#RTD_URI
  ///@see \#RTD_TEXT
  ///@see \#RTD_SMART_POSTER
  ///@see \#createUri
  static const TNF_WELL_KNOWN = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(S[B[B[B)V");

  /// from: public void <init>(short tnf, byte[] type, byte[] id, byte[] payload)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct an NDEF Record from its component fields.
  /// Recommend to use helpers such as {\#createUri} or
  /// {\#createExternal where possible, since they perform
  /// stricter validation that the record is correctly formatted
  /// as per NDEF specifications. However if you know what you are
  /// doing then this constructor offers the most flexibility.
  /// An NdefRecord represents a logical (complete)
  /// record, and cannot represent NDEF Record chunks.
  /// Basic validation of the tnf, type, id and payload is performed
  /// as per the following rules:
  /// <ul>
  /// <li>The tnf paramter must be a 3-bit value.</li>
  /// <li>Records with a tnf of \#TNF_EMPTY cannot have a type,
  /// id or payload.</li>
  /// <li>Records with a tnf of \#TNF_UNKNOWN or {@literal 0x07}
  /// cannot have a type.</li>
  /// <li>Records with a tnf of \#TNF_UNCHANGED are not allowed
  /// since this class only represents complete (unchunked) records.</li>
  /// </ul>
  /// This minimal validation is specified by
  /// NFCForum-TS-NDEF_1.0 section 3.2.6 (Type Name Format).
  /// If any of the above validation
  /// steps fail then IllegalArgumentException is thrown.
  /// Deep inspection of the type, id and payload fields is not
  /// performed, so it is possible to create NDEF Records
  /// that conform to section 3.2.6
  /// but fail other more strict NDEF specification requirements. For
  /// example, the payload may be invalid given the tnf and type.
  ///
  /// To omit a type, id or payload field, set the parameter to an
  /// empty byte array or null.
  ///@param tnf a 3-bit TNF constant
  ///@param type byte array, containing zero to 255 bytes, or null
  ///@param id byte array, containing zero to 255 bytes, or null
  ///@param payload byte array, containing zero to (2 ** 32 - 1) bytes,
  ///                or null
  ///@throws IllegalArugmentException if a valid record cannot be created
  NdefRecord(
      int tnf, jni.JniObject type, jni.JniObject id, jni.JniObject payload)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [tnf, type.reference, id.reference, payload.reference]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "([B)V");

  /// from: public void <init>(byte[] data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct an NDEF Record from raw bytes.
  /// This method is deprecated, use NdefMessage\#NdefMessage(byte[])
  /// instead. This is because it does not make sense to parse a record:
  /// the NDEF binary format is only defined for a message, and the
  /// record flags MB and ME do not make sense outside of the context of
  /// an entire message.
  /// This implementation will attempt to parse a single record by ignoring
  /// the MB and ME flags, and otherwise following the rules of
  /// NdefMessage\#NdefMessage(byte[]).
  ///@param data raw bytes to parse
  ///@throws FormatException if the data cannot be parsed into a valid record
  ///@deprecated use NdefMessage\#NdefMessage(byte[]) instead.
  NdefRecord.ctor1(jni.JniObject data)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [data.reference]).object);

  static final _id_createApplicationRecord = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createApplicationRecord",
      "(Ljava/lang/String;)Landroid/nfc/NdefRecord;");

  /// from: static public android.nfc.NdefRecord createApplicationRecord(java.lang.String packageName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new Android Application Record (AAR).
  ///
  /// This record indicates to other Android devices the package
  /// that should be used to handle the entire NDEF message.
  /// You can embed this record anywhere into your message
  /// to ensure that the intended package receives the message.
  ///
  /// When an Android device dispatches an NdefMessage
  /// containing one or more Android application records,
  /// the applications contained in those records will be the
  /// preferred target for the NfcAdapter\#ACTION_NDEF_DISCOVERED
  /// intent, in the order in which they appear in the message.
  /// This dispatch behavior was first added to Android in
  /// Ice Cream Sandwich.
  ///
  /// If none of the applications have a are installed on the device,
  /// a Market link will be opened to the first application.
  ///
  /// Note that Android application records do not overrule
  /// applications that have called
  /// NfcAdapter\#enableForegroundDispatch.
  ///@param packageName Android package name
  ///@return Android application NDEF record
  static NdefRecord createApplicationRecord(jni.JniString packageName) =>
      NdefRecord.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createApplicationRecord,
          jni.JniType.objectType,
          [packageName.reference]).object);

  static final _id_createUri = jniAccessors.getStaticMethodIDOf(
      _classRef, "createUri", "(Landroid/net/Uri;)Landroid/nfc/NdefRecord;");

  /// from: static public android.nfc.NdefRecord createUri(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new NDEF Record containing a URI.
  /// Use this method to encode a URI (or URL) into an NDEF Record.
  /// Uses the well known URI type representation: \#TNF_WELL_KNOWN
  /// and \#RTD_URI. This is the most efficient encoding
  /// of a URI into NDEF.
  /// The uri parameter will be normalized with
  /// Uri\#normalizeScheme to set the scheme to lower case to
  /// follow Android best practices for intent filtering.
  /// However the unchecked exception
  /// IllegalArgumentException may be thrown if the uri
  /// parameter has serious problems, for example if it is empty, so always
  /// catch this exception if you are passing user-generated data into this
  /// method.
  ///
  /// Reference specification: NFCForum-TS-RTD_URI_1.0
  ///@param uri URI to encode.
  ///@return an NDEF Record containing the URI
  ///@throws IllegalArugmentException if the uri is empty or invalid
  static NdefRecord createUri(uri_.Uri uri) =>
      NdefRecord.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_createUri, jni.JniType.objectType, [uri.reference]).object);

  static final _id_createUri1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "createUri", "(Ljava/lang/String;)Landroid/nfc/NdefRecord;");

  /// from: static public android.nfc.NdefRecord createUri(java.lang.String uriString)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new NDEF Record containing a URI.
  /// Use this method to encode a URI (or URL) into an NDEF Record.
  /// Uses the well known URI type representation: \#TNF_WELL_KNOWN
  /// and \#RTD_URI. This is the most efficient encoding
  /// of a URI into NDEF.
  /// The uriString parameter will be normalized with
  /// Uri\#normalizeScheme to set the scheme to lower case to
  /// follow Android best practices for intent filtering.
  /// However the unchecked exception
  /// IllegalArgumentException may be thrown if the uriString
  /// parameter has serious problems, for example if it is empty, so always
  /// catch this exception if you are passing user-generated data into this
  /// method.
  ///
  /// Reference specification: NFCForum-TS-RTD_URI_1.0
  ///@param uriString string URI to encode.
  ///@return an NDEF Record containing the URI
  ///@throws IllegalArugmentException if the uriString is empty or invalid
  static NdefRecord createUri1(jni.JniString uriString) =>
      NdefRecord.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createUri1,
          jni.JniType.objectType,
          [uriString.reference]).object);

  static final _id_createMime = jniAccessors.getStaticMethodIDOf(_classRef,
      "createMime", "(Ljava/lang/String;[B)Landroid/nfc/NdefRecord;");

  /// from: static public android.nfc.NdefRecord createMime(java.lang.String mimeType, byte[] mimeData)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new NDEF Record containing MIME data.
  /// Use this method to encode MIME-typed data into an NDEF Record,
  /// such as "text/plain", or "image/jpeg".
  /// The mimeType parameter will be normalized with
  /// Intent\#normalizeMimeType to follow Android best
  /// practices for intent filtering, for example to force lower-case.
  /// However the unchecked exception
  /// IllegalArgumentException may be thrown
  /// if the mimeType parameter has serious problems,
  /// for example if it is empty, so always catch this
  /// exception if you are passing user-generated data into this method.
  ///
  /// For efficiency, This method might not make an internal copy of the
  /// mimeData byte array, so take care not
  /// to modify the mimeData byte array while still using the returned
  /// NdefRecord.
  ///@param mimeType a valid MIME type
  ///@param mimeData MIME data as bytes
  ///@return an NDEF Record containing the MIME-typed data
  ///@throws IllegalArugmentException if the mimeType is empty or invalid
  static NdefRecord createMime(
          jni.JniString mimeType, jni.JniObject mimeData) =>
      NdefRecord.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createMime,
          jni.JniType.objectType,
          [mimeType.reference, mimeData.reference]).object);

  static final _id_createExternal = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createExternal",
      "(Ljava/lang/String;Ljava/lang/String;[B)Landroid/nfc/NdefRecord;");

  /// from: static public android.nfc.NdefRecord createExternal(java.lang.String domain, java.lang.String type, byte[] data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new NDEF Record containing external (application-specific) data.
  /// Use this method to encode application specific data into an NDEF Record.
  /// The data is typed by a domain name (usually your Android package name) and
  /// a domain-specific type. This data is packaged into a "NFC Forum External
  /// Type" NDEF Record.
  /// NFC Forum requires that the domain and type used in an external record
  /// are treated as case insensitive, however Android intent filtering is
  /// always case sensitive. So this method will force the domain and type to
  /// lower-case before creating the NDEF Record.
  /// The unchecked exception IllegalArgumentException will be thrown
  /// if the domain and type have serious problems, for example if either field
  /// is empty, so always catch this
  /// exception if you are passing user-generated data into this method.
  /// There are no such restrictions on the payload data.
  /// For efficiency, This method might not make an internal copy of the
  /// data byte array, so take care not
  /// to modify the data byte array while still using the returned
  /// NdefRecord.
  ///
  /// Reference specification: NFCForum-TS-RTD_1.0
  ///@param domain domain-name of issuing organization
  ///@param type domain-specific type of data
  ///@param data payload as bytes
  ///@throws IllegalArugmentException if either domain or type are empty or invalid
  static NdefRecord createExternal(
          jni.JniString domain, jni.JniString type, jni.JniObject data) =>
      NdefRecord.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createExternal,
          jni.JniType.objectType,
          [domain.reference, type.reference, data.reference]).object);

  static final _id_createTextRecord = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createTextRecord",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/nfc/NdefRecord;");

  /// from: static public android.nfc.NdefRecord createTextRecord(java.lang.String languageCode, java.lang.String text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new NDEF record containing UTF-8 text data.
  ///
  /// The caller can either specify the language code for the provided text,
  /// or otherwise the language code corresponding to the current default
  /// locale will be used.
  ///
  /// Reference specification: NFCForum-TS-RTD_Text_1.0
  ///@param languageCode The languageCode for the record. If locale is empty or null,
  ///                     the language code of the current default locale will be used.
  ///@param text The text to be encoded in the record. Will be represented in UTF-8 format.
  ///@throws IllegalArgumentException if text is null
  static NdefRecord createTextRecord(
          jni.JniString languageCode, jni.JniString text) =>
      NdefRecord.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createTextRecord,
          jni.JniType.objectType,
          [languageCode.reference, text.reference]).object);

  static final _id_getTnf =
      jniAccessors.getMethodIDOf(_classRef, "getTnf", "()S");

  /// from: public short getTnf()
  ///
  /// Returns the 3-bit TNF.
  ///
  /// TNF is the top-level type.
  int getTnf() => jniAccessors.callMethodWithArgs(
      reference, _id_getTnf, jni.JniType.shortType, []).short;

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "()[B");

  /// from: public byte[] getType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the variable length Type field.
  ///
  /// This should be used in conjunction with the TNF field to determine the
  /// payload format.
  ///
  /// Returns an empty byte array if this record
  /// does not have a type field.
  jni.JniObject getType() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getType, jni.JniType.objectType, []).object);

  static final _id_getId =
      jniAccessors.getMethodIDOf(_classRef, "getId", "()[B");

  /// from: public byte[] getId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the variable length ID.
  ///
  /// Returns an empty byte array if this record
  /// does not have an id field.
  jni.JniObject getId() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getId, jni.JniType.objectType, []).object);

  static final _id_getPayload =
      jniAccessors.getMethodIDOf(_classRef, "getPayload", "()[B");

  /// from: public byte[] getPayload()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the variable length payload.
  ///
  /// Returns an empty byte array if this record
  /// does not have a payload field.
  jni.JniObject getPayload() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPayload, jni.JniType.objectType, []).object);

  static final _id_toByteArray =
      jniAccessors.getMethodIDOf(_classRef, "toByteArray", "()[B");

  /// from: public byte[] toByteArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return this NDEF Record as a byte array.
  /// This method is deprecated, use NdefMessage\#toByteArray
  /// instead. This is because the NDEF binary format is not defined for
  /// a record outside of the context of a message: the MB and ME flags
  /// cannot be set without knowing the location inside a message.
  /// This implementation will attempt to serialize a single record by
  /// always setting the MB and ME flags (in other words, assume this
  /// is a single-record NDEF Message).
  ///@deprecated use NdefMessage\#toByteArray() instead
  jni.JniObject toByteArray() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toByteArray, jni.JniType.objectType, []).object);

  static final _id_toMimeType = jniAccessors.getMethodIDOf(
      _classRef, "toMimeType", "()Ljava/lang/String;");

  /// from: public java.lang.String toMimeType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Map this record to a MIME type, or return null if it cannot be mapped.
  /// Currently this method considers all \#TNF_MIME_MEDIA records to
  /// be MIME records, as well as some \#TNF_WELL_KNOWN records such as
  /// \#RTD_TEXT. If this is a MIME record then the MIME type as string
  /// is returned, otherwise null is returned.
  /// This method does not perform validation that the MIME type is
  /// actually valid. It always attempts to
  /// return a string containing the type if this is a MIME record.
  /// The returned MIME type will by normalized to lower-case using
  /// Intent\#normalizeMimeType.
  /// The MIME payload can be obtained using \#getPayload.
  ///@return MIME type as a string, or null if this is not a MIME record
  jni.JniString toMimeType() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toMimeType, jni.JniType.objectType, []).object);

  static final _id_toUri =
      jniAccessors.getMethodIDOf(_classRef, "toUri", "()Landroid/net/Uri;");

  /// from: public android.net.Uri toUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Map this record to a URI, or return null if it cannot be mapped.
  /// Currently this method considers the following to be URI records:
  /// <ul>
  /// <li>\#TNF_ABSOLUTE_URI records.</li>
  /// <li>\#TNF_WELL_KNOWN with a type of \#RTD_URI.</li>
  /// <li>\#TNF_WELL_KNOWN with a type of \#RTD_SMART_POSTER
  /// and containing a URI record in the NDEF message nested in the payload.
  /// </li>
  /// <li>\#TNF_EXTERNAL_TYPE records.</li>
  /// </ul>
  /// If this is not a URI record by the above rules, then null is returned.
  /// This method does not perform validation that the URI is
  /// actually valid: it always attempts to create and return a URI if
  /// this record appears to be a URI record by the above rules.
  /// The returned URI will be normalized to have a lower case scheme
  /// using Uri\#normalizeScheme.
  ///@return URI, or null if this is not a URI record
  uri_.Uri toUri() => uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_toUri, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// Returns true if the specified NDEF Record contains
  /// identical tnf, type, id and payload fields.
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
