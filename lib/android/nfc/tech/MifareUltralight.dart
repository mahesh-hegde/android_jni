// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../Tag.dart" as tag_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.nfc.tech.MifareUltralight
///
/// Provides access to MIFARE Ultralight properties and I/O operations on a Tag.
///
/// Acquire a MifareUltralight object using \#get.
///
/// MIFARE Ultralight compatible tags have 4 byte pages \#PAGE_SIZE.
/// The primary operations on an Ultralight tag are \#readPages and
/// \#writePage.
///
/// The original MIFARE Ultralight consists of a 64 byte EEPROM. The first
/// 4 pages are for the OTP area, manufacturer data, and locking bits. They are
/// readable and some bits are writable. The final 12 pages are the user
/// read/write area. For more information see the NXP data sheet MF0ICU1.
///
/// The MIFARE Ultralight C consists of a 192 byte EEPROM. The first 4 pages
/// are for OTP, manufacturer data, and locking bits. The next 36 pages are the
/// user read/write area. The next 4 pages are additional locking bits, counters
/// and authentication configuration and are readable. The final 4 pages are for
/// the authentication key and are not readable. For more information see the
/// NXP data sheet MF0ICU2.
///
/// Implementation of this class on a Android NFC device is optional.
/// If it is not implemented, then
/// MifareUltralight will never be enumerated in Tag\#getTechList.
/// If it is enumerated, then all MifareUltralight I/O operations will be supported.
/// In either case, NfcA will also be enumerated on the tag,
/// because all MIFARE Ultralight tags are also NfcA tags.
///
/// <p class="note"><strong>Note:</strong> Methods that perform I/O operations
/// require the android.Manifest.permission\#NFC permission.
class MifareUltralight extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/nfc/tech/MifareUltralight");
  MifareUltralight.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int PAGE_SIZE
  ///
  /// Size of a MIFARE Ultralight page in bytes
  static const PAGE_SIZE = 4;

  /// from: static public final int TYPE_ULTRALIGHT
  ///
  /// A MIFARE Ultralight tag
  static const TYPE_ULTRALIGHT = 1;

  /// from: static public final int TYPE_ULTRALIGHT_C
  ///
  /// A MIFARE Ultralight C tag
  static const TYPE_ULTRALIGHT_C = 2;

  /// from: static public final int TYPE_UNKNOWN
  ///
  /// A MIFARE Ultralight compatible tag of unknown type
  static const TYPE_UNKNOWN = -1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/nfc/Tag;)V");

  /// from: void <init>(android.nfc.Tag tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  MifareUltralight(tag_.Tag tag)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [tag.reference]).object);

  static final _id_get0 = jniAccessors.getStaticMethodIDOf(_classRef, "get",
      "(Landroid/nfc/Tag;)Landroid/nfc/tech/MifareUltralight;");

  /// from: static public android.nfc.tech.MifareUltralight get(android.nfc.Tag tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get an instance of MifareUltralight for the given tag.
  /// Returns null if MifareUltralight was not enumerated in
  /// Tag\#getTechList - this indicates the tag is not MIFARE
  /// Ultralight compatible, or that this Android
  /// device does not implement MIFARE Ultralight.
  /// Does not cause any RF activity and does not block.
  ///@param tag an MIFARE Ultralight compatible tag
  ///@return MIFARE Ultralight object
  static MifareUltralight get0(tag_.Tag tag) =>
      MifareUltralight.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_get0, jni.JniType.objectType, [tag.reference]).object);

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "()I");

  /// from: public int getType()
  ///
  /// Return the MIFARE Ultralight type of the tag.
  /// One of \#TYPE_ULTRALIGHT or \#TYPE_ULTRALIGHT_C or
  /// \#TYPE_UNKNOWN.
  /// Depending on how the tag has been formatted, it can be impossible
  /// to accurately classify between original MIFARE Ultralight and
  /// Ultralight C. So treat this method as a hint.
  /// Does not cause any RF activity and does not block.
  ///@return the type
  int getType() => jniAccessors.callMethodWithArgs(
      reference, _id_getType, jni.JniType.intType, []).integer;

  static final _id_readPages =
      jniAccessors.getMethodIDOf(_classRef, "readPages", "(I)[B");

  /// from: public byte[] readPages(int pageOffset)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read 4 pages (16 bytes).
  ///
  /// The MIFARE Ultralight protocol always reads 4 pages at a time, to
  /// reduce the number of commands required to read an entire tag.
  /// If a read spans past the last readable block, then the tag will
  /// return pages that have been wrapped back to the first blocks. MIFARE
  /// Ultralight tags have readable blocks 0x00 through 0x0F. So a read to
  /// block offset 0x0E would return blocks 0x0E, 0x0F, 0x00, 0x01. MIFARE
  /// Ultralight C tags have readable blocks 0x00 through 0x2B. So a read to
  /// block 0x2A would return blocks 0x2A, 0x2B, 0x00, 0x01.
  ///
  /// This is an I/O operation and will block until complete. It must
  /// not be called from the main application thread. A blocked call will be canceled with
  /// IOException if \#close is called from another thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param pageOffset index of first page to read, starting from 0
  ///@return 4 pages (16 bytes)
  ///@throws TagLostException if the tag leaves the field
  ///@throws IOException if there is an I/O failure, or the operation is canceled
  jni.JniObject readPages(int pageOffset) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_readPages, jni.JniType.objectType, [pageOffset]).object);

  static final _id_writePage =
      jniAccessors.getMethodIDOf(_classRef, "writePage", "(I[B)V");

  /// from: public void writePage(int pageOffset, byte[] data)
  ///
  /// Write 1 page (4 bytes).
  ///
  /// The MIFARE Ultralight protocol always writes 1 page at a time, to
  /// minimize EEPROM write cycles.
  ///
  /// This is an I/O operation and will block until complete. It must
  /// not be called from the main application thread. A blocked call will be canceled with
  /// IOException if \#close is called from another thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param pageOffset index of page to write, starting from 0
  ///@param data 4 bytes to write
  ///@throws TagLostException if the tag leaves the field
  ///@throws IOException if there is an I/O failure, or the operation is canceled
  void writePage(int pageOffset, jni.JniObject data) =>
      jniAccessors.callMethodWithArgs(reference, _id_writePage,
          jni.JniType.voidType, [pageOffset, data.reference]).check();

  static final _id_transceive =
      jniAccessors.getMethodIDOf(_classRef, "transceive", "([B)[B");

  /// from: public byte[] transceive(byte[] data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Send raw NfcA data to a tag and receive the response.
  ///
  /// This is equivalent to connecting to this tag via NfcA
  /// and calling NfcA\#transceive. Note that all MIFARE Classic
  /// tags are based on NfcA technology.
  ///
  /// Use \#getMaxTransceiveLength to retrieve the maximum number of bytes
  /// that can be sent with \#transceive.
  ///
  /// This is an I/O operation and will block until complete. It must
  /// not be called from the main application thread. A blocked call will be canceled with
  /// IOException if \#close is called from another thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@see NfcA\#transceive
  jni.JniObject transceive(jni.JniObject data) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_transceive, jni.JniType.objectType, [data.reference]).object);

  static final _id_getMaxTransceiveLength =
      jniAccessors.getMethodIDOf(_classRef, "getMaxTransceiveLength", "()I");

  /// from: public int getMaxTransceiveLength()
  ///
  /// Return the maximum number of bytes that can be sent with \#transceive.
  ///@return the maximum number of bytes that can be sent with \#transceive.
  int getMaxTransceiveLength() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxTransceiveLength, jni.JniType.intType, []).integer;

  static final _id_setTimeout =
      jniAccessors.getMethodIDOf(_classRef, "setTimeout", "(I)V");

  /// from: public void setTimeout(int timeout)
  ///
  /// Set the \#transceive timeout in milliseconds.
  ///
  /// The timeout only applies to \#transceive on this object,
  /// and is reset to a default value when \#close is called.
  ///
  /// Setting a longer timeout may be useful when performing
  /// transactions that require a long processing time on the tag
  /// such as key generation.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param timeout timeout value in milliseconds
  void setTimeout(int timeout) => jniAccessors.callMethodWithArgs(
      reference, _id_setTimeout, jni.JniType.voidType, [timeout]).check();

  static final _id_getTimeout =
      jniAccessors.getMethodIDOf(_classRef, "getTimeout", "()I");

  /// from: public int getTimeout()
  ///
  /// Get the current \#transceive timeout in milliseconds.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@return timeout value in milliseconds
  int getTimeout() => jniAccessors.callMethodWithArgs(
      reference, _id_getTimeout, jni.JniType.intType, []).integer;

  static final _id_isConnected =
      jniAccessors.getMethodIDOf(_classRef, "isConnected", "()Z");

  /// from: public boolean isConnected()
  bool isConnected() => jniAccessors.callMethodWithArgs(
      reference, _id_isConnected, jni.JniType.booleanType, []).boolean;

  static final _id_getTag =
      jniAccessors.getMethodIDOf(_classRef, "getTag", "()Landroid/nfc/Tag;");

  /// from: public android.nfc.Tag getTag()
  /// The returned object must be deleted after use, by calling the `delete` method.
  tag_.Tag getTag() => tag_.Tag.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getTag, jni.JniType.objectType, []).object);

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_connect =
      jniAccessors.getMethodIDOf(_classRef, "connect", "()V");

  /// from: public void connect()
  void connect() => jniAccessors.callMethodWithArgs(
      reference, _id_connect, jni.JniType.voidType, []).check();
}
