// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../Tag.dart" as tag_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.nfc.tech.MifareClassic
///
/// Provides access to MIFARE Classic properties and I/O operations on a Tag.
///
/// Acquire a MifareClassic object using \#get.
///
/// MIFARE Classic is also known as MIFARE Standard.
/// MIFARE Classic tags are divided into sectors, and each sector is sub-divided into
/// blocks. Block size is always 16 bytes (\#BLOCK_SIZE. Sector size varies.
/// <ul>
/// <li>MIFARE Classic Mini are 320 bytes (\#SIZE_MINI), with 5 sectors each of 4 blocks.
/// <li>MIFARE Classic 1k are 1024 bytes (\#SIZE_1K), with 16 sectors each of 4 blocks.
/// <li>MIFARE Classic 2k are 2048 bytes (\#SIZE_2K), with 32 sectors each of 4 blocks.
/// <li>MIFARE Classic 4k} are 4096 bytes (\#SIZE_4K). The first 32 sectors contain 4 blocks
/// and the last 8 sectors contain 16 blocks.
/// </ul>
///
/// MIFARE Classic tags require authentication on a per-sector basis before any
/// other I/O operations on that sector can be performed. There are two keys per sector,
/// and ACL bits determine what I/O operations are allowed on that sector after
/// authenticating with a key. {@see \#authenticateSectorWithKeyA} and
/// {@see \#authenticateSectorWithKeyB}.
///
/// Three well-known authentication keys are defined in this class:
/// \#KEY_DEFAULT, \#KEY_MIFARE_APPLICATION_DIRECTORY,
/// \#KEY_NFC_FORUM.
/// <ul>
/// <li>\#KEY_DEFAULT is the default factory key for MIFARE Classic.
/// <li>\#KEY_MIFARE_APPLICATION_DIRECTORY is the well-known key for
/// MIFARE Classic cards that have been formatted according to the
/// MIFARE Application Directory (MAD) specification.
/// <li>\#KEY_NFC_FORUM is the well-known key for MIFARE Classic cards that
/// have been formatted according to the NXP specification for NDEF on MIFARE Classic.
///
/// Implementation of this class on a Android NFC device is optional.
/// If it is not implemented, then
/// MifareClassic will never be enumerated in Tag\#getTechList.
/// If it is enumerated, then all MifareClassic I/O operations will be supported,
/// and Ndef\#MIFARE_CLASSIC NDEF tags will also be supported. In either case,
/// NfcA will also be enumerated on the tag, because all MIFARE Classic tags are also
/// NfcA.
///
/// <p class="note"><strong>Note:</strong> Methods that perform I/O operations
/// require the android.Manifest.permission\#NFC permission.
class MifareClassic extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/nfc/tech/MifareClassic");
  MifareClassic.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int BLOCK_SIZE
  ///
  /// Size of a MIFARE Classic block (in bytes)
  static const BLOCK_SIZE = 16;

  static final _id_KEY_DEFAULT =
      jniAccessors.getStaticFieldIDOf(_classRef, "KEY_DEFAULT", "[B");

  /// from: static public final byte[] KEY_DEFAULT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The default factory key.
  static jni.JniObject get KEY_DEFAULT => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_KEY_DEFAULT, jni.JniType.objectType)
      .object);

  static final _id_KEY_MIFARE_APPLICATION_DIRECTORY = jniAccessors
      .getStaticFieldIDOf(_classRef, "KEY_MIFARE_APPLICATION_DIRECTORY", "[B");

  /// from: static public final byte[] KEY_MIFARE_APPLICATION_DIRECTORY
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The well-known key for tags formatted according to the
  /// MIFARE Application Directory (MAD) specification.
  static jni.JniObject get KEY_MIFARE_APPLICATION_DIRECTORY =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(_classRef, _id_KEY_MIFARE_APPLICATION_DIRECTORY,
              jni.JniType.objectType)
          .object);

  static final _id_KEY_NFC_FORUM =
      jniAccessors.getStaticFieldIDOf(_classRef, "KEY_NFC_FORUM", "[B");

  /// from: static public final byte[] KEY_NFC_FORUM
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The well-known key for tags formatted according to the
  /// NDEF on MIFARE Classic specification.
  static jni.JniObject get KEY_NFC_FORUM => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_KEY_NFC_FORUM, jni.JniType.objectType)
      .object);

  /// from: static public final int SIZE_1K
  ///
  /// Tag contains 16 sectors, each with 4 blocks.
  static const SIZE_1K = 1024;

  /// from: static public final int SIZE_2K
  ///
  /// Tag contains 32 sectors, each with 4 blocks.
  static const SIZE_2K = 2048;

  /// from: static public final int SIZE_4K
  ///
  /// Tag contains 40 sectors. The first 32 sectors contain 4 blocks and the last 8 sectors
  /// contain 16 blocks.
  static const SIZE_4K = 4096;

  /// from: static public final int SIZE_MINI
  ///
  /// Tag contains 5 sectors, each with 4 blocks.
  static const SIZE_MINI = 320;

  /// from: static public final int TYPE_CLASSIC
  ///
  /// A MIFARE Classic tag
  static const TYPE_CLASSIC = 0;

  /// from: static public final int TYPE_PLUS
  ///
  /// A MIFARE Plus tag
  static const TYPE_PLUS = 1;

  /// from: static public final int TYPE_PRO
  ///
  /// A MIFARE Pro tag
  static const TYPE_PRO = 2;

  /// from: static public final int TYPE_UNKNOWN
  ///
  /// A MIFARE Classic compatible card of unknown type
  static const TYPE_UNKNOWN = -1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/nfc/Tag;)V");

  /// from: void <init>(android.nfc.Tag tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  MifareClassic(tag_.Tag tag)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [tag.reference]).object);

  static final _id_get0 = jniAccessors.getStaticMethodIDOf(
      _classRef, "get", "(Landroid/nfc/Tag;)Landroid/nfc/tech/MifareClassic;");

  /// from: static public android.nfc.tech.MifareClassic get(android.nfc.Tag tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get an instance of MifareClassic for the given tag.
  /// Does not cause any RF activity and does not block.
  /// Returns null if MifareClassic was not enumerated in Tag\#getTechList.
  /// This indicates the tag is not MIFARE Classic compatible, or this Android
  /// device does not support MIFARE Classic.
  ///@param tag an MIFARE Classic compatible tag
  ///@return MIFARE Classic object
  static MifareClassic get0(tag_.Tag tag) =>
      MifareClassic.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_get0, jni.JniType.objectType, [tag.reference]).object);

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "()I");

  /// from: public int getType()
  ///
  /// Return the type of this MIFARE Classic compatible tag.
  /// One of \#TYPE_UNKNOWN, \#TYPE_CLASSIC, \#TYPE_PLUS or
  /// \#TYPE_PRO.
  /// Does not cause any RF activity and does not block.
  ///@return type
  int getType() => jniAccessors.callMethodWithArgs(
      reference, _id_getType, jni.JniType.intType, []).integer;

  static final _id_getSize =
      jniAccessors.getMethodIDOf(_classRef, "getSize", "()I");

  /// from: public int getSize()
  ///
  /// Return the size of the tag in bytes
  /// One of \#SIZE_MINI, \#SIZE_1K, \#SIZE_2K, \#SIZE_4K.
  /// These constants are equal to their respective size in bytes.
  /// Does not cause any RF activity and does not block.
  ///@return size in bytes
  int getSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getSize, jni.JniType.intType, []).integer;

  static final _id_getSectorCount =
      jniAccessors.getMethodIDOf(_classRef, "getSectorCount", "()I");

  /// from: public int getSectorCount()
  ///
  /// Return the number of MIFARE Classic sectors.
  /// Does not cause any RF activity and does not block.
  ///@return number of sectors
  int getSectorCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getSectorCount, jni.JniType.intType, []).integer;

  static final _id_getBlockCount =
      jniAccessors.getMethodIDOf(_classRef, "getBlockCount", "()I");

  /// from: public int getBlockCount()
  ///
  /// Return the total number of MIFARE Classic blocks.
  /// Does not cause any RF activity and does not block.
  ///@return total number of blocks
  int getBlockCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getBlockCount, jni.JniType.intType, []).integer;

  static final _id_getBlockCountInSector =
      jniAccessors.getMethodIDOf(_classRef, "getBlockCountInSector", "(I)I");

  /// from: public int getBlockCountInSector(int sectorIndex)
  ///
  /// Return the number of blocks in the given sector.
  /// Does not cause any RF activity and does not block.
  ///@param sectorIndex index of sector, starting from 0
  ///@return number of blocks in the sector
  int getBlockCountInSector(int sectorIndex) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getBlockCountInSector,
      jni.JniType.intType,
      [sectorIndex]).integer;

  static final _id_blockToSector =
      jniAccessors.getMethodIDOf(_classRef, "blockToSector", "(I)I");

  /// from: public int blockToSector(int blockIndex)
  ///
  /// Return the sector that contains a given block.
  /// Does not cause any RF activity and does not block.
  ///@param blockIndex index of block to lookup, starting from 0
  ///@return sector index that contains the block
  int blockToSector(int blockIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_blockToSector, jni.JniType.intType, [blockIndex]).integer;

  static final _id_sectorToBlock =
      jniAccessors.getMethodIDOf(_classRef, "sectorToBlock", "(I)I");

  /// from: public int sectorToBlock(int sectorIndex)
  ///
  /// Return the first block of a given sector.
  /// Does not cause any RF activity and does not block.
  ///@param sectorIndex index of sector to lookup, starting from 0
  ///@return block index of first block in sector
  int sectorToBlock(int sectorIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_sectorToBlock, jni.JniType.intType, [sectorIndex]).integer;

  static final _id_authenticateSectorWithKeyA = jniAccessors.getMethodIDOf(
      _classRef, "authenticateSectorWithKeyA", "(I[B)Z");

  /// from: public boolean authenticateSectorWithKeyA(int sectorIndex, byte[] key)
  ///
  /// Authenticate a sector with key A.
  ///
  /// Successful authentication of a sector with key A enables other
  /// I/O operations on that sector. The set of operations granted by key A
  /// key depends on the ACL bits set in that sector. For more information
  /// see the MIFARE Classic specification on {@see http://www.nxp.com}.
  ///
  /// A failed authentication attempt causes an implicit reconnection to the
  /// tag, so authentication to other sectors will be lost.
  ///
  /// This is an I/O operation and will block until complete. It must
  /// not be called from the main application thread. A blocked call will be canceled with
  /// IOException if \#close is called from another thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param sectorIndex index of sector to authenticate, starting from 0
  ///@param key 6-byte authentication key
  ///@return true on success, false on authentication failure
  ///@throws TagLostException if the tag leaves the field
  ///@throws IOException if there is an I/O failure, or the operation is canceled
  bool authenticateSectorWithKeyA(int sectorIndex, jni.JniObject key) =>
      jniAccessors.callMethodWithArgs(reference, _id_authenticateSectorWithKeyA,
          jni.JniType.booleanType, [sectorIndex, key.reference]).boolean;

  static final _id_authenticateSectorWithKeyB = jniAccessors.getMethodIDOf(
      _classRef, "authenticateSectorWithKeyB", "(I[B)Z");

  /// from: public boolean authenticateSectorWithKeyB(int sectorIndex, byte[] key)
  ///
  /// Authenticate a sector with key B.
  ///
  /// Successful authentication of a sector with key B enables other
  /// I/O operations on that sector. The set of operations granted by key B
  /// depends on the ACL bits set in that sector. For more information
  /// see the MIFARE Classic specification on {@see http://www.nxp.com}.
  ///
  /// A failed authentication attempt causes an implicit reconnection to the
  /// tag, so authentication to other sectors will be lost.
  ///
  /// This is an I/O operation and will block until complete. It must
  /// not be called from the main application thread. A blocked call will be canceled with
  /// IOException if \#close is called from another thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param sectorIndex index of sector to authenticate, starting from 0
  ///@param key 6-byte authentication key
  ///@return true on success, false on authentication failure
  ///@throws TagLostException if the tag leaves the field
  ///@throws IOException if there is an I/O failure, or the operation is canceled
  bool authenticateSectorWithKeyB(int sectorIndex, jni.JniObject key) =>
      jniAccessors.callMethodWithArgs(reference, _id_authenticateSectorWithKeyB,
          jni.JniType.booleanType, [sectorIndex, key.reference]).boolean;

  static final _id_readBlock =
      jniAccessors.getMethodIDOf(_classRef, "readBlock", "(I)[B");

  /// from: public byte[] readBlock(int blockIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read 16-byte block.
  ///
  /// This is an I/O operation and will block until complete. It must
  /// not be called from the main application thread. A blocked call will be canceled with
  /// IOException if \#close is called from another thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param blockIndex index of block to read, starting from 0
  ///@return 16 byte block
  ///@throws TagLostException if the tag leaves the field
  ///@throws IOException if there is an I/O failure, or the operation is canceled
  jni.JniObject readBlock(int blockIndex) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_readBlock, jni.JniType.objectType, [blockIndex]).object);

  static final _id_writeBlock =
      jniAccessors.getMethodIDOf(_classRef, "writeBlock", "(I[B)V");

  /// from: public void writeBlock(int blockIndex, byte[] data)
  ///
  /// Write 16-byte block.
  ///
  /// This is an I/O operation and will block until complete. It must
  /// not be called from the main application thread. A blocked call will be canceled with
  /// IOException if \#close is called from another thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param blockIndex index of block to write, starting from 0
  ///@param data 16 bytes of data to write
  ///@throws TagLostException if the tag leaves the field
  ///@throws IOException if there is an I/O failure, or the operation is canceled
  void writeBlock(int blockIndex, jni.JniObject data) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeBlock,
          jni.JniType.voidType, [blockIndex, data.reference]).check();

  static final _id_increment =
      jniAccessors.getMethodIDOf(_classRef, "increment", "(II)V");

  /// from: public void increment(int blockIndex, int value)
  ///
  /// Increment a value block, storing the result in the temporary block on the tag.
  ///
  /// This is an I/O operation and will block until complete. It must
  /// not be called from the main application thread. A blocked call will be canceled with
  /// IOException if \#close is called from another thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param blockIndex index of block to increment, starting from 0
  ///@param value non-negative to increment by
  ///@throws TagLostException if the tag leaves the field
  ///@throws IOException if there is an I/O failure, or the operation is canceled
  void increment(int blockIndex, int value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_increment,
      jni.JniType.voidType,
      [blockIndex, value]).check();

  static final _id_decrement =
      jniAccessors.getMethodIDOf(_classRef, "decrement", "(II)V");

  /// from: public void decrement(int blockIndex, int value)
  ///
  /// Decrement a value block, storing the result in the temporary block on the tag.
  ///
  /// This is an I/O operation and will block until complete. It must
  /// not be called from the main application thread. A blocked call will be canceled with
  /// IOException if \#close is called from another thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param blockIndex index of block to decrement, starting from 0
  ///@param value non-negative to decrement by
  ///@throws TagLostException if the tag leaves the field
  ///@throws IOException if there is an I/O failure, or the operation is canceled
  void decrement(int blockIndex, int value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_decrement,
      jni.JniType.voidType,
      [blockIndex, value]).check();

  static final _id_transfer =
      jniAccessors.getMethodIDOf(_classRef, "transfer", "(I)V");

  /// from: public void transfer(int blockIndex)
  ///
  /// Copy from the temporary block to a value block.
  ///
  /// This is an I/O operation and will block until complete. It must
  /// not be called from the main application thread. A blocked call will be canceled with
  /// IOException if \#close is called from another thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param blockIndex index of block to copy to
  ///@throws TagLostException if the tag leaves the field
  ///@throws IOException if there is an I/O failure, or the operation is canceled
  void transfer(int blockIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_transfer, jni.JniType.voidType, [blockIndex]).check();

  static final _id_restore =
      jniAccessors.getMethodIDOf(_classRef, "restore", "(I)V");

  /// from: public void restore(int blockIndex)
  ///
  /// Copy from a value block to the temporary block.
  ///
  /// This is an I/O operation and will block until complete. It must
  /// not be called from the main application thread. A blocked call will be canceled with
  /// IOException if \#close is called from another thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param blockIndex index of block to copy from
  ///@throws TagLostException if the tag leaves the field
  ///@throws IOException if there is an I/O failure, or the operation is canceled
  void restore(int blockIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_restore, jni.JniType.voidType, [blockIndex]).check();

  static final _id_transceive =
      jniAccessors.getMethodIDOf(_classRef, "transceive", "([B)[B");

  /// from: public byte[] transceive(byte[] data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Send raw NfcA data to a tag and receive the response.
  ///
  /// This is equivalent to connecting to this tag via NfcA
  /// and calling NfcA\#transceive. Note that all MIFARE Classic
  /// tags are based on NfcA technology.
  ///
  /// Use \#getMaxTransceiveLength to retrieve the maximum number of bytes
  /// that can be sent with \#transceive.
  ///
  /// This is an I/O operation and will block until complete. It must
  /// not be called from the main application thread. A blocked call will be canceled with
  /// IOException if \#close is called from another thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@see NfcA\#transceive
  jni.JniObject transceive(jni.JniObject data) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_transceive, jni.JniType.objectType, [data.reference]).object);

  static final _id_getMaxTransceiveLength =
      jniAccessors.getMethodIDOf(_classRef, "getMaxTransceiveLength", "()I");

  /// from: public int getMaxTransceiveLength()
  ///
  /// Return the maximum number of bytes that can be sent with \#transceive.
  ///@return the maximum number of bytes that can be sent with \#transceive.
  int getMaxTransceiveLength() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxTransceiveLength, jni.JniType.intType, []).integer;

  static final _id_setTimeout =
      jniAccessors.getMethodIDOf(_classRef, "setTimeout", "(I)V");

  /// from: public void setTimeout(int timeout)
  ///
  /// Set the \#transceive timeout in milliseconds.
  ///
  /// The timeout only applies to \#transceive on this object,
  /// and is reset to a default value when \#close is called.
  ///
  /// Setting a longer timeout may be useful when performing
  /// transactions that require a long processing time on the tag
  /// such as key generation.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param timeout timeout value in milliseconds
  void setTimeout(int timeout) => jniAccessors.callMethodWithArgs(
      reference, _id_setTimeout, jni.JniType.voidType, [timeout]).check();

  static final _id_getTimeout =
      jniAccessors.getMethodIDOf(_classRef, "getTimeout", "()I");

  /// from: public int getTimeout()
  ///
  /// Get the current \#transceive timeout in milliseconds.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@return timeout value in milliseconds
  int getTimeout() => jniAccessors.callMethodWithArgs(
      reference, _id_getTimeout, jni.JniType.intType, []).integer;

  static final _id_isConnected =
      jniAccessors.getMethodIDOf(_classRef, "isConnected", "()Z");

  /// from: public boolean isConnected()
  bool isConnected() => jniAccessors.callMethodWithArgs(
      reference, _id_isConnected, jni.JniType.booleanType, []).boolean;

  static final _id_getTag =
      jniAccessors.getMethodIDOf(_classRef, "getTag", "()Landroid/nfc/Tag;");

  /// from: public android.nfc.Tag getTag()
  /// The returned object must be deleted after use, by calling the `delete` method.
  tag_.Tag getTag() => tag_.Tag.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getTag, jni.JniType.objectType, []).object);

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_connect =
      jniAccessors.getMethodIDOf(_classRef, "connect", "()V");

  /// from: public void connect()
  void connect() => jniAccessors.callMethodWithArgs(
      reference, _id_connect, jni.JniType.voidType, []).check();
}
