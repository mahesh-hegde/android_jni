// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../Tag.dart" as tag_;

import "../NdefMessage.dart" as ndefmessage_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.nfc.tech.Ndef
///
/// Provides access to NDEF content and operations on a Tag.
///
/// Acquire a Ndef object using \#get.
///
/// NDEF is an NFC Forum data format. The data formats are implemented in
/// android.nfc.NdefMessage and
/// android.nfc.NdefRecord. This class provides methods to
/// retrieve and modify the android.nfc.NdefMessage
/// on a tag.
///
/// There are currently four NFC Forum standardized tag types that can be
/// formatted to contain NDEF data.
/// <ul>
/// <li>NFC Forum Type 1 Tag (\#NFC_FORUM_TYPE_1), such as the Innovision Topaz
/// <li>NFC Forum Type 2 Tag (\#NFC_FORUM_TYPE_2), such as the NXP MIFARE Ultralight
/// <li>NFC Forum Type 3 Tag (\#NFC_FORUM_TYPE_3), such as Sony Felica
/// <li>NFC Forum Type 4 Tag (\#NFC_FORUM_TYPE_4), such as NXP MIFARE Desfire
/// </ul>
/// It is mandatory for all Android devices with NFC to correctly enumerate
/// Ndef on NFC Forum Tag Types 1-4, and implement all NDEF operations
/// as defined in this class.
///
/// Some vendors have their own well defined specifications for storing NDEF data
/// on tags that do not fall into the above categories. Android devices with NFC
/// should enumerate and implement Ndef under these vendor specifications
/// where possible, but it is not mandatory. \#getType returns a String
/// describing this specification, for example \#MIFARE_CLASSIC is
/// <code>com.nxp.ndef.mifareclassic</code>.
///
/// Android devices that support MIFARE Classic must also correctly
/// implement Ndef on MIFARE Classic tags formatted to NDEF.
///
/// For guaranteed compatibility across all Android devices with NFC, it is
/// recommended to use NFC Forum Types 1-4 in new deployments of NFC tags
/// with NDEF payload. Vendor NDEF formats will not work on all Android devices.
///
/// <p class="note"><strong>Note:</strong> Methods that perform I/O operations
/// require the android.Manifest.permission\#NFC permission.
class Ndef extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/nfc/tech/Ndef");
  Ndef.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String MIFARE_CLASSIC
  ///
  /// NDEF on MIFARE Classic
  static const MIFARE_CLASSIC = "com.nxp.ndef.mifareclassic";

  /// from: static public final java.lang.String NFC_FORUM_TYPE_1
  ///
  /// NFC Forum Tag Type 1
  static const NFC_FORUM_TYPE_1 = "org.nfcforum.ndef.type1";

  /// from: static public final java.lang.String NFC_FORUM_TYPE_2
  ///
  /// NFC Forum Tag Type 2
  static const NFC_FORUM_TYPE_2 = "org.nfcforum.ndef.type2";

  /// from: static public final java.lang.String NFC_FORUM_TYPE_3
  ///
  /// NFC Forum Tag Type 4
  static const NFC_FORUM_TYPE_3 = "org.nfcforum.ndef.type3";

  /// from: static public final java.lang.String NFC_FORUM_TYPE_4
  ///
  /// NFC Forum Tag Type 4
  static const NFC_FORUM_TYPE_4 = "org.nfcforum.ndef.type4";

  static final _id_get0 = jniAccessors.getStaticMethodIDOf(
      _classRef, "get", "(Landroid/nfc/Tag;)Landroid/nfc/tech/Ndef;");

  /// from: static public android.nfc.tech.Ndef get(android.nfc.Tag tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get an instance of Ndef for the given tag.
  ///
  /// Returns null if Ndef was not enumerated in Tag\#getTechList.
  /// This indicates the tag is not NDEF formatted, or that this tag
  /// is NDEF formatted but under a vendor specification that this Android
  /// device does not implement.
  ///
  /// Does not cause any RF activity and does not block.
  ///@param tag an NDEF compatible tag
  ///@return Ndef object
  static Ndef get0(tag_.Tag tag) =>
      Ndef.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_get0, jni.JniType.objectType, [tag.reference]).object);

  static final _id_getCachedNdefMessage = jniAccessors.getMethodIDOf(
      _classRef, "getCachedNdefMessage", "()Landroid/nfc/NdefMessage;");

  /// from: public android.nfc.NdefMessage getCachedNdefMessage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the NdefMessage that was read from the tag at discovery time.
  ///
  /// If the NDEF Message is modified by an I/O operation then it
  /// will not be updated here, this function only returns what was discovered
  /// when the tag entered the field.
  /// Note that this method may return null if the tag was in the
  /// INITIALIZED state as defined by NFC Forum, as in this state the
  /// tag is formatted to support NDEF but does not contain a message yet.
  /// Does not cause any RF activity and does not block.
  ///@return NDEF Message read from the tag at discovery time, can be null
  ndefmessage_.NdefMessage getCachedNdefMessage() =>
      ndefmessage_.NdefMessage.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCachedNdefMessage,
          jni.JniType.objectType, []).object);

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "()Ljava/lang/String;");

  /// from: public java.lang.String getType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the NDEF tag type.
  ///
  /// Returns one of \#NFC_FORUM_TYPE_1, \#NFC_FORUM_TYPE_2,
  /// \#NFC_FORUM_TYPE_3, \#NFC_FORUM_TYPE_4,
  /// \#MIFARE_CLASSIC or another NDEF tag type that has not yet been
  /// formalized in this Android API.
  ///
  /// Does not cause any RF activity and does not block.
  ///@return a string representing the NDEF tag type
  jni.JniString getType() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getType, jni.JniType.objectType, []).object);

  static final _id_getMaxSize =
      jniAccessors.getMethodIDOf(_classRef, "getMaxSize", "()I");

  /// from: public int getMaxSize()
  ///
  /// Get the maximum NDEF message size in bytes.
  ///
  /// Does not cause any RF activity and does not block.
  ///@return size in bytes
  int getMaxSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxSize, jni.JniType.intType, []).integer;

  static final _id_isWritable =
      jniAccessors.getMethodIDOf(_classRef, "isWritable", "()Z");

  /// from: public boolean isWritable()
  ///
  /// Determine if the tag is writable.
  ///
  /// NFC Forum tags can be in read-only or read-write states.
  ///
  /// Does not cause any RF activity and does not block.
  ///
  /// Requires android.Manifest.permission\#NFC permission.
  ///@return true if the tag is writable
  bool isWritable() => jniAccessors.callMethodWithArgs(
      reference, _id_isWritable, jni.JniType.booleanType, []).boolean;

  static final _id_getNdefMessage = jniAccessors.getMethodIDOf(
      _classRef, "getNdefMessage", "()Landroid/nfc/NdefMessage;");

  /// from: public android.nfc.NdefMessage getNdefMessage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read the current android.nfc.NdefMessage on this tag.
  ///
  /// This always reads the current NDEF Message stored on the tag.
  ///
  /// Note that this method may return null if the tag was in the
  /// INITIALIZED state as defined by NFC Forum, as in that state the
  /// tag is formatted to support NDEF but does not contain a message yet.
  ///
  /// This is an I/O operation and will block until complete. It must
  /// not be called from the main application thread. A blocked call will be canceled with
  /// IOException if \#close is called from another thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@return the NDEF Message, can be null
  ///@throws TagLostException if the tag leaves the field
  ///@throws IOException if there is an I/O failure, or the operation is canceled
  ///@throws FormatException if the NDEF Message on the tag is malformed
  ndefmessage_.NdefMessage getNdefMessage() =>
      ndefmessage_.NdefMessage.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getNdefMessage, jni.JniType.objectType, []).object);

  static final _id_writeNdefMessage = jniAccessors.getMethodIDOf(
      _classRef, "writeNdefMessage", "(Landroid/nfc/NdefMessage;)V");

  /// from: public void writeNdefMessage(android.nfc.NdefMessage msg)
  ///
  /// Overwrite the NdefMessage on this tag.
  ///
  /// This is an I/O operation and will block until complete. It must
  /// not be called from the main application thread. A blocked call will be canceled with
  /// IOException if \#close is called from another thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@param msg the NDEF Message to write, must not be null
  ///@throws TagLostException if the tag leaves the field
  ///@throws IOException if there is an I/O failure, or the operation is canceled
  ///@throws FormatException if the NDEF Message to write is malformed
  void writeNdefMessage(ndefmessage_.NdefMessage msg) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeNdefMessage,
          jni.JniType.voidType, [msg.reference]).check();

  static final _id_canMakeReadOnly =
      jniAccessors.getMethodIDOf(_classRef, "canMakeReadOnly", "()Z");

  /// from: public boolean canMakeReadOnly()
  ///
  /// Indicates whether a tag can be made read-only with \#makeReadOnly().
  ///
  /// Does not cause any RF activity and does not block.
  ///@return true if it is possible to make this tag read-only
  bool canMakeReadOnly() => jniAccessors.callMethodWithArgs(
      reference, _id_canMakeReadOnly, jni.JniType.booleanType, []).boolean;

  static final _id_makeReadOnly =
      jniAccessors.getMethodIDOf(_classRef, "makeReadOnly", "()Z");

  /// from: public boolean makeReadOnly()
  ///
  /// Make a tag read-only.
  ///
  /// This sets the CC field to indicate the tag is read-only,
  /// and where possible permanently sets the lock bits to prevent
  /// any further modification of the memory.
  /// This is a one-way process and cannot be reverted!
  ///
  /// This is an I/O operation and will block until complete. It must
  /// not be called from the main application thread. A blocked call will be canceled with
  /// IOException if \#close is called from another thread.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@return true on success, false if it is not possible to make this tag read-only
  ///@throws TagLostException if the tag leaves the field
  ///@throws IOException if there is an I/O failure, or the operation is canceled
  bool makeReadOnly() => jniAccessors.callMethodWithArgs(
      reference, _id_makeReadOnly, jni.JniType.booleanType, []).boolean;

  static final _id_isConnected =
      jniAccessors.getMethodIDOf(_classRef, "isConnected", "()Z");

  /// from: public boolean isConnected()
  bool isConnected() => jniAccessors.callMethodWithArgs(
      reference, _id_isConnected, jni.JniType.booleanType, []).boolean;

  static final _id_getTag =
      jniAccessors.getMethodIDOf(_classRef, "getTag", "()Landroid/nfc/Tag;");

  /// from: public android.nfc.Tag getTag()
  /// The returned object must be deleted after use, by calling the `delete` method.
  tag_.Tag getTag() => tag_.Tag.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getTag, jni.JniType.objectType, []).object);

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_connect =
      jniAccessors.getMethodIDOf(_classRef, "connect", "()V");

  /// from: public void connect()
  void connect() => jniAccessors.callMethodWithArgs(
      reference, _id_connect, jni.JniType.voidType, []).check();
}
