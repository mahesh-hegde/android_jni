// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../Tag.dart" as tag_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.nfc.tech.TagTechnology
///
/// TagTechnology is an interface to a technology in a Tag.
///
/// Obtain a TagTechnology implementation by calling the static method <code>get()</code>
/// on the implementation class.
///
/// NFC tags are based on a number of independently developed technologies and offer a
/// wide range of capabilities. The
/// TagTechnology implementations provide access to these different
/// technologies and capabilities. Some sub-classes map to technology
/// specification (for example NfcA, IsoDep, others map to
/// pseudo-technologies or capabilities (for example Ndef, NdefFormatable).
///
/// It is mandatory for all Android NFC devices to provide the following
/// TagTechnology implementations.
/// <ul>
/// <li>NfcA (also known as ISO 14443-3A)
/// <li>NfcB (also known as ISO 14443-3B)
/// <li>NfcF (also known as JIS 6319-4)
/// <li>NfcV (also known as ISO 15693)
/// <li>IsoDep
/// <li>Ndef on NFC Forum Type 1, Type 2, Type 3 or Type 4 compliant tags
/// </ul>
/// It is optional for Android NFC devices to provide the following
/// TagTechnology implementations. If it is not provided, the
/// Android device will never enumerate that class via Tag\#getTechList.
/// <ul>
/// <li>MifareClassic
/// <li>MifareUltralight
/// <li>NfcBarcode
/// <li>NdefFormatable must only be enumerated on tags for which this Android device
/// is capable of formatting. Proprietary knowledge is often required to format a tag
/// to make it NDEF compatible.
/// </ul>
///
/// TagTechnology implementations provide methods that fall into two classes:
/// _cached getters_ and _I/O operations_.
/// <h4>Cached getters</h4>
/// These methods (usually prefixed by <code>get</code> or <code>is</code>) return
/// properties of the tag, as determined at discovery time. These methods will never
/// block or cause RF activity, and do not require \#connect to have been called.
/// They also never update, for example if a property is changed by an I/O operation with a tag
/// then the cached getter will still return the result from tag discovery time.
/// <h4>I/O operations</h4>
/// I/O operations may require RF activity, and may block. They have the following semantics.
/// <ul>
/// <li>\#connect must be called before using any other I/O operation.
/// <li>\#close must be called after completing I/O operations with a
/// TagTechnology, and it will cancel all other blocked I/O operations on other threads
/// (including \#connect with IOException.
/// <li>Only one TagTechnology can be connected at a time. Other calls to
/// \#connect will return IOException.
/// <li>I/O operations may block, and should never be called on the main application
/// thread.
/// </ul>
///
/// <p class="note"><strong>Note:</strong> Methods that perform I/O operations
/// require the android.Manifest.permission\#NFC permission.
class TagTechnology extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/nfc/tech/TagTechnology");
  TagTechnology.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getTag =
      jniAccessors.getMethodIDOf(_classRef, "getTag", "()Landroid/nfc/Tag;");

  /// from: public abstract android.nfc.Tag getTag()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the Tag object backing this TagTechnology object.
  ///@return the Tag backing this TagTechnology object.
  tag_.Tag getTag() => tag_.Tag.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getTag, jni.JniType.objectType, []).object);

  static final _id_connect =
      jniAccessors.getMethodIDOf(_classRef, "connect", "()V");

  /// from: public abstract void connect()
  ///
  /// Enable I/O operations to the tag from this TagTechnology object.
  /// May cause RF activity and may block. Must not be called
  /// from the main application thread. A blocked call will be canceled with
  /// IOException by calling \#close from another thread.
  /// Only one TagTechnology object can be connected to a Tag at a time.
  /// Applications must call \#close when I/O operations are complete.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@see \#close()
  ///@throws TagLostException if the tag leaves the field
  ///@throws IOException if there is an I/O failure, or connect is canceled
  void connect() => jniAccessors.callMethodWithArgs(
      reference, _id_connect, jni.JniType.voidType, []).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public abstract void close()
  ///
  /// Disable I/O operations to the tag from this TagTechnology object, and release resources.
  /// Also causes all blocked I/O operations on other thread to be canceled and
  /// return with IOException.
  ///
  /// <p class="note">Requires the android.Manifest.permission\#NFC permission.
  ///@see \#connect()
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_isConnected =
      jniAccessors.getMethodIDOf(_classRef, "isConnected", "()Z");

  /// from: public abstract boolean isConnected()
  ///
  /// Helper to indicate if I/O operations should be possible.
  ///
  /// Returns true if \#connect has completed, and \#close has not been
  /// called, and the Tag is not known to be out of range.
  /// Does not cause RF activity, and does not block.
  ///@return true if I/O operations should be possible
  bool isConnected() => jniAccessors.callMethodWithArgs(
      reference, _id_isConnected, jni.JniType.booleanType, []).boolean;
}
