// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "NdefRecord.dart" as ndefrecord_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.nfc.NdefMessage
///
/// Represents an immutable NDEF Message.
///
/// NDEF (NFC Data Exchange Format) is a light-weight binary format,
/// used to encapsulate typed data. It is specified by the NFC Forum,
/// for transmission and storage with NFC, however it is transport agnostic.
///
/// NDEF defines messages and records. An NDEF Record contains
/// typed data, such as MIME-type media, a URI, or a custom
/// application payload. An NDEF Message is a container for
/// one or more NDEF Records.
///
/// When an Android device receives an NDEF Message
/// (for example by reading an NFC tag) it processes it through
/// a dispatch mechanism to determine an activity to launch.
/// The type of the _first_ record in the message has
/// special importance for message dispatch, so design this record
/// carefully.
///
/// Use \#NdefMessage(byte[]) to construct an NDEF Message from
/// binary data, or \#NdefMessage(NdefRecord[]) to
/// construct from one or more NdefRecords.
/// <p class="note">
/// NdefMessage and NdefRecord implementations are
/// always available, even on Android devices that do not have NFC hardware.
/// <p class="note">
/// NdefRecords are intended to be immutable (and thread-safe),
/// however they may contain mutable fields. So take care not to modify
/// mutable fields passed into constructors, or modify mutable fields
/// obtained by getter methods, unless such modification is explicitly
/// marked as safe.
///@see NfcAdapter\#ACTION_NDEF_DISCOVERED
///@see NdefRecord
class NdefMessage extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/nfc/NdefMessage");
  NdefMessage.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.nfc.NdefMessage> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "([B)V");

  /// from: public void <init>(byte[] data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct an NDEF Message by parsing raw bytes.
  /// Strict validation of the NDEF binary structure is performed:
  /// there must be at least one record, every record flag must
  /// be correct, and the total length of the message must match
  /// the length of the input data.
  /// This parser can handle chunked records, and converts them
  /// into logical NdefRecords within the message.
  /// Once the input data has been parsed to one or more logical
  /// records, basic validation of the tnf, type, id, and payload fields
  /// of each record is performed, as per the documentation on
  /// on NdefRecord\#NdefRecord(short, byte[], byte[], byte[])
  /// If either strict validation of the binary format fails, or
  /// basic validation during record construction fails, a
  /// FormatException is thrown
  /// Deep inspection of the type, id and payload fields of
  /// each record is not performed, so it is possible to parse input
  /// that has a valid binary format and confirms to the basic
  /// validation requirements of
  /// NdefRecord\#NdefRecord(short, byte[], byte[], byte[]),
  /// but fails more strict requirements as specified by the
  /// NFC Forum.
  ///
  /// <p class="note">
  /// It is safe to re-use the data byte array after construction:
  /// this constructor will make an internal copy of all necessary fields.
  ///@param data raw bytes to parse
  ///@throws FormatException if the data cannot be parsed
  NdefMessage(jni.JniObject data)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [data.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/nfc/NdefRecord;[Landroid/nfc/NdefRecord;)V");

  /// from: public void <init>(android.nfc.NdefRecord record, android.nfc.NdefRecord[] records)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct an NDEF Message from one or more NDEF Records.
  ///@param record first record (mandatory)
  ///@param records additional records (optional)
  NdefMessage.ctor1(ndefrecord_.NdefRecord record, jni.JniObject records)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [record.reference, records.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "([Landroid/nfc/NdefRecord;)V");

  /// from: public void <init>(android.nfc.NdefRecord[] records)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct an NDEF Message from one or more NDEF Records.
  ///@param records one or more records
  NdefMessage.ctor2(jni.JniObject records)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [records.reference]).object);

  static final _id_getRecords = jniAccessors.getMethodIDOf(
      _classRef, "getRecords", "()[Landroid/nfc/NdefRecord;");

  /// from: public android.nfc.NdefRecord[] getRecords()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the NDEF Records inside this NDEF Message.
  /// An NdefMessage always has one or more NDEF Records: so the
  /// following code to retrieve the first record is always safe
  /// (no need to check for null or array length >= 1):
  /// <pre>
  /// NdefRecord firstRecord = ndefMessage.getRecords()[0];
  /// </pre>
  ///@return array of one or more NDEF records.
  jni.JniObject getRecords() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRecords, jni.JniType.objectType, []).object);

  static final _id_getByteArrayLength =
      jniAccessors.getMethodIDOf(_classRef, "getByteArrayLength", "()I");

  /// from: public int getByteArrayLength()
  ///
  /// Return the length of this NDEF Message if it is written to a byte array
  /// with \#toByteArray.
  /// An NDEF Message can be formatted to bytes in different ways
  /// depending on chunking, SR, and ID flags, so the length returned
  /// by this method may not be equal to the length of the original
  /// byte array used to construct this NDEF Message. However it will
  /// always be equal to the length of the byte array produced by
  /// \#toByteArray.
  ///@return length of this NDEF Message when written to bytes with \#toByteArray
  ///@see \#toByteArray
  int getByteArrayLength() => jniAccessors.callMethodWithArgs(
      reference, _id_getByteArrayLength, jni.JniType.intType, []).integer;

  static final _id_toByteArray =
      jniAccessors.getMethodIDOf(_classRef, "toByteArray", "()[B");

  /// from: public byte[] toByteArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return this NDEF Message as raw bytes.
  /// The NDEF Message is formatted as per the NDEF 1.0 specification,
  /// and the byte array is suitable for network transmission or storage
  /// in an NFC Forum NDEF compatible tag.
  /// This method will not chunk any records, and will always use the
  /// short record (SR) format and omit the identifier field when possible.
  ///@return NDEF Message in binary format
  ///@see getByteArrayLength
  jni.JniObject toByteArray() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toByteArray, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// Returns true if the specified NDEF Message contains
  /// identical NDEF Records.
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
