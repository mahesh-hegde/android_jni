// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.telephony.ServiceState
///
/// Contains phone state and service related information.
///
/// The following phone information is included in returned ServiceState:
///
/// <ul>
///   <li>Service state: IN_SERVICE, OUT_OF_SERVICE, EMERGENCY_ONLY, POWER_OFF
///   <li>Duplex mode: UNKNOWN, FDD, TDD
///   <li>Roaming indicator
///   <li>Operator name, short name and numeric id
///   <li>Network selection mode
/// </ul>
class ServiceState extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/telephony/ServiceState");
  ServiceState.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.telephony.ServiceState> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int DUPLEX_MODE_FDD
  ///
  /// Duplex mode for the phone is frequency-division duplexing.
  static const DUPLEX_MODE_FDD = 1;

  /// from: static public final int DUPLEX_MODE_TDD
  ///
  /// Duplex mode for the phone is time-division duplexing.
  static const DUPLEX_MODE_TDD = 2;

  /// from: static public final int DUPLEX_MODE_UNKNOWN
  ///
  /// Duplex mode for the phone is unknown.
  static const DUPLEX_MODE_UNKNOWN = 0;

  /// from: static public final int STATE_EMERGENCY_ONLY
  ///
  /// The phone is registered and locked.  Only emergency numbers are allowed. {@more }
  static const STATE_EMERGENCY_ONLY = 2;

  /// from: static public final int STATE_IN_SERVICE
  ///
  /// Normal operation condition, the phone is registered
  /// with an operator either in home network or in roaming.
  static const STATE_IN_SERVICE = 0;

  /// from: static public final int STATE_OUT_OF_SERVICE
  ///
  /// Phone is not registered with any operator, the phone
  /// can be currently searching a new operator to register to, or not
  /// searching to registration at all, or registration is denied, or radio
  /// signal is not available.
  static const STATE_OUT_OF_SERVICE = 1;

  /// from: static public final int STATE_POWER_OFF
  ///
  /// Radio of telephony is explicitly powered off.
  static const STATE_POWER_OFF = 3;

  /// from: static public final int UNKNOWN_ID
  ///
  /// Unknown ID. Could be returned by \#getCdmaNetworkId() or \#getCdmaSystemId()
  static const UNKNOWN_ID = -1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Empty constructor
  ServiceState()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/telephony/ServiceState;)V");

  /// from: public void <init>(android.telephony.ServiceState s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copy constructors
  ///@param s Source service state
  ServiceState.ctor1(ServiceState s)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [s.reference]).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Parcel;)V");

  /// from: public void <init>(android.os.Parcel in)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a ServiceState object from the given parcel.
  ServiceState.ctor2(parcel_.Parcel in0)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [in0.reference]).object);

  static final _id_copyFrom = jniAccessors.getMethodIDOf(
      _classRef, "copyFrom", "(Landroid/telephony/ServiceState;)V");

  /// from: protected void copyFrom(android.telephony.ServiceState s)
  void copyFrom(ServiceState s) => jniAccessors.callMethodWithArgs(
      reference, _id_copyFrom, jni.JniType.voidType, [s.reference]).check();

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(parcel_.Parcel out, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [out.reference, flags]).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_getState =
      jniAccessors.getMethodIDOf(_classRef, "getState", "()I");

  /// from: public int getState()
  ///
  /// Get current voice service state
  int getState() => jniAccessors.callMethodWithArgs(
      reference, _id_getState, jni.JniType.intType, []).integer;

  static final _id_getDuplexMode =
      jniAccessors.getMethodIDOf(_classRef, "getDuplexMode", "()I");

  /// from: public int getDuplexMode()
  ///
  /// Get the current duplex mode
  ///@see \#DUPLEX_MODE_UNKNOWN
  ///@see \#DUPLEX_MODE_FDD
  ///@see \#DUPLEX_MODE_TDD
  ///@return Current {@code DuplexMode} for the phone
  ///
  /// Value is android.telephony.ServiceState\#DUPLEX_MODE_UNKNOWN, android.telephony.ServiceState\#DUPLEX_MODE_FDD, or android.telephony.ServiceState\#DUPLEX_MODE_TDD
  int getDuplexMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getDuplexMode, jni.JniType.intType, []).integer;

  static final _id_getChannelNumber =
      jniAccessors.getMethodIDOf(_classRef, "getChannelNumber", "()I");

  /// from: public int getChannelNumber()
  ///
  /// Get the channel number of the current primary serving cell, or -1 if unknown
  ///
  /// This is EARFCN for LTE, UARFCN for UMTS, and ARFCN for GSM.
  ///@return Channel number of primary serving cell
  int getChannelNumber() => jniAccessors.callMethodWithArgs(
      reference, _id_getChannelNumber, jni.JniType.intType, []).integer;

  static final _id_getCellBandwidths =
      jniAccessors.getMethodIDOf(_classRef, "getCellBandwidths", "()[I");

  /// from: public int[] getCellBandwidths()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get an array of cell bandwidths (kHz) for the current serving cells
  ///@return Current serving cell bandwidths
  jni.JniObject getCellBandwidths() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCellBandwidths, jni.JniType.objectType, []).object);

  static final _id_getRoaming =
      jniAccessors.getMethodIDOf(_classRef, "getRoaming", "()Z");

  /// from: public boolean getRoaming()
  ///
  /// Get current roaming indicator of phone
  /// (note: not just decoding from TS 27.007 7.2)
  ///@return true if TS 27.007 7.2 roaming is true
  ///              and ONS is different from SPN
  bool getRoaming() => jniAccessors.callMethodWithArgs(
      reference, _id_getRoaming, jni.JniType.booleanType, []).boolean;

  static final _id_getOperatorAlphaLong = jniAccessors.getMethodIDOf(
      _classRef, "getOperatorAlphaLong", "()Ljava/lang/String;");

  /// from: public java.lang.String getOperatorAlphaLong()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get current registered operator name in long alphanumeric format.
  ///
  /// In GSM/UMTS, long format can be up to 16 characters long.
  /// In CDMA, returns the ERI text, if set. Otherwise, returns the ONS.
  ///@return long name of operator, null if unregistered or unknown
  jni.JniString getOperatorAlphaLong() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getOperatorAlphaLong, jni.JniType.objectType, []).object);

  static final _id_getOperatorAlphaShort = jniAccessors.getMethodIDOf(
      _classRef, "getOperatorAlphaShort", "()Ljava/lang/String;");

  /// from: public java.lang.String getOperatorAlphaShort()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get current registered operator name in short alphanumeric format.
  ///
  /// In GSM/UMTS, short format can be up to 8 characters long.
  ///@return short name of operator, null if unregistered or unknown
  jni.JniString getOperatorAlphaShort() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getOperatorAlphaShort, jni.JniType.objectType, []).object);

  static final _id_getOperatorNumeric = jniAccessors.getMethodIDOf(
      _classRef, "getOperatorNumeric", "()Ljava/lang/String;");

  /// from: public java.lang.String getOperatorNumeric()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get current registered operator numeric id.
  ///
  /// In GSM/UMTS, numeric format is 3 digit country code plus 2 or 3 digit
  /// network code.
  ///@return numeric format of operator, null if unregistered or unknown
  jni.JniString getOperatorNumeric() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getOperatorNumeric, jni.JniType.objectType, []).object);

  static final _id_getIsManualSelection =
      jniAccessors.getMethodIDOf(_classRef, "getIsManualSelection", "()Z");

  /// from: public boolean getIsManualSelection()
  ///
  /// Get current network selection mode.
  ///@return true if manual mode, false if automatic mode
  bool getIsManualSelection() => jniAccessors.callMethodWithArgs(
      reference, _id_getIsManualSelection, jni.JniType.booleanType, []).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_setStateOutOfService =
      jniAccessors.getMethodIDOf(_classRef, "setStateOutOfService", "()V");

  /// from: public void setStateOutOfService()
  void setStateOutOfService() => jniAccessors.callMethodWithArgs(
      reference, _id_setStateOutOfService, jni.JniType.voidType, []).check();

  static final _id_setStateOff =
      jniAccessors.getMethodIDOf(_classRef, "setStateOff", "()V");

  /// from: public void setStateOff()
  void setStateOff() => jniAccessors.callMethodWithArgs(
      reference, _id_setStateOff, jni.JniType.voidType, []).check();

  static final _id_setState =
      jniAccessors.getMethodIDOf(_classRef, "setState", "(I)V");

  /// from: public void setState(int state)
  void setState(int state) => jniAccessors.callMethodWithArgs(
      reference, _id_setState, jni.JniType.voidType, [state]).check();

  static final _id_setRoaming =
      jniAccessors.getMethodIDOf(_classRef, "setRoaming", "(Z)V");

  /// from: public void setRoaming(boolean roaming)
  void setRoaming(bool roaming) => jniAccessors.callMethodWithArgs(
      reference, _id_setRoaming, jni.JniType.voidType, [roaming]).check();

  static final _id_setOperatorName = jniAccessors.getMethodIDOf(
      _classRef,
      "setOperatorName",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void setOperatorName(java.lang.String longName, java.lang.String shortName, java.lang.String numeric)
  void setOperatorName(jni.JniString longName, jni.JniString shortName,
          jni.JniString numeric) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOperatorName,
          jni.JniType.voidType,
          [longName.reference, shortName.reference, numeric.reference]).check();

  static final _id_setIsManualSelection =
      jniAccessors.getMethodIDOf(_classRef, "setIsManualSelection", "(Z)V");

  /// from: public void setIsManualSelection(boolean isManual)
  void setIsManualSelection(bool isManual) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setIsManualSelection,
      jni.JniType.voidType,
      [isManual]).check();

  static final _id_getCdmaNetworkId =
      jniAccessors.getMethodIDOf(_classRef, "getCdmaNetworkId", "()I");

  /// from: public int getCdmaNetworkId()
  ///
  /// Get the CDMA NID (Network Identification Number), a number uniquely identifying a network
  /// within a wireless system. (Defined in 3GPP2 C.S0023 3.4.8)
  ///@return The CDMA NID or \#UNKNOWN_ID if not available.
  int getCdmaNetworkId() => jniAccessors.callMethodWithArgs(
      reference, _id_getCdmaNetworkId, jni.JniType.intType, []).integer;

  static final _id_getCdmaSystemId =
      jniAccessors.getMethodIDOf(_classRef, "getCdmaSystemId", "()I");

  /// from: public int getCdmaSystemId()
  ///
  /// Get the CDMA SID (System Identification Number), a number uniquely identifying a wireless
  /// system. (Defined in 3GPP2 C.S0023 3.4.8)
  ///@return The CDMA SID or \#UNKNOWN_ID if not available.
  int getCdmaSystemId() => jniAccessors.callMethodWithArgs(
      reference, _id_getCdmaSystemId, jni.JniType.intType, []).integer;
}
