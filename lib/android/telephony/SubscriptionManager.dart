// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "SubscriptionInfo.dart" as subscriptioninfo_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.telephony.SubscriptionManager
///
/// SubscriptionManager is the application interface to SubscriptionController
/// and provides information about the current Telephony Subscriptions.
class SubscriptionManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/telephony/SubscriptionManager");
  SubscriptionManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED
  ///
  /// Broadcast Action: The default sms subscription has changed.  This has the following
  /// extra values:
  ///
  /// \#EXTRA_SUBSCRIPTION_INDEX extra indicates the current default sms
  /// subscription index
  static const ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED =
      "android.telephony.action.DEFAULT_SMS_SUBSCRIPTION_CHANGED";

  /// from: static public final java.lang.String ACTION_DEFAULT_SUBSCRIPTION_CHANGED
  ///
  /// Broadcast Action: The default subscription has changed.  This has the following
  /// extra values:
  ///
  /// The \#EXTRA_SUBSCRIPTION_INDEX extra indicates the current default subscription index
  static const ACTION_DEFAULT_SUBSCRIPTION_CHANGED =
      "android.telephony.action.DEFAULT_SUBSCRIPTION_CHANGED";

  /// from: static public final java.lang.String ACTION_MANAGE_SUBSCRIPTION_PLANS
  ///
  /// Activity Action: Display UI for managing the billing relationship plans
  /// between a carrier and a specific subscriber.
  ///
  /// Carrier apps are encouraged to implement this activity, and the OS will
  /// provide an affordance to quickly enter this activity, typically via
  /// Settings. This affordance will only be shown when the carrier app is
  /// actively providing subscription plan information via
  /// \#setSubscriptionPlans(int, List).
  ///
  /// Contains \#EXTRA_SUBSCRIPTION_INDEX to indicate which subscription
  /// the user is interested in.
  static const ACTION_MANAGE_SUBSCRIPTION_PLANS =
      "android.telephony.action.MANAGE_SUBSCRIPTION_PLANS";

  /// from: static public final java.lang.String ACTION_REFRESH_SUBSCRIPTION_PLANS
  ///
  /// Broadcast Action: Request a refresh of the billing relationship plans
  /// between a carrier and a specific subscriber.
  ///
  /// Carrier apps are encouraged to implement this receiver, and the OS will
  /// provide an affordance to request a refresh. This affordance will only be
  /// shown when the carrier app is actively providing subscription plan
  /// information via \#setSubscriptionPlans(int, List).
  ///
  /// Contains \#EXTRA_SUBSCRIPTION_INDEX to indicate which subscription
  /// the user is interested in.
  ///
  /// Receivers should protect themselves by checking that the sender holds the
  /// {@code android.permission.MANAGE_SUBSCRIPTION_PLANS} permission.
  static const ACTION_REFRESH_SUBSCRIPTION_PLANS =
      "android.telephony.action.REFRESH_SUBSCRIPTION_PLANS";

  /// from: static public final int DATA_ROAMING_DISABLE
  ///
  /// Indicates that data roaming is disabled for a subscription
  static const DATA_ROAMING_DISABLE = 0;

  /// from: static public final int DATA_ROAMING_ENABLE
  ///
  /// Indicates that data roaming is enabled for a subscription
  static const DATA_ROAMING_ENABLE = 1;

  /// from: static public final java.lang.String EXTRA_SUBSCRIPTION_INDEX
  ///
  /// Integer extra used with \#ACTION_DEFAULT_SUBSCRIPTION_CHANGED and
  /// \#ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED to indicate the subscription
  /// which has changed.
  static const EXTRA_SUBSCRIPTION_INDEX =
      "android.telephony.extra.SUBSCRIPTION_INDEX";

  /// from: static public final int INVALID_SUBSCRIPTION_ID
  ///
  /// An invalid subscription identifier
  static const INVALID_SUBSCRIPTION_ID = -1;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  SubscriptionManager(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_from = jniAccessors.getStaticMethodIDOf(_classRef, "from",
      "(Landroid/content/Context;)Landroid/telephony/SubscriptionManager;");

  /// from: static public android.telephony.SubscriptionManager from(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated developers should always obtain references directly from
  ///             Context\#getSystemService(Class).
  static SubscriptionManager from(context_.Context context) =>
      SubscriptionManager.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_from,
          jni.JniType.objectType,
          [context.reference]).object);

  static final _id_addOnSubscriptionsChangedListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addOnSubscriptionsChangedListener",
      "(Landroid/telephony/SubscriptionManager\$OnSubscriptionsChangedListener;)V");

  /// from: public void addOnSubscriptionsChangedListener(android.telephony.SubscriptionManager.OnSubscriptionsChangedListener listener)
  ///
  /// Register for changes to the list of active SubscriptionInfo records or to the
  /// individual records themselves. When a change occurs the onSubscriptionsChanged method of
  /// the listener will be invoked immediately if there has been a notification.
  ///@param listener an instance of OnSubscriptionsChangedListener with
  ///                 onSubscriptionsChanged overridden.
  void addOnSubscriptionsChangedListener(
          SubscriptionManager_OnSubscriptionsChangedListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOnSubscriptionsChangedListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_removeOnSubscriptionsChangedListener =
      jniAccessors.getMethodIDOf(
          _classRef,
          "removeOnSubscriptionsChangedListener",
          "(Landroid/telephony/SubscriptionManager\$OnSubscriptionsChangedListener;)V");

  /// from: public void removeOnSubscriptionsChangedListener(android.telephony.SubscriptionManager.OnSubscriptionsChangedListener listener)
  ///
  /// Unregister the OnSubscriptionsChangedListener. This is not strictly necessary
  /// as the listener will automatically be unregistered if an attempt to invoke the listener
  /// fails.
  ///@param listener that is to be unregistered.
  void removeOnSubscriptionsChangedListener(
          SubscriptionManager_OnSubscriptionsChangedListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeOnSubscriptionsChangedListener,
          jni.JniType.voidType,
          [listener.reference]).check();

  static final _id_getActiveSubscriptionInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getActiveSubscriptionInfo",
      "(I)Landroid/telephony/SubscriptionInfo;");

  /// from: public android.telephony.SubscriptionInfo getActiveSubscriptionInfo(int subId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the active SubscriptionInfo with the input subId.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see
  /// TelephonyManager\#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@param subId The unique SubscriptionInfo key in database.
  ///@return SubscriptionInfo, maybe null if its not active.
  subscriptioninfo_.SubscriptionInfo getActiveSubscriptionInfo(int subId) =>
      subscriptioninfo_.SubscriptionInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getActiveSubscriptionInfo,
              jni.JniType.objectType, [subId]).object);

  static final _id_getActiveSubscriptionInfoForSimSlotIndex =
      jniAccessors.getMethodIDOf(
          _classRef,
          "getActiveSubscriptionInfoForSimSlotIndex",
          "(I)Landroid/telephony/SubscriptionInfo;");

  /// from: public android.telephony.SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the active SubscriptionInfo associated with the slotIndex
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see
  /// TelephonyManager\#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@param slotIndex the slot which the subscription is inserted
  ///@return SubscriptionInfo, maybe null if its not active
  subscriptioninfo_.SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(
          int slotIndex) =>
      subscriptioninfo_.SubscriptionInfo.fromRef(jniAccessors
          .callMethodWithArgs(
              reference,
              _id_getActiveSubscriptionInfoForSimSlotIndex,
              jni.JniType.objectType,
              [slotIndex]).object);

  static final _id_getActiveSubscriptionInfoList = jniAccessors.getMethodIDOf(
      _classRef, "getActiveSubscriptionInfoList", "()Ljava/util/List;");

  /// from: public java.util.List<android.telephony.SubscriptionInfo> getActiveSubscriptionInfoList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the SubscriptionInfo(s) of the currently inserted SIM(s). The records will be sorted
  /// by SubscriptionInfo\#getSimSlotIndex then by SubscriptionInfo\#getSubscriptionId.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see
  /// TelephonyManager\#hasCarrierPrivileges). In the latter case, only records accessible
  /// to the calling app are returned.
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@return Sorted list of the currently SubscriptionInfo records available on the device.
  /// <ul>
  /// <li>
  /// If null is returned the current state is unknown but if a OnSubscriptionsChangedListener
  /// has been registered OnSubscriptionsChangedListener\#onSubscriptionsChanged will be
  /// invoked in the future.
  /// </li>
  /// <li>
  /// If the list is empty then there are no SubscriptionInfo records currently available.
  /// </li>
  /// <li>
  /// if the list is non-empty the list is sorted by SubscriptionInfo\#getSimSlotIndex
  /// then by SubscriptionInfo\#getSubscriptionId.
  /// </li>
  /// </ul>
  jni.JniObject getActiveSubscriptionInfoList() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getActiveSubscriptionInfoList,
          jni.JniType.objectType, []).object);

  static final _id_getAccessibleSubscriptionInfoList =
      jniAccessors.getMethodIDOf(
          _classRef, "getAccessibleSubscriptionInfoList", "()Ljava/util/List;");

  /// from: public java.util.List<android.telephony.SubscriptionInfo> getAccessibleSubscriptionInfoList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the SubscriptionInfo(s) of all embedded subscriptions accessible to the calling app, if
  /// any.
  ///
  /// Only those subscriptions for which the calling app has carrier privileges per the
  /// subscription metadata, if any, will be included in the returned list.
  ///
  /// The records will be sorted by SubscriptionInfo\#getSimSlotIndex then by
  /// SubscriptionInfo\#getSubscriptionId.
  ///@return Sorted list of the current embedded SubscriptionInfo records available on the
  /// device which are accessible to the caller.
  /// <ul>
  /// <li>
  /// If null is returned the current state is unknown but if a
  /// OnSubscriptionsChangedListener has been registered
  /// OnSubscriptionsChangedListener\#onSubscriptionsChanged will be invoked in the future.
  /// <li>
  /// If the list is empty then there are no SubscriptionInfo records currently available.
  /// <li>
  /// if the list is non-empty the list is sorted by SubscriptionInfo\#getSimSlotIndex
  /// then by SubscriptionInfo\#getSubscriptionId.
  /// </ul>
  jni.JniObject getAccessibleSubscriptionInfoList() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAccessibleSubscriptionInfoList,
          jni.JniType.objectType, []).object);

  static final _id_getActiveSubscriptionInfoCount = jniAccessors.getMethodIDOf(
      _classRef, "getActiveSubscriptionInfoCount", "()I");

  /// from: public int getActiveSubscriptionInfoCount()
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see
  /// TelephonyManager\#hasCarrierPrivileges). In the latter case, the count will include
  /// only those subscriptions accessible to the caller.
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@return the current number of active subscriptions. There is no guarantee the value
  /// returned by this method will be the same as the length of the list returned by
  /// \#getActiveSubscriptionInfoList.
  int getActiveSubscriptionInfoCount() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getActiveSubscriptionInfoCount,
      jni.JniType.intType, []).integer;

  static final _id_getActiveSubscriptionInfoCountMax = jniAccessors
      .getMethodIDOf(_classRef, "getActiveSubscriptionInfoCountMax", "()I");

  /// from: public int getActiveSubscriptionInfoCountMax()
  ///
  /// @return the maximum number of active subscriptions that will be returned by
  /// \#getActiveSubscriptionInfoList and the value returned by
  /// \#getActiveSubscriptionInfoCount.
  int getActiveSubscriptionInfoCountMax() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getActiveSubscriptionInfoCountMax,
      jni.JniType.intType, []).integer;

  static final _id_getDefaultSubscriptionId = jniAccessors.getStaticMethodIDOf(
      _classRef, "getDefaultSubscriptionId", "()I");

  /// from: static public int getDefaultSubscriptionId()
  ///
  /// Returns the system's default subscription id.
  ///
  /// For a voice capable device, it will return getDefaultVoiceSubscriptionId.
  /// For a data only device, it will return the getDefaultDataSubscriptionId.
  /// May return an INVALID_SUBSCRIPTION_ID on error.
  ///@return the "system" default subscription id.
  static int getDefaultSubscriptionId() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getDefaultSubscriptionId, jni.JniType.intType, []).integer;

  static final _id_getDefaultVoiceSubscriptionId = jniAccessors
      .getStaticMethodIDOf(_classRef, "getDefaultVoiceSubscriptionId", "()I");

  /// from: static public int getDefaultVoiceSubscriptionId()
  ///
  /// Returns the system's default voice subscription id.
  ///
  /// On a data only device or on error, will return INVALID_SUBSCRIPTION_ID.
  ///@return the default voice subscription Id.
  static int getDefaultVoiceSubscriptionId() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getDefaultVoiceSubscriptionId, jni.JniType.intType, []).integer;

  static final _id_getDefaultSmsSubscriptionId = jniAccessors
      .getStaticMethodIDOf(_classRef, "getDefaultSmsSubscriptionId", "()I");

  /// from: static public int getDefaultSmsSubscriptionId()
  ///
  /// Returns the system's default SMS subscription id.
  ///
  /// On a data only device or on error, will return INVALID_SUBSCRIPTION_ID.
  ///@return the default SMS subscription Id.
  static int getDefaultSmsSubscriptionId() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getDefaultSmsSubscriptionId, jni.JniType.intType, []).integer;

  static final _id_getDefaultDataSubscriptionId = jniAccessors
      .getStaticMethodIDOf(_classRef, "getDefaultDataSubscriptionId", "()I");

  /// from: static public int getDefaultDataSubscriptionId()
  ///
  /// Returns the system's default data subscription id.
  ///
  /// On a voice only device or on error, will return INVALID_SUBSCRIPTION_ID.
  ///@return the default data subscription Id.
  static int getDefaultDataSubscriptionId() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getDefaultDataSubscriptionId, jni.JniType.intType, []).integer;

  static final _id_isNetworkRoaming =
      jniAccessors.getMethodIDOf(_classRef, "isNetworkRoaming", "(I)Z");

  /// from: public boolean isNetworkRoaming(int subId)
  ///
  /// Returns true if the device is considered roaming on the current
  /// network for a subscription.
  ///
  /// Availability: Only when user registered to a network.
  ///@param subId The subscription ID
  ///@return true if the network for the subscription is roaming, false otherwise
  bool isNetworkRoaming(int subId) => jniAccessors.callMethodWithArgs(reference,
      _id_isNetworkRoaming, jni.JniType.booleanType, [subId]).boolean;

  static final _id_getSubscriptionPlans = jniAccessors.getMethodIDOf(
      _classRef, "getSubscriptionPlans", "(I)Ljava/util/List;");

  /// from: public java.util.List<android.telephony.SubscriptionPlan> getSubscriptionPlans(int subId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the description of the billing relationship plan between a carrier
  /// and a specific subscriber.
  ///
  /// This method is only accessible to the following narrow set of apps:
  /// <ul>
  /// <li>The carrier app for this subscriberId, as determined by
  /// TelephonyManager\#hasCarrierPrivileges().
  /// <li>The carrier app explicitly delegated access through
  /// CarrierConfigManager\#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING.
  /// </ul>
  ///@param subId the subscriber this relationship applies to
  ///@throws SecurityException if the caller doesn't meet the requirements
  ///             outlined above.
  ///@return This value will never be {@code null}.
  jni.JniObject getSubscriptionPlans(int subId) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSubscriptionPlans, jni.JniType.objectType, [subId]).object);

  static final _id_setSubscriptionPlans = jniAccessors.getMethodIDOf(
      _classRef, "setSubscriptionPlans", "(ILjava/util/List;)V");

  /// from: public void setSubscriptionPlans(int subId, java.util.List<android.telephony.SubscriptionPlan> plans)
  ///
  /// Set the description of the billing relationship plan between a carrier
  /// and a specific subscriber.
  ///
  /// This method is only accessible to the following narrow set of apps:
  /// <ul>
  /// <li>The carrier app for this subscriberId, as determined by
  /// TelephonyManager\#hasCarrierPrivileges().
  /// <li>The carrier app explicitly delegated access through
  /// CarrierConfigManager\#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING.
  /// </ul>
  ///@param subId the subscriber this relationship applies to. An empty list
  ///            may be sent to clear any existing plans.
  ///@param plans the list of plans. The first plan is always the primary and
  ///            most important plan. Any additional plans are secondary and
  ///            may not be displayed or used by decision making logic.
  /// This value must never be {@code null}.
  ///@throws SecurityException if the caller doesn't meet the requirements
  ///             outlined above.
  void setSubscriptionPlans(int subId, jni.JniObject plans) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSubscriptionPlans,
          jni.JniType.voidType, [subId, plans.reference]).check();

  static final _id_setSubscriptionOverrideUnmetered = jniAccessors
      .getMethodIDOf(_classRef, "setSubscriptionOverrideUnmetered", "(IZJ)V");

  /// from: public void setSubscriptionOverrideUnmetered(int subId, boolean overrideUnmetered, long timeoutMillis)
  ///
  /// Temporarily override the billing relationship plan between a carrier and
  /// a specific subscriber to be considered unmetered. This will be reflected
  /// to apps via NetworkCapabilities\#NET_CAPABILITY_NOT_METERED.
  ///
  /// This method is only accessible to the following narrow set of apps:
  /// <ul>
  /// <li>The carrier app for this subscriberId, as determined by
  /// TelephonyManager\#hasCarrierPrivileges().
  /// <li>The carrier app explicitly delegated access through
  /// CarrierConfigManager\#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING.
  /// </ul>
  ///@param subId the subscriber this override applies to.
  ///@param overrideUnmetered set if the billing relationship should be
  ///            considered unmetered.
  ///@param timeoutMillis the timeout after which the requested override will
  ///            be automatically cleared, or {@code 0} to leave in the
  ///            requested state until explicitly cleared, or the next reboot,
  ///            whichever happens first.
  /// Value is a non-negative duration in milliseconds.
  ///@throws SecurityException if the caller doesn't meet the requirements
  ///             outlined above.
  void setSubscriptionOverrideUnmetered(
          int subId, bool overrideUnmetered, int timeoutMillis) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSubscriptionOverrideUnmetered,
          jni.JniType.voidType,
          [subId, overrideUnmetered, timeoutMillis]).check();

  static final _id_setSubscriptionOverrideCongested = jniAccessors
      .getMethodIDOf(_classRef, "setSubscriptionOverrideCongested", "(IZJ)V");

  /// from: public void setSubscriptionOverrideCongested(int subId, boolean overrideCongested, long timeoutMillis)
  ///
  /// Temporarily override the billing relationship plan between a carrier and
  /// a specific subscriber to be considered congested. This will cause the
  /// device to delay certain network requests when possible, such as developer
  /// jobs that are willing to run in a flexible time window.
  ///
  /// This method is only accessible to the following narrow set of apps:
  /// <ul>
  /// <li>The carrier app for this subscriberId, as determined by
  /// TelephonyManager\#hasCarrierPrivileges().
  /// <li>The carrier app explicitly delegated access through
  /// CarrierConfigManager\#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING.
  /// </ul>
  ///@param subId the subscriber this override applies to.
  ///@param overrideCongested set if the subscription should be considered
  ///            congested.
  ///@param timeoutMillis the timeout after which the requested override will
  ///            be automatically cleared, or {@code 0} to leave in the
  ///            requested state until explicitly cleared, or the next reboot,
  ///            whichever happens first.
  /// Value is a non-negative duration in milliseconds.
  ///@throws SecurityException if the caller doesn't meet the requirements
  ///             outlined above.
  void setSubscriptionOverrideCongested(
          int subId, bool overrideCongested, int timeoutMillis) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSubscriptionOverrideCongested,
          jni.JniType.voidType,
          [subId, overrideCongested, timeoutMillis]).check();

  static final _id_canManageSubscription = jniAccessors.getMethodIDOf(_classRef,
      "canManageSubscription", "(Landroid/telephony/SubscriptionInfo;)Z");

  /// from: public boolean canManageSubscription(android.telephony.SubscriptionInfo info)
  ///
  /// Checks whether the app with the given context is authorized to manage the given subscription
  /// according to its metadata. Only supported for embedded subscriptions (if
  /// {@code SubscriptionInfo\#isEmbedded} returns true).
  ///@param info The subscription to check.
  ///@return whether the app is authorized to manage this subscription per its metadata.
  ///@throws IllegalArgumentException if this subscription is not embedded.
  bool canManageSubscription(subscriptioninfo_.SubscriptionInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_canManageSubscription,
          jni.JniType.booleanType, [info.reference]).boolean;
}

/// from: android.telephony.SubscriptionManager$OnSubscriptionsChangedListener
///
/// A listener class for monitoring changes to SubscriptionInfo records.
///
/// Override the onSubscriptionsChanged method in the object that extends this
/// class and pass it to \#addOnSubscriptionsChangedListener(OnSubscriptionsChangedListener)
/// to register your listener and to unregister invoke
/// \#removeOnSubscriptionsChangedListener(OnSubscriptionsChangedListener)
///
/// Permissions android.Manifest.permission.READ_PHONE_STATE is required
/// for \#onSubscriptionsChanged to be invoked.
class SubscriptionManager_OnSubscriptionsChangedListener extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/telephony/SubscriptionManager\$OnSubscriptionsChangedListener");
  SubscriptionManager_OnSubscriptionsChangedListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  SubscriptionManager_OnSubscriptionsChangedListener()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onSubscriptionsChanged =
      jniAccessors.getMethodIDOf(_classRef, "onSubscriptionsChanged", "()V");

  /// from: public void onSubscriptionsChanged()
  ///
  /// Callback invoked when there is any change to any SubscriptionInfo. Typically
  /// this method would invoke \#getActiveSubscriptionInfoList
  void onSubscriptionsChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_onSubscriptionsChanged, jni.JniType.voidType, []).check();
}
