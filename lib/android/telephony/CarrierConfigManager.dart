// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/PersistableBundle.dart" as persistablebundle_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.telephony.CarrierConfigManager
///
/// Provides access to telephony configuration values that are carrier-specific.
class CarrierConfigManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/telephony/CarrierConfigManager");
  CarrierConfigManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_CARRIER_CONFIG_CHANGED
  ///
  /// This intent is broadcast by the system when carrier config changes. An int is specified in
  /// \#EXTRA_SLOT_INDEX to indicate the slot index that this is for. An optional int extra
  /// \#EXTRA_SUBSCRIPTION_INDEX is included to indicate the subscription index if a valid
  /// one is available for the slot index.
  static const ACTION_CARRIER_CONFIG_CHANGED =
      "android.telephony.action.CARRIER_CONFIG_CHANGED";

  /// from: static public final int DATA_CYCLE_THRESHOLD_DISABLED
  ///
  /// Flag indicating that a data cycle threshold should be disabled.
  ///
  /// If \#KEY_DATA_WARNING_THRESHOLD_BYTES_LONG is set to this value, the platform's
  /// default data warning, if one exists, will be disabled. A user selected data warning will not
  /// be overridden.
  ///
  /// If \#KEY_DATA_LIMIT_THRESHOLD_BYTES_LONG is set to this value, the platform's
  /// default data limit, if one exists, will be disabled. A user selected data limit will not be
  /// overridden.
  static const DATA_CYCLE_THRESHOLD_DISABLED = -2;

  /// from: static public final java.lang.String EXTRA_SLOT_INDEX
  ///
  /// Extra included in \#ACTION_CARRIER_CONFIG_CHANGED to indicate the slot index that the
  /// broadcast is for.
  static const EXTRA_SLOT_INDEX = "android.telephony.extra.SLOT_INDEX";

  /// from: static public final java.lang.String EXTRA_SUBSCRIPTION_INDEX
  ///
  /// Optional extra included in \#ACTION_CARRIER_CONFIG_CHANGED to indicate the
  /// subscription index that the broadcast is for, if a valid one is available.
  static const EXTRA_SUBSCRIPTION_INDEX =
      "android.telephony.extra.SUBSCRIPTION_INDEX";

  /// from: static public final java.lang.String KEY_ADDITIONAL_CALL_SETTING_BOOL
  ///
  /// Does not display additional call setting for IMS phone based on GSM Phone
  static const KEY_ADDITIONAL_CALL_SETTING_BOOL =
      "additional_call_setting_bool";

  /// from: static public final java.lang.String KEY_ALLOW_ADDING_APNS_BOOL
  ///
  /// Allow user to add APNs
  static const KEY_ALLOW_ADDING_APNS_BOOL = "allow_adding_apns_bool";

  /// from: static public final java.lang.String KEY_ALLOW_ADD_CALL_DURING_VIDEO_CALL_BOOL
  ///
  /// When true, indicates that adding a call is disabled when there is an ongoing video call
  /// or when there is an ongoing call on wifi which was downgraded from video and VoWifi is
  /// turned off.
  static const KEY_ALLOW_ADD_CALL_DURING_VIDEO_CALL_BOOL =
      "allow_add_call_during_video_call";

  /// from: static public final java.lang.String KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL
  ///
  /// Determines if the current device should allow emergency numbers to be logged in the Call Log.
  /// (Some carriers require that emergency calls *not* be logged, presumably to avoid the risk of
  /// accidental redialing from the call log UI. This is a good idea, so the default here is
  /// false.)
  static const KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL =
      "allow_emergency_numbers_in_call_log_bool";

  /// from: static public final java.lang.String KEY_ALLOW_EMERGENCY_VIDEO_CALLS_BOOL
  ///
  /// Flag indicating whether to allow carrier video calls to emergency numbers.
  /// When {@code true}, video calls to emergency numbers will be allowed.  When {@code false},
  /// video calls to emergency numbers will be initiated as audio-only calls instead.
  static const KEY_ALLOW_EMERGENCY_VIDEO_CALLS_BOOL =
      "allow_emergency_video_calls_bool";

  /// from: static public final java.lang.String KEY_ALLOW_LOCAL_DTMF_TONES_BOOL
  ///
  /// Determine whether we want to play local DTMF tones in a call, or just let the radio/BP handle
  /// playing of the tones.
  static const KEY_ALLOW_LOCAL_DTMF_TONES_BOOL = "allow_local_dtmf_tones_bool";

  /// from: static public final java.lang.String KEY_ALLOW_MERGE_WIFI_CALLS_WHEN_VOWIFI_OFF_BOOL
  ///
  /// Flag indicating whether the carrier supports merging wifi calls when VoWIFI is disabled.
  /// This can happen in the case of a carrier which allows offloading video calls to WIFI
  /// separately of whether voice over wifi is enabled.  In such a scenario when two video calls
  /// are downgraded to voice, they remain over wifi.  However, if VoWIFI is disabled, these calls
  /// cannot be merged.
  static const KEY_ALLOW_MERGE_WIFI_CALLS_WHEN_VOWIFI_OFF_BOOL =
      "allow_merge_wifi_calls_when_vowifi_off_bool";

  /// from: static public final java.lang.String KEY_ALLOW_NON_EMERGENCY_CALLS_IN_ECM_BOOL
  ///
  /// Determines whether the carrier supports making non-emergency phone calls while the phone is
  /// in emergency callback mode.  Default value is {@code true}, meaning that non-emergency calls
  /// are allowed in emergency callback mode.
  static const KEY_ALLOW_NON_EMERGENCY_CALLS_IN_ECM_BOOL =
      "allow_non_emergency_calls_in_ecm_bool";

  /// from: static public final java.lang.String KEY_ALWAYS_SHOW_EMERGENCY_ALERT_ONOFF_BOOL
  ///
  /// The default flag specifying whether "Turn on Notifications" option will be always shown in
  /// Settings->More->Emergency broadcasts menu regardless developer options is turned on or not.
  static const KEY_ALWAYS_SHOW_EMERGENCY_ALERT_ONOFF_BOOL =
      "always_show_emergency_alert_onoff_bool";

  /// from: static public final java.lang.String KEY_APN_EXPAND_BOOL
  ///
  /// Control whether users can edit APNs in Settings.
  static const KEY_APN_EXPAND_BOOL = "apn_expand_bool";

  /// from: static public final java.lang.String KEY_AUTO_RETRY_ENABLED_BOOL
  ///
  /// Flag indicating if auto retry is enabled
  static const KEY_AUTO_RETRY_ENABLED_BOOL = "auto_retry_enabled_bool";

  /// from: static public final java.lang.String KEY_CALL_FORWARDING_BLOCKS_WHILE_ROAMING_STRING_ARRAY
  ///
  /// An array containing custom call forwarding number prefixes that will be blocked while the
  /// device is reporting that it is roaming. By default, there are no custom call
  /// forwarding prefixes and none of these numbers will be filtered. If one or more entries are
  /// present, the system will not complete the call and display an error message.
  ///
  /// To display a message to the user when call forwarding fails for 3gpp MMI codes while roaming,
  /// use the \#KEY_SUPPORT_3GPP_CALL_FORWARDING_WHILE_ROAMING_BOOL option instead.
  static const KEY_CALL_FORWARDING_BLOCKS_WHILE_ROAMING_STRING_ARRAY =
      "call_forwarding_blocks_while_roaming_string_array";

  /// from: static public final java.lang.String KEY_CARRIER_ALLOW_TURNOFF_IMS_BOOL
  ///
  /// Flag specifying whether IMS service can be turned off. If false then the service will not be
  /// turned-off completely, but individual features can be disabled.
  static const KEY_CARRIER_ALLOW_TURNOFF_IMS_BOOL =
      "carrier_allow_turnoff_ims_bool";

  /// from: static public final java.lang.String KEY_CARRIER_DATA_CALL_PERMANENT_FAILURE_STRINGS
  ///
  /// Data call setup permanent failure causes by the carrier
  static const KEY_CARRIER_DATA_CALL_PERMANENT_FAILURE_STRINGS =
      "carrier_data_call_permanent_failure_strings";

  /// from: static public final java.lang.String KEY_CARRIER_FORCE_DISABLE_ETWS_CMAS_TEST_BOOL
  ///
  /// The default flag specifying whether ETWS/CMAS test setting is forcibly disabled in
  /// Settings->More->Emergency broadcasts menu even though developer options is turned on.
  static const KEY_CARRIER_FORCE_DISABLE_ETWS_CMAS_TEST_BOOL =
      "carrier_force_disable_etws_cmas_test_bool";

  /// from: static public final java.lang.String KEY_CARRIER_IMS_GBA_REQUIRED_BOOL
  ///
  /// Flag specifying whether Generic Bootstrapping Architecture capable SIM is required for IMS.
  static const KEY_CARRIER_IMS_GBA_REQUIRED_BOOL =
      "carrier_ims_gba_required_bool";

  /// from: static public final java.lang.String KEY_CARRIER_INSTANT_LETTERING_AVAILABLE_BOOL
  ///
  /// Flag specifying whether IMS instant lettering is available for the carrier.  {@code True} if
  /// instant lettering is available for the carrier, {@code false} otherwise.
  static const KEY_CARRIER_INSTANT_LETTERING_AVAILABLE_BOOL =
      "carrier_instant_lettering_available_bool";

  /// from: static public final java.lang.String KEY_CARRIER_INSTANT_LETTERING_ENCODING_STRING
  ///
  /// When IMS instant lettering is available for a carrier (see
  /// \#KEY_CARRIER_INSTANT_LETTERING_AVAILABLE_BOOL), determines the character encoding
  /// which will be used when determining the length of messages.  Used in the InCall UI to limit
  /// the number of characters the user may type.  If empty-string, the instant lettering
  /// message size limit will be enforced on a 1:1 basis.  That is, each character will count
  /// towards the messages size limit as a single bye.  If a character encoding is specified, the
  /// message size limit will be based on the number of bytes in the message per the specified
  /// encoding.
  static const KEY_CARRIER_INSTANT_LETTERING_ENCODING_STRING =
      "carrier_instant_lettering_encoding_string";

  /// from: static public final java.lang.String KEY_CARRIER_INSTANT_LETTERING_ESCAPED_CHARS_STRING
  ///
  /// When IMS instant lettering is available for a carrier (see
  /// \#KEY_CARRIER_INSTANT_LETTERING_AVAILABLE_BOOL), determines a list of characters which
  /// must be escaped with a backslash '\' character.  Should be specified as a string containing
  /// the characters to be escaped.  For example to escape quote and backslash the string would be
  /// a quote and a backslash.
  static const KEY_CARRIER_INSTANT_LETTERING_ESCAPED_CHARS_STRING =
      "carrier_instant_lettering_escaped_chars_string";

  /// from: static public final java.lang.String KEY_CARRIER_INSTANT_LETTERING_INVALID_CHARS_STRING
  ///
  /// When IMS instant lettering is available for a carrier (see
  /// \#KEY_CARRIER_INSTANT_LETTERING_AVAILABLE_BOOL), determines the list of characters
  /// which may not be contained in messages.  Should be specified as a regular expression suitable
  /// for use with String\#matches(String).
  static const KEY_CARRIER_INSTANT_LETTERING_INVALID_CHARS_STRING =
      "carrier_instant_lettering_invalid_chars_string";

  /// from: static public final java.lang.String KEY_CARRIER_INSTANT_LETTERING_LENGTH_LIMIT_INT
  ///
  /// When IMS instant lettering is available for a carrier (see
  /// \#KEY_CARRIER_INSTANT_LETTERING_AVAILABLE_BOOL), the length limit for messages.  Used
  /// in the InCall UI to ensure the user cannot enter more characters than allowed by the carrier.
  /// See also \#KEY_CARRIER_INSTANT_LETTERING_ENCODING_STRING for more information on how
  /// the length of the message is calculated.
  static const KEY_CARRIER_INSTANT_LETTERING_LENGTH_LIMIT_INT =
      "carrier_instant_lettering_length_limit_int";

  /// from: static public final java.lang.String KEY_CARRIER_NAME_OVERRIDE_BOOL
  ///
  /// Unconditionally override the carrier name string using \#KEY_CARRIER_NAME_STRING.
  ///
  /// If true, then the carrier name string will be \#KEY_CARRIER_NAME_STRING, unconditionally.
  ///
  /// If false, then the override will be performed conditionally and the
  /// \#KEY_CARRIER_NAME_STRING will have the lowest-precedence; it will only be used in the event
  /// that the name string would otherwise be empty, allowing it to serve as a last-resort. If
  /// used, this value functions in place of the SPN on any/all ICC records for the corresponding
  /// subscription.
  static const KEY_CARRIER_NAME_OVERRIDE_BOOL = "carrier_name_override_bool";

  /// from: static public final java.lang.String KEY_CARRIER_NAME_STRING
  ///
  /// String to identify carrier name in CarrierConfig app. This string overrides SPN if
  /// \#KEY_CARRIER_NAME_OVERRIDE_BOOL is true; otherwise, it will be used if its value is provided
  /// and SPN is unavailable
  static const KEY_CARRIER_NAME_STRING = "carrier_name_string";

  /// from: static public final java.lang.String KEY_CARRIER_SETTINGS_ENABLE_BOOL
  ///
  /// Display carrier settings menu if true
  static const KEY_CARRIER_SETTINGS_ENABLE_BOOL =
      "carrier_settings_enable_bool";

  /// from: static public final java.lang.String KEY_CARRIER_USE_IMS_FIRST_FOR_EMERGENCY_BOOL
  static const KEY_CARRIER_USE_IMS_FIRST_FOR_EMERGENCY_BOOL =
      "carrier_use_ims_first_for_emergency_bool";

  /// from: static public final java.lang.String KEY_CARRIER_VOLTE_AVAILABLE_BOOL
  ///
  /// Flag specifying whether VoLTE should be available for carrier, independent of carrier
  /// provisioning. If false: hard disabled. If true: then depends on carrier provisioning,
  /// availability, etc.
  static const KEY_CARRIER_VOLTE_AVAILABLE_BOOL =
      "carrier_volte_available_bool";

  /// from: static public final java.lang.String KEY_CARRIER_VOLTE_PROVISIONED_BOOL
  ///
  /// This flag specifies whether VoLTE availability is based on provisioning. By default this is
  /// false.
  static const KEY_CARRIER_VOLTE_PROVISIONED_BOOL =
      "carrier_volte_provisioned_bool";

  /// from: static public final java.lang.String KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL
  ///
  /// Flag specifying whether provisioning is required for VOLTE.
  static const KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL =
      "carrier_volte_provisioning_required_bool";

  /// from: static public final java.lang.String KEY_CARRIER_VOLTE_TTY_SUPPORTED_BOOL
  ///
  /// Flag specifying whether VoLTE TTY is supported.
  static const KEY_CARRIER_VOLTE_TTY_SUPPORTED_BOOL =
      "carrier_volte_tty_supported_bool";

  /// from: static public final java.lang.String KEY_CARRIER_VT_AVAILABLE_BOOL
  ///
  /// Flag specifying whether video telephony is available for carrier. If false: hard disabled.
  /// If true: then depends on carrier provisioning, availability, etc.
  static const KEY_CARRIER_VT_AVAILABLE_BOOL = "carrier_vt_available_bool";

  /// from: static public final java.lang.String KEY_CARRIER_VVM_PACKAGE_NAME_STRING
  ///
  /// The package name of the carrier's visual voicemail app to ensure that dialer visual voicemail
  /// and carrier visual voicemail are not active at the same time.
  ///@deprecated use \#KEY_CARRIER_VVM_PACKAGE_NAME_STRING_ARRAY.
  static const KEY_CARRIER_VVM_PACKAGE_NAME_STRING =
      "carrier_vvm_package_name_string";

  /// from: static public final java.lang.String KEY_CARRIER_VVM_PACKAGE_NAME_STRING_ARRAY
  ///
  /// A list of the carrier's visual voicemail app package names to ensure that dialer visual
  /// voicemail and carrier visual voicemail are not active at the same time.
  static const KEY_CARRIER_VVM_PACKAGE_NAME_STRING_ARRAY =
      "carrier_vvm_package_name_string_array";

  /// from: static public final java.lang.String KEY_CARRIER_WFC_IMS_AVAILABLE_BOOL
  ///
  /// Flag specifying whether WFC over IMS should be available for carrier: independent of
  /// carrier provisioning. If false: hard disabled. If true: then depends on carrier
  /// provisioning, availability etc.
  static const KEY_CARRIER_WFC_IMS_AVAILABLE_BOOL =
      "carrier_wfc_ims_available_bool";

  /// from: static public final java.lang.String KEY_CARRIER_WFC_SUPPORTS_WIFI_ONLY_BOOL
  ///
  /// Flag specifying whether WFC over IMS supports the "wifi only" option.  If false, the wifi
  /// calling settings will not include an option for "wifi only".  If true, the wifi calling
  /// settings will include an option for "wifi only"
  ///
  /// By default, it is assumed that WFC supports "wifi only".
  static const KEY_CARRIER_WFC_SUPPORTS_WIFI_ONLY_BOOL =
      "carrier_wfc_supports_wifi_only_bool";

  /// from: static public final java.lang.String KEY_CDMA_3WAYCALL_FLASH_DELAY_INT
  ///
  /// For carriers which require an empty flash to be sent before sending the normal 3-way calling
  /// flash, the duration in milliseconds of the empty flash to send.  When {@code 0}, no empty
  /// flash is sent.
  static const KEY_CDMA_3WAYCALL_FLASH_DELAY_INT =
      "cdma_3waycall_flash_delay_int";

  /// from: static public final java.lang.String KEY_CDMA_DTMF_TONE_DELAY_INT
  ///
  /// Specifies the amount of gap to be added in millis between postdial DTMF tones. When a
  /// non-zero value is specified, the UE shall wait for the specified amount of time before it
  /// sends out successive DTMF tones on the network.
  static const KEY_CDMA_DTMF_TONE_DELAY_INT = "cdma_dtmf_tone_delay_int";

  /// from: static public final java.lang.String KEY_CDMA_NONROAMING_NETWORKS_STRING_ARRAY
  ///
  /// Override the platform's notion of a network operator being considered non roaming.
  /// Value is string array of SIDs to be considered not roaming for 3GPP2 RATs.
  static const KEY_CDMA_NONROAMING_NETWORKS_STRING_ARRAY =
      "cdma_nonroaming_networks_string_array";

  /// from: static public final java.lang.String KEY_CDMA_ROAMING_MODE_INT
  ///
  /// The CDMA roaming mode (aka CDMA system select).
  ///
  /// The value should be one of the CDMA_ROAMING_MODE_ constants in TelephonyManager.
  /// Values other than TelephonyManager\#CDMA_ROAMING_MODE_RADIO_DEFAULT (which is the
  /// default) will take precedence over user selection.
  ///@see TelephonyManager\#CDMA_ROAMING_MODE_RADIO_DEFAULT
  ///@see TelephonyManager\#CDMA_ROAMING_MODE_HOME
  ///@see TelephonyManager\#CDMA_ROAMING_MODE_AFFILIATED
  ///@see TelephonyManager\#CDMA_ROAMING_MODE_ANY
  static const KEY_CDMA_ROAMING_MODE_INT = "cdma_roaming_mode_int";

  /// from: static public final java.lang.String KEY_CDMA_ROAMING_NETWORKS_STRING_ARRAY
  ///
  /// Override the platform's notion of a network operator being considered roaming.
  /// Value is string array of SIDs to be considered roaming for 3GPP2 RATs.
  static const KEY_CDMA_ROAMING_NETWORKS_STRING_ARRAY =
      "cdma_roaming_networks_string_array";

  /// from: static public final java.lang.String KEY_CI_ACTION_ON_SYS_UPDATE_BOOL
  ///
  /// Flag specifying whether an additional (client initiated) intent needs to be sent on System
  /// update
  static const KEY_CI_ACTION_ON_SYS_UPDATE_BOOL =
      "ci_action_on_sys_update_bool";

  /// from: static public final java.lang.String KEY_CI_ACTION_ON_SYS_UPDATE_EXTRA_STRING
  ///
  /// Extra to be included in the intent sent for additional action on System update
  static const KEY_CI_ACTION_ON_SYS_UPDATE_EXTRA_STRING =
      "ci_action_on_sys_update_extra_string";

  /// from: static public final java.lang.String KEY_CI_ACTION_ON_SYS_UPDATE_EXTRA_VAL_STRING
  ///
  /// Value of extra included in intent sent for additional action on System update
  static const KEY_CI_ACTION_ON_SYS_UPDATE_EXTRA_VAL_STRING =
      "ci_action_on_sys_update_extra_val_string";

  /// from: static public final java.lang.String KEY_CI_ACTION_ON_SYS_UPDATE_INTENT_STRING
  ///
  /// Intent to be sent for the additional action on System update
  static const KEY_CI_ACTION_ON_SYS_UPDATE_INTENT_STRING =
      "ci_action_on_sys_update_intent_string";

  /// from: static public final java.lang.String KEY_CONFIG_IMS_PACKAGE_OVERRIDE_STRING
  ///
  /// Override the device's configuration for the ImsService to use for this SIM card.
  static const KEY_CONFIG_IMS_PACKAGE_OVERRIDE_STRING =
      "config_ims_package_override_string";

  /// from: static public final java.lang.String KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING
  ///
  /// Override the package that will manage SubscriptionPlan
  /// information instead of the CarrierService that defines this
  /// value.
  ///@see SubscriptionManager\#getSubscriptionPlans(int)
  ///@see SubscriptionManager\#setSubscriptionPlans(int, java.util.List)
  static const KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING =
      "config_plans_package_override_string";

  /// from: static public final java.lang.String KEY_CONFIG_TELEPHONY_USE_OWN_NUMBER_FOR_VOICEMAIL_BOOL
  ///
  /// Flag that specifies to use the user's own phone number as the voicemail number when there is
  /// no pre-loaded voicemail number on the SIM card.
  ///
  /// \#KEY_DEFAULT_VM_NUMBER_STRING takes precedence over this flag.
  ///
  /// If false, the system default (*86) will be used instead.
  static const KEY_CONFIG_TELEPHONY_USE_OWN_NUMBER_FOR_VOICEMAIL_BOOL =
      "config_telephony_use_own_number_for_voicemail_bool";

  /// from: static public final java.lang.String KEY_CSP_ENABLED_BOOL
  ///
  /// If this is true, the SIM card (through Customer Service Profile EF file) will be able to
  /// prevent manual operator selection. If false, this SIM setting will be ignored and manual
  /// operator selection will always be available. See CPHS4_2.WW6, CPHS B.4.7.1 for more
  /// information
  static const KEY_CSP_ENABLED_BOOL = "csp_enabled_bool";

  /// from: static public final java.lang.String KEY_DATA_LIMIT_THRESHOLD_BYTES_LONG
  ///
  /// Controls the cellular data limit.
  ///
  /// If the user uses more than this amount of data in their billing cycle, as defined by
  /// \#KEY_MONTHLY_DATA_CYCLE_DAY_INT, cellular data will be turned off by the user's
  /// phone. If the value is set to \#DATA_CYCLE_THRESHOLD_DISABLED, the data limit will be
  /// disabled.
  ///
  /// This setting may be overridden by explicit user choice. By default, the platform value
  /// will be used.
  static const KEY_DATA_LIMIT_THRESHOLD_BYTES_LONG =
      "data_limit_threshold_bytes_long";

  /// from: static public final java.lang.String KEY_DATA_WARNING_THRESHOLD_BYTES_LONG
  ///
  /// Controls the data usage warning.
  ///
  /// If the user uses more than this amount of data in their billing cycle, as defined by
  /// \#KEY_MONTHLY_DATA_CYCLE_DAY_INT, the user will be alerted about the usage.
  /// If the value is set to \#DATA_CYCLE_THRESHOLD_DISABLED, the data usage warning will
  /// be disabled.
  ///
  /// This setting may be overridden by explicit user choice. By default, the platform value
  /// will be used.
  static const KEY_DATA_WARNING_THRESHOLD_BYTES_LONG =
      "data_warning_threshold_bytes_long";

  /// from: static public final java.lang.String KEY_DEFAULT_SIM_CALL_MANAGER_STRING
  ///
  /// The default sim call manager to use when the default dialer doesn't implement one. A sim call
  /// manager can control and route outgoing and incoming phone calls, even if they're placed
  /// using another connection service (PSTN, for example).
  static const KEY_DEFAULT_SIM_CALL_MANAGER_STRING =
      "default_sim_call_manager_string";

  /// from: static public final java.lang.String KEY_DEFAULT_VM_NUMBER_STRING
  ///
  /// Where there is no preloaded voicemail number on a SIM card, specifies the carrier's default
  /// voicemail number.
  /// When empty string, no default voicemail number is specified.
  static const KEY_DEFAULT_VM_NUMBER_STRING = "default_vm_number_string";

  /// from: static public final java.lang.String KEY_DIAL_STRING_REPLACE_STRING_ARRAY
  ///
  /// Specifies a map from dialstrings to replacements for roaming network service numbers which
  /// cannot be replaced on the carrier side.
  ///
  /// Individual entries have the format:
  /// [dialstring to replace]:[replacement]
  static const KEY_DIAL_STRING_REPLACE_STRING_ARRAY =
      "dial_string_replace_string_array";

  /// from: static public final java.lang.String KEY_DISABLE_CDMA_ACTIVATION_CODE_BOOL
  ///
  /// Disables dialing "*228" (OTASP provisioning) on CDMA carriers where it is not supported or is
  /// potentially harmful by locking the SIM to 3G.
  static const KEY_DISABLE_CDMA_ACTIVATION_CODE_BOOL =
      "disable_cdma_activation_code_bool";

  /// from: static public final java.lang.String KEY_DISPLAY_HD_AUDIO_PROPERTY_BOOL
  ///
  /// Determines whether High Definition audio property is displayed in the dialer UI.
  /// If {@code false}, remove the HD audio property from the connection so that HD audio related
  /// UI is not displayed. If {@code true}, keep HD audio property as it is configured.
  static const KEY_DISPLAY_HD_AUDIO_PROPERTY_BOOL =
      "display_hd_audio_property_bool";

  /// from: static public final java.lang.String KEY_DROP_VIDEO_CALL_WHEN_ANSWERING_AUDIO_CALL_BOOL
  ///
  /// When {@code true}, if the user is in an ongoing video call over WIFI and answers an incoming
  /// audio call, the video call will be disconnected before the audio call is answered.  This is
  /// in contrast to the usual expected behavior where a foreground video call would be put into
  /// the background and held when an incoming audio call is answered.
  static const KEY_DROP_VIDEO_CALL_WHEN_ANSWERING_AUDIO_CALL_BOOL =
      "drop_video_call_when_answering_audio_call_bool";

  /// from: static public final java.lang.String KEY_DTMF_TYPE_ENABLED_BOOL
  ///
  /// Flag indicating if dtmf tone type is enabled
  static const KEY_DTMF_TYPE_ENABLED_BOOL = "dtmf_type_enabled_bool";

  /// from: static public final java.lang.String KEY_DURATION_BLOCKING_DISABLED_AFTER_EMERGENCY_INT
  ///
  /// The duration in seconds that platform call and message blocking is disabled after the user
  /// contacts emergency services. Platform considers values for below cases:
  ///  1) 0 <= VALUE <= 604800(one week): the value will be used as the duration directly.
  ///  2) VALUE > 604800(one week): will use the default value as duration instead.
  ///  3) VALUE < 0: block will be disabled forever until user re-eanble block manually,
  ///     the suggested value to disable forever is -1.
  /// See {@code android.provider.BlockedNumberContract\#notifyEmergencyContact(Context)}
  /// See {@code android.provider.BlockedNumberContract\#isBlocked(Context, String)}.
  static const KEY_DURATION_BLOCKING_DISABLED_AFTER_EMERGENCY_INT =
      "duration_blocking_disabled_after_emergency_int";

  /// from: static public final java.lang.String KEY_EDITABLE_ENHANCED_4G_LTE_BOOL
  ///
  /// Determine whether user can toggle Enhanced 4G LTE Mode in Settings.
  static const KEY_EDITABLE_ENHANCED_4G_LTE_BOOL =
      "editable_enhanced_4g_lte_bool";

  /// from: static public final java.lang.String KEY_EDITABLE_VOICEMAIL_NUMBER_BOOL
  ///
  /// Since the default voicemail number is empty, if a SIM card does not have a voicemail number
  /// available the user cannot use voicemail. This flag allows the user to edit the voicemail
  /// number in such cases, and is false by default.
  static const KEY_EDITABLE_VOICEMAIL_NUMBER_BOOL =
      "editable_voicemail_number_bool";

  /// from: static public final java.lang.String KEY_EDITABLE_VOICEMAIL_NUMBER_SETTING_BOOL
  ///
  /// Determine whether user can edit voicemail number in Settings.
  static const KEY_EDITABLE_VOICEMAIL_NUMBER_SETTING_BOOL =
      "editable_voicemail_number_setting_bool";

  /// from: static public final java.lang.String KEY_ENABLE_DIALER_KEY_VIBRATION_BOOL
  ///
  /// If true, enable vibration (haptic feedback) for key presses in the EmergencyDialer activity.
  /// The pattern is set on a per-platform basis using config_virtualKeyVibePattern. To be
  /// consistent with the regular Dialer, this value should agree with the corresponding values
  /// from config.xml under apps/Contacts.
  static const KEY_ENABLE_DIALER_KEY_VIBRATION_BOOL =
      "enable_dialer_key_vibration_bool";

  /// from: static public final java.lang.String KEY_FORCE_HOME_NETWORK_BOOL
  ///
  /// Override the platform's notion of a network operator being considered non roaming.
  /// If true all networks are considered as home network a.k.a non-roaming.  When false,
  /// the 2 pairs of CMDA and GSM roaming/non-roaming arrays are consulted.
  ///@see \#KEY_GSM_ROAMING_NETWORKS_STRING_ARRAY
  ///@see \#KEY_GSM_NONROAMING_NETWORKS_STRING_ARRAY
  ///@see \#KEY_CDMA_ROAMING_NETWORKS_STRING_ARRAY
  ///@see \#KEY_CDMA_NONROAMING_NETWORKS_STRING_ARRAY
  static const KEY_FORCE_HOME_NETWORK_BOOL = "force_home_network_bool";

  /// from: static public final java.lang.String KEY_GSM_DTMF_TONE_DELAY_INT
  ///
  /// Specifies the amount of gap to be added in millis between postdial DTMF tones. When a
  /// non-zero value is specified, the UE shall wait for the specified amount of time before it
  /// sends out successive DTMF tones on the network.
  static const KEY_GSM_DTMF_TONE_DELAY_INT = "gsm_dtmf_tone_delay_int";

  /// from: static public final java.lang.String KEY_GSM_NONROAMING_NETWORKS_STRING_ARRAY
  ///
  /// Override the platform's notion of a network operator being considered not roaming.
  /// Value is string array of MCCMNCs to be considered not roaming for 3GPP RATs.
  static const KEY_GSM_NONROAMING_NETWORKS_STRING_ARRAY =
      "gsm_nonroaming_networks_string_array";

  /// from: static public final java.lang.String KEY_GSM_ROAMING_NETWORKS_STRING_ARRAY
  ///
  /// Override the platform's notion of a network operator being considered roaming.
  /// Value is string array of MCCMNCs to be considered roaming for 3GPP RATs.
  static const KEY_GSM_ROAMING_NETWORKS_STRING_ARRAY =
      "gsm_roaming_networks_string_array";

  /// from: static public final java.lang.String KEY_HAS_IN_CALL_NOISE_SUPPRESSION_BOOL
  ///
  /// Determines if device implements a noise suppression device for in call audio.
  static const KEY_HAS_IN_CALL_NOISE_SUPPRESSION_BOOL =
      "has_in_call_noise_suppression_bool";

  /// from: static public final java.lang.String KEY_HIDE_CARRIER_NETWORK_SETTINGS_BOOL
  ///
  /// Control whether users can reach the carrier portions of Cellular Network Settings.
  static const KEY_HIDE_CARRIER_NETWORK_SETTINGS_BOOL =
      "hide_carrier_network_settings_bool";

  /// from: static public final java.lang.String KEY_HIDE_ENHANCED_4G_LTE_BOOL
  ///
  /// Determines whether the Enhanced 4G LTE toggle will be shown in the settings. When this
  /// option is {@code true}, the toggle will be hidden regardless of whether the device and
  /// carrier supports 4G LTE or not.
  static const KEY_HIDE_ENHANCED_4G_LTE_BOOL = "hide_enhanced_4g_lte_bool";

  /// from: static public final java.lang.String KEY_HIDE_IMS_APN_BOOL
  ///
  /// Determine whether IMS apn can be shown.
  static const KEY_HIDE_IMS_APN_BOOL = "hide_ims_apn_bool";

  /// from: static public final java.lang.String KEY_HIDE_PREFERRED_NETWORK_TYPE_BOOL
  ///
  /// Determine whether preferred network type can be shown.
  static const KEY_HIDE_PREFERRED_NETWORK_TYPE_BOOL =
      "hide_preferred_network_type_bool";

  /// from: static public final java.lang.String KEY_HIDE_SIM_LOCK_SETTINGS_BOOL
  ///
  /// Control whether users can reach the SIM lock settings.
  static const KEY_HIDE_SIM_LOCK_SETTINGS_BOOL = "hide_sim_lock_settings_bool";

  /// from: static public final java.lang.String KEY_IGNORE_SIM_NETWORK_LOCKED_EVENTS_BOOL
  ///
  /// Flag indicating whether the Phone app should ignore EVENT_SIM_NETWORK_LOCKED
  /// events from the Sim.
  /// If true, this will prevent the IccNetworkDepersonalizationPanel from being shown, and
  /// effectively disable the "Sim network lock" feature.
  static const KEY_IGNORE_SIM_NETWORK_LOCKED_EVENTS_BOOL =
      "ignore_sim_network_locked_events_bool";

  /// from: static public final java.lang.String KEY_IMS_CONFERENCE_SIZE_LIMIT_INT
  ///
  /// Determines the maximum number of participants the carrier supports for a conference call.
  /// This number is exclusive of the current device.  A conference between 3 devices, for example,
  /// would have a size limit of 2 participants.
  /// Enforced when \#KEY_IS_IMS_CONFERENCE_SIZE_ENFORCED_BOOL is {@code true}.
  static const KEY_IMS_CONFERENCE_SIZE_LIMIT_INT =
      "ims_conference_size_limit_int";

  /// from: static public final java.lang.String KEY_IMS_DTMF_TONE_DELAY_INT
  ///
  /// Specifies the amount of gap to be added in millis between DTMF tones. When a non-zero value
  /// is specified, the UE shall wait for the specified amount of time before it sends out
  /// successive DTMF tones on the network.
  static const KEY_IMS_DTMF_TONE_DELAY_INT = "ims_dtmf_tone_delay_int";

  /// from: static public final java.lang.String KEY_IS_IMS_CONFERENCE_SIZE_ENFORCED_BOOL
  ///
  /// Determines whether a maximum size limit for IMS conference calls is enforced on the device.
  /// When {@code true}, IMS conference calls will be limited to at most
  /// \#KEY_IMS_CONFERENCE_SIZE_LIMIT_INT participants.  When {@code false}, no attempt is made
  /// to limit the number of participants in a conference (the carrier will raise an error when an
  /// attempt is made to merge too many participants into a conference).
  static const KEY_IS_IMS_CONFERENCE_SIZE_ENFORCED_BOOL =
      "is_ims_conference_size_enforced_bool";

  /// from: static public final java.lang.String KEY_MDN_IS_ADDITIONAL_VOICEMAIL_NUMBER_BOOL
  ///
  /// When checking if a given number is the voicemail number, if this flag is true
  /// then in addition to comparing the given number to the voicemail number, we also compare it
  /// to the mdn. If this flag is false, the given number is only compared to the voicemail number.
  /// By default this value is false.
  static const KEY_MDN_IS_ADDITIONAL_VOICEMAIL_NUMBER_BOOL =
      "mdn_is_additional_voicemail_number_bool";

  /// from: static public final java.lang.String KEY_MMS_ALIAS_ENABLED_BOOL
  static const KEY_MMS_ALIAS_ENABLED_BOOL = "aliasEnabled";

  /// from: static public final java.lang.String KEY_MMS_ALIAS_MAX_CHARS_INT
  static const KEY_MMS_ALIAS_MAX_CHARS_INT = "aliasMaxChars";

  /// from: static public final java.lang.String KEY_MMS_ALIAS_MIN_CHARS_INT
  static const KEY_MMS_ALIAS_MIN_CHARS_INT = "aliasMinChars";

  /// from: static public final java.lang.String KEY_MMS_ALLOW_ATTACH_AUDIO_BOOL
  static const KEY_MMS_ALLOW_ATTACH_AUDIO_BOOL = "allowAttachAudio";

  /// from: static public final java.lang.String KEY_MMS_APPEND_TRANSACTION_ID_BOOL
  static const KEY_MMS_APPEND_TRANSACTION_ID_BOOL = "enabledTransID";

  /// from: static public final java.lang.String KEY_MMS_EMAIL_GATEWAY_NUMBER_STRING
  static const KEY_MMS_EMAIL_GATEWAY_NUMBER_STRING = "emailGatewayNumber";

  /// from: static public final java.lang.String KEY_MMS_GROUP_MMS_ENABLED_BOOL
  static const KEY_MMS_GROUP_MMS_ENABLED_BOOL = "enableGroupMms";

  /// from: static public final java.lang.String KEY_MMS_HTTP_PARAMS_STRING
  static const KEY_MMS_HTTP_PARAMS_STRING = "httpParams";

  /// from: static public final java.lang.String KEY_MMS_HTTP_SOCKET_TIMEOUT_INT
  static const KEY_MMS_HTTP_SOCKET_TIMEOUT_INT = "httpSocketTimeout";

  /// from: static public final java.lang.String KEY_MMS_MAX_IMAGE_HEIGHT_INT
  static const KEY_MMS_MAX_IMAGE_HEIGHT_INT = "maxImageHeight";

  /// from: static public final java.lang.String KEY_MMS_MAX_IMAGE_WIDTH_INT
  static const KEY_MMS_MAX_IMAGE_WIDTH_INT = "maxImageWidth";

  /// from: static public final java.lang.String KEY_MMS_MAX_MESSAGE_SIZE_INT
  static const KEY_MMS_MAX_MESSAGE_SIZE_INT = "maxMessageSize";

  /// from: static public final java.lang.String KEY_MMS_MESSAGE_TEXT_MAX_SIZE_INT
  static const KEY_MMS_MESSAGE_TEXT_MAX_SIZE_INT = "maxMessageTextSize";

  /// from: static public final java.lang.String KEY_MMS_MMS_DELIVERY_REPORT_ENABLED_BOOL
  static const KEY_MMS_MMS_DELIVERY_REPORT_ENABLED_BOOL =
      "enableMMSDeliveryReports";

  /// from: static public final java.lang.String KEY_MMS_MMS_ENABLED_BOOL
  static const KEY_MMS_MMS_ENABLED_BOOL = "enabledMMS";

  /// from: static public final java.lang.String KEY_MMS_MMS_READ_REPORT_ENABLED_BOOL
  static const KEY_MMS_MMS_READ_REPORT_ENABLED_BOOL = "enableMMSReadReports";

  /// from: static public final java.lang.String KEY_MMS_MULTIPART_SMS_ENABLED_BOOL
  static const KEY_MMS_MULTIPART_SMS_ENABLED_BOOL = "enableMultipartSMS";

  /// from: static public final java.lang.String KEY_MMS_NAI_SUFFIX_STRING
  static const KEY_MMS_NAI_SUFFIX_STRING = "naiSuffix";

  /// from: static public final java.lang.String KEY_MMS_NOTIFY_WAP_MMSC_ENABLED_BOOL
  static const KEY_MMS_NOTIFY_WAP_MMSC_ENABLED_BOOL = "enabledNotifyWapMMSC";

  /// from: static public final java.lang.String KEY_MMS_RECIPIENT_LIMIT_INT
  static const KEY_MMS_RECIPIENT_LIMIT_INT = "recipientLimit";

  /// from: static public final java.lang.String KEY_MMS_SEND_MULTIPART_SMS_AS_SEPARATE_MESSAGES_BOOL
  static const KEY_MMS_SEND_MULTIPART_SMS_AS_SEPARATE_MESSAGES_BOOL =
      "sendMultipartSmsAsSeparateMessages";

  /// from: static public final java.lang.String KEY_MMS_SHOW_CELL_BROADCAST_APP_LINKS_BOOL
  static const KEY_MMS_SHOW_CELL_BROADCAST_APP_LINKS_BOOL =
      "config_cellBroadcastAppLinks";

  /// from: static public final java.lang.String KEY_MMS_SMS_DELIVERY_REPORT_ENABLED_BOOL
  static const KEY_MMS_SMS_DELIVERY_REPORT_ENABLED_BOOL =
      "enableSMSDeliveryReports";

  /// from: static public final java.lang.String KEY_MMS_SMS_TO_MMS_TEXT_LENGTH_THRESHOLD_INT
  static const KEY_MMS_SMS_TO_MMS_TEXT_LENGTH_THRESHOLD_INT =
      "smsToMmsTextLengthThreshold";

  /// from: static public final java.lang.String KEY_MMS_SMS_TO_MMS_TEXT_THRESHOLD_INT
  static const KEY_MMS_SMS_TO_MMS_TEXT_THRESHOLD_INT = "smsToMmsTextThreshold";

  /// from: static public final java.lang.String KEY_MMS_SUBJECT_MAX_LENGTH_INT
  static const KEY_MMS_SUBJECT_MAX_LENGTH_INT = "maxSubjectLength";

  /// from: static public final java.lang.String KEY_MMS_SUPPORT_HTTP_CHARSET_HEADER_BOOL
  static const KEY_MMS_SUPPORT_HTTP_CHARSET_HEADER_BOOL =
      "supportHttpCharsetHeader";

  /// from: static public final java.lang.String KEY_MMS_SUPPORT_MMS_CONTENT_DISPOSITION_BOOL
  static const KEY_MMS_SUPPORT_MMS_CONTENT_DISPOSITION_BOOL =
      "supportMmsContentDisposition";

  /// from: static public final java.lang.String KEY_MMS_UA_PROF_TAG_NAME_STRING
  static const KEY_MMS_UA_PROF_TAG_NAME_STRING = "uaProfTagName";

  /// from: static public final java.lang.String KEY_MMS_UA_PROF_URL_STRING
  static const KEY_MMS_UA_PROF_URL_STRING = "uaProfUrl";

  /// from: static public final java.lang.String KEY_MMS_USER_AGENT_STRING
  static const KEY_MMS_USER_AGENT_STRING = "userAgent";

  /// from: static public final java.lang.String KEY_MONTHLY_DATA_CYCLE_DAY_INT
  ///
  /// The day of the month (1-31) on which the data cycle rolls over.
  ///
  /// If the current month does not have this day, the cycle will roll over at
  /// the start of the next month.
  ///
  /// This setting may be still overridden by explicit user choice. By default,
  /// the platform value will be used.
  static const KEY_MONTHLY_DATA_CYCLE_DAY_INT = "monthly_data_cycle_day_int";

  /// from: static public final java.lang.String KEY_ONLY_SINGLE_DC_ALLOWED_INT_ARRAY
  ///
  /// List of RIL radio technologies (See ServiceState {@code RIL_RADIO_TECHNOLOGY_*}
  /// constants) which support only a single data connection at a time. Some carriers do not
  /// support multiple pdp on UMTS.
  static const KEY_ONLY_SINGLE_DC_ALLOWED_INT_ARRAY =
      "only_single_dc_allowed_int_array";

  /// from: static public final java.lang.String KEY_OPERATOR_SELECTION_EXPAND_BOOL
  ///
  /// Control whether users can choose a network operator.
  static const KEY_OPERATOR_SELECTION_EXPAND_BOOL =
      "operator_selection_expand_bool";

  /// from: static public final java.lang.String KEY_PREFER_2G_BOOL
  ///
  /// Used in Cellular Network Settings for preferred network type.
  static const KEY_PREFER_2G_BOOL = "prefer_2g_bool";

  /// from: static public final java.lang.String KEY_RCS_CONFIG_SERVER_URL_STRING
  ///
  /// The RCS configuration server URL. This URL is used to initiate RCS provisioning.
  static const KEY_RCS_CONFIG_SERVER_URL_STRING =
      "rcs_config_server_url_string";

  /// from: static public final java.lang.String KEY_REQUIRE_ENTITLEMENT_CHECKS_BOOL
  ///
  /// Flag to require or skip entitlement checks.
  /// If true, entitlement checks will be executed if device has been configured for it,
  /// If false, entitlement checks will be skipped.
  static const KEY_REQUIRE_ENTITLEMENT_CHECKS_BOOL =
      "require_entitlement_checks_bool";

  /// from: static public final java.lang.String KEY_RESTART_RADIO_ON_PDP_FAIL_REGULAR_DEACTIVATION_BOOL
  ///
  /// Flag indicating whether radio is to be restarted on error PDP_FAIL_REGULAR_DEACTIVATION
  /// This is false by default.
  static const KEY_RESTART_RADIO_ON_PDP_FAIL_REGULAR_DEACTIVATION_BOOL =
      "restart_radio_on_pdp_fail_regular_deactivation_bool";

  /// from: static public final java.lang.String KEY_RTT_SUPPORTED_BOOL
  ///
  /// Flag indicating whether the carrier supports RTT over IMS.
  static const KEY_RTT_SUPPORTED_BOOL = "rtt_supported_bool";

  /// from: static public final java.lang.String KEY_SHOW_APN_SETTING_CDMA_BOOL
  ///
  /// Show APN Settings for some CDMA carriers
  static const KEY_SHOW_APN_SETTING_CDMA_BOOL = "show_apn_setting_cdma_bool";

  /// from: static public final java.lang.String KEY_SHOW_CDMA_CHOICES_BOOL
  ///
  /// Show cdma network mode choices 1x, 3G, global etc.
  static const KEY_SHOW_CDMA_CHOICES_BOOL = "show_cdma_choices_bool";

  /// from: static public final java.lang.String KEY_SHOW_ICCID_IN_SIM_STATUS_BOOL
  ///
  /// Flag specifying whether ICCID is showed in SIM Status screen, default to false.
  static const KEY_SHOW_ICCID_IN_SIM_STATUS_BOOL =
      "show_iccid_in_sim_status_bool";

  /// from: static public final java.lang.String KEY_SHOW_ONSCREEN_DIAL_BUTTON_BOOL
  ///
  /// If true, show an onscreen "Dial" button in the dialer. In practice this is used on all
  /// platforms, even the ones with hard SEND/END keys, but for maximum flexibility it's controlled
  /// by a flag here (which can be overridden on a per-product basis.)
  static const KEY_SHOW_ONSCREEN_DIAL_BUTTON_BOOL =
      "show_onscreen_dial_button_bool";

  /// from: static public final java.lang.String KEY_SHOW_SIGNAL_STRENGTH_IN_SIM_STATUS_BOOL
  ///
  /// Flag specifying whether the android.telephony.SignalStrength is shown in the SIM
  /// Status screen. The default value is true.
  static const KEY_SHOW_SIGNAL_STRENGTH_IN_SIM_STATUS_BOOL =
      "show_signal_strength_in_sim_status_bool";

  /// from: static public final java.lang.String KEY_SIMPLIFIED_NETWORK_SETTINGS_BOOL
  ///
  /// Control whether users receive a simplified network settings UI and improved network
  /// selection.
  static const KEY_SIMPLIFIED_NETWORK_SETTINGS_BOOL =
      "simplified_network_settings_bool";

  /// from: static public final java.lang.String KEY_SIM_NETWORK_UNLOCK_ALLOW_DISMISS_BOOL
  ///
  /// Flag indicating whether the Phone app should provide a "Dismiss" button on the SIM network
  /// unlock screen. The default value is true. If set to false, there will be *no way* to dismiss
  /// the SIM network unlock screen if you don't enter the correct unlock code. (One important
  /// consequence: there will be no way to make an Emergency Call if your SIM is network-locked and
  /// you don't know the PIN.)
  static const KEY_SIM_NETWORK_UNLOCK_ALLOW_DISMISS_BOOL =
      "sim_network_unlock_allow_dismiss_bool";

  /// from: static public final java.lang.String KEY_SMS_REQUIRES_DESTINATION_NUMBER_CONVERSION_BOOL
  ///
  /// Determines if the carrier requires converting the destination number before sending out an
  /// SMS. Certain networks and numbering plans require different formats.
  static const KEY_SMS_REQUIRES_DESTINATION_NUMBER_CONVERSION_BOOL =
      "sms_requires_destination_number_conversion_bool";

  /// from: static public final java.lang.String KEY_SUPPORT_3GPP_CALL_FORWARDING_WHILE_ROAMING_BOOL
  ///
  /// Indicates whether the carrier supports 3gpp call forwarding MMI codes while roaming. If
  /// false, the user will be notified that call forwarding is not available when the MMI code
  /// fails.
  static const KEY_SUPPORT_3GPP_CALL_FORWARDING_WHILE_ROAMING_BOOL =
      "support_3gpp_call_forwarding_while_roaming_bool";

  /// from: static public final java.lang.String KEY_SUPPORT_CONFERENCE_CALL_BOOL
  ///
  /// Determines whether conference calls are supported by a carrier.  When {@code true},
  /// conference calling is supported, {@code false otherwise}.
  static const KEY_SUPPORT_CONFERENCE_CALL_BOOL =
      "support_conference_call_bool";

  /// from: static public final java.lang.String KEY_SUPPORT_PAUSE_IMS_VIDEO_CALLS_BOOL
  ///
  /// For IMS video over LTE calls, determines whether video pause signalling is supported.
  static const KEY_SUPPORT_PAUSE_IMS_VIDEO_CALLS_BOOL =
      "support_pause_ims_video_calls_bool";

  /// from: static public final java.lang.String KEY_SUPPORT_SWAP_AFTER_MERGE_BOOL
  ///
  /// After a CDMA conference call is merged, the swap button should be displayed.
  static const KEY_SUPPORT_SWAP_AFTER_MERGE_BOOL =
      "support_swap_after_merge_bool";

  /// from: static public final java.lang.String KEY_TREAT_DOWNGRADED_VIDEO_CALLS_AS_VIDEO_CALLS_BOOL
  ///
  /// Flag indicating whether some telephony logic will treat a call which was formerly a video
  /// call as if it is still a video call.  When {@code true}:
  ///
  /// Logic which will automatically drop a video call which takes place over WIFI when a
  /// voice call is answered (see \#KEY_DROP_VIDEO_CALL_WHEN_ANSWERING_AUDIO_CALL_BOOL.
  ///
  /// Logic which determines whether the user can use TTY calling.
  static const KEY_TREAT_DOWNGRADED_VIDEO_CALLS_AS_VIDEO_CALLS_BOOL =
      "treat_downgraded_video_calls_as_video_calls_bool";

  /// from: static public final java.lang.String KEY_USE_HFA_FOR_PROVISIONING_BOOL
  ///
  /// CDMA activation goes through HFA
  static const KEY_USE_HFA_FOR_PROVISIONING_BOOL =
      "use_hfa_for_provisioning_bool";

  /// from: static public final java.lang.String KEY_USE_OTASP_FOR_PROVISIONING_BOOL
  ///
  /// CDMA activation goes through OTASP.
  ///
  /// TODO: This should be combined with config_use_hfa_for_provisioning and implemented as an enum
  /// (NONE, HFA, OTASP).
  static const KEY_USE_OTASP_FOR_PROVISIONING_BOOL =
      "use_otasp_for_provisioning_bool";

  /// from: static public final java.lang.String KEY_USE_RCS_PRESENCE_BOOL
  ///
  /// Flag indicating whether the carrier supports RCS presence indication for video calls.  When
  /// {@code true}, the carrier supports RCS presence indication for video calls.  When presence
  /// is supported, the device should use the
  /// android.provider.ContactsContract.Data\#CARRIER_PRESENCE bit mask and set the
  /// android.provider.ContactsContract.Data\#CARRIER_PRESENCE_VT_CAPABLE bit to indicate
  /// whether each contact supports video calling.  The UI is made aware that presence is enabled
  /// via android.telecom.PhoneAccount\#CAPABILITY_VIDEO_CALLING_RELIES_ON_PRESENCE
  /// and can choose to hide or show the video calling icon based on whether a contact supports
  /// video.
  static const KEY_USE_RCS_PRESENCE_BOOL = "use_rcs_presence_bool";

  /// from: static public final java.lang.String KEY_VOICEMAIL_NOTIFICATION_PERSISTENT_BOOL
  ///
  /// Determine whether the voicemail notification is persistent in the notification bar. If true,
  /// the voicemail notifications cannot be dismissed from the notification bar.
  static const KEY_VOICEMAIL_NOTIFICATION_PERSISTENT_BOOL =
      "voicemail_notification_persistent_bool";

  /// from: static public final java.lang.String KEY_VOICE_PRIVACY_DISABLE_UI_BOOL
  ///
  /// If true, removes the Voice Privacy option from Call Settings
  static const KEY_VOICE_PRIVACY_DISABLE_UI_BOOL =
      "voice_privacy_disable_ui_bool";

  /// from: static public final java.lang.String KEY_VOLTE_REPLACEMENT_RAT_INT
  ///
  /// If Voice Radio Technology is RIL_RADIO_TECHNOLOGY_LTE:14 or RIL_RADIO_TECHNOLOGY_UNKNOWN:0
  /// this is the value that should be used instead. A configuration value of
  /// RIL_RADIO_TECHNOLOGY_UNKNOWN:0 means there is no replacement value and that the default
  /// assumption for phone type (GSM) should be used.
  static const KEY_VOLTE_REPLACEMENT_RAT_INT = "volte_replacement_rat_int";

  /// from: static public final java.lang.String KEY_VVM_CELLULAR_DATA_REQUIRED_BOOL
  ///
  /// Whether cellular data is required to access visual voicemail.
  static const KEY_VVM_CELLULAR_DATA_REQUIRED_BOOL =
      "vvm_cellular_data_required_bool";

  /// from: static public final java.lang.String KEY_VVM_CLIENT_PREFIX_STRING
  ///
  /// The default OMTP visual voicemail client prefix to use. Defaulted to "//VVM"
  static const KEY_VVM_CLIENT_PREFIX_STRING = "vvm_client_prefix_string";

  /// from: static public final java.lang.String KEY_VVM_DESTINATION_NUMBER_STRING
  ///
  /// The carrier number mobile outgoing (MO) sms messages are sent to.
  static const KEY_VVM_DESTINATION_NUMBER_STRING =
      "vvm_destination_number_string";

  /// from: static public final java.lang.String KEY_VVM_DISABLED_CAPABILITIES_STRING_ARRAY
  ///
  /// A set of capabilities that should not be used even if it is reported by the visual voicemail
  /// IMAP CAPABILITY command.
  static const KEY_VVM_DISABLED_CAPABILITIES_STRING_ARRAY =
      "vvm_disabled_capabilities_string_array";

  /// from: static public final java.lang.String KEY_VVM_LEGACY_MODE_ENABLED_BOOL
  ///
  /// Whether legacy mode should be used when the visual voicemail client is disabled.
  ///
  /// Legacy mode is a mode that on the carrier side visual voicemail is still activated, but on
  /// the client side all network operations are disabled. SMSs are still monitored so a new
  /// message SYNC SMS will be translated to show a message waiting indicator, like traditional
  /// voicemails.
  ///
  /// This is for carriers that does not support VVM deactivation so voicemail can continue to
  /// function without the data cost.
  static const KEY_VVM_LEGACY_MODE_ENABLED_BOOL =
      "vvm_legacy_mode_enabled_bool";

  /// from: static public final java.lang.String KEY_VVM_PORT_NUMBER_INT
  ///
  /// The port through which the mobile outgoing (MO) sms messages are sent through.
  static const KEY_VVM_PORT_NUMBER_INT = "vvm_port_number_int";

  /// from: static public final java.lang.String KEY_VVM_PREFETCH_BOOL
  ///
  /// Whether to prefetch audio data on new voicemail arrival, defaulted to true.
  static const KEY_VVM_PREFETCH_BOOL = "vvm_prefetch_bool";

  /// from: static public final java.lang.String KEY_VVM_SSL_ENABLED_BOOL
  ///
  /// Whether to use SSL to connect to the visual voicemail IMAP server. Defaulted to false.
  static const KEY_VVM_SSL_ENABLED_BOOL = "vvm_ssl_enabled_bool";

  /// from: static public final java.lang.String KEY_VVM_TYPE_STRING
  ///
  /// The type of visual voicemail protocol the carrier adheres to. See TelephonyManager
  /// for possible values. For example TelephonyManager\#VVM_TYPE_OMTP.
  static const KEY_VVM_TYPE_STRING = "vvm_type_string";

  /// from: static public final java.lang.String KEY_WORLD_PHONE_BOOL
  ///
  /// Flag indicating if the phone is a world phone
  static const KEY_WORLD_PHONE_BOOL = "world_phone_bool";

  static final _id_getConfigForSubId = jniAccessors.getMethodIDOf(
      _classRef, "getConfigForSubId", "(I)Landroid/os/PersistableBundle;");

  /// from: public android.os.PersistableBundle getConfigForSubId(int subId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the configuration values for a particular subscription, which is associated with a
  /// specific SIM card. If an invalid subId is used, the returned config will contain default
  /// values. After using this method to get the configuration bundle,
  /// \#isConfigForIdentifiedCarrier(PersistableBundle) should be called to confirm whether
  /// any carrier specific configuration has been applied.
  ///
  /// Requires Permission:
  /// android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  ///@param subId the subscription ID, normally obtained from SubscriptionManager.
  ///@return A PersistableBundle containing the config for the given subId, or default
  ///         values for an invalid subId.
  ///
  /// This value may be {@code null}.
  persistablebundle_.PersistableBundle getConfigForSubId(int subId) =>
      persistablebundle_.PersistableBundle.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getConfigForSubId,
              jni.JniType.objectType, [subId]).object);

  static final _id_getConfig = jniAccessors.getMethodIDOf(
      _classRef, "getConfig", "()Landroid/os/PersistableBundle;");

  /// from: public android.os.PersistableBundle getConfig()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the configuration values for the default subscription. After using this method to get
  /// the configuration bundle, \#isConfigForIdentifiedCarrier(PersistableBundle) should be
  /// called to confirm whether any carrier specific configuration has been applied.
  ///
  /// Requires Permission:
  /// android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  ///@see \#getConfigForSubId
  ///@return This value may be {@code null}.
  persistablebundle_.PersistableBundle getConfig() =>
      persistablebundle_.PersistableBundle.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getConfig, jni.JniType.objectType, []).object);

  static final _id_isConfigForIdentifiedCarrier =
      jniAccessors.getStaticMethodIDOf(_classRef,
          "isConfigForIdentifiedCarrier", "(Landroid/os/PersistableBundle;)Z");

  /// from: static public boolean isConfigForIdentifiedCarrier(android.os.PersistableBundle bundle)
  ///
  /// Determines whether a configuration PersistableBundle obtained from
  /// \#getConfig() or \#getConfigForSubId(int) corresponds to an identified carrier.
  ///
  /// When an app receives the CarrierConfigManager\#ACTION_CARRIER_CONFIG_CHANGED
  /// broadcast which informs it that the carrier configuration has changed, it is possible
  /// that another reload of the carrier configuration has begun since the intent was sent.
  /// In this case, the carrier configuration the app fetches (e.g. via \#getConfig())
  /// may not represent the configuration for the current carrier. It should be noted that it
  /// does not necessarily mean the configuration belongs to current carrier when this function
  /// return true because it may belong to another previous identified carrier. Users should
  /// always call \#getConfig() or \#getConfigForSubId(int) after receiving the
  /// broadcast \#ACTION_CARRIER_CONFIG_CHANGED.
  ///
  ///
  ///
  /// After using \#getConfig() or \#getConfigForSubId(int) an app should always
  /// use this method to confirm whether any carrier specific configuration has been applied.
  /// Especially when an app misses the broadcast \#ACTION_CARRIER_CONFIG_CHANGED but it
  /// still needs to get the current configuration, it must use this method to verify whether the
  /// configuration is default or carrier overridden.
  ///
  ///
  ///@param bundle the configuration bundle to be checked.
  ///@return boolean true if any carrier specific configuration bundle has been applied, false
  /// otherwise or the bundle is null.
  static bool isConfigForIdentifiedCarrier(
          persistablebundle_.PersistableBundle bundle) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_isConfigForIdentifiedCarrier,
          jni.JniType.booleanType,
          [bundle.reference]).boolean;

  static final _id_notifyConfigChangedForSubId = jniAccessors.getMethodIDOf(
      _classRef, "notifyConfigChangedForSubId", "(I)V");

  /// from: public void notifyConfigChangedForSubId(int subId)
  ///
  /// Calling this method triggers telephony services to fetch the current carrier configuration.
  ///
  /// Normally this does not need to be called because the platform reloads config on its own.
  /// This should be called by a carrier service app if it wants to update config at an arbitrary
  /// moment.
  ///
  ///
  /// Requires that the calling app has carrier privileges.
  ///
  /// This method returns before the reload has completed, and
  /// android.service.carrier.CarrierService\#onLoadConfig will be called from an
  /// arbitrary thread.
  ///
  ///
  ///@see TelephonyManager\#hasCarrierPrivileges
  void notifyConfigChangedForSubId(int subId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_notifyConfigChangedForSubId,
          jni.JniType.voidType,
          [subId]).check();
}
