// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.telephony.mbms.ServiceInfo
///
/// Describes a cell-broadcast service. This class should not be instantiated directly -- use
/// StreamingServiceInfo or FileServiceInfo
class ServiceInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/telephony/mbms/ServiceInfo");
  ServiceInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getNameForLocale = jniAccessors.getMethodIDOf(_classRef,
      "getNameForLocale", "(Ljava/util/Locale;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getNameForLocale(java.util.Locale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the user-displayable name for this cell-broadcast service corresponding to the
  /// provided Locale.
  ///@param locale The Locale in which you want the name of the service. This must be a
  ///               value from the set returned by \#getNamedContentLocales() -- an
  ///               java.util.NoSuchElementException may be thrown otherwise.
  /// This value must never be {@code null}.
  ///@return The CharSequence providing the name of the service in the given
  ///         Locale
  ///
  /// This value will never be {@code null}.
  jni.JniObject getNameForLocale(jni.JniObject locale) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getNameForLocale,
          jni.JniType.objectType,
          [locale.reference]).object);

  static final _id_getNamedContentLocales = jniAccessors.getMethodIDOf(
      _classRef, "getNamedContentLocales", "()Ljava/util/Set;");

  /// from: public java.util.Set<java.util.Locale> getNamedContentLocales()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an unmodifiable set of the current Locales that have a user-displayable name
  /// associated with them. The user-displayable name associated with any Locale in this
  /// set can be retrieved with \#getNameForLocale(Locale).
  ///@return An unmodifiable set of Locale objects corresponding to a user-displayable
  /// content name in that locale.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getNamedContentLocales() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getNamedContentLocales, jni.JniType.objectType, []).object);

  static final _id_getServiceClassName = jniAccessors.getMethodIDOf(
      _classRef, "getServiceClassName", "()Ljava/lang/String;");

  /// from: public java.lang.String getServiceClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The class name for this service - used to categorize and filter
  jni.JniString getServiceClassName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getServiceClassName, jni.JniType.objectType, []).object);

  static final _id_getLocales =
      jniAccessors.getMethodIDOf(_classRef, "getLocales", "()Ljava/util/List;");

  /// from: public java.util.List<java.util.Locale> getLocales()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The languages available for this service content
  jni.JniObject getLocales() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLocales, jni.JniType.objectType, []).object);

  static final _id_getServiceId = jniAccessors.getMethodIDOf(
      _classRef, "getServiceId", "()Ljava/lang/String;");

  /// from: public java.lang.String getServiceId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The carrier's identifier for the service.
  jni.JniString getServiceId() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getServiceId, jni.JniType.objectType, []).object);

  static final _id_getSessionStartTime = jniAccessors.getMethodIDOf(
      _classRef, "getSessionStartTime", "()Ljava/util/Date;");

  /// from: public java.util.Date getSessionStartTime()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The start time indicating when this service will be available.
  jni.JniObject getSessionStartTime() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSessionStartTime, jni.JniType.objectType, []).object);

  static final _id_getSessionEndTime = jniAccessors.getMethodIDOf(
      _classRef, "getSessionEndTime", "()Ljava/util/Date;");

  /// from: public java.util.Date getSessionEndTime()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The end time indicating when this session stops being available.
  jni.JniObject getSessionEndTime() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSessionEndTime, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}
