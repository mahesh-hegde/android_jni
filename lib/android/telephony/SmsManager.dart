// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../app/PendingIntent.dart" as pendingintent_;

import "../content/Context.dart" as context_;

import "../net/Uri.dart" as uri_;

import "../os/Bundle.dart" as bundle_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.telephony.SmsManager
///
/// Manages SMS operations such as sending data, text, and pdu SMS messages.
/// Get this object by calling the static method \#getDefault().
///
/// For information about how to behave as the default SMS app on Android 4.4 (API level 19)
/// and higher, see android.provider.Telephony.
class SmsManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/telephony/SmsManager");
  SmsManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String EXTRA_MMS_DATA
  ///
  /// Intent extra name for MMS sending result data in byte array type
  static const EXTRA_MMS_DATA = "android.telephony.extra.MMS_DATA";

  /// from: static public final java.lang.String EXTRA_MMS_HTTP_STATUS
  ///
  /// Intent extra name for HTTP status code for MMS HTTP failure in integer type
  static const EXTRA_MMS_HTTP_STATUS =
      "android.telephony.extra.MMS_HTTP_STATUS";

  /// from: static public final java.lang.String MMS_CONFIG_ALIAS_ENABLED
  ///
  /// Whether alias is enabled (boolean type)
  static const MMS_CONFIG_ALIAS_ENABLED = "aliasEnabled";

  /// from: static public final java.lang.String MMS_CONFIG_ALIAS_MAX_CHARS
  ///
  /// Max alias character count (int type)
  static const MMS_CONFIG_ALIAS_MAX_CHARS = "aliasMaxChars";

  /// from: static public final java.lang.String MMS_CONFIG_ALIAS_MIN_CHARS
  ///
  /// Min alias character count (int type)
  static const MMS_CONFIG_ALIAS_MIN_CHARS = "aliasMinChars";

  /// from: static public final java.lang.String MMS_CONFIG_ALLOW_ATTACH_AUDIO
  ///
  /// Whether audio is allowed to be attached for MMS messages (boolean type)
  static const MMS_CONFIG_ALLOW_ATTACH_AUDIO = "allowAttachAudio";

  /// from: static public final java.lang.String MMS_CONFIG_APPEND_TRANSACTION_ID
  ///
  /// Whether to append transaction id to MMS WAP Push M-Notification.ind's content location URI
  /// when constructing the download URL of a new MMS (boolean type)
  static const MMS_CONFIG_APPEND_TRANSACTION_ID = "enabledTransID";

  /// from: static public final java.lang.String MMS_CONFIG_EMAIL_GATEWAY_NUMBER
  ///
  /// Email gateway number (String type)
  static const MMS_CONFIG_EMAIL_GATEWAY_NUMBER = "emailGatewayNumber";

  /// from: static public final java.lang.String MMS_CONFIG_GROUP_MMS_ENABLED
  ///
  /// Whether group MMS is enabled for the current carrier (boolean type)
  static const MMS_CONFIG_GROUP_MMS_ENABLED = "enableGroupMms";

  /// from: static public final java.lang.String MMS_CONFIG_HTTP_PARAMS
  ///
  /// A list of HTTP headers to add to MMS HTTP request, separated by "|" (String type)
  static const MMS_CONFIG_HTTP_PARAMS = "httpParams";

  /// from: static public final java.lang.String MMS_CONFIG_HTTP_SOCKET_TIMEOUT
  ///
  /// MMS HTTP socket timeout in milliseconds (int type)
  static const MMS_CONFIG_HTTP_SOCKET_TIMEOUT = "httpSocketTimeout";

  /// from: static public final java.lang.String MMS_CONFIG_MAX_IMAGE_HEIGHT
  ///
  /// Max MMS image height (int type)
  static const MMS_CONFIG_MAX_IMAGE_HEIGHT = "maxImageHeight";

  /// from: static public final java.lang.String MMS_CONFIG_MAX_IMAGE_WIDTH
  ///
  /// Max MMS image width (int type)
  static const MMS_CONFIG_MAX_IMAGE_WIDTH = "maxImageWidth";

  /// from: static public final java.lang.String MMS_CONFIG_MAX_MESSAGE_SIZE
  ///
  /// Max MMS message size in bytes (int type)
  static const MMS_CONFIG_MAX_MESSAGE_SIZE = "maxMessageSize";

  /// from: static public final java.lang.String MMS_CONFIG_MESSAGE_TEXT_MAX_SIZE
  ///
  /// Max message text size (int type)
  static const MMS_CONFIG_MESSAGE_TEXT_MAX_SIZE = "maxMessageTextSize";

  /// from: static public final java.lang.String MMS_CONFIG_MMS_DELIVERY_REPORT_ENABLED
  ///
  /// Whether MMS delivery report is enabled (boolean type)
  static const MMS_CONFIG_MMS_DELIVERY_REPORT_ENABLED =
      "enableMMSDeliveryReports";

  /// from: static public final java.lang.String MMS_CONFIG_MMS_ENABLED
  ///
  /// Whether MMS is enabled for the current carrier (boolean type)
  static const MMS_CONFIG_MMS_ENABLED = "enabledMMS";

  /// from: static public final java.lang.String MMS_CONFIG_MMS_READ_REPORT_ENABLED
  ///
  /// Whether MMS read report is enabled (boolean type)
  static const MMS_CONFIG_MMS_READ_REPORT_ENABLED = "enableMMSReadReports";

  /// from: static public final java.lang.String MMS_CONFIG_MULTIPART_SMS_ENABLED
  ///
  /// Whether multipart SMS is enabled (boolean type)
  static const MMS_CONFIG_MULTIPART_SMS_ENABLED = "enableMultipartSMS";

  /// from: static public final java.lang.String MMS_CONFIG_NAI_SUFFIX
  ///
  /// The suffix to append to the NAI header value for MMS HTTP request (String type)
  static const MMS_CONFIG_NAI_SUFFIX = "naiSuffix";

  /// from: static public final java.lang.String MMS_CONFIG_NOTIFY_WAP_MMSC_ENABLED
  ///
  /// If this is enabled, M-NotifyResp.ind should be sent to the WAP Push content location instead
  /// of the default MMSC (boolean type)
  static const MMS_CONFIG_NOTIFY_WAP_MMSC_ENABLED = "enabledNotifyWapMMSC";

  /// from: static public final java.lang.String MMS_CONFIG_RECIPIENT_LIMIT
  ///
  /// Limit of recipients of MMS messages (int type)
  static const MMS_CONFIG_RECIPIENT_LIMIT = "recipientLimit";

  /// from: static public final java.lang.String MMS_CONFIG_SEND_MULTIPART_SMS_AS_SEPARATE_MESSAGES
  ///
  /// Whether multipart SMS should be sent as separate messages
  static const MMS_CONFIG_SEND_MULTIPART_SMS_AS_SEPARATE_MESSAGES =
      "sendMultipartSmsAsSeparateMessages";

  /// from: static public final java.lang.String MMS_CONFIG_SHOW_CELL_BROADCAST_APP_LINKS
  ///
  /// If true, show the cell broadcast (amber alert) in the SMS settings. Some carriers don't want
  /// this shown. (Boolean type)
  static const MMS_CONFIG_SHOW_CELL_BROADCAST_APP_LINKS =
      "config_cellBroadcastAppLinks";

  /// from: static public final java.lang.String MMS_CONFIG_SMS_DELIVERY_REPORT_ENABLED
  ///
  /// Whether SMS delivery report is enabled (boolean type)
  static const MMS_CONFIG_SMS_DELIVERY_REPORT_ENABLED =
      "enableSMSDeliveryReports";

  /// from: static public final java.lang.String MMS_CONFIG_SMS_TO_MMS_TEXT_LENGTH_THRESHOLD
  ///
  /// Some carriers require SMS to be converted into MMS when text length reaches this threshold
  /// (int type)
  static const MMS_CONFIG_SMS_TO_MMS_TEXT_LENGTH_THRESHOLD =
      "smsToMmsTextLengthThreshold";

  /// from: static public final java.lang.String MMS_CONFIG_SMS_TO_MMS_TEXT_THRESHOLD
  ///
  /// When the number of parts of a multipart SMS reaches this threshold, it should be converted
  /// into an MMS (int type)
  static const MMS_CONFIG_SMS_TO_MMS_TEXT_THRESHOLD = "smsToMmsTextThreshold";

  /// from: static public final java.lang.String MMS_CONFIG_SUBJECT_MAX_LENGTH
  ///
  /// Max message subject length (int type)
  static const MMS_CONFIG_SUBJECT_MAX_LENGTH = "maxSubjectLength";

  /// from: static public final java.lang.String MMS_CONFIG_SUPPORT_HTTP_CHARSET_HEADER
  ///
  /// Whether the carrier MMSC supports charset field in Content-Type header. If this is false,
  /// then we don't add "charset" to "Content-Type"
  static const MMS_CONFIG_SUPPORT_HTTP_CHARSET_HEADER =
      "supportHttpCharsetHeader";

  /// from: static public final java.lang.String MMS_CONFIG_SUPPORT_MMS_CONTENT_DISPOSITION
  ///
  /// Whether content-disposition field should be expected in an MMS PDU (boolean type)
  static const MMS_CONFIG_SUPPORT_MMS_CONTENT_DISPOSITION =
      "supportMmsContentDisposition";

  /// from: static public final java.lang.String MMS_CONFIG_UA_PROF_TAG_NAME
  ///
  /// The name of the UA Prof URL HTTP header for MMS HTTP request (String type)
  static const MMS_CONFIG_UA_PROF_TAG_NAME = "uaProfTagName";

  /// from: static public final java.lang.String MMS_CONFIG_UA_PROF_URL
  ///
  /// The UA Profile URL header value for MMS HTTP request (String type)
  static const MMS_CONFIG_UA_PROF_URL = "uaProfUrl";

  /// from: static public final java.lang.String MMS_CONFIG_USER_AGENT
  ///
  /// The User-Agent header value for MMS HTTP request (String type)
  static const MMS_CONFIG_USER_AGENT = "userAgent";

  /// from: static public final int MMS_ERROR_CONFIGURATION_ERROR
  static const MMS_ERROR_CONFIGURATION_ERROR = 7;

  /// from: static public final int MMS_ERROR_HTTP_FAILURE
  static const MMS_ERROR_HTTP_FAILURE = 4;

  /// from: static public final int MMS_ERROR_INVALID_APN
  static const MMS_ERROR_INVALID_APN = 2;

  /// from: static public final int MMS_ERROR_IO_ERROR
  static const MMS_ERROR_IO_ERROR = 5;

  /// from: static public final int MMS_ERROR_NO_DATA_NETWORK
  static const MMS_ERROR_NO_DATA_NETWORK = 8;

  /// from: static public final int MMS_ERROR_RETRY
  static const MMS_ERROR_RETRY = 6;

  /// from: static public final int MMS_ERROR_UNABLE_CONNECT_MMS
  static const MMS_ERROR_UNABLE_CONNECT_MMS = 3;

  /// from: static public final int MMS_ERROR_UNSPECIFIED
  static const MMS_ERROR_UNSPECIFIED = 1;

  /// from: static public final int RESULT_ERROR_GENERIC_FAILURE
  ///
  /// Generic failure cause
  static const RESULT_ERROR_GENERIC_FAILURE = 1;

  /// from: static public final int RESULT_ERROR_LIMIT_EXCEEDED
  ///
  /// Failed because we reached the sending queue limit.
  static const RESULT_ERROR_LIMIT_EXCEEDED = 5;

  /// from: static public final int RESULT_ERROR_NO_SERVICE
  ///
  /// Failed because service is currently unavailable
  static const RESULT_ERROR_NO_SERVICE = 4;

  /// from: static public final int RESULT_ERROR_NULL_PDU
  ///
  /// Failed because no pdu provided
  static const RESULT_ERROR_NULL_PDU = 3;

  /// from: static public final int RESULT_ERROR_RADIO_OFF
  ///
  /// Failed because radio was explicitly turned off
  static const RESULT_ERROR_RADIO_OFF = 2;

  /// from: static public final int RESULT_ERROR_SHORT_CODE_NEVER_ALLOWED
  ///
  /// Failed because the user has denied this app ever send premium short codes.
  static const RESULT_ERROR_SHORT_CODE_NEVER_ALLOWED = 8;

  /// from: static public final int RESULT_ERROR_SHORT_CODE_NOT_ALLOWED
  ///
  /// Failed because user denied the sending of this short code.
  static const RESULT_ERROR_SHORT_CODE_NOT_ALLOWED = 7;

  /// from: static public final int STATUS_ON_ICC_FREE
  ///
  /// Free space (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27).
  static const STATUS_ON_ICC_FREE = 0;

  /// from: static public final int STATUS_ON_ICC_READ
  ///
  /// Received and read (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27).
  static const STATUS_ON_ICC_READ = 1;

  /// from: static public final int STATUS_ON_ICC_SENT
  ///
  /// Stored and sent (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27).
  static const STATUS_ON_ICC_SENT = 5;

  /// from: static public final int STATUS_ON_ICC_UNREAD
  ///
  /// Received and unread (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27).
  static const STATUS_ON_ICC_UNREAD = 3;

  /// from: static public final int STATUS_ON_ICC_UNSENT
  ///
  /// Stored and unsent (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27).
  static const STATUS_ON_ICC_UNSENT = 7;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: void <init>(int subId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SmsManager(int subId)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [subId]).object);

  static final _id_sendTextMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "sendTextMessage",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Landroid/app/PendingIntent;Landroid/app/PendingIntent;)V");

  /// from: public void sendTextMessage(java.lang.String destinationAddress, java.lang.String scAddress, java.lang.String text, android.app.PendingIntent sentIntent, android.app.PendingIntent deliveryIntent)
  ///
  /// Send a text based SMS.
  ///
  /// <p class="note"><strong>Note:</strong> Using this method requires that your app has the
  /// android.Manifest.permission\#SEND_SMS permission.
  ///
  ///
  /// <p class="note"><strong>Note:</strong> Beginning with Android 4.4 (API level 19), if
  /// _and only if_ an app is not selected as the default SMS app, the system automatically
  /// writes messages sent using this method to the SMS Provider (the default SMS app is always
  /// responsible for writing its sent messages to the SMS Provider). For information about
  /// how to behave as the default SMS app, see android.provider.Telephony.
  ///
  ///@param destinationAddress the address to send the message to
  ///@param scAddress is the service center address or null to use
  ///  the current default SMSC
  ///@param text the body of the message to send
  ///@param sentIntent if not NULL this <code>PendingIntent</code> is
  ///  broadcast when the message is successfully sent, or failed.
  ///  The result code will be <code>Activity.RESULT_OK</code> for success,
  ///  or one of these errors:<br>
  ///  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
  ///  <code>RESULT_ERROR_RADIO_OFF</code><br>
  ///  <code>RESULT_ERROR_NULL_PDU</code><br>
  ///  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
  ///  the extra "errorCode" containing a radio technology specific value,
  ///  generally only useful for troubleshooting.<br>
  ///  The per-application based SMS control checks sentIntent. If sentIntent
  ///  is NULL the caller will be checked against all unknown applications,
  ///  which cause smaller number of SMS to be sent in checking period.
  ///@param deliveryIntent if not NULL this <code>PendingIntent</code> is
  ///  broadcast when the message is delivered to the recipient.  The
  ///  raw pdu of the status report is in the extended data ("pdu").
  ///@throws IllegalArgumentException if destinationAddress or text are empty
  void sendTextMessage(
          jni.JniString destinationAddress,
          jni.JniString scAddress,
          jni.JniString text,
          pendingintent_.PendingIntent sentIntent,
          pendingintent_.PendingIntent deliveryIntent) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_sendTextMessage, jni.JniType.voidType, [
        destinationAddress.reference,
        scAddress.reference,
        text.reference,
        sentIntent.reference,
        deliveryIntent.reference
      ]).check();

  static final _id_sendTextMessageWithoutPersisting = jniAccessors.getMethodIDOf(
      _classRef,
      "sendTextMessageWithoutPersisting",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Landroid/app/PendingIntent;Landroid/app/PendingIntent;)V");

  /// from: public void sendTextMessageWithoutPersisting(java.lang.String destinationAddress, java.lang.String scAddress, java.lang.String text, android.app.PendingIntent sentIntent, android.app.PendingIntent deliveryIntent)
  ///
  /// Send a text based SMS without writing it into the SMS Provider.
  ///
  ///
  /// The message will be sent directly over the network and will not be visible in SMS
  /// applications. Intended for internal carrier use only.
  ///
  ///
  ///
  /// Requires Permission: Both android.Manifest.permission\#SEND_SMS and
  /// android.Manifest.permission\#MODIFY_PHONE_STATE, or that the calling app has carrier
  /// privileges (see TelephonyManager\#hasCarrierPrivileges), or that the calling app is
  /// the default IMS app (see
  /// CarrierConfigManager\#KEY_CONFIG_IMS_PACKAGE_OVERRIDE_STRING).
  ///
  /// Requires android.Manifest.permission\#MODIFY_PHONE_STATE and android.Manifest.permission\#SEND_SMS
  ///@see \#sendTextMessage(String, String, String, PendingIntent, PendingIntent)
  void sendTextMessageWithoutPersisting(
          jni.JniString destinationAddress,
          jni.JniString scAddress,
          jni.JniString text,
          pendingintent_.PendingIntent sentIntent,
          pendingintent_.PendingIntent deliveryIntent) =>
      jniAccessors.callMethodWithArgs(reference,
          _id_sendTextMessageWithoutPersisting, jni.JniType.voidType, [
        destinationAddress.reference,
        scAddress.reference,
        text.reference,
        sentIntent.reference,
        deliveryIntent.reference
      ]).check();

  static final _id_injectSmsPdu = jniAccessors.getMethodIDOf(_classRef,
      "injectSmsPdu", "([BLjava/lang/String;Landroid/app/PendingIntent;)V");

  /// from: public void injectSmsPdu(byte[] pdu, java.lang.String format, android.app.PendingIntent receivedIntent)
  ///
  /// Inject an SMS PDU into the android application framework.
  ///
  /// Requires permission: android.Manifest.permission\#MODIFY_PHONE_STATE or carrier
  /// privileges per android.telephony.TelephonyManager\#hasCarrierPrivileges.
  ///@param pdu is the byte array of pdu to be injected into android application framework
  ///@param format is the format of SMS pdu (SmsMessage\#FORMAT_3GPP or
  ///  SmsMessage\#FORMAT_3GPP2)
  /// Value is android.telephony.SmsMessage\#FORMAT_3GPP, or android.telephony.SmsMessage\#FORMAT_3GPP2
  ///@param receivedIntent if not NULL this <code>PendingIntent</code> is
  ///  broadcast when the message is successfully received by the
  ///  android application framework, or failed. This intent is broadcasted at
  ///  the same time an SMS received from radio is acknowledged back.
  ///  The result code will be android.provider.Telephony.Sms.Intents\#RESULT_SMS_HANDLED
  ///  for success, or android.provider.Telephony.Sms.Intents\#RESULT_SMS_GENERIC_ERROR for
  ///  error.
  ///@throws IllegalArgumentException if the format is invalid.
  void injectSmsPdu(jni.JniObject pdu, jni.JniString format,
          pendingintent_.PendingIntent receivedIntent) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_injectSmsPdu,
          jni.JniType.voidType,
          [pdu.reference, format.reference, receivedIntent.reference]).check();

  static final _id_divideMessage = jniAccessors.getMethodIDOf(
      _classRef, "divideMessage", "(Ljava/lang/String;)Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList<java.lang.String> divideMessage(java.lang.String text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Divide a message text into several fragments, none bigger than
  /// the maximum SMS message size.
  ///@param text the original message.  Must not be null.
  ///@return an <code>ArrayList</code> of strings that, in order,
  ///   comprise the original message
  ///@throws IllegalArgumentException if text is null
  jni.JniObject divideMessage(jni.JniString text) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_divideMessage, jni.JniType.objectType, [text.reference]).object);

  static final _id_sendMultipartTextMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "sendMultipartTextMessage",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/util/ArrayList;Ljava/util/ArrayList;Ljava/util/ArrayList;)V");

  /// from: public void sendMultipartTextMessage(java.lang.String destinationAddress, java.lang.String scAddress, java.util.ArrayList<java.lang.String> parts, java.util.ArrayList<android.app.PendingIntent> sentIntents, java.util.ArrayList<android.app.PendingIntent> deliveryIntents)
  ///
  /// Send a multi-part text based SMS.  The callee should have already
  /// divided the message into correctly sized parts by calling
  /// <code>divideMessage</code>.
  ///
  /// <p class="note"><strong>Note:</strong> Using this method requires that your app has the
  /// android.Manifest.permission\#SEND_SMS permission.
  ///
  ///
  /// <p class="note"><strong>Note:</strong> Beginning with Android 4.4 (API level 19), if
  /// _and only if_ an app is not selected as the default SMS app, the system automatically
  /// writes messages sent using this method to the SMS Provider (the default SMS app is always
  /// responsible for writing its sent messages to the SMS Provider). For information about
  /// how to behave as the default SMS app, see android.provider.Telephony.
  ///
  ///@param destinationAddress the address to send the message to
  ///@param scAddress is the service center address or null to use
  ///   the current default SMSC
  ///@param parts an <code>ArrayList</code> of strings that, in order,
  ///   comprise the original message
  ///@param sentIntents if not null, an <code>ArrayList</code> of
  ///   <code>PendingIntent</code>s (one for each message part) that is
  ///   broadcast when the corresponding message part has been sent.
  ///   The result code will be <code>Activity.RESULT_OK</code> for success,
  ///   or one of these errors:<br>
  ///   <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
  ///   <code>RESULT_ERROR_RADIO_OFF</code><br>
  ///   <code>RESULT_ERROR_NULL_PDU</code><br>
  ///   For <code>RESULT_ERROR_GENERIC_FAILURE</code> each sentIntent may include
  ///   the extra "errorCode" containing a radio technology specific value,
  ///   generally only useful for troubleshooting.<br>
  ///   The per-application based SMS control checks sentIntent. If sentIntent
  ///   is NULL the caller will be checked against all unknown applications,
  ///   which cause smaller number of SMS to be sent in checking period.
  ///@param deliveryIntents if not null, an <code>ArrayList</code> of
  ///   <code>PendingIntent</code>s (one for each message part) that is
  ///   broadcast when the corresponding message part has been delivered
  ///   to the recipient.  The raw pdu of the status report is in the
  ///   extended data ("pdu").
  ///@throws IllegalArgumentException if destinationAddress or data are empty
  void sendMultipartTextMessage(
          jni.JniString destinationAddress,
          jni.JniString scAddress,
          jni.JniObject parts,
          jni.JniObject sentIntents,
          jni.JniObject deliveryIntents) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_sendMultipartTextMessage, jni.JniType.voidType, [
        destinationAddress.reference,
        scAddress.reference,
        parts.reference,
        sentIntents.reference,
        deliveryIntents.reference
      ]).check();

  static final _id_sendDataMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "sendDataMessage",
      "(Ljava/lang/String;Ljava/lang/String;S[BLandroid/app/PendingIntent;Landroid/app/PendingIntent;)V");

  /// from: public void sendDataMessage(java.lang.String destinationAddress, java.lang.String scAddress, short destinationPort, byte[] data, android.app.PendingIntent sentIntent, android.app.PendingIntent deliveryIntent)
  ///
  /// Send a data based SMS to a specific application port.
  ///
  /// <p class="note"><strong>Note:</strong> Using this method requires that your app has the
  /// android.Manifest.permission\#SEND_SMS permission.
  ///
  ///@param destinationAddress the address to send the message to
  ///@param scAddress is the service center address or null to use
  ///  the current default SMSC
  ///@param destinationPort the port to deliver the message to
  ///@param data the body of the message to send
  ///@param sentIntent if not NULL this <code>PendingIntent</code> is
  ///  broadcast when the message is successfully sent, or failed.
  ///  The result code will be <code>Activity.RESULT_OK</code> for success,
  ///  or one of these errors:<br>
  ///  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
  ///  <code>RESULT_ERROR_RADIO_OFF</code><br>
  ///  <code>RESULT_ERROR_NULL_PDU</code><br>
  ///  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
  ///  the extra "errorCode" containing a radio technology specific value,
  ///  generally only useful for troubleshooting.<br>
  ///  The per-application based SMS control checks sentIntent. If sentIntent
  ///  is NULL the caller will be checked against all unknown applications,
  ///  which cause smaller number of SMS to be sent in checking period.
  ///@param deliveryIntent if not NULL this <code>PendingIntent</code> is
  ///  broadcast when the message is delivered to the recipient.  The
  ///  raw pdu of the status report is in the extended data ("pdu").
  ///@throws IllegalArgumentException if destinationAddress or data are empty
  void sendDataMessage(
          jni.JniString destinationAddress,
          jni.JniString scAddress,
          int destinationPort,
          jni.JniObject data,
          pendingintent_.PendingIntent sentIntent,
          pendingintent_.PendingIntent deliveryIntent) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_sendDataMessage, jni.JniType.voidType, [
        destinationAddress.reference,
        scAddress.reference,
        destinationPort,
        data.reference,
        sentIntent.reference,
        deliveryIntent.reference
      ]).check();

  static final _id_getDefault = jniAccessors.getStaticMethodIDOf(
      _classRef, "getDefault", "()Landroid/telephony/SmsManager;");

  /// from: static public android.telephony.SmsManager getDefault()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the SmsManager associated with the default subscription id. The instance will always be
  /// associated with the default subscription id, even if the default subscription id is changed.
  ///@return the SmsManager associated with the default subscription id
  static SmsManager getDefault() =>
      SmsManager.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getDefault, jni.JniType.objectType, []).object);

  static final _id_getSmsManagerForSubscriptionId =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "getSmsManagerForSubscriptionId",
          "(I)Landroid/telephony/SmsManager;");

  /// from: static public android.telephony.SmsManager getSmsManagerForSubscriptionId(int subId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the the instance of the SmsManager associated with a particular subscription id
  ///@param subId an SMS subscription id, typically accessed using
  ///   android.telephony.SubscriptionManager
  ///@return the instance of the SmsManager associated with subId
  static SmsManager getSmsManagerForSubscriptionId(int subId) =>
      SmsManager.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getSmsManagerForSubscriptionId,
          jni.JniType.objectType,
          [subId]).object);

  static final _id_getSubscriptionId =
      jniAccessors.getMethodIDOf(_classRef, "getSubscriptionId", "()I");

  /// from: public int getSubscriptionId()
  ///
  /// Get the associated subscription id. If the instance was returned by \#getDefault(),
  /// then this method may return different values at different points in time (if the user
  /// changes the default subscription id). It will return < 0 if the default subscription id
  /// cannot be determined.
  ///
  /// Additionally, to support legacy applications that are not multi-SIM aware,
  /// if the following are true:
  ///     - We are using a multi-SIM device
  ///     - A default SMS SIM has not been selected
  ///     - At least one SIM subscription is available
  /// then ask the user to set the default SMS SIM.
  ///@return associated subscription id
  int getSubscriptionId() => jniAccessors.callMethodWithArgs(
      reference, _id_getSubscriptionId, jni.JniType.intType, []).integer;

  static final _id_getDefaultSmsSubscriptionId = jniAccessors
      .getStaticMethodIDOf(_classRef, "getDefaultSmsSubscriptionId", "()I");

  /// from: static public int getDefaultSmsSubscriptionId()
  ///
  /// Get default sms subscription id
  ///@return the default SMS subscription id
  static int getDefaultSmsSubscriptionId() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getDefaultSmsSubscriptionId, jni.JniType.intType, []).integer;

  static final _id_sendMultimediaMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "sendMultimediaMessage",
      "(Landroid/content/Context;Landroid/net/Uri;Ljava/lang/String;Landroid/os/Bundle;Landroid/app/PendingIntent;)V");

  /// from: public void sendMultimediaMessage(android.content.Context context, android.net.Uri contentUri, java.lang.String locationUrl, android.os.Bundle configOverrides, android.app.PendingIntent sentIntent)
  ///
  /// Send an MMS message
  ///@param context application context
  ///@param contentUri the content Uri from which the message pdu will be read
  ///@param locationUrl the optional location url where message should be sent to
  ///@param configOverrides the carrier-specific messaging configuration values to override for
  ///  sending the message.
  ///@param sentIntent if not NULL this <code>PendingIntent</code> is
  ///  broadcast when the message is successfully sent, or failed
  ///@throws IllegalArgumentException if contentUri is empty
  void sendMultimediaMessage(
          context_.Context context,
          uri_.Uri contentUri,
          jni.JniString locationUrl,
          bundle_.Bundle configOverrides,
          pendingintent_.PendingIntent sentIntent) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_sendMultimediaMessage, jni.JniType.voidType, [
        context.reference,
        contentUri.reference,
        locationUrl.reference,
        configOverrides.reference,
        sentIntent.reference
      ]).check();

  static final _id_downloadMultimediaMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "downloadMultimediaMessage",
      "(Landroid/content/Context;Ljava/lang/String;Landroid/net/Uri;Landroid/os/Bundle;Landroid/app/PendingIntent;)V");

  /// from: public void downloadMultimediaMessage(android.content.Context context, java.lang.String locationUrl, android.net.Uri contentUri, android.os.Bundle configOverrides, android.app.PendingIntent downloadedIntent)
  ///
  /// Download an MMS message from carrier by a given location URL
  ///@param context application context
  ///@param locationUrl the location URL of the MMS message to be downloaded, usually obtained
  ///  from the MMS WAP push notification
  ///@param contentUri the content uri to which the downloaded pdu will be written
  ///@param configOverrides the carrier-specific messaging configuration values to override for
  ///  downloading the message.
  ///@param downloadedIntent if not NULL this <code>PendingIntent</code> is
  ///  broadcast when the message is downloaded, or the download is failed
  ///@throws IllegalArgumentException if locationUrl or contentUri is empty
  void downloadMultimediaMessage(
          context_.Context context,
          jni.JniString locationUrl,
          uri_.Uri contentUri,
          bundle_.Bundle configOverrides,
          pendingintent_.PendingIntent downloadedIntent) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_downloadMultimediaMessage, jni.JniType.voidType, [
        context.reference,
        locationUrl.reference,
        contentUri.reference,
        configOverrides.reference,
        downloadedIntent.reference
      ]).check();

  static final _id_getCarrierConfigValues = jniAccessors.getMethodIDOf(
      _classRef, "getCarrierConfigValues", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getCarrierConfigValues()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get carrier-dependent configuration values.
  ///@return bundle key/values pairs of configuration values
  bundle_.Bundle getCarrierConfigValues() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCarrierConfigValues, jni.JniType.objectType, []).object);

  static final _id_createAppSpecificSmsToken = jniAccessors.getMethodIDOf(
      _classRef,
      "createAppSpecificSmsToken",
      "(Landroid/app/PendingIntent;)Ljava/lang/String;");

  /// from: public java.lang.String createAppSpecificSmsToken(android.app.PendingIntent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a single use app specific incoming SMS request for the the calling package.
  ///
  /// This method returns a token that if included in a subsequent incoming SMS message will cause
  /// {@code intent} to be sent with the SMS data.
  ///
  /// The token is only good for one use, after an SMS has been received containing the token all
  /// subsequent SMS messages with the token will be routed as normal.
  ///
  /// An app can only have one request at a time, if the app already has a request pending it will
  /// be replaced with a new request.
  ///@return Token to include in an SMS message. The token will be 11 characters long.
  ///@see android.provider.Telephony.Sms.Intents\#getMessagesFromIntent
  jni.JniString createAppSpecificSmsToken(
          pendingintent_.PendingIntent intent) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createAppSpecificSmsToken,
          jni.JniType.objectType,
          [intent.reference]).object);
}
