// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Intent.dart" as intent_;

import "../content/Context.dart" as context_;

import "../text/Editable.dart" as editable_;

import "../text/Spannable.dart" as spannable_;

import "../text/style/TtsSpan.dart" as ttsspan_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.telephony.PhoneNumberUtils
///
/// Various utilities for dealing with phone number strings.
class PhoneNumberUtils extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/telephony/PhoneNumberUtils");
  PhoneNumberUtils.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int BCD_EXTENDED_TYPE_CALLED_PARTY
  static const BCD_EXTENDED_TYPE_CALLED_PARTY = 2;

  /// from: static public final int BCD_EXTENDED_TYPE_EF_ADN
  static const BCD_EXTENDED_TYPE_EF_ADN = 1;

  /// from: static public final int FORMAT_JAPAN
  ///
  /// Japanese formatting
  static const FORMAT_JAPAN = 2;

  /// from: static public final int FORMAT_NANP
  ///
  /// NANP formatting
  static const FORMAT_NANP = 1;

  /// from: static public final int FORMAT_UNKNOWN
  ///
  /// The current locale is unknown, look for a country code or don't format
  static const FORMAT_UNKNOWN = 0;

  /// from: static public final char PAUSE
  static const PAUSE = ",";

  /// from: static public final int TOA_International
  static const TOA_International = 145;

  /// from: static public final int TOA_Unknown
  static const TOA_Unknown = 129;

  /// from: static public final char WAIT
  static const WAIT = ";";

  /// from: static public final char WILD
  static const WILD = "N";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  PhoneNumberUtils()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_isISODigit =
      jniAccessors.getStaticMethodIDOf(_classRef, "isISODigit", "(C)Z");

  /// from: static public boolean isISODigit(char c)
  ///
  /// True if c is ISO-LATIN characters 0-9
  static bool isISODigit(int c) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_isISODigit, jni.JniType.booleanType, [c]).boolean;

  static final _id_is12Key =
      jniAccessors.getStaticMethodIDOf(_classRef, "is12Key", "(C)Z");

  /// from: static public final boolean is12Key(char c)
  ///
  /// True if c is ISO-LATIN characters 0-9, *, \#
  static bool is12Key(int c) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_is12Key, jni.JniType.booleanType, [c]).boolean;

  static final _id_isDialable =
      jniAccessors.getStaticMethodIDOf(_classRef, "isDialable", "(C)Z");

  /// from: static public final boolean isDialable(char c)
  ///
  /// True if c is ISO-LATIN characters 0-9, *, \# , +, WILD
  static bool isDialable(int c) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_isDialable, jni.JniType.booleanType, [c]).boolean;

  static final _id_isReallyDialable =
      jniAccessors.getStaticMethodIDOf(_classRef, "isReallyDialable", "(C)Z");

  /// from: static public final boolean isReallyDialable(char c)
  ///
  /// True if c is ISO-LATIN characters 0-9, *, \# , + (no WILD)
  static bool isReallyDialable(int c) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_isReallyDialable, jni.JniType.booleanType, [c]).boolean;

  static final _id_isNonSeparator =
      jniAccessors.getStaticMethodIDOf(_classRef, "isNonSeparator", "(C)Z");

  /// from: static public final boolean isNonSeparator(char c)
  ///
  /// True if c is ISO-LATIN characters 0-9, *, \# , +, WILD, WAIT, PAUSE
  static bool isNonSeparator(int c) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_isNonSeparator, jni.JniType.booleanType, [c]).boolean;

  static final _id_isStartsPostDial =
      jniAccessors.getStaticMethodIDOf(_classRef, "isStartsPostDial", "(C)Z");

  /// from: static public final boolean isStartsPostDial(char c)
  ///
  /// This any anything to the right of this char is part of the
  ///  post-dial string (eg this is PAUSE or WAIT)
  static bool isStartsPostDial(int c) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_isStartsPostDial, jni.JniType.booleanType, [c]).boolean;

  static final _id_getNumberFromIntent = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getNumberFromIntent",
      "(Landroid/content/Intent;Landroid/content/Context;)Ljava/lang/String;");

  /// from: static public java.lang.String getNumberFromIntent(android.content.Intent intent, android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Extracts the phone number from an Intent.
  ///@param intent the intent to get the number of
  ///@param context a context to use for database access
  ///@return the phone number that would be called by the intent, or
  ///         <code>null</code> if the number cannot be found.
  static jni.JniString getNumberFromIntent(
          intent_.Intent intent, context_.Context context) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getNumberFromIntent,
          jni.JniType.objectType,
          [intent.reference, context.reference]).object);

  static final _id_extractNetworkPortion = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "extractNetworkPortion",
      "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String extractNetworkPortion(java.lang.String phoneNumber)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Extracts the network address portion and canonicalizes
  ///  (filters out separators.)
  ///  Network address portion is everything up to DTMF control digit
  ///  separators (pause or wait), but without non-dialable characters.
  ///
  ///  Please note that the GSM wild character is allowed in the result.
  ///  This must be resolved before dialing.
  ///
  ///  Returns null if phoneNumber == null
  static jni.JniString extractNetworkPortion(jni.JniString phoneNumber) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_extractNetworkPortion,
          jni.JniType.objectType,
          [phoneNumber.reference]).object);

  static final _id_stripSeparators = jniAccessors.getStaticMethodIDOf(
      _classRef, "stripSeparators", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String stripSeparators(java.lang.String phoneNumber)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Strips separators from a phone number string.
  ///@param phoneNumber phone number to strip.
  ///@return phone string stripped of separators.
  static jni.JniString stripSeparators(jni.JniString phoneNumber) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_stripSeparators,
          jni.JniType.objectType,
          [phoneNumber.reference]).object);

  static final _id_extractPostDialPortion = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "extractPostDialPortion",
      "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String extractPostDialPortion(java.lang.String phoneNumber)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Extracts the post-dial sequence of DTMF control digits, pauses, and
  /// waits. Strips separators. This string may be empty, but will not be null
  /// unless phoneNumber == null.
  ///
  /// Returns null if phoneNumber == null
  static jni.JniString extractPostDialPortion(jni.JniString phoneNumber) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_extractPostDialPortion,
          jni.JniType.objectType,
          [phoneNumber.reference]).object);

  static final _id_compare = jniAccessors.getStaticMethodIDOf(
      _classRef, "compare", "(Ljava/lang/String;Ljava/lang/String;)Z");

  /// from: static public boolean compare(java.lang.String a, java.lang.String b)
  ///
  /// Compare phone numbers a and b, return true if they're identical enough for caller ID purposes.
  static bool compare(jni.JniString a, jni.JniString b) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_compare,
          jni.JniType.booleanType, [a.reference, b.reference]).boolean;

  static final _id_compare1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "compare",
      "(Landroid/content/Context;Ljava/lang/String;Ljava/lang/String;)Z");

  /// from: static public boolean compare(android.content.Context context, java.lang.String a, java.lang.String b)
  ///
  /// Compare phone numbers a and b, and return true if they're identical
  /// enough for caller ID purposes. Checks a resource to determine whether
  /// to use a strict or loose comparison algorithm.
  static bool compare1(
          context_.Context context, jni.JniString a, jni.JniString b) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_compare1,
          jni.JniType.booleanType,
          [context.reference, a.reference, b.reference]).boolean;

  static final _id_toCallerIDMinMatch = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "toCallerIDMinMatch",
      "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String toCallerIDMinMatch(java.lang.String phoneNumber)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the rightmost MIN_MATCH (5) characters in the network portion
  /// in *reversed* order
  ///
  /// This can be used to do a database lookup against the column
  /// that stores getStrippedReversed()
  ///
  /// Returns null if phoneNumber == null
  static jni.JniString toCallerIDMinMatch(jni.JniString phoneNumber) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_toCallerIDMinMatch,
          jni.JniType.objectType,
          [phoneNumber.reference]).object);

  static final _id_getStrippedReversed = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getStrippedReversed",
      "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String getStrippedReversed(java.lang.String phoneNumber)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the network portion reversed.
  /// This string is intended to go into an index column for a
  /// database lookup.
  ///
  /// Returns null if phoneNumber == null
  static jni.JniString getStrippedReversed(jni.JniString phoneNumber) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getStrippedReversed,
          jni.JniType.objectType,
          [phoneNumber.reference]).object);

  static final _id_stringFromStringAndTOA = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "stringFromStringAndTOA",
      "(Ljava/lang/String;I)Ljava/lang/String;");

  /// from: static public java.lang.String stringFromStringAndTOA(java.lang.String s, int TOA)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Basically: makes sure there's a + in front of a
  /// TOA_International number
  ///
  /// Returns null if s == null
  static jni.JniString stringFromStringAndTOA(jni.JniString s, int TOA) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_stringFromStringAndTOA,
          jni.JniType.objectType,
          [s.reference, TOA]).object);

  static final _id_toaFromString = jniAccessors.getStaticMethodIDOf(
      _classRef, "toaFromString", "(Ljava/lang/String;)I");

  /// from: static public int toaFromString(java.lang.String s)
  ///
  /// Returns the TOA for the given dial string
  /// Basically, returns TOA_International if there's a + prefix
  static int toaFromString(jni.JniString s) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_toaFromString,
          jni.JniType.intType, [s.reference]).integer;

  static final _id_calledPartyBCDToString = jniAccessors.getStaticMethodIDOf(
      _classRef, "calledPartyBCDToString", "([BII)Ljava/lang/String;");

  /// from: static public java.lang.String calledPartyBCDToString(byte[] bytes, int offset, int length)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// 3GPP TS 24.008 10.5.4.7
  ///  Called Party BCD Number
  ///
  ///  See Also TS 51.011 10.5.1 "dialing number/ssc string"
  ///  and TS 11.11 "10.3.1 EF adn (Abbreviated dialing numbers)"
  ///@param bytes the data buffer
  ///@param offset should point to the TOA (aka. TON/NPI) octet after the length byte
  ///@param length is the number of bytes including TOA byte
  ///                and must be at least 2
  ///@return partial string on invalid decode
  ///@deprecated use \#calledPartyBCDToString(byte[], int, int, int) instead. Calling this
  /// method is equivalent to calling \#calledPartyBCDToString(byte[], int, int) with
  /// \#BCD_EXTENDED_TYPE_EF_ADN as the extended type.
  static jni.JniString calledPartyBCDToString(
          jni.JniObject bytes, int offset, int length) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_calledPartyBCDToString,
          jni.JniType.objectType,
          [bytes.reference, offset, length]).object);

  static final _id_calledPartyBCDToString1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "calledPartyBCDToString", "([BIII)Ljava/lang/String;");

  /// from: static public java.lang.String calledPartyBCDToString(byte[] bytes, int offset, int length, int bcdExtType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// 3GPP TS 24.008 10.5.4.7
  ///  Called Party BCD Number
  ///
  ///  See Also TS 51.011 10.5.1 "dialing number/ssc string"
  ///  and TS 11.11 "10.3.1 EF adn (Abbreviated dialing numbers)"
  ///@param bytes the data buffer
  ///@param offset should point to the TOA (aka. TON/NPI) octet after the length byte
  ///@param length is the number of bytes including TOA byte
  ///                and must be at least 2
  ///@param bcdExtType used to determine the extended bcd coding
  /// Value is android.telephony.PhoneNumberUtils\#BCD_EXTENDED_TYPE_EF_ADN, or android.telephony.PhoneNumberUtils\#BCD_EXTENDED_TYPE_CALLED_PARTY
  ///@see \#BCD_EXTENDED_TYPE_EF_ADN
  ///@see \#BCD_EXTENDED_TYPE_CALLED_PARTY
  static jni.JniString calledPartyBCDToString1(
          jni.JniObject bytes, int offset, int length, int bcdExtType) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_calledPartyBCDToString1,
          jni.JniType.objectType,
          [bytes.reference, offset, length, bcdExtType]).object);

  static final _id_calledPartyBCDFragmentToString =
      jniAccessors.getStaticMethodIDOf(_classRef,
          "calledPartyBCDFragmentToString", "([BII)Ljava/lang/String;");

  /// from: static public java.lang.String calledPartyBCDFragmentToString(byte[] bytes, int offset, int length)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like calledPartyBCDToString, but field does not start with a
  /// TOA byte. For example: SIM ADN extension fields
  ///@deprecated use \#calledPartyBCDFragmentToString(byte[], int, int, int) instead.
  /// Calling this method is equivalent to calling
  /// \#calledPartyBCDFragmentToString(byte[], int, int, int) with
  /// \#BCD_EXTENDED_TYPE_EF_ADN as the extended type.
  static jni.JniString calledPartyBCDFragmentToString(
          jni.JniObject bytes, int offset, int length) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_calledPartyBCDFragmentToString,
          jni.JniType.objectType,
          [bytes.reference, offset, length]).object);

  static final _id_calledPartyBCDFragmentToString1 =
      jniAccessors.getStaticMethodIDOf(_classRef,
          "calledPartyBCDFragmentToString", "([BIII)Ljava/lang/String;");

  /// from: static public java.lang.String calledPartyBCDFragmentToString(byte[] bytes, int offset, int length, int bcdExtType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like calledPartyBCDToString, but field does not start with a
  /// TOA byte. For example: SIM ADN extension fields
  ///@param bcdExtType Value is android.telephony.PhoneNumberUtils\#BCD_EXTENDED_TYPE_EF_ADN, or android.telephony.PhoneNumberUtils\#BCD_EXTENDED_TYPE_CALLED_PARTY
  static jni.JniString calledPartyBCDFragmentToString1(
          jni.JniObject bytes, int offset, int length, int bcdExtType) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_calledPartyBCDFragmentToString1,
          jni.JniType.objectType,
          [bytes.reference, offset, length, bcdExtType]).object);

  static final _id_isWellFormedSmsAddress = jniAccessors.getStaticMethodIDOf(
      _classRef, "isWellFormedSmsAddress", "(Ljava/lang/String;)Z");

  /// from: static public boolean isWellFormedSmsAddress(java.lang.String address)
  ///
  /// Return true iff the network portion of <code>address</code> is,
  /// as far as we can tell on the device, suitable for use as an SMS
  /// destination address.
  static bool isWellFormedSmsAddress(jni.JniString address) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_isWellFormedSmsAddress,
          jni.JniType.booleanType,
          [address.reference]).boolean;

  static final _id_isGlobalPhoneNumber = jniAccessors.getStaticMethodIDOf(
      _classRef, "isGlobalPhoneNumber", "(Ljava/lang/String;)Z");

  /// from: static public boolean isGlobalPhoneNumber(java.lang.String phoneNumber)
  static bool isGlobalPhoneNumber(jni.JniString phoneNumber) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isGlobalPhoneNumber,
          jni.JniType.booleanType, [phoneNumber.reference]).boolean;

  static final _id_networkPortionToCalledPartyBCD =
      jniAccessors.getStaticMethodIDOf(_classRef,
          "networkPortionToCalledPartyBCD", "(Ljava/lang/String;)[B");

  /// from: static public byte[] networkPortionToCalledPartyBCD(java.lang.String s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Note: calls extractNetworkPortion(), so do not use for
  /// SIM EF[ADN] style records
  ///
  /// Returns null if network portion is empty.
  static jni.JniObject networkPortionToCalledPartyBCD(jni.JniString s) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_networkPortionToCalledPartyBCD,
          jni.JniType.objectType,
          [s.reference]).object);

  static final _id_networkPortionToCalledPartyBCDWithLength =
      jniAccessors.getStaticMethodIDOf(_classRef,
          "networkPortionToCalledPartyBCDWithLength", "(Ljava/lang/String;)[B");

  /// from: static public byte[] networkPortionToCalledPartyBCDWithLength(java.lang.String s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Same as \#networkPortionToCalledPartyBCD, but includes a
  /// one-byte length prefix.
  static jni.JniObject networkPortionToCalledPartyBCDWithLength(
          jni.JniString s) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_networkPortionToCalledPartyBCDWithLength,
          jni.JniType.objectType,
          [s.reference]).object);

  static final _id_numberToCalledPartyBCD = jniAccessors.getStaticMethodIDOf(
      _classRef, "numberToCalledPartyBCD", "(Ljava/lang/String;)[B");

  /// from: static public byte[] numberToCalledPartyBCD(java.lang.String number)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convert a dialing number to BCD byte array
  ///@param number dialing number string. If the dialing number starts with '+', set to
  /// international TOA
  ///@return BCD byte array
  ///@deprecated use \#numberToCalledPartyBCD(String, int) instead. Calling this method
  /// is equivalent to calling \#numberToCalledPartyBCD(String, int) with
  /// \#BCD_EXTENDED_TYPE_EF_ADN as the extended type.
  static jni.JniObject numberToCalledPartyBCD(jni.JniString number) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_numberToCalledPartyBCD,
          jni.JniType.objectType,
          [number.reference]).object);

  static final _id_numberToCalledPartyBCD1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "numberToCalledPartyBCD", "(Ljava/lang/String;I)[B");

  /// from: static public byte[] numberToCalledPartyBCD(java.lang.String number, int bcdExtType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convert a dialing number to BCD byte array
  ///@param number dialing number string. If the dialing number starts with '+', set to
  /// international TOA
  ///@param bcdExtType used to determine the extended bcd coding
  /// Value is android.telephony.PhoneNumberUtils\#BCD_EXTENDED_TYPE_EF_ADN, or android.telephony.PhoneNumberUtils\#BCD_EXTENDED_TYPE_CALLED_PARTY
  ///@see \#BCD_EXTENDED_TYPE_EF_ADN
  ///@see \#BCD_EXTENDED_TYPE_CALLED_PARTY
  ///@return BCD byte array
  static jni.JniObject numberToCalledPartyBCD1(
          jni.JniString number, int bcdExtType) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_numberToCalledPartyBCD1,
          jni.JniType.objectType,
          [number.reference, bcdExtType]).object);

  static final _id_formatNumber = jniAccessors.getStaticMethodIDOf(
      _classRef, "formatNumber", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String formatNumber(java.lang.String source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Breaks the given number down and formats it according to the rules
  /// for the country the number is from.
  ///@param source The phone number to format
  ///@return A locally acceptable formatting of the input, or the raw input if
  ///  formatting rules aren't known for the number
  ///@deprecated Use link \#formatNumber(String phoneNumber, String defaultCountryIso) instead
  static jni.JniString formatNumber(jni.JniString source) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_formatNumber, jni.JniType.objectType, [source.reference]).object);

  static final _id_getFormatTypeForLocale = jniAccessors.getStaticMethodIDOf(
      _classRef, "getFormatTypeForLocale", "(Ljava/util/Locale;)I");

  /// from: static public int getFormatTypeForLocale(java.util.Locale locale)
  ///
  /// Returns the phone number formatting type for the given locale.
  ///@param locale The locale of interest, usually Locale\#getDefault()
  ///@return The formatting type for the given locale, or FORMAT_UNKNOWN if the formatting
  /// rules are not known for the given locale
  ///@deprecated Use link \#formatNumber(String phoneNumber, String defaultCountryIso) instead
  static int getFormatTypeForLocale(jni.JniObject locale) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getFormatTypeForLocale,
          jni.JniType.intType,
          [locale.reference]).integer;

  static final _id_formatNumber1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "formatNumber", "(Landroid/text/Editable;I)V");

  /// from: static public void formatNumber(android.text.Editable text, int defaultFormattingType)
  ///
  /// Formats a phone number in-place. Currently \#FORMAT_JAPAN and \#FORMAT_NANP
  /// is supported as a second argument.
  ///@param text The number to be formatted, will be modified with the formatting
  ///@param defaultFormattingType The default formatting rules to apply if the number does
  /// not begin with +[country_code]
  ///@deprecated Use link \#formatNumber(String phoneNumber, String defaultCountryIso) instead
  static void formatNumber1(
          editable_.Editable text, int defaultFormattingType) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_formatNumber1,
          jni.JniType.voidType,
          [text.reference, defaultFormattingType]).check();

  static final _id_formatNanpNumber = jniAccessors.getStaticMethodIDOf(
      _classRef, "formatNanpNumber", "(Landroid/text/Editable;)V");

  /// from: static public void formatNanpNumber(android.text.Editable text)
  ///
  /// Formats a phone number in-place using the NANP formatting rules. Numbers will be formatted
  /// as:
  ///
  /// <code>
  /// xxxxx
  /// xxx-xxxx
  /// xxx-xxx-xxxx
  /// 1-xxx-xxx-xxxx
  /// +1-xxx-xxx-xxxx
  /// </code>
  ///
  ///@param text the number to be formatted, will be modified with the formatting
  ///@deprecated Use link \#formatNumber(String phoneNumber, String defaultCountryIso) instead
  static void formatNanpNumber(editable_.Editable text) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_formatNanpNumber,
          jni.JniType.voidType, [text.reference]).check();

  static final _id_formatJapaneseNumber = jniAccessors.getStaticMethodIDOf(
      _classRef, "formatJapaneseNumber", "(Landroid/text/Editable;)V");

  /// from: static public void formatJapaneseNumber(android.text.Editable text)
  ///
  /// Formats a phone number in-place using the Japanese formatting rules.
  /// Numbers will be formatted as:
  ///
  /// <code>
  /// 03-xxxx-xxxx
  /// 090-xxxx-xxxx
  /// 0120-xxx-xxx
  /// +81-3-xxxx-xxxx
  /// +81-90-xxxx-xxxx
  /// </code>
  ///
  ///@param text the number to be formatted, will be modified with
  /// the formatting
  ///@deprecated Use link \#formatNumber(String phoneNumber, String defaultCountryIso) instead
  static void formatJapaneseNumber(editable_.Editable text) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_formatJapaneseNumber,
          jni.JniType.voidType, [text.reference]).check();

  static final _id_formatNumberToE164 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "formatNumberToE164",
      "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String formatNumberToE164(java.lang.String phoneNumber, java.lang.String defaultCountryIso)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formats the specified {@code phoneNumber} to the E.164 representation.
  ///@param phoneNumber the phone number to format.
  ///@param defaultCountryIso the ISO 3166-1 two letters country code.
  ///@return the E.164 representation, or null if the given phone number is not valid.
  static jni.JniString formatNumberToE164(
          jni.JniString phoneNumber, jni.JniString defaultCountryIso) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_formatNumberToE164,
          jni.JniType.objectType,
          [phoneNumber.reference, defaultCountryIso.reference]).object);

  static final _id_formatNumberToRFC3966 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "formatNumberToRFC3966",
      "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String formatNumberToRFC3966(java.lang.String phoneNumber, java.lang.String defaultCountryIso)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formats the specified {@code phoneNumber} to the RFC3966 representation.
  ///@param phoneNumber the phone number to format.
  ///@param defaultCountryIso the ISO 3166-1 two letters country code.
  ///@return the RFC3966 representation, or null if the given phone number is not valid.
  static jni.JniString formatNumberToRFC3966(
          jni.JniString phoneNumber, jni.JniString defaultCountryIso) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_formatNumberToRFC3966,
          jni.JniType.objectType,
          [phoneNumber.reference, defaultCountryIso.reference]).object);

  static final _id_formatNumber2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "formatNumber",
      "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String formatNumber(java.lang.String phoneNumber, java.lang.String defaultCountryIso)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Format a phone number.
  ///
  /// If the given number doesn't have the country code, the phone will be
  /// formatted to the default country's convention.
  ///@param phoneNumber the number to be formatted.
  ///@param defaultCountryIso the ISO 3166-1 two letters country code whose convention will
  ///            be used if the given number doesn't have the country code.
  ///@return the formatted number, or null if the given number is not valid.
  static jni.JniString formatNumber2(
          jni.JniString phoneNumber, jni.JniString defaultCountryIso) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_formatNumber2,
          jni.JniType.objectType,
          [phoneNumber.reference, defaultCountryIso.reference]).object);

  static final _id_formatNumber3 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "formatNumber",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String formatNumber(java.lang.String phoneNumber, java.lang.String phoneNumberE164, java.lang.String defaultCountryIso)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Format the phone number only if the given number hasn't been formatted.
  ///
  /// The number which has only dailable character is treated as not being
  /// formatted.
  ///@param phoneNumber the number to be formatted.
  ///@param phoneNumberE164 the E164 format number whose country code is used if the given
  ///            phoneNumber doesn't have the country code.
  ///@param defaultCountryIso the ISO 3166-1 two letters country code whose convention will
  ///            be used if the phoneNumberE164 is null or invalid, or if phoneNumber
  ///            contains IDD.
  ///@return the formatted number if the given number has been formatted,
  ///            otherwise, return the given number.
  static jni.JniString formatNumber3(jni.JniString phoneNumber,
          jni.JniString phoneNumberE164, jni.JniString defaultCountryIso) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_formatNumber3, jni.JniType.objectType, [
        phoneNumber.reference,
        phoneNumberE164.reference,
        defaultCountryIso.reference
      ]).object);

  static final _id_normalizeNumber = jniAccessors.getStaticMethodIDOf(
      _classRef, "normalizeNumber", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String normalizeNumber(java.lang.String phoneNumber)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Normalize a phone number by removing the characters other than digits. If
  /// the given number has keypad letters, the letters will be converted to
  /// digits first.
  ///@param phoneNumber the number to be normalized.
  ///@return the normalized number.
  static jni.JniString normalizeNumber(jni.JniString phoneNumber) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_normalizeNumber,
          jni.JniType.objectType,
          [phoneNumber.reference]).object);

  static final _id_replaceUnicodeDigits = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "replaceUnicodeDigits",
      "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String replaceUnicodeDigits(java.lang.String number)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Replaces all unicode(e.g.&nbsp;Arabic, Persian) digits with their decimal digit equivalents.
  ///@param number the number to perform the replacement on.
  ///@return the replaced number.
  static jni.JniString replaceUnicodeDigits(jni.JniString number) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_replaceUnicodeDigits,
          jni.JniType.objectType,
          [number.reference]).object);

  static final _id_isEmergencyNumber = jniAccessors.getStaticMethodIDOf(
      _classRef, "isEmergencyNumber", "(Ljava/lang/String;)Z");

  /// from: static public boolean isEmergencyNumber(java.lang.String number)
  ///
  /// Checks a given number against the list of
  /// emergency numbers provided by the RIL and SIM card.
  ///@param number the number to look up.
  ///@return true if the number is in the list of emergency numbers
  ///         listed in the RIL / SIM, otherwise return false.
  static bool isEmergencyNumber(jni.JniString number) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isEmergencyNumber,
          jni.JniType.booleanType, [number.reference]).boolean;

  static final _id_isLocalEmergencyNumber = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "isLocalEmergencyNumber",
      "(Landroid/content/Context;Ljava/lang/String;)Z");

  /// from: static public boolean isLocalEmergencyNumber(android.content.Context context, java.lang.String number)
  ///
  /// Checks if a given number is an emergency number for the country that the user is in.
  ///@param number the number to look up.
  ///@param context the specific context which the number should be checked against
  ///@return true if the specified number is an emergency number for the country the user
  /// is currently in.
  static bool isLocalEmergencyNumber(
          context_.Context context, jni.JniString number) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_isLocalEmergencyNumber,
          jni.JniType.booleanType,
          [context.reference, number.reference]).boolean;

  static final _id_isVoiceMailNumber = jniAccessors.getStaticMethodIDOf(
      _classRef, "isVoiceMailNumber", "(Ljava/lang/String;)Z");

  /// from: static public boolean isVoiceMailNumber(java.lang.String number)
  ///
  /// isVoiceMailNumber: checks a given number against the voicemail
  ///   number provided by the RIL and SIM card. The caller must have
  ///   the READ_PHONE_STATE credential.
  ///@param number the number to look up.
  ///@return true if the number is in the list of voicemail. False
  /// otherwise, including if the caller does not have the permission
  /// to read the VM number.
  static bool isVoiceMailNumber(jni.JniString number) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isVoiceMailNumber,
          jni.JniType.booleanType, [number.reference]).boolean;

  static final _id_convertKeypadLettersToDigits =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "convertKeypadLettersToDigits",
          "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String convertKeypadLettersToDigits(java.lang.String input)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Translates any alphabetic letters (i.e. [A-Za-z]) in the
  /// specified phone number into the equivalent numeric digits,
  /// according to the phone keypad letter mapping described in
  /// ITU E.161 and ISO/IEC 9995-8.
  ///@return the input string, with alpha letters converted to numeric
  ///         digits using the phone keypad letter mapping.  For example,
  ///         an input of "1-800-GOOG-411" will return "1-800-4664-411".
  static jni.JniString convertKeypadLettersToDigits(jni.JniString input) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_convertKeypadLettersToDigits,
          jni.JniType.objectType,
          [input.reference]).object);

  static final _id_createTtsSpannable = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createTtsSpannable",
      "(Ljava/lang/CharSequence;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence createTtsSpannable(java.lang.CharSequence phoneNumber)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Wrap the supplied {@code CharSequence} with a {@code TtsSpan}, annotating it as
  /// containing a phone number in its entirety.
  ///@param phoneNumber A {@code CharSequence} the entirety of which represents a phone number.
  ///@return A {@code CharSequence} with appropriate annotations.
  static jni.JniObject createTtsSpannable(jni.JniObject phoneNumber) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createTtsSpannable,
          jni.JniType.objectType,
          [phoneNumber.reference]).object);

  static final _id_addTtsSpan = jniAccessors.getStaticMethodIDOf(
      _classRef, "addTtsSpan", "(Landroid/text/Spannable;II)V");

  /// from: static public void addTtsSpan(android.text.Spannable s, int start, int endExclusive)
  ///
  /// Attach a TtsSpan to the supplied {@code Spannable} at the indicated location,
  /// annotating that location as containing a phone number.
  ///@param s A {@code Spannable} to annotate.
  ///@param start The starting character position of the phone number in {@code s}.
  ///@param endExclusive The position after the ending character in the phone number {@code s}.
  static void addTtsSpan(spannable_.Spannable s, int start, int endExclusive) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_addTtsSpan,
          jni.JniType.voidType, [s.reference, start, endExclusive]).check();

  static final _id_createTtsSpan = jniAccessors.getStaticMethodIDOf(_classRef,
      "createTtsSpan", "(Ljava/lang/String;)Landroid/text/style/TtsSpan;");

  /// from: static public android.text.style.TtsSpan createTtsSpan(java.lang.String phoneNumberString)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a {@code TtsSpan} for the supplied {@code String}.
  ///@param phoneNumberString A {@code String} the entirety of which represents a phone number.
  ///@return A {@code TtsSpan} for {@param phoneNumberString}.
  static ttsspan_.TtsSpan createTtsSpan(jni.JniString phoneNumberString) =>
      ttsspan_.TtsSpan.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createTtsSpan,
          jni.JniType.objectType,
          [phoneNumberString.reference]).object);
}
