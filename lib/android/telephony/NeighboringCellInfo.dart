// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.telephony.NeighboringCellInfo
///
/// Represents the neighboring cell information, including
/// Received Signal Strength and Cell ID location.
class NeighboringCellInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/telephony/NeighboringCellInfo");
  NeighboringCellInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.telephony.NeighboringCellInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int UNKNOWN_CID
  ///
  /// Cell location is not available
  static const UNKNOWN_CID = -1;

  /// from: static public final int UNKNOWN_RSSI
  ///
  /// Signal strength is not available
  static const UNKNOWN_RSSI = 99;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Empty constructor.  Initializes the RSSI and CID.
  ///
  /// NeighboringCellInfo is one time shot for the neighboring cells based on
  /// the radio network type at that moment. Its constructor needs radio network
  /// type.
  ///@deprecated by \#NeighboringCellInfo(int, String, int)
  NeighboringCellInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(II)V");

  /// from: public void <init>(int rssi, int cid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Initialize the object from rssi and cid.
  ///
  /// NeighboringCellInfo is one time shot for the neighboring cells based on
  /// the radio network type at that moment. Its constructor needs radio network
  /// type.
  ///@deprecated by \#NeighboringCellInfo(int, String, int)
  NeighboringCellInfo.ctor1(int rssi, int cid)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [rssi, cid]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(ILjava/lang/String;I)V");

  /// from: public void <init>(int rssi, java.lang.String location, int radioType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Initialize the object from rssi, location string, and radioType
  /// radioType is one of following
  /// TelephonyManager\#NETWORK_TYPE_GPRS TelephonyManager.NETWORK_TYPE_GPRS,
  /// TelephonyManager\#NETWORK_TYPE_EDGE TelephonyManager.NETWORK_TYPE_EDGE,
  /// TelephonyManager\#NETWORK_TYPE_UMTS TelephonyManager.NETWORK_TYPE_UMTS,
  /// TelephonyManager\#NETWORK_TYPE_HSDPA TelephonyManager.NETWORK_TYPE_HSDPA,
  /// TelephonyManager\#NETWORK_TYPE_HSUPA TelephonyManager.NETWORK_TYPE_HSUPA,
  /// and TelephonyManager\#NETWORK_TYPE_HSPA TelephonyManager.NETWORK_TYPE_HSPA.
  NeighboringCellInfo.ctor2(int rssi, jni.JniString location, int radioType)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [rssi, location.reference, radioType]).object);

  static final _id_ctor3 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Parcel;)V");

  /// from: public void <init>(android.os.Parcel in)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Initialize the object from a parcel.
  NeighboringCellInfo.ctor3(parcel_.Parcel in0)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor3, [in0.reference]).object);

  static final _id_getRssi =
      jniAccessors.getMethodIDOf(_classRef, "getRssi", "()I");

  /// from: public int getRssi()
  ///
  /// @return received signal strength or UNKNOWN_RSSI if unknown
  ///
  /// For GSM, it is in "asu" ranging from 0 to 31 (dBm = -113 + 2*asu)
  /// 0 means "-113 dBm or less" and 31 means "-51 dBm or greater"
  /// For UMTS, it is the Level index of CPICH RSCP defined in TS 25.125
  int getRssi() => jniAccessors.callMethodWithArgs(
      reference, _id_getRssi, jni.JniType.intType, []).integer;

  static final _id_getLac =
      jniAccessors.getMethodIDOf(_classRef, "getLac", "()I");

  /// from: public int getLac()
  ///
  /// @return LAC in GSM, 0xffff max legal value
  ///  UNKNOWN_CID if in UMTS or CMDA or unknown
  int getLac() => jniAccessors.callMethodWithArgs(
      reference, _id_getLac, jni.JniType.intType, []).integer;

  static final _id_getCid =
      jniAccessors.getMethodIDOf(_classRef, "getCid", "()I");

  /// from: public int getCid()
  ///
  /// @return cell id in GSM, 0xffff max legal value
  ///  UNKNOWN_CID if in UMTS or CDMA or unknown
  int getCid() => jniAccessors.callMethodWithArgs(
      reference, _id_getCid, jni.JniType.intType, []).integer;

  static final _id_getPsc =
      jniAccessors.getMethodIDOf(_classRef, "getPsc", "()I");

  /// from: public int getPsc()
  ///
  /// @return Primary Scrambling Code in 9 bits format in UMTS, 0x1ff max value
  ///  UNKNOWN_CID if in GSM or CMDA or unknown
  int getPsc() => jniAccessors.callMethodWithArgs(
      reference, _id_getPsc, jni.JniType.intType, []).integer;

  static final _id_getNetworkType =
      jniAccessors.getMethodIDOf(_classRef, "getNetworkType", "()I");

  /// from: public int getNetworkType()
  ///
  /// @return Radio network type while neighboring cell location is stored.
  ///
  /// Return TelephonyManager\#NETWORK_TYPE_UNKNOWN TelephonyManager.NETWORK_TYPE_UNKNOWN
  /// means that the location information is unavailable.
  ///
  /// Return TelephonyManager\#NETWORK_TYPE_GPRS TelephonyManager.NETWORK_TYPE_GPRS or
  /// TelephonyManager\#NETWORK_TYPE_EDGE TelephonyManager.NETWORK_TYPE_EDGE
  /// means that Neighboring Cell information is stored for GSM network, in
  /// which NeighboringCellInfo\#getLac NeighboringCellInfo.getLac and
  /// NeighboringCellInfo\#getCid NeighboringCellInfo.getCid should be
  /// called to access location.
  ///
  /// Return TelephonyManager\#NETWORK_TYPE_UMTS TelephonyManager.NETWORK_TYPE_UMTS,
  /// TelephonyManager\#NETWORK_TYPE_HSDPA TelephonyManager.NETWORK_TYPE_HSDPA,
  /// TelephonyManager\#NETWORK_TYPE_HSUPA TelephonyManager.NETWORK_TYPE_HSUPA,
  /// or TelephonyManager\#NETWORK_TYPE_HSPA TelephonyManager.NETWORK_TYPE_HSPA
  /// means that Neighboring Cell information is stored for UMTS network, in
  /// which NeighboringCellInfo\#getPsc NeighboringCellInfo.getPsc
  /// should be called to access location.
  int getNetworkType() => jniAccessors.callMethodWithArgs(
      reference, _id_getNetworkType, jni.JniType.intType, []).integer;

  static final _id_setCid =
      jniAccessors.getMethodIDOf(_classRef, "setCid", "(I)V");

  /// from: public void setCid(int cid)
  ///
  /// Set the cell id.
  ///
  /// NeighboringCellInfo is a one time shot for the neighboring cells based on
  /// the radio network type at that moment. It shouldn't be changed after
  /// creation.
  ///@deprecated cid value passed as in location parameter passed to constructor
  ///              \#NeighboringCellInfo(int, String, int)
  void setCid(int cid) => jniAccessors.callMethodWithArgs(
      reference, _id_setCid, jni.JniType.voidType, [cid]).check();

  static final _id_setRssi =
      jniAccessors.getMethodIDOf(_classRef, "setRssi", "(I)V");

  /// from: public void setRssi(int rssi)
  ///
  /// Set the signal strength of the cell.
  ///
  /// NeighboringCellInfo is a one time shot for the neighboring cells based on
  /// the radio network type at that moment. It shouldn't be changed after
  /// creation.
  ///@deprecated initial rssi value passed as parameter to constructor
  ///              \#NeighboringCellInfo(int, String, int)
  void setRssi(int rssi) => jniAccessors.callMethodWithArgs(
      reference, _id_setRssi, jni.JniType.voidType, [rssi]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}
