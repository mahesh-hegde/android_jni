// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../telecom/PhoneAccountHandle.dart" as phoneaccounthandle_;

import "CellLocation.dart" as celllocation_;

import "../os/PersistableBundle.dart" as persistablebundle_;

import "VisualVoicemailSmsFilterSettings.dart"
    as visualvoicemailsmsfiltersettings_;

import "../app/PendingIntent.dart" as pendingintent_;

import "PhoneStateListener.dart" as phonestatelistener_;

import "IccOpenLogicalChannelResponse.dart" as iccopenlogicalchannelresponse_;

import "NetworkScan.dart" as networkscan_;

import "NetworkScanRequest.dart" as networkscanrequest_;

import "TelephonyScanManager.dart" as telephonyscanmanager_;

import "../os/Handler.dart" as handler_;

import "ServiceState.dart" as servicestate_;

import "../net/Uri.dart" as uri_;

import "SignalStrength.dart" as signalstrength_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.telephony.TelephonyManager
///
/// Provides access to information about the telephony services on
/// the device. Applications can use the methods in this class to
/// determine telephony services and states, as well as to access some
/// types of subscriber information. Applications can also register
/// a listener to receive notification of telephony state changes.
///
/// The returned TelephonyManager will use the default subscription for all calls.
/// To call an API for a specific subscription, use \#createForSubscriptionId(int). e.g.
/// <code>
///   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);
/// </code>
///
/// Note that access to some telephony information is
/// permission-protected. Your application cannot access the protected
/// information unless it has the appropriate permissions declared in
/// its manifest file. Where permissions apply, they are noted in the
/// the methods through which you access the protected information.
class TelephonyManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/telephony/TelephonyManager");
  TelephonyManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_CONFIGURE_VOICEMAIL
  ///
  /// Open the voicemail settings activity to make changes to voicemail configuration.
  ///
  ///
  /// The \#EXTRA_PHONE_ACCOUNT_HANDLE extra indicates which PhoneAccountHandle to
  /// configure voicemail.
  /// The \#EXTRA_HIDE_PUBLIC_SETTINGS hides settings the dialer will modify through public
  /// API if set.
  ///@see \#EXTRA_PHONE_ACCOUNT_HANDLE
  ///@see \#EXTRA_HIDE_PUBLIC_SETTINGS
  static const ACTION_CONFIGURE_VOICEMAIL =
      "android.telephony.action.CONFIGURE_VOICEMAIL";

  /// from: static public final java.lang.String ACTION_PHONE_STATE_CHANGED
  ///
  /// Broadcast intent action indicating that the call state
  /// on the device has changed.
  ///
  ///
  /// The \#EXTRA_STATE extra indicates the new call state.
  /// If a receiving app has android.Manifest.permission\#READ_CALL_LOG permission, a second
  /// extra \#EXTRA_INCOMING_NUMBER provides the phone number for incoming and outgoing
  /// calls as a String.
  ///
  /// If the receiving app has
  /// android.Manifest.permission\#READ_CALL_LOG and
  /// android.Manifest.permission\#READ_PHONE_STATE permission, it will receive the
  /// broadcast twice; one with the \#EXTRA_INCOMING_NUMBER populated with the phone number,
  /// and another with it blank.  Due to the nature of broadcasts, you cannot assume the order
  /// in which these broadcasts will arrive, however you are guaranteed to receive two in this
  /// case.  Apps which are interested in the \#EXTRA_INCOMING_NUMBER can ignore the
  /// broadcasts where \#EXTRA_INCOMING_NUMBER is not present in the extras (e.g. where
  /// Intent\#hasExtra(String) returns {@code false}).
  /// <p class="note">
  /// This was a android.content.Context\#sendStickyBroadcast sticky
  /// broadcast in version 1.0, but it is no longer sticky.
  /// Instead, use \#getCallState to synchronously query the current call state.
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@see \#EXTRA_STATE
  ///@see \#EXTRA_INCOMING_NUMBER
  ///@see \#getCallState
  static const ACTION_PHONE_STATE_CHANGED = "android.intent.action.PHONE_STATE";

  /// from: static public final java.lang.String ACTION_RESPOND_VIA_MESSAGE
  ///
  /// The Phone app sends this intent when a user opts to respond-via-message during an incoming
  /// call. By default, the device's default SMS app consumes this message and sends a text message
  /// to the caller. A third party app can also provide this functionality by consuming this Intent
  /// with a android.app.Service and sending the message using its own messaging system.
  /// The intent contains a URI (available from android.content.Intent\#getData)
  /// describing the recipient, using either the {@code sms:}, {@code smsto:}, {@code mms:},
  /// or {@code mmsto:} URI schema. Each of these URI schema carry the recipient information the
  /// same way: the path part of the URI contains the recipient's phone number or a comma-separated
  /// set of phone numbers if there are multiple recipients. For example, {@code
  /// smsto:2065551234}.
  ///
  ///
  /// The intent may also contain extras for the message text (in android.content.Intent\#EXTRA_TEXT) and a message subject
  /// (in android.content.Intent\#EXTRA_SUBJECT).
  ///
  ///
  /// <p class="note"><strong>Note:</strong>
  /// The intent-filter that consumes this Intent needs to be in a android.app.Service
  /// that requires the
  /// permission android.Manifest.permission\#SEND_RESPOND_VIA_MESSAGE.
  ///
  /// For example, the service that receives this intent can be declared in the manifest file
  /// with an intent filter like this:
  ///
  /// <pre>
  /// &lt;!-- Service that delivers SMS messages received from the phone "quick response" -->
  /// &lt;service android:name=".HeadlessSmsSendService"
  ///          android:permission="android.permission.SEND_RESPOND_VIA_MESSAGE"
  ///          android:exported="true" >
  ///   &lt;intent-filter>
  ///     &lt;action android:name="android.intent.action.RESPOND_VIA_MESSAGE" />
  ///     &lt;category android:name="android.intent.category.DEFAULT" />
  ///     &lt;data android:scheme="sms" />
  ///     &lt;data android:scheme="smsto" />
  ///     &lt;data android:scheme="mms" />
  ///     &lt;data android:scheme="mmsto" />
  ///   &lt;/intent-filter>
  /// &lt;/service></pre>
  ///
  /// Output: nothing.
  static const ACTION_RESPOND_VIA_MESSAGE =
      "android.intent.action.RESPOND_VIA_MESSAGE";

  /// from: static public final java.lang.String ACTION_SHOW_VOICEMAIL_NOTIFICATION
  ///
  /// Broadcast intent action for letting the default dialer to know to show voicemail
  /// notification.
  ///
  ///
  /// The \#EXTRA_PHONE_ACCOUNT_HANDLE extra indicates which PhoneAccountHandle the
  /// voicemail is received on.
  /// The \#EXTRA_NOTIFICATION_COUNT extra indicates the total numbers of unheard
  /// voicemails.
  /// The \#EXTRA_VOICEMAIL_NUMBER extra indicates the voicemail number if available.
  /// The \#EXTRA_CALL_VOICEMAIL_INTENT extra is a android.app.PendingIntent that
  /// will call the voicemail number when sent. This extra will be empty if the voicemail number
  /// is not set, and \#EXTRA_LAUNCH_VOICEMAIL_SETTINGS_INTENT will be set instead.
  /// The \#EXTRA_LAUNCH_VOICEMAIL_SETTINGS_INTENT extra is a
  /// android.app.PendingIntent that will launch the voicemail settings. This extra is only
  /// available when the voicemail number is not set.
  /// The \#EXTRA_IS_REFRESH extra indicates whether the notification is a refresh or a new
  /// notification.
  ///@see \#EXTRA_PHONE_ACCOUNT_HANDLE
  ///@see \#EXTRA_NOTIFICATION_COUNT
  ///@see \#EXTRA_VOICEMAIL_NUMBER
  ///@see \#EXTRA_CALL_VOICEMAIL_INTENT
  ///@see \#EXTRA_LAUNCH_VOICEMAIL_SETTINGS_INTENT
  ///@see \#EXTRA_IS_REFRESH
  static const ACTION_SHOW_VOICEMAIL_NOTIFICATION =
      "android.telephony.action.SHOW_VOICEMAIL_NOTIFICATION";

  /// from: static public final java.lang.String ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED
  ///
  /// Broadcast Action: The subscription carrier identity has changed.
  /// This intent could be sent on the following events:
  /// <ul>
  ///   <li>Subscription absent. Carrier identity could change from a valid id to
  ///   TelephonyManager\#UNKNOWN_CARRIER_ID.</li>
  ///   <li>Subscription loaded. Carrier identity could change from
  ///   TelephonyManager\#UNKNOWN_CARRIER_ID to a valid id.</li>
  ///   <li>The subscription carrier is recognized after a remote update.</li>
  /// </ul>
  /// The intent will have the following extra values:
  /// <ul>
  ///   <li>\#EXTRA_CARRIER_ID The up-to-date carrier id of the current subscription id.
  ///   </li>
  ///   <li>\#EXTRA_CARRIER_NAME The up-to-date carrier name of the current subscription.
  ///   </li>
  ///   <li>\#EXTRA_SUBSCRIPTION_ID The subscription id associated with the changed carrier
  ///   identity.
  ///   </li>
  /// </ul>
  /// <p class="note">This is a protected intent that can only be sent by the system.
  static const ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED =
      "android.telephony.action.SUBSCRIPTION_CARRIER_IDENTITY_CHANGED";

  /// from: static public final int APPTYPE_CSIM
  ///
  /// UICC application type is CSIM
  static const APPTYPE_CSIM = 4;

  /// from: static public final int APPTYPE_ISIM
  ///
  /// UICC application type is ISIM
  static const APPTYPE_ISIM = 5;

  /// from: static public final int APPTYPE_RUIM
  ///
  /// UICC application type is RUIM
  static const APPTYPE_RUIM = 3;

  /// from: static public final int APPTYPE_SIM
  ///
  /// UICC application type is SIM
  static const APPTYPE_SIM = 1;

  /// from: static public final int APPTYPE_USIM
  ///
  /// UICC application type is USIM
  static const APPTYPE_USIM = 2;

  /// from: static public final int AUTHTYPE_EAP_AKA
  ///
  /// Authentication type for UICC challenge is EAP AKA. See RFC 4187 for details.
  static const AUTHTYPE_EAP_AKA = 129;

  /// from: static public final int AUTHTYPE_EAP_SIM
  ///
  /// Authentication type for UICC challenge is EAP SIM. See RFC 4186 for details.
  static const AUTHTYPE_EAP_SIM = 128;

  /// from: static public final int CALL_STATE_IDLE
  ///
  /// Device call state: No activity.
  static const CALL_STATE_IDLE = 0;

  /// from: static public final int CALL_STATE_OFFHOOK
  ///
  /// Device call state: Off-hook. At least one call exists
  /// that is dialing, active, or on hold, and no calls are ringing
  /// or waiting.
  static const CALL_STATE_OFFHOOK = 2;

  /// from: static public final int CALL_STATE_RINGING
  ///
  /// Device call state: Ringing. A new call arrived and is
  ///  ringing or waiting. In the latter case, another call is
  ///  already active.
  static const CALL_STATE_RINGING = 1;

  /// from: static public final int CDMA_ROAMING_MODE_AFFILIATED
  ///
  /// Value for CarrierConfigManager\#KEY_CDMA_ROAMING_MODE_INT which permits roaming on
  /// affiliated networks.
  static const CDMA_ROAMING_MODE_AFFILIATED = 1;

  /// from: static public final int CDMA_ROAMING_MODE_ANY
  ///
  /// Value for CarrierConfigManager\#KEY_CDMA_ROAMING_MODE_INT which permits roaming on
  /// any network.
  static const CDMA_ROAMING_MODE_ANY = 2;

  /// from: static public final int CDMA_ROAMING_MODE_HOME
  ///
  /// Value for CarrierConfigManager\#KEY_CDMA_ROAMING_MODE_INT which only permits
  /// connections on home networks.
  static const CDMA_ROAMING_MODE_HOME = 0;

  /// from: static public final int CDMA_ROAMING_MODE_RADIO_DEFAULT
  ///
  /// Value for CarrierConfigManager\#KEY_CDMA_ROAMING_MODE_INT which leaves the roaming
  /// mode set to the radio default or to the user's preference if they've indicated one.
  static const CDMA_ROAMING_MODE_RADIO_DEFAULT = -1;

  /// from: static public final int DATA_ACTIVITY_DORMANT
  ///
  /// Data connection is active, but physical link is down
  static const DATA_ACTIVITY_DORMANT = 4;

  /// from: static public final int DATA_ACTIVITY_IN
  ///
  /// Data connection activity: Currently receiving IP PPP traffic.
  static const DATA_ACTIVITY_IN = 1;

  /// from: static public final int DATA_ACTIVITY_INOUT
  ///
  /// Data connection activity: Currently both sending and receiving
  ///  IP PPP traffic.
  static const DATA_ACTIVITY_INOUT = 3;

  /// from: static public final int DATA_ACTIVITY_NONE
  ///
  /// Data connection activity: No traffic.
  static const DATA_ACTIVITY_NONE = 0;

  /// from: static public final int DATA_ACTIVITY_OUT
  ///
  /// Data connection activity: Currently sending IP PPP traffic.
  static const DATA_ACTIVITY_OUT = 2;

  /// from: static public final int DATA_CONNECTED
  ///
  /// Data connection state: Connected. IP traffic should be available.
  static const DATA_CONNECTED = 2;

  /// from: static public final int DATA_CONNECTING
  ///
  /// Data connection state: Currently setting up a data connection.
  static const DATA_CONNECTING = 1;

  /// from: static public final int DATA_DISCONNECTED
  ///
  /// Data connection state: Disconnected. IP traffic not available.
  static const DATA_DISCONNECTED = 0;

  /// from: static public final int DATA_SUSPENDED
  ///
  /// Data connection state: Suspended. The connection is up, but IP
  /// traffic is temporarily unavailable. For example, in a 2G network,
  /// data activity may be suspended when a voice call arrives.
  static const DATA_SUSPENDED = 3;

  /// from: static public final java.lang.String EXTRA_CALL_VOICEMAIL_INTENT
  ///
  /// The intent to call voicemail.
  static const EXTRA_CALL_VOICEMAIL_INTENT =
      "android.telephony.extra.CALL_VOICEMAIL_INTENT";

  /// from: static public final java.lang.String EXTRA_CARRIER_ID
  ///
  /// An int extra used with \#ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED which indicates
  /// the updated carrier id TelephonyManager\#getSimCarrierId() of
  /// the current subscription.
  /// Will be TelephonyManager\#UNKNOWN_CARRIER_ID if the subscription is unavailable or
  /// the carrier cannot be identified.
  static const EXTRA_CARRIER_ID = "android.telephony.extra.CARRIER_ID";

  /// from: static public final java.lang.String EXTRA_CARRIER_NAME
  ///
  /// An string extra used with \#ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED which
  /// indicates the updated carrier name of the current subscription.
  /// {@see TelephonyManager\#getSimCarrierIdName()}
  /// Carrier name is a user-facing name of the carrier id \#EXTRA_CARRIER_ID,
  /// usually the brand name of the subsidiary (e.g. T-Mobile).
  static const EXTRA_CARRIER_NAME = "android.telephony.extra.CARRIER_NAME";

  /// from: static public final java.lang.String EXTRA_HIDE_PUBLIC_SETTINGS
  ///
  /// The boolean value indicating whether the voicemail settings activity launched by \#ACTION_CONFIGURE_VOICEMAIL should hide settings accessible through public API. This is
  /// used by dialer implementations which provides their own voicemail settings UI, but still
  /// needs to expose device specific voicemail settings to the user.
  ///@see \#ACTION_CONFIGURE_VOICEMAIL
  ///@see \#METADATA_HIDE_VOICEMAIL_SETTINGS_MENU
  static const EXTRA_HIDE_PUBLIC_SETTINGS =
      "android.telephony.extra.HIDE_PUBLIC_SETTINGS";

  /// from: static public final java.lang.String EXTRA_INCOMING_NUMBER
  ///
  /// Extra key used with the \#ACTION_PHONE_STATE_CHANGED broadcast
  /// for a String containing the incoming or outgoing phone number.
  ///
  /// This extra is only populated for receivers of the \#ACTION_PHONE_STATE_CHANGED
  /// broadcast which have been granted the android.Manifest.permission\#READ_CALL_LOG and
  /// android.Manifest.permission\#READ_PHONE_STATE permissions.
  ///
  /// For incoming calls, the phone number is only guaranteed to be populated when the
  /// \#EXTRA_STATE changes from \#EXTRA_STATE_IDLE to \#EXTRA_STATE_RINGING.
  /// If the incoming caller is from an unknown number, the extra will be populated with an empty
  /// string.
  /// For outgoing calls, the phone number is only guaranteed to be populated when the
  /// \#EXTRA_STATE changes from \#EXTRA_STATE_IDLE to \#EXTRA_STATE_OFFHOOK.
  /// <p class="note">
  /// Retrieve with
  /// android.content.Intent\#getStringExtra(String).
  static const EXTRA_INCOMING_NUMBER = "incoming_number";

  /// from: static public final java.lang.String EXTRA_IS_REFRESH
  ///
  /// Boolean value representing whether the TelephonyManager\#ACTION_SHOW_VOICEMAIL_NOTIFICATION is new or a refresh of an existing
  /// notification. Notification refresh happens after reboot or connectivity changes. The user has
  /// already been notified for the voicemail so it should not alert the user, and should not be
  /// shown again if the user has dismissed it.
  static const EXTRA_IS_REFRESH = "android.telephony.extra.IS_REFRESH";

  /// from: static public final java.lang.String EXTRA_LAUNCH_VOICEMAIL_SETTINGS_INTENT
  ///
  /// The intent to launch voicemail settings.
  static const EXTRA_LAUNCH_VOICEMAIL_SETTINGS_INTENT =
      "android.telephony.extra.LAUNCH_VOICEMAIL_SETTINGS_INTENT";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_COUNT
  ///
  /// The number of voice messages associated with the notification.
  static const EXTRA_NOTIFICATION_COUNT =
      "android.telephony.extra.NOTIFICATION_COUNT";

  /// from: static public final java.lang.String EXTRA_PHONE_ACCOUNT_HANDLE
  ///
  /// The extra used with an \#ACTION_CONFIGURE_VOICEMAIL and
  /// \#ACTION_SHOW_VOICEMAIL_NOTIFICATION {@code Intent} to specify the
  /// PhoneAccountHandle the configuration or notification is for.
  /// <p class="note">
  /// Retrieve with android.content.Intent\#getParcelableExtra(String).
  static const EXTRA_PHONE_ACCOUNT_HANDLE =
      "android.telephony.extra.PHONE_ACCOUNT_HANDLE";

  /// from: static public final java.lang.String EXTRA_STATE
  ///
  /// The lookup key used with the \#ACTION_PHONE_STATE_CHANGED broadcast
  /// for a String containing the new call state.
  ///
  /// <p class="note">
  /// Retrieve with
  /// android.content.Intent\#getStringExtra(String).
  ///@see \#EXTRA_STATE_IDLE
  ///@see \#EXTRA_STATE_RINGING
  ///@see \#EXTRA_STATE_OFFHOOK
  static const EXTRA_STATE = "state";

  static final _id_EXTRA_STATE_IDLE = jniAccessors.getStaticFieldIDOf(
      _classRef, "EXTRA_STATE_IDLE", "Ljava/lang/String;");

  /// from: static public final java.lang.String EXTRA_STATE_IDLE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Value used with \#EXTRA_STATE corresponding to
  /// \#CALL_STATE_IDLE.
  static jni.JniString get EXTRA_STATE_IDLE =>
      jni.JniString.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_EXTRA_STATE_IDLE, jni.JniType.objectType)
          .object);

  static final _id_EXTRA_STATE_OFFHOOK = jniAccessors.getStaticFieldIDOf(
      _classRef, "EXTRA_STATE_OFFHOOK", "Ljava/lang/String;");

  /// from: static public final java.lang.String EXTRA_STATE_OFFHOOK
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Value used with \#EXTRA_STATE corresponding to
  /// \#CALL_STATE_OFFHOOK.
  static jni.JniString get EXTRA_STATE_OFFHOOK => jni.JniString.fromRef(
      jniAccessors
          .getStaticField(
              _classRef, _id_EXTRA_STATE_OFFHOOK, jni.JniType.objectType)
          .object);

  static final _id_EXTRA_STATE_RINGING = jniAccessors.getStaticFieldIDOf(
      _classRef, "EXTRA_STATE_RINGING", "Ljava/lang/String;");

  /// from: static public final java.lang.String EXTRA_STATE_RINGING
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Value used with \#EXTRA_STATE corresponding to
  /// \#CALL_STATE_RINGING.
  static jni.JniString get EXTRA_STATE_RINGING => jni.JniString.fromRef(
      jniAccessors
          .getStaticField(
              _classRef, _id_EXTRA_STATE_RINGING, jni.JniType.objectType)
          .object);

  /// from: static public final java.lang.String EXTRA_SUBSCRIPTION_ID
  ///
  /// An int extra used with \#ACTION_SUBSCRIPTION_CARRIER_IDENTITY_CHANGED to indicate the
  /// subscription which has changed.
  static const EXTRA_SUBSCRIPTION_ID =
      "android.telephony.extra.SUBSCRIPTION_ID";

  /// from: static public final java.lang.String EXTRA_VOICEMAIL_NUMBER
  ///
  /// The voicemail number.
  static const EXTRA_VOICEMAIL_NUMBER =
      "android.telephony.extra.VOICEMAIL_NUMBER";

  /// from: static public final java.lang.String METADATA_HIDE_VOICEMAIL_SETTINGS_MENU
  ///
  /// A boolean meta-data value indicating whether the voicemail settings should be hidden in the
  /// call settings page launched by
  /// android.telecom.TelecomManager\#ACTION_SHOW_CALL_SETTINGS.
  /// Dialer implementations (see android.telecom.TelecomManager\#getDefaultDialerPackage())
  /// which would also like to manage voicemail settings should set this meta-data to {@code true}
  /// in the manifest registration of their application.
  ///@see android.telecom.TelecomManager\#ACTION_SHOW_CALL_SETTINGS
  ///@see \#ACTION_CONFIGURE_VOICEMAIL
  ///@see \#EXTRA_HIDE_PUBLIC_SETTINGS
  static const METADATA_HIDE_VOICEMAIL_SETTINGS_MENU =
      "android.telephony.HIDE_VOICEMAIL_SETTINGS_MENU";

  /// from: static public final int NETWORK_TYPE_1xRTT
  ///
  /// Current network is 1xRTT
  static const NETWORK_TYPE_1xRTT = 7;

  /// from: static public final int NETWORK_TYPE_CDMA
  ///
  /// Current network is CDMA: Either IS95A or IS95B
  static const NETWORK_TYPE_CDMA = 4;

  /// from: static public final int NETWORK_TYPE_EDGE
  ///
  /// Current network is EDGE
  static const NETWORK_TYPE_EDGE = 2;

  /// from: static public final int NETWORK_TYPE_EHRPD
  ///
  /// Current network is eHRPD
  static const NETWORK_TYPE_EHRPD = 14;

  /// from: static public final int NETWORK_TYPE_EVDO_0
  ///
  /// Current network is EVDO revision 0
  static const NETWORK_TYPE_EVDO_0 = 5;

  /// from: static public final int NETWORK_TYPE_EVDO_A
  ///
  /// Current network is EVDO revision A
  static const NETWORK_TYPE_EVDO_A = 6;

  /// from: static public final int NETWORK_TYPE_EVDO_B
  ///
  /// Current network is EVDO revision B
  static const NETWORK_TYPE_EVDO_B = 12;

  /// from: static public final int NETWORK_TYPE_GPRS
  ///
  /// Current network is GPRS
  static const NETWORK_TYPE_GPRS = 1;

  /// from: static public final int NETWORK_TYPE_GSM
  ///
  /// Current network is GSM
  static const NETWORK_TYPE_GSM = 16;

  /// from: static public final int NETWORK_TYPE_HSDPA
  ///
  /// Current network is HSDPA
  static const NETWORK_TYPE_HSDPA = 8;

  /// from: static public final int NETWORK_TYPE_HSPA
  ///
  /// Current network is HSPA
  static const NETWORK_TYPE_HSPA = 10;

  /// from: static public final int NETWORK_TYPE_HSPAP
  ///
  /// Current network is HSPA+
  static const NETWORK_TYPE_HSPAP = 15;

  /// from: static public final int NETWORK_TYPE_HSUPA
  ///
  /// Current network is HSUPA
  static const NETWORK_TYPE_HSUPA = 9;

  /// from: static public final int NETWORK_TYPE_IDEN
  ///
  /// Current network is iDen
  static const NETWORK_TYPE_IDEN = 11;

  /// from: static public final int NETWORK_TYPE_IWLAN
  ///
  /// Current network is IWLAN
  static const NETWORK_TYPE_IWLAN = 18;

  /// from: static public final int NETWORK_TYPE_LTE
  ///
  /// Current network is LTE
  static const NETWORK_TYPE_LTE = 13;

  /// from: static public final int NETWORK_TYPE_TD_SCDMA
  ///
  /// Current network is TD_SCDMA
  static const NETWORK_TYPE_TD_SCDMA = 17;

  /// from: static public final int NETWORK_TYPE_UMTS
  ///
  /// Current network is UMTS
  static const NETWORK_TYPE_UMTS = 3;

  /// from: static public final int NETWORK_TYPE_UNKNOWN
  ///
  /// Network type is unknown
  static const NETWORK_TYPE_UNKNOWN = 0;

  /// from: static public final int PHONE_TYPE_CDMA
  ///
  /// Phone radio is CDMA.
  static const PHONE_TYPE_CDMA = 2;

  /// from: static public final int PHONE_TYPE_GSM
  ///
  /// Phone radio is GSM.
  static const PHONE_TYPE_GSM = 1;

  /// from: static public final int PHONE_TYPE_NONE
  ///
  /// No phone radio.
  static const PHONE_TYPE_NONE = 0;

  /// from: static public final int PHONE_TYPE_SIP
  ///
  /// Phone is via SIP.
  static const PHONE_TYPE_SIP = 3;

  /// from: static public final int SIM_STATE_ABSENT
  ///
  /// SIM card state: no SIM card is available in the device
  static const SIM_STATE_ABSENT = 1;

  /// from: static public final int SIM_STATE_CARD_IO_ERROR
  ///
  /// SIM card state: SIM Card Error, present but faulty
  static const SIM_STATE_CARD_IO_ERROR = 8;

  /// from: static public final int SIM_STATE_CARD_RESTRICTED
  ///
  /// SIM card state: SIM Card restricted, present but not usable due to
  /// carrier restrictions.
  static const SIM_STATE_CARD_RESTRICTED = 9;

  /// from: static public final int SIM_STATE_NETWORK_LOCKED
  ///
  /// SIM card state: Locked: requires a network PIN to unlock
  static const SIM_STATE_NETWORK_LOCKED = 4;

  /// from: static public final int SIM_STATE_NOT_READY
  ///
  /// SIM card state: SIM Card is NOT READY
  static const SIM_STATE_NOT_READY = 6;

  /// from: static public final int SIM_STATE_PERM_DISABLED
  ///
  /// SIM card state: SIM Card Error, permanently disabled
  static const SIM_STATE_PERM_DISABLED = 7;

  /// from: static public final int SIM_STATE_PIN_REQUIRED
  ///
  /// SIM card state: Locked: requires the user's SIM PIN to unlock
  static const SIM_STATE_PIN_REQUIRED = 2;

  /// from: static public final int SIM_STATE_PUK_REQUIRED
  ///
  /// SIM card state: Locked: requires the user's SIM PUK to unlock
  static const SIM_STATE_PUK_REQUIRED = 3;

  /// from: static public final int SIM_STATE_READY
  ///
  /// SIM card state: Ready
  static const SIM_STATE_READY = 5;

  /// from: static public final int SIM_STATE_UNKNOWN
  ///
  /// SIM card state: Unknown. Signifies that the SIM is in transition
  /// between states. For example, when the user inputs the SIM pin
  /// under PIN_REQUIRED state, a query for sim status returns
  /// this state before turning to SIM_STATE_READY.
  ///
  /// These are the ordinal value of IccCardConstants.State.
  static const SIM_STATE_UNKNOWN = 0;

  /// from: static public final int UNKNOWN_CARRIER_ID
  ///
  /// An unknown carrier id. It could either be subscription unavailable or the subscription
  /// carrier cannot be recognized. Unrecognized carriers here means
  /// \#getSimOperator() MCC+MNC cannot be identified.
  static const UNKNOWN_CARRIER_ID = -1;

  /// from: static public final int USSD_ERROR_SERVICE_UNAVAIL
  ///
  /// Failure code returned when a USSD request has failed to execute because the Telephony
  /// service is unavailable.
  ///
  /// Returned via TelephonyManager.UssdResponseCallback\#onReceiveUssdResponseFailed(
  /// TelephonyManager, String, int).
  static const USSD_ERROR_SERVICE_UNAVAIL = -2;

  /// from: static public final int USSD_RETURN_FAILURE
  ///
  /// Failed code returned when the mobile network has failed to complete a USSD request.
  ///
  /// Returned via TelephonyManager.UssdResponseCallback\#onReceiveUssdResponseFailed(
  /// TelephonyManager, String, int).
  static const USSD_RETURN_FAILURE = -1;

  /// from: static public final java.lang.String VVM_TYPE_CVVM
  ///
  /// A flavor of OMTP protocol with a different mobile originated (MO) format
  static const VVM_TYPE_CVVM = "vvm_type_cvvm";

  /// from: static public final java.lang.String VVM_TYPE_OMTP
  ///
  /// The OMTP protocol.
  static const VVM_TYPE_OMTP = "vvm_type_omtp";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  TelephonyManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getPhoneCount =
      jniAccessors.getMethodIDOf(_classRef, "getPhoneCount", "()I");

  /// from: public int getPhoneCount()
  ///
  /// Returns the number of phones available.
  /// Returns 0 if none of voice, sms, data is not supported
  /// Returns 1 for Single standby mode (Single SIM functionality)
  /// Returns 2 for Dual standby mode.(Dual SIM functionality)
  int getPhoneCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getPhoneCount, jni.JniType.intType, []).integer;

  static final _id_createForSubscriptionId = jniAccessors.getMethodIDOf(
      _classRef,
      "createForSubscriptionId",
      "(I)Landroid/telephony/TelephonyManager;");

  /// from: public android.telephony.TelephonyManager createForSubscriptionId(int subId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new TelephonyManager object pinned to the given subscription ID.
  ///@return a TelephonyManager that uses the given subId for all calls.
  TelephonyManager createForSubscriptionId(int subId) =>
      TelephonyManager.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_createForSubscriptionId, jni.JniType.objectType, [subId]).object);

  static final _id_createForPhoneAccountHandle = jniAccessors.getMethodIDOf(
      _classRef,
      "createForPhoneAccountHandle",
      "(Landroid/telecom/PhoneAccountHandle;)Landroid/telephony/TelephonyManager;");

  /// from: public android.telephony.TelephonyManager createForPhoneAccountHandle(android.telecom.PhoneAccountHandle phoneAccountHandle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new TelephonyManager object pinned to the subscription ID associated with the given
  /// phone account.
  ///@return a TelephonyManager that uses the given phone account for all calls, or {@code null}
  /// if the phone account does not correspond to a valid subscription ID.
  TelephonyManager createForPhoneAccountHandle(
          phoneaccounthandle_.PhoneAccountHandle phoneAccountHandle) =>
      TelephonyManager.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createForPhoneAccountHandle,
          jni.JniType.objectType,
          [phoneAccountHandle.reference]).object);

  static final _id_getDeviceSoftwareVersion = jniAccessors.getMethodIDOf(
      _classRef, "getDeviceSoftwareVersion", "()Ljava/lang/String;");

  /// from: public java.lang.String getDeviceSoftwareVersion()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the software version number for the device, for example,
  /// the IMEI/SV for GSM phones. Return null if the software version is
  /// not available.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  jni.JniString getDeviceSoftwareVersion() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDeviceSoftwareVersion, jni.JniType.objectType, []).object);

  static final _id_getDeviceId = jniAccessors.getMethodIDOf(
      _classRef, "getDeviceId", "()Ljava/lang/String;");

  /// from: public java.lang.String getDeviceId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the unique device ID, for example, the IMEI for GSM and the MEID
  /// or ESN for CDMA phones. Return null if device ID is not available.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@deprecated Use (@link getImei} which returns IMEI for GSM or (@link getMeid} which returns
  /// MEID for CDMA.
  jni.JniString getDeviceId() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDeviceId, jni.JniType.objectType, []).object);

  static final _id_getDeviceId1 = jniAccessors.getMethodIDOf(
      _classRef, "getDeviceId", "(I)Ljava/lang/String;");

  /// from: public java.lang.String getDeviceId(int slotIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the unique device ID of a subscription, for example, the IMEI for
  /// GSM and the MEID for CDMA phones. Return null if device ID is not available.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@param slotIndex of which deviceID is returned
  ///@deprecated Use (@link getImei} which returns IMEI for GSM or (@link getMeid} which returns
  /// MEID for CDMA.
  jni.JniString getDeviceId1(int slotIndex) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDeviceId1, jni.JniType.objectType, [slotIndex]).object);

  static final _id_getImei =
      jniAccessors.getMethodIDOf(_classRef, "getImei", "()Ljava/lang/String;");

  /// from: public java.lang.String getImei()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the IMEI (International Mobile Equipment Identity). Return null if IMEI is not
  /// available.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  jni.JniString getImei() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getImei, jni.JniType.objectType, []).object);

  static final _id_getImei1 =
      jniAccessors.getMethodIDOf(_classRef, "getImei", "(I)Ljava/lang/String;");

  /// from: public java.lang.String getImei(int slotIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the IMEI (International Mobile Equipment Identity). Return null if IMEI is not
  /// available.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@param slotIndex of which IMEI is returned
  jni.JniString getImei1(int slotIndex) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getImei1, jni.JniType.objectType, [slotIndex]).object);

  static final _id_getMeid =
      jniAccessors.getMethodIDOf(_classRef, "getMeid", "()Ljava/lang/String;");

  /// from: public java.lang.String getMeid()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the MEID (Mobile Equipment Identifier). Return null if MEID is not available.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  jni.JniString getMeid() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMeid, jni.JniType.objectType, []).object);

  static final _id_getMeid1 =
      jniAccessors.getMethodIDOf(_classRef, "getMeid", "(I)Ljava/lang/String;");

  /// from: public java.lang.String getMeid(int slotIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the MEID (Mobile Equipment Identifier). Return null if MEID is not available.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@param slotIndex of which MEID is returned
  jni.JniString getMeid1(int slotIndex) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMeid1, jni.JniType.objectType, [slotIndex]).object);

  static final _id_getNai =
      jniAccessors.getMethodIDOf(_classRef, "getNai", "()Ljava/lang/String;");

  /// from: public java.lang.String getNai()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Network Access Identifier (NAI). Return null if NAI is not available.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  jni.JniString getNai() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getNai, jni.JniType.objectType, []).object);

  static final _id_getCellLocation = jniAccessors.getMethodIDOf(
      _classRef, "getCellLocation", "()Landroid/telephony/CellLocation;");

  /// from: public android.telephony.CellLocation getCellLocation()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current location of the device.
  ///
  /// If there is only one radio in the device and that radio has an LTE connection,
  /// this method will return null. The implementation must not to try add LTE
  /// identifiers into the existing cdma/gsm classes.
  ///
  /// Requires android.Manifest.permission\#ACCESS_COARSE_LOCATION or android.Manifest.permission\#ACCESS_FINE_LOCATION
  ///@return Current location of the device or null if not available.
  ///@deprecated use \#getAllCellInfo instead, which returns a superset of this API.
  celllocation_.CellLocation getCellLocation() =>
      celllocation_.CellLocation.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCellLocation, jni.JniType.objectType, []).object);

  static final _id_getNeighboringCellInfo = jniAccessors.getMethodIDOf(
      _classRef, "getNeighboringCellInfo", "()Ljava/util/List;");

  /// from: public java.util.List<android.telephony.NeighboringCellInfo> getNeighboringCellInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the neighboring cell information of the device.
  ///
  /// Requires android.Manifest.permission\#ACCESS_COARSE_LOCATION
  ///@return List of NeighboringCellInfo or null if info unavailable.
  ///@deprecated Use \#getAllCellInfo which returns a superset of the information
  ///             from NeighboringCellInfo.
  jni.JniObject getNeighboringCellInfo() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getNeighboringCellInfo, jni.JniType.objectType, []).object);

  static final _id_getPhoneType =
      jniAccessors.getMethodIDOf(_classRef, "getPhoneType", "()I");

  /// from: public int getPhoneType()
  ///
  /// Returns a constant indicating the device phone type.  This
  /// indicates the type of radio used to transmit voice calls.
  ///@see \#PHONE_TYPE_NONE
  ///@see \#PHONE_TYPE_GSM
  ///@see \#PHONE_TYPE_CDMA
  ///@see \#PHONE_TYPE_SIP
  int getPhoneType() => jniAccessors.callMethodWithArgs(
      reference, _id_getPhoneType, jni.JniType.intType, []).integer;

  static final _id_getNetworkOperatorName = jniAccessors.getMethodIDOf(
      _classRef, "getNetworkOperatorName", "()Ljava/lang/String;");

  /// from: public java.lang.String getNetworkOperatorName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the alphabetic name of current registered operator.
  ///
  /// Availability: Only when user is registered to a network. Result may be
  /// unreliable on CDMA networks (use \#getPhoneType() to determine if
  /// on a CDMA network).
  jni.JniString getNetworkOperatorName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getNetworkOperatorName, jni.JniType.objectType, []).object);

  static final _id_getNetworkOperator = jniAccessors.getMethodIDOf(
      _classRef, "getNetworkOperator", "()Ljava/lang/String;");

  /// from: public java.lang.String getNetworkOperator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the numeric name (MCC+MNC) of current registered operator.
  ///
  /// Availability: Only when user is registered to a network. Result may be
  /// unreliable on CDMA networks (use \#getPhoneType() to determine if
  /// on a CDMA network).
  jni.JniString getNetworkOperator() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getNetworkOperator, jni.JniType.objectType, []).object);

  static final _id_getNetworkSpecifier = jniAccessors.getMethodIDOf(
      _classRef, "getNetworkSpecifier", "()Ljava/lang/String;");

  /// from: public java.lang.String getNetworkSpecifier()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the network specifier of the subscription ID pinned to the TelephonyManager. The
  /// network specifier is used by android.net.NetworkRequest.Builder\#setNetworkSpecifier(String) to create a android.net.NetworkRequest that connects through the subscription.
  ///@see android.net.NetworkRequest.Builder\#setNetworkSpecifier(String)
  ///@see \#createForSubscriptionId(int)
  ///@see \#createForPhoneAccountHandle(PhoneAccountHandle)
  jni.JniString getNetworkSpecifier() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getNetworkSpecifier, jni.JniType.objectType, []).object);

  static final _id_getCarrierConfig = jniAccessors.getMethodIDOf(
      _classRef, "getCarrierConfig", "()Landroid/os/PersistableBundle;");

  /// from: public android.os.PersistableBundle getCarrierConfig()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the carrier config of the subscription ID pinned to the TelephonyManager. If an
  /// invalid subscription ID is pinned to the TelephonyManager, the returned config will contain
  /// default values.
  ///
  /// This method may take several seconds to complete, so it should only be called from a
  /// worker thread.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@see CarrierConfigManager\#getConfigForSubId(int)
  ///@see \#createForSubscriptionId(int)
  ///@see \#createForPhoneAccountHandle(PhoneAccountHandle)
  persistablebundle_.PersistableBundle getCarrierConfig() =>
      persistablebundle_.PersistableBundle.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getCarrierConfig,
              jni.JniType.objectType, []).object);

  static final _id_isNetworkRoaming =
      jniAccessors.getMethodIDOf(_classRef, "isNetworkRoaming", "()Z");

  /// from: public boolean isNetworkRoaming()
  ///
  /// Returns true if the device is considered roaming on the current
  /// network, for GSM purposes.
  ///
  /// Availability: Only when user registered to a network.
  bool isNetworkRoaming() => jniAccessors.callMethodWithArgs(
      reference, _id_isNetworkRoaming, jni.JniType.booleanType, []).boolean;

  static final _id_getNetworkCountryIso = jniAccessors.getMethodIDOf(
      _classRef, "getNetworkCountryIso", "()Ljava/lang/String;");

  /// from: public java.lang.String getNetworkCountryIso()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the ISO country code equivalent of the MCC (Mobile Country Code) of the current
  /// registered operator, or nearby cell information if not registered.
  /// .
  ///
  /// Note: Result may be unreliable on CDMA networks (use \#getPhoneType() to determine
  /// if on a CDMA network).
  jni.JniString getNetworkCountryIso() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getNetworkCountryIso, jni.JniType.objectType, []).object);

  static final _id_getNetworkType =
      jniAccessors.getMethodIDOf(_classRef, "getNetworkType", "()I");

  /// from: public int getNetworkType()
  ///
  /// @return the NETWORK_TYPE_xxxx for current data connection.
  int getNetworkType() => jniAccessors.callMethodWithArgs(
      reference, _id_getNetworkType, jni.JniType.intType, []).integer;

  static final _id_getDataNetworkType =
      jniAccessors.getMethodIDOf(_classRef, "getDataNetworkType", "()I");

  /// from: public int getDataNetworkType()
  ///
  /// Returns a constant indicating the radio technology (network type)
  /// currently in use on the device for data transmission.
  ///
  /// If this object has been created with \#createForSubscriptionId, applies to the given
  /// subId. Otherwise, applies to SubscriptionManager\#getDefaultDataSubscriptionId()
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@return the network type
  ///@see \#NETWORK_TYPE_UNKNOWN
  ///@see \#NETWORK_TYPE_GPRS
  ///@see \#NETWORK_TYPE_EDGE
  ///@see \#NETWORK_TYPE_UMTS
  ///@see \#NETWORK_TYPE_HSDPA
  ///@see \#NETWORK_TYPE_HSUPA
  ///@see \#NETWORK_TYPE_HSPA
  ///@see \#NETWORK_TYPE_CDMA
  ///@see \#NETWORK_TYPE_EVDO_0
  ///@see \#NETWORK_TYPE_EVDO_A
  ///@see \#NETWORK_TYPE_EVDO_B
  ///@see \#NETWORK_TYPE_1xRTT
  ///@see \#NETWORK_TYPE_IDEN
  ///@see \#NETWORK_TYPE_LTE
  ///@see \#NETWORK_TYPE_EHRPD
  ///@see \#NETWORK_TYPE_HSPAP
  int getDataNetworkType() => jniAccessors.callMethodWithArgs(
      reference, _id_getDataNetworkType, jni.JniType.intType, []).integer;

  static final _id_getVoiceNetworkType =
      jniAccessors.getMethodIDOf(_classRef, "getVoiceNetworkType", "()I");

  /// from: public int getVoiceNetworkType()
  ///
  /// Returns the NETWORK_TYPE_xxxx for voice
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  int getVoiceNetworkType() => jniAccessors.callMethodWithArgs(
      reference, _id_getVoiceNetworkType, jni.JniType.intType, []).integer;

  static final _id_hasIccCard =
      jniAccessors.getMethodIDOf(_classRef, "hasIccCard", "()Z");

  /// from: public boolean hasIccCard()
  ///
  /// @return true if a ICC card is present
  bool hasIccCard() => jniAccessors.callMethodWithArgs(
      reference, _id_hasIccCard, jni.JniType.booleanType, []).boolean;

  static final _id_getSimState =
      jniAccessors.getMethodIDOf(_classRef, "getSimState", "()I");

  /// from: public int getSimState()
  ///
  /// Returns a constant indicating the state of the default SIM card.
  ///@see \#SIM_STATE_UNKNOWN
  ///@see \#SIM_STATE_ABSENT
  ///@see \#SIM_STATE_PIN_REQUIRED
  ///@see \#SIM_STATE_PUK_REQUIRED
  ///@see \#SIM_STATE_NETWORK_LOCKED
  ///@see \#SIM_STATE_READY
  ///@see \#SIM_STATE_NOT_READY
  ///@see \#SIM_STATE_PERM_DISABLED
  ///@see \#SIM_STATE_CARD_IO_ERROR
  ///@see \#SIM_STATE_CARD_RESTRICTED
  int getSimState() => jniAccessors.callMethodWithArgs(
      reference, _id_getSimState, jni.JniType.intType, []).integer;

  static final _id_getSimState1 =
      jniAccessors.getMethodIDOf(_classRef, "getSimState", "(I)I");

  /// from: public int getSimState(int slotIndex)
  ///
  /// Returns a constant indicating the state of the device SIM card in a slot.
  ///@param slotIndex
  ///@see \#SIM_STATE_UNKNOWN
  ///@see \#SIM_STATE_ABSENT
  ///@see \#SIM_STATE_PIN_REQUIRED
  ///@see \#SIM_STATE_PUK_REQUIRED
  ///@see \#SIM_STATE_NETWORK_LOCKED
  ///@see \#SIM_STATE_READY
  ///@see \#SIM_STATE_NOT_READY
  ///@see \#SIM_STATE_PERM_DISABLED
  ///@see \#SIM_STATE_CARD_IO_ERROR
  ///@see \#SIM_STATE_CARD_RESTRICTED
  int getSimState1(int slotIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_getSimState1, jni.JniType.intType, [slotIndex]).integer;

  static final _id_getSimOperator = jniAccessors.getMethodIDOf(
      _classRef, "getSimOperator", "()Ljava/lang/String;");

  /// from: public java.lang.String getSimOperator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the MCC+MNC (mobile country code + mobile network code) of the
  /// provider of the SIM. 5 or 6 decimal digits.
  ///
  /// Availability: SIM state must be \#SIM_STATE_READY
  ///@see \#getSimState
  jni.JniString getSimOperator() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSimOperator, jni.JniType.objectType, []).object);

  static final _id_getSimOperatorName = jniAccessors.getMethodIDOf(
      _classRef, "getSimOperatorName", "()Ljava/lang/String;");

  /// from: public java.lang.String getSimOperatorName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Service Provider Name (SPN).
  ///
  /// Availability: SIM state must be \#SIM_STATE_READY
  ///@see \#getSimState
  jni.JniString getSimOperatorName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSimOperatorName, jni.JniType.objectType, []).object);

  static final _id_getSimCountryIso = jniAccessors.getMethodIDOf(
      _classRef, "getSimCountryIso", "()Ljava/lang/String;");

  /// from: public java.lang.String getSimCountryIso()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the ISO country code equivalent for the SIM provider's country code.
  jni.JniString getSimCountryIso() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSimCountryIso, jni.JniType.objectType, []).object);

  static final _id_getSimSerialNumber = jniAccessors.getMethodIDOf(
      _classRef, "getSimSerialNumber", "()Ljava/lang/String;");

  /// from: public java.lang.String getSimSerialNumber()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the serial number of the SIM, if applicable. Return null if it is
  /// unavailable.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  jni.JniString getSimSerialNumber() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSimSerialNumber, jni.JniType.objectType, []).object);

  static final _id_getSubscriberId = jniAccessors.getMethodIDOf(
      _classRef, "getSubscriberId", "()Ljava/lang/String;");

  /// from: public java.lang.String getSubscriberId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the unique subscriber ID, for example, the IMSI for a GSM phone.
  /// Return null if it is unavailable.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  jni.JniString getSubscriberId() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSubscriberId, jni.JniType.objectType, []).object);

  static final _id_getGroupIdLevel1 = jniAccessors.getMethodIDOf(
      _classRef, "getGroupIdLevel1", "()Ljava/lang/String;");

  /// from: public java.lang.String getGroupIdLevel1()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Group Identifier Level1 for a GSM phone.
  /// Return null if it is unavailable.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  jni.JniString getGroupIdLevel1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getGroupIdLevel1, jni.JniType.objectType, []).object);

  static final _id_getLine1Number = jniAccessors.getMethodIDOf(
      _classRef, "getLine1Number", "()Ljava/lang/String;");

  /// from: public java.lang.String getLine1Number()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the phone number string for line 1, for example, the MSISDN
  /// for a GSM phone. Return null if it is unavailable.
  ///
  /// Requires Permission:
  ///     android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE,
  ///     android.Manifest.permission\#READ_SMS READ_SMS,
  ///     android.Manifest.permission\#READ_PHONE_NUMBERS READ_PHONE_NUMBERS,
  ///     that the caller is the default SMS app,
  ///     or that the caller has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE or android.Manifest.permission\#READ_SMS or android.Manifest.permission\#READ_PHONE_NUMBERS
  jni.JniString getLine1Number() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLine1Number, jni.JniType.objectType, []).object);

  static final _id_setLine1NumberForDisplay = jniAccessors.getMethodIDOf(
      _classRef,
      "setLine1NumberForDisplay",
      "(Ljava/lang/String;Ljava/lang/String;)Z");

  /// from: public boolean setLine1NumberForDisplay(java.lang.String alphaTag, java.lang.String number)
  ///
  /// Set the line 1 phone number string and its alphatag for the current ICCID
  /// for display purpose only, for example, displayed in Phone Status. It won't
  /// change the actual MSISDN/MDN. To unset alphatag or number, pass in a null
  /// value.
  ///
  /// Requires that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///@param alphaTag alpha-tagging of the dailing nubmer
  ///@param number The dialing number
  ///@return true if the operation was executed correctly.
  bool setLine1NumberForDisplay(jni.JniString alphaTag, jni.JniString number) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setLine1NumberForDisplay,
          jni.JniType.booleanType,
          [alphaTag.reference, number.reference]).boolean;

  static final _id_getVoiceMailNumber = jniAccessors.getMethodIDOf(
      _classRef, "getVoiceMailNumber", "()Ljava/lang/String;");

  /// from: public java.lang.String getVoiceMailNumber()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the voice mail number. Return null if it is unavailable.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  jni.JniString getVoiceMailNumber() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getVoiceMailNumber, jni.JniType.objectType, []).object);

  static final _id_setVoiceMailNumber = jniAccessors.getMethodIDOf(_classRef,
      "setVoiceMailNumber", "(Ljava/lang/String;Ljava/lang/String;)Z");

  /// from: public boolean setVoiceMailNumber(java.lang.String alphaTag, java.lang.String number)
  ///
  /// Sets the voice mail number.
  ///
  /// Requires that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///@param alphaTag The alpha tag to display.
  ///@param number The voicemail number.
  bool setVoiceMailNumber(jni.JniString alphaTag, jni.JniString number) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setVoiceMailNumber,
          jni.JniType.booleanType,
          [alphaTag.reference, number.reference]).boolean;

  static final _id_getVisualVoicemailPackageName = jniAccessors.getMethodIDOf(
      _classRef, "getVisualVoicemailPackageName", "()Ljava/lang/String;");

  /// from: public java.lang.String getVisualVoicemailPackageName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the package responsible of processing visual voicemail for the subscription ID pinned
  /// to the TelephonyManager. Returns {@code null} when there is no package responsible for
  /// processing visual voicemail for the subscription.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@see \#createForSubscriptionId(int)
  ///@see \#createForPhoneAccountHandle(PhoneAccountHandle)
  ///@see VisualVoicemailService
  jni.JniString getVisualVoicemailPackageName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getVisualVoicemailPackageName,
          jni.JniType.objectType, []).object);

  static final _id_setVisualVoicemailSmsFilterSettings =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setVisualVoicemailSmsFilterSettings",
          "(Landroid/telephony/VisualVoicemailSmsFilterSettings;)V");

  /// from: public void setVisualVoicemailSmsFilterSettings(android.telephony.VisualVoicemailSmsFilterSettings settings)
  ///
  /// Set the visual voicemail SMS filter settings for the subscription ID pinned
  /// to the TelephonyManager.
  /// When the filter is enabled, VisualVoicemailService\#onSmsReceived(VisualVoicemailTask, VisualVoicemailSms) will be
  /// called when a SMS matching the settings is received. Caller must be the default dialer,
  /// system dialer, or carrier visual voicemail app.
  ///@param settings The settings for the filter, or {@code null} to disable the filter.
  ///@see TelecomManager\#getDefaultDialerPackage()
  ///@see CarrierConfigManager\#KEY_CARRIER_VVM_PACKAGE_NAME_STRING_ARRAY
  void setVisualVoicemailSmsFilterSettings(
          visualvoicemailsmsfiltersettings_.VisualVoicemailSmsFilterSettings
              settings) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setVisualVoicemailSmsFilterSettings,
          jni.JniType.voidType,
          [settings.reference]).check();

  static final _id_sendVisualVoicemailSms = jniAccessors.getMethodIDOf(
      _classRef,
      "sendVisualVoicemailSms",
      "(Ljava/lang/String;ILjava/lang/String;Landroid/app/PendingIntent;)V");

  /// from: public void sendVisualVoicemailSms(java.lang.String number, int port, java.lang.String text, android.app.PendingIntent sentIntent)
  ///
  /// Send a visual voicemail SMS. The caller must be the current default dialer.
  /// A VisualVoicemailService uses this method to send a command via SMS to the carrier's
  /// visual voicemail server.  Some examples for carriers using the OMTP standard include
  /// activating and deactivating visual voicemail, or requesting the current visual voicemail
  /// provisioning status.  See the OMTP Visual Voicemail specification for more information on the
  /// format of these SMS messages.
  ///
  /// Requires Permission:
  /// android.Manifest.permission\#SEND_SMS SEND_SMS
  ///@param number The destination number.
  ///@param port The destination port for data SMS, or 0 for text SMS.
  ///@param text The message content. For data sms, it will be encoded as a UTF-8 byte stream.
  ///@param sentIntent The sent intent passed to the SmsManager
  ///@throws SecurityException if the caller is not the current default dialer
  ///@see SmsManager\#sendDataMessage(String, String, short, byte[], PendingIntent, PendingIntent)
  ///@see SmsManager\#sendTextMessage(String, String, String, PendingIntent, PendingIntent)
  void sendVisualVoicemailSms(jni.JniString number, int port,
          jni.JniString text, pendingintent_.PendingIntent sentIntent) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_sendVisualVoicemailSms, jni.JniType.voidType, [
        number.reference,
        port,
        text.reference,
        sentIntent.reference
      ]).check();

  static final _id_getVoiceMailAlphaTag = jniAccessors.getMethodIDOf(
      _classRef, "getVoiceMailAlphaTag", "()Ljava/lang/String;");

  /// from: public java.lang.String getVoiceMailAlphaTag()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the alphabetic identifier associated with the voice
  /// mail number.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  jni.JniString getVoiceMailAlphaTag() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getVoiceMailAlphaTag, jni.JniType.objectType, []).object);

  static final _id_sendDialerSpecialCode = jniAccessors.getMethodIDOf(
      _classRef, "sendDialerSpecialCode", "(Ljava/lang/String;)V");

  /// from: public void sendDialerSpecialCode(java.lang.String inputCode)
  ///
  /// Send the special dialer code. The IPC caller must be the current default dialer or have
  /// carrier privileges (see \#hasCarrierPrivileges).
  ///@param inputCode The special dialer code to send
  ///@throws SecurityException if the caller does not have carrier privileges or is not the
  ///         current default dialer
  void sendDialerSpecialCode(jni.JniString inputCode) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendDialerSpecialCode,
          jni.JniType.voidType, [inputCode.reference]).check();

  static final _id_getCallState =
      jniAccessors.getMethodIDOf(_classRef, "getCallState", "()I");

  /// from: public int getCallState()
  ///
  /// Returns one of the following constants that represents the current state of all
  /// phone calls.
  ///
  /// TelephonyManager\#CALL_STATE_RINGING
  /// TelephonyManager\#CALL_STATE_OFFHOOK
  /// TelephonyManager\#CALL_STATE_IDLE
  int getCallState() => jniAccessors.callMethodWithArgs(
      reference, _id_getCallState, jni.JniType.intType, []).integer;

  static final _id_getDataActivity =
      jniAccessors.getMethodIDOf(_classRef, "getDataActivity", "()I");

  /// from: public int getDataActivity()
  ///
  /// Returns a constant indicating the type of activity on a data connection
  /// (cellular).
  ///@see \#DATA_ACTIVITY_NONE
  ///@see \#DATA_ACTIVITY_IN
  ///@see \#DATA_ACTIVITY_OUT
  ///@see \#DATA_ACTIVITY_INOUT
  ///@see \#DATA_ACTIVITY_DORMANT
  int getDataActivity() => jniAccessors.callMethodWithArgs(
      reference, _id_getDataActivity, jni.JniType.intType, []).integer;

  static final _id_getDataState =
      jniAccessors.getMethodIDOf(_classRef, "getDataState", "()I");

  /// from: public int getDataState()
  ///
  /// Returns a constant indicating the current data connection state
  /// (cellular).
  ///@see \#DATA_DISCONNECTED
  ///@see \#DATA_CONNECTING
  ///@see \#DATA_CONNECTED
  ///@see \#DATA_SUSPENDED
  int getDataState() => jniAccessors.callMethodWithArgs(
      reference, _id_getDataState, jni.JniType.intType, []).integer;

  static final _id_listen = jniAccessors.getMethodIDOf(
      _classRef, "listen", "(Landroid/telephony/PhoneStateListener;I)V");

  /// from: public void listen(android.telephony.PhoneStateListener listener, int events)
  ///
  /// Registers a listener object to receive notification of changes
  /// in specified telephony states.
  ///
  /// To register a listener, pass a PhoneStateListener
  /// and specify at least one telephony state of interest in
  /// the events argument.
  ///
  /// At registration, and when a specified telephony state
  /// changes, the telephony manager invokes the appropriate
  /// callback method on the listener object and passes the
  /// current (updated) values.
  ///
  /// To unregister a listener, pass the listener object and set the
  /// events argument to
  /// PhoneStateListener\#LISTEN_NONE LISTEN_NONE (0).
  /// Note: if you call this method while in the middle of a binder transaction, you __must__
  /// call android.os.Binder\#clearCallingIdentity() before calling this method. A
  /// SecurityException will be thrown otherwise.
  ///@param listener The PhoneStateListener object to register
  ///                 (or unregister)
  ///@param events The telephony state(s) of interest to the listener,
  ///               as a bitwise-OR combination of PhoneStateListener
  ///               LISTEN_ flags.
  void listen(phonestatelistener_.PhoneStateListener listener, int events) =>
      jniAccessors.callMethodWithArgs(reference, _id_listen,
          jni.JniType.voidType, [listener.reference, events]).check();

  static final _id_isVoiceCapable =
      jniAccessors.getMethodIDOf(_classRef, "isVoiceCapable", "()Z");

  /// from: public boolean isVoiceCapable()
  ///
  /// @return true if the current device is "voice capable".
  ///
  /// "Voice capable" means that this device supports circuit-switched
  /// (i.e. voice) phone calls over the telephony network, and is allowed
  /// to display the in-call UI while a cellular voice call is active.
  /// This will be false on "data only" devices which can't make voice
  /// calls and don't support any in-call UI.
  ///
  /// Note: the meaning of this flag is subtly different from the
  /// PackageManager.FEATURE_TELEPHONY system feature, which is available
  /// on any device with a telephony radio, even if the device is
  /// data-only.
  bool isVoiceCapable() => jniAccessors.callMethodWithArgs(
      reference, _id_isVoiceCapable, jni.JniType.booleanType, []).boolean;

  static final _id_isSmsCapable =
      jniAccessors.getMethodIDOf(_classRef, "isSmsCapable", "()Z");

  /// from: public boolean isSmsCapable()
  ///
  /// @return true if the current device supports sms service.
  ///
  /// If true, this means that the device supports both sending and
  /// receiving sms via the telephony network.
  ///
  /// Note: Voicemail waiting sms, cell broadcasting sms, and MMS are
  ///       disabled when device doesn't support sms.
  bool isSmsCapable() => jniAccessors.callMethodWithArgs(
      reference, _id_isSmsCapable, jni.JniType.booleanType, []).boolean;

  static final _id_getAllCellInfo = jniAccessors.getMethodIDOf(
      _classRef, "getAllCellInfo", "()Ljava/util/List;");

  /// from: public java.util.List<android.telephony.CellInfo> getAllCellInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns all observed cell information from all radios on the
  /// device including the primary and neighboring cells. Calling this method does
  /// not trigger a call to android.telephony.PhoneStateListener\#onCellInfoChanged onCellInfoChanged(), or change the rate at which
  /// android.telephony.PhoneStateListener\#onCellInfoChanged onCellInfoChanged() is called.
  ///
  ///
  /// The list can include one or more android.telephony.CellInfoGsm CellInfoGsm,
  /// android.telephony.CellInfoCdma CellInfoCdma,
  /// android.telephony.CellInfoLte CellInfoLte, and
  /// android.telephony.CellInfoWcdma CellInfoWcdma objects, in any combination.
  /// On devices with multiple radios it is typical to see instances of
  /// one or more of any these in the list. In addition, zero, one, or more
  /// of the returned objects may be considered registered; that is, their
  /// android.telephony.CellInfo\#isRegistered CellInfo.isRegistered()
  /// methods may return true.
  ///
  /// This method returns valid data for registered cells on devices with
  /// android.content.pm.PackageManager\#FEATURE_TELEPHONY. In cases where only
  /// partial information is available for a particular CellInfo entry, unavailable fields
  /// will be reported as Integer.MAX_VALUE. All reported cells will include at least a
  /// valid set of technology-specific identification info and a power level measurement.
  ///
  ///
  /// This method is preferred over using android.telephony.TelephonyManager\#getCellLocation getCellLocation().
  /// However, for older devices, <code>getAllCellInfo()</code> may return
  /// null. In these cases, you should call android.telephony.TelephonyManager\#getCellLocation getCellLocation()
  /// instead.
  ///
  /// Requires android.Manifest.permission\#ACCESS_COARSE_LOCATION
  ///@return List of android.telephony.CellInfo; null if cell
  /// information is unavailable.
  jni.JniObject getAllCellInfo() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAllCellInfo, jni.JniType.objectType, []).object);

  static final _id_getMmsUserAgent = jniAccessors.getMethodIDOf(
      _classRef, "getMmsUserAgent", "()Ljava/lang/String;");

  /// from: public java.lang.String getMmsUserAgent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the MMS user agent.
  jni.JniString getMmsUserAgent() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMmsUserAgent, jni.JniType.objectType, []).object);

  static final _id_getMmsUAProfUrl = jniAccessors.getMethodIDOf(
      _classRef, "getMmsUAProfUrl", "()Ljava/lang/String;");

  /// from: public java.lang.String getMmsUAProfUrl()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the MMS user agent profile URL.
  jni.JniString getMmsUAProfUrl() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMmsUAProfUrl, jni.JniType.objectType, []).object);

  static final _id_iccOpenLogicalChannel = jniAccessors.getMethodIDOf(
      _classRef,
      "iccOpenLogicalChannel",
      "(Ljava/lang/String;)Landroid/telephony/IccOpenLogicalChannelResponse;");

  /// from: public android.telephony.IccOpenLogicalChannelResponse iccOpenLogicalChannel(java.lang.String AID)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Opens a logical channel to the ICC card.
  ///
  /// Input parameters equivalent to TS 27.007 AT+CCHO command.
  ///
  /// Requires Permission:
  /// android.Manifest.permission\#MODIFY_PHONE_STATE MODIFY_PHONE_STATE or that the calling
  /// app has carrier privileges (see \#hasCarrierPrivileges).
  ///@param AID Application id. See ETSI 102.221 and 101.220.
  ///@return an IccOpenLogicalChannelResponse object.
  ///@deprecated Replaced by \#iccOpenLogicalChannel(String, int)
  iccopenlogicalchannelresponse_.IccOpenLogicalChannelResponse
      iccOpenLogicalChannel(jni.JniString AID) =>
          iccopenlogicalchannelresponse_.IccOpenLogicalChannelResponse.fromRef(
              jniAccessors.callMethodWithArgs(
                  reference,
                  _id_iccOpenLogicalChannel,
                  jni.JniType.objectType,
                  [AID.reference]).object);

  static final _id_iccOpenLogicalChannel1 = jniAccessors.getMethodIDOf(
      _classRef,
      "iccOpenLogicalChannel",
      "(Ljava/lang/String;I)Landroid/telephony/IccOpenLogicalChannelResponse;");

  /// from: public android.telephony.IccOpenLogicalChannelResponse iccOpenLogicalChannel(java.lang.String AID, int p2)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Opens a logical channel to the ICC card.
  ///
  /// Input parameters equivalent to TS 27.007 AT+CCHO command.
  ///
  /// Requires Permission:
  /// android.Manifest.permission\#MODIFY_PHONE_STATE MODIFY_PHONE_STATE or that the calling
  /// app has carrier privileges (see \#hasCarrierPrivileges).
  ///@param AID Application id. See ETSI 102.221 and 101.220.
  ///@param p2 P2 parameter (described in ISO 7816-4).
  ///@return an IccOpenLogicalChannelResponse object.
  iccopenlogicalchannelresponse_.IccOpenLogicalChannelResponse
      iccOpenLogicalChannel1(jni.JniString AID, int p2) =>
          iccopenlogicalchannelresponse_.IccOpenLogicalChannelResponse.fromRef(
              jniAccessors.callMethodWithArgs(
                  reference,
                  _id_iccOpenLogicalChannel1,
                  jni.JniType.objectType,
                  [AID.reference, p2]).object);

  static final _id_iccCloseLogicalChannel =
      jniAccessors.getMethodIDOf(_classRef, "iccCloseLogicalChannel", "(I)Z");

  /// from: public boolean iccCloseLogicalChannel(int channel)
  ///
  /// Closes a previously opened logical channel to the ICC card.
  ///
  /// Input parameters equivalent to TS 27.007 AT+CCHC command.
  ///
  /// Requires Permission:
  /// android.Manifest.permission\#MODIFY_PHONE_STATE MODIFY_PHONE_STATE or that the calling
  /// app has carrier privileges (see \#hasCarrierPrivileges).
  ///@param channel is the channel id to be closed as retruned by a successful
  ///            iccOpenLogicalChannel.
  ///@return true if the channel was closed successfully.
  bool iccCloseLogicalChannel(int channel) => jniAccessors.callMethodWithArgs(
      reference,
      _id_iccCloseLogicalChannel,
      jni.JniType.booleanType,
      [channel]).boolean;

  static final _id_iccTransmitApduLogicalChannel = jniAccessors.getMethodIDOf(
      _classRef,
      "iccTransmitApduLogicalChannel",
      "(IIIIIILjava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String iccTransmitApduLogicalChannel(int channel, int cla, int instruction, int p1, int p2, int p3, java.lang.String data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Transmit an APDU to the ICC card over a logical channel.
  ///
  /// Input parameters equivalent to TS 27.007 AT+CGLA command.
  ///
  /// Requires Permission:
  /// android.Manifest.permission\#MODIFY_PHONE_STATE MODIFY_PHONE_STATE or that the calling
  /// app has carrier privileges (see \#hasCarrierPrivileges).
  ///@param channel is the channel id to be closed as returned by a successful
  ///            iccOpenLogicalChannel.
  ///@param cla Class of the APDU command.
  ///@param instruction Instruction of the APDU command.
  ///@param p1 P1 value of the APDU command.
  ///@param p2 P2 value of the APDU command.
  ///@param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU
  ///            is sent to the SIM.
  ///@param data Data to be sent with the APDU.
  ///@return The APDU response from the ICC card with the status appended at
  ///            the end.
  jni.JniString iccTransmitApduLogicalChannel(int channel, int cla,
          int instruction, int p1, int p2, int p3, jni.JniString data) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_iccTransmitApduLogicalChannel,
          jni.JniType.objectType,
          [channel, cla, instruction, p1, p2, p3, data.reference]).object);

  static final _id_iccTransmitApduBasicChannel = jniAccessors.getMethodIDOf(
      _classRef,
      "iccTransmitApduBasicChannel",
      "(IIIIILjava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String iccTransmitApduBasicChannel(int cla, int instruction, int p1, int p2, int p3, java.lang.String data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Transmit an APDU to the ICC card over the basic channel.
  ///
  /// Input parameters equivalent to TS 27.007 AT+CSIM command.
  ///
  /// Requires Permission:
  /// android.Manifest.permission\#MODIFY_PHONE_STATE MODIFY_PHONE_STATE or that the calling
  /// app has carrier privileges (see \#hasCarrierPrivileges).
  ///@param cla Class of the APDU command.
  ///@param instruction Instruction of the APDU command.
  ///@param p1 P1 value of the APDU command.
  ///@param p2 P2 value of the APDU command.
  ///@param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU
  ///            is sent to the SIM.
  ///@param data Data to be sent with the APDU.
  ///@return The APDU response from the ICC card with the status appended at
  ///            the end.
  jni.JniString iccTransmitApduBasicChannel(int cla, int instruction, int p1,
          int p2, int p3, jni.JniString data) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_iccTransmitApduBasicChannel,
          jni.JniType.objectType,
          [cla, instruction, p1, p2, p3, data.reference]).object);

  static final _id_iccExchangeSimIO = jniAccessors.getMethodIDOf(
      _classRef, "iccExchangeSimIO", "(IIIIILjava/lang/String;)[B");

  /// from: public byte[] iccExchangeSimIO(int fileID, int command, int p1, int p2, int p3, java.lang.String filePath)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the response APDU for a command APDU sent through SIM_IO.
  ///
  /// Requires Permission:
  /// android.Manifest.permission\#MODIFY_PHONE_STATE MODIFY_PHONE_STATE or that the calling
  /// app has carrier privileges (see \#hasCarrierPrivileges).
  ///@param fileID
  ///@param command
  ///@param p1 P1 value of the APDU command.
  ///@param p2 P2 value of the APDU command.
  ///@param p3 P3 value of the APDU command.
  ///@param filePath
  ///@return The APDU response.
  jni.JniObject iccExchangeSimIO(int fileID, int command, int p1, int p2,
          int p3, jni.JniString filePath) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_iccExchangeSimIO,
          jni.JniType.objectType,
          [fileID, command, p1, p2, p3, filePath.reference]).object);

  static final _id_sendEnvelopeWithStatus = jniAccessors.getMethodIDOf(
      _classRef,
      "sendEnvelopeWithStatus",
      "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String sendEnvelopeWithStatus(java.lang.String content)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Send ENVELOPE to the SIM and return the response.
  ///
  /// Requires Permission:
  /// android.Manifest.permission\#MODIFY_PHONE_STATE MODIFY_PHONE_STATE or that the calling
  /// app has carrier privileges (see \#hasCarrierPrivileges).
  ///@param content String containing SAT/USAT response in hexadecimal
  ///                format starting with command tag. See TS 102 223 for
  ///                details.
  ///@return The APDU response from the ICC card in hexadecimal format
  ///         with the last 4 bytes being the status word. If the command fails,
  ///         returns an empty string.
  jni.JniString sendEnvelopeWithStatus(jni.JniString content) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_sendEnvelopeWithStatus,
          jni.JniType.objectType,
          [content.reference]).object);

  static final _id_getIccAuthentication = jniAccessors.getMethodIDOf(_classRef,
      "getIccAuthentication", "(IILjava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String getIccAuthentication(int appType, int authType, java.lang.String data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the response of authentication for the default subscription.
  /// Returns null if the authentication hasn't been successful
  ///
  /// Requires Permission: READ_PRIVILEGED_PHONE_STATE or that the calling
  /// app has carrier privileges (see \#hasCarrierPrivileges).
  ///@param appType the icc application type, like \#APPTYPE_USIM
  ///@param authType the authentication type, \#AUTHTYPE_EAP_AKA or
  /// \#AUTHTYPE_EAP_SIM
  ///@param data authentication challenge data, base64 encoded.
  /// See 3GPP TS 31.102 7.1.2 for more details.
  ///@return the response of authentication. This value will be null in the following cases:
  ///   Authentication error, incorrect MAC
  ///   Authentication error, security context not supported
  ///   Key freshness failure
  ///   Authentication error, no memory space available
  ///   Authentication error, no memory space available in EFMUK
  jni.JniString getIccAuthentication(
          int appType, int authType, jni.JniString data) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getIccAuthentication,
          jni.JniType.objectType,
          [appType, authType, data.reference]).object);

  static final _id_getForbiddenPlmns = jniAccessors.getMethodIDOf(
      _classRef, "getForbiddenPlmns", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getForbiddenPlmns()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an array of Forbidden PLMNs from the USIM App
  /// Returns null if the query fails.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@return an array of forbidden PLMNs or null if not available
  jni.JniObject getForbiddenPlmns() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getForbiddenPlmns, jni.JniType.objectType, []).object);

  static final _id_setNetworkSelectionModeAutomatic = jniAccessors
      .getMethodIDOf(_classRef, "setNetworkSelectionModeAutomatic", "()V");

  /// from: public void setNetworkSelectionModeAutomatic()
  ///
  /// Sets the network selection mode to automatic.
  ///
  /// Requires Permission:
  /// android.Manifest.permission\#MODIFY_PHONE_STATE MODIFY_PHONE_STATE or that the calling
  /// app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#MODIFY_PHONE_STATE
  void setNetworkSelectionModeAutomatic() => jniAccessors.callMethodWithArgs(
      reference,
      _id_setNetworkSelectionModeAutomatic,
      jni.JniType.voidType, []).check();

  static final _id_requestNetworkScan = jniAccessors.getMethodIDOf(
      _classRef,
      "requestNetworkScan",
      "(Landroid/telephony/NetworkScanRequest;Ljava/util/concurrent/Executor;Landroid/telephony/TelephonyScanManager\$NetworkScanCallback;)Landroid/telephony/NetworkScan;");

  /// from: public android.telephony.NetworkScan requestNetworkScan(android.telephony.NetworkScanRequest request, java.util.concurrent.Executor executor, android.telephony.TelephonyScanManager.NetworkScanCallback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Request a network scan.
  ///
  /// This method is asynchronous, so the network scan results will be returned by callback.
  /// The returned NetworkScan will contain a callback method which can be used to stop the scan.
  ///
  /// Requires Permission:
  /// android.Manifest.permission\#MODIFY_PHONE_STATE MODIFY_PHONE_STATE or that the calling
  /// app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#MODIFY_PHONE_STATE
  ///@param request Contains all the RAT with bands/channels that need to be scanned.
  ///@param executor The executor through which the callback should be invoked. Since the scan
  ///        request may trigger multiple callbacks and they must be invoked in the same order as
  ///        they are received by the platform, the user should provide an executor which executes
  ///        tasks one at a time in serial order. For example AsyncTask.SERIAL_EXECUTOR.
  ///@param callback Returns network scan results or errors.
  ///@return A NetworkScan obj which contains a callback which can be used to stop the scan.
  networkscan_.NetworkScan requestNetworkScan(
          networkscanrequest_.NetworkScanRequest request,
          jni.JniObject executor,
          telephonyscanmanager_.TelephonyScanManager_NetworkScanCallback
              callback) =>
      networkscan_.NetworkScan.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_requestNetworkScan,
          jni.JniType.objectType,
          [request.reference, executor.reference, callback.reference]).object);

  static final _id_setNetworkSelectionModeManual = jniAccessors.getMethodIDOf(
      _classRef, "setNetworkSelectionModeManual", "(Ljava/lang/String;Z)Z");

  /// from: public boolean setNetworkSelectionModeManual(java.lang.String operatorNumeric, boolean persistSelection)
  ///
  /// Ask the radio to connect to the input network and change selection mode to manual.
  ///
  /// Requires Permission:
  /// android.Manifest.permission\#MODIFY_PHONE_STATE MODIFY_PHONE_STATE or that the calling
  /// app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#MODIFY_PHONE_STATE
  ///@param operatorNumeric the PLMN ID of the network to select.
  ///@param persistSelection whether the selection will persist until reboot. If true, only allows
  /// attaching to the selected PLMN until reboot; otherwise, attach to the chosen PLMN and resume
  /// normal network selection next time.
  ///@return true on success; false on any failure.
  bool setNetworkSelectionModeManual(
          jni.JniString operatorNumeric, bool persistSelection) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setNetworkSelectionModeManual,
          jni.JniType.booleanType,
          [operatorNumeric.reference, persistSelection]).boolean;

  static final _id_setPreferredNetworkTypeToGlobal = jniAccessors.getMethodIDOf(
      _classRef, "setPreferredNetworkTypeToGlobal", "()Z");

  /// from: public boolean setPreferredNetworkTypeToGlobal()
  ///
  /// Set the preferred network type to global mode which includes LTE, CDMA, EvDo and GSM/WCDMA.
  ///
  /// Requires that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///@return true on success; false on any failure.
  bool setPreferredNetworkTypeToGlobal() => jniAccessors.callMethodWithArgs(
      reference,
      _id_setPreferredNetworkTypeToGlobal,
      jni.JniType.booleanType, []).boolean;

  static final _id_hasCarrierPrivileges =
      jniAccessors.getMethodIDOf(_classRef, "hasCarrierPrivileges", "()Z");

  /// from: public boolean hasCarrierPrivileges()
  ///
  /// Has the calling application been granted carrier privileges by the carrier.
  ///
  /// If any of the packages in the calling UID has carrier privileges, the
  /// call will return true. This access is granted by the owner of the UICC
  /// card and does not depend on the registered carrier.
  ///@return true if the app has carrier privileges.
  bool hasCarrierPrivileges() => jniAccessors.callMethodWithArgs(
      reference, _id_hasCarrierPrivileges, jni.JniType.booleanType, []).boolean;

  static final _id_setOperatorBrandOverride = jniAccessors.getMethodIDOf(
      _classRef, "setOperatorBrandOverride", "(Ljava/lang/String;)Z");

  /// from: public boolean setOperatorBrandOverride(java.lang.String brand)
  ///
  /// Override the branding for the current ICCID.
  ///
  /// Once set, whenever the SIM is present in the device, the service
  /// provider name (SPN) and the operator name will both be replaced by the
  /// brand value input. To unset the value, the same function should be
  /// called with a null brand value.
  ///
  /// Requires that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///@param brand The brand name to display/set.
  ///@return true if the operation was executed correctly.
  bool setOperatorBrandOverride(jni.JniString brand) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOperatorBrandOverride,
          jni.JniType.booleanType, [brand.reference]).boolean;

  static final _id_sendUssdRequest = jniAccessors.getMethodIDOf(
      _classRef,
      "sendUssdRequest",
      "(Ljava/lang/String;Landroid/telephony/TelephonyManager\$UssdResponseCallback;Landroid/os/Handler;)V");

  /// from: public void sendUssdRequest(java.lang.String ussdRequest, android.telephony.TelephonyManager.UssdResponseCallback callback, android.os.Handler handler)
  ///
  /// Sends an Unstructured Supplementary Service Data (USSD) request to the mobile network and
  /// informs the caller of the response via the supplied {@code callback}.
  /// Carriers define USSD codes which can be sent by the user to request information such as
  /// the user's current data balance or minutes balance.
  /// Requires permission:
  /// android.Manifest.permission\#CALL_PHONE
  /// Requires android.Manifest.permission\#CALL_PHONE
  ///@param ussdRequest the USSD command to be executed.
  ///@param callback called by the framework to inform the caller of the result of executing the
  ///                 USSD request (see UssdResponseCallback).
  ///@param handler the Handler to run the request on.
  void sendUssdRequest(
          jni.JniString ussdRequest,
          TelephonyManager_UssdResponseCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_sendUssdRequest, jni.JniType.voidType, [
        ussdRequest.reference,
        callback.reference,
        handler.reference
      ]).check();

  static final _id_isConcurrentVoiceAndDataSupported = jniAccessors
      .getMethodIDOf(_classRef, "isConcurrentVoiceAndDataSupported", "()Z");

  /// from: public boolean isConcurrentVoiceAndDataSupported()
  ///
  /// Whether the device is currently on a technology (e.g.&nbsp;UMTS or LTE) which can support
  /// voice and data simultaneously. This can change based on location or network condition.
  ///@return {@code true} if simultaneous voice and data supported, and {@code false} otherwise.
  bool isConcurrentVoiceAndDataSupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isConcurrentVoiceAndDataSupported,
      jni.JniType.booleanType, []).boolean;

  static final _id_setDataEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setDataEnabled", "(Z)V");

  /// from: public void setDataEnabled(boolean enable)
  ///
  /// Turns mobile data on or off.
  /// If this object has been created with \#createForSubscriptionId, applies to the given
  /// subId. Otherwise, applies to SubscriptionManager\#getDefaultDataSubscriptionId()
  ///
  /// Requires Permission:
  /// android.Manifest.permission\#MODIFY_PHONE_STATE MODIFY_PHONE_STATE or that the calling
  /// app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#MODIFY_PHONE_STATE
  ///@param enable Whether to enable mobile data.
  void setDataEnabled(bool enable) => jniAccessors.callMethodWithArgs(
      reference, _id_setDataEnabled, jni.JniType.voidType, [enable]).check();

  static final _id_isDataEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isDataEnabled", "()Z");

  /// from: public boolean isDataEnabled()
  ///
  /// Returns whether mobile data is enabled or not per user setting. There are other factors
  /// that could disable mobile data, but they are not considered here.
  ///
  /// If this object has been created with \#createForSubscriptionId, applies to the given
  /// subId. Otherwise, applies to SubscriptionManager\#getDefaultDataSubscriptionId()
  ///
  /// Requires one of the following permissions:
  /// android.Manifest.permission\#ACCESS_NETWORK_STATE ACCESS_NETWORK_STATE,
  /// android.Manifest.permission\#MODIFY_PHONE_STATE MODIFY_PHONE_STATE, or that the
  /// calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Note that this does not take into account any data restrictions that may be present on the
  /// calling app. Such restrictions may be inspected with
  /// ConnectivityManager\#getRestrictBackgroundStatus.
  ///@return true if mobile data is enabled.
  bool isDataEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isDataEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_canChangeDtmfToneLength =
      jniAccessors.getMethodIDOf(_classRef, "canChangeDtmfToneLength", "()Z");

  /// from: public boolean canChangeDtmfToneLength()
  ///
  /// Whether the device supports configuring the DTMF tone length.
  ///@return {@code true} if the DTMF tone length can be changed, and {@code false} otherwise.
  bool canChangeDtmfToneLength() => jniAccessors.callMethodWithArgs(reference,
      _id_canChangeDtmfToneLength, jni.JniType.booleanType, []).boolean;

  static final _id_isWorldPhone =
      jniAccessors.getMethodIDOf(_classRef, "isWorldPhone", "()Z");

  /// from: public boolean isWorldPhone()
  ///
  /// Whether the device is a world phone.
  ///@return {@code true} if the device is a world phone, and {@code false} otherwise.
  bool isWorldPhone() => jniAccessors.callMethodWithArgs(
      reference, _id_isWorldPhone, jni.JniType.booleanType, []).boolean;

  static final _id_isTtyModeSupported =
      jniAccessors.getMethodIDOf(_classRef, "isTtyModeSupported", "()Z");

  /// from: public boolean isTtyModeSupported()
  ///
  /// @deprecated Use TelecomManager\#isTtySupported() instead
  /// Whether the phone supports TTY mode.
  ///@return {@code true} if the device supports TTY mode, and {@code false} otherwise.
  bool isTtyModeSupported() => jniAccessors.callMethodWithArgs(
      reference, _id_isTtyModeSupported, jni.JniType.booleanType, []).boolean;

  static final _id_isHearingAidCompatibilitySupported = jniAccessors
      .getMethodIDOf(_classRef, "isHearingAidCompatibilitySupported", "()Z");

  /// from: public boolean isHearingAidCompatibilitySupported()
  ///
  /// Whether the phone supports hearing aid compatibility.
  ///@return {@code true} if the device supports hearing aid compatibility, and {@code false}
  /// otherwise.
  bool isHearingAidCompatibilitySupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isHearingAidCompatibilitySupported,
      jni.JniType.booleanType, []).boolean;

  static final _id_getServiceState = jniAccessors.getMethodIDOf(
      _classRef, "getServiceState", "()Landroid/telephony/ServiceState;");

  /// from: public android.telephony.ServiceState getServiceState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current ServiceState information.
  ///
  /// Requires Permission: android.Manifest.permission\#READ_PHONE_STATE READ_PHONE_STATE
  /// or that the calling app has carrier privileges (see \#hasCarrierPrivileges).
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  servicestate_.ServiceState getServiceState() =>
      servicestate_.ServiceState.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getServiceState, jni.JniType.objectType, []).object);

  static final _id_getVoicemailRingtoneUri = jniAccessors.getMethodIDOf(
      _classRef,
      "getVoicemailRingtoneUri",
      "(Landroid/telecom/PhoneAccountHandle;)Landroid/net/Uri;");

  /// from: public android.net.Uri getVoicemailRingtoneUri(android.telecom.PhoneAccountHandle accountHandle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the URI for the per-account voicemail ringtone set in Phone settings.
  ///@param accountHandle The handle for the PhoneAccount for which to retrieve the
  /// voicemail ringtone.
  ///@return The URI for the ringtone to play when receiving a voicemail from a specific
  /// PhoneAccount.
  uri_.Uri getVoicemailRingtoneUri(
          phoneaccounthandle_.PhoneAccountHandle accountHandle) =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getVoicemailRingtoneUri,
          jni.JniType.objectType,
          [accountHandle.reference]).object);

  static final _id_setVoicemailRingtoneUri = jniAccessors.getMethodIDOf(
      _classRef,
      "setVoicemailRingtoneUri",
      "(Landroid/telecom/PhoneAccountHandle;Landroid/net/Uri;)V");

  /// from: public void setVoicemailRingtoneUri(android.telecom.PhoneAccountHandle phoneAccountHandle, android.net.Uri uri)
  ///
  /// Sets the per-account voicemail ringtone.
  ///
  /// Requires that the calling app is the default dialer, or has carrier privileges (see
  /// \#hasCarrierPrivileges, or has permission
  /// android.Manifest.permission\#MODIFY_PHONE_STATE MODIFY_PHONE_STATE.
  ///@param phoneAccountHandle The handle for the PhoneAccount for which to set the
  /// voicemail ringtone.
  ///@param uri The URI for the ringtone to play when receiving a voicemail from a specific
  /// PhoneAccount.
  ///@deprecated Use android.provider.Settings\#ACTION_CHANNEL_NOTIFICATION_SETTINGS
  /// instead.
  void setVoicemailRingtoneUri(
          phoneaccounthandle_.PhoneAccountHandle phoneAccountHandle,
          uri_.Uri uri) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setVoicemailRingtoneUri,
          jni.JniType.voidType,
          [phoneAccountHandle.reference, uri.reference]).check();

  static final _id_isVoicemailVibrationEnabled = jniAccessors.getMethodIDOf(
      _classRef,
      "isVoicemailVibrationEnabled",
      "(Landroid/telecom/PhoneAccountHandle;)Z");

  /// from: public boolean isVoicemailVibrationEnabled(android.telecom.PhoneAccountHandle accountHandle)
  ///
  /// Returns whether vibration is set for voicemail notification in Phone settings.
  ///@param accountHandle The handle for the PhoneAccount for which to retrieve the
  /// voicemail vibration setting.
  ///@return {@code true} if the vibration is set for this PhoneAccount, {@code false} otherwise.
  bool isVoicemailVibrationEnabled(
          phoneaccounthandle_.PhoneAccountHandle accountHandle) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isVoicemailVibrationEnabled,
          jni.JniType.booleanType,
          [accountHandle.reference]).boolean;

  static final _id_setVoicemailVibrationEnabled = jniAccessors.getMethodIDOf(
      _classRef,
      "setVoicemailVibrationEnabled",
      "(Landroid/telecom/PhoneAccountHandle;Z)V");

  /// from: public void setVoicemailVibrationEnabled(android.telecom.PhoneAccountHandle phoneAccountHandle, boolean enabled)
  ///
  /// Sets the per-account preference whether vibration is enabled for voicemail notifications.
  ///
  /// Requires that the calling app is the default dialer, or has carrier privileges (see
  /// \#hasCarrierPrivileges, or has permission
  /// android.Manifest.permission\#MODIFY_PHONE_STATE MODIFY_PHONE_STATE.
  ///@param phoneAccountHandle The handle for the PhoneAccount for which to set the
  /// voicemail vibration setting.
  ///@param enabled Whether to enable or disable vibration for voicemail notifications from a
  /// specific PhoneAccount.
  ///@deprecated Use android.provider.Settings\#ACTION_CHANNEL_NOTIFICATION_SETTINGS
  /// instead.
  void setVoicemailVibrationEnabled(
          phoneaccounthandle_.PhoneAccountHandle phoneAccountHandle,
          bool enabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setVoicemailVibrationEnabled,
          jni.JniType.voidType,
          [phoneAccountHandle.reference, enabled]).check();

  static final _id_getSimCarrierId =
      jniAccessors.getMethodIDOf(_classRef, "getSimCarrierId", "()I");

  /// from: public int getSimCarrierId()
  ///
  /// Returns carrier id of the current subscription.
  /// To recognize a carrier (including MVNO) as a first-class identity, Android assigns each
  /// carrier with a canonical integer a.k.a. carrier id. The carrier ID is an Android
  /// platform-wide identifier for a carrier. AOSP maintains carrier ID assignments in
  /// <a href="https://android.googlesource.com/platform/packages/providers/TelephonyProvider/+/master/assets/carrier_list.textpb">here</a>
  ///
  /// Apps which have carrier-specific configurations or business logic can use the carrier id
  /// as an Android platform-wide identifier for carriers.
  ///@return Carrier id of the current subscription. Return \#UNKNOWN_CARRIER_ID if the
  /// subscription is unavailable or the carrier cannot be identified.
  int getSimCarrierId() => jniAccessors.callMethodWithArgs(
      reference, _id_getSimCarrierId, jni.JniType.intType, []).integer;

  static final _id_getSimCarrierIdName = jniAccessors.getMethodIDOf(
      _classRef, "getSimCarrierIdName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getSimCarrierIdName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns carrier id name of the current subscription.
  /// Carrier id name is a user-facing name of carrier id
  /// \#getSimCarrierId(), usually the brand name of the subsidiary
  /// (e.g. T-Mobile). Each carrier could configure multiple \#getSimOperatorName() SPN but
  /// should have a single carrier name. Carrier name is not a canonical identity,
  /// use \#getSimCarrierId() instead.
  /// The returned carrier name is unlocalized.
  ///@return Carrier name of the current subscription. Return {@code null} if the subscription is
  /// unavailable or the carrier cannot be identified.
  jni.JniObject getSimCarrierIdName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSimCarrierIdName, jni.JniType.objectType, []).object);

  static final _id_getSignalStrength = jniAccessors.getMethodIDOf(
      _classRef, "getSignalStrength", "()Landroid/telephony/SignalStrength;");

  /// from: public android.telephony.SignalStrength getSignalStrength()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the most recently available signal strength information.
  ///
  /// Get the most recent SignalStrength information reported by the modem. Due
  /// to power saving this information may not always be current.
  ///@return the most recent cached signal strength info from the modem
  ///
  /// This value may be {@code null}.
  signalstrength_.SignalStrength getSignalStrength() =>
      signalstrength_.SignalStrength.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSignalStrength, jni.JniType.objectType, []).object);
}

/// from: android.telephony.TelephonyManager$UssdResponseCallback
///
/// Used to notify callers of
/// TelephonyManager\#sendUssdRequest(String, UssdResponseCallback, Handler) when the
/// network either successfully executes a USSD request, or if there was a failure while
/// executing the request.
///
/// \#onReceiveUssdResponse(TelephonyManager, String, CharSequence) will be called if the
/// USSD request has succeeded.
/// \#onReceiveUssdResponseFailed(TelephonyManager, String, int) will be called if the
/// USSD request has failed.
class TelephonyManager_UssdResponseCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/telephony/TelephonyManager\$UssdResponseCallback");
  TelephonyManager_UssdResponseCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  TelephonyManager_UssdResponseCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onReceiveUssdResponse = jniAccessors.getMethodIDOf(
      _classRef,
      "onReceiveUssdResponse",
      "(Landroid/telephony/TelephonyManager;Ljava/lang/String;Ljava/lang/CharSequence;)V");

  /// from: public void onReceiveUssdResponse(android.telephony.TelephonyManager telephonyManager, java.lang.String request, java.lang.CharSequence response)
  ///
  /// Called when a USSD request has succeeded.  The {@code response} contains the USSD
  /// response received from the network.  The calling app can choose to either display the
  /// response to the user or perform some operation based on the response.
  ///
  /// USSD responses are unstructured text and their content is determined by the mobile network
  /// operator.
  ///@param telephonyManager the TelephonyManager the callback is registered to.
  ///@param request the USSD request sent to the mobile network.
  ///@param response the response to the USSD request provided by the mobile network.
  void onReceiveUssdResponse(TelephonyManager telephonyManager,
          jni.JniString request, jni.JniObject response) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onReceiveUssdResponse, jni.JniType.voidType, [
        telephonyManager.reference,
        request.reference,
        response.reference
      ]).check();

  static final _id_onReceiveUssdResponseFailed = jniAccessors.getMethodIDOf(
      _classRef,
      "onReceiveUssdResponseFailed",
      "(Landroid/telephony/TelephonyManager;Ljava/lang/String;I)V");

  /// from: public void onReceiveUssdResponseFailed(android.telephony.TelephonyManager telephonyManager, java.lang.String request, int failureCode)
  ///
  /// Called when a USSD request has failed to complete.
  ///@param telephonyManager the TelephonyManager the callback is registered to.
  ///@param request the USSD request sent to the mobile network.
  ///@param failureCode failure code indicating why the request failed.  Will be either
  ///        TelephonyManager\#USSD_RETURN_FAILURE or
  ///        TelephonyManager\#USSD_ERROR_SERVICE_UNAVAIL.
  void onReceiveUssdResponseFailed(TelephonyManager telephonyManager,
          jni.JniString request, int failureCode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onReceiveUssdResponseFailed,
          jni.JniType.voidType,
          [telephonyManager.reference, request.reference, failureCode]).check();
}
