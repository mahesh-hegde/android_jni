// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../content/res/TypedArray.dart" as typedarray_;

import "../content/Intent.dart" as intent_;

import "PreferenceDataStore.dart" as preferencedatastore_;

import "../os/Bundle.dart" as bundle_;

import "../view/View.dart" as view_;

import "../view/ViewGroup.dart" as viewgroup_;

import "../graphics/drawable/Drawable.dart" as drawable_;

import "../content/SharedPreferences.dart" as sharedpreferences_;

import "PreferenceManager.dart" as preferencemanager_;

import "PreferenceGroup.dart" as preferencegroup_;

import "../os/Parcelable.dart" as parcelable_;

import "../view/AbsSavedState.dart" as abssavedstate_;

import "../os/Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.preference.Preference
///
/// Represents the basic Preference UI building
/// block displayed by a PreferenceActivity in the form of a
/// ListView. This class provides the View to be displayed in
/// the activity and associates with a SharedPreferences to
/// store/retrieve the preference data.
///
/// When specifying a preference hierarchy in XML, each element can point to a
/// subclass of Preference, similar to the view hierarchy and layouts.
///
/// This class contains a {@code key} that will be used as the key into the
/// SharedPreferences. It is up to the subclass to decide how to store
/// the value.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For information about building a settings UI with Preferences,
/// read the <a href="{@docRoot}guide/topics/ui/settings.html">Settings</a>
/// guide.
///
/// </div>
///@attr ref android.R.styleable\#Preference_icon
///@attr ref android.R.styleable\#Preference_key
///@attr ref android.R.styleable\#Preference_title
///@attr ref android.R.styleable\#Preference_summary
///@attr ref android.R.styleable\#Preference_order
///@attr ref android.R.styleable\#Preference_fragment
///@attr ref android.R.styleable\#Preference_layout
///@attr ref android.R.styleable\#Preference_widgetLayout
///@attr ref android.R.styleable\#Preference_enabled
///@attr ref android.R.styleable\#Preference_selectable
///@attr ref android.R.styleable\#Preference_dependency
///@attr ref android.R.styleable\#Preference_persistent
///@attr ref android.R.styleable\#Preference_defaultValue
///@attr ref android.R.styleable\#Preference_shouldDisableView
///@attr ref android.R.styleable\#Preference_recycleEnabled
///@attr ref android.R.styleable\#Preference_singleLineTitle
///@attr ref android.R.styleable\#Preference_iconSpaceReserved
class Preference extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/preference/Preference");
  Preference.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DEFAULT_ORDER
  ///
  /// Specify for \#setOrder(int) if a specific order is not required.
  static const DEFAULT_ORDER = 2147483647;

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform inflation from XML and apply a class-specific base style. This
  /// constructor of Preference allows subclasses to use their own base style
  /// when they are inflating. For example, a CheckBoxPreference
  /// constructor calls this version of the super class constructor and
  /// supplies {@code android.R.attr.checkBoxPreferenceStyle} for
  /// <var>defStyleAttr</var>. This allows the theme's checkbox preference
  /// style to modify all of the base preference attributes as well as the
  /// CheckBoxPreference class's attributes.
  ///@param context The Context this is associated with, through which it can
  ///            access the current theme, resources,
  ///            SharedPreferences, etc.
  ///@param attrs The attributes of the XML tag that is inflating the
  ///            preference.
  ///@param defStyleAttr An attribute in the current theme that contains a
  ///            reference to a style resource that supplies default values for
  ///            the view. Can be 0 to not look for defaults.
  ///@param defStyleRes A resource identifier of a style resource that
  ///            supplies default values for the view, used only if
  ///            defStyleAttr is 0 or can not be found in the theme. Can be 0
  ///            to not look for defaults.
  ///@see \#Preference(Context, AttributeSet)
  Preference(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform inflation from XML and apply a class-specific base style. This
  /// constructor of Preference allows subclasses to use their own base style
  /// when they are inflating. For example, a CheckBoxPreference
  /// constructor calls this version of the super class constructor and
  /// supplies {@code android.R.attr.checkBoxPreferenceStyle} for
  /// <var>defStyleAttr</var>. This allows the theme's checkbox preference
  /// style to modify all of the base preference attributes as well as the
  /// CheckBoxPreference class's attributes.
  ///@param context The Context this is associated with, through which it can
  ///            access the current theme, resources,
  ///            SharedPreferences, etc.
  ///@param attrs The attributes of the XML tag that is inflating the
  ///            preference.
  ///@param defStyleAttr An attribute in the current theme that contains a
  ///            reference to a style resource that supplies default values for
  ///            the view. Can be 0 to not look for defaults.
  ///@see \#Preference(Context, AttributeSet)
  Preference.ctor1(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor that is called when inflating a Preference from XML. This is
  /// called when a Preference is being constructed from an XML file, supplying
  /// attributes that were specified in the XML file. This version uses a
  /// default style of 0, so the only attribute values applied are those in the
  /// Context's Theme and the given AttributeSet.
  ///@param context The Context this is associated with, through which it can
  ///            access the current theme, resources, SharedPreferences,
  ///            etc.
  ///@param attrs The attributes of the XML tag that is inflating the
  ///            preference.
  ///@see \#Preference(Context, AttributeSet, int)
  Preference.ctor2(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [context.reference, attrs.reference]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor to create a Preference.
  ///@param context The Context in which to store Preference values.
  Preference.ctor3(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor3, [context.reference]).object);

  static final _id_onGetDefaultValue = jniAccessors.getMethodIDOf(
      _classRef,
      "onGetDefaultValue",
      "(Landroid/content/res/TypedArray;I)Ljava/lang/Object;");

  /// from: protected java.lang.Object onGetDefaultValue(android.content.res.TypedArray a, int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called when a Preference is being inflated and the default value
  /// attribute needs to be read. Since different Preference types have
  /// different value types, the subclass should get and return the default
  /// value which will be its value type.
  ///
  /// For example, if the value type is String, the body of the method would
  /// proxy to TypedArray\#getString(int).
  ///@param a The set of attributes.
  ///@param index The index of the default value attribute.
  ///@return The default value of this preference type.
  jni.JniObject onGetDefaultValue(typedarray_.TypedArray a, int index) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onGetDefaultValue,
          jni.JniType.objectType,
          [a.reference, index]).object);

  static final _id_setIntent = jniAccessors.getMethodIDOf(
      _classRef, "setIntent", "(Landroid/content/Intent;)V");

  /// from: public void setIntent(android.content.Intent intent)
  ///
  /// Sets an Intent to be used for
  /// Context\#startActivity(Intent) when this Preference is clicked.
  ///@param intent The intent associated with this Preference.
  void setIntent(intent_.Intent intent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setIntent,
      jni.JniType.voidType,
      [intent.reference]).check();

  static final _id_getIntent = jniAccessors.getMethodIDOf(
      _classRef, "getIntent", "()Landroid/content/Intent;");

  /// from: public android.content.Intent getIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Intent associated with this Preference.
  ///@return The Intent last set via \#setIntent(Intent) or XML.
  intent_.Intent getIntent() =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIntent, jni.JniType.objectType, []).object);

  static final _id_setFragment = jniAccessors.getMethodIDOf(
      _classRef, "setFragment", "(Ljava/lang/String;)V");

  /// from: public void setFragment(java.lang.String fragment)
  ///
  /// Sets the class name of a fragment to be shown when this Preference is clicked.
  ///@param fragment The class name of the fragment associated with this Preference.
  void setFragment(jni.JniString fragment) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFragment,
      jni.JniType.voidType,
      [fragment.reference]).check();

  static final _id_getFragment = jniAccessors.getMethodIDOf(
      _classRef, "getFragment", "()Ljava/lang/String;");

  /// from: public java.lang.String getFragment()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the fragment class name associated with this Preference.
  ///@return The fragment class name last set via \#setFragment or XML.
  jni.JniString getFragment() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFragment, jni.JniType.objectType, []).object);

  static final _id_setPreferenceDataStore = jniAccessors.getMethodIDOf(
      _classRef,
      "setPreferenceDataStore",
      "(Landroid/preference/PreferenceDataStore;)V");

  /// from: public void setPreferenceDataStore(android.preference.PreferenceDataStore dataStore)
  ///
  /// Sets a PreferenceDataStore to be used by this Preference instead of using
  /// android.content.SharedPreferences.
  ///
  /// The data store will remain assigned even if the Preference is moved around the preference
  /// hierarchy. It will also override a data store propagated from the PreferenceManager
  /// that owns this Preference.
  ///@param dataStore The PreferenceDataStore to be used by this Preference.
  ///@see PreferenceManager\#setPreferenceDataStore(PreferenceDataStore)
  void setPreferenceDataStore(
          preferencedatastore_.PreferenceDataStore dataStore) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPreferenceDataStore,
          jni.JniType.voidType, [dataStore.reference]).check();

  static final _id_getPreferenceDataStore = jniAccessors.getMethodIDOf(
      _classRef,
      "getPreferenceDataStore",
      "()Landroid/preference/PreferenceDataStore;");

  /// from: public android.preference.PreferenceDataStore getPreferenceDataStore()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns PreferenceDataStore used by this Preference. Returns {@code null} if
  /// android.content.SharedPreferences is used instead.
  ///
  /// By default preferences always use android.content.SharedPreferences. To make this
  /// preference to use the PreferenceDataStore you need to assign your implementation
  /// to the Preference itself via \#setPreferenceDataStore(PreferenceDataStore) or to its
  /// PreferenceManager via
  /// PreferenceManager\#setPreferenceDataStore(PreferenceDataStore).
  ///@return The PreferenceDataStore used by this Preference or {@code null} if none.
  preferencedatastore_.PreferenceDataStore getPreferenceDataStore() =>
      preferencedatastore_.PreferenceDataStore.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getPreferenceDataStore,
              jni.JniType.objectType, []).object);

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the extras Bundle object associated with this preference, creating
  /// a new Bundle if there currently isn't one.  You can use this to get and
  /// set individual extra key/value pairs.
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_peekExtras = jniAccessors.getMethodIDOf(
      _classRef, "peekExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle peekExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the extras Bundle object associated with this preference, returning {@code null} if
  /// there is not currently one.
  bundle_.Bundle peekExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_peekExtras, jni.JniType.objectType, []).object);

  static final _id_setLayoutResource =
      jniAccessors.getMethodIDOf(_classRef, "setLayoutResource", "(I)V");

  /// from: public void setLayoutResource(int layoutResId)
  ///
  /// Sets the layout resource that is inflated as the View to be shown
  /// for this Preference. In most cases, the default layout is sufficient for
  /// custom Preference objects and only the widget layout needs to be changed.
  ///
  /// This layout should contain a ViewGroup with ID
  /// android.R.id\#widget_frame to be the parent of the specific widget
  /// for this Preference. It should similarly contain
  /// android.R.id\#title and android.R.id\#summary.
  ///@param layoutResId The layout resource ID to be inflated and returned as
  ///            a View.
  ///@see \#setWidgetLayoutResource(int)
  void setLayoutResource(int layoutResId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLayoutResource,
      jni.JniType.voidType,
      [layoutResId]).check();

  static final _id_getLayoutResource =
      jniAccessors.getMethodIDOf(_classRef, "getLayoutResource", "()I");

  /// from: public int getLayoutResource()
  ///
  /// Gets the layout resource that will be shown as the View for this Preference.
  ///@return The layout resource ID.
  int getLayoutResource() => jniAccessors.callMethodWithArgs(
      reference, _id_getLayoutResource, jni.JniType.intType, []).integer;

  static final _id_setWidgetLayoutResource =
      jniAccessors.getMethodIDOf(_classRef, "setWidgetLayoutResource", "(I)V");

  /// from: public void setWidgetLayoutResource(int widgetLayoutResId)
  ///
  /// Sets the layout for the controllable widget portion of this Preference. This
  /// is inflated into the main layout. For example, a CheckBoxPreference
  /// would specify a custom layout (consisting of just the CheckBox) here,
  /// instead of creating its own main layout.
  ///@param widgetLayoutResId The layout resource ID to be inflated into the
  ///            main layout.
  ///@see \#setLayoutResource(int)
  void setWidgetLayoutResource(int widgetLayoutResId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setWidgetLayoutResource,
          jni.JniType.voidType, [widgetLayoutResId]).check();

  static final _id_getWidgetLayoutResource =
      jniAccessors.getMethodIDOf(_classRef, "getWidgetLayoutResource", "()I");

  /// from: public int getWidgetLayoutResource()
  ///
  /// Gets the layout resource for the controllable widget portion of this Preference.
  ///@return The layout resource ID.
  int getWidgetLayoutResource() => jniAccessors.callMethodWithArgs(
      reference, _id_getWidgetLayoutResource, jni.JniType.intType, []).integer;

  static final _id_getView = jniAccessors.getMethodIDOf(_classRef, "getView",
      "(Landroid/view/View;Landroid/view/ViewGroup;)Landroid/view/View;");

  /// from: public android.view.View getView(android.view.View convertView, android.view.ViewGroup parent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the View that will be shown in the PreferenceActivity.
  ///@param convertView The old View to reuse, if possible. Note: You should
  ///            check that this View is non-null and of an appropriate type
  ///            before using. If it is not possible to convert this View to
  ///            display the correct data, this method can create a new View.
  ///@param parent The parent that this View will eventually be attached to.
  ///@return Returns the same Preference object, for chaining multiple calls
  ///         into a single statement.
  ///@see \#onCreateView(ViewGroup)
  ///@see \#onBindView(View)
  view_.View getView(view_.View convertView, viewgroup_.ViewGroup parent) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getView,
          jni.JniType.objectType,
          [convertView.reference, parent.reference]).object);

  static final _id_onCreateView = jniAccessors.getMethodIDOf(_classRef,
      "onCreateView", "(Landroid/view/ViewGroup;)Landroid/view/View;");

  /// from: protected android.view.View onCreateView(android.view.ViewGroup parent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates the View to be shown for this Preference in the
  /// PreferenceActivity. The default behavior is to inflate the main
  /// layout of this Preference (see \#setLayoutResource(int). If
  /// changing this behavior, please specify a ViewGroup with ID
  /// android.R.id\#widget_frame.
  ///
  /// Make sure to call through to the superclass's implementation.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param parent The parent that this View will eventually be attached to.
  ///@return The View that displays this Preference.
  ///@see \#onBindView(View)
  view_.View onCreateView(viewgroup_.ViewGroup parent) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onCreateView, jni.JniType.objectType, [parent.reference]).object);

  static final _id_onBindView = jniAccessors.getMethodIDOf(
      _classRef, "onBindView", "(Landroid/view/View;)V");

  /// from: protected void onBindView(android.view.View view)
  ///
  /// Binds the created View to the data for this Preference.
  ///
  /// This is a good place to grab references to custom Views in the layout and
  /// set properties on them.
  ///
  /// Make sure to call through to the superclass's implementation.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param view The View that shows this Preference.
  ///@see \#onCreateView(ViewGroup)
  void onBindView(view_.View view) => jniAccessors.callMethodWithArgs(reference,
      _id_onBindView, jni.JniType.voidType, [view.reference]).check();

  static final _id_setOrder =
      jniAccessors.getMethodIDOf(_classRef, "setOrder", "(I)V");

  /// from: public void setOrder(int order)
  ///
  /// Sets the order of this Preference with respect to other Preference objects on the same level.
  /// If this is not specified, the default behavior is to sort alphabetically. The
  /// PreferenceGroup\#setOrderingAsAdded(boolean) can be used to order Preference objects
  /// based on the order they appear in the XML.
  ///@param order the order for this Preference. A lower value will be shown first. Use
  ///              \#DEFAULT_ORDER to sort alphabetically or allow ordering from XML
  ///@see PreferenceGroup\#setOrderingAsAdded(boolean)
  ///@see \#DEFAULT_ORDER
  void setOrder(int order) => jniAccessors.callMethodWithArgs(
      reference, _id_setOrder, jni.JniType.voidType, [order]).check();

  static final _id_getOrder =
      jniAccessors.getMethodIDOf(_classRef, "getOrder", "()I");

  /// from: public int getOrder()
  ///
  /// Gets the order of this Preference with respect to other Preference objects on the same level.
  ///@return the order of this Preference
  ///@see \#setOrder(int)
  int getOrder() => jniAccessors.callMethodWithArgs(
      reference, _id_getOrder, jni.JniType.intType, []).integer;

  static final _id_setTitle = jniAccessors.getMethodIDOf(
      _classRef, "setTitle", "(Ljava/lang/CharSequence;)V");

  /// from: public void setTitle(java.lang.CharSequence title)
  ///
  /// Sets the title for this Preference with a CharSequence. This title will be placed into the ID
  /// android.R.id\#title within the View created by \#onCreateView(ViewGroup).
  ///@param title the title for this Preference
  void setTitle(jni.JniObject title) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitle, jni.JniType.voidType, [title.reference]).check();

  static final _id_setTitle1 =
      jniAccessors.getMethodIDOf(_classRef, "setTitle", "(I)V");

  /// from: public void setTitle(int titleResId)
  ///
  /// Sets the title for this Preference with a resource ID.
  ///@see \#setTitle(CharSequence)
  ///@param titleResId the title as a resource ID
  void setTitle1(int titleResId) => jniAccessors.callMethodWithArgs(
      reference, _id_setTitle1, jni.JniType.voidType, [titleResId]).check();

  static final _id_getTitleRes =
      jniAccessors.getMethodIDOf(_classRef, "getTitleRes", "()I");

  /// from: public int getTitleRes()
  ///
  /// Returns the title resource ID of this Preference. If the title did not come from a resource,
  /// {@code 0} is returned.
  ///@return the title resource
  ///@see \#setTitle(int)
  int getTitleRes() => jniAccessors.callMethodWithArgs(
      reference, _id_getTitleRes, jni.JniType.intType, []).integer;

  static final _id_getTitle = jniAccessors.getMethodIDOf(
      _classRef, "getTitle", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the title of this Preference.
  ///@return the title
  ///@see \#setTitle(CharSequence)
  jni.JniObject getTitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTitle, jni.JniType.objectType, []).object);

  static final _id_setIcon = jniAccessors.getMethodIDOf(
      _classRef, "setIcon", "(Landroid/graphics/drawable/Drawable;)V");

  /// from: public void setIcon(android.graphics.drawable.Drawable icon)
  ///
  /// Sets the icon for this Preference with a Drawable. This icon will be placed into the ID
  /// android.R.id\#icon within the View created by \#onCreateView(ViewGroup).
  ///@param icon the optional icon for this Preference
  void setIcon(drawable_.Drawable icon) => jniAccessors.callMethodWithArgs(
      reference, _id_setIcon, jni.JniType.voidType, [icon.reference]).check();

  static final _id_setIcon1 =
      jniAccessors.getMethodIDOf(_classRef, "setIcon", "(I)V");

  /// from: public void setIcon(int iconResId)
  ///
  /// Sets the icon for this Preference with a resource ID.
  ///@see \#setIcon(Drawable)
  ///@param iconResId the icon as a resource ID
  void setIcon1(int iconResId) => jniAccessors.callMethodWithArgs(
      reference, _id_setIcon1, jni.JniType.voidType, [iconResId]).check();

  static final _id_getIcon = jniAccessors.getMethodIDOf(
      _classRef, "getIcon", "()Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable getIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the icon of this Preference.
  ///@return the icon
  ///@see \#setIcon(Drawable)
  drawable_.Drawable getIcon() =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getIcon, jni.JniType.objectType, []).object);

  static final _id_getSummary = jniAccessors.getMethodIDOf(
      _classRef, "getSummary", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getSummary()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the summary of this Preference.
  ///@return the summary
  ///@see \#setSummary(CharSequence)
  jni.JniObject getSummary() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSummary, jni.JniType.objectType, []).object);

  static final _id_setSummary = jniAccessors.getMethodIDOf(
      _classRef, "setSummary", "(Ljava/lang/CharSequence;)V");

  /// from: public void setSummary(java.lang.CharSequence summary)
  ///
  /// Sets the summary for this Preference with a CharSequence.
  ///@param summary the summary for the preference
  void setSummary(jni.JniObject summary) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSummary,
      jni.JniType.voidType,
      [summary.reference]).check();

  static final _id_setSummary1 =
      jniAccessors.getMethodIDOf(_classRef, "setSummary", "(I)V");

  /// from: public void setSummary(int summaryResId)
  ///
  /// Sets the summary for this Preference with a resource ID.
  ///@see \#setSummary(CharSequence)
  ///@param summaryResId the summary as a resource
  void setSummary1(int summaryResId) => jniAccessors.callMethodWithArgs(
      reference, _id_setSummary1, jni.JniType.voidType, [summaryResId]).check();

  static final _id_setEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setEnabled", "(Z)V");

  /// from: public void setEnabled(boolean enabled)
  ///
  /// Sets whether this Preference is enabled. If disabled, it will
  /// not handle clicks.
  ///@param enabled set {@code true} to enable it
  void setEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference, _id_setEnabled, jni.JniType.voidType, [enabled]).check();

  static final _id_isEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isEnabled", "()Z");

  /// from: public boolean isEnabled()
  ///
  /// Checks whether this Preference should be enabled in the list.
  ///@return {@code true} if this Preference is enabled, false otherwise
  bool isEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setSelectable =
      jniAccessors.getMethodIDOf(_classRef, "setSelectable", "(Z)V");

  /// from: public void setSelectable(boolean selectable)
  ///
  /// Sets whether this Preference is selectable.
  ///@param selectable set {@code true} to make it selectable
  void setSelectable(bool selectable) => jniAccessors.callMethodWithArgs(
      reference, _id_setSelectable, jni.JniType.voidType, [selectable]).check();

  static final _id_isSelectable =
      jniAccessors.getMethodIDOf(_classRef, "isSelectable", "()Z");

  /// from: public boolean isSelectable()
  ///
  /// Checks whether this Preference should be selectable in the list.
  ///@return {@code true} if it is selectable, {@code false} otherwise
  bool isSelectable() => jniAccessors.callMethodWithArgs(
      reference, _id_isSelectable, jni.JniType.booleanType, []).boolean;

  static final _id_setShouldDisableView =
      jniAccessors.getMethodIDOf(_classRef, "setShouldDisableView", "(Z)V");

  /// from: public void setShouldDisableView(boolean shouldDisableView)
  ///
  /// Sets whether this Preference should disable its view when it gets disabled.
  ///
  /// For example, set this and \#setEnabled(boolean) to false for preferences that are
  /// only displaying information and 1) should not be clickable 2) should not have the view set to
  /// the disabled state.
  ///@param shouldDisableView set {@code true} if this preference should disable its view when
  ///                          the preference is disabled
  void setShouldDisableView(bool shouldDisableView) =>
      jniAccessors.callMethodWithArgs(reference, _id_setShouldDisableView,
          jni.JniType.voidType, [shouldDisableView]).check();

  static final _id_getShouldDisableView =
      jniAccessors.getMethodIDOf(_classRef, "getShouldDisableView", "()Z");

  /// from: public boolean getShouldDisableView()
  ///
  /// Checks whether this Preference should disable its view when it's action is disabled.
  ///@see \#setShouldDisableView(boolean)
  ///@return {@code true} if it should disable the view
  bool getShouldDisableView() => jniAccessors.callMethodWithArgs(
      reference, _id_getShouldDisableView, jni.JniType.booleanType, []).boolean;

  static final _id_setRecycleEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setRecycleEnabled", "(Z)V");

  /// from: public void setRecycleEnabled(boolean enabled)
  ///
  /// Sets whether this Preference has enabled to have its view recycled when used in the list
  /// view. By default the recycling is enabled.
  ///
  /// The value can be changed only before this preference is added to the preference hierarchy.
  ///
  /// If view recycling is not allowed then each time the list view populates this preference
  /// the \#getView(View, ViewGroup) method receives a {@code null} convert view and needs
  /// to recreate the view. Otherwise view gets recycled and only \#onBindView(View) gets
  /// called.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param enabled set {@code true} if this preference view should be recycled
  void setRecycleEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setRecycleEnabled,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_isRecycleEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isRecycleEnabled", "()Z");

  /// from: public boolean isRecycleEnabled()
  ///
  /// Checks whether this Preference has enabled to have its view recycled when used in the list
  /// view.
  ///@see \#setRecycleEnabled(boolean)
  ///@return {@code true} if this preference view should be recycled
  bool isRecycleEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isRecycleEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setSingleLineTitle =
      jniAccessors.getMethodIDOf(_classRef, "setSingleLineTitle", "(Z)V");

  /// from: public void setSingleLineTitle(boolean singleLineTitle)
  ///
  /// Sets whether to constrain the title of this Preference to a single line instead of
  /// letting it wrap onto multiple lines.
  ///@param singleLineTitle set {@code true} if the title should be constrained to one line
  void setSingleLineTitle(bool singleLineTitle) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSingleLineTitle,
          jni.JniType.voidType, [singleLineTitle]).check();

  static final _id_isSingleLineTitle =
      jniAccessors.getMethodIDOf(_classRef, "isSingleLineTitle", "()Z");

  /// from: public boolean isSingleLineTitle()
  ///
  /// Gets whether the title of this preference is constrained to a single line.
  ///@see \#setSingleLineTitle(boolean)
  ///@return {@code true} if the title of this preference is constrained to a single line
  bool isSingleLineTitle() => jniAccessors.callMethodWithArgs(
      reference, _id_isSingleLineTitle, jni.JniType.booleanType, []).boolean;

  static final _id_setIconSpaceReserved =
      jniAccessors.getMethodIDOf(_classRef, "setIconSpaceReserved", "(Z)V");

  /// from: public void setIconSpaceReserved(boolean iconSpaceReserved)
  ///
  /// Sets whether to reserve the space of this Preference icon view when no icon is provided.
  ///@param iconSpaceReserved set {@code true} if the space for the icon view should be reserved
  void setIconSpaceReserved(bool iconSpaceReserved) =>
      jniAccessors.callMethodWithArgs(reference, _id_setIconSpaceReserved,
          jni.JniType.voidType, [iconSpaceReserved]).check();

  static final _id_isIconSpaceReserved =
      jniAccessors.getMethodIDOf(_classRef, "isIconSpaceReserved", "()Z");

  /// from: public boolean isIconSpaceReserved()
  ///
  /// Gets whether the space this preference icon view is reserved.
  ///@see \#setIconSpaceReserved(boolean)
  ///@return {@code true} if the space of this preference icon view is reserved
  bool isIconSpaceReserved() => jniAccessors.callMethodWithArgs(
      reference, _id_isIconSpaceReserved, jni.JniType.booleanType, []).boolean;

  static final _id_onClick =
      jniAccessors.getMethodIDOf(_classRef, "onClick", "()V");

  /// from: protected void onClick()
  ///
  /// Processes a click on the preference. This includes saving the value to
  /// the SharedPreferences. However, the overridden method should
  /// call \#callChangeListener(Object) to make sure the client wants to
  /// update the preference's state with the new value.
  void onClick() => jniAccessors.callMethodWithArgs(
      reference, _id_onClick, jni.JniType.voidType, []).check();

  static final _id_setKey =
      jniAccessors.getMethodIDOf(_classRef, "setKey", "(Ljava/lang/String;)V");

  /// from: public void setKey(java.lang.String key)
  ///
  /// Sets the key for this Preference, which is used as a key to the SharedPreferences or
  /// PreferenceDataStore. This should be unique for the package.
  ///@param key The key for the preference.
  void setKey(jni.JniString key) => jniAccessors.callMethodWithArgs(
      reference, _id_setKey, jni.JniType.voidType, [key.reference]).check();

  static final _id_getKey =
      jniAccessors.getMethodIDOf(_classRef, "getKey", "()Ljava/lang/String;");

  /// from: public java.lang.String getKey()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the key for this Preference, which is also the key used for storing values into
  /// SharedPreferences or PreferenceDataStore.
  ///@return The key.
  jni.JniString getKey() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getKey, jni.JniType.objectType, []).object);

  static final _id_hasKey =
      jniAccessors.getMethodIDOf(_classRef, "hasKey", "()Z");

  /// from: public boolean hasKey()
  ///
  /// Checks whether this Preference has a valid key.
  ///@return True if the key exists and is not a blank string, false otherwise.
  bool hasKey() => jniAccessors.callMethodWithArgs(
      reference, _id_hasKey, jni.JniType.booleanType, []).boolean;

  static final _id_isPersistent =
      jniAccessors.getMethodIDOf(_classRef, "isPersistent", "()Z");

  /// from: public boolean isPersistent()
  ///
  /// Checks whether this Preference is persistent. If it is, it stores its value(s) into
  /// the persistent SharedPreferences storage by default or into
  /// PreferenceDataStore if assigned.
  ///@return True if it is persistent.
  bool isPersistent() => jniAccessors.callMethodWithArgs(
      reference, _id_isPersistent, jni.JniType.booleanType, []).boolean;

  static final _id_shouldPersist =
      jniAccessors.getMethodIDOf(_classRef, "shouldPersist", "()Z");

  /// from: protected boolean shouldPersist()
  ///
  /// Checks whether, at the given time this method is called, this Preference should store/restore
  /// its value(s) into the SharedPreferences or into PreferenceDataStore if
  /// assigned. This, at minimum, checks whether this Preference is persistent and it currently has
  /// a key. Before you save/restore from the storage, check this first.
  ///@return True if it should persist the value.
  bool shouldPersist() => jniAccessors.callMethodWithArgs(
      reference, _id_shouldPersist, jni.JniType.booleanType, []).boolean;

  static final _id_setPersistent =
      jniAccessors.getMethodIDOf(_classRef, "setPersistent", "(Z)V");

  /// from: public void setPersistent(boolean persistent)
  ///
  /// Sets whether this Preference is persistent. When persistent, it stores its value(s) into
  /// the persistent SharedPreferences storage by default or into
  /// PreferenceDataStore if assigned.
  ///@param persistent set {@code true} if it should store its value(s) into the storage.
  void setPersistent(bool persistent) => jniAccessors.callMethodWithArgs(
      reference, _id_setPersistent, jni.JniType.voidType, [persistent]).check();

  static final _id_callChangeListener = jniAccessors.getMethodIDOf(
      _classRef, "callChangeListener", "(Ljava/lang/Object;)Z");

  /// from: protected boolean callChangeListener(java.lang.Object newValue)
  ///
  /// Call this method after the user changes the preference, but before the
  /// internal state is set. This allows the client to ignore the user value.
  ///@param newValue The new value of this Preference.
  ///@return True if the user value should be set as the preference
  ///         value (and persisted).
  bool callChangeListener(jni.JniObject newValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_callChangeListener,
          jni.JniType.booleanType, [newValue.reference]).boolean;

  static final _id_setOnPreferenceChangeListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnPreferenceChangeListener",
      "(Landroid/preference/Preference\$OnPreferenceChangeListener;)V");

  /// from: public void setOnPreferenceChangeListener(android.preference.Preference.OnPreferenceChangeListener onPreferenceChangeListener)
  ///
  /// Sets the callback to be invoked when this Preference is changed by the
  /// user (but before the internal state has been updated).
  ///@param onPreferenceChangeListener The callback to be invoked.
  void setOnPreferenceChangeListener(
          Preference_OnPreferenceChangeListener onPreferenceChangeListener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnPreferenceChangeListener,
          jni.JniType.voidType,
          [onPreferenceChangeListener.reference]).check();

  static final _id_getOnPreferenceChangeListener = jniAccessors.getMethodIDOf(
      _classRef,
      "getOnPreferenceChangeListener",
      "()Landroid/preference/Preference\$OnPreferenceChangeListener;");

  /// from: public android.preference.Preference.OnPreferenceChangeListener getOnPreferenceChangeListener()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the callback to be invoked when this Preference is changed by the
  /// user (but before the internal state has been updated).
  ///@return The callback to be invoked.
  Preference_OnPreferenceChangeListener getOnPreferenceChangeListener() =>
      Preference_OnPreferenceChangeListener.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getOnPreferenceChangeListener,
              jni.JniType.objectType, []).object);

  static final _id_setOnPreferenceClickListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setOnPreferenceClickListener",
      "(Landroid/preference/Preference\$OnPreferenceClickListener;)V");

  /// from: public void setOnPreferenceClickListener(android.preference.Preference.OnPreferenceClickListener onPreferenceClickListener)
  ///
  /// Sets the callback to be invoked when this Preference is clicked.
  ///@param onPreferenceClickListener The callback to be invoked.
  void setOnPreferenceClickListener(
          Preference_OnPreferenceClickListener onPreferenceClickListener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOnPreferenceClickListener,
          jni.JniType.voidType,
          [onPreferenceClickListener.reference]).check();

  static final _id_getOnPreferenceClickListener = jniAccessors.getMethodIDOf(
      _classRef,
      "getOnPreferenceClickListener",
      "()Landroid/preference/Preference\$OnPreferenceClickListener;");

  /// from: public android.preference.Preference.OnPreferenceClickListener getOnPreferenceClickListener()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the callback to be invoked when this Preference is clicked.
  ///@return The callback to be invoked.
  Preference_OnPreferenceClickListener getOnPreferenceClickListener() =>
      Preference_OnPreferenceClickListener.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getOnPreferenceClickListener,
              jni.JniType.objectType, []).object);

  static final _id_getContext = jniAccessors.getMethodIDOf(
      _classRef, "getContext", "()Landroid/content/Context;");

  /// from: public android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the android.content.Context of this Preference.
  /// Each Preference in a Preference hierarchy can be
  /// from different Context (for example, if multiple activities provide preferences into a single
  /// PreferenceActivity). This Context will be used to save the Preference values.
  ///@return The Context of this Preference.
  context_.Context getContext() =>
      context_.Context.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getContext, jni.JniType.objectType, []).object);

  static final _id_getSharedPreferences = jniAccessors.getMethodIDOf(_classRef,
      "getSharedPreferences", "()Landroid/content/SharedPreferences;");

  /// from: public android.content.SharedPreferences getSharedPreferences()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the SharedPreferences where this Preference can read its
  /// value(s). Usually, it's easier to use one of the helper read methods:
  /// \#getPersistedBoolean(boolean), \#getPersistedFloat(float),
  /// \#getPersistedInt(int), \#getPersistedLong(long),
  /// \#getPersistedString(String). To save values, see
  /// \#getEditor().
  ///
  /// In some cases, writes to the \#getEditor() will not be committed
  /// right away and hence not show up in the returned
  /// SharedPreferences, this is intended behavior to improve
  /// performance.
  ///@return the SharedPreferences where this Preference reads its value(s). If
  ///         this preference isn't attached to a Preference hierarchy or if
  ///         a PreferenceDataStore has been set, this method returns {@code null}.
  ///@see \#getEditor()
  ///@see \#setPreferenceDataStore(PreferenceDataStore)
  sharedpreferences_.SharedPreferences getSharedPreferences() =>
      sharedpreferences_.SharedPreferences.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getSharedPreferences,
              jni.JniType.objectType, []).object);

  static final _id_getEditor = jniAccessors.getMethodIDOf(
      _classRef, "getEditor", "()Landroid/content/SharedPreferences\$Editor;");

  /// from: public android.content.SharedPreferences.Editor getEditor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an SharedPreferences.Editor where this Preference can
  /// save its value(s). Usually it's easier to use one of the helper save
  /// methods: \#persistBoolean(boolean), \#persistFloat(float),
  /// \#persistInt(int), \#persistLong(long),
  /// \#persistString(String). To read values, see
  /// \#getSharedPreferences(). If \#shouldCommit() returns
  /// true, it is this Preference's responsibility to commit.
  ///
  /// In some cases, writes to this will not be committed right away and hence
  /// not show up in the SharedPreferences, this is intended behavior to
  /// improve performance.
  ///@return a SharedPreferences.Editor where this preference saves its value(s). If
  ///         this preference isn't attached to a Preference hierarchy or if
  ///         a PreferenceDataStore has been set, this method returns {@code null}.
  ///@see \#shouldCommit()
  ///@see \#getSharedPreferences()
  ///@see \#setPreferenceDataStore(PreferenceDataStore)
  sharedpreferences_.SharedPreferences_Editor getEditor() =>
      sharedpreferences_.SharedPreferences_Editor.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getEditor, jni.JniType.objectType, []).object);

  static final _id_shouldCommit =
      jniAccessors.getMethodIDOf(_classRef, "shouldCommit", "()Z");

  /// from: public boolean shouldCommit()
  ///
  /// Returns whether the Preference should commit its saved value(s) in
  /// \#getEditor(). This may return false in situations where batch
  /// committing is being done (by the manager) to improve performance.
  ///
  /// If this preference is using PreferenceDataStore this value is irrelevant.
  ///@return Whether the Preference should commit its saved value(s).
  ///@see \#getEditor()
  bool shouldCommit() => jniAccessors.callMethodWithArgs(
      reference, _id_shouldCommit, jni.JniType.booleanType, []).boolean;

  static final _id_compareTo = jniAccessors.getMethodIDOf(
      _classRef, "compareTo", "(Landroid/preference/Preference;)I");

  /// from: public int compareTo(android.preference.Preference another)
  ///
  /// Compares Preference objects based on order (if set), otherwise alphabetically on the titles.
  ///@param another The Preference to compare to this one.
  ///@return 0 if the same; less than 0 if this Preference sorts ahead of <var>another</var>;
  ///          greater than 0 if this Preference sorts after <var>another</var>.
  int compareTo(Preference another) => jniAccessors.callMethodWithArgs(
      reference,
      _id_compareTo,
      jni.JniType.intType,
      [another.reference]).integer;

  static final _id_notifyChanged =
      jniAccessors.getMethodIDOf(_classRef, "notifyChanged", "()V");

  /// from: protected void notifyChanged()
  ///
  /// Should be called when the data of this Preference has changed.
  void notifyChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_notifyChanged, jni.JniType.voidType, []).check();

  static final _id_notifyHierarchyChanged =
      jniAccessors.getMethodIDOf(_classRef, "notifyHierarchyChanged", "()V");

  /// from: protected void notifyHierarchyChanged()
  ///
  /// Should be called when a Preference has been
  /// added/removed from this group, or the ordering should be
  /// re-evaluated.
  void notifyHierarchyChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_notifyHierarchyChanged, jni.JniType.voidType, []).check();

  static final _id_getPreferenceManager = jniAccessors.getMethodIDOf(_classRef,
      "getPreferenceManager", "()Landroid/preference/PreferenceManager;");

  /// from: public android.preference.PreferenceManager getPreferenceManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the PreferenceManager that manages this Preference object's tree.
  ///@return The PreferenceManager.
  preferencemanager_.PreferenceManager getPreferenceManager() =>
      preferencemanager_.PreferenceManager.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getPreferenceManager,
              jni.JniType.objectType, []).object);

  static final _id_onAttachedToHierarchy = jniAccessors.getMethodIDOf(_classRef,
      "onAttachedToHierarchy", "(Landroid/preference/PreferenceManager;)V");

  /// from: protected void onAttachedToHierarchy(android.preference.PreferenceManager preferenceManager)
  ///
  /// Called when this Preference has been attached to a Preference hierarchy.
  /// Make sure to call the super implementation.
  ///@param preferenceManager The PreferenceManager of the hierarchy.
  void onAttachedToHierarchy(
          preferencemanager_.PreferenceManager preferenceManager) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAttachedToHierarchy,
          jni.JniType.voidType, [preferenceManager.reference]).check();

  static final _id_onAttachedToActivity =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToActivity", "()V");

  /// from: protected void onAttachedToActivity()
  ///
  /// Called when the Preference hierarchy has been attached to the
  /// PreferenceActivity. This can also be called when this
  /// Preference has been attached to a group that was already attached
  /// to the PreferenceActivity.
  void onAttachedToActivity() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToActivity, jni.JniType.voidType, []).check();

  static final _id_findPreferenceInHierarchy = jniAccessors.getMethodIDOf(
      _classRef,
      "findPreferenceInHierarchy",
      "(Ljava/lang/String;)Landroid/preference/Preference;");

  /// from: protected android.preference.Preference findPreferenceInHierarchy(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Finds a Preference in this hierarchy (the whole thing,
  /// even above/below your PreferenceScreen screen break) with the given
  /// key.
  ///
  /// This only functions after we have been attached to a hierarchy.
  ///@param key The key of the Preference to find.
  ///@return The Preference that uses the given key.
  Preference findPreferenceInHierarchy(jni.JniString key) =>
      Preference.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_findPreferenceInHierarchy,
          jni.JniType.objectType,
          [key.reference]).object);

  static final _id_notifyDependencyChange =
      jniAccessors.getMethodIDOf(_classRef, "notifyDependencyChange", "(Z)V");

  /// from: public void notifyDependencyChange(boolean disableDependents)
  ///
  /// Notifies any listening dependents of a change that affects the
  /// dependency.
  ///@param disableDependents Whether this Preference should disable
  ///            its dependents.
  void notifyDependencyChange(bool disableDependents) =>
      jniAccessors.callMethodWithArgs(reference, _id_notifyDependencyChange,
          jni.JniType.voidType, [disableDependents]).check();

  static final _id_onDependencyChanged = jniAccessors.getMethodIDOf(
      _classRef, "onDependencyChanged", "(Landroid/preference/Preference;Z)V");

  /// from: public void onDependencyChanged(android.preference.Preference dependency, boolean disableDependent)
  ///
  /// Called when the dependency changes.
  ///@param dependency The Preference that this Preference depends on.
  ///@param disableDependent Set true to disable this Preference.
  void onDependencyChanged(Preference dependency, bool disableDependent) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onDependencyChanged,
          jni.JniType.voidType,
          [dependency.reference, disableDependent]).check();

  static final _id_onParentChanged = jniAccessors.getMethodIDOf(
      _classRef, "onParentChanged", "(Landroid/preference/Preference;Z)V");

  /// from: public void onParentChanged(android.preference.Preference parent, boolean disableChild)
  ///
  /// Called when the implicit parent dependency changes.
  ///@param parent The Preference that this Preference depends on.
  ///@param disableChild Set true to disable this Preference.
  void onParentChanged(Preference parent, bool disableChild) =>
      jniAccessors.callMethodWithArgs(reference, _id_onParentChanged,
          jni.JniType.voidType, [parent.reference, disableChild]).check();

  static final _id_shouldDisableDependents =
      jniAccessors.getMethodIDOf(_classRef, "shouldDisableDependents", "()Z");

  /// from: public boolean shouldDisableDependents()
  ///
  /// Checks whether this preference's dependents should currently be
  /// disabled.
  ///@return True if the dependents should be disabled, otherwise false.
  bool shouldDisableDependents() => jniAccessors.callMethodWithArgs(reference,
      _id_shouldDisableDependents, jni.JniType.booleanType, []).boolean;

  static final _id_setDependency = jniAccessors.getMethodIDOf(
      _classRef, "setDependency", "(Ljava/lang/String;)V");

  /// from: public void setDependency(java.lang.String dependencyKey)
  ///
  /// Sets the key of a Preference that this Preference will depend on. If that
  /// Preference is not set or is off, this Preference will be disabled.
  ///@param dependencyKey The key of the Preference that this depends on.
  void setDependency(jni.JniString dependencyKey) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDependency,
          jni.JniType.voidType, [dependencyKey.reference]).check();

  static final _id_getDependency = jniAccessors.getMethodIDOf(
      _classRef, "getDependency", "()Ljava/lang/String;");

  /// from: public java.lang.String getDependency()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the key of the dependency on this Preference.
  ///@return The key of the dependency.
  ///@see \#setDependency(String)
  jni.JniString getDependency() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDependency, jni.JniType.objectType, []).object);

  static final _id_getParent = jniAccessors.getMethodIDOf(
      _classRef, "getParent", "()Landroid/preference/PreferenceGroup;");

  /// from: public android.preference.PreferenceGroup getParent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the PreferenceGroup which is this Preference assigned to or {@code null} if
  /// this preference is not assigned to any group or is a root Preference.
  ///@return the parent PreferenceGroup or {@code null} if not attached to any
  preferencegroup_.PreferenceGroup getParent() =>
      preferencegroup_.PreferenceGroup.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getParent, jni.JniType.objectType, []).object);

  static final _id_onPrepareForRemoval =
      jniAccessors.getMethodIDOf(_classRef, "onPrepareForRemoval", "()V");

  /// from: protected void onPrepareForRemoval()
  ///
  /// Called when this Preference is being removed from the hierarchy. You
  /// should remove any references to this Preference that you know about. Make
  /// sure to call through to the superclass implementation.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onPrepareForRemoval() => jniAccessors.callMethodWithArgs(
      reference, _id_onPrepareForRemoval, jni.JniType.voidType, []).check();

  static final _id_setDefaultValue = jniAccessors.getMethodIDOf(
      _classRef, "setDefaultValue", "(Ljava/lang/Object;)V");

  /// from: public void setDefaultValue(java.lang.Object defaultValue)
  ///
  /// Sets the default value for this Preference, which will be set either if
  /// persistence is off or persistence is on and the preference is not found
  /// in the persistent storage.
  ///@param defaultValue The default value.
  void setDefaultValue(jni.JniObject defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDefaultValue,
          jni.JniType.voidType, [defaultValue.reference]).check();

  static final _id_onSetInitialValue = jniAccessors.getMethodIDOf(
      _classRef, "onSetInitialValue", "(ZLjava/lang/Object;)V");

  /// from: protected void onSetInitialValue(boolean restorePersistedValue, java.lang.Object defaultValue)
  ///
  /// Implement this to set the initial value of the Preference.
  ///
  /// If <var>restorePersistedValue</var> is true, you should restore the
  /// Preference value from the android.content.SharedPreferences. If
  /// <var>restorePersistedValue</var> is false, you should set the Preference
  /// value to defaultValue that is given (and possibly store to SharedPreferences
  /// if \#shouldPersist() is true).
  ///
  /// In case of using PreferenceDataStore, the <var>restorePersistedValue</var> is
  /// always {@code true}. But the default value (if provided) is set.
  ///
  /// This may not always be called. One example is if it should not persist
  /// but there is no default value given.
  ///@param restorePersistedValue True to restore the persisted value;
  ///            false to use the given <var>defaultValue</var>.
  ///@param defaultValue The default value for this Preference. Only use this
  ///            if <var>restorePersistedValue</var> is false.
  void onSetInitialValue(
          bool restorePersistedValue, jni.JniObject defaultValue) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onSetInitialValue,
          jni.JniType.voidType,
          [restorePersistedValue, defaultValue.reference]).check();

  static final _id_persistString = jniAccessors.getMethodIDOf(
      _classRef, "persistString", "(Ljava/lang/String;)Z");

  /// from: protected boolean persistString(java.lang.String value)
  ///
  /// Attempts to persist a String if this Preference is persistent.
  ///@param value The value to persist.
  ///@return True if this Preference is persistent. (This is not whether the
  ///         value was persisted, since we may not necessarily commit if there
  ///         will be a batch commit later.)
  ///@see \#getPersistedString(String)
  bool persistString(jni.JniString value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_persistString,
      jni.JniType.booleanType,
      [value.reference]).boolean;

  static final _id_getPersistedString = jniAccessors.getMethodIDOf(_classRef,
      "getPersistedString", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: protected java.lang.String getPersistedString(java.lang.String defaultReturnValue)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Attempts to get a persisted String if this Preference is persistent.
  ///@param defaultReturnValue The default value to return if either this
  ///            Preference is not persistent or this Preference is not present.
  ///@return The value from the data store or the default return
  ///         value.
  ///@see \#persistString(String)
  jni.JniString getPersistedString(jni.JniString defaultReturnValue) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPersistedString,
          jni.JniType.objectType,
          [defaultReturnValue.reference]).object);

  static final _id_persistStringSet = jniAccessors.getMethodIDOf(
      _classRef, "persistStringSet", "(Ljava/util/Set;)Z");

  /// from: public boolean persistStringSet(java.util.Set<java.lang.String> values)
  ///
  /// Attempts to persist a set of Strings if this Preference is persistent.
  ///@param values The values to persist.
  ///@return True if this Preference is persistent. (This is not whether the
  ///         value was persisted, since we may not necessarily commit if there
  ///         will be a batch commit later.)
  ///@see \#getPersistedStringSet(Set)
  bool persistStringSet(jni.JniObject values) =>
      jniAccessors.callMethodWithArgs(reference, _id_persistStringSet,
          jni.JniType.booleanType, [values.reference]).boolean;

  static final _id_getPersistedStringSet = jniAccessors.getMethodIDOf(
      _classRef, "getPersistedStringSet", "(Ljava/util/Set;)Ljava/util/Set;");

  /// from: public java.util.Set<java.lang.String> getPersistedStringSet(java.util.Set<java.lang.String> defaultReturnValue)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Attempts to get a persisted set of Strings if this Preference is persistent.
  ///@param defaultReturnValue The default value to return if either this
  ///            Preference is not persistent or this Preference is not present.
  ///@return The value from the data store or the default return
  ///         value.
  ///@see \#persistStringSet(Set)
  jni.JniObject getPersistedStringSet(jni.JniObject defaultReturnValue) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPersistedStringSet,
          jni.JniType.objectType,
          [defaultReturnValue.reference]).object);

  static final _id_persistInt =
      jniAccessors.getMethodIDOf(_classRef, "persistInt", "(I)Z");

  /// from: protected boolean persistInt(int value)
  ///
  /// Attempts to persist an int if this Preference is persistent.
  ///@param value The value to persist.
  ///@return True if this Preference is persistent. (This is not whether the
  ///         value was persisted, since we may not necessarily commit if there
  ///         will be a batch commit later.)
  ///@see \#persistString(String)
  ///@see \#getPersistedInt(int)
  bool persistInt(int value) => jniAccessors.callMethodWithArgs(
      reference, _id_persistInt, jni.JniType.booleanType, [value]).boolean;

  static final _id_getPersistedInt =
      jniAccessors.getMethodIDOf(_classRef, "getPersistedInt", "(I)I");

  /// from: protected int getPersistedInt(int defaultReturnValue)
  ///
  /// Attempts to get a persisted int if this Preference is persistent.
  ///@param defaultReturnValue The default value to return if either this
  ///            Preference is not persistent or this Preference is not present.
  ///@return The value from the data store or the default return
  ///         value.
  ///@see \#getPersistedString(String)
  ///@see \#persistInt(int)
  int getPersistedInt(int defaultReturnValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getPersistedInt,
          jni.JniType.intType, [defaultReturnValue]).integer;

  static final _id_persistFloat =
      jniAccessors.getMethodIDOf(_classRef, "persistFloat", "(F)Z");

  /// from: protected boolean persistFloat(float value)
  ///
  /// Attempts to persist a long if this Preference is persistent.
  ///@param value The value to persist.
  ///@return True if this Preference is persistent. (This is not whether the
  ///         value was persisted, since we may not necessarily commit if there
  ///         will be a batch commit later.)
  ///@see \#persistString(String)
  ///@see \#getPersistedFloat(float)
  bool persistFloat(double value) => jniAccessors.callMethodWithArgs(
      reference, _id_persistFloat, jni.JniType.booleanType, [value]).boolean;

  static final _id_getPersistedFloat =
      jniAccessors.getMethodIDOf(_classRef, "getPersistedFloat", "(F)F");

  /// from: protected float getPersistedFloat(float defaultReturnValue)
  ///
  /// Attempts to get a persisted float if this Preference is persistent.
  ///@param defaultReturnValue The default value to return if either this
  ///            Preference is not persistent or this Preference is not present.
  ///@return The value from the data store or the default return
  ///         value.
  ///@see \#getPersistedString(String)
  ///@see \#persistFloat(float)
  double getPersistedFloat(double defaultReturnValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getPersistedFloat,
          jni.JniType.floatType, [defaultReturnValue]).float;

  static final _id_persistLong =
      jniAccessors.getMethodIDOf(_classRef, "persistLong", "(J)Z");

  /// from: protected boolean persistLong(long value)
  ///
  /// Attempts to persist a long if this Preference is persistent.
  ///@param value The value to persist.
  ///@return True if this Preference is persistent. (This is not whether the
  ///         value was persisted, since we may not necessarily commit if there
  ///         will be a batch commit later.)
  ///@see \#persistString(String)
  ///@see \#getPersistedLong(long)
  bool persistLong(int value) => jniAccessors.callMethodWithArgs(
      reference, _id_persistLong, jni.JniType.booleanType, [value]).boolean;

  static final _id_getPersistedLong =
      jniAccessors.getMethodIDOf(_classRef, "getPersistedLong", "(J)J");

  /// from: protected long getPersistedLong(long defaultReturnValue)
  ///
  /// Attempts to get a persisted long if this Preference is persistent.
  ///@param defaultReturnValue The default value to return if either this
  ///            Preference is not persistent or this Preference is not present.
  ///@return The value from the data store or the default return
  ///         value.
  ///@see \#getPersistedString(String)
  ///@see \#persistLong(long)
  int getPersistedLong(int defaultReturnValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getPersistedLong,
          jni.JniType.longType, [defaultReturnValue]).long;

  static final _id_persistBoolean =
      jniAccessors.getMethodIDOf(_classRef, "persistBoolean", "(Z)Z");

  /// from: protected boolean persistBoolean(boolean value)
  ///
  /// Attempts to persist a boolean if this Preference is persistent.
  ///@param value The value to persist.
  ///@return True if this Preference is persistent. (This is not whether the
  ///         value was persisted, since we may not necessarily commit if there
  ///         will be a batch commit later.)
  ///@see \#persistString(String)
  ///@see \#getPersistedBoolean(boolean)
  bool persistBoolean(bool value) => jniAccessors.callMethodWithArgs(
      reference, _id_persistBoolean, jni.JniType.booleanType, [value]).boolean;

  static final _id_getPersistedBoolean =
      jniAccessors.getMethodIDOf(_classRef, "getPersistedBoolean", "(Z)Z");

  /// from: protected boolean getPersistedBoolean(boolean defaultReturnValue)
  ///
  /// Attempts to get a persisted boolean if this Preference is persistent.
  ///@param defaultReturnValue The default value to return if either this
  ///            Preference is not persistent or this Preference is not present.
  ///@return The value from the data store or the default return
  ///         value.
  ///@see \#getPersistedString(String)
  ///@see \#persistBoolean(boolean)
  bool getPersistedBoolean(bool defaultReturnValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getPersistedBoolean,
          jni.JniType.booleanType, [defaultReturnValue]).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_saveHierarchyState = jniAccessors.getMethodIDOf(
      _classRef, "saveHierarchyState", "(Landroid/os/Bundle;)V");

  /// from: public void saveHierarchyState(android.os.Bundle container)
  ///
  /// Store this Preference hierarchy's frozen state into the given container.
  ///@param container The Bundle in which to save the instance of this Preference.
  ///@see \#restoreHierarchyState
  ///@see \#onSaveInstanceState
  void saveHierarchyState(bundle_.Bundle container) =>
      jniAccessors.callMethodWithArgs(reference, _id_saveHierarchyState,
          jni.JniType.voidType, [container.reference]).check();

  static final _id_onSaveInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "onSaveInstanceState", "()Landroid/os/Parcelable;");

  /// from: protected android.os.Parcelable onSaveInstanceState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Hook allowing a Preference to generate a representation of its internal
  /// state that can later be used to create a new instance with that same
  /// state. This state should only contain information that is not persistent
  /// or can be reconstructed later.
  ///@return A Parcelable object containing the current dynamic state of this Preference, or
  ///         {@code null} if there is nothing interesting to save. The default implementation
  ///         returns {@code null}.
  ///@see \#onRestoreInstanceState
  ///@see \#saveHierarchyState
  parcelable_.Parcelable onSaveInstanceState() =>
      parcelable_.Parcelable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onSaveInstanceState, jni.JniType.objectType, []).object);

  static final _id_restoreHierarchyState = jniAccessors.getMethodIDOf(
      _classRef, "restoreHierarchyState", "(Landroid/os/Bundle;)V");

  /// from: public void restoreHierarchyState(android.os.Bundle container)
  ///
  /// Restore this Preference hierarchy's previously saved state from the given container.
  ///@param container The Bundle that holds the previously saved state.
  ///@see \#saveHierarchyState
  ///@see \#onRestoreInstanceState
  void restoreHierarchyState(bundle_.Bundle container) =>
      jniAccessors.callMethodWithArgs(reference, _id_restoreHierarchyState,
          jni.JniType.voidType, [container.reference]).check();

  static final _id_onRestoreInstanceState = jniAccessors.getMethodIDOf(
      _classRef, "onRestoreInstanceState", "(Landroid/os/Parcelable;)V");

  /// from: protected void onRestoreInstanceState(android.os.Parcelable state)
  ///
  /// Hook allowing a Preference to re-apply a representation of its internal state that had
  /// previously been generated by \#onSaveInstanceState. This function will never be called
  /// with a {@code null} state.
  ///@param state The saved state that had previously been returned by
  ///            \#onSaveInstanceState.
  ///@see \#onSaveInstanceState
  ///@see \#restoreHierarchyState
  void onRestoreInstanceState(parcelable_.Parcelable state) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRestoreInstanceState,
          jni.JniType.voidType, [state.reference]).check();
}

/// from: android.preference.Preference$OnPreferenceClickListener
///
/// Interface definition for a callback to be invoked when a Preference is
/// clicked.
class Preference_OnPreferenceClickListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/preference/Preference\$OnPreferenceClickListener");
  Preference_OnPreferenceClickListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onPreferenceClick = jniAccessors.getMethodIDOf(
      _classRef, "onPreferenceClick", "(Landroid/preference/Preference;)Z");

  /// from: public abstract boolean onPreferenceClick(android.preference.Preference preference)
  ///
  /// Called when a Preference has been clicked.
  ///@param preference The Preference that was clicked.
  ///@return True if the click was handled.
  bool onPreferenceClick(Preference preference) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPreferenceClick,
          jni.JniType.booleanType, [preference.reference]).boolean;
}

/// from: android.preference.Preference$OnPreferenceChangeListener
///
/// Interface definition for a callback to be invoked when the value of this
/// Preference has been changed by the user and is
/// about to be set and/or persisted.  This gives the client a chance
/// to prevent setting and/or persisting the value.
class Preference_OnPreferenceChangeListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/preference/Preference\$OnPreferenceChangeListener");
  Preference_OnPreferenceChangeListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onPreferenceChange = jniAccessors.getMethodIDOf(
      _classRef,
      "onPreferenceChange",
      "(Landroid/preference/Preference;Ljava/lang/Object;)Z");

  /// from: public abstract boolean onPreferenceChange(android.preference.Preference preference, java.lang.Object newValue)
  ///
  /// Called when a Preference has been changed by the user. This is
  /// called before the state of the Preference is about to be updated and
  /// before the state is persisted.
  ///@param preference The changed Preference.
  ///@param newValue The new value of the Preference.
  ///@return True to update the state of the Preference with the new value.
  bool onPreferenceChange(Preference preference, jni.JniObject newValue) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPreferenceChange,
          jni.JniType.booleanType,
          [preference.reference, newValue.reference]).boolean;
}

/// from: android.preference.Preference$BaseSavedState
///
/// A base class for managing the instance state of a Preference.
class Preference_BaseSavedState extends abssavedstate_.AbsSavedState {
  static final _classRef =
      jniAccessors.getClassOf("android/preference/Preference\$BaseSavedState");
  Preference_BaseSavedState.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR1 = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.preference.Preference.BaseSavedState> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR1 =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR1, jni.JniType.objectType)
          .object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Parcel;)V");

  /// from: public void <init>(android.os.Parcel source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Preference_BaseSavedState.ctor1(parcel_.Parcel source)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [source.reference]).object);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/os/Parcelable;)V");

  /// from: public void <init>(android.os.Parcelable superState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Preference_BaseSavedState(parcelable_.Parcelable superState)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [superState.reference]).object);
}
