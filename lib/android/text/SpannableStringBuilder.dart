// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../graphics/Paint.dart" as paint_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.text.SpannableStringBuilder
///
/// This is the class for text whose content and markup can both be changed.
class SpannableStringBuilder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/SpannableStringBuilder");
  SpannableStringBuilder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new SpannableStringBuilder with empty contents
  SpannableStringBuilder()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/CharSequence;)V");

  /// from: public void <init>(java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new SpannableStringBuilder containing a copy of the
  /// specified text, including its spans if any.
  SpannableStringBuilder.ctor1(jni.JniObject text)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [text.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/CharSequence;II)V");

  /// from: public void <init>(java.lang.CharSequence text, int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new SpannableStringBuilder containing a copy of the
  /// specified slice of the specified text, including its spans if any.
  SpannableStringBuilder.ctor2(jni.JniObject text, int start, int end)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [text.reference, start, end]).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/CharSequence;)Landroid/text/SpannableStringBuilder;");

  /// from: static public android.text.SpannableStringBuilder valueOf(java.lang.CharSequence source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static SpannableStringBuilder valueOf(jni.JniObject source) =>
      SpannableStringBuilder.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [source.reference]).object);

  static final _id_charAt =
      jniAccessors.getMethodIDOf(_classRef, "charAt", "(I)C");

  /// from: public char charAt(int where)
  ///
  /// Return the char at the specified offset within the buffer.
  int charAt(int where) => jniAccessors.callMethodWithArgs(
      reference, _id_charAt, jni.JniType.charType, [where]).char;

  static final _id_length =
      jniAccessors.getMethodIDOf(_classRef, "length", "()I");

  /// from: public int length()
  ///
  /// Return the number of chars in the buffer.
  int length() => jniAccessors.callMethodWithArgs(
      reference, _id_length, jni.JniType.intType, []).integer;

  static final _id_insert = jniAccessors.getMethodIDOf(_classRef, "insert",
      "(ILjava/lang/CharSequence;II)Landroid/text/SpannableStringBuilder;");

  /// from: public android.text.SpannableStringBuilder insert(int where, java.lang.CharSequence tb, int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SpannableStringBuilder insert(
          int where, jni.JniObject tb, int start, int end) =>
      SpannableStringBuilder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_insert,
          jni.JniType.objectType,
          [where, tb.reference, start, end]).object);

  static final _id_insert1 = jniAccessors.getMethodIDOf(_classRef, "insert",
      "(ILjava/lang/CharSequence;)Landroid/text/SpannableStringBuilder;");

  /// from: public android.text.SpannableStringBuilder insert(int where, java.lang.CharSequence tb)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SpannableStringBuilder insert1(int where, jni.JniObject tb) =>
      SpannableStringBuilder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_insert1, jni.JniType.objectType, [where, tb.reference]).object);

  static final _id_delete1 = jniAccessors.getMethodIDOf(
      _classRef, "delete", "(II)Landroid/text/SpannableStringBuilder;");

  /// from: public android.text.SpannableStringBuilder delete(int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SpannableStringBuilder delete1(int start, int end) =>
      SpannableStringBuilder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_delete1, jni.JniType.objectType, [start, end]).object);

  static final _id_clear =
      jniAccessors.getMethodIDOf(_classRef, "clear", "()V");

  /// from: public void clear()
  void clear() => jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniType.voidType, []).check();

  static final _id_clearSpans =
      jniAccessors.getMethodIDOf(_classRef, "clearSpans", "()V");

  /// from: public void clearSpans()
  void clearSpans() => jniAccessors.callMethodWithArgs(
      reference, _id_clearSpans, jni.JniType.voidType, []).check();

  static final _id_append = jniAccessors.getMethodIDOf(_classRef, "append",
      "(Ljava/lang/CharSequence;)Landroid/text/SpannableStringBuilder;");

  /// from: public android.text.SpannableStringBuilder append(java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SpannableStringBuilder append(jni.JniObject text) =>
      SpannableStringBuilder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_append, jni.JniType.objectType, [text.reference]).object);

  static final _id_append1 = jniAccessors.getMethodIDOf(_classRef, "append",
      "(Ljava/lang/CharSequence;Ljava/lang/Object;I)Landroid/text/SpannableStringBuilder;");

  /// from: public android.text.SpannableStringBuilder append(java.lang.CharSequence text, java.lang.Object what, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Appends the character sequence {@code text} and spans {@code what} over the appended part.
  /// See Spanned for an explanation of what the flags mean.
  ///@param text the character sequence to append.
  ///@param what the object to be spanned over the appended text.
  ///@param flags see Spanned.
  ///@return this {@code SpannableStringBuilder}.
  SpannableStringBuilder append1(
          jni.JniObject text, jni.JniObject what, int flags) =>
      SpannableStringBuilder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_append1,
          jni.JniType.objectType,
          [text.reference, what.reference, flags]).object);

  static final _id_append2 = jniAccessors.getMethodIDOf(_classRef, "append",
      "(Ljava/lang/CharSequence;II)Landroid/text/SpannableStringBuilder;");

  /// from: public android.text.SpannableStringBuilder append(java.lang.CharSequence text, int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SpannableStringBuilder append2(jni.JniObject text, int start, int end) =>
      SpannableStringBuilder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_append2,
          jni.JniType.objectType,
          [text.reference, start, end]).object);

  static final _id_append3 = jniAccessors.getMethodIDOf(
      _classRef, "append", "(C)Landroid/text/SpannableStringBuilder;");

  /// from: public android.text.SpannableStringBuilder append(char text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SpannableStringBuilder append3(int text) =>
      SpannableStringBuilder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_append3, jni.JniType.objectType, [text]).object);

  static final _id_replace = jniAccessors.getMethodIDOf(_classRef, "replace",
      "(IILjava/lang/CharSequence;)Landroid/text/SpannableStringBuilder;");

  /// from: public android.text.SpannableStringBuilder replace(int start, int end, java.lang.CharSequence tb)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SpannableStringBuilder replace(int start, int end, jni.JniObject tb) =>
      SpannableStringBuilder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_replace,
          jni.JniType.objectType,
          [start, end, tb.reference]).object);

  static final _id_replace1 = jniAccessors.getMethodIDOf(_classRef, "replace",
      "(IILjava/lang/CharSequence;II)Landroid/text/SpannableStringBuilder;");

  /// from: public android.text.SpannableStringBuilder replace(int start, int end, java.lang.CharSequence tb, int tbstart, int tbend)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SpannableStringBuilder replace1(
          int start, int end, jni.JniObject tb, int tbstart, int tbend) =>
      SpannableStringBuilder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_replace1,
          jni.JniType.objectType,
          [start, end, tb.reference, tbstart, tbend]).object);

  static final _id_setSpan = jniAccessors.getMethodIDOf(
      _classRef, "setSpan", "(Ljava/lang/Object;III)V");

  /// from: public void setSpan(java.lang.Object what, int start, int end, int flags)
  ///
  /// Mark the specified range of text with the specified object.
  /// The flags determine how the span will behave when text is
  /// inserted at the start or end of the span's range.
  void setSpan(jni.JniObject what, int start, int end, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSpan,
          jni.JniType.voidType, [what.reference, start, end, flags]).check();

  static final _id_removeSpan = jniAccessors.getMethodIDOf(
      _classRef, "removeSpan", "(Ljava/lang/Object;)V");

  /// from: public void removeSpan(java.lang.Object what)
  ///
  /// Remove the specified markup object from the buffer.
  void removeSpan(jni.JniObject what) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeSpan,
      jni.JniType.voidType,
      [what.reference]).check();

  static final _id_getSpanStart = jniAccessors.getMethodIDOf(
      _classRef, "getSpanStart", "(Ljava/lang/Object;)I");

  /// from: public int getSpanStart(java.lang.Object what)
  ///
  /// Return the buffer offset of the beginning of the specified
  /// markup object, or -1 if it is not attached to this buffer.
  int getSpanStart(jni.JniObject what) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getSpanStart,
      jni.JniType.intType,
      [what.reference]).integer;

  static final _id_getSpanEnd = jniAccessors.getMethodIDOf(
      _classRef, "getSpanEnd", "(Ljava/lang/Object;)I");

  /// from: public int getSpanEnd(java.lang.Object what)
  ///
  /// Return the buffer offset of the end of the specified
  /// markup object, or -1 if it is not attached to this buffer.
  int getSpanEnd(jni.JniObject what) => jniAccessors.callMethodWithArgs(
      reference, _id_getSpanEnd, jni.JniType.intType, [what.reference]).integer;

  static final _id_getSpanFlags = jniAccessors.getMethodIDOf(
      _classRef, "getSpanFlags", "(Ljava/lang/Object;)I");

  /// from: public int getSpanFlags(java.lang.Object what)
  ///
  /// Return the flags of the end of the specified
  /// markup object, or 0 if it is not attached to this buffer.
  int getSpanFlags(jni.JniObject what) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getSpanFlags,
      jni.JniType.intType,
      [what.reference]).integer;

  static final _id_getSpans = jniAccessors.getMethodIDOf(
      _classRef, "getSpans", "(IILjava/lang/Class;)[Ljava/lang/Object;");

  /// from: public T[] getSpans(int queryStart, int queryEnd, java.lang.Class<T> kind)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an array of the spans of the specified type that overlap
  /// the specified range of the buffer.  The kind may be Object.class to get
  /// a list of all the spans regardless of type.
  ///@param kind This value may be {@code null}.
  jni.JniObject getSpans(int queryStart, int queryEnd, jni.JniObject kind) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSpans,
          jni.JniType.objectType,
          [queryStart, queryEnd, kind.reference]).object);

  static final _id_nextSpanTransition = jniAccessors.getMethodIDOf(
      _classRef, "nextSpanTransition", "(IILjava/lang/Class;)I");

  /// from: public int nextSpanTransition(int start, int limit, java.lang.Class kind)
  ///
  /// Return the next offset after <code>start</code> but less than or
  /// equal to <code>limit</code> where a span of the specified type
  /// begins or ends.
  int nextSpanTransition(int start, int limit, jni.JniObject kind) =>
      jniAccessors.callMethodWithArgs(reference, _id_nextSpanTransition,
          jni.JniType.intType, [start, limit, kind.reference]).integer;

  static final _id_subSequence = jniAccessors.getMethodIDOf(
      _classRef, "subSequence", "(II)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence subSequence(int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new CharSequence containing a copy of the specified
  /// range of this buffer, including the overlapping spans.
  jni.JniObject subSequence(int start, int end) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_subSequence, jni.JniType.objectType, [start, end]).object);

  static final _id_getChars =
      jniAccessors.getMethodIDOf(_classRef, "getChars", "(II[CI)V");

  /// from: public void getChars(int start, int end, char[] dest, int destoff)
  ///
  /// Copy the specified range of chars from this buffer into the
  /// specified array, beginning at the specified offset.
  void getChars(int start, int end, jni.JniObject dest, int destoff) =>
      jniAccessors.callMethodWithArgs(reference, _id_getChars,
          jni.JniType.voidType, [start, end, dest.reference, destoff]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a String containing a copy of the chars in this buffer.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_getTextWatcherDepth =
      jniAccessors.getMethodIDOf(_classRef, "getTextWatcherDepth", "()I");

  /// from: public int getTextWatcherDepth()
  ///
  /// Returns the depth of TextWatcher callbacks. Returns 0 when the object is not handling
  /// TextWatchers. A return value greater than 1 implies that a TextWatcher caused a change that
  /// recursively triggered a TextWatcher.
  int getTextWatcherDepth() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextWatcherDepth, jni.JniType.intType, []).integer;

  static final _id_getTextRunCursor = jniAccessors.getMethodIDOf(
      _classRef, "getTextRunCursor", "(IIIIILandroid/graphics/Paint;)I");

  /// from: public int getTextRunCursor(int contextStart, int contextEnd, int dir, int offset, int cursorOpt, android.graphics.Paint p)
  ///
  /// Returns the next cursor position in the run.  This avoids placing the cursor between
  /// surrogates, between characters that form conjuncts, between base characters and combining
  /// marks, or within a reordering cluster.
  ///
  /// The context is the shaping context for cursor movement, generally the bounds of the metric
  /// span enclosing the cursor in the direction of movement.
  /// <code>contextStart</code>, <code>contextEnd</code> and <code>offset</code> are relative to
  /// the start of the string.
  ///
  ///
  /// If cursorOpt is CURSOR_AT and the offset is not a valid cursor position,
  /// this returns -1.  Otherwise this will never return a value before contextStart or after
  /// contextEnd.
  ///
  ///@param contextStart the start index of the context
  ///@param contextEnd the (non-inclusive) end index of the context
  ///@param dir either DIRECTION_RTL or DIRECTION_LTR
  ///@param offset the cursor position to move from
  ///@param cursorOpt how to move the cursor, one of CURSOR_AFTER,
  /// CURSOR_AT_OR_AFTER, CURSOR_BEFORE,
  /// CURSOR_AT_OR_BEFORE, or CURSOR_AT
  ///@param p the Paint object that is requesting this information
  ///@return the offset of the next position, or -1
  ///@deprecated This is an internal method, refrain from using it in your code
  int getTextRunCursor(int contextStart, int contextEnd, int dir, int offset,
          int cursorOpt, paint_.Paint p) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_getTextRunCursor, jni.JniType.intType, [
        contextStart,
        contextEnd,
        dir,
        offset,
        cursorOpt,
        p.reference
      ]).integer;

  static final _id_setFilters = jniAccessors.getMethodIDOf(
      _classRef, "setFilters", "([Landroid/text/InputFilter;)V");

  /// from: public void setFilters(android.text.InputFilter[] filters)
  void setFilters(jni.JniObject filters) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFilters,
      jni.JniType.voidType,
      [filters.reference]).check();

  static final _id_getFilters = jniAccessors.getMethodIDOf(
      _classRef, "getFilters", "()[Landroid/text/InputFilter;");

  /// from: public android.text.InputFilter[] getFilters()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getFilters() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFilters, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}
