// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.text.Spannable
///
/// This is the interface for text to which markup objects can be
/// attached and detached.  Not all Spannable classes have mutable text;
/// see Editable for that.
class Spannable extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/text/Spannable");
  Spannable.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_setSpan = jniAccessors.getMethodIDOf(
      _classRef, "setSpan", "(Ljava/lang/Object;III)V");

  /// from: public abstract void setSpan(java.lang.Object what, int start, int end, int flags)
  ///
  /// Attach the specified markup object to the range <code>start&hellip;end</code>
  /// of the text, or move the object to that range if it was already
  /// attached elsewhere.  See Spanned for an explanation of
  /// what the flags mean.  The object can be one that has meaning only
  /// within your application, or it can be one that the text system will
  /// use to affect text display or behavior.  Some noteworthy ones are
  /// the subclasses of android.text.style.CharacterStyle and
  /// android.text.style.ParagraphStyle, and
  /// android.text.TextWatcher and
  /// android.text.SpanWatcher.
  void setSpan(jni.JniObject what, int start, int end, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSpan,
          jni.JniType.voidType, [what.reference, start, end, flags]).check();

  static final _id_removeSpan = jniAccessors.getMethodIDOf(
      _classRef, "removeSpan", "(Ljava/lang/Object;)V");

  /// from: public abstract void removeSpan(java.lang.Object what)
  ///
  /// Remove the specified object from the range of text to which it
  /// was attached, if any.  It is OK to remove an object that was never
  /// attached in the first place.
  void removeSpan(jni.JniObject what) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeSpan,
      jni.JniType.voidType,
      [what.reference]).check();
}

/// from: android.text.Spannable$Factory
///
/// Factory used by TextView to create new Spannable Spannables. You can subclass
/// it to provide something other than SpannableString.
///@see android.widget.TextView\#setSpannableFactory(Factory)
class Spannable_Factory extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/Spannable\$Factory");
  Spannable_Factory.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Spannable_Factory()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getInstance", "()Landroid/text/Spannable\$Factory;");

  /// from: static public android.text.Spannable.Factory getInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the standard Spannable Factory.
  static Spannable_Factory getInstance() =>
      Spannable_Factory.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getInstance, jni.JniType.objectType, []).object);

  static final _id_newSpannable = jniAccessors.getMethodIDOf(_classRef,
      "newSpannable", "(Ljava/lang/CharSequence;)Landroid/text/Spannable;");

  /// from: public android.text.Spannable newSpannable(java.lang.CharSequence source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a new SpannableString from the specified CharSequence.
  /// You can override this to provide a different kind of Spannable.
  Spannable newSpannable(jni.JniObject source) =>
      Spannable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_newSpannable, jni.JniType.objectType, [source.reference]).object);
}
