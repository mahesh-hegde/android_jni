// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../Spannable.dart" as spannable_;

import "../../view/KeyEvent.dart" as keyevent_;

import "../../view/View.dart" as view_;

import "../Editable.dart" as editable_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.text.method.MetaKeyKeyListener
///
/// This base class encapsulates the behavior for tracking the state of
/// meta keys such as SHIFT, ALT and SYM as well as the pseudo-meta state of selecting text.
///
/// Key listeners that care about meta state should inherit from this class;
/// you should not instantiate this class directly in a client.
///
///
/// This class provides two mechanisms for tracking meta state that can be used
/// together or independently.
///
///
/// <ul>
/// <li>Methods such as \#handleKeyDown(long, int, KeyEvent) and
/// \#getMetaState(long) operate on a meta key state bit mask.</li>
/// <li>Methods such as \#onKeyDown(View, Editable, int, KeyEvent) and
/// \#getMetaState(CharSequence, int) operate on meta key state flags stored
/// as spans in an Editable text buffer.  The spans only describe the current
/// meta key state of the text editor; they do not carry any positional information.</li>
/// </ul>
///
/// The behavior of this class varies according to the keyboard capabilities
/// described by the KeyCharacterMap of the keyboard device such as
/// the KeyCharacterMap\#getModifierBehavior() key modifier behavior.
///
///
/// MetaKeyKeyListener implements chorded and toggled key modifiers.
/// When key modifiers are toggled into a latched or locked state, the state
/// of the modifier is stored in the Editable text buffer or in a
/// meta state integer managed by the client.  These latched or locked modifiers
/// should be considered to be held __in addition to__ those that the
/// keyboard already reported as being pressed in KeyEvent\#getMetaState().
/// In other words, the MetaKeyKeyListener augments the meta state
/// provided by the keyboard; it does not replace it.  This distinction is important
/// to ensure that meta keys not handled by MetaKeyKeyListener such as
/// KeyEvent\#KEYCODE_CAPS_LOCK or KeyEvent\#KEYCODE_NUM_LOCK are
/// taken into consideration.
///
///
/// To ensure correct meta key behavior, the following pattern should be used
/// when mapping key codes to characters:
///
///
/// <code>
/// private char getUnicodeChar(TextKeyListener listener, KeyEvent event, Editable textBuffer) {
///     // Use the combined meta states from the event and the key listener.
///     int metaState = event.getMetaState() | listener.getMetaState(textBuffer);
///     return event.getUnicodeChar(metaState);
/// }
/// </code>
class MetaKeyKeyListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/method/MetaKeyKeyListener");
  MetaKeyKeyListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int META_ALT_LOCKED
  ///
  /// Flag that indicates that the ALT key is locked.
  static const META_ALT_LOCKED = 512;

  /// from: static public final int META_ALT_ON
  ///
  /// Flag that indicates that the ALT key is on.
  /// Value equals KeyEvent\#META_ALT_ON.
  static const META_ALT_ON = 2;

  /// from: static public final int META_CAP_LOCKED
  ///
  /// Flag that indicates that the SHIFT key is locked in CAPS mode.
  static const META_CAP_LOCKED = 256;

  /// from: static public final int META_SHIFT_ON
  ///
  /// Flag that indicates that the SHIFT key is on.
  /// Value equals KeyEvent\#META_SHIFT_ON.
  static const META_SHIFT_ON = 1;

  /// from: static public final int META_SYM_LOCKED
  ///
  /// Flag that indicates that the SYM key is locked.
  static const META_SYM_LOCKED = 1024;

  /// from: static public final int META_SYM_ON
  ///
  /// Flag that indicates that the SYM key is on.
  /// Value equals KeyEvent\#META_SYM_ON.
  static const META_SYM_ON = 4;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MetaKeyKeyListener()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_resetMetaState = jniAccessors.getStaticMethodIDOf(
      _classRef, "resetMetaState", "(Landroid/text/Spannable;)V");

  /// from: static public void resetMetaState(android.text.Spannable text)
  ///
  /// Resets all meta state to inactive.
  static void resetMetaState(spannable_.Spannable text) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_resetMetaState,
          jni.JniType.voidType, [text.reference]).check();

  static final _id_getMetaState = jniAccessors.getStaticMethodIDOf(
      _classRef, "getMetaState", "(Ljava/lang/CharSequence;)I");

  /// from: static public final int getMetaState(java.lang.CharSequence text)
  ///
  /// Gets the state of the meta keys.
  ///@param text the buffer in which the meta key would have been pressed.
  ///@return an integer in which each bit set to one represents a pressed
  ///         or locked meta key.
  static int getMetaState(jni.JniObject text) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getMetaState,
          jni.JniType.intType, [text.reference]).integer;

  static final _id_getMetaState1 = jniAccessors.getStaticMethodIDOf(_classRef,
      "getMetaState", "(Ljava/lang/CharSequence;Landroid/view/KeyEvent;)I");

  /// from: static public final int getMetaState(java.lang.CharSequence text, android.view.KeyEvent event)
  ///
  /// Gets the state of the meta keys for a specific key event.
  ///
  /// For input devices that use toggled key modifiers, the `toggled' state
  /// is stored into the text buffer. This method retrieves the meta state
  /// for this event, accounting for the stored state. If the event has been
  /// created by a device that does not support toggled key modifiers, like
  /// a virtual device for example, the stored state is ignored.
  ///@param text the buffer in which the meta key would have been pressed.
  ///@param event the event for which to evaluate the meta state.
  ///@return an integer in which each bit set to one represents a pressed
  ///         or locked meta key.
  static int getMetaState1(jni.JniObject text, keyevent_.KeyEvent event) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getMetaState1,
          jni.JniType.intType, [text.reference, event.reference]).integer;

  static final _id_getMetaState2 = jniAccessors.getStaticMethodIDOf(
      _classRef, "getMetaState", "(Ljava/lang/CharSequence;I)I");

  /// from: static public final int getMetaState(java.lang.CharSequence text, int meta)
  ///
  /// Gets the state of a particular meta key.
  ///@param meta META_SHIFT_ON, META_ALT_ON, META_SYM_ON
  ///@param text the buffer in which the meta key would have been pressed.
  ///@return 0 if inactive, 1 if active, 2 if locked.
  static int getMetaState2(jni.JniObject text, int meta) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getMetaState2,
          jni.JniType.intType, [text.reference, meta]).integer;

  static final _id_getMetaState3 = jniAccessors.getStaticMethodIDOf(_classRef,
      "getMetaState", "(Ljava/lang/CharSequence;ILandroid/view/KeyEvent;)I");

  /// from: static public final int getMetaState(java.lang.CharSequence text, int meta, android.view.KeyEvent event)
  ///
  /// Gets the state of a particular meta key to use with a particular key event.
  ///
  /// If the key event has been created by a device that does not support toggled
  /// key modifiers, like a virtual keyboard for example, only the meta state in
  /// the key event is considered.
  ///@param meta META_SHIFT_ON, META_ALT_ON, META_SYM_ON
  ///@param text the buffer in which the meta key would have been pressed.
  ///@param event the event for which to evaluate the meta state.
  ///@return 0 if inactive, 1 if active, 2 if locked.
  static int getMetaState3(
          jni.JniObject text, int meta, keyevent_.KeyEvent event) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getMetaState3,
          jni.JniType.intType, [text.reference, meta, event.reference]).integer;

  static final _id_adjustMetaAfterKeypress = jniAccessors.getStaticMethodIDOf(
      _classRef, "adjustMetaAfterKeypress", "(Landroid/text/Spannable;)V");

  /// from: static public void adjustMetaAfterKeypress(android.text.Spannable content)
  ///
  /// Call this method after you handle a keypress so that the meta
  /// state will be reset to unshifted (if it is not still down)
  /// or primed to be reset to unshifted (once it is released).
  static void adjustMetaAfterKeypress(spannable_.Spannable content) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_adjustMetaAfterKeypress,
          jni.JniType.voidType,
          [content.reference]).check();

  static final _id_isMetaTracker = jniAccessors.getStaticMethodIDOf(_classRef,
      "isMetaTracker", "(Ljava/lang/CharSequence;Ljava/lang/Object;)Z");

  /// from: static public boolean isMetaTracker(java.lang.CharSequence text, java.lang.Object what)
  ///
  /// Returns true if this object is one that this class would use to
  /// keep track of any meta state in the specified text.
  static bool isMetaTracker(jni.JniObject text, jni.JniObject what) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isMetaTracker,
          jni.JniType.booleanType, [text.reference, what.reference]).boolean;

  static final _id_isSelectingMetaTracker = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "isSelectingMetaTracker",
      "(Ljava/lang/CharSequence;Ljava/lang/Object;)Z");

  /// from: static public boolean isSelectingMetaTracker(java.lang.CharSequence text, java.lang.Object what)
  ///
  /// Returns true if this object is one that this class would use to
  /// keep track of the selecting meta state in the specified text.
  static bool isSelectingMetaTracker(jni.JniObject text, jni.JniObject what) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_isSelectingMetaTracker,
          jni.JniType.booleanType,
          [text.reference, what.reference]).boolean;

  static final _id_resetLockedMeta = jniAccessors.getStaticMethodIDOf(
      _classRef, "resetLockedMeta", "(Landroid/text/Spannable;)V");

  /// from: static protected void resetLockedMeta(android.text.Spannable content)
  ///
  /// Call this if you are a method that ignores the locked meta state
  /// (arrow keys, for example) and you handle a key.
  static void resetLockedMeta(spannable_.Spannable content) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_resetLockedMeta,
          jni.JniType.voidType, [content.reference]).check();

  static final _id_onKeyDown = jniAccessors.getMethodIDOf(
      _classRef,
      "onKeyDown",
      "(Landroid/view/View;Landroid/text/Editable;ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyDown(android.view.View view, android.text.Editable content, int keyCode, android.view.KeyEvent event)
  ///
  /// Handles presses of the meta keys.
  bool onKeyDown(view_.View view, editable_.Editable content, int keyCode,
          keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onKeyDown, jni.JniType.booleanType, [
        view.reference,
        content.reference,
        keyCode,
        event.reference
      ]).boolean;

  static final _id_onKeyUp = jniAccessors.getMethodIDOf(_classRef, "onKeyUp",
      "(Landroid/view/View;Landroid/text/Editable;ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyUp(android.view.View view, android.text.Editable content, int keyCode, android.view.KeyEvent event)
  ///
  /// Handles release of the meta keys.
  bool onKeyUp(view_.View view, editable_.Editable content, int keyCode,
          keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onKeyUp, jni.JniType.booleanType, [
        view.reference,
        content.reference,
        keyCode,
        event.reference
      ]).boolean;

  static final _id_clearMetaKeyState = jniAccessors.getMethodIDOf(_classRef,
      "clearMetaKeyState", "(Landroid/view/View;Landroid/text/Editable;I)V");

  /// from: public void clearMetaKeyState(android.view.View view, android.text.Editable content, int states)
  void clearMetaKeyState(
          view_.View view, editable_.Editable content, int states) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_clearMetaKeyState,
          jni.JniType.voidType,
          [view.reference, content.reference, states]).check();

  static final _id_clearMetaKeyState1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "clearMetaKeyState", "(Landroid/text/Editable;I)V");

  /// from: static public void clearMetaKeyState(android.text.Editable content, int states)
  static void clearMetaKeyState1(editable_.Editable content, int states) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_clearMetaKeyState1,
          jni.JniType.voidType, [content.reference, states]).check();

  static final _id_resetLockedMeta1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "resetLockedMeta", "(J)J");

  /// from: static public long resetLockedMeta(long state)
  ///
  /// Call this if you are a method that ignores the locked meta state
  /// (arrow keys, for example) and you handle a key.
  static int resetLockedMeta1(int state) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_resetLockedMeta1, jni.JniType.longType, [state]).long;

  static final _id_getMetaState4 =
      jniAccessors.getStaticMethodIDOf(_classRef, "getMetaState", "(J)I");

  /// from: static public final int getMetaState(long state)
  ///
  /// Gets the state of the meta keys.
  ///@param state the current meta state bits.
  ///@return an integer in which each bit set to one represents a pressed
  ///         or locked meta key.
  static int getMetaState4(int state) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getMetaState4, jni.JniType.intType, [state]).integer;

  static final _id_getMetaState5 =
      jniAccessors.getStaticMethodIDOf(_classRef, "getMetaState", "(JI)I");

  /// from: static public final int getMetaState(long state, int meta)
  ///
  /// Gets the state of a particular meta key.
  ///@param state the current state bits.
  ///@param meta META_SHIFT_ON, META_ALT_ON, or META_SYM_ON
  ///@return 0 if inactive, 1 if active, 2 if locked.
  static int getMetaState5(int state, int meta) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getMetaState5,
          jni.JniType.intType, [state, meta]).integer;

  static final _id_adjustMetaAfterKeypress1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "adjustMetaAfterKeypress", "(J)J");

  /// from: static public long adjustMetaAfterKeypress(long state)
  ///
  /// Call this method after you handle a keypress so that the meta
  /// state will be reset to unshifted (if it is not still down)
  /// or primed to be reset to unshifted (once it is released).  Takes
  /// the current state, returns the new state.
  static int adjustMetaAfterKeypress1(int state) =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_adjustMetaAfterKeypress1, jni.JniType.longType, [state]).long;

  static final _id_handleKeyDown = jniAccessors.getStaticMethodIDOf(
      _classRef, "handleKeyDown", "(JILandroid/view/KeyEvent;)J");

  /// from: static public long handleKeyDown(long state, int keyCode, android.view.KeyEvent event)
  ///
  /// Handles presses of the meta keys.
  static int handleKeyDown(int state, int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_handleKeyDown,
          jni.JniType.longType, [state, keyCode, event.reference]).long;

  static final _id_handleKeyUp = jniAccessors.getStaticMethodIDOf(
      _classRef, "handleKeyUp", "(JILandroid/view/KeyEvent;)J");

  /// from: static public long handleKeyUp(long state, int keyCode, android.view.KeyEvent event)
  ///
  /// Handles release of the meta keys.
  static int handleKeyUp(int state, int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_handleKeyUp,
          jni.JniType.longType, [state, keyCode, event.reference]).long;

  static final _id_clearMetaKeyState2 =
      jniAccessors.getMethodIDOf(_classRef, "clearMetaKeyState", "(JI)J");

  /// from: public long clearMetaKeyState(long state, int which)
  ///
  /// Clears the state of the specified meta key if it is locked.
  ///@param state the meta key state
  ///@param which meta keys to clear, may be a combination of \#META_SHIFT_ON,
  /// \#META_ALT_ON or \#META_SYM_ON.
  int clearMetaKeyState2(int state, int which) =>
      jniAccessors.callMethodWithArgs(reference, _id_clearMetaKeyState2,
          jni.JniType.longType, [state, which]).long;
}
