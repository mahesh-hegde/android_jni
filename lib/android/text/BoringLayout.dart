// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Layout.dart" as layout_;

import "TextPaint.dart" as textpaint_;

import "TextUtils.dart" as textutils_;

import "../graphics/Canvas.dart" as canvas_;

import "../graphics/Path.dart" as path_;

import "../graphics/Paint.dart" as paint_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.text.BoringLayout
///
/// A BoringLayout is a very simple Layout implementation for text that
/// fits on a single line and is all left-to-right characters.
/// You will probably never want to make one of these yourself;
/// if you do, be sure to call \#isBoring first to make sure
/// the text meets the criteria.
/// This class is used by widgets to control text layout. You should not need
/// to use this class directly unless you are implementing your own widget
/// or custom display object, in which case
/// you are encouraged to use a Layout instead of calling
/// android.graphics.Canvas\#drawText(java.lang.CharSequence, int, int, float, float, android.graphics.Paint) Canvas.drawText() directly.
///
class BoringLayout extends layout_.Layout {
  static final _classRef = jniAccessors.getClassOf("android/text/BoringLayout");
  BoringLayout.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/CharSequence;Landroid/text/TextPaint;ILandroid/text/Layout\$Alignment;FFLandroid/text/BoringLayout\$Metrics;Z)V");

  /// from: public void <init>(java.lang.CharSequence source, android.text.TextPaint paint, int outerwidth, android.text.Layout.Alignment align, float spacingMult, float spacingAdd, android.text.BoringLayout.Metrics metrics, boolean includePad)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param source the text to render
  ///@param paint the default paint for the layout
  ///@param outerwidth the wrapping width for the text
  ///@param align whether to left, right, or center the text
  ///@param spacingMult this value is no longer used by BoringLayout
  ///@param spacingAdd this value is no longer used by BoringLayout
  ///@param metrics {@code \#Metrics} instance that contains information about FontMetrics and
  ///                line width
  ///@param includePad set whether to include extra space beyond font ascent and descent which is
  ///                   needed to avoid clipping in some scripts
  BoringLayout.ctor1(
      jni.JniObject source,
      textpaint_.TextPaint paint,
      int outerwidth,
      layout_.Layout_Alignment align,
      double spacingMult,
      double spacingAdd,
      BoringLayout_Metrics metrics,
      bool includePad)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1, [
          source.reference,
          paint.reference,
          outerwidth,
          align.reference,
          spacingMult,
          spacingAdd,
          metrics.reference,
          includePad
        ]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/CharSequence;Landroid/text/TextPaint;ILandroid/text/Layout\$Alignment;FFLandroid/text/BoringLayout\$Metrics;ZLandroid/text/TextUtils\$TruncateAt;I)V");

  /// from: public void <init>(java.lang.CharSequence source, android.text.TextPaint paint, int outerWidth, android.text.Layout.Alignment align, float spacingMult, float spacingAdd, android.text.BoringLayout.Metrics metrics, boolean includePad, android.text.TextUtils.TruncateAt ellipsize, int ellipsizedWidth)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param source the text to render
  ///@param paint the default paint for the layout
  ///@param outerWidth the wrapping width for the text
  ///@param align whether to left, right, or center the text
  ///@param spacingMult this value is no longer used by BoringLayout
  ///@param spacingAdd this value is no longer used by BoringLayout
  ///@param metrics {@code \#Metrics} instance that contains information about FontMetrics and
  ///                line width
  ///@param includePad set whether to include extra space beyond font ascent and descent which is
  ///                   needed to avoid clipping in some scripts
  ///@param ellipsize whether to ellipsize the text if width of the text is longer than the
  ///                  requested {@code outerwidth}
  ///@param ellipsizedWidth the width to which this Layout is ellipsizing. If {@code ellipsize} is
  ///                        {@code null}, or is TextUtils.TruncateAt\#MARQUEE this value is
  ///                        not used, {@code outerwidth} is used instead
  BoringLayout.ctor2(
      jni.JniObject source,
      textpaint_.TextPaint paint,
      int outerWidth,
      layout_.Layout_Alignment align,
      double spacingMult,
      double spacingAdd,
      BoringLayout_Metrics metrics,
      bool includePad,
      textutils_.TextUtils_TruncateAt ellipsize,
      int ellipsizedWidth)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, [
          source.reference,
          paint.reference,
          outerWidth,
          align.reference,
          spacingMult,
          spacingAdd,
          metrics.reference,
          includePad,
          ellipsize.reference,
          ellipsizedWidth
        ]).object);

  static final _id_make = jniAccessors.getStaticMethodIDOf(_classRef, "make",
      "(Ljava/lang/CharSequence;Landroid/text/TextPaint;ILandroid/text/Layout\$Alignment;FFLandroid/text/BoringLayout\$Metrics;Z)Landroid/text/BoringLayout;");

  /// from: static public android.text.BoringLayout make(java.lang.CharSequence source, android.text.TextPaint paint, int outerWidth, android.text.Layout.Alignment align, float spacingMult, float spacingAdd, android.text.BoringLayout.Metrics metrics, boolean includePad)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Utility function to construct a BoringLayout instance.
  ///@param source the text to render
  ///@param paint the default paint for the layout
  ///@param outerWidth the wrapping width for the text
  ///@param align whether to left, right, or center the text
  ///@param spacingMult this value is no longer used by BoringLayout
  ///@param spacingAdd this value is no longer used by BoringLayout
  ///@param metrics {@code \#Metrics} instance that contains information about FontMetrics and
  ///                line width
  ///@param includePad set whether to include extra space beyond font ascent and descent which is
  ///                   needed to avoid clipping in some scripts
  static BoringLayout make(
          jni.JniObject source,
          textpaint_.TextPaint paint,
          int outerWidth,
          layout_.Layout_Alignment align,
          double spacingMult,
          double spacingAdd,
          BoringLayout_Metrics metrics,
          bool includePad) =>
      BoringLayout.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_make, jni.JniType.objectType, [
        source.reference,
        paint.reference,
        outerWidth,
        align.reference,
        spacingMult,
        spacingAdd,
        metrics.reference,
        includePad
      ]).object);

  static final _id_make1 = jniAccessors.getStaticMethodIDOf(_classRef, "make",
      "(Ljava/lang/CharSequence;Landroid/text/TextPaint;ILandroid/text/Layout\$Alignment;FFLandroid/text/BoringLayout\$Metrics;ZLandroid/text/TextUtils\$TruncateAt;I)Landroid/text/BoringLayout;");

  /// from: static public android.text.BoringLayout make(java.lang.CharSequence source, android.text.TextPaint paint, int outerWidth, android.text.Layout.Alignment align, float spacingmult, float spacingadd, android.text.BoringLayout.Metrics metrics, boolean includePad, android.text.TextUtils.TruncateAt ellipsize, int ellipsizedWidth)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Utility function to construct a BoringLayout instance.
  ///@param source the text to render
  ///@param paint the default paint for the layout
  ///@param outerWidth the wrapping width for the text
  ///@param align whether to left, right, or center the text
  ///@param spacingmult this value is no longer used by BoringLayout
  ///@param spacingadd this value is no longer used by BoringLayout
  ///@param metrics {@code \#Metrics} instance that contains information about FontMetrics and
  ///                line width
  ///@param includePad set whether to include extra space beyond font ascent and descent which is
  ///                   needed to avoid clipping in some scripts
  ///@param ellipsize whether to ellipsize the text if width of the text is longer than the
  ///                  requested width
  ///@param ellipsizedWidth the width to which this Layout is ellipsizing. If {@code ellipsize} is
  ///                        {@code null}, or is TextUtils.TruncateAt\#MARQUEE this value is
  ///                        not used, {@code outerWidth} is used instead
  static BoringLayout make1(
          jni.JniObject source,
          textpaint_.TextPaint paint,
          int outerWidth,
          layout_.Layout_Alignment align,
          double spacingmult,
          double spacingadd,
          BoringLayout_Metrics metrics,
          bool includePad,
          textutils_.TextUtils_TruncateAt ellipsize,
          int ellipsizedWidth) =>
      BoringLayout.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_make1, jni.JniType.objectType, [
        source.reference,
        paint.reference,
        outerWidth,
        align.reference,
        spacingmult,
        spacingadd,
        metrics.reference,
        includePad,
        ellipsize.reference,
        ellipsizedWidth
      ]).object);

  static final _id_replaceOrMake = jniAccessors.getMethodIDOf(
      _classRef,
      "replaceOrMake",
      "(Ljava/lang/CharSequence;Landroid/text/TextPaint;ILandroid/text/Layout\$Alignment;FFLandroid/text/BoringLayout\$Metrics;Z)Landroid/text/BoringLayout;");

  /// from: public android.text.BoringLayout replaceOrMake(java.lang.CharSequence source, android.text.TextPaint paint, int outerwidth, android.text.Layout.Alignment align, float spacingMult, float spacingAdd, android.text.BoringLayout.Metrics metrics, boolean includePad)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a BoringLayout for the specified text, potentially reusing
  /// this one if it is already suitable.  The caller must make sure that
  /// no one is still using this Layout.
  ///@param source the text to render
  ///@param paint the default paint for the layout
  ///@param outerwidth the wrapping width for the text
  ///@param align whether to left, right, or center the text
  ///@param spacingMult this value is no longer used by BoringLayout
  ///@param spacingAdd this value is no longer used by BoringLayout
  ///@param metrics {@code \#Metrics} instance that contains information about FontMetrics and
  ///                line width
  ///@param includePad set whether to include extra space beyond font ascent and descent which is
  ///                   needed to avoid clipping in some scripts
  BoringLayout replaceOrMake(
          jni.JniObject source,
          textpaint_.TextPaint paint,
          int outerwidth,
          layout_.Layout_Alignment align,
          double spacingMult,
          double spacingAdd,
          BoringLayout_Metrics metrics,
          bool includePad) =>
      BoringLayout.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_replaceOrMake, jni.JniType.objectType, [
        source.reference,
        paint.reference,
        outerwidth,
        align.reference,
        spacingMult,
        spacingAdd,
        metrics.reference,
        includePad
      ]).object);

  static final _id_replaceOrMake1 = jniAccessors.getMethodIDOf(
      _classRef,
      "replaceOrMake",
      "(Ljava/lang/CharSequence;Landroid/text/TextPaint;ILandroid/text/Layout\$Alignment;FFLandroid/text/BoringLayout\$Metrics;ZLandroid/text/TextUtils\$TruncateAt;I)Landroid/text/BoringLayout;");

  /// from: public android.text.BoringLayout replaceOrMake(java.lang.CharSequence source, android.text.TextPaint paint, int outerWidth, android.text.Layout.Alignment align, float spacingMult, float spacingAdd, android.text.BoringLayout.Metrics metrics, boolean includePad, android.text.TextUtils.TruncateAt ellipsize, int ellipsizedWidth)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a BoringLayout for the specified text, potentially reusing
  /// this one if it is already suitable.  The caller must make sure that
  /// no one is still using this Layout.
  ///@param source the text to render
  ///@param paint the default paint for the layout
  ///@param outerWidth the wrapping width for the text
  ///@param align whether to left, right, or center the text
  ///@param spacingMult this value is no longer used by BoringLayout
  ///@param spacingAdd this value is no longer used by BoringLayout
  ///@param metrics {@code \#Metrics} instance that contains information about FontMetrics and
  ///                line width
  ///@param includePad set whether to include extra space beyond font ascent and descent which is
  ///                   needed to avoid clipping in some scripts
  ///@param ellipsize whether to ellipsize the text if width of the text is longer than the
  ///                  requested width
  ///@param ellipsizedWidth the width to which this Layout is ellipsizing. If {@code ellipsize} is
  ///                        {@code null}, or is TextUtils.TruncateAt\#MARQUEE this value is
  ///                        not used, {@code outerwidth} is used instead
  BoringLayout replaceOrMake1(
          jni.JniObject source,
          textpaint_.TextPaint paint,
          int outerWidth,
          layout_.Layout_Alignment align,
          double spacingMult,
          double spacingAdd,
          BoringLayout_Metrics metrics,
          bool includePad,
          textutils_.TextUtils_TruncateAt ellipsize,
          int ellipsizedWidth) =>
      BoringLayout.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_replaceOrMake1, jni.JniType.objectType, [
        source.reference,
        paint.reference,
        outerWidth,
        align.reference,
        spacingMult,
        spacingAdd,
        metrics.reference,
        includePad,
        ellipsize.reference,
        ellipsizedWidth
      ]).object);

  static final _id_isBoring = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "isBoring",
      "(Ljava/lang/CharSequence;Landroid/text/TextPaint;)Landroid/text/BoringLayout\$Metrics;");

  /// from: static public android.text.BoringLayout.Metrics isBoring(java.lang.CharSequence text, android.text.TextPaint paint)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns null if not boring; the width, ascent, and descent if boring.
  static BoringLayout_Metrics isBoring(
          jni.JniObject text, textpaint_.TextPaint paint) =>
      BoringLayout_Metrics.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_isBoring,
          jni.JniType.objectType,
          [text.reference, paint.reference]).object);

  static final _id_isBoring1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "isBoring",
      "(Ljava/lang/CharSequence;Landroid/text/TextPaint;Landroid/text/BoringLayout\$Metrics;)Landroid/text/BoringLayout\$Metrics;");

  /// from: static public android.text.BoringLayout.Metrics isBoring(java.lang.CharSequence text, android.text.TextPaint paint, android.text.BoringLayout.Metrics metrics)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns null if not boring; the width, ascent, and descent in the
  /// provided Metrics object (or a new one if the provided one was null)
  /// if boring.
  static BoringLayout_Metrics isBoring1(jni.JniObject text,
          textpaint_.TextPaint paint, BoringLayout_Metrics metrics) =>
      BoringLayout_Metrics.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_isBoring1,
          jni.JniType.objectType,
          [text.reference, paint.reference, metrics.reference]).object);

  static final _id_getHeight =
      jniAccessors.getMethodIDOf(_classRef, "getHeight", "()I");

  /// from: public int getHeight()
  int getHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeight, jni.JniType.intType, []).integer;

  static final _id_getLineCount =
      jniAccessors.getMethodIDOf(_classRef, "getLineCount", "()I");

  /// from: public int getLineCount()
  int getLineCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getLineCount, jni.JniType.intType, []).integer;

  static final _id_getLineTop =
      jniAccessors.getMethodIDOf(_classRef, "getLineTop", "(I)I");

  /// from: public int getLineTop(int line)
  int getLineTop(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineTop, jni.JniType.intType, [line]).integer;

  static final _id_getLineDescent =
      jniAccessors.getMethodIDOf(_classRef, "getLineDescent", "(I)I");

  /// from: public int getLineDescent(int line)
  int getLineDescent(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineDescent, jni.JniType.intType, [line]).integer;

  static final _id_getLineStart =
      jniAccessors.getMethodIDOf(_classRef, "getLineStart", "(I)I");

  /// from: public int getLineStart(int line)
  int getLineStart(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineStart, jni.JniType.intType, [line]).integer;

  static final _id_getParagraphDirection =
      jniAccessors.getMethodIDOf(_classRef, "getParagraphDirection", "(I)I");

  /// from: public int getParagraphDirection(int line)
  int getParagraphDirection(int line) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getParagraphDirection,
      jni.JniType.intType,
      [line]).integer;

  static final _id_getLineContainsTab =
      jniAccessors.getMethodIDOf(_classRef, "getLineContainsTab", "(I)Z");

  /// from: public boolean getLineContainsTab(int line)
  bool getLineContainsTab(int line) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getLineContainsTab,
      jni.JniType.booleanType,
      [line]).boolean;

  static final _id_getLineMax =
      jniAccessors.getMethodIDOf(_classRef, "getLineMax", "(I)F");

  /// from: public float getLineMax(int line)
  double getLineMax(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineMax, jni.JniType.floatType, [line]).float;

  static final _id_getLineWidth =
      jniAccessors.getMethodIDOf(_classRef, "getLineWidth", "(I)F");

  /// from: public float getLineWidth(int line)
  double getLineWidth(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineWidth, jni.JniType.floatType, [line]).float;

  static final _id_getLineDirections = jniAccessors.getMethodIDOf(
      _classRef, "getLineDirections", "(I)Landroid/text/Layout\$Directions;");

  /// from: public final android.text.Layout.Directions getLineDirections(int line)
  /// The returned object must be deleted after use, by calling the `delete` method.
  layout_.Layout_Directions getLineDirections(int line) =>
      layout_.Layout_Directions.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getLineDirections,
          jni.JniType.objectType,
          [line]).object);

  static final _id_getTopPadding =
      jniAccessors.getMethodIDOf(_classRef, "getTopPadding", "()I");

  /// from: public int getTopPadding()
  int getTopPadding() => jniAccessors.callMethodWithArgs(
      reference, _id_getTopPadding, jni.JniType.intType, []).integer;

  static final _id_getBottomPadding =
      jniAccessors.getMethodIDOf(_classRef, "getBottomPadding", "()I");

  /// from: public int getBottomPadding()
  int getBottomPadding() => jniAccessors.callMethodWithArgs(
      reference, _id_getBottomPadding, jni.JniType.intType, []).integer;

  static final _id_getEllipsisCount =
      jniAccessors.getMethodIDOf(_classRef, "getEllipsisCount", "(I)I");

  /// from: public int getEllipsisCount(int line)
  int getEllipsisCount(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getEllipsisCount, jni.JniType.intType, [line]).integer;

  static final _id_getEllipsisStart =
      jniAccessors.getMethodIDOf(_classRef, "getEllipsisStart", "(I)I");

  /// from: public int getEllipsisStart(int line)
  int getEllipsisStart(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getEllipsisStart, jni.JniType.intType, [line]).integer;

  static final _id_getEllipsizedWidth =
      jniAccessors.getMethodIDOf(_classRef, "getEllipsizedWidth", "()I");

  /// from: public int getEllipsizedWidth()
  int getEllipsizedWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getEllipsizedWidth, jni.JniType.intType, []).integer;

  static final _id_draw1 = jniAccessors.getMethodIDOf(_classRef, "draw",
      "(Landroid/graphics/Canvas;Landroid/graphics/Path;Landroid/graphics/Paint;I)V");

  /// from: public void draw(android.graphics.Canvas c, android.graphics.Path highlight, android.graphics.Paint highlightpaint, int cursorOffset)
  void draw1(canvas_.Canvas c, path_.Path highlight,
          paint_.Paint highlightpaint, int cursorOffset) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_draw1, jni.JniType.voidType, [
        c.reference,
        highlight.reference,
        highlightpaint.reference,
        cursorOffset
      ]).check();

  static final _id_ellipsized =
      jniAccessors.getMethodIDOf(_classRef, "ellipsized", "(II)V");

  /// from: public void ellipsized(int start, int end)
  ///
  /// Callback for the ellipsizer to report what region it ellipsized.
  void ellipsized(int start, int end) => jniAccessors.callMethodWithArgs(
      reference, _id_ellipsized, jni.JniType.voidType, [start, end]).check();
}

/// from: android.text.BoringLayout$Metrics
class BoringLayout_Metrics extends paint_.Paint_FontMetricsInt {
  static final _classRef =
      jniAccessors.getClassOf("android/text/BoringLayout\$Metrics");
  BoringLayout_Metrics.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_width = jniAccessors.getFieldIDOf(_classRef, "width", "I");

  /// from: public int width
  int get width =>
      jniAccessors.getField(reference, _id_width, jni.JniType.intType).integer;

  /// from: public int width
  set width(int value) => jniEnv.SetIntField(reference, _id_width, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  BoringLayout_Metrics()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
