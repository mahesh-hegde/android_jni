// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Spanned.dart" as spanned_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.text.LoginFilter
///
/// Abstract class for filtering login-related text (user names and passwords)
class LoginFilter extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/text/LoginFilter");
  LoginFilter.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_filter = jniAccessors.getMethodIDOf(_classRef, "filter",
      "(Ljava/lang/CharSequence;IILandroid/text/Spanned;II)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence filter(java.lang.CharSequence source, int start, int end, android.text.Spanned dest, int dstart, int dend)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method is called when the buffer is going to replace the
  /// range <code>dstart &hellip; dend</code> of <code>dest</code>
  /// with the new text from the range <code>start &hellip; end</code>
  /// of <code>source</code>.  Returns the CharSequence that we want
  /// placed there instead, including an empty string
  /// if appropriate, or <code>null</code> to accept the original
  /// replacement.  Be careful to not to reject 0-length replacements,
  /// as this is what happens when you delete text.
  jni.JniObject filter(jni.JniObject source, int start, int end,
          spanned_.Spanned dest, int dstart, int dend) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_filter,
          jni.JniType.objectType,
          [source.reference, start, end, dest.reference, dstart, dend]).object);

  static final _id_onStart =
      jniAccessors.getMethodIDOf(_classRef, "onStart", "()V");

  /// from: public void onStart()
  ///
  /// Called when we start processing filter.
  void onStart() => jniAccessors.callMethodWithArgs(
      reference, _id_onStart, jni.JniType.voidType, []).check();

  static final _id_onInvalidCharacter =
      jniAccessors.getMethodIDOf(_classRef, "onInvalidCharacter", "(C)V");

  /// from: public void onInvalidCharacter(char c)
  ///
  /// Called whenever we encounter an invalid character.
  ///@param c the invalid character
  void onInvalidCharacter(int c) => jniAccessors.callMethodWithArgs(
      reference, _id_onInvalidCharacter, jni.JniType.voidType, [c]).check();

  static final _id_onStop =
      jniAccessors.getMethodIDOf(_classRef, "onStop", "()V");

  /// from: public void onStop()
  ///
  /// Called when we're done processing filter
  void onStop() => jniAccessors.callMethodWithArgs(
      reference, _id_onStop, jni.JniType.voidType, []).check();

  static final _id_isAllowed =
      jniAccessors.getMethodIDOf(_classRef, "isAllowed", "(C)Z");

  /// from: public abstract boolean isAllowed(char c)
  ///
  /// Returns whether or not we allow character c.
  /// Subclasses must override this method.
  bool isAllowed(int c) => jniAccessors.callMethodWithArgs(
      reference, _id_isAllowed, jni.JniType.booleanType, [c]).boolean;
}

/// from: android.text.LoginFilter$UsernameFilterGeneric
///
/// This filter rejects characters in the user name that are not compatible with Google login.
/// It is slightly less restrictive than the above filter in that it allows [a-zA-Z0-9._-+].
class LoginFilter_UsernameFilterGeneric extends LoginFilter {
  static final _classRef = jniAccessors
      .getClassOf("android/text/LoginFilter\$UsernameFilterGeneric");
  LoginFilter_UsernameFilterGeneric.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  LoginFilter_UsernameFilterGeneric()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Z)V");

  /// from: public void <init>(boolean appendInvalid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  LoginFilter_UsernameFilterGeneric.ctor1(bool appendInvalid)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [appendInvalid]).object);

  static final _id_isAllowed =
      jniAccessors.getMethodIDOf(_classRef, "isAllowed", "(C)Z");

  /// from: public boolean isAllowed(char c)
  bool isAllowed(int c) => jniAccessors.callMethodWithArgs(
      reference, _id_isAllowed, jni.JniType.booleanType, [c]).boolean;
}

/// from: android.text.LoginFilter$UsernameFilterGMail
///
/// This filter rejects characters in the user name that are not compatible with GMail
/// account creation. It prevents the user from entering user names with characters other than
/// [a-zA-Z0-9.].
class LoginFilter_UsernameFilterGMail extends LoginFilter {
  static final _classRef =
      jniAccessors.getClassOf("android/text/LoginFilter\$UsernameFilterGMail");
  LoginFilter_UsernameFilterGMail.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  LoginFilter_UsernameFilterGMail()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Z)V");

  /// from: public void <init>(boolean appendInvalid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  LoginFilter_UsernameFilterGMail.ctor1(bool appendInvalid)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [appendInvalid]).object);

  static final _id_isAllowed =
      jniAccessors.getMethodIDOf(_classRef, "isAllowed", "(C)Z");

  /// from: public boolean isAllowed(char c)
  bool isAllowed(int c) => jniAccessors.callMethodWithArgs(
      reference, _id_isAllowed, jni.JniType.booleanType, [c]).boolean;
}

/// from: android.text.LoginFilter$PasswordFilterGMail
///
/// This filter is compatible with GMail passwords which restricts characters to
/// the Latin-1 (ISO8859-1) char set.
class LoginFilter_PasswordFilterGMail extends LoginFilter {
  static final _classRef =
      jniAccessors.getClassOf("android/text/LoginFilter\$PasswordFilterGMail");
  LoginFilter_PasswordFilterGMail.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  LoginFilter_PasswordFilterGMail()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Z)V");

  /// from: public void <init>(boolean appendInvalid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  LoginFilter_PasswordFilterGMail.ctor1(bool appendInvalid)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [appendInvalid]).object);

  static final _id_isAllowed =
      jniAccessors.getMethodIDOf(_classRef, "isAllowed", "(C)Z");

  /// from: public boolean isAllowed(char c)
  bool isAllowed(int c) => jniAccessors.callMethodWithArgs(
      reference, _id_isAllowed, jni.JniType.booleanType, [c]).boolean;
}
