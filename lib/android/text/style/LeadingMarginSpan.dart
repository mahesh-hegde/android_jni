// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../graphics/Canvas.dart" as canvas_;

import "../../graphics/Paint.dart" as paint_;

import "../Layout.dart" as layout_;

import "../../os/Parcel.dart" as parcel_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.text.style.LeadingMarginSpan
///
/// A paragraph style affecting the leading margin. There can be multiple leading
/// margin spans on a single paragraph; they will be rendered in order, each
/// adding its margin to the ones before it. The leading margin is on the right
/// for lines in a right-to-left paragraph.
///
/// LeadingMarginSpans should be attached from the first character to the last
/// character of a single paragraph.
class LeadingMarginSpan extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/style/LeadingMarginSpan");
  LeadingMarginSpan.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getLeadingMargin =
      jniAccessors.getMethodIDOf(_classRef, "getLeadingMargin", "(Z)I");

  /// from: public abstract int getLeadingMargin(boolean first)
  ///
  /// Returns the amount by which to adjust the leading margin. Positive values
  /// move away from the leading edge of the paragraph, negative values move
  /// towards it.
  ///@param first true if the request is for the first line of a paragraph,
  /// false for subsequent lines
  ///@return the offset for the margin.
  int getLeadingMargin(bool first) => jniAccessors.callMethodWithArgs(
      reference, _id_getLeadingMargin, jni.JniType.intType, [first]).integer;

  static final _id_drawLeadingMargin = jniAccessors.getMethodIDOf(
      _classRef,
      "drawLeadingMargin",
      "(Landroid/graphics/Canvas;Landroid/graphics/Paint;IIIIILjava/lang/CharSequence;IIZLandroid/text/Layout;)V");

  /// from: public abstract void drawLeadingMargin(android.graphics.Canvas c, android.graphics.Paint p, int x, int dir, int top, int baseline, int bottom, java.lang.CharSequence text, int start, int end, boolean first, android.text.Layout layout)
  ///
  /// Renders the leading margin.  This is called before the margin has been
  /// adjusted by the value returned by \#getLeadingMargin(boolean).
  ///@param c the canvas
  ///@param p the paint. The this should be left unchanged on exit.
  ///@param x the current position of the margin
  ///@param dir the base direction of the paragraph; if negative, the margin
  /// is to the right of the text, otherwise it is to the left.
  ///@param top the top of the line
  ///@param baseline the baseline of the line
  ///@param bottom the bottom of the line
  ///@param text the text
  ///@param start the start of the line
  ///@param end the end of the line
  ///@param first true if this is the first line of its paragraph
  ///@param layout the layout containing this line
  void drawLeadingMargin(
          canvas_.Canvas c,
          paint_.Paint p,
          int x,
          int dir,
          int top,
          int baseline,
          int bottom,
          jni.JniObject text,
          int start,
          int end,
          bool first,
          layout_.Layout layout) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_drawLeadingMargin, jni.JniType.voidType, [
        c.reference,
        p.reference,
        x,
        dir,
        top,
        baseline,
        bottom,
        text.reference,
        start,
        end,
        first,
        layout.reference
      ]).check();
}

/// from: android.text.style.LeadingMarginSpan$Standard
///
/// The standard implementation of LeadingMarginSpan, which adjusts the
/// margin but does not do any rendering.
class LeadingMarginSpan_Standard extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/style/LeadingMarginSpan\$Standard");
  LeadingMarginSpan_Standard.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(II)V");

  /// from: public void <init>(int first, int rest)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor taking separate indents for the first and subsequent
  /// lines.
  ///@param first the indent for the first line of the paragraph
  ///@param rest the indent for the remaining lines of the paragraph
  LeadingMarginSpan_Standard(int first, int rest)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [first, rest]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int every)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor taking an indent for all lines.
  ///@param every the indent of each line
  LeadingMarginSpan_Standard.ctor1(int every)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [every]).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Parcel;)V");

  /// from: public void <init>(android.os.Parcel src)
  /// The returned object must be deleted after use, by calling the `delete` method.
  LeadingMarginSpan_Standard.ctor2(parcel_.Parcel src)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [src.reference]).object);

  static final _id_getSpanTypeId =
      jniAccessors.getMethodIDOf(_classRef, "getSpanTypeId", "()I");

  /// from: public int getSpanTypeId()
  int getSpanTypeId() => jniAccessors.callMethodWithArgs(
      reference, _id_getSpanTypeId, jni.JniType.intType, []).integer;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_getLeadingMargin =
      jniAccessors.getMethodIDOf(_classRef, "getLeadingMargin", "(Z)I");

  /// from: public int getLeadingMargin(boolean first)
  int getLeadingMargin(bool first) => jniAccessors.callMethodWithArgs(
      reference, _id_getLeadingMargin, jni.JniType.intType, [first]).integer;

  static final _id_drawLeadingMargin = jniAccessors.getMethodIDOf(
      _classRef,
      "drawLeadingMargin",
      "(Landroid/graphics/Canvas;Landroid/graphics/Paint;IIIIILjava/lang/CharSequence;IIZLandroid/text/Layout;)V");

  /// from: public void drawLeadingMargin(android.graphics.Canvas c, android.graphics.Paint p, int x, int dir, int top, int baseline, int bottom, java.lang.CharSequence text, int start, int end, boolean first, android.text.Layout layout)
  void drawLeadingMargin(
          canvas_.Canvas c,
          paint_.Paint p,
          int x,
          int dir,
          int top,
          int baseline,
          int bottom,
          jni.JniObject text,
          int start,
          int end,
          bool first,
          layout_.Layout layout) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_drawLeadingMargin, jni.JniType.voidType, [
        c.reference,
        p.reference,
        x,
        dir,
        top,
        baseline,
        bottom,
        text.reference,
        start,
        end,
        first,
        layout.reference
      ]).check();
}

/// from: android.text.style.LeadingMarginSpan$LeadingMarginSpan2
///
/// An extended version of LeadingMarginSpan, which allows the
/// implementor to specify the number of lines of the paragraph to which
/// this object is attached that the "first line of paragraph" margin width
/// will be applied to.
///
/// There should only be one LeadingMarginSpan2 per paragraph. The leading
/// margin line count affects all LeadingMarginSpans in the paragraph,
/// adjusting the number of lines to which the first line margin is applied.
///
/// As with LeadingMarginSpans, LeadingMarginSpan2s should be attached from
/// the beginning to the end of a paragraph.
class LeadingMarginSpan_LeadingMarginSpan2 extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/text/style/LeadingMarginSpan\$LeadingMarginSpan2");
  LeadingMarginSpan_LeadingMarginSpan2.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_getLeadingMarginLineCount =
      jniAccessors.getMethodIDOf(_classRef, "getLeadingMarginLineCount", "()I");

  /// from: public abstract int getLeadingMarginLineCount()
  ///
  /// Returns the number of lines of the paragraph to which this object is
  /// attached that the "first line" margin will apply to.
  int getLeadingMarginLineCount() => jniAccessors.callMethodWithArgs(reference,
      _id_getLeadingMarginLineCount, jni.JniType.intType, []).integer;
}
