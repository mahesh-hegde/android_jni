// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../Spannable.dart" as spannable_;

import "../../widget/TextView.dart" as textview_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.text.util.Linkify
///
/// Linkify take a piece of text and a regular expression and turns all of the
///  regex matches in the text into clickable links.  This is particularly
///  useful for matching things like email addresses, web URLs, etc. and making
///  them actionable.
///
///  Alone with the pattern that is to be matched, a URL scheme prefix is also
///  required.  Any pattern match that does not begin with the supplied scheme
///  will have the scheme prepended to the matched text when the clickable URL
///  is created.  For instance, if you are matching web URLs you would supply
///  the scheme <code>http://</code>. If the pattern matches example.com, which
///  does not have a URL scheme prefix, the supplied scheme will be prepended to
///  create <code>http://example.com</code> when the clickable URL link is
///  created.
class Linkify extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/text/util/Linkify");
  Linkify.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ALL
  ///
  /// Bit mask indicating that all available patterns should be matched in
  ///  methods that take an options mask
  ///  <strong>Note:</strong>
  /// \#MAP_ADDRESSES is deprecated.
  ///  Use android.view.textclassifier.TextClassifier\#generateLinks(TextLinks.Request)
  ///  instead and avoid it even when targeting API levels where no alternative is available.
  static const ALL = 15;

  /// from: static public final int EMAIL_ADDRESSES
  ///
  /// Bit field indicating that email addresses should be matched in methods
  ///  that take an options mask
  static const EMAIL_ADDRESSES = 2;

  /// from: static public final int MAP_ADDRESSES
  ///
  /// Bit field indicating that street addresses should be matched in methods that
  ///  take an options mask. Note that this uses the
  ///  android.webkit.WebView\#findAddress(String) findAddress() method in
  ///  android.webkit.WebView for finding addresses, which has various
  ///  limitations and has been deprecated.
  ///@deprecated use android.view.textclassifier.TextClassifier\#generateLinks(
  ///  TextLinks.Request) instead and avoid it even when targeting API levels where no alternative
  ///  is available.
  static const MAP_ADDRESSES = 8;

  /// from: static public final int PHONE_NUMBERS
  ///
  /// Bit field indicating that phone numbers should be matched in methods that
  ///  take an options mask
  static const PHONE_NUMBERS = 4;

  /// from: static public final int WEB_URLS
  ///
  /// Bit field indicating that web URLs should be matched in methods that
  ///  take an options mask
  static const WEB_URLS = 1;

  static final _id_sPhoneNumberMatchFilter = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "sPhoneNumberMatchFilter",
      "Landroid/text/util/Linkify\$MatchFilter;");

  /// from: static public final android.text.util.Linkify.MatchFilter sPhoneNumberMatchFilter
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Filters out URL matches that don't have enough digits to be a
  ///  phone number.
  static Linkify_MatchFilter get sPhoneNumberMatchFilter =>
      Linkify_MatchFilter.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_sPhoneNumberMatchFilter, jni.JniType.objectType)
          .object);

  static final _id_sPhoneNumberTransformFilter =
      jniAccessors.getStaticFieldIDOf(_classRef, "sPhoneNumberTransformFilter",
          "Landroid/text/util/Linkify\$TransformFilter;");

  /// from: static public final android.text.util.Linkify.TransformFilter sPhoneNumberTransformFilter
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Transforms matched phone number text into something suitable
  ///  to be used in a tel: URL.  It does this by removing everything
  ///  but the digits and plus signs.  For instance:
  ///  &apos;+1 (919) 555-1212&apos;
  ///  becomes &apos;+19195551212&apos;
  static Linkify_TransformFilter get sPhoneNumberTransformFilter =>
      Linkify_TransformFilter.fromRef(jniAccessors
          .getStaticField(_classRef, _id_sPhoneNumberTransformFilter,
              jni.JniType.objectType)
          .object);

  static final _id_sUrlMatchFilter = jniAccessors.getStaticFieldIDOf(
      _classRef, "sUrlMatchFilter", "Landroid/text/util/Linkify\$MatchFilter;");

  /// from: static public final android.text.util.Linkify.MatchFilter sUrlMatchFilter
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Filters out web URL matches that occur after an at-sign (@).  This is
  ///  to prevent turning the domain name in an email address into a web link.
  static Linkify_MatchFilter get sUrlMatchFilter =>
      Linkify_MatchFilter.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_sUrlMatchFilter, jni.JniType.objectType)
          .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Linkify()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_addLinks = jniAccessors.getStaticMethodIDOf(
      _classRef, "addLinks", "(Landroid/text/Spannable;I)Z");

  /// from: static public final boolean addLinks(android.text.Spannable text, int mask)
  ///
  /// Scans the text of the provided Spannable and turns all occurrences
  ///  of the link types indicated in the mask into clickable links.
  ///  If the mask is nonzero, it also removes any existing URLSpans
  ///  attached to the Spannable, to avoid problems if you call it
  ///  repeatedly on the same text.
  ///@param text Spannable whose text is to be marked-up with links
  ///
  /// This value must never be {@code null}.
  ///@param mask Mask to define which kinds of links will be searched.
  ///
  ///
  /// Value is either <code>0</code> or a combination of android.text.util.Linkify\#WEB_URLS, android.text.util.Linkify\#EMAIL_ADDRESSES, android.text.util.Linkify\#PHONE_NUMBERS, android.text.util.Linkify\#MAP_ADDRESSES, and android.text.util.Linkify\#ALL
  ///@return True if at least one link is found and applied.
  static bool addLinks(spannable_.Spannable text, int mask) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_addLinks,
          jni.JniType.booleanType, [text.reference, mask]).boolean;

  static final _id_addLinks1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "addLinks", "(Landroid/widget/TextView;I)Z");

  /// from: static public final boolean addLinks(android.widget.TextView text, int mask)
  ///
  /// Scans the text of the provided TextView and turns all occurrences of
  ///  the link types indicated in the mask into clickable links.  If matches
  ///  are found the movement method for the TextView is set to
  ///  LinkMovementMethod.
  ///@param text TextView whose text is to be marked-up with links
  ///
  /// This value must never be {@code null}.
  ///@param mask Mask to define which kinds of links will be searched.
  ///
  ///
  /// Value is either <code>0</code> or a combination of android.text.util.Linkify\#WEB_URLS, android.text.util.Linkify\#EMAIL_ADDRESSES, android.text.util.Linkify\#PHONE_NUMBERS, android.text.util.Linkify\#MAP_ADDRESSES, and android.text.util.Linkify\#ALL
  ///@return True if at least one link is found and applied.
  static bool addLinks1(textview_.TextView text, int mask) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_addLinks1,
          jni.JniType.booleanType, [text.reference, mask]).boolean;

  static final _id_addLinks2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "addLinks",
      "(Landroid/widget/TextView;Ljava/util/regex/Pattern;Ljava/lang/String;)V");

  /// from: static public final void addLinks(android.widget.TextView text, java.util.regex.Pattern pattern, java.lang.String scheme)
  ///
  /// Applies a regex to the text of a TextView turning the matches into
  ///  links.  If links are found then UrlSpans are applied to the link
  ///  text match areas, and the movement method for the text is changed
  ///  to LinkMovementMethod.
  ///@param text TextView whose text is to be marked-up with links
  ///
  /// This value must never be {@code null}.
  ///@param pattern Regex pattern to be used for finding links
  ///
  /// This value must never be {@code null}.
  ///@param scheme URL scheme string (eg <code>http://</code>) to be
  ///                      prepended to the links that do not start with this scheme.
  ///
  /// This value may be {@code null}.
  static void addLinks2(textview_.TextView text, jni.JniObject pattern,
          jni.JniString scheme) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_addLinks2,
          jni.JniType.voidType,
          [text.reference, pattern.reference, scheme.reference]).check();

  static final _id_addLinks3 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "addLinks",
      "(Landroid/widget/TextView;Ljava/util/regex/Pattern;Ljava/lang/String;Landroid/text/util/Linkify\$MatchFilter;Landroid/text/util/Linkify\$TransformFilter;)V");

  /// from: static public final void addLinks(android.widget.TextView text, java.util.regex.Pattern pattern, java.lang.String scheme, android.text.util.Linkify.MatchFilter matchFilter, android.text.util.Linkify.TransformFilter transformFilter)
  ///
  /// Applies a regex to the text of a TextView turning the matches into
  ///  links.  If links are found then UrlSpans are applied to the link
  ///  text match areas, and the movement method for the text is changed
  ///  to LinkMovementMethod.
  ///@param text TextView whose text is to be marked-up with links
  ///
  /// This value must never be {@code null}.
  ///@param pattern Regex pattern to be used for finding links
  ///
  /// This value must never be {@code null}.
  ///@param scheme URL scheme string (eg <code>http://</code>) to be
  ///                      prepended to the links that do not start with this scheme.
  ///
  /// This value may be {@code null}.
  ///@param matchFilter The filter that is used to allow the client code
  ///                      additional control over which pattern matches are
  ///                      to be converted into links.
  ///
  /// This value may be {@code null}.
  ///@param transformFilter This value may be {@code null}.
  static void addLinks3(
          textview_.TextView text,
          jni.JniObject pattern,
          jni.JniString scheme,
          Linkify_MatchFilter matchFilter,
          Linkify_TransformFilter transformFilter) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_addLinks3, jni.JniType.voidType, [
        text.reference,
        pattern.reference,
        scheme.reference,
        matchFilter.reference,
        transformFilter.reference
      ]).check();

  static final _id_addLinks4 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "addLinks",
      "(Landroid/widget/TextView;Ljava/util/regex/Pattern;Ljava/lang/String;[Ljava/lang/String;Landroid/text/util/Linkify\$MatchFilter;Landroid/text/util/Linkify\$TransformFilter;)V");

  /// from: static public final void addLinks(android.widget.TextView text, java.util.regex.Pattern pattern, java.lang.String defaultScheme, java.lang.String[] schemes, android.text.util.Linkify.MatchFilter matchFilter, android.text.util.Linkify.TransformFilter transformFilter)
  ///
  /// Applies a regex to the text of a TextView turning the matches into
  ///  links.  If links are found then UrlSpans are applied to the link
  ///  text match areas, and the movement method for the text is changed
  ///  to LinkMovementMethod.
  ///@param text TextView whose text is to be marked-up with links.
  ///
  /// This value must never be {@code null}.
  ///@param pattern Regex pattern to be used for finding links.
  ///
  /// This value must never be {@code null}.
  ///@param defaultScheme The default scheme to be prepended to links if the link does not
  ///                       start with one of the <code>schemes</code> given.
  ///
  /// This value may be {@code null}.
  ///@param schemes Array of schemes (eg <code>http://</code>) to check if the link found
  ///                 contains a scheme. Passing a null or empty value means prepend defaultScheme
  ///                 to all links.
  ///
  /// This value may be {@code null}.
  ///@param matchFilter The filter that is used to allow the client code additional control
  ///                      over which pattern matches are to be converted into links.
  ///
  /// This value may be {@code null}.
  ///@param transformFilter Filter to allow the client code to update the link found.
  ///
  /// This value may be {@code null}.
  static void addLinks4(
          textview_.TextView text,
          jni.JniObject pattern,
          jni.JniString defaultScheme,
          jni.JniObject schemes,
          Linkify_MatchFilter matchFilter,
          Linkify_TransformFilter transformFilter) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_addLinks4, jni.JniType.voidType, [
        text.reference,
        pattern.reference,
        defaultScheme.reference,
        schemes.reference,
        matchFilter.reference,
        transformFilter.reference
      ]).check();

  static final _id_addLinks5 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "addLinks",
      "(Landroid/text/Spannable;Ljava/util/regex/Pattern;Ljava/lang/String;)Z");

  /// from: static public final boolean addLinks(android.text.Spannable text, java.util.regex.Pattern pattern, java.lang.String scheme)
  ///
  /// Applies a regex to a Spannable turning the matches into
  ///  links.
  ///@param text Spannable whose text is to be marked-up with links
  ///
  /// This value must never be {@code null}.
  ///@param pattern Regex pattern to be used for finding links
  ///
  /// This value must never be {@code null}.
  ///@param scheme URL scheme string (eg <code>http://</code>) to be
  ///                      prepended to the links that do not start with this scheme.
  ///
  /// This value may be {@code null}.
  static bool addLinks5(spannable_.Spannable text, jni.JniObject pattern,
          jni.JniString scheme) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_addLinks5,
          jni.JniType.booleanType,
          [text.reference, pattern.reference, scheme.reference]).boolean;

  static final _id_addLinks6 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "addLinks",
      "(Landroid/text/Spannable;Ljava/util/regex/Pattern;Ljava/lang/String;Landroid/text/util/Linkify\$MatchFilter;Landroid/text/util/Linkify\$TransformFilter;)Z");

  /// from: static public final boolean addLinks(android.text.Spannable spannable, java.util.regex.Pattern pattern, java.lang.String scheme, android.text.util.Linkify.MatchFilter matchFilter, android.text.util.Linkify.TransformFilter transformFilter)
  ///
  /// Applies a regex to a Spannable turning the matches into
  /// links.
  ///@param spannable Spannable whose text is to be marked-up with links
  /// This value must never be {@code null}.
  ///@param pattern Regex pattern to be used for finding links
  /// This value must never be {@code null}.
  ///@param scheme URL scheme string (eg <code>http://</code>) to be
  ///                     prepended to the links that do not start with this scheme.
  /// This value may be {@code null}.
  ///@param matchFilter The filter that is used to allow the client code
  ///                     additional control over which pattern matches are
  ///                     to be converted into links.
  /// This value may be {@code null}.
  ///@param transformFilter Filter to allow the client code to update the link found.
  ///
  /// This value may be {@code null}.
  ///@return True if at least one link is found and applied.
  static bool addLinks6(
          spannable_.Spannable spannable,
          jni.JniObject pattern,
          jni.JniString scheme,
          Linkify_MatchFilter matchFilter,
          Linkify_TransformFilter transformFilter) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_addLinks6, jni.JniType.booleanType, [
        spannable.reference,
        pattern.reference,
        scheme.reference,
        matchFilter.reference,
        transformFilter.reference
      ]).boolean;

  static final _id_addLinks7 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "addLinks",
      "(Landroid/text/Spannable;Ljava/util/regex/Pattern;Ljava/lang/String;[Ljava/lang/String;Landroid/text/util/Linkify\$MatchFilter;Landroid/text/util/Linkify\$TransformFilter;)Z");

  /// from: static public final boolean addLinks(android.text.Spannable spannable, java.util.regex.Pattern pattern, java.lang.String defaultScheme, java.lang.String[] schemes, android.text.util.Linkify.MatchFilter matchFilter, android.text.util.Linkify.TransformFilter transformFilter)
  ///
  /// Applies a regex to a Spannable turning the matches into links.
  ///@param spannable Spannable whose text is to be marked-up with links.
  /// This value must never be {@code null}.
  ///@param pattern Regex pattern to be used for finding links.
  /// This value must never be {@code null}.
  ///@param defaultScheme The default scheme to be prepended to links if the link does not
  ///                      start with one of the <code>schemes</code> given.
  /// This value may be {@code null}.
  ///@param schemes Array of schemes (eg <code>http://</code>) to check if the link found
  ///                contains a scheme. Passing a null or empty value means prepend defaultScheme
  ///                to all links.
  /// This value may be {@code null}.
  ///@param matchFilter The filter that is used to allow the client code additional control
  ///                     over which pattern matches are to be converted into links.
  /// This value may be {@code null}.
  ///@param transformFilter Filter to allow the client code to update the link found.
  ///
  /// This value may be {@code null}.
  ///@return True if at least one link is found and applied.
  static bool addLinks7(
          spannable_.Spannable spannable,
          jni.JniObject pattern,
          jni.JniString defaultScheme,
          jni.JniObject schemes,
          Linkify_MatchFilter matchFilter,
          Linkify_TransformFilter transformFilter) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_addLinks7, jni.JniType.booleanType, [
        spannable.reference,
        pattern.reference,
        defaultScheme.reference,
        schemes.reference,
        matchFilter.reference,
        transformFilter.reference
      ]).boolean;
}

/// from: android.text.util.Linkify$TransformFilter
///
/// TransformFilter enables client code to have more control over
///  how matched patterns are represented as URLs.
///
///  For example:  when converting a phone number such as (919)  555-1212
///  into a tel: URL the parentheses, white space, and hyphen need to be
///  removed to produce tel:9195551212.
class Linkify_TransformFilter extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/util/Linkify\$TransformFilter");
  Linkify_TransformFilter.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_transformUrl = jniAccessors.getMethodIDOf(
      _classRef,
      "transformUrl",
      "(Ljava/util/regex/Matcher;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public abstract java.lang.String transformUrl(java.util.regex.Matcher match, java.lang.String url)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Examines the matched text and either passes it through or uses the
  ///  data in the Matcher state to produce a replacement.
  ///@param match The regex matcher state that found this URL text
  ///@param url The text that was matched
  ///@return The transformed form of the URL
  jni.JniString transformUrl(jni.JniObject match, jni.JniString url) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_transformUrl,
          jni.JniType.objectType,
          [match.reference, url.reference]).object);
}

/// from: android.text.util.Linkify$MatchFilter
///
/// MatchFilter enables client code to have more control over
///  what is allowed to match and become a link, and what is not.
///
///  For example:  when matching web URLs you would like things like
///  http://www.example.com to match, as well as just example.com itelf.
///  However, you would not want to match against the domain in
///  support@example.com.  So, when matching against a web URL pattern you
///  might also include a MatchFilter that disallows the match if it is
///  immediately preceded by an at-sign (@).
class Linkify_MatchFilter extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/util/Linkify\$MatchFilter");
  Linkify_MatchFilter.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_acceptMatch = jniAccessors.getMethodIDOf(
      _classRef, "acceptMatch", "(Ljava/lang/CharSequence;II)Z");

  /// from: public abstract boolean acceptMatch(java.lang.CharSequence s, int start, int end)
  ///
  /// Examines the character span matched by the pattern and determines
  ///  if the match should be turned into an actionable link.
  ///@param s The body of text against which the pattern
  ///                  was matched
  ///@param start The index of the first character in s that was
  ///                  matched by the pattern - inclusive
  ///@param end The index of the last character in s that was
  ///                  matched - exclusive
  ///@return Whether this match should be turned into a link
  bool acceptMatch(jni.JniObject s, int start, int end) =>
      jniAccessors.callMethodWithArgs(reference, _id_acceptMatch,
          jni.JniType.booleanType, [s.reference, start, end]).boolean;
}
