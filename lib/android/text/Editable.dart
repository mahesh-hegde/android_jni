// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.text.Editable
///
/// This is the interface for text whose content and markup
/// can be changed (as opposed
/// to immutable text like Strings).  If you make a DynamicLayout
/// of an Editable, the layout will be reflowed as the text is changed.
class Editable extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/text/Editable");
  Editable.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_replace = jniAccessors.getMethodIDOf(_classRef, "replace",
      "(IILjava/lang/CharSequence;II)Landroid/text/Editable;");

  /// from: public abstract android.text.Editable replace(int st, int en, java.lang.CharSequence source, int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Replaces the specified range (<code>st&hellip;en</code>) of text in this
  /// Editable with a copy of the slice <code>start&hellip;end</code> from
  /// <code>source</code>.  The destination slice may be empty, in which case
  /// the operation is an insertion, or the source slice may be empty,
  /// in which case the operation is a deletion.
  ///
  /// Before the change is committed, each filter that was set with
  /// \#setFilters is given the opportunity to modify the
  /// <code>source</code> text.
  ///
  /// If <code>source</code>
  /// is Spanned, the spans from it are preserved into the Editable.
  /// Existing spans within the Editable that entirely cover the replaced
  /// range are retained, but any that were strictly within the range
  /// that was replaced are removed. If the <code>source</code> contains a span
  /// with Spanned\#SPAN_PARAGRAPH flag, and it does not satisfy the
  /// paragraph boundary constraint, it is not retained. As a special case, the
  /// cursor position is preserved even when the entire range where it is located
  /// is replaced.
  ///@return a reference to this object.
  ///@see Spanned\#SPAN_PARAGRAPH
  Editable replace(int st, int en, jni.JniObject source, int start, int end) =>
      Editable.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_replace,
          jni.JniType.objectType,
          [st, en, source.reference, start, end]).object);

  static final _id_replace1 = jniAccessors.getMethodIDOf(_classRef, "replace",
      "(IILjava/lang/CharSequence;)Landroid/text/Editable;");

  /// from: public abstract android.text.Editable replace(int st, int en, java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for replace(st, en, text, 0, text.length())
  ///@see \#replace(int, int, CharSequence, int, int)
  Editable replace1(int st, int en, jni.JniObject text) =>
      Editable.fromRef(jniAccessors.callMethodWithArgs(reference, _id_replace1,
          jni.JniType.objectType, [st, en, text.reference]).object);

  static final _id_insert = jniAccessors.getMethodIDOf(_classRef, "insert",
      "(ILjava/lang/CharSequence;II)Landroid/text/Editable;");

  /// from: public abstract android.text.Editable insert(int where, java.lang.CharSequence text, int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for replace(where, where, text, start, end)
  ///@see \#replace(int, int, CharSequence, int, int)
  Editable insert(int where, jni.JniObject text, int start, int end) =>
      Editable.fromRef(jniAccessors.callMethodWithArgs(reference, _id_insert,
          jni.JniType.objectType, [where, text.reference, start, end]).object);

  static final _id_insert1 = jniAccessors.getMethodIDOf(_classRef, "insert",
      "(ILjava/lang/CharSequence;)Landroid/text/Editable;");

  /// from: public abstract android.text.Editable insert(int where, java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for replace(where, where, text, 0, text.length());
  ///@see \#replace(int, int, CharSequence, int, int)
  Editable insert1(int where, jni.JniObject text) =>
      Editable.fromRef(jniAccessors.callMethodWithArgs(reference, _id_insert1,
          jni.JniType.objectType, [where, text.reference]).object);

  static final _id_delete1 = jniAccessors.getMethodIDOf(
      _classRef, "delete", "(II)Landroid/text/Editable;");

  /// from: public abstract android.text.Editable delete(int st, int en)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for replace(st, en, "", 0, 0)
  ///@see \#replace(int, int, CharSequence, int, int)
  Editable delete1(int st, int en) =>
      Editable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_delete1, jni.JniType.objectType, [st, en]).object);

  static final _id_append = jniAccessors.getMethodIDOf(
      _classRef, "append", "(Ljava/lang/CharSequence;)Landroid/text/Editable;");

  /// from: public abstract android.text.Editable append(java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for replace(length(), length(), text, 0, text.length())
  ///@see \#replace(int, int, CharSequence, int, int)
  Editable append(jni.JniObject text) =>
      Editable.fromRef(jniAccessors.callMethodWithArgs(reference, _id_append,
          jni.JniType.objectType, [text.reference]).object);

  static final _id_append1 = jniAccessors.getMethodIDOf(_classRef, "append",
      "(Ljava/lang/CharSequence;II)Landroid/text/Editable;");

  /// from: public abstract android.text.Editable append(java.lang.CharSequence text, int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for replace(length(), length(), text, start, end)
  ///@see \#replace(int, int, CharSequence, int, int)
  Editable append1(jni.JniObject text, int start, int end) =>
      Editable.fromRef(jniAccessors.callMethodWithArgs(reference, _id_append1,
          jni.JniType.objectType, [text.reference, start, end]).object);

  static final _id_append2 = jniAccessors.getMethodIDOf(
      _classRef, "append", "(C)Landroid/text/Editable;");

  /// from: public abstract android.text.Editable append(char text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for append(String.valueOf(text)).
  ///@see \#replace(int, int, CharSequence, int, int)
  Editable append2(int text) =>
      Editable.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_append2, jni.JniType.objectType, [text]).object);

  static final _id_clear =
      jniAccessors.getMethodIDOf(_classRef, "clear", "()V");

  /// from: public abstract void clear()
  ///
  /// Convenience for replace(0, length(), "", 0, 0).
  /// Note that this clears the text, not the spans;
  /// use \#clearSpans if you need that.
  ///@see \#replace(int, int, CharSequence, int, int)
  void clear() => jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniType.voidType, []).check();

  static final _id_clearSpans =
      jniAccessors.getMethodIDOf(_classRef, "clearSpans", "()V");

  /// from: public abstract void clearSpans()
  ///
  /// Removes all spans from the Editable, as if by calling
  /// \#removeSpan on each of them.
  void clearSpans() => jniAccessors.callMethodWithArgs(
      reference, _id_clearSpans, jni.JniType.voidType, []).check();

  static final _id_setFilters = jniAccessors.getMethodIDOf(
      _classRef, "setFilters", "([Landroid/text/InputFilter;)V");

  /// from: public abstract void setFilters(android.text.InputFilter[] filters)
  ///
  /// Sets the series of filters that will be called in succession
  /// whenever the text of this Editable is changed, each of which has
  /// the opportunity to limit or transform the text that is being inserted.
  void setFilters(jni.JniObject filters) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFilters,
      jni.JniType.voidType,
      [filters.reference]).check();

  static final _id_getFilters = jniAccessors.getMethodIDOf(
      _classRef, "getFilters", "()[Landroid/text/InputFilter;");

  /// from: public abstract android.text.InputFilter[] getFilters()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the array of input filters that are currently applied
  /// to changes to this Editable.
  jni.JniObject getFilters() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFilters, jni.JniType.objectType, []).object);
}

/// from: android.text.Editable$Factory
///
/// Factory used by TextView to create new Editable Editables. You can subclass
/// it to provide something other than SpannableStringBuilder.
///@see android.widget.TextView\#setEditableFactory(Factory)
class Editable_Factory extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/Editable\$Factory");
  Editable_Factory.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Editable_Factory()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getInstance", "()Landroid/text/Editable\$Factory;");

  /// from: static public android.text.Editable.Factory getInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the standard Editable Factory.
  static Editable_Factory getInstance() =>
      Editable_Factory.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getInstance, jni.JniType.objectType, []).object);

  static final _id_newEditable = jniAccessors.getMethodIDOf(_classRef,
      "newEditable", "(Ljava/lang/CharSequence;)Landroid/text/Editable;");

  /// from: public android.text.Editable newEditable(java.lang.CharSequence source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a new SpannedStringBuilder from the specified
  /// CharSequence.  You can override this to provide
  /// a different kind of Spanned.
  Editable newEditable(jni.JniObject source) =>
      Editable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_newEditable, jni.JniType.objectType, [source.reference]).object);
}
