// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Spanned.dart" as spanned_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.text.InputFilter
///
/// InputFilters can be attached to Editables to constrain the
/// changes that can be made to them.
class InputFilter extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/text/InputFilter");
  InputFilter.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_filter = jniAccessors.getMethodIDOf(_classRef, "filter",
      "(Ljava/lang/CharSequence;IILandroid/text/Spanned;II)Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence filter(java.lang.CharSequence source, int start, int end, android.text.Spanned dest, int dstart, int dend)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method is called when the buffer is going to replace the
  /// range <code>dstart &hellip; dend</code> of <code>dest</code>
  /// with the new text from the range <code>start &hellip; end</code>
  /// of <code>source</code>.  Return the CharSequence that you would
  /// like to have placed there instead, including an empty string
  /// if appropriate, or <code>null</code> to accept the original
  /// replacement.  Be careful to not to reject 0-length replacements,
  /// as this is what happens when you delete text.  Also beware that
  /// you should not attempt to make any changes to <code>dest</code>
  /// from this method; you may only examine it for context.
  ///
  /// Note: If <var>source</var> is an instance of Spanned or
  /// Spannable, the span objects in the <var>source</var> should be
  /// copied into the filtered result (i.e. the non-null return value).
  /// TextUtils\#copySpansFrom can be used for convenience if the
  /// span boundary indices would be remaining identical relative to the source.
  jni.JniObject filter(jni.JniObject source, int start, int end,
          spanned_.Spanned dest, int dstart, int dend) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_filter,
          jni.JniType.objectType,
          [source.reference, start, end, dest.reference, dstart, dend]).object);
}

/// from: android.text.InputFilter$LengthFilter
///
/// This filter will constrain edits not to make the length of the text
/// greater than the specified length.
class InputFilter_LengthFilter extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/InputFilter\$LengthFilter");
  InputFilter_LengthFilter.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int max)
  /// The returned object must be deleted after use, by calling the `delete` method.
  InputFilter_LengthFilter(int max)
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [max]).object);

  static final _id_filter = jniAccessors.getMethodIDOf(_classRef, "filter",
      "(Ljava/lang/CharSequence;IILandroid/text/Spanned;II)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence filter(java.lang.CharSequence source, int start, int end, android.text.Spanned dest, int dstart, int dend)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject filter(jni.JniObject source, int start, int end,
          spanned_.Spanned dest, int dstart, int dend) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_filter,
          jni.JniType.objectType,
          [source.reference, start, end, dest.reference, dstart, dend]).object);

  static final _id_getMax =
      jniAccessors.getMethodIDOf(_classRef, "getMax", "()I");

  /// from: public int getMax()
  ///
  /// @return the maximum length enforced by this input filter
  int getMax() => jniAccessors.callMethodWithArgs(
      reference, _id_getMax, jni.JniType.intType, []).integer;
}

/// from: android.text.InputFilter$AllCaps
///
/// This filter will capitalize all the lowercase and titlecase letters that are added
/// through edits. (Note that if there are no lowercase or titlecase letters in the input, the
/// text would not be transformed, even if the result of capitalization of the string is
/// different from the string.)
class InputFilter_AllCaps extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/InputFilter\$AllCaps");
  InputFilter_AllCaps.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  InputFilter_AllCaps()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/util/Locale;)V");

  /// from: public void <init>(java.util.Locale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a locale-specific AllCaps filter, to make sure capitalization rules of that
  /// locale are used for transforming the sequence.
  ///@param locale This value must never be {@code null}.
  InputFilter_AllCaps.ctor1(jni.JniObject locale)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [locale.reference]).object);

  static final _id_filter = jniAccessors.getMethodIDOf(_classRef, "filter",
      "(Ljava/lang/CharSequence;IILandroid/text/Spanned;II)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence filter(java.lang.CharSequence source, int start, int end, android.text.Spanned dest, int dstart, int dend)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject filter(jni.JniObject source, int start, int end,
          spanned_.Spanned dest, int dstart, int dend) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_filter,
          jni.JniType.objectType,
          [source.reference, start, end, dest.reference, dstart, dend]).object);
}
