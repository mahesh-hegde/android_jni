// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcelable.dart" as parcelable_;

import "../os/Parcel.dart" as parcel_;

import "../util/Printer.dart" as printer_;

import "Spanned.dart" as spanned_;

import "Spannable.dart" as spannable_;

import "TextPaint.dart" as textpaint_;

import "../content/Context.dart" as context_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.text.TextUtils
class TextUtils extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/text/TextUtils");
  TextUtils.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CAP_MODE_CHARACTERS
  ///
  /// Capitalization mode for \#getCapsMode: capitalize all
  /// characters.  This value is explicitly defined to be the same as
  /// InputType\#TYPE_TEXT_FLAG_CAP_CHARACTERS.
  static const CAP_MODE_CHARACTERS = 4096;

  /// from: static public final int CAP_MODE_SENTENCES
  ///
  /// Capitalization mode for \#getCapsMode: capitalize the first
  /// character of each sentence.  This value is explicitly defined to be the same as
  /// InputType\#TYPE_TEXT_FLAG_CAP_SENTENCES.
  static const CAP_MODE_SENTENCES = 16384;

  /// from: static public final int CAP_MODE_WORDS
  ///
  /// Capitalization mode for \#getCapsMode: capitalize the first
  /// character of all words.  This value is explicitly defined to be the same as
  /// InputType\#TYPE_TEXT_FLAG_CAP_WORDS.
  static const CAP_MODE_WORDS = 8192;

  static final _id_CHAR_SEQUENCE_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CHAR_SEQUENCE_CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<java.lang.CharSequence> CHAR_SEQUENCE_CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CHAR_SEQUENCE_CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_CHAR_SEQUENCE_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_getChars = jniAccessors.getStaticMethodIDOf(
      _classRef, "getChars", "(Ljava/lang/CharSequence;II[CI)V");

  /// from: static public void getChars(java.lang.CharSequence s, int start, int end, char[] dest, int destoff)
  static void getChars(jni.JniObject s, int start, int end, jni.JniObject dest,
          int destoff) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getChars,
          jni.JniType.voidType,
          [s.reference, start, end, dest.reference, destoff]).check();

  static final _id_indexOf = jniAccessors.getStaticMethodIDOf(
      _classRef, "indexOf", "(Ljava/lang/CharSequence;C)I");

  /// from: static public int indexOf(java.lang.CharSequence s, char ch)
  static int indexOf(jni.JniObject s, int ch) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_indexOf,
          jni.JniType.intType, [s.reference, ch]).integer;

  static final _id_indexOf1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "indexOf", "(Ljava/lang/CharSequence;CI)I");

  /// from: static public int indexOf(java.lang.CharSequence s, char ch, int start)
  static int indexOf1(jni.JniObject s, int ch, int start) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_indexOf1,
          jni.JniType.intType, [s.reference, ch, start]).integer;

  static final _id_indexOf2 = jniAccessors.getStaticMethodIDOf(
      _classRef, "indexOf", "(Ljava/lang/CharSequence;CII)I");

  /// from: static public int indexOf(java.lang.CharSequence s, char ch, int start, int end)
  static int indexOf2(jni.JniObject s, int ch, int start, int end) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_indexOf2,
          jni.JniType.intType, [s.reference, ch, start, end]).integer;

  static final _id_lastIndexOf = jniAccessors.getStaticMethodIDOf(
      _classRef, "lastIndexOf", "(Ljava/lang/CharSequence;C)I");

  /// from: static public int lastIndexOf(java.lang.CharSequence s, char ch)
  static int lastIndexOf(jni.JniObject s, int ch) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_lastIndexOf,
          jni.JniType.intType, [s.reference, ch]).integer;

  static final _id_lastIndexOf1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "lastIndexOf", "(Ljava/lang/CharSequence;CI)I");

  /// from: static public int lastIndexOf(java.lang.CharSequence s, char ch, int last)
  static int lastIndexOf1(jni.JniObject s, int ch, int last) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_lastIndexOf1,
          jni.JniType.intType, [s.reference, ch, last]).integer;

  static final _id_lastIndexOf2 = jniAccessors.getStaticMethodIDOf(
      _classRef, "lastIndexOf", "(Ljava/lang/CharSequence;CII)I");

  /// from: static public int lastIndexOf(java.lang.CharSequence s, char ch, int start, int last)
  static int lastIndexOf2(jni.JniObject s, int ch, int start, int last) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_lastIndexOf2,
          jni.JniType.intType, [s.reference, ch, start, last]).integer;

  static final _id_indexOf3 = jniAccessors.getStaticMethodIDOf(_classRef,
      "indexOf", "(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)I");

  /// from: static public int indexOf(java.lang.CharSequence s, java.lang.CharSequence needle)
  static int indexOf3(jni.JniObject s, jni.JniObject needle) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_indexOf3,
          jni.JniType.intType, [s.reference, needle.reference]).integer;

  static final _id_indexOf4 = jniAccessors.getStaticMethodIDOf(_classRef,
      "indexOf", "(Ljava/lang/CharSequence;Ljava/lang/CharSequence;I)I");

  /// from: static public int indexOf(java.lang.CharSequence s, java.lang.CharSequence needle, int start)
  static int indexOf4(jni.JniObject s, jni.JniObject needle, int start) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_indexOf4,
          jni.JniType.intType, [s.reference, needle.reference, start]).integer;

  static final _id_indexOf5 = jniAccessors.getStaticMethodIDOf(_classRef,
      "indexOf", "(Ljava/lang/CharSequence;Ljava/lang/CharSequence;II)I");

  /// from: static public int indexOf(java.lang.CharSequence s, java.lang.CharSequence needle, int start, int end)
  static int indexOf5(
          jni.JniObject s, jni.JniObject needle, int start, int end) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_indexOf5,
          jni.JniType.intType,
          [s.reference, needle.reference, start, end]).integer;

  static final _id_regionMatches = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "regionMatches",
      "(Ljava/lang/CharSequence;ILjava/lang/CharSequence;II)Z");

  /// from: static public boolean regionMatches(java.lang.CharSequence one, int toffset, java.lang.CharSequence two, int ooffset, int len)
  static bool regionMatches(jni.JniObject one, int toffset, jni.JniObject two,
          int ooffset, int len) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_regionMatches,
          jni.JniType.booleanType,
          [one.reference, toffset, two.reference, ooffset, len]).boolean;

  static final _id_substring = jniAccessors.getStaticMethodIDOf(
      _classRef, "substring", "(Ljava/lang/CharSequence;II)Ljava/lang/String;");

  /// from: static public java.lang.String substring(java.lang.CharSequence source, int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new String object containing the given range of characters
  /// from the source string.  This is different than simply calling
  /// CharSequence\#subSequence(int, int) CharSequence.subSequence
  /// in that it does not preserve any style runs in the source sequence,
  /// allowing a more efficient implementation.
  static jni.JniString substring(jni.JniObject source, int start, int end) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_substring,
          jni.JniType.objectType,
          [source.reference, start, end]).object);

  static final _id_join = jniAccessors.getStaticMethodIDOf(_classRef, "join",
      "(Ljava/lang/CharSequence;[Ljava/lang/Object;)Ljava/lang/String;");

  /// from: static public java.lang.String join(java.lang.CharSequence delimiter, java.lang.Object[] tokens)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a string containing the tokens joined by delimiters.
  ///@param delimiter a CharSequence that will be inserted between the tokens. If null, the string
  ///     "null" will be used as the delimiter.
  /// This value must never be {@code null}.
  ///@param tokens an array objects to be joined. Strings will be formed from the objects by
  ///     calling object.toString(). If tokens is null, a NullPointerException will be thrown. If
  ///     tokens is an empty array, an empty string will be returned.
  ///
  /// This value must never be {@code null}.
  static jni.JniString join(jni.JniObject delimiter, jni.JniObject tokens) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_join,
          jni.JniType.objectType,
          [delimiter.reference, tokens.reference]).object);

  static final _id_join1 = jniAccessors.getStaticMethodIDOf(_classRef, "join",
      "(Ljava/lang/CharSequence;Ljava/lang/Iterable;)Ljava/lang/String;");

  /// from: static public java.lang.String join(java.lang.CharSequence delimiter, java.lang.Iterable tokens)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a string containing the tokens joined by delimiters.
  ///@param delimiter a CharSequence that will be inserted between the tokens. If null, the string
  ///     "null" will be used as the delimiter.
  /// This value must never be {@code null}.
  ///@param tokens an array objects to be joined. Strings will be formed from the objects by
  ///     calling object.toString(). If tokens is null, a NullPointerException will be thrown. If
  ///     tokens is empty, an empty string will be returned.
  ///
  /// This value must never be {@code null}.
  static jni.JniString join1(jni.JniObject delimiter, jni.JniObject tokens) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_join1,
          jni.JniType.objectType,
          [delimiter.reference, tokens.reference]).object);

  static final _id_split = jniAccessors.getStaticMethodIDOf(_classRef, "split",
      "(Ljava/lang/String;Ljava/lang/String;)[Ljava/lang/String;");

  /// from: static public java.lang.String[] split(java.lang.String text, java.lang.String expression)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// String.split() returns [''] when the string to be split is empty. This returns []. This does
  /// not remove any empty strings from the result. For example split("a,", ","  ) returns {"a", ""}.
  ///@param text the string to split
  ///@param expression the regular expression to match
  ///@return an array of strings. The array will be empty if text is empty
  ///@throws NullPointerException if expression or text is null
  static jni.JniObject split(jni.JniString text, jni.JniString expression) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_split,
          jni.JniType.objectType,
          [text.reference, expression.reference]).object);

  static final _id_split1 = jniAccessors.getStaticMethodIDOf(_classRef, "split",
      "(Ljava/lang/String;Ljava/util/regex/Pattern;)[Ljava/lang/String;");

  /// from: static public java.lang.String[] split(java.lang.String text, java.util.regex.Pattern pattern)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Splits a string on a pattern. String.split() returns [''] when the string to be
  /// split is empty. This returns []. This does not remove any empty strings from the result.
  ///@param text the string to split
  ///@param pattern the regular expression to match
  ///@return an array of strings. The array will be empty if text is empty
  ///@throws NullPointerException if expression or text is null
  static jni.JniObject split1(jni.JniString text, jni.JniObject pattern) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_split1,
          jni.JniType.objectType,
          [text.reference, pattern.reference]).object);

  static final _id_stringOrSpannedString = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "stringOrSpannedString",
      "(Ljava/lang/CharSequence;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence stringOrSpannedString(java.lang.CharSequence source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject stringOrSpannedString(jni.JniObject source) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_stringOrSpannedString,
          jni.JniType.objectType,
          [source.reference]).object);

  static final _id_isEmpty = jniAccessors.getStaticMethodIDOf(
      _classRef, "isEmpty", "(Ljava/lang/CharSequence;)Z");

  /// from: static public boolean isEmpty(java.lang.CharSequence str)
  ///
  /// Returns true if the string is null or 0-length.
  ///@param str the string to be examined
  /// This value may be {@code null}.
  ///@return true if str is null or zero length
  static bool isEmpty(jni.JniObject str) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isEmpty,
          jni.JniType.booleanType, [str.reference]).boolean;

  static final _id_getTrimmedLength = jniAccessors.getStaticMethodIDOf(
      _classRef, "getTrimmedLength", "(Ljava/lang/CharSequence;)I");

  /// from: static public int getTrimmedLength(java.lang.CharSequence s)
  ///
  /// Returns the length that the specified CharSequence would have if
  /// spaces and ASCII control characters were trimmed from the start and end,
  /// as by String\#trim.
  static int getTrimmedLength(jni.JniObject s) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getTrimmedLength,
          jni.JniType.intType, [s.reference]).integer;

  static final _id_equals1 = jniAccessors.getStaticMethodIDOf(_classRef,
      "equals", "(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Z");

  /// from: static public boolean equals(java.lang.CharSequence a, java.lang.CharSequence b)
  ///
  /// Returns true if a and b are equal, including if they are both null.
  /// <i>Note: In platform versions 1.1 and earlier, this method only worked well if
  /// both the arguments were instances of String.</i>
  ///
  ///@param a first CharSequence to check
  ///@param b second CharSequence to check
  ///@return true if a and b are equal
  static bool equals1(jni.JniObject a, jni.JniObject b) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_equals1,
          jni.JniType.booleanType, [a.reference, b.reference]).boolean;

  static final _id_getReverse = jniAccessors.getStaticMethodIDOf(_classRef,
      "getReverse", "(Ljava/lang/CharSequence;II)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getReverse(java.lang.CharSequence source, int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This function only reverses individual {@code char}s and not their associated
  /// spans. It doesn't support surrogate pairs (that correspond to non-BMP code points), combining
  /// sequences or conjuncts either.
  ///@deprecated Do not use.
  static jni.JniObject getReverse(jni.JniObject source, int start, int end) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getReverse,
          jni.JniType.objectType,
          [source.reference, start, end]).object);

  static final _id_writeToParcel = jniAccessors.getStaticMethodIDOf(_classRef,
      "writeToParcel", "(Ljava/lang/CharSequence;Landroid/os/Parcel;I)V");

  /// from: static public void writeToParcel(java.lang.CharSequence cs, android.os.Parcel p, int parcelableFlags)
  ///
  /// Flatten a CharSequence and whatever styles can be copied across processes
  /// into the parcel.
  static void writeToParcel(
          jni.JniObject cs, parcel_.Parcel p, int parcelableFlags) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_writeToParcel,
          jni.JniType.voidType,
          [cs.reference, p.reference, parcelableFlags]).check();

  static final _id_dumpSpans = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "dumpSpans",
      "(Ljava/lang/CharSequence;Landroid/util/Printer;Ljava/lang/String;)V");

  /// from: static public void dumpSpans(java.lang.CharSequence cs, android.util.Printer printer, java.lang.String prefix)
  ///
  /// Debugging tool to print the spans in a CharSequence.  The output will
  /// be printed one span per line.  If the CharSequence is not a Spanned,
  /// then the entire string will be printed on a single line.
  static void dumpSpans(
          jni.JniObject cs, printer_.Printer printer, jni.JniString prefix) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_dumpSpans,
          jni.JniType.voidType,
          [cs.reference, printer.reference, prefix.reference]).check();

  static final _id_replace = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "replace",
      "(Ljava/lang/CharSequence;[Ljava/lang/String;[Ljava/lang/CharSequence;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence replace(java.lang.CharSequence template, java.lang.String[] sources, java.lang.CharSequence[] destinations)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new CharSequence in which each of the source strings is
  /// replaced by the corresponding element of the destinations.
  static jni.JniObject replace(jni.JniObject template, jni.JniObject sources,
          jni.JniObject destinations) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_replace, jni.JniType.objectType, [
        template.reference,
        sources.reference,
        destinations.reference
      ]).object);

  static final _id_expandTemplate = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "expandTemplate",
      "(Ljava/lang/CharSequence;[Ljava/lang/CharSequence;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence expandTemplate(java.lang.CharSequence template, java.lang.CharSequence[] values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Replace instances of "^1", "^2", etc. in the
  /// <code>template</code> CharSequence with the corresponding
  /// <code>values</code>.  "^^" is used to produce a single caret in
  /// the output.  Only up to 9 replacement values are supported,
  /// "^10" will be produce the first replacement value followed by a
  /// '0'.
  ///@param template the input text containing "^1"-style
  /// placeholder values.  This object is not modified; a copy is
  /// returned.
  ///@param values CharSequences substituted into the template.  The
  /// first is substituted for "^1", the second for "^2", and so on.
  ///@return the new CharSequence produced by doing the replacement
  ///@throws IllegalArgumentException if the template requests a
  /// value that was not provided, or if more than 9 values are
  /// provided.
  static jni.JniObject expandTemplate(
          jni.JniObject template, jni.JniObject values) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_expandTemplate,
          jni.JniType.objectType,
          [template.reference, values.reference]).object);

  static final _id_getOffsetBefore = jniAccessors.getStaticMethodIDOf(
      _classRef, "getOffsetBefore", "(Ljava/lang/CharSequence;I)I");

  /// from: static public int getOffsetBefore(java.lang.CharSequence text, int offset)
  static int getOffsetBefore(jni.JniObject text, int offset) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getOffsetBefore,
          jni.JniType.intType, [text.reference, offset]).integer;

  static final _id_getOffsetAfter = jniAccessors.getStaticMethodIDOf(
      _classRef, "getOffsetAfter", "(Ljava/lang/CharSequence;I)I");

  /// from: static public int getOffsetAfter(java.lang.CharSequence text, int offset)
  static int getOffsetAfter(jni.JniObject text, int offset) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getOffsetAfter,
          jni.JniType.intType, [text.reference, offset]).integer;

  static final _id_copySpansFrom = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "copySpansFrom",
      "(Landroid/text/Spanned;IILjava/lang/Class;Landroid/text/Spannable;I)V");

  /// from: static public void copySpansFrom(android.text.Spanned source, int start, int end, java.lang.Class kind, android.text.Spannable dest, int destoff)
  ///
  /// Copies the spans from the region <code>start...end</code> in
  /// <code>source</code> to the region
  /// <code>destoff...destoff+end-start</code> in <code>dest</code>.
  /// Spans in <code>source</code> that begin before <code>start</code>
  /// or end after <code>end</code> but overlap this range are trimmed
  /// as if they began at <code>start</code> or ended at <code>end</code>.
  ///@throws IndexOutOfBoundsException if any of the copied spans
  /// are out of range in <code>dest</code>.
  static void copySpansFrom(spanned_.Spanned source, int start, int end,
          jni.JniObject kind, spannable_.Spannable dest, int destoff) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_copySpansFrom, jni.JniType.voidType, [
        source.reference,
        start,
        end,
        kind.reference,
        dest.reference,
        destoff
      ]).check();

  static final _id_ellipsize = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "ellipsize",
      "(Ljava/lang/CharSequence;Landroid/text/TextPaint;FLandroid/text/TextUtils\$TruncateAt;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence ellipsize(java.lang.CharSequence text, android.text.TextPaint p, float avail, android.text.TextUtils.TruncateAt where)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the original text if it fits in the specified width
  /// given the properties of the specified Paint,
  /// or, if it does not fit, a truncated
  /// copy with ellipsis character added at the specified edge or center.
  static jni.JniObject ellipsize(jni.JniObject text, textpaint_.TextPaint p,
          double avail, TextUtils_TruncateAt where) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_ellipsize,
          jni.JniType.objectType,
          [text.reference, p.reference, avail, where.reference]).object);

  static final _id_ellipsize1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "ellipsize",
      "(Ljava/lang/CharSequence;Landroid/text/TextPaint;FLandroid/text/TextUtils\$TruncateAt;ZLandroid/text/TextUtils\$EllipsizeCallback;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence ellipsize(java.lang.CharSequence text, android.text.TextPaint paint, float avail, android.text.TextUtils.TruncateAt where, boolean preserveLength, android.text.TextUtils.EllipsizeCallback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the original text if it fits in the specified width
  /// given the properties of the specified Paint,
  /// or, if it does not fit, a copy with ellipsis character added
  /// at the specified edge or center.
  /// If <code>preserveLength</code> is specified, the returned copy
  /// will be padded with zero-width spaces to preserve the original
  /// length and offsets instead of truncating.
  /// If <code>callback</code> is non-null, it will be called to
  /// report the start and end of the ellipsized range.  TextDirection
  /// is determined by the first strong directional character.
  ///@param callback This value may be {@code null}.
  static jni.JniObject ellipsize1(
          jni.JniObject text,
          textpaint_.TextPaint paint,
          double avail,
          TextUtils_TruncateAt where,
          bool preserveLength,
          TextUtils_EllipsizeCallback callback) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_ellipsize1, jni.JniType.objectType, [
        text.reference,
        paint.reference,
        avail,
        where.reference,
        preserveLength,
        callback.reference
      ]).object);

  static final _id_listEllipsize = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "listEllipsize",
      "(Landroid/content/Context;Ljava/util/List;Ljava/lang/String;Landroid/text/TextPaint;FI)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence listEllipsize(android.content.Context context, java.util.List<java.lang.CharSequence> elements, java.lang.String separator, android.text.TextPaint paint, float avail, int moreId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formats a list of CharSequences by repeatedly inserting the separator between them,
  /// but stopping when the resulting sequence is too wide for the specified width.
  ///
  /// This method actually tries to fit the maximum number of elements. So if {@code "A, 11 more"
  /// fits}, {@code "A, B, 10 more"} doesn't fit, but {@code "A, B, C, 9 more"} fits again (due to
  /// the glyphs for the digits being very wide, for example), it returns
  /// {@code "A, B, C, 9 more"}. Because of this, this method may be inefficient for very long
  /// lists.
  ///
  /// Note that the elements of the returned value, as well as the string for {@code moreId}, will
  /// be bidi-wrapped using BidiFormatter\#unicodeWrap based on the locale of the input
  /// Context. If the input {@code Context} is null, the default BidiFormatter from
  /// BidiFormatter\#getInstance() will be used.
  ///@param context the {@code Context} to get the {@code moreId} resource from. If {@code null},
  ///     an ellipsis (U+2026) would be used for {@code moreId}.
  /// This value may be {@code null}.
  ///@param elements the list to format
  /// This value may be {@code null}.
  ///@param separator a separator, such as {@code ", "}
  /// This value must never be {@code null}.
  ///@param paint the Paint with which to measure the text
  /// This value must never be {@code null}.
  ///@param avail the horizontal width available for the text (in pixels)
  /// Value is 0.0 or greater
  ///@param moreId the resource ID for the pluralized string to insert at the end of sequence when
  ///     some of the elements don't fit.
  ///@return the formatted CharSequence. If even the shortest sequence (e.g. {@code "A, 11 more"})
  ///     doesn't fit, it will return an empty string.
  static jni.JniObject listEllipsize(
          context_.Context context,
          jni.JniObject elements,
          jni.JniString separator,
          textpaint_.TextPaint paint,
          double avail,
          int moreId) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_listEllipsize, jni.JniType.objectType, [
        context.reference,
        elements.reference,
        separator.reference,
        paint.reference,
        avail,
        moreId
      ]).object);

  static final _id_commaEllipsize = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "commaEllipsize",
      "(Ljava/lang/CharSequence;Landroid/text/TextPaint;FLjava/lang/String;Ljava/lang/String;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence commaEllipsize(java.lang.CharSequence text, android.text.TextPaint p, float avail, java.lang.String oneMore, java.lang.String more)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Converts a CharSequence of the comma-separated form "Andy, Bob,
  /// Charles, David" that is too wide to fit into the specified width
  /// into one like "Andy, Bob, 2 more".
  ///@param text the text to truncate
  ///@param p the Paint with which to measure the text
  ///@param avail the horizontal width available for the text (in pixels)
  ///@param oneMore the string for "1 more" in the current locale
  ///@param more the string for "%d more" in the current locale
  ///@deprecated Do not use. This is not internationalized, and has known issues
  /// with right-to-left text, languages that have more than one plural form, languages
  /// that use a different character as a comma-like separator, etc.
  /// Use \#listEllipsize instead.
  static jni.JniObject commaEllipsize(
          jni.JniObject text,
          textpaint_.TextPaint p,
          double avail,
          jni.JniString oneMore,
          jni.JniString more) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_commaEllipsize, jni.JniType.objectType, [
        text.reference,
        p.reference,
        avail,
        oneMore.reference,
        more.reference
      ]).object);

  static final _id_htmlEncode = jniAccessors.getStaticMethodIDOf(
      _classRef, "htmlEncode", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String htmlEncode(java.lang.String s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Html-encode the string.
  ///@param s the string to be encoded
  ///@return the encoded string
  static jni.JniString htmlEncode(jni.JniString s) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_htmlEncode, jni.JniType.objectType, [s.reference]).object);

  static final _id_concat = jniAccessors.getStaticMethodIDOf(_classRef,
      "concat", "([Ljava/lang/CharSequence;)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence concat(java.lang.CharSequence[] text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a CharSequence concatenating the specified CharSequences,
  /// retaining their spans if any.
  ///
  /// If there are no parameters, an empty string will be returned.
  ///
  /// If the number of parameters is exactly one, that parameter is returned as output, even if it
  /// is null.
  ///
  /// If the number of parameters is at least two, any null CharSequence among the parameters is
  /// treated as if it was the string <code>"null"</code>.
  ///
  /// If there are paragraph spans in the source CharSequences that satisfy paragraph boundary
  /// requirements in the sources but would no longer satisfy them in the concatenated
  /// CharSequence, they may get extended in the resulting CharSequence or not retained.
  static jni.JniObject concat(jni.JniObject text) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_concat, jni.JniType.objectType, [text.reference]).object);

  static final _id_isGraphic = jniAccessors.getStaticMethodIDOf(
      _classRef, "isGraphic", "(Ljava/lang/CharSequence;)Z");

  /// from: static public boolean isGraphic(java.lang.CharSequence str)
  ///
  /// Returns whether the given CharSequence contains any printable characters.
  static bool isGraphic(jni.JniObject str) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isGraphic,
          jni.JniType.booleanType, [str.reference]).boolean;

  static final _id_isGraphic1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "isGraphic", "(C)Z");

  /// from: static public boolean isGraphic(char c)
  ///
  /// Returns whether this character is a printable character.
  ///
  /// This does not support non-BMP characters and should not be used.
  ///@deprecated Use \#isGraphic(CharSequence) instead.
  static bool isGraphic1(int c) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_isGraphic1, jni.JniType.booleanType, [c]).boolean;

  static final _id_isDigitsOnly = jniAccessors.getStaticMethodIDOf(
      _classRef, "isDigitsOnly", "(Ljava/lang/CharSequence;)Z");

  /// from: static public boolean isDigitsOnly(java.lang.CharSequence str)
  ///
  /// Returns whether the given CharSequence contains only digits.
  static bool isDigitsOnly(jni.JniObject str) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isDigitsOnly,
          jni.JniType.booleanType, [str.reference]).boolean;

  static final _id_getCapsMode = jniAccessors.getStaticMethodIDOf(
      _classRef, "getCapsMode", "(Ljava/lang/CharSequence;II)I");

  /// from: static public int getCapsMode(java.lang.CharSequence cs, int off, int reqModes)
  ///
  /// Determine what caps mode should be in effect at the current offset in
  /// the text.  Only the mode bits set in <var>reqModes</var> will be
  /// checked.  Note that the caps mode flags here are explicitly defined
  /// to match those in InputType.
  ///@param cs The text that should be checked for caps modes.
  ///@param off Location in the text at which to check.
  ///@param reqModes The modes to be checked: may be any combination of
  /// \#CAP_MODE_CHARACTERS, \#CAP_MODE_WORDS, and
  /// \#CAP_MODE_SENTENCES.
  ///@return Returns the actual capitalization modes that can be in effect
  /// at the current position, which is any combination of
  /// \#CAP_MODE_CHARACTERS, \#CAP_MODE_WORDS, and
  /// \#CAP_MODE_SENTENCES.
  static int getCapsMode(jni.JniObject cs, int off, int reqModes) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getCapsMode,
          jni.JniType.intType, [cs.reference, off, reqModes]).integer;

  static final _id_getLayoutDirectionFromLocale =
      jniAccessors.getStaticMethodIDOf(
          _classRef, "getLayoutDirectionFromLocale", "(Ljava/util/Locale;)I");

  /// from: static public int getLayoutDirectionFromLocale(java.util.Locale locale)
  ///
  /// Return the layout direction for a given Locale
  ///@param locale the Locale for which we want the layout direction. Can be null.
  ///@return the layout direction. This may be one of:
  /// android.view.View\#LAYOUT_DIRECTION_LTR or
  /// android.view.View\#LAYOUT_DIRECTION_RTL.
  ///
  /// Be careful: this code will need to be updated when vertical scripts will be supported
  static int getLayoutDirectionFromLocale(jni.JniObject locale) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getLayoutDirectionFromLocale,
          jni.JniType.intType,
          [locale.reference]).integer;
}

/// from: android.text.TextUtils$TruncateAt
class TextUtils_TruncateAt extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/TextUtils\$TruncateAt");
  TextUtils_TruncateAt.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/text/TextUtils\$TruncateAt;");

  /// from: static public android.text.TextUtils.TruncateAt[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/text/TextUtils\$TruncateAt;");

  /// from: static public android.text.TextUtils.TruncateAt valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static TextUtils_TruncateAt valueOf(jni.JniString name) =>
      TextUtils_TruncateAt.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);
}

/// from: android.text.TextUtils$StringSplitter
///
/// An interface for splitting strings according to rules that are opaque to the user of this
/// interface. This also has less overhead than split, which uses regular expressions and
/// allocates an array to hold the results.
///
/// The most efficient way to use this class is:
///
/// <pre>
/// // Once
/// TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(delimiter);
///
/// // Once per string to split
/// splitter.setString(string);
/// for (String s : splitter) {
///     ...
/// }
/// </pre>
class TextUtils_StringSplitter extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/TextUtils\$StringSplitter");
  TextUtils_StringSplitter.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_setString = jniAccessors.getMethodIDOf(
      _classRef, "setString", "(Ljava/lang/String;)V");

  /// from: public abstract void setString(java.lang.String string)
  void setString(jni.JniString string) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setString,
      jni.JniType.voidType,
      [string.reference]).check();
}

/// from: android.text.TextUtils$SimpleStringSplitter
///
/// A simple string splitter.
///
/// If the final character in the string to split is the delimiter then no empty string will
/// be returned for the empty string after that delimeter. That is, splitting <tt>"a,b,"</tt> on
/// comma will return <tt>"a", "b"</tt>, not <tt>"a", "b", ""</tt>.
class TextUtils_SimpleStringSplitter extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/TextUtils\$SimpleStringSplitter");
  TextUtils_SimpleStringSplitter.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(C)V");

  /// from: public void <init>(char delimiter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Initializes the splitter. setString may be called later.
  ///@param delimiter the delimeter on which to split
  TextUtils_SimpleStringSplitter(int delimiter)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [delimiter]).object);

  static final _id_setString = jniAccessors.getMethodIDOf(
      _classRef, "setString", "(Ljava/lang/String;)V");

  /// from: public void setString(java.lang.String string)
  ///
  /// Sets the string to split
  ///@param string the string to split
  void setString(jni.JniString string) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setString,
      jni.JniType.voidType,
      [string.reference]).check();

  static final _id_iterator = jniAccessors.getMethodIDOf(
      _classRef, "iterator", "()Ljava/util/Iterator;");

  /// from: public java.util.Iterator<java.lang.String> iterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject iterator() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_iterator, jni.JniType.objectType, []).object);

  static final _id_hasNext =
      jniAccessors.getMethodIDOf(_classRef, "hasNext", "()Z");

  /// from: public boolean hasNext()
  bool hasNext() => jniAccessors.callMethodWithArgs(
      reference, _id_hasNext, jni.JniType.booleanType, []).boolean;

  static final _id_next =
      jniAccessors.getMethodIDOf(_classRef, "next", "()Ljava/lang/String;");

  /// from: public java.lang.String next()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString next() => jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_next, jni.JniType.objectType, []).object);

  static final _id_remove =
      jniAccessors.getMethodIDOf(_classRef, "remove", "()V");

  /// from: public void remove()
  void remove() => jniAccessors.callMethodWithArgs(
      reference, _id_remove, jni.JniType.voidType, []).check();
}

/// from: android.text.TextUtils$EllipsizeCallback
class TextUtils_EllipsizeCallback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/TextUtils\$EllipsizeCallback");
  TextUtils_EllipsizeCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ellipsized =
      jniAccessors.getMethodIDOf(_classRef, "ellipsized", "(II)V");

  /// from: public abstract void ellipsized(int start, int end)
  ///
  /// This method is called to report that the specified region of
  /// text was ellipsized away by a call to \#ellipsize.
  void ellipsized(int start, int end) => jniAccessors.callMethodWithArgs(
      reference, _id_ellipsized, jni.JniType.voidType, [start, end]).check();
}
