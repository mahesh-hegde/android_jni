// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../content/Context.dart" as context_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.text.format.DateUtils
///
/// This class contains various date-related utilities for creating text for things like
/// elapsed time and date ranges, strings for days of the week and months, and AM/PM text etc.
class DateUtils extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/format/DateUtils");
  DateUtils.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ABBREV_MONTH_FORMAT
  ///
  /// This is not actually a useful month name in all locales.
  ///@deprecated Use java.text.SimpleDateFormat instead.
  static const ABBREV_MONTH_FORMAT = "%b";

  /// from: static public final java.lang.String ABBREV_WEEKDAY_FORMAT
  static const ABBREV_WEEKDAY_FORMAT = "%a";

  /// from: static public final long DAY_IN_MILLIS
  static const DAY_IN_MILLIS = 86400000;

  /// from: static public final int FORMAT_12HOUR
  static const FORMAT_12HOUR = 64;

  /// from: static public final int FORMAT_24HOUR
  static const FORMAT_24HOUR = 128;

  /// from: static public final int FORMAT_ABBREV_ALL
  static const FORMAT_ABBREV_ALL = 524288;

  /// from: static public final int FORMAT_ABBREV_MONTH
  static const FORMAT_ABBREV_MONTH = 65536;

  /// from: static public final int FORMAT_ABBREV_RELATIVE
  static const FORMAT_ABBREV_RELATIVE = 262144;

  /// from: static public final int FORMAT_ABBREV_TIME
  static const FORMAT_ABBREV_TIME = 16384;

  /// from: static public final int FORMAT_ABBREV_WEEKDAY
  static const FORMAT_ABBREV_WEEKDAY = 32768;

  /// from: static public final int FORMAT_CAP_AMPM
  static const FORMAT_CAP_AMPM = 256;

  /// from: static public final int FORMAT_CAP_MIDNIGHT
  static const FORMAT_CAP_MIDNIGHT = 4096;

  /// from: static public final int FORMAT_CAP_NOON
  static const FORMAT_CAP_NOON = 1024;

  /// from: static public final int FORMAT_CAP_NOON_MIDNIGHT
  static const FORMAT_CAP_NOON_MIDNIGHT = 5120;

  /// from: static public final int FORMAT_NO_MIDNIGHT
  static const FORMAT_NO_MIDNIGHT = 2048;

  /// from: static public final int FORMAT_NO_MONTH_DAY
  static const FORMAT_NO_MONTH_DAY = 32;

  /// from: static public final int FORMAT_NO_NOON
  static const FORMAT_NO_NOON = 512;

  /// from: static public final int FORMAT_NO_NOON_MIDNIGHT
  static const FORMAT_NO_NOON_MIDNIGHT = 2560;

  /// from: static public final int FORMAT_NO_YEAR
  static const FORMAT_NO_YEAR = 8;

  /// from: static public final int FORMAT_NUMERIC_DATE
  static const FORMAT_NUMERIC_DATE = 131072;

  /// from: static public final int FORMAT_SHOW_DATE
  static const FORMAT_SHOW_DATE = 16;

  /// from: static public final int FORMAT_SHOW_TIME
  static const FORMAT_SHOW_TIME = 1;

  /// from: static public final int FORMAT_SHOW_WEEKDAY
  static const FORMAT_SHOW_WEEKDAY = 2;

  /// from: static public final int FORMAT_SHOW_YEAR
  static const FORMAT_SHOW_YEAR = 4;

  /// from: static public final int FORMAT_UTC
  ///
  /// @deprecated Use
  /// \#formatDateRange(Context, Formatter, long, long, int, String) formatDateRange
  /// and pass in Time\#TIMEZONE_UTC Time.TIMEZONE_UTC for the timeZone instead.
  static const FORMAT_UTC = 8192;

  /// from: static public final long HOUR_IN_MILLIS
  static const HOUR_IN_MILLIS = 3600000;

  /// from: static public final java.lang.String HOUR_MINUTE_24
  ///
  /// This is not actually the preferred 24-hour date format in all locales.
  ///@deprecated Use java.text.SimpleDateFormat instead.
  static const HOUR_MINUTE_24 = "%H:%M";

  /// from: static public final int LENGTH_LONG
  ///
  /// Request the full spelled-out name. For use with the 'abbrev' parameter of
  /// \#getDayOfWeekString and \#getMonthString.
  ///@more
  ///       e.g. "Sunday" or "January"
  ///@deprecated Use java.text.SimpleDateFormat instead.
  static const LENGTH_LONG = 10;

  /// from: static public final int LENGTH_MEDIUM
  ///
  /// Request an abbreviated version of the name. For use with the 'abbrev'
  /// parameter of \#getDayOfWeekString and \#getMonthString.
  ///@more
  ///       e.g. "Sun" or "Jan"
  ///@deprecated Use java.text.SimpleDateFormat instead.
  static const LENGTH_MEDIUM = 20;

  /// from: static public final int LENGTH_SHORT
  ///
  /// Request a shorter abbreviated version of the name.
  /// For use with the 'abbrev' parameter of \#getDayOfWeekString and \#getMonthString.
  ///@more e.g. "Su" or "Jan"
  /// In most languages, the results returned for LENGTH_SHORT will be the same as
  /// the results returned for \#LENGTH_MEDIUM.
  ///@deprecated Use java.text.SimpleDateFormat instead.
  static const LENGTH_SHORT = 30;

  /// from: static public final int LENGTH_SHORTER
  ///
  /// Request an even shorter abbreviated version of the name.
  /// Do not use this.  Currently this will always return the same result
  /// as \#LENGTH_SHORT.
  ///@deprecated Use java.text.SimpleDateFormat instead.
  static const LENGTH_SHORTER = 40;

  /// from: static public final int LENGTH_SHORTEST
  ///
  /// Request an even shorter abbreviated version of the name.
  /// For use with the 'abbrev' parameter of \#getDayOfWeekString and \#getMonthString.
  ///@more e.g. "S", "T", "T" or "J"
  /// In some languages, the results returned for LENGTH_SHORTEST will be the same as
  /// the results returned for \#LENGTH_SHORT.
  ///@deprecated Use java.text.SimpleDateFormat instead.
  static const LENGTH_SHORTEST = 50;

  /// from: static public final long MINUTE_IN_MILLIS
  static const MINUTE_IN_MILLIS = 60000;

  /// from: static public final java.lang.String MONTH_DAY_FORMAT
  static const MONTH_DAY_FORMAT = "%-d";

  /// from: static public final java.lang.String MONTH_FORMAT
  static const MONTH_FORMAT = "%B";

  /// from: static public final java.lang.String NUMERIC_MONTH_FORMAT
  static const NUMERIC_MONTH_FORMAT = "%m";

  /// from: static public final long SECOND_IN_MILLIS
  static const SECOND_IN_MILLIS = 1000;

  /// from: static public final java.lang.String WEEKDAY_FORMAT
  static const WEEKDAY_FORMAT = "%A";

  /// from: static public final long WEEK_IN_MILLIS
  static const WEEK_IN_MILLIS = 604800000;

  /// from: static public final java.lang.String YEAR_FORMAT
  static const YEAR_FORMAT = "%Y";

  /// from: static public final java.lang.String YEAR_FORMAT_TWO_DIGITS
  static const YEAR_FORMAT_TWO_DIGITS = "%g";

  /// from: static public final long YEAR_IN_MILLIS
  ///
  /// This constant is actually the length of 364 days, not of a year!
  static const YEAR_IN_MILLIS = 31449600000;

  static final _id_sameMonthTable =
      jniAccessors.getStaticFieldIDOf(_classRef, "sameMonthTable", "[I");

  /// from: static public final int[] sameMonthTable
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Do not use.
  static jni.JniObject get sameMonthTable => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_sameMonthTable, jni.JniType.objectType)
      .object);

  static final _id_sameYearTable =
      jniAccessors.getStaticFieldIDOf(_classRef, "sameYearTable", "[I");

  /// from: static public final int[] sameYearTable
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Do not use.
  static jni.JniObject get sameYearTable => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_sameYearTable, jni.JniType.objectType)
      .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  DateUtils()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getDayOfWeekString = jniAccessors.getStaticMethodIDOf(
      _classRef, "getDayOfWeekString", "(II)Ljava/lang/String;");

  /// from: static public java.lang.String getDayOfWeekString(int dayOfWeek, int abbrev)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a string for the day of the week.
  ///@param dayOfWeek One of Calendar\#SUNDAY Calendar.SUNDAY,
  ///               Calendar\#MONDAY Calendar.MONDAY, etc.
  ///@param abbrev One of \#LENGTH_LONG, \#LENGTH_SHORT,
  ///               \#LENGTH_MEDIUM, or \#LENGTH_SHORTEST.
  ///               Note that in most languages, \#LENGTH_SHORT
  ///               will return the same as \#LENGTH_MEDIUM.
  ///               Undefined lengths will return \#LENGTH_MEDIUM
  ///               but may return something different in the future.
  ///@throws IndexOutOfBoundsException if the dayOfWeek is out of bounds.
  ///@deprecated Use java.text.SimpleDateFormat instead.
  static jni.JniString getDayOfWeekString(int dayOfWeek, int abbrev) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getDayOfWeekString,
          jni.JniType.objectType,
          [dayOfWeek, abbrev]).object);

  static final _id_getAMPMString = jniAccessors.getStaticMethodIDOf(
      _classRef, "getAMPMString", "(I)Ljava/lang/String;");

  /// from: static public java.lang.String getAMPMString(int ampm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a localized string for AM or PM.
  ///@param ampm Either Calendar\#AM Calendar.AM or Calendar\#PM Calendar.PM.
  ///@throws IndexOutOfBoundsException if the ampm is out of bounds.
  ///@return Localized version of "AM" or "PM".
  ///@deprecated Use java.text.SimpleDateFormat instead.
  static jni.JniString getAMPMString(int ampm) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getAMPMString, jni.JniType.objectType, [ampm]).object);

  static final _id_getMonthString = jniAccessors.getStaticMethodIDOf(
      _classRef, "getMonthString", "(II)Ljava/lang/String;");

  /// from: static public java.lang.String getMonthString(int month, int abbrev)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a localized string for the month of the year.
  ///@param month One of Calendar\#JANUARY Calendar.JANUARY,
  ///               Calendar\#FEBRUARY Calendar.FEBRUARY, etc.
  ///@param abbrev One of \#LENGTH_LONG, \#LENGTH_MEDIUM,
  ///               or \#LENGTH_SHORTEST.
  ///               Undefined lengths will return \#LENGTH_MEDIUM
  ///               but may return something different in the future.
  ///@return Localized month of the year.
  ///@deprecated Use java.text.SimpleDateFormat instead.
  static jni.JniString getMonthString(int month, int abbrev) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getMonthString, jni.JniType.objectType, [month, abbrev]).object);

  static final _id_getRelativeTimeSpanString = jniAccessors.getStaticMethodIDOf(
      _classRef, "getRelativeTimeSpanString", "(J)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getRelativeTimeSpanString(long startTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a string describing the elapsed time since startTime.
  ///
  /// The minimum timespan to report is set to \#MINUTE_IN_MILLIS.
  ///@param startTime some time in the past.
  ///@return a String object containing the elapsed time.
  ///@see \#getRelativeTimeSpanString(long, long, long)
  static jni.JniObject getRelativeTimeSpanString(int startTime) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getRelativeTimeSpanString,
          jni.JniType.objectType,
          [startTime]).object);

  static final _id_getRelativeTimeSpanString1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "getRelativeTimeSpanString",
          "(JJJ)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getRelativeTimeSpanString(long time, long now, long minResolution)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a string describing 'time' as a time relative to 'now'.
  ///
  /// Time spans in the past are formatted like "42 minutes ago".
  /// Time spans in the future are formatted like "In 42 minutes".
  ///@param time the time to describe, in milliseconds
  ///@param now the current time in milliseconds
  ///@param minResolution the minimum timespan to report. For example, a time 3 seconds in the
  ///     past will be reported as "0 minutes ago" if this is set to MINUTE_IN_MILLIS. Pass one of
  ///     0, MINUTE_IN_MILLIS, HOUR_IN_MILLIS, DAY_IN_MILLIS, WEEK_IN_MILLIS
  static jni.JniObject getRelativeTimeSpanString1(
          int time, int now, int minResolution) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getRelativeTimeSpanString1,
          jni.JniType.objectType,
          [time, now, minResolution]).object);

  static final _id_getRelativeTimeSpanString2 =
      jniAccessors.getStaticMethodIDOf(_classRef, "getRelativeTimeSpanString",
          "(JJJI)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getRelativeTimeSpanString(long time, long now, long minResolution, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a string describing 'time' as a time relative to 'now'.
  ///
  /// Time spans in the past are formatted like "42 minutes ago". Time spans in
  /// the future are formatted like "In 42 minutes".
  ///
  /// Can use \#FORMAT_ABBREV_RELATIVE flag to use abbreviated relative
  /// times, like "42 mins ago".
  ///@param time the time to describe, in milliseconds
  ///@param now the current time in milliseconds
  ///@param minResolution the minimum timespan to report. For example, a time
  ///            3 seconds in the past will be reported as "0 minutes ago" if
  ///            this is set to MINUTE_IN_MILLIS. Pass one of 0,
  ///            MINUTE_IN_MILLIS, HOUR_IN_MILLIS, DAY_IN_MILLIS,
  ///            WEEK_IN_MILLIS
  ///@param flags a bit mask of formatting options, such as
  ///            \#FORMAT_NUMERIC_DATE or
  ///            \#FORMAT_ABBREV_RELATIVE
  static jni.JniObject getRelativeTimeSpanString2(
          int time, int now, int minResolution, int flags) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getRelativeTimeSpanString2,
          jni.JniType.objectType,
          [time, now, minResolution, flags]).object);

  static final _id_getRelativeDateTimeString = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getRelativeDateTimeString",
      "(Landroid/content/Context;JJJI)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getRelativeDateTimeString(android.content.Context c, long time, long minResolution, long transitionResolution, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return string describing the elapsed time since startTime formatted like
  /// "[relative time/date], [time]".
  ///
  /// Example output strings for the US date format.
  /// <ul>
  /// <li>3 min. ago, 10:15 AM</li>
  /// <li>Yesterday, 12:20 PM</li>
  /// <li>Dec 12, 4:12 AM</li>
  /// <li>11/14/2007, 8:20 AM</li>
  /// </ul>
  ///@param time some time in the past.
  ///@param minResolution the minimum elapsed time (in milliseconds) to report
  ///            when showing relative times. For example, a time 3 seconds in
  ///            the past will be reported as "0 minutes ago" if this is set to
  ///            \#MINUTE_IN_MILLIS.
  ///@param transitionResolution the elapsed time (in milliseconds) at which
  ///            to stop reporting relative measurements. Elapsed times greater
  ///            than this resolution will default to normal date formatting.
  ///            For example, will transition from "7 days ago" to "Dec 12"
  ///            when using \#WEEK_IN_MILLIS.
  static jni.JniObject getRelativeDateTimeString(context_.Context c, int time,
          int minResolution, int transitionResolution, int flags) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getRelativeDateTimeString, jni.JniType.objectType, [
        c.reference,
        time,
        minResolution,
        transitionResolution,
        flags
      ]).object);

  static final _id_formatElapsedTime = jniAccessors.getStaticMethodIDOf(
      _classRef, "formatElapsedTime", "(J)Ljava/lang/String;");

  /// from: static public java.lang.String formatElapsedTime(long elapsedSeconds)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formats an elapsed time in the form "MM:SS" or "H:MM:SS"
  /// for display on the call-in-progress screen.
  ///@param elapsedSeconds the elapsed time in seconds.
  static jni.JniString formatElapsedTime(int elapsedSeconds) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_formatElapsedTime,
          jni.JniType.objectType,
          [elapsedSeconds]).object);

  static final _id_formatElapsedTime1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "formatElapsedTime",
      "(Ljava/lang/StringBuilder;J)Ljava/lang/String;");

  /// from: static public java.lang.String formatElapsedTime(java.lang.StringBuilder recycle, long elapsedSeconds)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formats an elapsed time in a format like "MM:SS" or "H:MM:SS" (using a form
  /// suited to the current locale), similar to that used on the call-in-progress
  /// screen.
  ///@param recycle StringBuilder to recycle, or null to use a temporary one.
  ///@param elapsedSeconds the elapsed time in seconds.
  static jni.JniString formatElapsedTime1(
          jni.JniObject recycle, int elapsedSeconds) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_formatElapsedTime1,
          jni.JniType.objectType,
          [recycle.reference, elapsedSeconds]).object);

  static final _id_formatSameDayTime = jniAccessors.getStaticMethodIDOf(
      _classRef, "formatSameDayTime", "(JJII)Ljava/lang/CharSequence;");

  /// from: static public final java.lang.CharSequence formatSameDayTime(long then, long now, int dateStyle, int timeStyle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Format a date / time such that if the then is on the same day as now, it shows
  /// just the time and if it's a different day, it shows just the date.
  ///
  /// The parameters dateFormat and timeFormat should each be one of
  /// java.text.DateFormat\#DEFAULT,
  /// java.text.DateFormat\#FULL,
  /// java.text.DateFormat\#LONG,
  /// java.text.DateFormat\#MEDIUM
  /// or
  /// java.text.DateFormat\#SHORT
  ///@param then the date to format
  ///@param now the base time
  ///@param dateStyle how to format the date portion.
  ///@param timeStyle how to format the time portion.
  static jni.JniObject formatSameDayTime(
          int then, int now, int dateStyle, int timeStyle) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_formatSameDayTime,
          jni.JniType.objectType,
          [then, now, dateStyle, timeStyle]).object);

  static final _id_isToday =
      jniAccessors.getStaticMethodIDOf(_classRef, "isToday", "(J)Z");

  /// from: static public boolean isToday(long when)
  ///
  /// @return true if the supplied when is today else false
  static bool isToday(int when) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_isToday, jni.JniType.booleanType, [when]).boolean;

  static final _id_formatDateRange = jniAccessors.getStaticMethodIDOf(_classRef,
      "formatDateRange", "(Landroid/content/Context;JJI)Ljava/lang/String;");

  /// from: static public java.lang.String formatDateRange(android.content.Context context, long startMillis, long endMillis, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formats a date or a time range according to the local conventions.
  ///
  /// Note that this is a convenience method. Using it involves creating an
  /// internal java.util.Formatter instance on-the-fly, which is
  /// somewhat costly in terms of memory and time. This is probably acceptable
  /// if you use the method only rarely, but if you rely on it for formatting a
  /// large number of dates, consider creating and reusing your own
  /// java.util.Formatter instance and use the version of
  /// \#formatDateRange(Context, long, long, int) formatDateRange
  /// that takes a java.util.Formatter.
  ///@param context the context is required only if the time is shown
  ///@param startMillis the start time in UTC milliseconds
  ///@param endMillis the end time in UTC milliseconds
  ///@param flags a bit mask of options See
  /// \#formatDateRange(Context, Formatter, long, long, int, String) formatDateRange
  ///@return a string containing the formatted date/time range.
  static jni.JniString formatDateRange(context_.Context context,
          int startMillis, int endMillis, int flags) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_formatDateRange,
          jni.JniType.objectType,
          [context.reference, startMillis, endMillis, flags]).object);

  static final _id_formatDateRange1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "formatDateRange",
      "(Landroid/content/Context;Ljava/util/Formatter;JJI)Ljava/util/Formatter;");

  /// from: static public java.util.Formatter formatDateRange(android.content.Context context, java.util.Formatter formatter, long startMillis, long endMillis, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formats a date or a time range according to the local conventions.
  ///
  /// Note that this is a convenience method for formatting the date or
  /// time range in the local time zone. If you want to specify the time
  /// zone please use
  /// \#formatDateRange(Context, Formatter, long, long, int, String) formatDateRange.
  ///@param context the context is required only if the time is shown
  ///@param formatter the Formatter used for formatting the date range.
  /// Note: be sure to call setLength(0) on StringBuilder passed to
  /// the Formatter constructor unless you want the results to accumulate.
  ///@param startMillis the start time in UTC milliseconds
  ///@param endMillis the end time in UTC milliseconds
  ///@param flags a bit mask of options See
  /// \#formatDateRange(Context, Formatter, long, long, int, String) formatDateRange
  ///@return a string containing the formatted date/time range.
  static jni.JniObject formatDateRange1(context_.Context context,
          jni.JniObject formatter, int startMillis, int endMillis, int flags) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_formatDateRange1, jni.JniType.objectType, [
        context.reference,
        formatter.reference,
        startMillis,
        endMillis,
        flags
      ]).object);

  static final _id_formatDateRange2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "formatDateRange",
      "(Landroid/content/Context;Ljava/util/Formatter;JJILjava/lang/String;)Ljava/util/Formatter;");

  /// from: static public java.util.Formatter formatDateRange(android.content.Context context, java.util.Formatter formatter, long startMillis, long endMillis, int flags, java.lang.String timeZone)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formats a date or a time range according to the local conventions.
  ///
  ///
  /// Example output strings (date formats in these examples are shown using
  /// the US date format convention but that may change depending on the
  /// local settings):
  /// <ul>
  ///   <li>10:15am</li>
  ///   <li>3:00pm - 4:00pm</li>
  ///   <li>3pm - 4pm</li>
  ///   <li>3PM - 4PM</li>
  ///   <li>08:00 - 17:00</li>
  ///   <li>Oct 9</li>
  ///   <li>Tue, Oct 9</li>
  ///   <li>October 9, 2007</li>
  ///   <li>Oct 9 - 10</li>
  ///   <li>Oct 9 - 10, 2007</li>
  ///   <li>Oct 28 - Nov 3, 2007</li>
  ///   <li>Dec 31, 2007 - Jan 1, 2008</li>
  ///   <li>Oct 9, 8:00am - Oct 10, 5:00pm</li>
  ///   <li>12/31/2007 - 01/01/2008</li>
  /// </ul>
  ///
  ///
  /// The flags argument is a bitmask of options from the following list:
  ///
  /// <ul>
  ///   <li>FORMAT_SHOW_TIME</li>
  ///   <li>FORMAT_SHOW_WEEKDAY</li>
  ///   <li>FORMAT_SHOW_YEAR</li>
  ///   <li>FORMAT_SHOW_DATE</li>
  ///   <li>FORMAT_NO_MONTH_DAY</li>
  ///   <li>FORMAT_12HOUR</li>
  ///   <li>FORMAT_24HOUR</li>
  ///   <li>FORMAT_CAP_AMPM</li>
  ///   <li>FORMAT_NO_NOON</li>
  ///   <li>FORMAT_CAP_NOON</li>
  ///   <li>FORMAT_NO_MIDNIGHT</li>
  ///   <li>FORMAT_CAP_MIDNIGHT</li>
  ///   <li>FORMAT_UTC</li>
  ///   <li>FORMAT_ABBREV_TIME</li>
  ///   <li>FORMAT_ABBREV_WEEKDAY</li>
  ///   <li>FORMAT_ABBREV_MONTH</li>
  ///   <li>FORMAT_ABBREV_ALL</li>
  ///   <li>FORMAT_NUMERIC_DATE</li>
  /// </ul>
  ///
  ///
  /// If FORMAT_SHOW_TIME is set, the time is shown as part of the date range.
  /// If the start and end time are the same, then just the start time is
  /// shown.
  ///
  ///
  /// If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown.
  ///
  ///
  /// If FORMAT_SHOW_YEAR is set, then the year is always shown.
  /// If FORMAT_SHOW_YEAR is not set, then the year
  /// is shown only if it is different from the current year, or if the start
  /// and end dates fall on different years.
  ///
  ///
  /// Normally the date is shown unless the start and end day are the same.
  /// If FORMAT_SHOW_DATE is set, then the date is always shown, even for
  /// same day ranges.
  ///
  ///
  /// If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the
  /// month name will be shown, not the day of the month.  For example,
  /// "January, 2008" instead of "January 6 - 12, 2008".
  ///
  ///
  /// If FORMAT_CAP_AMPM is set and 12-hour time is used, then the "AM"
  /// and "PM" are capitalized.  You should not use this flag
  /// because in some locales these terms cannot be capitalized, and in
  /// many others it doesn't make sense to do so even though it is possible.
  ///
  ///
  /// If FORMAT_NO_NOON is set and 12-hour time is used, then "12pm" is
  /// shown instead of "noon".
  ///
  ///
  /// If FORMAT_CAP_NOON is set and 12-hour time is used, then "Noon" is
  /// shown instead of "noon".  You should probably not use this flag
  /// because in many locales it will not make sense to capitalize
  /// the term.
  ///
  ///
  /// If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then "12am" is
  /// shown instead of "midnight".
  ///
  ///
  /// If FORMAT_CAP_MIDNIGHT is set and 12-hour time is used, then "Midnight"
  /// is shown instead of "midnight".  You should probably not use this
  /// flag because in many locales it will not make sense to capitalize
  /// the term.
  ///
  ///
  /// If FORMAT_12HOUR is set and the time is shown, then the time is
  /// shown in the 12-hour time format. You should not normally set this.
  /// Instead, let the time format be chosen automatically according to the
  /// system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
  /// FORMAT_24HOUR takes precedence.
  ///
  ///
  /// If FORMAT_24HOUR is set and the time is shown, then the time is
  /// shown in the 24-hour time format. You should not normally set this.
  /// Instead, let the time format be chosen automatically according to the
  /// system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
  /// FORMAT_24HOUR takes precedence.
  ///
  ///
  /// If FORMAT_UTC is set, then the UTC time zone is used for the start
  /// and end milliseconds unless a time zone is specified. If a time zone
  /// is specified it will be used regardless of the FORMAT_UTC flag.
  ///
  ///
  /// If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the
  /// start and end times (if shown) are abbreviated by not showing the minutes
  /// if they are zero.  For example, instead of "3:00pm" the time would be
  /// abbreviated to "3pm".
  ///
  ///
  /// If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is
  /// abbreviated to a 3-letter string.
  ///
  ///
  /// If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated
  /// to a 3-letter string.
  ///
  ///
  /// If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown)
  /// are abbreviated to 3-letter strings.
  ///
  ///
  /// If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format
  /// instead of using the name of the month.  For example, "12/31/2008"
  /// instead of "December 31, 2008".
  ///
  ///
  /// If the end date ends at 12:00am at the beginning of a day, it is
  /// formatted as the end of the previous day in two scenarios:
  /// <ul>
  ///   <li>For single day events. This results in "8pm - midnight" instead of
  ///       "Nov 10, 8pm - Nov 11, 12am".</li>
  ///   <li>When the time is not displayed. This results in "Nov 10 - 11" for
  ///       an event with a start date of Nov 10 and an end date of Nov 12 at
  ///       00:00.</li>
  /// </ul>
  ///@param context the context is required only if the time is shown
  ///@param formatter the Formatter used for formatting the date range.
  /// Note: be sure to call setLength(0) on StringBuilder passed to
  /// the Formatter constructor unless you want the results to accumulate.
  ///@param startMillis the start time in UTC milliseconds
  ///@param endMillis the end time in UTC milliseconds
  ///@param flags a bit mask of options
  ///@param timeZone the time zone to compute the string in. Use null for local
  /// or if the FORMAT_UTC flag is being used.
  ///@return the formatter with the formatted date/time range appended to the string buffer.
  static jni.JniObject formatDateRange2(
          context_.Context context,
          jni.JniObject formatter,
          int startMillis,
          int endMillis,
          int flags,
          jni.JniString timeZone) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_formatDateRange2, jni.JniType.objectType, [
        context.reference,
        formatter.reference,
        startMillis,
        endMillis,
        flags,
        timeZone.reference
      ]).object);

  static final _id_formatDateTime = jniAccessors.getStaticMethodIDOf(_classRef,
      "formatDateTime", "(Landroid/content/Context;JI)Ljava/lang/String;");

  /// from: static public java.lang.String formatDateTime(android.content.Context context, long millis, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formats a date or a time according to the local conventions. There are
  /// lots of options that allow the caller to control, for example, if the
  /// time is shown, if the day of the week is shown, if the month name is
  /// abbreviated, if noon is shown instead of 12pm, and so on. For the
  /// complete list of options, see the documentation for
  /// \#formatDateRange.
  ///
  /// Example output strings (date formats in these examples are shown using
  /// the US date format convention but that may change depending on the
  /// local settings):
  /// <ul>
  ///   <li>10:15am</li>
  ///   <li>3:00pm</li>
  ///   <li>3pm</li>
  ///   <li>3PM</li>
  ///   <li>08:00</li>
  ///   <li>17:00</li>
  ///   <li>noon</li>
  ///   <li>Noon</li>
  ///   <li>midnight</li>
  ///   <li>Midnight</li>
  ///   <li>Oct 31</li>
  ///   <li>Oct 31, 2007</li>
  ///   <li>October 31, 2007</li>
  ///   <li>10am, Oct 31</li>
  ///   <li>17:00, Oct 31</li>
  ///   <li>Wed</li>
  ///   <li>Wednesday</li>
  ///   <li>10am, Wed, Oct 31</li>
  ///   <li>Wed, Oct 31</li>
  ///   <li>Wednesday, Oct 31</li>
  ///   <li>Wed, Oct 31, 2007</li>
  ///   <li>Wed, October 31</li>
  ///   <li>10/31/2007</li>
  /// </ul>
  ///@param context the context is required only if the time is shown
  ///@param millis a point in time in UTC milliseconds
  ///@param flags a bit mask of formatting options
  ///@return a string containing the formatted date/time.
  static jni.JniString formatDateTime(
          context_.Context context, int millis, int flags) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_formatDateTime,
          jni.JniType.objectType,
          [context.reference, millis, flags]).object);

  static final _id_getRelativeTimeSpanString3 =
      jniAccessors.getStaticMethodIDOf(_classRef, "getRelativeTimeSpanString",
          "(Landroid/content/Context;JZ)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getRelativeTimeSpanString(android.content.Context c, long millis, boolean withPreposition)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return a relative time string to display the time expressed by millis.  Times
  /// are counted starting at midnight, which means that assuming that the current
  /// time is March 31st, 0:30:
  /// <ul>
  ///   <li>"millis=0:10 today" will be displayed as "0:10"</li>
  ///   <li>"millis=11:30pm the day before" will be displayed as "Mar 30"</li>
  /// </ul>
  /// If the given millis is in a different year, then the full date is
  /// returned in numeric format (e.g., "10/12/2008").
  ///@param withPreposition If true, the string returned will include the correct
  /// preposition ("at 9:20am", "on 10/12/2008" or "on May 29").
  static jni.JniObject getRelativeTimeSpanString3(
          context_.Context c, int millis, bool withPreposition) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getRelativeTimeSpanString3,
          jni.JniType.objectType,
          [c.reference, millis, withPreposition]).object);

  static final _id_getRelativeTimeSpanString4 =
      jniAccessors.getStaticMethodIDOf(_classRef, "getRelativeTimeSpanString",
          "(Landroid/content/Context;J)Ljava/lang/CharSequence;");

  /// from: static public java.lang.CharSequence getRelativeTimeSpanString(android.content.Context c, long millis)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience function to return relative time string without preposition.
  ///@param c context for resources
  ///@param millis time in milliseconds
  ///@return CharSequence containing relative time.
  ///@see \#getRelativeTimeSpanString(Context, long, boolean)
  static jni.JniObject getRelativeTimeSpanString4(
          context_.Context c, int millis) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getRelativeTimeSpanString4,
          jni.JniType.objectType,
          [c.reference, millis]).object);
}
