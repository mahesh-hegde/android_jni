// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "TextDirectionHeuristic.dart" as textdirectionheuristic_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.text.BidiFormatter
///
/// Utility class for formatting text for display in a potentially opposite-directionality context
/// without garbling. The directionality of the context is set at formatter creation and the
/// directionality of the text can be either estimated or passed in when known.
///
/// To support versions lower than android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2,
/// you can use the support library's android.support.v4.text.BidiFormatter class.
///
/// These APIs provides the following functionality:
///
/// 1. Bidi Wrapping
/// When text in one language is mixed into a document in another, opposite-directionality language,
/// e.g. when an English business name is embedded in some Hebrew text, both the inserted string
/// and the text surrounding it may be displayed incorrectly unless the inserted string is explicitly
/// separated from the surrounding text in a "wrapper" that:
///
/// - Declares its directionality so that the string is displayed correctly. This can be done in
///   Unicode bidi formatting codes by \#unicodeWrap and similar methods.
///
/// - Isolates the string's directionality, so it does not unduly affect the surrounding content.
///   Currently, this can only be done using invisible Unicode characters of the same direction as
///   the context (LRM or RLM) in addition to the directionality declaration above, thus "resetting"
///   the directionality to that of the context. The "reset" may need to be done at both ends of the
///   string. Without "reset" after the string, the string will "stick" to a number or logically
///   separate opposite-direction text that happens to follow it in-line (even if separated by
///   neutral content like spaces and punctuation). Without "reset" before the string, the same can
///   happen there, but only with more opposite-direction text, not a number. One approach is to
///   "reset" the direction only after each string, on the theory that if the preceding opposite-
///   direction text is itself bidi-wrapped, the "reset" after it will prevent the sticking. (Doing
///   the "reset" only before each string definitely does not work because we do not want to require
///   bidi-wrapping numbers, and a bidi-wrapped opposite-direction string could be followed by a
///   number.) Still, the safest policy is to do the "reset" on both ends of each string, since RTL
///   message translations often contain untranslated Latin-script brand names and technical terms,
///   and one of these can be followed by a bidi-wrapped inserted value. On the other hand, when one
///   has such a message, it is best to do the "reset" manually in the message translation itself,
///   since the message's opposite-direction text could be followed by an inserted number, which we
///   would not bidi-wrap anyway. Thus, "reset" only after the string is the current default. In an
///   alternative to "reset", recent additions to the HTML, CSS, and Unicode standards allow the
///   isolation to be part of the directionality declaration. This form of isolation is better than
///   "reset" because it takes less space, does not require knowing the context directionality, has a
///   gentler effect than "reset", and protects both ends of the string. However, we do not yet allow
///   using it because required platforms do not yet support it.
///
/// Providing these wrapping services is the basic purpose of the bidi formatter.
///
/// 2. Directionality estimation
/// How does one know whether a string about to be inserted into surrounding text has the same
/// directionality? Well, in many cases, one knows that this must be the case when writing the code
/// doing the insertion, e.g. when a localized message is inserted into a localized page. In such
/// cases there is no need to involve the bidi formatter at all. In some other cases, it need not be
/// the same as the context, but is either constant (e.g. urls are always LTR) or otherwise known.
/// In the remaining cases, e.g. when the string is user-entered or comes from a database, the
/// language of the string (and thus its directionality) is not known a priori, and must be
/// estimated at run-time. The bidi formatter can do this automatically using the default
/// first-strong estimation algorithm. It can also be configured to use a custom directionality
/// estimation object.
class BidiFormatter extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/BidiFormatter");
  BidiFormatter.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getInstance", "()Landroid/text/BidiFormatter;");

  /// from: static public android.text.BidiFormatter getInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Factory for creating an instance of BidiFormatter for the default locale directionality.
  ///
  /// This does not create any new objects, and returns already existing static instances.
  static BidiFormatter getInstance() =>
      BidiFormatter.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getInstance, jni.JniType.objectType, []).object);

  static final _id_getInstance1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "getInstance", "(Z)Landroid/text/BidiFormatter;");

  /// from: static public android.text.BidiFormatter getInstance(boolean rtlContext)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Factory for creating an instance of BidiFormatter given the context directionality.
  ///
  /// This does not create any new objects, and returns already existing static instances.
  ///@param rtlContext Whether the context directionality is RTL.
  static BidiFormatter getInstance1(bool rtlContext) =>
      BidiFormatter.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getInstance1, jni.JniType.objectType, [rtlContext]).object);

  static final _id_getInstance2 = jniAccessors.getStaticMethodIDOf(_classRef,
      "getInstance", "(Ljava/util/Locale;)Landroid/text/BidiFormatter;");

  /// from: static public android.text.BidiFormatter getInstance(java.util.Locale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Factory for creating an instance of BidiFormatter given the context locale.
  ///
  /// This does not create any new objects, and returns already existing static instances.
  ///@param locale The context locale.
  static BidiFormatter getInstance2(jni.JniObject locale) =>
      BidiFormatter.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getInstance2, jni.JniType.objectType, [locale.reference]).object);

  static final _id_isRtlContext =
      jniAccessors.getMethodIDOf(_classRef, "isRtlContext", "()Z");

  /// from: public boolean isRtlContext()
  ///
  /// @return Whether the context directionality is RTL
  bool isRtlContext() => jniAccessors.callMethodWithArgs(
      reference, _id_isRtlContext, jni.JniType.booleanType, []).boolean;

  static final _id_getStereoReset =
      jniAccessors.getMethodIDOf(_classRef, "getStereoReset", "()Z");

  /// from: public boolean getStereoReset()
  ///
  /// @return Whether directionality "reset" should also be done before a string being
  /// bidi-wrapped, not just after it.
  bool getStereoReset() => jniAccessors.callMethodWithArgs(
      reference, _id_getStereoReset, jni.JniType.booleanType, []).boolean;

  static final _id_isRtl =
      jniAccessors.getMethodIDOf(_classRef, "isRtl", "(Ljava/lang/String;)Z");

  /// from: public boolean isRtl(java.lang.String str)
  ///
  /// Estimates the directionality of a string using the default text direction heuristic.
  ///@param str String whose directionality is to be estimated.
  ///@return true if {@code str}'s estimated overall directionality is RTL. Otherwise returns
  ///          false.
  bool isRtl(jni.JniString str) => jniAccessors.callMethodWithArgs(
      reference, _id_isRtl, jni.JniType.booleanType, [str.reference]).boolean;

  static final _id_isRtl1 = jniAccessors.getMethodIDOf(
      _classRef, "isRtl", "(Ljava/lang/CharSequence;)Z");

  /// from: public boolean isRtl(java.lang.CharSequence str)
  ///
  /// Operates like \#isRtl(String), but takes a CharSequence instead of a string
  ///@param str CharSequence whose directionality is to be estimated.
  ///@return true if {@code str}'s estimated overall directionality is RTL. Otherwise returns
  ///          false.
  bool isRtl1(jni.JniObject str) => jniAccessors.callMethodWithArgs(
      reference, _id_isRtl1, jni.JniType.booleanType, [str.reference]).boolean;

  static final _id_unicodeWrap = jniAccessors.getMethodIDOf(
      _classRef,
      "unicodeWrap",
      "(Ljava/lang/String;Landroid/text/TextDirectionHeuristic;Z)Ljava/lang/String;");

  /// from: public java.lang.String unicodeWrap(java.lang.String str, android.text.TextDirectionHeuristic heuristic, boolean isolate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formats a string of given directionality for use in plain-text output of the context
  /// directionality, so an opposite-directionality string is neither garbled nor garbles its
  /// surroundings. This makes use of Unicode bidi formatting characters.
  ///
  /// The algorithm: In case the given directionality doesn't match the context directionality, wraps
  /// the string with Unicode bidi formatting characters: RLE+{@code str}+PDF for RTL text, or
  /// LRE+{@code str}+PDF for LTR text.
  ///
  /// If {@code isolate}, directionally isolates the string so that it does not garble its
  /// surroundings. Currently, this is done by "resetting" the directionality after the string by
  /// appending a trailing Unicode bidi mark matching the context directionality (LRM or RLM) when
  /// either the overall directionality or the exit directionality of the string is opposite to
  /// that of the context. Unless the formatter was built using
  /// Builder\#stereoReset(boolean) with a {@code false} argument, also prepends a Unicode
  /// bidi mark matching the context directionality when either the overall directionality or the
  /// entry directionality of the string is opposite to that of the context. Note that as opposed
  /// to the overall directionality, the entry and exit directionalities are determined from the
  /// string itself.
  ///
  /// Does *not* do HTML-escaping.
  ///@param str The input string.
  /// This value may be {@code null}.
  ///@param heuristic The algorithm to be used to estimate the string's overall direction.
  ///        See TextDirectionHeuristics for pre-defined heuristics.
  ///@param isolate Whether to directionally isolate the string to prevent it from garbling the
  ///     content around it
  ///@return Input string after applying the above processing. {@code null} if {@code str} is
  ///     {@code null}.
  jni.JniString unicodeWrap(
          jni.JniString str,
          textdirectionheuristic_.TextDirectionHeuristic heuristic,
          bool isolate) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_unicodeWrap,
          jni.JniType.objectType,
          [str.reference, heuristic.reference, isolate]).object);

  static final _id_unicodeWrap1 = jniAccessors.getMethodIDOf(
      _classRef,
      "unicodeWrap",
      "(Ljava/lang/CharSequence;Landroid/text/TextDirectionHeuristic;Z)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence unicodeWrap(java.lang.CharSequence str, android.text.TextDirectionHeuristic heuristic, boolean isolate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Operates like \#unicodeWrap(String, TextDirectionHeuristic, boolean), but takes a
  /// CharSequence instead of a string
  ///@param str The input CharSequence.
  /// This value may be {@code null}.
  ///@param heuristic The algorithm to be used to estimate the CharSequence's overall direction.
  ///        See TextDirectionHeuristics for pre-defined heuristics.
  ///@param isolate Whether to directionally isolate the CharSequence to prevent it from garbling
  ///     the content around it
  ///@return Input CharSequence after applying the above processing. {@code null} if {@code str}
  ///     is {@code null}.
  jni.JniObject unicodeWrap1(
          jni.JniObject str,
          textdirectionheuristic_.TextDirectionHeuristic heuristic,
          bool isolate) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_unicodeWrap1,
          jni.JniType.objectType,
          [str.reference, heuristic.reference, isolate]).object);

  static final _id_unicodeWrap2 = jniAccessors.getMethodIDOf(
      _classRef,
      "unicodeWrap",
      "(Ljava/lang/String;Landroid/text/TextDirectionHeuristic;)Ljava/lang/String;");

  /// from: public java.lang.String unicodeWrap(java.lang.String str, android.text.TextDirectionHeuristic heuristic)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Operates like \#unicodeWrap(String, TextDirectionHeuristic, boolean), but assumes
  /// {@code isolate} is true.
  ///@param str The input string.
  ///@param heuristic The algorithm to be used to estimate the string's overall direction.
  ///        See TextDirectionHeuristics for pre-defined heuristics.
  ///@return Input string after applying the above processing.
  jni.JniString unicodeWrap2(jni.JniString str,
          textdirectionheuristic_.TextDirectionHeuristic heuristic) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_unicodeWrap2,
          jni.JniType.objectType,
          [str.reference, heuristic.reference]).object);

  static final _id_unicodeWrap3 = jniAccessors.getMethodIDOf(
      _classRef,
      "unicodeWrap",
      "(Ljava/lang/CharSequence;Landroid/text/TextDirectionHeuristic;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence unicodeWrap(java.lang.CharSequence str, android.text.TextDirectionHeuristic heuristic)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Operates like \#unicodeWrap(CharSequence, TextDirectionHeuristic, boolean), but
  /// assumes {@code isolate} is true.
  ///@param str The input CharSequence.
  ///@param heuristic The algorithm to be used to estimate the CharSequence's overall direction.
  ///        See TextDirectionHeuristics for pre-defined heuristics.
  ///@return Input CharSequence after applying the above processing.
  jni.JniObject unicodeWrap3(jni.JniObject str,
          textdirectionheuristic_.TextDirectionHeuristic heuristic) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_unicodeWrap3,
          jni.JniType.objectType,
          [str.reference, heuristic.reference]).object);

  static final _id_unicodeWrap4 = jniAccessors.getMethodIDOf(
      _classRef, "unicodeWrap", "(Ljava/lang/String;Z)Ljava/lang/String;");

  /// from: public java.lang.String unicodeWrap(java.lang.String str, boolean isolate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Operates like \#unicodeWrap(String, TextDirectionHeuristic, boolean), but uses the
  /// formatter's default direction estimation algorithm.
  ///@param str The input string.
  ///@param isolate Whether to directionally isolate the string to prevent it from garbling the
  ///     content around it
  ///@return Input string after applying the above processing.
  jni.JniString unicodeWrap4(jni.JniString str, bool isolate) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_unicodeWrap4,
          jni.JniType.objectType,
          [str.reference, isolate]).object);

  static final _id_unicodeWrap5 = jniAccessors.getMethodIDOf(_classRef,
      "unicodeWrap", "(Ljava/lang/CharSequence;Z)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence unicodeWrap(java.lang.CharSequence str, boolean isolate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Operates like \#unicodeWrap(CharSequence, TextDirectionHeuristic, boolean), but uses
  /// the formatter's default direction estimation algorithm.
  ///@param str The input CharSequence.
  ///@param isolate Whether to directionally isolate the CharSequence to prevent it from garbling
  ///     the content around it
  ///@return Input CharSequence after applying the above processing.
  jni.JniObject unicodeWrap5(jni.JniObject str, bool isolate) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_unicodeWrap5,
          jni.JniType.objectType,
          [str.reference, isolate]).object);

  static final _id_unicodeWrap6 = jniAccessors.getMethodIDOf(
      _classRef, "unicodeWrap", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String unicodeWrap(java.lang.String str)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Operates like \#unicodeWrap(String, TextDirectionHeuristic, boolean), but uses the
  /// formatter's default direction estimation algorithm and assumes {@code isolate} is true.
  ///@param str The input string.
  ///@return Input string after applying the above processing.
  jni.JniString unicodeWrap6(jni.JniString str) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_unicodeWrap6, jni.JniType.objectType, [str.reference]).object);

  static final _id_unicodeWrap7 = jniAccessors.getMethodIDOf(_classRef,
      "unicodeWrap", "(Ljava/lang/CharSequence;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence unicodeWrap(java.lang.CharSequence str)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Operates like \#unicodeWrap(CharSequence, TextDirectionHeuristic, boolean), but uses
  /// the formatter's default direction estimation algorithm and assumes {@code isolate} is true.
  ///@param str The input CharSequence.
  ///@return Input CharSequence after applying the above processing.
  jni.JniObject unicodeWrap7(jni.JniObject str) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_unicodeWrap7, jni.JniType.objectType, [str.reference]).object);
}

/// from: android.text.BidiFormatter$Builder
///
/// A class for building a BidiFormatter with non-default options.
class BidiFormatter_Builder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/BidiFormatter\$Builder");
  BidiFormatter_Builder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor.
  BidiFormatter_Builder()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Z)V");

  /// from: public void <init>(boolean rtlContext)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor.
  ///@param rtlContext Whether the context directionality is RTL.
  BidiFormatter_Builder.ctor1(bool rtlContext)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [rtlContext]).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/util/Locale;)V");

  /// from: public void <init>(java.util.Locale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor.
  ///@param locale The context locale.
  BidiFormatter_Builder.ctor2(jni.JniObject locale)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [locale.reference]).object);

  static final _id_stereoReset = jniAccessors.getMethodIDOf(
      _classRef, "stereoReset", "(Z)Landroid/text/BidiFormatter\$Builder;");

  /// from: public android.text.BidiFormatter.Builder stereoReset(boolean stereoReset)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specifies whether the BidiFormatter to be built should also "reset" directionality before
  /// a string being bidi-wrapped, not just after it. The default is true.
  BidiFormatter_Builder stereoReset(bool stereoReset) =>
      BidiFormatter_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_stereoReset, jni.JniType.objectType, [stereoReset]).object);

  static final _id_setTextDirectionHeuristic = jniAccessors.getMethodIDOf(
      _classRef,
      "setTextDirectionHeuristic",
      "(Landroid/text/TextDirectionHeuristic;)Landroid/text/BidiFormatter\$Builder;");

  /// from: public android.text.BidiFormatter.Builder setTextDirectionHeuristic(android.text.TextDirectionHeuristic heuristic)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specifies the default directionality estimation algorithm to be used by the BidiFormatter.
  /// By default, uses the first-strong heuristic.
  ///@param heuristic the {@code TextDirectionHeuristic} to use.
  ///@return the builder itself.
  BidiFormatter_Builder setTextDirectionHeuristic(
          textdirectionheuristic_.TextDirectionHeuristic heuristic) =>
      BidiFormatter_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setTextDirectionHeuristic,
          jni.JniType.objectType,
          [heuristic.reference]).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/text/BidiFormatter;");

  /// from: public android.text.BidiFormatter build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return A BidiFormatter with the specified options.
  BidiFormatter build() =>
      BidiFormatter.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_build, jni.JniType.objectType, []).object);
}
