// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Spanned.dart" as spanned_;

import "Editable.dart" as editable_;

import "../graphics/drawable/Drawable.dart" as drawable_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.text.Html
///
/// This class processes HTML strings into displayable styled text.
/// Not all HTML tags are supported.
class Html extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/text/Html");
  Html.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int FROM_HTML_MODE_COMPACT
  ///
  /// Flags for \#fromHtml(String, int, ImageGetter, TagHandler): Separate block-level
  /// elements with line breaks (single newline character) in between. This inverts the
  /// Spanned to HTML string conversion done with the option
  /// \#TO_HTML_PARAGRAPH_LINES_INDIVIDUAL.
  static const FROM_HTML_MODE_COMPACT = 63;

  /// from: static public final int FROM_HTML_MODE_LEGACY
  ///
  /// Flags for \#fromHtml(String, int, ImageGetter, TagHandler): Separate block-level
  /// elements with blank lines (two newline characters) in between. This is the legacy behavior
  /// prior to N.
  static const FROM_HTML_MODE_LEGACY = 0;

  /// from: static public final int FROM_HTML_OPTION_USE_CSS_COLORS
  ///
  /// Flag indicating that CSS color values should be used instead of those defined in
  /// Color.
  static const FROM_HTML_OPTION_USE_CSS_COLORS = 256;

  /// from: static public final int FROM_HTML_SEPARATOR_LINE_BREAK_BLOCKQUOTE
  ///
  /// Flag indicating that texts inside &lt;blockquote&gt; elements will be separated from other
  /// texts with one newline character by default.
  static const FROM_HTML_SEPARATOR_LINE_BREAK_BLOCKQUOTE = 32;

  /// from: static public final int FROM_HTML_SEPARATOR_LINE_BREAK_DIV
  ///
  /// Flag indicating that texts inside &lt;div&gt; elements will be separated from other texts
  /// with one newline character by default.
  static const FROM_HTML_SEPARATOR_LINE_BREAK_DIV = 16;

  /// from: static public final int FROM_HTML_SEPARATOR_LINE_BREAK_HEADING
  ///
  /// Flag indicating that texts inside &lt;h1&gt;~&lt;h6&gt; elements will be separated from
  /// other texts with one newline character by default.
  static const FROM_HTML_SEPARATOR_LINE_BREAK_HEADING = 2;

  /// from: static public final int FROM_HTML_SEPARATOR_LINE_BREAK_LIST
  ///
  /// Flag indicating that texts inside &lt;ul&gt; elements will be separated from other texts
  /// with one newline character by default.
  static const FROM_HTML_SEPARATOR_LINE_BREAK_LIST = 8;

  /// from: static public final int FROM_HTML_SEPARATOR_LINE_BREAK_LIST_ITEM
  ///
  /// Flag indicating that texts inside &lt;li&gt; elements will be separated from other texts
  /// with one newline character by default.
  static const FROM_HTML_SEPARATOR_LINE_BREAK_LIST_ITEM = 4;

  /// from: static public final int FROM_HTML_SEPARATOR_LINE_BREAK_PARAGRAPH
  ///
  /// Flag indicating that texts inside &lt;p&gt; elements will be separated from other texts with
  /// one newline character by default.
  static const FROM_HTML_SEPARATOR_LINE_BREAK_PARAGRAPH = 1;

  /// from: static public final int TO_HTML_PARAGRAPH_LINES_CONSECUTIVE
  ///
  /// Option for \#toHtml(Spanned, int): Wrap consecutive lines of text delimited by '\n'
  /// inside &lt;p&gt; elements. BulletSpans are ignored.
  static const TO_HTML_PARAGRAPH_LINES_CONSECUTIVE = 0;

  /// from: static public final int TO_HTML_PARAGRAPH_LINES_INDIVIDUAL
  ///
  /// Option for \#toHtml(Spanned, int): Wrap each line of text delimited by '\n' inside a
  /// &lt;p&gt; or a &lt;li&gt; element. This allows ParagraphStyles attached to be
  /// encoded as CSS styles within the corresponding &lt;p&gt; or &lt;li&gt; element.
  static const TO_HTML_PARAGRAPH_LINES_INDIVIDUAL = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Html()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_fromHtml = jniAccessors.getStaticMethodIDOf(
      _classRef, "fromHtml", "(Ljava/lang/String;)Landroid/text/Spanned;");

  /// from: static public android.text.Spanned fromHtml(java.lang.String source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns displayable styled text from the provided HTML string with the legacy flags
  /// \#FROM_HTML_MODE_LEGACY.
  ///@deprecated use \#fromHtml(String, int) instead.
  static spanned_.Spanned fromHtml(jni.JniString source) =>
      spanned_.Spanned.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_fromHtml, jni.JniType.objectType, [source.reference]).object);

  static final _id_fromHtml1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "fromHtml", "(Ljava/lang/String;I)Landroid/text/Spanned;");

  /// from: static public android.text.Spanned fromHtml(java.lang.String source, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns displayable styled text from the provided HTML string. Any &lt;img&gt; tags in the
  /// HTML will display as a generic replacement image which your program can then go through and
  /// replace with real images.
  ///
  /// This uses TagSoup to handle real HTML, including all of the brokenness found in the wild.
  static spanned_.Spanned fromHtml1(jni.JniString source, int flags) =>
      spanned_.Spanned.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_fromHtml1,
          jni.JniType.objectType,
          [source.reference, flags]).object);

  static final _id_fromHtml2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "fromHtml",
      "(Ljava/lang/String;Landroid/text/Html\$ImageGetter;Landroid/text/Html\$TagHandler;)Landroid/text/Spanned;");

  /// from: static public android.text.Spanned fromHtml(java.lang.String source, android.text.Html.ImageGetter imageGetter, android.text.Html.TagHandler tagHandler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns displayable styled text from the provided HTML string with the legacy flags
  /// \#FROM_HTML_MODE_LEGACY.
  ///@deprecated use \#fromHtml(String, int, ImageGetter, TagHandler) instead.
  static spanned_.Spanned fromHtml2(jni.JniString source,
          Html_ImageGetter imageGetter, Html_TagHandler tagHandler) =>
      spanned_.Spanned.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_fromHtml2, jni.JniType.objectType, [
        source.reference,
        imageGetter.reference,
        tagHandler.reference
      ]).object);

  static final _id_fromHtml3 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "fromHtml",
      "(Ljava/lang/String;ILandroid/text/Html\$ImageGetter;Landroid/text/Html\$TagHandler;)Landroid/text/Spanned;");

  /// from: static public android.text.Spanned fromHtml(java.lang.String source, int flags, android.text.Html.ImageGetter imageGetter, android.text.Html.TagHandler tagHandler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns displayable styled text from the provided HTML string. Any &lt;img&gt; tags in the
  /// HTML will use the specified ImageGetter to request a representation of the image (use null
  /// if you don't want this) and the specified TagHandler to handle unknown tags (specify null if
  /// you don't want this).
  ///
  /// This uses TagSoup to handle real HTML, including all of the brokenness found in the wild.
  static spanned_.Spanned fromHtml3(jni.JniString source, int flags,
          Html_ImageGetter imageGetter, Html_TagHandler tagHandler) =>
      spanned_.Spanned.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_fromHtml3, jni.JniType.objectType, [
        source.reference,
        flags,
        imageGetter.reference,
        tagHandler.reference
      ]).object);

  static final _id_toHtml = jniAccessors.getStaticMethodIDOf(
      _classRef, "toHtml", "(Landroid/text/Spanned;)Ljava/lang/String;");

  /// from: static public java.lang.String toHtml(android.text.Spanned text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated use \#toHtml(Spanned, int) instead.
  static jni.JniString toHtml(spanned_.Spanned text) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_toHtml, jni.JniType.objectType, [text.reference]).object);

  static final _id_toHtml1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "toHtml", "(Landroid/text/Spanned;I)Ljava/lang/String;");

  /// from: static public java.lang.String toHtml(android.text.Spanned text, int option)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an HTML representation of the provided Spanned text. A best effort is
  /// made to add HTML tags corresponding to spans. Also note that HTML metacharacters
  /// (such as "&lt;" and "&amp;") within the input text are escaped.
  ///@param text input text to convert
  ///@param option one of \#TO_HTML_PARAGRAPH_LINES_CONSECUTIVE or
  ///     \#TO_HTML_PARAGRAPH_LINES_INDIVIDUAL
  ///@return string containing input converted to HTML
  static jni.JniString toHtml1(spanned_.Spanned text, int option) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_toHtml1,
          jni.JniType.objectType,
          [text.reference, option]).object);

  static final _id_escapeHtml = jniAccessors.getStaticMethodIDOf(
      _classRef, "escapeHtml", "(Ljava/lang/CharSequence;)Ljava/lang/String;");

  /// from: static public java.lang.String escapeHtml(java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an HTML escaped representation of the given plain text.
  static jni.JniString escapeHtml(jni.JniObject text) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_escapeHtml, jni.JniType.objectType, [text.reference]).object);
}

/// from: android.text.Html$TagHandler
///
/// Is notified when HTML tags are encountered that the parser does
/// not know how to interpret.
class Html_TagHandler extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/Html\$TagHandler");
  Html_TagHandler.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_handleTag = jniAccessors.getMethodIDOf(
      _classRef,
      "handleTag",
      "(ZLjava/lang/String;Landroid/text/Editable;Lorg/xml/sax/XMLReader;)V");

  /// from: public abstract void handleTag(boolean opening, java.lang.String tag, android.text.Editable output, org.xml.sax.XMLReader xmlReader)
  ///
  /// This method will be called whenn the HTML parser encounters
  /// a tag that it does not know how to interpret.
  void handleTag(bool opening, jni.JniString tag, editable_.Editable output,
          jni.JniObject xmlReader) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_handleTag, jni.JniType.voidType, [
        opening,
        tag.reference,
        output.reference,
        xmlReader.reference
      ]).check();
}

/// from: android.text.Html$ImageGetter
///
/// Retrieves images for HTML &lt;img&gt; tags.
class Html_ImageGetter extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/Html\$ImageGetter");
  Html_ImageGetter.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getDrawable = jniAccessors.getMethodIDOf(
      _classRef,
      "getDrawable",
      "(Ljava/lang/String;)Landroid/graphics/drawable/Drawable;");

  /// from: public abstract android.graphics.drawable.Drawable getDrawable(java.lang.String source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method is called when the HTML parser encounters an
  /// &lt;img&gt; tag.  The <code>source</code> argument is the
  /// string from the "src" attribute; the return value should be
  /// a Drawable representation of the image or <code>null</code>
  /// for a generic replacement image.  Make sure you call
  /// setBounds() on your Drawable if it doesn't already have
  /// its bounds set.
  drawable_.Drawable getDrawable(jni.JniString source) =>
      drawable_.Drawable.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDrawable, jni.JniType.objectType, [source.reference]).object);
}
