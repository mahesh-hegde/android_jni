// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "TextPaint.dart" as textpaint_;

import "../graphics/Canvas.dart" as canvas_;

import "../graphics/Path.dart" as path_;

import "../graphics/Paint.dart" as paint_;

import "../graphics/Rect.dart" as rect_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.text.Layout
///
/// A base class that manages text layout in visual elements on
/// the screen.
/// For text that will be edited, use a DynamicLayout,
/// which will be updated as the text changes.
/// For text that will not change, use a StaticLayout.
class Layout extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/text/Layout");
  Layout.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int BREAK_STRATEGY_BALANCED
  ///
  /// Value for break strategy indicating balanced line breaking. The breaks are chosen to
  /// make all lines as close to the same length as possible, including automatic hyphenation.
  static const BREAK_STRATEGY_BALANCED = 2;

  /// from: static public final int BREAK_STRATEGY_HIGH_QUALITY
  ///
  /// Value for break strategy indicating high quality line breaking, including automatic
  /// hyphenation and doing whole-paragraph optimization of line breaks.
  static const BREAK_STRATEGY_HIGH_QUALITY = 1;

  /// from: static public final int BREAK_STRATEGY_SIMPLE
  ///
  /// Value for break strategy indicating simple line breaking. Automatic hyphens are not added
  /// (though soft hyphens are respected), and modifying text generally doesn't affect the layout
  /// before it (which yields a more consistent user experience when editing), but layout may not
  /// be the highest quality.
  static const BREAK_STRATEGY_SIMPLE = 0;

  /// from: static public final float DEFAULT_LINESPACING_ADDITION
  static const DEFAULT_LINESPACING_ADDITION = 0.0;

  /// from: static public final float DEFAULT_LINESPACING_MULTIPLIER
  static const DEFAULT_LINESPACING_MULTIPLIER = 1.0;

  /// from: static public final int DIR_LEFT_TO_RIGHT
  static const DIR_LEFT_TO_RIGHT = 1;

  /// from: static public final int DIR_RIGHT_TO_LEFT
  static const DIR_RIGHT_TO_LEFT = -1;

  /// from: static public final int HYPHENATION_FREQUENCY_FULL
  ///
  /// Value for hyphenation frequency indicating the full amount of automatic hyphenation, typical
  /// in typography. Useful for running text and where it's important to put the maximum amount of
  /// text in a screen with limited space.
  static const HYPHENATION_FREQUENCY_FULL = 2;

  /// from: static public final int HYPHENATION_FREQUENCY_NONE
  ///
  /// Value for hyphenation frequency indicating no automatic hyphenation. Useful
  /// for backward compatibility, and for cases where the automatic hyphenation algorithm results
  /// in incorrect hyphenation. Mid-word breaks may still happen when a word is wider than the
  /// layout and there is otherwise no valid break. Soft hyphens are ignored and will not be used
  /// as suggestions for potential line breaks.
  static const HYPHENATION_FREQUENCY_NONE = 0;

  /// from: static public final int HYPHENATION_FREQUENCY_NORMAL
  ///
  /// Value for hyphenation frequency indicating a light amount of automatic hyphenation, which
  /// is a conservative default. Useful for informal cases, such as short sentences or chat
  /// messages.
  static const HYPHENATION_FREQUENCY_NORMAL = 1;

  /// from: static public final int JUSTIFICATION_MODE_INTER_WORD
  ///
  /// Value for justification mode indicating the text is justified by stretching word spacing.
  static const JUSTIFICATION_MODE_INTER_WORD = 1;

  /// from: static public final int JUSTIFICATION_MODE_NONE
  ///
  /// Value for justification mode indicating no justification.
  static const JUSTIFICATION_MODE_NONE = 0;

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/CharSequence;Landroid/text/TextPaint;ILandroid/text/Layout\$Alignment;FF)V");

  /// from: protected void <init>(java.lang.CharSequence text, android.text.TextPaint paint, int width, android.text.Layout.Alignment align, float spacingMult, float spacingAdd)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Subclasses of Layout use this constructor to set the display text,
  /// width, and other standard properties.
  ///@param text the text to render
  ///@param paint the default paint for the layout.  Styles can override
  /// various attributes of the paint.
  ///@param width the wrapping width for the text.
  ///@param align whether to left, right, or center the text.  Styles can
  /// override the alignment.
  ///@param spacingMult factor by which to scale the font size to get the
  /// default line spacing
  ///@param spacingAdd amount to add to the default line spacing
  Layout(jni.JniObject text, textpaint_.TextPaint paint, int width,
      Layout_Alignment align, double spacingMult, double spacingAdd)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [
          text.reference,
          paint.reference,
          width,
          align.reference,
          spacingMult,
          spacingAdd
        ]).object);

  static final _id_getDesiredWidth = jniAccessors.getStaticMethodIDOf(_classRef,
      "getDesiredWidth", "(Ljava/lang/CharSequence;Landroid/text/TextPaint;)F");

  /// from: static public float getDesiredWidth(java.lang.CharSequence source, android.text.TextPaint paint)
  ///
  /// Return how wide a layout must be in order to display the specified text with one line per
  /// paragraph.
  ///
  /// As of O, Uses
  /// TextDirectionHeuristics\#FIRSTSTRONG_LTR as the default text direction heuristics. In
  /// the earlier versions uses TextDirectionHeuristics\#LTR as the default.
  ///
  static double getDesiredWidth(
          jni.JniObject source, textpaint_.TextPaint paint) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getDesiredWidth,
          jni.JniType.floatType, [source.reference, paint.reference]).float;

  static final _id_getDesiredWidth1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getDesiredWidth",
      "(Ljava/lang/CharSequence;IILandroid/text/TextPaint;)F");

  /// from: static public float getDesiredWidth(java.lang.CharSequence source, int start, int end, android.text.TextPaint paint)
  ///
  /// Return how wide a layout must be in order to display the specified text slice with one
  /// line per paragraph.
  ///
  /// As of O, Uses
  /// TextDirectionHeuristics\#FIRSTSTRONG_LTR as the default text direction heuristics. In
  /// the earlier versions uses TextDirectionHeuristics\#LTR as the default.
  ///
  static double getDesiredWidth1(jni.JniObject source, int start, int end,
          textpaint_.TextPaint paint) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getDesiredWidth1,
          jni.JniType.floatType,
          [source.reference, start, end, paint.reference]).float;

  static final _id_draw = jniAccessors.getMethodIDOf(
      _classRef, "draw", "(Landroid/graphics/Canvas;)V");

  /// from: public void draw(android.graphics.Canvas c)
  ///
  /// Draw this Layout on the specified Canvas.
  void draw(canvas_.Canvas c) => jniAccessors.callMethodWithArgs(
      reference, _id_draw, jni.JniType.voidType, [c.reference]).check();

  static final _id_draw1 = jniAccessors.getMethodIDOf(_classRef, "draw",
      "(Landroid/graphics/Canvas;Landroid/graphics/Path;Landroid/graphics/Paint;I)V");

  /// from: public void draw(android.graphics.Canvas canvas, android.graphics.Path highlight, android.graphics.Paint highlightPaint, int cursorOffsetVertical)
  ///
  /// Draw this Layout on the specified canvas, with the highlight path drawn
  /// between the background and the text.
  ///@param canvas the canvas
  ///@param highlight the path of the highlight or cursor; can be null
  ///@param highlightPaint the paint for the highlight
  ///@param cursorOffsetVertical the amount to temporarily translate the
  ///        canvas while rendering the highlight
  void draw1(canvas_.Canvas canvas, path_.Path highlight,
          paint_.Paint highlightPaint, int cursorOffsetVertical) =>
      jniAccessors
          .callMethodWithArgs(reference, _id_draw1, jni.JniType.voidType, [
        canvas.reference,
        highlight.reference,
        highlightPaint.reference,
        cursorOffsetVertical
      ]).check();

  static final _id_getText = jniAccessors.getMethodIDOf(
      _classRef, "getText", "()Ljava/lang/CharSequence;");

  /// from: public final java.lang.CharSequence getText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the text that is displayed by this Layout.
  jni.JniObject getText() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getText, jni.JniType.objectType, []).object);

  static final _id_getPaint = jniAccessors.getMethodIDOf(
      _classRef, "getPaint", "()Landroid/text/TextPaint;");

  /// from: public final android.text.TextPaint getPaint()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the base Paint properties for this layout.
  /// Do NOT change the paint, which may result in funny
  /// drawing for this layout.
  textpaint_.TextPaint getPaint() =>
      textpaint_.TextPaint.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPaint, jni.JniType.objectType, []).object);

  static final _id_getWidth =
      jniAccessors.getMethodIDOf(_classRef, "getWidth", "()I");

  /// from: public final int getWidth()
  ///
  /// Return the width of this layout.
  int getWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getWidth, jni.JniType.intType, []).integer;

  static final _id_getEllipsizedWidth =
      jniAccessors.getMethodIDOf(_classRef, "getEllipsizedWidth", "()I");

  /// from: public int getEllipsizedWidth()
  ///
  /// Return the width to which this Layout is ellipsizing, or
  /// \#getWidth if it is not doing anything special.
  int getEllipsizedWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getEllipsizedWidth, jni.JniType.intType, []).integer;

  static final _id_increaseWidthTo =
      jniAccessors.getMethodIDOf(_classRef, "increaseWidthTo", "(I)V");

  /// from: public final void increaseWidthTo(int wid)
  ///
  /// Increase the width of this layout to the specified width.
  /// Be careful to use this only when you know it is appropriate&mdash;
  /// it does not cause the text to reflow to use the full new width.
  void increaseWidthTo(int wid) => jniAccessors.callMethodWithArgs(
      reference, _id_increaseWidthTo, jni.JniType.voidType, [wid]).check();

  static final _id_getHeight =
      jniAccessors.getMethodIDOf(_classRef, "getHeight", "()I");

  /// from: public int getHeight()
  ///
  /// Return the total height of this layout.
  int getHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeight, jni.JniType.intType, []).integer;

  static final _id_getAlignment = jniAccessors.getMethodIDOf(
      _classRef, "getAlignment", "()Landroid/text/Layout\$Alignment;");

  /// from: public final android.text.Layout.Alignment getAlignment()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the base alignment of this layout.
  Layout_Alignment getAlignment() =>
      Layout_Alignment.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAlignment, jni.JniType.objectType, []).object);

  static final _id_getSpacingMultiplier =
      jniAccessors.getMethodIDOf(_classRef, "getSpacingMultiplier", "()F");

  /// from: public final float getSpacingMultiplier()
  ///
  /// Return what the text height is multiplied by to get the line height.
  double getSpacingMultiplier() => jniAccessors.callMethodWithArgs(
      reference, _id_getSpacingMultiplier, jni.JniType.floatType, []).float;

  static final _id_getSpacingAdd =
      jniAccessors.getMethodIDOf(_classRef, "getSpacingAdd", "()F");

  /// from: public final float getSpacingAdd()
  ///
  /// Return the number of units of leading that are added to each line.
  double getSpacingAdd() => jniAccessors.callMethodWithArgs(
      reference, _id_getSpacingAdd, jni.JniType.floatType, []).float;

  static final _id_getLineCount =
      jniAccessors.getMethodIDOf(_classRef, "getLineCount", "()I");

  /// from: public abstract int getLineCount()
  ///
  /// Return the number of lines of text in this layout.
  int getLineCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getLineCount, jni.JniType.intType, []).integer;

  static final _id_getLineBounds = jniAccessors.getMethodIDOf(
      _classRef, "getLineBounds", "(ILandroid/graphics/Rect;)I");

  /// from: public int getLineBounds(int line, android.graphics.Rect bounds)
  ///
  /// Return the baseline for the specified line (0&hellip;getLineCount() - 1)
  /// If bounds is not null, return the top, left, right, bottom extents
  /// of the specified line in it.
  ///@param line which line to examine (0..getLineCount() - 1)
  ///@param bounds Optional. If not null, it returns the extent of the line
  ///@return the Y-coordinate of the baseline
  int getLineBounds(int line, rect_.Rect bounds) =>
      jniAccessors.callMethodWithArgs(reference, _id_getLineBounds,
          jni.JniType.intType, [line, bounds.reference]).integer;

  static final _id_getLineTop =
      jniAccessors.getMethodIDOf(_classRef, "getLineTop", "(I)I");

  /// from: public abstract int getLineTop(int line)
  ///
  /// Return the vertical position of the top of the specified line
  /// (0&hellip;getLineCount()).
  /// If the specified line is equal to the line count, returns the
  /// bottom of the last line.
  int getLineTop(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineTop, jni.JniType.intType, [line]).integer;

  static final _id_getLineDescent =
      jniAccessors.getMethodIDOf(_classRef, "getLineDescent", "(I)I");

  /// from: public abstract int getLineDescent(int line)
  ///
  /// Return the descent of the specified line(0&hellip;getLineCount() - 1).
  int getLineDescent(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineDescent, jni.JniType.intType, [line]).integer;

  static final _id_getLineStart =
      jniAccessors.getMethodIDOf(_classRef, "getLineStart", "(I)I");

  /// from: public abstract int getLineStart(int line)
  ///
  /// Return the text offset of the beginning of the specified line (
  /// 0&hellip;getLineCount()). If the specified line is equal to the line
  /// count, returns the length of the text.
  int getLineStart(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineStart, jni.JniType.intType, [line]).integer;

  static final _id_getParagraphDirection =
      jniAccessors.getMethodIDOf(_classRef, "getParagraphDirection", "(I)I");

  /// from: public abstract int getParagraphDirection(int line)
  ///
  /// Returns the primary directionality of the paragraph containing the
  /// specified line, either 1 for left-to-right lines, or -1 for right-to-left
  /// lines (see \#DIR_LEFT_TO_RIGHT, \#DIR_RIGHT_TO_LEFT).
  int getParagraphDirection(int line) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getParagraphDirection,
      jni.JniType.intType,
      [line]).integer;

  static final _id_getLineContainsTab =
      jniAccessors.getMethodIDOf(_classRef, "getLineContainsTab", "(I)Z");

  /// from: public abstract boolean getLineContainsTab(int line)
  ///
  /// Returns whether the specified line contains one or more
  /// characters that need to be handled specially, like tabs.
  bool getLineContainsTab(int line) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getLineContainsTab,
      jni.JniType.booleanType,
      [line]).boolean;

  static final _id_getLineDirections = jniAccessors.getMethodIDOf(
      _classRef, "getLineDirections", "(I)Landroid/text/Layout\$Directions;");

  /// from: public abstract android.text.Layout.Directions getLineDirections(int line)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the directional run information for the specified line.
  /// The array alternates counts of characters in left-to-right
  /// and right-to-left segments of the line.
  ///
  /// NOTE: this is inadequate to support bidirectional text, and will change.
  Layout_Directions getLineDirections(int line) =>
      Layout_Directions.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getLineDirections, jni.JniType.objectType, [line]).object);

  static final _id_getTopPadding =
      jniAccessors.getMethodIDOf(_classRef, "getTopPadding", "()I");

  /// from: public abstract int getTopPadding()
  ///
  /// Returns the (negative) number of extra pixels of ascent padding in the
  /// top line of the Layout.
  int getTopPadding() => jniAccessors.callMethodWithArgs(
      reference, _id_getTopPadding, jni.JniType.intType, []).integer;

  static final _id_getBottomPadding =
      jniAccessors.getMethodIDOf(_classRef, "getBottomPadding", "()I");

  /// from: public abstract int getBottomPadding()
  ///
  /// Returns the number of extra pixels of descent padding in the
  /// bottom line of the Layout.
  int getBottomPadding() => jniAccessors.callMethodWithArgs(
      reference, _id_getBottomPadding, jni.JniType.intType, []).integer;

  static final _id_isRtlCharAt =
      jniAccessors.getMethodIDOf(_classRef, "isRtlCharAt", "(I)Z");

  /// from: public boolean isRtlCharAt(int offset)
  ///
  /// Returns true if the character at offset is right to left (RTL).
  ///@param offset the offset
  ///@return true if the character is RTL, false if it is LTR
  bool isRtlCharAt(int offset) => jniAccessors.callMethodWithArgs(
      reference, _id_isRtlCharAt, jni.JniType.booleanType, [offset]).boolean;

  static final _id_getPrimaryHorizontal =
      jniAccessors.getMethodIDOf(_classRef, "getPrimaryHorizontal", "(I)F");

  /// from: public float getPrimaryHorizontal(int offset)
  ///
  /// Get the primary horizontal position for the specified text offset.
  /// This is the location where a new character would be inserted in
  /// the paragraph's primary direction.
  double getPrimaryHorizontal(int offset) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getPrimaryHorizontal,
      jni.JniType.floatType,
      [offset]).float;

  static final _id_getSecondaryHorizontal =
      jniAccessors.getMethodIDOf(_classRef, "getSecondaryHorizontal", "(I)F");

  /// from: public float getSecondaryHorizontal(int offset)
  ///
  /// Get the secondary horizontal position for the specified text offset.
  /// This is the location where a new character would be inserted in
  /// the direction other than the paragraph's primary direction.
  double getSecondaryHorizontal(int offset) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getSecondaryHorizontal,
      jni.JniType.floatType,
      [offset]).float;

  static final _id_getLineLeft =
      jniAccessors.getMethodIDOf(_classRef, "getLineLeft", "(I)F");

  /// from: public float getLineLeft(int line)
  ///
  /// Get the leftmost position that should be exposed for horizontal
  /// scrolling on the specified line.
  double getLineLeft(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineLeft, jni.JniType.floatType, [line]).float;

  static final _id_getLineRight =
      jniAccessors.getMethodIDOf(_classRef, "getLineRight", "(I)F");

  /// from: public float getLineRight(int line)
  ///
  /// Get the rightmost position that should be exposed for horizontal
  /// scrolling on the specified line.
  double getLineRight(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineRight, jni.JniType.floatType, [line]).float;

  static final _id_getLineMax =
      jniAccessors.getMethodIDOf(_classRef, "getLineMax", "(I)F");

  /// from: public float getLineMax(int line)
  ///
  /// Gets the unsigned horizontal extent of the specified line, including
  /// leading margin indent, but excluding trailing whitespace.
  double getLineMax(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineMax, jni.JniType.floatType, [line]).float;

  static final _id_getLineWidth =
      jniAccessors.getMethodIDOf(_classRef, "getLineWidth", "(I)F");

  /// from: public float getLineWidth(int line)
  ///
  /// Gets the unsigned horizontal extent of the specified line, including
  /// leading margin indent and trailing whitespace.
  double getLineWidth(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineWidth, jni.JniType.floatType, [line]).float;

  static final _id_getLineForVertical =
      jniAccessors.getMethodIDOf(_classRef, "getLineForVertical", "(I)I");

  /// from: public int getLineForVertical(int vertical)
  ///
  /// Get the line number corresponding to the specified vertical position.
  /// If you ask for a position above 0, you get 0; if you ask for a position
  /// below the bottom of the text, you get the last line.
  int getLineForVertical(int vertical) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getLineForVertical,
      jni.JniType.intType,
      [vertical]).integer;

  static final _id_getLineForOffset =
      jniAccessors.getMethodIDOf(_classRef, "getLineForOffset", "(I)I");

  /// from: public int getLineForOffset(int offset)
  ///
  /// Get the line number on which the specified text offset appears.
  /// If you ask for a position before 0, you get 0; if you ask for a position
  /// beyond the end of the text, you get the last line.
  int getLineForOffset(int offset) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineForOffset, jni.JniType.intType, [offset]).integer;

  static final _id_getOffsetForHorizontal =
      jniAccessors.getMethodIDOf(_classRef, "getOffsetForHorizontal", "(IF)I");

  /// from: public int getOffsetForHorizontal(int line, float horiz)
  ///
  /// Get the character offset on the specified line whose position is
  /// closest to the specified horizontal position.
  int getOffsetForHorizontal(int line, double horiz) =>
      jniAccessors.callMethodWithArgs(reference, _id_getOffsetForHorizontal,
          jni.JniType.intType, [line, horiz]).integer;

  static final _id_getLineEnd =
      jniAccessors.getMethodIDOf(_classRef, "getLineEnd", "(I)I");

  /// from: public final int getLineEnd(int line)
  ///
  /// Return the text offset after the last character on the specified line.
  int getLineEnd(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineEnd, jni.JniType.intType, [line]).integer;

  static final _id_getLineVisibleEnd =
      jniAccessors.getMethodIDOf(_classRef, "getLineVisibleEnd", "(I)I");

  /// from: public int getLineVisibleEnd(int line)
  ///
  /// Return the text offset after the last visible character (so whitespace
  /// is not counted) on the specified line.
  int getLineVisibleEnd(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineVisibleEnd, jni.JniType.intType, [line]).integer;

  static final _id_getLineBottom =
      jniAccessors.getMethodIDOf(_classRef, "getLineBottom", "(I)I");

  /// from: public final int getLineBottom(int line)
  ///
  /// Return the vertical position of the bottom of the specified line.
  int getLineBottom(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineBottom, jni.JniType.intType, [line]).integer;

  static final _id_getLineBaseline =
      jniAccessors.getMethodIDOf(_classRef, "getLineBaseline", "(I)I");

  /// from: public final int getLineBaseline(int line)
  ///
  /// Return the vertical position of the baseline of the specified line.
  int getLineBaseline(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineBaseline, jni.JniType.intType, [line]).integer;

  static final _id_getLineAscent =
      jniAccessors.getMethodIDOf(_classRef, "getLineAscent", "(I)I");

  /// from: public final int getLineAscent(int line)
  ///
  /// Get the ascent of the text on the specified line.
  /// The return value is negative to match the Paint.ascent() convention.
  int getLineAscent(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getLineAscent, jni.JniType.intType, [line]).integer;

  static final _id_getOffsetToLeftOf =
      jniAccessors.getMethodIDOf(_classRef, "getOffsetToLeftOf", "(I)I");

  /// from: public int getOffsetToLeftOf(int offset)
  int getOffsetToLeftOf(int offset) => jniAccessors.callMethodWithArgs(
      reference, _id_getOffsetToLeftOf, jni.JniType.intType, [offset]).integer;

  static final _id_getOffsetToRightOf =
      jniAccessors.getMethodIDOf(_classRef, "getOffsetToRightOf", "(I)I");

  /// from: public int getOffsetToRightOf(int offset)
  int getOffsetToRightOf(int offset) => jniAccessors.callMethodWithArgs(
      reference, _id_getOffsetToRightOf, jni.JniType.intType, [offset]).integer;

  static final _id_getCursorPath = jniAccessors.getMethodIDOf(_classRef,
      "getCursorPath", "(ILandroid/graphics/Path;Ljava/lang/CharSequence;)V");

  /// from: public void getCursorPath(int point, android.graphics.Path dest, java.lang.CharSequence editingBuffer)
  ///
  /// Fills in the specified Path with a representation of a cursor
  /// at the specified offset.  This will often be a vertical line
  /// but can be multiple discontinuous lines in text with multiple
  /// directionalities.
  void getCursorPath(int point, path_.Path dest, jni.JniObject editingBuffer) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getCursorPath,
          jni.JniType.voidType,
          [point, dest.reference, editingBuffer.reference]).check();

  static final _id_getSelectionPath = jniAccessors.getMethodIDOf(
      _classRef, "getSelectionPath", "(IILandroid/graphics/Path;)V");

  /// from: public void getSelectionPath(int start, int end, android.graphics.Path dest)
  ///
  /// Fills in the specified Path with a representation of a highlight
  /// between the specified offsets.  This will often be a rectangle
  /// or a potentially discontinuous set of rectangles.  If the start
  /// and end are the same, the returned path is empty.
  void getSelectionPath(int start, int end, path_.Path dest) =>
      jniAccessors.callMethodWithArgs(reference, _id_getSelectionPath,
          jni.JniType.voidType, [start, end, dest.reference]).check();

  static final _id_getParagraphAlignment = jniAccessors.getMethodIDOf(_classRef,
      "getParagraphAlignment", "(I)Landroid/text/Layout\$Alignment;");

  /// from: public final android.text.Layout.Alignment getParagraphAlignment(int line)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the alignment of the specified paragraph, taking into account
  /// markup attached to it.
  Layout_Alignment getParagraphAlignment(int line) =>
      Layout_Alignment.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getParagraphAlignment, jni.JniType.objectType, [line]).object);

  static final _id_getParagraphLeft =
      jniAccessors.getMethodIDOf(_classRef, "getParagraphLeft", "(I)I");

  /// from: public final int getParagraphLeft(int line)
  ///
  /// Get the left edge of the specified paragraph, inset by left margins.
  int getParagraphLeft(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getParagraphLeft, jni.JniType.intType, [line]).integer;

  static final _id_getParagraphRight =
      jniAccessors.getMethodIDOf(_classRef, "getParagraphRight", "(I)I");

  /// from: public final int getParagraphRight(int line)
  ///
  /// Get the right edge of the specified paragraph, inset by right margins.
  int getParagraphRight(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getParagraphRight, jni.JniType.intType, [line]).integer;

  static final _id_isSpanned =
      jniAccessors.getMethodIDOf(_classRef, "isSpanned", "()Z");

  /// from: protected final boolean isSpanned()
  bool isSpanned() => jniAccessors.callMethodWithArgs(
      reference, _id_isSpanned, jni.JniType.booleanType, []).boolean;

  static final _id_getEllipsisStart =
      jniAccessors.getMethodIDOf(_classRef, "getEllipsisStart", "(I)I");

  /// from: public abstract int getEllipsisStart(int line)
  ///
  /// Return the offset of the first character to be ellipsized away,
  /// relative to the start of the line.  (So 0 if the beginning of the
  /// line is ellipsized, not getLineStart().)
  int getEllipsisStart(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getEllipsisStart, jni.JniType.intType, [line]).integer;

  static final _id_getEllipsisCount =
      jniAccessors.getMethodIDOf(_classRef, "getEllipsisCount", "(I)I");

  /// from: public abstract int getEllipsisCount(int line)
  ///
  /// Returns the number of characters to be ellipsized away, or 0 if
  /// no ellipsis is to take place.
  int getEllipsisCount(int line) => jniAccessors.callMethodWithArgs(
      reference, _id_getEllipsisCount, jni.JniType.intType, [line]).integer;
}

/// from: android.text.Layout$Directions
///
/// Stores information about bidirectional (left-to-right or right-to-left)
/// text within the layout of a line.
class Layout_Directions extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/Layout\$Directions");
  Layout_Directions.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "([I)V");

  /// from: void <init>(int[] dirs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  Layout_Directions(jni.JniObject dirs)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [dirs.reference]).object);
}

/// from: android.text.Layout$Alignment
class Layout_Alignment extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/text/Layout\$Alignment");
  Layout_Alignment.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/text/Layout\$Alignment;");

  /// from: static public android.text.Layout.Alignment[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/text/Layout\$Alignment;");

  /// from: static public android.text.Layout.Alignment valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Layout_Alignment valueOf(jni.JniString name) =>
      Layout_Alignment.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Layout_Alignment()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
