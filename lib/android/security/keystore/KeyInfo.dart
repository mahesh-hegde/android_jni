// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.security.keystore.KeyInfo
///
/// Information about a key from the <a href="{@docRoot}training/articles/keystore.html">Android
/// Keystore system</a>. This class describes whether the key material is available in
/// plaintext outside of secure hardware, whether user authentication is required for using the key
/// and whether this requirement is enforced by secure hardware, the key's origin, what uses the key
/// is authorized for (e.g., only in {@code GCM} mode, or signing only), whether the key should be
/// encrypted at rest, the key's and validity start and end dates.
///
/// Instances of this class are immutable.
///
/// <h3>Example: Symmetric Key</h3>
/// The following example illustrates how to obtain a {@code KeyInfo} describing the provided Android
/// Keystore SecretKey.
/// <pre>{@code
/// SecretKey key = ...; // Android Keystore key
///
/// SecretKeyFactory factory = SecretKeyFactory.getInstance(key.getAlgorithm(), "AndroidKeyStore");
/// KeyInfo keyInfo;
/// try {
///     keyInfo = (KeyInfo) factory.getKeySpec(key, KeyInfo.class);
/// } catch (InvalidKeySpecException e) {
///     // Not an Android KeyStore key.
/// }}</pre>
///
/// <h3>Example: Private Key</h3>
/// The following example illustrates how to obtain a {@code KeyInfo} describing the provided
/// Android KeyStore PrivateKey.
/// <pre>{@code
/// PrivateKey key = ...; // Android KeyStore key
///
/// KeyFactory factory = KeyFactory.getInstance(key.getAlgorithm(), "AndroidKeyStore");
/// KeyInfo keyInfo;
/// try {
///     keyInfo = factory.getKeySpec(key, KeyInfo.class);
/// } catch (InvalidKeySpecException e) {
///     // Not an Android KeyStore key.
/// }}</pre>
class KeyInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/security/keystore/KeyInfo");
  KeyInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getKeystoreAlias = jniAccessors.getMethodIDOf(
      _classRef, "getKeystoreAlias", "()Ljava/lang/String;");

  /// from: public java.lang.String getKeystoreAlias()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the entry alias under which the key is stored in the {@code AndroidKeyStore}.
  jni.JniString getKeystoreAlias() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getKeystoreAlias, jni.JniType.objectType, []).object);

  static final _id_isInsideSecureHardware =
      jniAccessors.getMethodIDOf(_classRef, "isInsideSecureHardware", "()Z");

  /// from: public boolean isInsideSecureHardware()
  ///
  /// Returns {@code true} if the key resides inside secure hardware (e.g., Trusted Execution
  /// Environment (TEE) or Secure Element (SE)). Key material of such keys is available in
  /// plaintext only inside the secure hardware and is not exposed outside of it.
  bool isInsideSecureHardware() => jniAccessors.callMethodWithArgs(reference,
      _id_isInsideSecureHardware, jni.JniType.booleanType, []).boolean;

  static final _id_getOrigin =
      jniAccessors.getMethodIDOf(_classRef, "getOrigin", "()I");

  /// from: public int getOrigin()
  ///
  /// Gets the origin of the key. See KeyProperties.{@code ORIGIN} constants.
  ///@return Value is android.security.keystore.KeyProperties\#ORIGIN_GENERATED, android.security.keystore.KeyProperties\#ORIGIN_IMPORTED, or android.security.keystore.KeyProperties\#ORIGIN_UNKNOWN
  int getOrigin() => jniAccessors.callMethodWithArgs(
      reference, _id_getOrigin, jni.JniType.intType, []).integer;

  static final _id_getKeySize =
      jniAccessors.getMethodIDOf(_classRef, "getKeySize", "()I");

  /// from: public int getKeySize()
  ///
  /// Gets the size of the key in bits.
  int getKeySize() => jniAccessors.callMethodWithArgs(
      reference, _id_getKeySize, jni.JniType.intType, []).integer;

  static final _id_getKeyValidityStart = jniAccessors.getMethodIDOf(
      _classRef, "getKeyValidityStart", "()Ljava/util/Date;");

  /// from: public java.util.Date getKeyValidityStart()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the time instant before which the key is not yet valid.
  ///@return instant or {@code null} if not restricted.
  jni.JniObject getKeyValidityStart() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getKeyValidityStart, jni.JniType.objectType, []).object);

  static final _id_getKeyValidityForConsumptionEnd = jniAccessors.getMethodIDOf(
      _classRef, "getKeyValidityForConsumptionEnd", "()Ljava/util/Date;");

  /// from: public java.util.Date getKeyValidityForConsumptionEnd()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the time instant after which the key is no long valid for decryption and verification.
  ///@return instant or {@code null} if not restricted.
  jni.JniObject getKeyValidityForConsumptionEnd() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getKeyValidityForConsumptionEnd,
          jni.JniType.objectType, []).object);

  static final _id_getKeyValidityForOriginationEnd = jniAccessors.getMethodIDOf(
      _classRef, "getKeyValidityForOriginationEnd", "()Ljava/util/Date;");

  /// from: public java.util.Date getKeyValidityForOriginationEnd()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the time instant after which the key is no long valid for encryption and signing.
  ///@return instant or {@code null} if not restricted.
  jni.JniObject getKeyValidityForOriginationEnd() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getKeyValidityForOriginationEnd,
          jni.JniType.objectType, []).object);

  static final _id_getPurposes =
      jniAccessors.getMethodIDOf(_classRef, "getPurposes", "()I");

  /// from: public int getPurposes()
  ///
  /// Gets the set of purposes (e.g., encrypt, decrypt, sign) for which the key can be used.
  /// Attempts to use the key for any other purpose will be rejected.
  ///
  /// See KeyProperties.{@code PURPOSE} flags.
  ///@return Value is either <code>0</code> or a combination of android.security.keystore.KeyProperties\#PURPOSE_ENCRYPT, android.security.keystore.KeyProperties\#PURPOSE_DECRYPT, android.security.keystore.KeyProperties\#PURPOSE_SIGN, android.security.keystore.KeyProperties\#PURPOSE_VERIFY, and android.security.keystore.KeyProperties\#PURPOSE_WRAP_KEY
  int getPurposes() => jniAccessors.callMethodWithArgs(
      reference, _id_getPurposes, jni.JniType.intType, []).integer;

  static final _id_getBlockModes = jniAccessors.getMethodIDOf(
      _classRef, "getBlockModes", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getBlockModes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the set of block modes (e.g., {@code GCM}, {@code CBC}) with which the key can be used
  /// when encrypting/decrypting. Attempts to use the key with any other block modes will be
  /// rejected.
  ///
  /// See KeyProperties.{@code BLOCK_MODE} constants.
  ///@return This value will never be {@code null}.
  ///
  /// Value is android.security.keystore.KeyProperties\#BLOCK_MODE_ECB, android.security.keystore.KeyProperties\#BLOCK_MODE_CBC, android.security.keystore.KeyProperties\#BLOCK_MODE_CTR, or android.security.keystore.KeyProperties\#BLOCK_MODE_GCM
  jni.JniObject getBlockModes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBlockModes, jni.JniType.objectType, []).object);

  static final _id_getEncryptionPaddings = jniAccessors.getMethodIDOf(
      _classRef, "getEncryptionPaddings", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getEncryptionPaddings()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the set of padding schemes (e.g., {@code PKCS7Padding}, {@code PKCS1Padding},
  /// {@code NoPadding}) with which the key can be used when encrypting/decrypting. Attempts to use
  /// the key with any other padding scheme will be rejected.
  ///
  /// See KeyProperties.{@code ENCRYPTION_PADDING} constants.
  ///@return This value will never be {@code null}.
  ///
  /// Value is android.security.keystore.KeyProperties\#ENCRYPTION_PADDING_NONE, android.security.keystore.KeyProperties\#ENCRYPTION_PADDING_PKCS7, android.security.keystore.KeyProperties\#ENCRYPTION_PADDING_RSA_PKCS1, or android.security.keystore.KeyProperties\#ENCRYPTION_PADDING_RSA_OAEP
  jni.JniObject getEncryptionPaddings() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getEncryptionPaddings, jni.JniType.objectType, []).object);

  static final _id_getSignaturePaddings = jniAccessors.getMethodIDOf(
      _classRef, "getSignaturePaddings", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getSignaturePaddings()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the set of padding schemes (e.g., {@code PSS}, {@code PKCS\#1}) with which the key
  /// can be used when signing/verifying. Attempts to use the key with any other padding scheme
  /// will be rejected.
  ///
  /// See KeyProperties.{@code SIGNATURE_PADDING} constants.
  ///@return This value will never be {@code null}.
  ///
  /// Value is android.security.keystore.KeyProperties\#SIGNATURE_PADDING_RSA_PKCS1, or android.security.keystore.KeyProperties\#SIGNATURE_PADDING_RSA_PSS
  jni.JniObject getSignaturePaddings() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSignaturePaddings, jni.JniType.objectType, []).object);

  static final _id_getDigests = jniAccessors.getMethodIDOf(
      _classRef, "getDigests", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getDigests()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the set of digest algorithms (e.g., {@code SHA-256}, {@code SHA-384}) with which the key
  /// can be used.
  ///
  /// See KeyProperties.{@code DIGEST} constants.
  ///@return This value will never be {@code null}.
  ///
  /// Value is android.security.keystore.KeyProperties\#DIGEST_NONE, android.security.keystore.KeyProperties\#DIGEST_MD5, android.security.keystore.KeyProperties\#DIGEST_SHA1, android.security.keystore.KeyProperties\#DIGEST_SHA224, android.security.keystore.KeyProperties\#DIGEST_SHA256, android.security.keystore.KeyProperties\#DIGEST_SHA384, or android.security.keystore.KeyProperties\#DIGEST_SHA512
  jni.JniObject getDigests() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDigests, jni.JniType.objectType, []).object);

  static final _id_isUserAuthenticationRequired = jniAccessors.getMethodIDOf(
      _classRef, "isUserAuthenticationRequired", "()Z");

  /// from: public boolean isUserAuthenticationRequired()
  ///
  /// Returns {@code true} if the key is authorized to be used only if the user has been
  /// authenticated.
  ///
  /// This authorization applies only to secret key and private key operations. Public key
  /// operations are not restricted.
  ///@see \#getUserAuthenticationValidityDurationSeconds()
  ///@see KeyGenParameterSpec.Builder\#setUserAuthenticationRequired(boolean)
  ///@see KeyProtection.Builder\#setUserAuthenticationRequired(boolean)
  bool isUserAuthenticationRequired() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isUserAuthenticationRequired,
      jni.JniType.booleanType, []).boolean;

  static final _id_isUserConfirmationRequired = jniAccessors.getMethodIDOf(
      _classRef, "isUserConfirmationRequired", "()Z");

  /// from: public boolean isUserConfirmationRequired()
  ///
  /// Returns {@code true} if the key is authorized to be used only for messages confirmed by the
  /// user.
  ///
  /// Confirmation is separate from user authentication (see
  /// \#isUserAuthenticationRequired()). Keys can be created that require confirmation but
  /// not user authentication, or user authentication but not confirmation, or both. Confirmation
  /// verifies that some user with physical possession of the device has approved a displayed
  /// message. User authentication verifies that the correct user is present and has
  /// authenticated.
  ///
  /// This authorization applies only to secret key and private key operations. Public key
  /// operations are not restricted.
  ///@see KeyGenParameterSpec.Builder\#setUserConfirmationRequired(boolean)
  ///@see KeyProtection.Builder\#setUserConfirmationRequired(boolean)
  bool isUserConfirmationRequired() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isUserConfirmationRequired,
      jni.JniType.booleanType, []).boolean;

  static final _id_getUserAuthenticationValidityDurationSeconds =
      jniAccessors.getMethodIDOf(
          _classRef, "getUserAuthenticationValidityDurationSeconds", "()I");

  /// from: public int getUserAuthenticationValidityDurationSeconds()
  ///
  /// Gets the duration of time (seconds) for which this key is authorized to be used after the
  /// user is successfully authenticated. This has effect only if user authentication is required
  /// (see \#isUserAuthenticationRequired()).
  ///
  /// This authorization applies only to secret key and private key operations. Public key
  /// operations are not restricted.
  ///@return duration in seconds or {@code -1} if authentication is required for every use of the
  ///         key.
  ///@see \#isUserAuthenticationRequired()
  int getUserAuthenticationValidityDurationSeconds() =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getUserAuthenticationValidityDurationSeconds,
          jni.JniType.intType, []).integer;

  static final _id_isUserAuthenticationRequirementEnforcedBySecureHardware =
      jniAccessors.getMethodIDOf(_classRef,
          "isUserAuthenticationRequirementEnforcedBySecureHardware", "()Z");

  /// from: public boolean isUserAuthenticationRequirementEnforcedBySecureHardware()
  ///
  /// Returns {@code true} if the requirement that this key can only be used if the user has been
  /// authenticated is enforced by secure hardware (e.g., Trusted Execution Environment (TEE) or
  /// Secure Element (SE)).
  ///@see \#isUserAuthenticationRequired()
  bool isUserAuthenticationRequirementEnforcedBySecureHardware() =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isUserAuthenticationRequirementEnforcedBySecureHardware,
          jni.JniType.booleanType, []).boolean;

  static final _id_isUserAuthenticationValidWhileOnBody = jniAccessors
      .getMethodIDOf(_classRef, "isUserAuthenticationValidWhileOnBody", "()Z");

  /// from: public boolean isUserAuthenticationValidWhileOnBody()
  ///
  /// Returns {@code true} if this key will become unusable when the device is removed from the
  /// user's body.  This is possible only for keys with a specified validity duration, and only on
  /// devices with an on-body sensor.  Always returns {@code false} on devices that lack an on-body
  /// sensor.
  bool isUserAuthenticationValidWhileOnBody() =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isUserAuthenticationValidWhileOnBody,
          jni.JniType.booleanType, []).boolean;

  static final _id_isInvalidatedByBiometricEnrollment = jniAccessors
      .getMethodIDOf(_classRef, "isInvalidatedByBiometricEnrollment", "()Z");

  /// from: public boolean isInvalidatedByBiometricEnrollment()
  ///
  /// Returns {@code true} if the key will be invalidated by enrollment of a new fingerprint or
  /// removal of all fingerprints.
  bool isInvalidatedByBiometricEnrollment() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isInvalidatedByBiometricEnrollment,
      jni.JniType.booleanType, []).boolean;

  static final _id_isTrustedUserPresenceRequired = jniAccessors.getMethodIDOf(
      _classRef, "isTrustedUserPresenceRequired", "()Z");

  /// from: public boolean isTrustedUserPresenceRequired()
  ///
  /// Returns {@code true} if the key can only be only be used if a test for user presence has
  /// succeeded since Signature.initSign() has been called.
  bool isTrustedUserPresenceRequired() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isTrustedUserPresenceRequired,
      jni.JniType.booleanType, []).boolean;
}
