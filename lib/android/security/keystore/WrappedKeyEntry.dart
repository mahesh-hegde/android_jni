// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.security.keystore.WrappedKeyEntry
///
/// An Entry that holds a wrapped key. Wrapped keys contain encrypted key data and
/// description information that can be used to securely import key material into a hardware-backed
/// Keystore.
///
///
///   The wrapped key is in DER-encoded ASN.1 format, specified by the following schema:
///
///
///
/// <pre>
///     KeyDescription ::= SEQUENCE(
///         keyFormat INTEGER,                   \# Values from KeyFormat enum.
///         keyParams AuthorizationList,
///     )
///
///     SecureKeyWrapper ::= SEQUENCE(
///         version INTEGER,                     \# Contains value 0
///         encryptedTransportKey OCTET_STRING,
///         initializationVector OCTET_STRING,
///         keyDescription KeyDescription,
///         encryptedKey OCTET_STRING,
///         tag OCTET_STRING
///     )
/// </pre>
/// <ul>
///     <li>keyFormat is an integer from the KeyFormat enum, defining the format of the plaintext
///       key material.
///     </li>
///     <li>keyParams is the characteristics of the key to be imported (as with generateKey or
///       importKey).  If the secure import is successful, these characteristics must be
///       associated with the key exactly as if the key material had been insecurely imported
///       with importKey. See <a href="https://developer.android.com/training/articles/security-key-attestation.html\#certificate_schema">Key Attestation</a> for the AuthorizationList format.
///     </li>
///     <li>encryptedTransportKey is a 256-bit AES key, XORed with a masking key and then encrypted
///       in RSA-OAEP mode (SHA-256 digest, SHA-1 MGF1 digest) with the wrapping key specified by
///       wrappingKeyBlob.
///     </li>
///     <li>keyDescription is a KeyDescription, above.
///     </li>
///     <li>encryptedKey is the key material of the key to be imported, in format keyFormat, and
///       encrypted with encryptedEphemeralKey in AES-GCM mode, with the DER-encoded
///       representation of keyDescription provided as additional authenticated data.
///     </li>
///     <li>tag is the tag produced by the AES-GCM encryption of encryptedKey.
///     </li>
///</ul>
///
///
///     Imported wrapped keys will have KeymasterDefs.KM_ORIGIN_SECURELY_IMPORTED
///
///
class WrappedKeyEntry extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/security/keystore/WrappedKeyEntry");
  WrappedKeyEntry.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "([BLjava/lang/String;Ljava/lang/String;Ljava/security/spec/AlgorithmParameterSpec;)V");

  /// from: public void <init>(byte[] wrappedKeyBytes, java.lang.String wrappingKeyAlias, java.lang.String transformation, java.security.spec.AlgorithmParameterSpec algorithmParameterSpec)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a WrappedKeyEntry with a binary wrapped key.
  ///@param wrappedKeyBytes ASN.1 DER encoded wrapped key
  ///@param wrappingKeyAlias identifies the private key that can unwrap the wrapped key
  ///@param transformation used to unwrap the key. ex: "RSA/ECB/OAEPPadding"
  ///@param algorithmParameterSpec spec for the private key used to unwrap the wrapped key
  WrappedKeyEntry(jni.JniObject wrappedKeyBytes, jni.JniString wrappingKeyAlias,
      jni.JniString transformation, jni.JniObject algorithmParameterSpec)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [
          wrappedKeyBytes.reference,
          wrappingKeyAlias.reference,
          transformation.reference,
          algorithmParameterSpec.reference
        ]).object);

  static final _id_getWrappedKeyBytes =
      jniAccessors.getMethodIDOf(_classRef, "getWrappedKeyBytes", "()[B");

  /// from: public byte[] getWrappedKeyBytes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getWrappedKeyBytes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getWrappedKeyBytes, jni.JniType.objectType, []).object);

  static final _id_getWrappingKeyAlias = jniAccessors.getMethodIDOf(
      _classRef, "getWrappingKeyAlias", "()Ljava/lang/String;");

  /// from: public java.lang.String getWrappingKeyAlias()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getWrappingKeyAlias() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getWrappingKeyAlias, jni.JniType.objectType, []).object);

  static final _id_getTransformation = jniAccessors.getMethodIDOf(
      _classRef, "getTransformation", "()Ljava/lang/String;");

  /// from: public java.lang.String getTransformation()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getTransformation() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTransformation, jni.JniType.objectType, []).object);

  static final _id_getAlgorithmParameterSpec = jniAccessors.getMethodIDOf(
      _classRef,
      "getAlgorithmParameterSpec",
      "()Ljava/security/spec/AlgorithmParameterSpec;");

  /// from: public java.security.spec.AlgorithmParameterSpec getAlgorithmParameterSpec()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAlgorithmParameterSpec() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAlgorithmParameterSpec, jni.JniType.objectType, []).object);
}
