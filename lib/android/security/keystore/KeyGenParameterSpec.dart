// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.security.keystore.KeyGenParameterSpec
///
/// AlgorithmParameterSpec for initializing a KeyPairGenerator or a
/// KeyGenerator of the <a href="{@docRoot}training/articles/keystore.html">Android Keystore
/// system</a>. The spec determines authorized uses of the key, such as whether user authentication
/// is required for using the key, what operations are authorized (e.g., signing, but not
/// decryption), with what parameters (e.g., only with a particular padding scheme or digest), and
/// the key's validity start and end dates. Key use authorizations expressed in the spec apply
/// only to secret keys and private keys -- public keys can be used for any supported operations.
///
/// To generate an asymmetric key pair or a symmetric key, create an instance of this class using
/// the Builder, initialize a {@code KeyPairGenerator} or a {@code KeyGenerator} of the
/// desired key type (e.g., {@code EC} or {@code AES} -- see
/// KeyProperties.{@code KEY_ALGORITHM} constants) from the {@code AndroidKeyStore} provider
/// with the {@code KeyGenParameterSpec} instance, and then generate a key or key pair using
/// KeyGenerator\#generateKey() or KeyPairGenerator\#generateKeyPair().
///
/// The generated key pair or key will be returned by the generator and also stored in the Android
/// Keystore under the alias specified in this spec. To obtain the secret or private key from the
/// Android Keystore use java.security.KeyStore\#getKey(String, char[]) KeyStore.getKey(String, null)
/// or java.security.KeyStore\#getEntry(String, java.security.KeyStore.ProtectionParameter) KeyStore.getEntry(String, null).
/// To obtain the public key from the Android Keystore use
/// java.security.KeyStore\#getCertificate(String) and then
/// Certificate\#getPublicKey().
///
/// To help obtain algorithm-specific public parameters of key pairs stored in the Android
/// Keystore, generated private keys implement java.security.interfaces.ECKey or
/// java.security.interfaces.RSAKey interfaces whereas public keys implement
/// java.security.interfaces.ECPublicKey or java.security.interfaces.RSAPublicKey
/// interfaces.
///
/// For asymmetric key pairs, a self-signed X.509 certificate will be also generated and stored in
/// the Android Keystore. This is because the java.security.KeyStore abstraction does not
/// support storing key pairs without a certificate. The subject, serial number, and validity dates
/// of the certificate can be customized in this spec. The self-signed certificate may be replaced at
/// a later time by a certificate signed by a Certificate Authority (CA).
///
/// NOTE: If a private key is not authorized to sign the self-signed certificate, then the
/// certificate will be created with an invalid signature which will not verify. Such a certificate
/// is still useful because it provides access to the public key. To generate a valid signature for
/// the certificate the key needs to be authorized for all of the following:
/// <ul>
/// <li>KeyProperties\#PURPOSE_SIGN,</li>
/// <li>operation without requiring the user to be authenticated (see
/// Builder\#setUserAuthenticationRequired(boolean)),</li>
/// <li>signing/origination at this moment in time (see Builder\#setKeyValidityStart(Date)
/// and Builder\#setKeyValidityForOriginationEnd(Date)),</li>
/// <li>suitable digest,</li>
/// <li>(RSA keys only) padding scheme KeyProperties\#SIGNATURE_PADDING_RSA_PKCS1.</li>
/// </ul>
///
/// NOTE: The key material of the generated symmetric and private keys is not accessible. The key
/// material of the public keys is accessible.
///
/// Instances of this class are immutable.
///
/// <h3>Known issues</h3>
/// A known bug in Android 6.0 (API Level 23) causes user authentication-related authorizations to be
/// enforced even for public keys. To work around this issue extract the public key material to use
/// outside of Android Keystore. For example:
/// <pre> {@code
/// PublicKey unrestrictedPublicKey =
///         KeyFactory.getInstance(publicKey.getAlgorithm()).generatePublic(
///                 new X509EncodedKeySpec(publicKey.getEncoded()));
/// }</pre>
///
/// <h3>Example: NIST P-256 EC key pair for signing/verification using ECDSA</h3>
/// This example illustrates how to generate a NIST P-256 (aka secp256r1 aka prime256v1) EC key pair
/// in the Android KeyStore system under alias {@code key1} where the private key is authorized to be
/// used only for signing using SHA-256, SHA-384, or SHA-512 digest and only if the user has been
/// authenticated within the last five minutes. The use of the public key is unrestricted (See Known
/// Issues).
/// <pre> {@code
/// KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(
///         KeyProperties.KEY_ALGORITHM_EC, "AndroidKeyStore");
/// keyPairGenerator.initialize(
///         new KeyGenParameterSpec.Builder(
///                 "key1",
///                 KeyProperties.PURPOSE_SIGN)
///                 .setAlgorithmParameterSpec(new ECGenParameterSpec("secp256r1"))
///                 .setDigests(KeyProperties.DIGEST_SHA256,
///                         KeyProperties.DIGEST_SHA384,
///                         KeyProperties.DIGEST_SHA512)
///                 // Only permit the private key to be used if the user authenticated
///                 // within the last five minutes.
///                 .setUserAuthenticationRequired(true)
///                 .setUserAuthenticationValidityDurationSeconds(5 * 60)
///                 .build());
/// KeyPair keyPair = keyPairGenerator.generateKeyPair();
/// Signature signature = Signature.getInstance("SHA256withECDSA");
/// signature.initSign(keyPair.getPrivate());
/// ...
///
/// // The key pair can also be obtained from the Android Keystore any time as follows:
/// KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
/// keyStore.load(null);
/// PrivateKey privateKey = (PrivateKey) keyStore.getKey("key1", null);
/// PublicKey publicKey = keyStore.getCertificate("key1").getPublicKey();
/// }</pre>
///
/// <h3>Example: RSA key pair for signing/verification using RSA-PSS</h3>
/// This example illustrates how to generate an RSA key pair in the Android KeyStore system under
/// alias {@code key1} authorized to be used only for signing using the RSA-PSS signature padding
/// scheme with SHA-256 or SHA-512 digests. The use of the public key is unrestricted.
/// <pre> {@code
/// KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(
///         KeyProperties.KEY_ALGORITHM_RSA, "AndroidKeyStore");
/// keyPairGenerator.initialize(
///         new KeyGenParameterSpec.Builder(
///                 "key1",
///                 KeyProperties.PURPOSE_SIGN)
///                 .setDigests(KeyProperties.DIGEST_SHA256, KeyProperties.DIGEST_SHA512)
///                 .setSignaturePaddings(KeyProperties.SIGNATURE_PADDING_RSA_PSS)
///                 .build());
/// KeyPair keyPair = keyPairGenerator.generateKeyPair();
/// Signature signature = Signature.getInstance("SHA256withRSA/PSS");
/// signature.initSign(keyPair.getPrivate());
/// ...
///
/// // The key pair can also be obtained from the Android Keystore any time as follows:
/// KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
/// keyStore.load(null);
/// PrivateKey privateKey = (PrivateKey) keyStore.getKey("key1", null);
/// PublicKey publicKey = keyStore.getCertificate("key1").getPublicKey();
/// }</pre>
///
/// <h3>Example: RSA key pair for encryption/decryption using RSA OAEP</h3>
/// This example illustrates how to generate an RSA key pair in the Android KeyStore system under
/// alias {@code key1} where the private key is authorized to be used only for decryption using RSA
/// OAEP encryption padding scheme with SHA-256 or SHA-512 digests. The use of the public key is
/// unrestricted.
/// <pre> {@code
/// KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(
///         KeyProperties.KEY_ALGORITHM_RSA, "AndroidKeyStore");
/// keyPairGenerator.initialize(
///         new KeyGenParameterSpec.Builder(
///                 "key1",
///                 KeyProperties.PURPOSE_DECRYPT)
///                 .setDigests(KeyProperties.DIGEST_SHA256, KeyProperties.DIGEST_SHA512)
///                 .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_RSA_OAEP)
///                 .build());
/// KeyPair keyPair = keyPairGenerator.generateKeyPair();
/// Cipher cipher = Cipher.getInstance("RSA/ECB/OAEPWithSHA-256AndMGF1Padding");
/// cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());
/// ...
///
/// // The key pair can also be obtained from the Android Keystore any time as follows:
/// KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
/// keyStore.load(null);
/// PrivateKey privateKey = (PrivateKey) keyStore.getKey("key1", null);
/// PublicKey publicKey = keyStore.getCertificate("key1").getPublicKey();
/// }</pre>
///
/// <h3>Example: AES key for encryption/decryption in GCM mode</h3>
/// The following example illustrates how to generate an AES key in the Android KeyStore system under
/// alias {@code key2} authorized to be used only for encryption/decryption in GCM mode with no
/// padding.
/// <pre> {@code
/// KeyGenerator keyGenerator = KeyGenerator.getInstance(
///         KeyProperties.KEY_ALGORITHM_AES, "AndroidKeyStore");
/// keyGenerator.init(
///         new KeyGenParameterSpec.Builder("key2",
///                 KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
///                 .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
///                 .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
///                 .build());
/// SecretKey key = keyGenerator.generateKey();
///
/// Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
/// cipher.init(Cipher.ENCRYPT_MODE, key);
/// ...
///
/// // The key can also be obtained from the Android Keystore any time as follows:
/// KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
/// keyStore.load(null);
/// key = (SecretKey) keyStore.getKey("key2", null);
/// }</pre>
///
/// <h3>Example: HMAC key for generating a MAC using SHA-256</h3>
/// This example illustrates how to generate an HMAC key in the Android KeyStore system under alias
/// {@code key2} authorized to be used only for generating an HMAC using SHA-256.
/// <pre> {@code
/// KeyGenerator keyGenerator = KeyGenerator.getInstance(
///         KeyProperties.KEY_ALGORITHM_HMAC_SHA256, "AndroidKeyStore");
/// keyGenerator.init(
///         new KeyGenParameterSpec.Builder("key2", KeyProperties.PURPOSE_SIGN).build());
/// SecretKey key = keyGenerator.generateKey();
/// Mac mac = Mac.getInstance("HmacSHA256");
/// mac.init(key);
/// ...
///
/// // The key can also be obtained from the Android Keystore any time as follows:
/// KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
/// keyStore.load(null);
/// key = (SecretKey) keyStore.getKey("key2", null);
/// }</pre>
class KeyGenParameterSpec extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/security/keystore/KeyGenParameterSpec");
  KeyGenParameterSpec.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;IILjava/security/spec/AlgorithmParameterSpec;Ljavax/security/auth/x500/X500Principal;Ljava/math/BigInteger;Ljava/util/Date;Ljava/util/Date;Ljava/util/Date;Ljava/util/Date;Ljava/util/Date;I[Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;ZZIZ[BZZZZZZ)V");

  /// from: void <init>(java.lang.String keyStoreAlias, int uid, int keySize, java.security.spec.AlgorithmParameterSpec spec, javax.security.auth.x500.X500Principal certificateSubject, java.math.BigInteger certificateSerialNumber, java.util.Date certificateNotBefore, java.util.Date certificateNotAfter, java.util.Date keyValidityStart, java.util.Date keyValidityForOriginationEnd, java.util.Date keyValidityForConsumptionEnd, int purposes, java.lang.String[] digests, java.lang.String[] encryptionPaddings, java.lang.String[] signaturePaddings, java.lang.String[] blockModes, boolean randomizedEncryptionRequired, boolean userAuthenticationRequired, int userAuthenticationValidityDurationSeconds, boolean userPresenceRequired, byte[] attestationChallenge, boolean uniqueIdIncluded, boolean userAuthenticationValidWhileOnBody, boolean invalidatedByBiometricEnrollment, boolean isStrongBoxBacked, boolean userConfirmationRequired, boolean unlockedDeviceRequired)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide should be built with Builder
  KeyGenParameterSpec(
      jni.JniString keyStoreAlias,
      int uid,
      int keySize,
      jni.JniObject spec,
      jni.JniObject certificateSubject,
      jni.JniObject certificateSerialNumber,
      jni.JniObject certificateNotBefore,
      jni.JniObject certificateNotAfter,
      jni.JniObject keyValidityStart,
      jni.JniObject keyValidityForOriginationEnd,
      jni.JniObject keyValidityForConsumptionEnd,
      int purposes,
      jni.JniObject digests,
      jni.JniObject encryptionPaddings,
      jni.JniObject signaturePaddings,
      jni.JniObject blockModes,
      bool randomizedEncryptionRequired,
      bool userAuthenticationRequired,
      int userAuthenticationValidityDurationSeconds,
      bool userPresenceRequired,
      jni.JniObject attestationChallenge,
      bool uniqueIdIncluded,
      bool userAuthenticationValidWhileOnBody,
      bool invalidatedByBiometricEnrollment,
      bool isStrongBoxBacked,
      bool userConfirmationRequired,
      bool unlockedDeviceRequired)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [
          keyStoreAlias.reference,
          uid,
          keySize,
          spec.reference,
          certificateSubject.reference,
          certificateSerialNumber.reference,
          certificateNotBefore.reference,
          certificateNotAfter.reference,
          keyValidityStart.reference,
          keyValidityForOriginationEnd.reference,
          keyValidityForConsumptionEnd.reference,
          purposes,
          digests.reference,
          encryptionPaddings.reference,
          signaturePaddings.reference,
          blockModes.reference,
          randomizedEncryptionRequired,
          userAuthenticationRequired,
          userAuthenticationValidityDurationSeconds,
          userPresenceRequired,
          attestationChallenge.reference,
          uniqueIdIncluded,
          userAuthenticationValidWhileOnBody,
          invalidatedByBiometricEnrollment,
          isStrongBoxBacked,
          userConfirmationRequired,
          unlockedDeviceRequired
        ]).object);

  static final _id_getKeystoreAlias = jniAccessors.getMethodIDOf(
      _classRef, "getKeystoreAlias", "()Ljava/lang/String;");

  /// from: public java.lang.String getKeystoreAlias()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the alias that will be used in the {@code java.security.KeyStore}
  /// in conjunction with the {@code AndroidKeyStore}.
  ///@return This value will never be {@code null}.
  jni.JniString getKeystoreAlias() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getKeystoreAlias, jni.JniType.objectType, []).object);

  static final _id_getKeySize =
      jniAccessors.getMethodIDOf(_classRef, "getKeySize", "()I");

  /// from: public int getKeySize()
  ///
  /// Returns the requested key size. If {@code -1}, the size should be looked up from
  /// \#getAlgorithmParameterSpec(), if provided, otherwise an algorithm-specific default
  /// size should be used.
  int getKeySize() => jniAccessors.callMethodWithArgs(
      reference, _id_getKeySize, jni.JniType.intType, []).integer;

  static final _id_getAlgorithmParameterSpec = jniAccessors.getMethodIDOf(
      _classRef,
      "getAlgorithmParameterSpec",
      "()Ljava/security/spec/AlgorithmParameterSpec;");

  /// from: public java.security.spec.AlgorithmParameterSpec getAlgorithmParameterSpec()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the key algorithm-specific AlgorithmParameterSpec that will be used for
  /// creation of the key or {@code null} if algorithm-specific defaults should be used.
  jni.JniObject getAlgorithmParameterSpec() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAlgorithmParameterSpec, jni.JniType.objectType, []).object);

  static final _id_getCertificateSubject = jniAccessors.getMethodIDOf(_classRef,
      "getCertificateSubject", "()Ljavax/security/auth/x500/X500Principal;");

  /// from: public javax.security.auth.x500.X500Principal getCertificateSubject()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the subject distinguished name to be used on the X.509 certificate that will be put
  /// in the java.security.KeyStore.
  ///@return This value will never be {@code null}.
  jni.JniObject getCertificateSubject() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCertificateSubject, jni.JniType.objectType, []).object);

  static final _id_getCertificateSerialNumber = jniAccessors.getMethodIDOf(
      _classRef, "getCertificateSerialNumber", "()Ljava/math/BigInteger;");

  /// from: public java.math.BigInteger getCertificateSerialNumber()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the serial number to be used on the X.509 certificate that will be put in the
  /// java.security.KeyStore.
  ///@return This value will never be {@code null}.
  jni.JniObject getCertificateSerialNumber() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCertificateSerialNumber, jni.JniType.objectType, []).object);

  static final _id_getCertificateNotBefore = jniAccessors.getMethodIDOf(
      _classRef, "getCertificateNotBefore", "()Ljava/util/Date;");

  /// from: public java.util.Date getCertificateNotBefore()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the start date to be used on the X.509 certificate that will be put in the
  /// java.security.KeyStore.
  ///@return This value will never be {@code null}.
  jni.JniObject getCertificateNotBefore() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCertificateNotBefore, jni.JniType.objectType, []).object);

  static final _id_getCertificateNotAfter = jniAccessors.getMethodIDOf(
      _classRef, "getCertificateNotAfter", "()Ljava/util/Date;");

  /// from: public java.util.Date getCertificateNotAfter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the end date to be used on the X.509 certificate that will be put in the
  /// java.security.KeyStore.
  ///@return This value will never be {@code null}.
  jni.JniObject getCertificateNotAfter() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCertificateNotAfter, jni.JniType.objectType, []).object);

  static final _id_getKeyValidityStart = jniAccessors.getMethodIDOf(
      _classRef, "getKeyValidityStart", "()Ljava/util/Date;");

  /// from: public java.util.Date getKeyValidityStart()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the time instant before which the key is not yet valid or {@code null} if not
  /// restricted.
  jni.JniObject getKeyValidityStart() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getKeyValidityStart, jni.JniType.objectType, []).object);

  static final _id_getKeyValidityForConsumptionEnd = jniAccessors.getMethodIDOf(
      _classRef, "getKeyValidityForConsumptionEnd", "()Ljava/util/Date;");

  /// from: public java.util.Date getKeyValidityForConsumptionEnd()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the time instant after which the key is no longer valid for decryption and
  /// verification or {@code null} if not restricted.
  jni.JniObject getKeyValidityForConsumptionEnd() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getKeyValidityForConsumptionEnd,
          jni.JniType.objectType, []).object);

  static final _id_getKeyValidityForOriginationEnd = jniAccessors.getMethodIDOf(
      _classRef, "getKeyValidityForOriginationEnd", "()Ljava/util/Date;");

  /// from: public java.util.Date getKeyValidityForOriginationEnd()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the time instant after which the key is no longer valid for encryption and signing
  /// or {@code null} if not restricted.
  jni.JniObject getKeyValidityForOriginationEnd() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getKeyValidityForOriginationEnd,
          jni.JniType.objectType, []).object);

  static final _id_getPurposes =
      jniAccessors.getMethodIDOf(_classRef, "getPurposes", "()I");

  /// from: public int getPurposes()
  ///
  /// Returns the set of purposes (e.g., encrypt, decrypt, sign) for which the key can be used.
  /// Attempts to use the key for any other purpose will be rejected.
  ///
  /// See KeyProperties.{@code PURPOSE} flags.
  ///@return Value is either <code>0</code> or a combination of android.security.keystore.KeyProperties\#PURPOSE_ENCRYPT, android.security.keystore.KeyProperties\#PURPOSE_DECRYPT, android.security.keystore.KeyProperties\#PURPOSE_SIGN, android.security.keystore.KeyProperties\#PURPOSE_VERIFY, and android.security.keystore.KeyProperties\#PURPOSE_WRAP_KEY
  int getPurposes() => jniAccessors.callMethodWithArgs(
      reference, _id_getPurposes, jni.JniType.intType, []).integer;

  static final _id_getDigests = jniAccessors.getMethodIDOf(
      _classRef, "getDigests", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getDigests()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the set of digest algorithms (e.g., {@code SHA-256}, {@code SHA-384} with which the
  /// key can be used or {@code null} if not specified.
  ///
  /// See KeyProperties.{@code DIGEST} constants.
  ///@throws IllegalStateException if this set has not been specified.
  ///@see \#isDigestsSpecified()
  ///@return Value is android.security.keystore.KeyProperties\#DIGEST_NONE, android.security.keystore.KeyProperties\#DIGEST_MD5, android.security.keystore.KeyProperties\#DIGEST_SHA1, android.security.keystore.KeyProperties\#DIGEST_SHA224, android.security.keystore.KeyProperties\#DIGEST_SHA256, android.security.keystore.KeyProperties\#DIGEST_SHA384, or android.security.keystore.KeyProperties\#DIGEST_SHA512
  jni.JniObject getDigests() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDigests, jni.JniType.objectType, []).object);

  static final _id_isDigestsSpecified =
      jniAccessors.getMethodIDOf(_classRef, "isDigestsSpecified", "()Z");

  /// from: public boolean isDigestsSpecified()
  ///
  /// Returns {@code true} if the set of digest algorithms with which the key can be used has been
  /// specified.
  ///@see \#getDigests()
  ///@return This value will never be {@code null}.
  bool isDigestsSpecified() => jniAccessors.callMethodWithArgs(
      reference, _id_isDigestsSpecified, jni.JniType.booleanType, []).boolean;

  static final _id_getEncryptionPaddings = jniAccessors.getMethodIDOf(
      _classRef, "getEncryptionPaddings", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getEncryptionPaddings()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the set of padding schemes (e.g., {@code PKCS7Padding}, {@code OEAPPadding},
  /// {@code PKCS1Padding}, {@code NoPadding}) with which the key can be used when
  /// encrypting/decrypting. Attempts to use the key with any other padding scheme will be
  /// rejected.
  ///
  /// See KeyProperties.{@code ENCRYPTION_PADDING} constants.
  ///@return This value will never be {@code null}.
  ///
  /// Value is android.security.keystore.KeyProperties\#ENCRYPTION_PADDING_NONE, android.security.keystore.KeyProperties\#ENCRYPTION_PADDING_PKCS7, android.security.keystore.KeyProperties\#ENCRYPTION_PADDING_RSA_PKCS1, or android.security.keystore.KeyProperties\#ENCRYPTION_PADDING_RSA_OAEP
  jni.JniObject getEncryptionPaddings() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getEncryptionPaddings, jni.JniType.objectType, []).object);

  static final _id_getSignaturePaddings = jniAccessors.getMethodIDOf(
      _classRef, "getSignaturePaddings", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getSignaturePaddings()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the set of padding schemes (e.g., {@code PSS}, {@code PKCS\#1}) with which the key
  /// can be used when signing/verifying. Attempts to use the key with any other padding scheme
  /// will be rejected.
  ///
  /// See KeyProperties.{@code SIGNATURE_PADDING} constants.
  ///@return This value will never be {@code null}.
  ///
  /// Value is android.security.keystore.KeyProperties\#SIGNATURE_PADDING_RSA_PKCS1, or android.security.keystore.KeyProperties\#SIGNATURE_PADDING_RSA_PSS
  jni.JniObject getSignaturePaddings() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSignaturePaddings, jni.JniType.objectType, []).object);

  static final _id_getBlockModes = jniAccessors.getMethodIDOf(
      _classRef, "getBlockModes", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getBlockModes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the set of block modes (e.g., {@code GCM}, {@code CBC}) with which the key can be used
  /// when encrypting/decrypting. Attempts to use the key with any other block modes will be
  /// rejected.
  ///
  /// See KeyProperties.{@code BLOCK_MODE} constants.
  ///@return This value will never be {@code null}.
  ///
  /// Value is android.security.keystore.KeyProperties\#BLOCK_MODE_ECB, android.security.keystore.KeyProperties\#BLOCK_MODE_CBC, android.security.keystore.KeyProperties\#BLOCK_MODE_CTR, or android.security.keystore.KeyProperties\#BLOCK_MODE_GCM
  jni.JniObject getBlockModes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBlockModes, jni.JniType.objectType, []).object);

  static final _id_isRandomizedEncryptionRequired = jniAccessors.getMethodIDOf(
      _classRef, "isRandomizedEncryptionRequired", "()Z");

  /// from: public boolean isRandomizedEncryptionRequired()
  ///
  /// Returns {@code true} if encryption using this key must be sufficiently randomized to produce
  /// different ciphertexts for the same plaintext every time. The formal cryptographic property
  /// being required is _indistinguishability under chosen-plaintext attack ({@code
  /// IND-CPA})_. This property is important because it mitigates several classes of
  /// weaknesses due to which ciphertext may leak information about plaintext.  For example, if a
  /// given plaintext always produces the same ciphertext, an attacker may see the repeated
  /// ciphertexts and be able to deduce something about the plaintext.
  bool isRandomizedEncryptionRequired() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isRandomizedEncryptionRequired,
      jni.JniType.booleanType, []).boolean;

  static final _id_isUserAuthenticationRequired = jniAccessors.getMethodIDOf(
      _classRef, "isUserAuthenticationRequired", "()Z");

  /// from: public boolean isUserAuthenticationRequired()
  ///
  /// Returns {@code true} if the key is authorized to be used only if the user has been
  /// authenticated.
  ///
  /// This authorization applies only to secret key and private key operations. Public key
  /// operations are not restricted.
  ///@see \#getUserAuthenticationValidityDurationSeconds()
  ///@see Builder\#setUserAuthenticationRequired(boolean)
  bool isUserAuthenticationRequired() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isUserAuthenticationRequired,
      jni.JniType.booleanType, []).boolean;

  static final _id_isUserConfirmationRequired = jniAccessors.getMethodIDOf(
      _classRef, "isUserConfirmationRequired", "()Z");

  /// from: public boolean isUserConfirmationRequired()
  ///
  /// Returns {@code true} if the key is authorized to be used only for messages confirmed by the
  /// user.
  ///
  /// Confirmation is separate from user authentication (see
  /// Builder\#setUserAuthenticationRequired(boolean)). Keys can be created that require
  /// confirmation but not user authentication, or user authentication but not confirmation, or
  /// both. Confirmation verifies that some user with physical possession of the device has
  /// approved a displayed message. User authentication verifies that the correct user is present
  /// and has authenticated.
  ///
  /// This authorization applies only to secret key and private key operations. Public key
  /// operations are not restricted.
  ///@see Builder\#setUserConfirmationRequired(boolean)
  bool isUserConfirmationRequired() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isUserConfirmationRequired,
      jni.JniType.booleanType, []).boolean;

  static final _id_getUserAuthenticationValidityDurationSeconds =
      jniAccessors.getMethodIDOf(
          _classRef, "getUserAuthenticationValidityDurationSeconds", "()I");

  /// from: public int getUserAuthenticationValidityDurationSeconds()
  ///
  /// Gets the duration of time (seconds) for which this key is authorized to be used after the
  /// user is successfully authenticated. This has effect only if user authentication is required
  /// (see \#isUserAuthenticationRequired()).
  ///
  /// This authorization applies only to secret key and private key operations. Public key
  /// operations are not restricted.
  ///@return duration in seconds or {@code -1} if authentication is required for every use of the
  ///         key.
  ///@see \#isUserAuthenticationRequired()
  ///@see Builder\#setUserAuthenticationValidityDurationSeconds(int)
  int getUserAuthenticationValidityDurationSeconds() =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getUserAuthenticationValidityDurationSeconds,
          jni.JniType.intType, []).integer;

  static final _id_isUserPresenceRequired =
      jniAccessors.getMethodIDOf(_classRef, "isUserPresenceRequired", "()Z");

  /// from: public boolean isUserPresenceRequired()
  ///
  /// Returns {@code true} if the key is authorized to be used only if a test of user presence has
  /// been performed between the {@code Signature.initSign()} and {@code Signature.sign()} calls.
  /// It requires that the KeyStore implementation have a direct way to validate the user presence
  /// for example a KeyStore hardware backed strongbox can use a button press that is observable
  /// in hardware. A test for user presence is tangential to authentication. The test can be part
  /// of an authentication step as long as this step can be validated by the hardware protecting
  /// the key and cannot be spoofed. For example, a physical button press can be used as a test of
  /// user presence if the other pins connected to the button are not able to simulate a button
  /// press. There must be no way for the primary processor to fake a button press, or that
  /// button must not be used as a test of user presence.
  bool isUserPresenceRequired() => jniAccessors.callMethodWithArgs(reference,
      _id_isUserPresenceRequired, jni.JniType.booleanType, []).boolean;

  static final _id_getAttestationChallenge =
      jniAccessors.getMethodIDOf(_classRef, "getAttestationChallenge", "()[B");

  /// from: public byte[] getAttestationChallenge()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the attestation challenge value that will be placed in attestation certificate for
  /// this key pair.
  ///
  /// If this method returns non-{@code null}, the public key certificate for this key pair will
  /// contain an extension that describes the details of the key's configuration and
  /// authorizations, including the content of the attestation challenge value. If the key is in
  /// secure hardware, and if the secure hardware supports attestation, the certificate will be
  /// signed by a chain of certificates rooted at a trustworthy CA key. Otherwise the chain will
  /// be rooted at an untrusted certificate.
  ///
  /// If this method returns {@code null}, and the spec is used to generate an asymmetric (RSA
  /// or EC) key pair, the public key will have a self-signed certificate if it has purpose KeyProperties\#PURPOSE_SIGN. If does not have purpose KeyProperties\#PURPOSE_SIGN, it
  /// will have a fake certificate.
  ///
  /// Symmetric keys, such as AES and HMAC keys, do not have public key certificates. If a
  /// KeyGenParameterSpec with getAttestationChallenge returning non-null is used to generate a
  /// symmetric (AES or HMAC) key, javax.crypto.KeyGenerator\#generateKey() will throw
  /// java.security.InvalidAlgorithmParameterException.
  ///@see Builder\#setAttestationChallenge(byte[])
  jni.JniObject getAttestationChallenge() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAttestationChallenge, jni.JniType.objectType, []).object);

  static final _id_isUserAuthenticationValidWhileOnBody = jniAccessors
      .getMethodIDOf(_classRef, "isUserAuthenticationValidWhileOnBody", "()Z");

  /// from: public boolean isUserAuthenticationValidWhileOnBody()
  ///
  /// Returns {@code true} if the key will remain authorized only until the device is removed from
  /// the user's body, up to the validity duration.  This option has no effect on keys that don't
  /// have an authentication validity duration, and has no effect if the device lacks an on-body
  /// sensor.
  ///
  /// Authorization applies only to secret key and private key operations. Public key operations
  /// are not restricted.
  ///@see \#isUserAuthenticationRequired()
  ///@see \#getUserAuthenticationValidityDurationSeconds()
  ///@see Builder\#setUserAuthenticationValidWhileOnBody(boolean)
  bool isUserAuthenticationValidWhileOnBody() =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isUserAuthenticationValidWhileOnBody,
          jni.JniType.booleanType, []).boolean;

  static final _id_isInvalidatedByBiometricEnrollment = jniAccessors
      .getMethodIDOf(_classRef, "isInvalidatedByBiometricEnrollment", "()Z");

  /// from: public boolean isInvalidatedByBiometricEnrollment()
  ///
  /// Returns {@code true} if the key is irreversibly invalidated when a new fingerprint is
  /// enrolled or all enrolled fingerprints are removed. This has effect only for keys that
  /// require fingerprint user authentication for every use.
  ///@see \#isUserAuthenticationRequired()
  ///@see \#getUserAuthenticationValidityDurationSeconds()
  ///@see Builder\#setInvalidatedByBiometricEnrollment(boolean)
  bool isInvalidatedByBiometricEnrollment() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isInvalidatedByBiometricEnrollment,
      jni.JniType.booleanType, []).boolean;

  static final _id_isStrongBoxBacked =
      jniAccessors.getMethodIDOf(_classRef, "isStrongBoxBacked", "()Z");

  /// from: public boolean isStrongBoxBacked()
  ///
  /// Returns {@code true} if the key is protected by a Strongbox security chip.
  bool isStrongBoxBacked() => jniAccessors.callMethodWithArgs(
      reference, _id_isStrongBoxBacked, jni.JniType.booleanType, []).boolean;

  static final _id_isUnlockedDeviceRequired =
      jniAccessors.getMethodIDOf(_classRef, "isUnlockedDeviceRequired", "()Z");

  /// from: public boolean isUnlockedDeviceRequired()
  ///
  /// Returns {@code true} if the screen must be unlocked for this key to be used for decryption or
  /// signing. Encryption and signature verification will still be available when the screen is
  /// locked.
  ///@see Builder\#setUnlockedDeviceRequired(boolean)
  bool isUnlockedDeviceRequired() => jniAccessors.callMethodWithArgs(reference,
      _id_isUnlockedDeviceRequired, jni.JniType.booleanType, []).boolean;
}

/// from: android.security.keystore.KeyGenParameterSpec$Builder
///
/// Builder of KeyGenParameterSpec instances.
class KeyGenParameterSpec_Builder extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/security/keystore/KeyGenParameterSpec\$Builder");
  KeyGenParameterSpec_Builder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;I)V");

  /// from: public void <init>(java.lang.String keystoreAlias, int purposes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new instance of the {@code Builder}.
  ///@param keystoreAlias alias of the entry in which the generated key will appear in
  ///        Android KeyStore. Must not be empty.
  /// This value must never be {@code null}.
  ///@param purposes set of purposes (e.g., encrypt, decrypt, sign) for which the key can be
  ///        used. Attempts to use the key for any other purpose will be rejected.
  ///
  ///        If the set of purposes for which the key can be used does not contain
  ///        KeyProperties\#PURPOSE_SIGN, the self-signed certificate generated by
  ///        KeyPairGenerator of {@code AndroidKeyStore} provider will contain an
  ///        invalid signature. This is OK if the certificate is only used for obtaining the
  ///        public key from Android KeyStore.
  ///
  ///        See KeyProperties.{@code PURPOSE} flags.
  ///
  /// Value is either <code>0</code> or a combination of android.security.keystore.KeyProperties\#PURPOSE_ENCRYPT, android.security.keystore.KeyProperties\#PURPOSE_DECRYPT, android.security.keystore.KeyProperties\#PURPOSE_SIGN, android.security.keystore.KeyProperties\#PURPOSE_VERIFY, and android.security.keystore.KeyProperties\#PURPOSE_WRAP_KEY
  KeyGenParameterSpec_Builder(jni.JniString keystoreAlias, int purposes)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [keystoreAlias.reference, purposes]).object);

  static final _id_setKeySize = jniAccessors.getMethodIDOf(
      _classRef,
      "setKeySize",
      "(I)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setKeySize(int keySize)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the size (in bits) of the key to be generated. For instance, for RSA keys this sets
  /// the modulus size, for EC keys this selects a curve with a matching field size, and for
  /// symmetric keys this sets the size of the bitstring which is their key material.
  ///
  /// The default key size is specific to each key algorithm. If key size is not set
  /// via this method, it should be looked up from the algorithm-specific parameters (if any)
  /// provided via
  /// \#setAlgorithmParameterSpec(AlgorithmParameterSpec) setAlgorithmParameterSpec.
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setKeySize(int keySize) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_setKeySize, jni.JniType.objectType, [keySize]).object);

  static final _id_setAlgorithmParameterSpec = jniAccessors.getMethodIDOf(
      _classRef,
      "setAlgorithmParameterSpec",
      "(Ljava/security/spec/AlgorithmParameterSpec;)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setAlgorithmParameterSpec(java.security.spec.AlgorithmParameterSpec spec)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the algorithm-specific key generation parameters. For example, for RSA keys this may
  /// be an instance of java.security.spec.RSAKeyGenParameterSpec whereas for EC keys
  /// this may be an instance of java.security.spec.ECGenParameterSpec.
  ///
  /// These key generation parameters must match other explicitly set parameters (if any),
  /// such as key size.
  ///@param spec This value must never be {@code null}.
  KeyGenParameterSpec_Builder setAlgorithmParameterSpec(jni.JniObject spec) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setAlgorithmParameterSpec,
          jni.JniType.objectType,
          [spec.reference]).object);

  static final _id_setCertificateSubject = jniAccessors.getMethodIDOf(
      _classRef,
      "setCertificateSubject",
      "(Ljavax/security/auth/x500/X500Principal;)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setCertificateSubject(javax.security.auth.x500.X500Principal subject)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the subject used for the self-signed certificate of the generated key pair.
  ///
  /// By default, the subject is {@code CN=fake}.
  ///@param subject This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setCertificateSubject(jni.JniObject subject) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setCertificateSubject,
          jni.JniType.objectType,
          [subject.reference]).object);

  static final _id_setCertificateSerialNumber = jniAccessors.getMethodIDOf(
      _classRef,
      "setCertificateSerialNumber",
      "(Ljava/math/BigInteger;)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setCertificateSerialNumber(java.math.BigInteger serialNumber)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the serial number used for the self-signed certificate of the generated key pair.
  ///
  /// By default, the serial number is {@code 1}.
  ///@param serialNumber This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setCertificateSerialNumber(
          jni.JniObject serialNumber) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setCertificateSerialNumber,
          jni.JniType.objectType,
          [serialNumber.reference]).object);

  static final _id_setCertificateNotBefore = jniAccessors.getMethodIDOf(
      _classRef,
      "setCertificateNotBefore",
      "(Ljava/util/Date;)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setCertificateNotBefore(java.util.Date date)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the start of the validity period for the self-signed certificate of the generated
  /// key pair.
  ///
  /// By default, this date is {@code Jan 1 1970}.
  ///@param date This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setCertificateNotBefore(jni.JniObject date) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setCertificateNotBefore,
          jni.JniType.objectType,
          [date.reference]).object);

  static final _id_setCertificateNotAfter = jniAccessors.getMethodIDOf(
      _classRef,
      "setCertificateNotAfter",
      "(Ljava/util/Date;)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setCertificateNotAfter(java.util.Date date)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the end of the validity period for the self-signed certificate of the generated key
  /// pair.
  ///
  /// By default, this date is {@code Jan 1 2048}.
  ///@param date This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setCertificateNotAfter(jni.JniObject date) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setCertificateNotAfter,
          jni.JniType.objectType,
          [date.reference]).object);

  static final _id_setKeyValidityStart = jniAccessors.getMethodIDOf(
      _classRef,
      "setKeyValidityStart",
      "(Ljava/util/Date;)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setKeyValidityStart(java.util.Date startDate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the time instant before which the key is not yet valid.
  ///
  /// By default, the key is valid at any instant.
  ///@see \#setKeyValidityEnd(Date)
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setKeyValidityStart(jni.JniObject startDate) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setKeyValidityStart,
          jni.JniType.objectType,
          [startDate.reference]).object);

  static final _id_setKeyValidityEnd = jniAccessors.getMethodIDOf(
      _classRef,
      "setKeyValidityEnd",
      "(Ljava/util/Date;)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setKeyValidityEnd(java.util.Date endDate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the time instant after which the key is no longer valid.
  ///
  /// By default, the key is valid at any instant.
  ///@see \#setKeyValidityStart(Date)
  ///@see \#setKeyValidityForConsumptionEnd(Date)
  ///@see \#setKeyValidityForOriginationEnd(Date)
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setKeyValidityEnd(jni.JniObject endDate) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setKeyValidityEnd,
          jni.JniType.objectType,
          [endDate.reference]).object);

  static final _id_setKeyValidityForOriginationEnd = jniAccessors.getMethodIDOf(
      _classRef,
      "setKeyValidityForOriginationEnd",
      "(Ljava/util/Date;)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setKeyValidityForOriginationEnd(java.util.Date endDate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the time instant after which the key is no longer valid for encryption and signing.
  ///
  /// By default, the key is valid at any instant.
  ///@see \#setKeyValidityForConsumptionEnd(Date)
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setKeyValidityForOriginationEnd(
          jni.JniObject endDate) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setKeyValidityForOriginationEnd,
          jni.JniType.objectType,
          [endDate.reference]).object);

  static final _id_setKeyValidityForConsumptionEnd = jniAccessors.getMethodIDOf(
      _classRef,
      "setKeyValidityForConsumptionEnd",
      "(Ljava/util/Date;)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setKeyValidityForConsumptionEnd(java.util.Date endDate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the time instant after which the key is no longer valid for decryption and
  /// verification.
  ///
  /// By default, the key is valid at any instant.
  ///@see \#setKeyValidityForOriginationEnd(Date)
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setKeyValidityForConsumptionEnd(
          jni.JniObject endDate) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setKeyValidityForConsumptionEnd,
          jni.JniType.objectType,
          [endDate.reference]).object);

  static final _id_setDigests = jniAccessors.getMethodIDOf(
      _classRef,
      "setDigests",
      "([Ljava/lang/String;)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setDigests(java.lang.String[] digests)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the set of digests algorithms (e.g., {@code SHA-256}, {@code SHA-384}) with which
  /// the key can be used. Attempts to use the key with any other digest algorithm will be
  /// rejected.
  ///
  /// This must be specified for signing/verification keys and RSA encryption/decryption
  /// keys used with RSA OAEP padding scheme because these operations involve a digest. For
  /// HMAC keys, the default is the digest associated with the key algorithm (e.g.,
  /// {@code SHA-256} for key algorithm {@code HmacSHA256}). HMAC keys cannot be authorized
  /// for more than one digest.
  ///
  /// For private keys used for TLS/SSL client or server authentication it is usually
  /// necessary to authorize the use of no digest (KeyProperties\#DIGEST_NONE). This is
  /// because TLS/SSL stacks typically generate the necessary digest(s) themselves and then use
  /// a private key to sign it.
  ///
  /// See KeyProperties.{@code DIGEST} constants.
  ///@param digests Value is android.security.keystore.KeyProperties\#DIGEST_NONE, android.security.keystore.KeyProperties\#DIGEST_MD5, android.security.keystore.KeyProperties\#DIGEST_SHA1, android.security.keystore.KeyProperties\#DIGEST_SHA224, android.security.keystore.KeyProperties\#DIGEST_SHA256, android.security.keystore.KeyProperties\#DIGEST_SHA384, or android.security.keystore.KeyProperties\#DIGEST_SHA512
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setDigests(jni.JniObject digests) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setDigests,
          jni.JniType.objectType,
          [digests.reference]).object);

  static final _id_setEncryptionPaddings = jniAccessors.getMethodIDOf(
      _classRef,
      "setEncryptionPaddings",
      "([Ljava/lang/String;)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setEncryptionPaddings(java.lang.String[] paddings)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the set of padding schemes (e.g., {@code PKCS7Padding}, {@code OAEPPadding},
  /// {@code PKCS1Padding}, {@code NoPadding}) with which the key can be used when
  /// encrypting/decrypting. Attempts to use the key with any other padding scheme will be
  /// rejected.
  ///
  /// This must be specified for keys which are used for encryption/decryption.
  ///
  /// For RSA private keys used by TLS/SSL servers to authenticate themselves to clients it
  /// is usually necessary to authorize the use of no/any padding
  /// (KeyProperties\#ENCRYPTION_PADDING_NONE) and/or PKCS\#1 encryption padding
  /// (KeyProperties\#ENCRYPTION_PADDING_RSA_PKCS1). This is because RSA decryption is
  /// required by some cipher suites, and some stacks request decryption using no padding
  /// whereas others request PKCS\#1 padding.
  ///
  /// See KeyProperties.{@code ENCRYPTION_PADDING} constants.
  ///@param paddings Value is android.security.keystore.KeyProperties\#ENCRYPTION_PADDING_NONE, android.security.keystore.KeyProperties\#ENCRYPTION_PADDING_PKCS7, android.security.keystore.KeyProperties\#ENCRYPTION_PADDING_RSA_PKCS1, or android.security.keystore.KeyProperties\#ENCRYPTION_PADDING_RSA_OAEP
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setEncryptionPaddings(jni.JniObject paddings) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setEncryptionPaddings,
          jni.JniType.objectType,
          [paddings.reference]).object);

  static final _id_setSignaturePaddings = jniAccessors.getMethodIDOf(
      _classRef,
      "setSignaturePaddings",
      "([Ljava/lang/String;)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setSignaturePaddings(java.lang.String[] paddings)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the set of padding schemes (e.g., {@code PSS}, {@code PKCS\#1}) with which the key
  /// can be used when signing/verifying. Attempts to use the key with any other padding scheme
  /// will be rejected.
  ///
  /// This must be specified for RSA keys which are used for signing/verification.
  ///
  /// See KeyProperties.{@code SIGNATURE_PADDING} constants.
  ///@param paddings Value is android.security.keystore.KeyProperties\#SIGNATURE_PADDING_RSA_PKCS1, or android.security.keystore.KeyProperties\#SIGNATURE_PADDING_RSA_PSS
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setSignaturePaddings(jni.JniObject paddings) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setSignaturePaddings,
          jni.JniType.objectType,
          [paddings.reference]).object);

  static final _id_setBlockModes = jniAccessors.getMethodIDOf(
      _classRef,
      "setBlockModes",
      "([Ljava/lang/String;)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setBlockModes(java.lang.String[] blockModes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the set of block modes (e.g., {@code GCM}, {@code CBC}) with which the key can be
  /// used when encrypting/decrypting. Attempts to use the key with any other block modes will
  /// be rejected.
  ///
  /// This must be specified for symmetric encryption/decryption keys.
  ///
  /// See KeyProperties.{@code BLOCK_MODE} constants.
  ///@param blockModes Value is android.security.keystore.KeyProperties\#BLOCK_MODE_ECB, android.security.keystore.KeyProperties\#BLOCK_MODE_CBC, android.security.keystore.KeyProperties\#BLOCK_MODE_CTR, or android.security.keystore.KeyProperties\#BLOCK_MODE_GCM
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setBlockModes(jni.JniObject blockModes) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setBlockModes,
          jni.JniType.objectType,
          [blockModes.reference]).object);

  static final _id_setRandomizedEncryptionRequired = jniAccessors.getMethodIDOf(
      _classRef,
      "setRandomizedEncryptionRequired",
      "(Z)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setRandomizedEncryptionRequired(boolean required)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether encryption using this key must be sufficiently randomized to produce
  /// different ciphertexts for the same plaintext every time. The formal cryptographic
  /// property being required is _indistinguishability under chosen-plaintext attack
  /// ({@code IND-CPA})_. This property is important because it mitigates several classes
  /// of weaknesses due to which ciphertext may leak information about plaintext. For example,
  /// if a given plaintext always produces the same ciphertext, an attacker may see the
  /// repeated ciphertexts and be able to deduce something about the plaintext.
  ///
  /// By default, {@code IND-CPA} is required.
  ///
  /// When {@code IND-CPA} is required:
  /// <ul>
  /// <li>encryption/decryption transformation which do not offer {@code IND-CPA}, such as
  /// {@code ECB} with a symmetric encryption algorithm, or RSA encryption/decryption without
  /// padding, are prohibited;</li>
  /// <li>in block modes which use an IV, such as {@code GCM}, {@code CBC}, and {@code CTR},
  /// caller-provided IVs are rejected when encrypting, to ensure that only random IVs are
  /// used.</li>
  /// </ul>
  ///
  /// Before disabling this requirement, consider the following approaches instead:
  /// <ul>
  /// <li>If you are generating a random IV for encryption and then initializing a {@code}
  /// Cipher using the IV, the solution is to let the {@code Cipher} generate a random IV
  /// instead. This will occur if the {@code Cipher} is initialized for encryption without an
  /// IV. The IV can then be queried via Cipher\#getIV().</li>
  /// <li>If you are generating a non-random IV (e.g., an IV derived from something not fully
  /// random, such as the name of the file being encrypted, or transaction ID, or password,
  /// or a device identifier), consider changing your design to use a random IV which will then
  /// be provided in addition to the ciphertext to the entities which need to decrypt the
  /// ciphertext.</li>
  /// <li>If you are using RSA encryption without padding, consider switching to encryption
  /// padding schemes which offer {@code IND-CPA}, such as PKCS\#1 or OAEP.</li>
  /// </ul>
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setRandomizedEncryptionRequired(bool required0) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setRandomizedEncryptionRequired,
          jni.JniType.objectType,
          [required0]).object);

  static final _id_setUserAuthenticationRequired = jniAccessors.getMethodIDOf(
      _classRef,
      "setUserAuthenticationRequired",
      "(Z)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setUserAuthenticationRequired(boolean required)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether this key is authorized to be used only if the user has been authenticated.
  ///
  /// By default, the key is authorized to be used regardless of whether the user has been
  /// authenticated.
  ///
  /// When user authentication is required:
  /// <ul>
  /// <li>The key can only be generated if secure lock screen is set up (see
  /// KeyguardManager\#isDeviceSecure()). Additionally, if the key requires that user
  /// authentication takes place for every use of the key (see
  /// \#setUserAuthenticationValidityDurationSeconds(int)), at least one fingerprint
  /// must be enrolled (see FingerprintManager\#hasEnrolledFingerprints()).</li>
  /// <li>The use of the key must be authorized by the user by authenticating to this Android
  /// device using a subset of their secure lock screen credentials such as
  /// password/PIN/pattern or fingerprint.
  /// <a href="{@docRoot}training/articles/keystore.html\#UserAuthentication">More
  /// information</a>.
  /// <li>The key will become _irreversibly invalidated_ once the secure lock screen is
  /// disabled (reconfigured to None, Swipe or other mode which does not authenticate the user)
  /// or when the secure lock screen is forcibly reset (e.g., by a Device Administrator).
  /// Additionally, if the key requires that user authentication takes place for every use of
  /// the key, it is also irreversibly invalidated once a new fingerprint is enrolled or once\
  /// no more fingerprints are enrolled, unless \#setInvalidatedByBiometricEnrollment(boolean) is used to allow validity after
  /// enrollment. Attempts to initialize cryptographic operations using such keys will throw
  /// KeyPermanentlyInvalidatedException.</li>
  /// </ul>
  ///
  /// This authorization applies only to secret key and private key operations. Public key
  /// operations are not restricted.
  ///@see \#setUserAuthenticationValidityDurationSeconds(int)
  ///@see KeyguardManager\#isDeviceSecure()
  ///@see FingerprintManager\#hasEnrolledFingerprints()
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setUserAuthenticationRequired(bool required0) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setUserAuthenticationRequired,
          jni.JniType.objectType,
          [required0]).object);

  static final _id_setUserConfirmationRequired = jniAccessors.getMethodIDOf(
      _classRef,
      "setUserConfirmationRequired",
      "(Z)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setUserConfirmationRequired(boolean required)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether this key is authorized to be used only for messages confirmed by the
  /// user.
  ///
  /// Confirmation is separate from user authentication (see
  /// \#setUserAuthenticationRequired(boolean)). Keys can be created that require
  /// confirmation but not user authentication, or user authentication but not confirmation,
  /// or both. Confirmation verifies that some user with physical possession of the device has
  /// approved a displayed message. User authentication verifies that the correct user is
  /// present and has authenticated.
  ///
  /// This authorization applies only to secret key and private key operations. Public key
  /// operations are not restricted.
  ///@see android.security.ConfirmationPrompter ConfirmationPrompter class for
  /// more details about user confirmations.
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setUserConfirmationRequired(bool required0) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setUserConfirmationRequired,
          jni.JniType.objectType,
          [required0]).object);

  static final _id_setUserAuthenticationValidityDurationSeconds =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setUserAuthenticationValidityDurationSeconds",
          "(I)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setUserAuthenticationValidityDurationSeconds(int seconds)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the duration of time (seconds) for which this key is authorized to be used after the
  /// user is successfully authenticated. This has effect if the key requires user
  /// authentication for its use (see \#setUserAuthenticationRequired(boolean)).
  ///
  /// By default, if user authentication is required, it must take place for every use of
  /// the key.
  ///
  /// Cryptographic operations involving keys which require user authentication to take
  /// place for every operation can only use fingerprint authentication. This is achieved by
  /// initializing a cryptographic operation (Signature, Cipher, Mac)
  /// with the key, wrapping it into a FingerprintManager.CryptoObject, invoking
  /// {@code FingerprintManager.authenticate} with {@code CryptoObject}, and proceeding with
  /// the cryptographic operation only if the authentication flow succeeds.
  ///
  /// Cryptographic operations involving keys which are authorized to be used for a duration
  /// of time after a successful user authentication event can only use secure lock screen
  /// authentication. These cryptographic operations will throw
  /// UserNotAuthenticatedException during initialization if the user needs to be
  /// authenticated to proceed. This situation can be resolved by the user unlocking the secure
  /// lock screen of the Android or by going through the confirm credential flow initiated by
  /// KeyguardManager\#createConfirmDeviceCredentialIntent(CharSequence, CharSequence).
  /// Once resolved, initializing a new cryptographic operation using this key (or any other
  /// key which is authorized to be used for a fixed duration of time after user
  /// authentication) should succeed provided the user authentication flow completed
  /// successfully.
  ///@param seconds duration in seconds or {@code -1} if user authentication must take place
  ///        for every use of the key.
  ///
  /// Value is -1 or greater
  ///@see \#setUserAuthenticationRequired(boolean)
  ///@see FingerprintManager
  ///@see FingerprintManager.CryptoObject
  ///@see KeyguardManager
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setUserAuthenticationValidityDurationSeconds(
          int seconds) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setUserAuthenticationValidityDurationSeconds,
          jni.JniType.objectType,
          [seconds]).object);

  static final _id_setUserPresenceRequired = jniAccessors.getMethodIDOf(
      _classRef,
      "setUserPresenceRequired",
      "(Z)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setUserPresenceRequired(boolean required)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether a test of user presence is required to be performed between the
  /// {@code Signature.initSign()} and {@code Signature.sign()} method calls.
  /// It requires that the KeyStore implementation have a direct way to validate the user
  /// presence for example a KeyStore hardware backed strongbox can use a button press that
  /// is observable in hardware. A test for user presence is tangential to authentication. The
  /// test can be part of an authentication step as long as this step can be validated by the
  /// hardware protecting the key and cannot be spoofed. For example, a physical button press
  /// can be used as a test of user presence if the other pins connected to the button are not
  /// able to simulate a button press.There must be no way for the primary processor to fake a
  /// button press, or that button must not be used as a test of user presence.
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setUserPresenceRequired(bool required0) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setUserPresenceRequired,
          jni.JniType.objectType,
          [required0]).object);

  static final _id_setAttestationChallenge = jniAccessors.getMethodIDOf(
      _classRef,
      "setAttestationChallenge",
      "([B)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setAttestationChallenge(byte[] attestationChallenge)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether an attestation certificate will be generated for this key pair, and what
  /// challenge value will be placed in the certificate.  The attestation certificate chain
  /// can be retrieved with with java.security.KeyStore\#getCertificateChain(String).
  ///
  /// If {@code attestationChallenge} is not {@code null}, the public key certificate for
  /// this key pair will contain an extension that describes the details of the key's
  /// configuration and authorizations, including the {@code attestationChallenge} value. If
  /// the key is in secure hardware, and if the secure hardware supports attestation, the
  /// certificate will be signed by a chain of certificates rooted at a trustworthy CA key.
  /// Otherwise the chain will be rooted at an untrusted certificate.
  ///
  /// The purpose of the challenge value is to enable relying parties to verify that the key
  /// was created in response to a specific request. If attestation is desired but no
  /// challenged is needed, any non-{@code null} value may be used, including an empty byte
  /// array.
  ///
  /// If {@code attestationChallenge} is {@code null}, and this spec is used to generate an
  /// asymmetric (RSA or EC) key pair, the public key certificate will be self-signed if the
  /// key has purpose android.security.keystore.KeyProperties\#PURPOSE_SIGN. If the key
  /// does not have purpose android.security.keystore.KeyProperties\#PURPOSE_SIGN, it is
  /// not possible to use the key to sign a certificate, so the public key certificate will
  /// contain a dummy signature.
  ///
  /// Symmetric keys, such as AES and HMAC keys, do not have public key certificates. If a
  /// \#getAttestationChallenge() returns non-null and the spec is used to generate a
  /// symmetric (AES or HMAC) key, javax.crypto.KeyGenerator\#generateKey() will throw
  /// java.security.InvalidAlgorithmParameterException.
  KeyGenParameterSpec_Builder setAttestationChallenge(
          jni.JniObject attestationChallenge) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setAttestationChallenge,
          jni.JniType.objectType,
          [attestationChallenge.reference]).object);

  static final _id_setUserAuthenticationValidWhileOnBody =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setUserAuthenticationValidWhileOnBody",
          "(Z)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setUserAuthenticationValidWhileOnBody(boolean remainsValid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether the key will remain authorized only until the device is removed from the
  /// user's body up to the limit of the authentication validity period (see
  /// \#setUserAuthenticationValidityDurationSeconds and
  /// \#setUserAuthenticationRequired). Once the device has been removed from the
  /// user's body, the key will be considered unauthorized and the user will need to
  /// re-authenticate to use it. For keys without an authentication validity period this
  /// parameter has no effect.
  ///
  /// Similarly, on devices that do not have an on-body sensor, this parameter will have no
  /// effect; the device will always be considered to be "on-body" and the key will therefore
  /// remain authorized until the validity period ends.
  ///@param remainsValid if {@code true}, and if the device supports on-body detection, key
  /// will be invalidated when the device is removed from the user's body or when the
  /// authentication validity expires, whichever occurs first.
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setUserAuthenticationValidWhileOnBody(
          bool remainsValid) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setUserAuthenticationValidWhileOnBody,
          jni.JniType.objectType,
          [remainsValid]).object);

  static final _id_setInvalidatedByBiometricEnrollment =
      jniAccessors.getMethodIDOf(
          _classRef,
          "setInvalidatedByBiometricEnrollment",
          "(Z)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setInvalidatedByBiometricEnrollment(boolean invalidateKey)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether this key should be invalidated on fingerprint enrollment.  This
  /// applies only to keys which require user authentication (see \#setUserAuthenticationRequired(boolean)) and if no positive validity duration has been
  /// set (see \#setUserAuthenticationValidityDurationSeconds(int), meaning the key is
  /// valid for fingerprint authentication only.
  ///
  /// By default, {@code invalidateKey} is {@code true}, so keys that are valid for
  /// fingerprint authentication only are _irreversibly invalidated_ when a new
  /// fingerprint is enrolled, or when all existing fingerprints are deleted.  That may be
  /// changed by calling this method with {@code invalidateKey} set to {@code false}.
  ///
  /// Invalidating keys on enrollment of a new finger or unenrollment of all fingers
  /// improves security by ensuring that an unauthorized person who obtains the password can't
  /// gain the use of fingerprint-authenticated keys by enrolling their own finger.  However,
  /// invalidating keys makes key-dependent operations impossible, requiring some fallback
  /// procedure to authenticate the user and set up a new key.
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setInvalidatedByBiometricEnrollment(
          bool invalidateKey) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setInvalidatedByBiometricEnrollment,
          jni.JniType.objectType,
          [invalidateKey]).object);

  static final _id_setIsStrongBoxBacked = jniAccessors.getMethodIDOf(
      _classRef,
      "setIsStrongBoxBacked",
      "(Z)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setIsStrongBoxBacked(boolean isStrongBoxBacked)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether this key should be protected by a StrongBox security chip.
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setIsStrongBoxBacked(bool isStrongBoxBacked) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setIsStrongBoxBacked,
          jni.JniType.objectType,
          [isStrongBoxBacked]).object);

  static final _id_setUnlockedDeviceRequired = jniAccessors.getMethodIDOf(
      _classRef,
      "setUnlockedDeviceRequired",
      "(Z)Landroid/security/keystore/KeyGenParameterSpec\$Builder;");

  /// from: public android.security.keystore.KeyGenParameterSpec.Builder setUnlockedDeviceRequired(boolean unlockedDeviceRequired)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether the keystore requires the screen to be unlocked before allowing decryption
  /// using this key. If this is set to {@code true}, any attempt to decrypt or sign using this
  /// key while the screen is locked will fail. A locked device requires a PIN, password,
  /// fingerprint, or other trusted factor to access. While the screen is locked, the key can
  /// still be used for encryption or signature verification.
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec_Builder setUnlockedDeviceRequired(
          bool unlockedDeviceRequired) =>
      KeyGenParameterSpec_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setUnlockedDeviceRequired,
          jni.JniType.objectType,
          [unlockedDeviceRequired]).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/security/keystore/KeyGenParameterSpec;");

  /// from: public android.security.keystore.KeyGenParameterSpec build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Builds an instance of {@code KeyGenParameterSpec}.
  ///@return This value will never be {@code null}.
  KeyGenParameterSpec build() =>
      KeyGenParameterSpec.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_build, jni.JniType.objectType, []).object);
}
