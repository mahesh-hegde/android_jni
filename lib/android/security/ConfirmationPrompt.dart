// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "ConfirmationCallback.dart" as confirmationcallback_;

import "../content/Context.dart" as context_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.security.ConfirmationPrompt
///
/// Class used for displaying confirmation prompts.
///
/// Confirmation prompts are prompts shown to the user to confirm a given text and are
/// implemented in a way that a positive response indicates with high confidence that the user has
/// seen the given text, even if the Android framework (including the kernel) was
/// compromised. Implementing confirmation prompts with these guarantees requires dedicated
/// hardware-support and may not always be available.
///
/// Confirmation prompts are typically used with an external entitity - the <i>Relying Party</i> -
/// in the following way. The setup steps are as follows:
/// <ul>
/// <li> Before first use, the application generates a key-pair with the
/// android.security.keystore.KeyGenParameterSpec.Builder\#setUserConfirmationRequired CONFIRMATION tag set. Device attestation,
/// e.g. java.security.KeyStore\#getCertificateChain getCertificateChain(), is used to
/// generate a certificate chain that includes the public key (<code>Kpub</code> in the following)
/// of the newly generated key.
/// <li> The application sends <code>Kpub</code> and the certificate chain resulting from device
/// attestation to the <i>Relying Party</i>.
/// <li> The <i>Relying Party</i> validates the certificate chain which involves checking the root
/// certificate is what is expected (e.g. a certificate from Google), each certificate signs the
/// next one in the chain, ending with <code>Kpub</code>, and that the attestation certificate
/// asserts that <code>Kpub</code> has the
/// android.security.keystore.KeyGenParameterSpec.Builder\#setUserConfirmationRequired CONFIRMATION tag set.
/// Additionally the relying party stores <code>Kpub</code> and associates it with the device
/// it was received from.
/// </ul>
///
/// The <i>Relying Party</i> is typically an external device (for example connected via
/// Bluetooth) or application server.
///
/// Before executing a transaction which requires a high assurance of user content, the
/// application does the following:
/// <ul>
/// <li> The application gets a cryptographic nonce from the <i>Relying Party</i> and passes this as
/// the <code>extraData</code> (via the Builder helper class) to the
/// \#presentPrompt presentPrompt() method. The <i>Relying Party</i> stores the nonce locally
/// since it'll use it in a later step.
/// <li> If the user approves the prompt a <i>Confirmation Response</i> is returned in the
/// ConfirmationCallback\#onConfirmed onConfirmed(byte[]) callback as the
/// <code>dataThatWasConfirmed</code> parameter. This blob contains the text that was shown to the
/// user, the <code>extraData</code> parameter, and possibly other data.
/// <li> The application signs the <i>Confirmation Response</i> with the previously created key and
/// sends the blob and the signature to the <i>Relying Party</i>.
/// <li> The <i>Relying Party</i> checks that the signature was made with <code>Kpub</code> and then
/// extracts <code>promptText</code> matches what is expected and <code>extraData</code> matches the
/// previously created nonce. If all checks passes, the transaction is executed.
/// </ul>
///
/// A common way of implementing the "<code>promptText</code> is what is expected" check in the
/// last bullet, is to have the <i>Relying Party</i> generate <code>promptText</code> and store it
/// along the nonce in the <code>extraData</code> blob.
class ConfirmationPrompt extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/security/ConfirmationPrompt");
  ConfirmationPrompt.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_presentPrompt = jniAccessors.getMethodIDOf(
      _classRef,
      "presentPrompt",
      "(Ljava/util/concurrent/Executor;Landroid/security/ConfirmationCallback;)V");

  /// from: public void presentPrompt(java.util.concurrent.Executor executor, android.security.ConfirmationCallback callback)
  ///
  /// Requests a confirmation prompt to be presented to the user.
  ///
  /// When the prompt is no longer being presented, one of the methods in
  /// ConfirmationCallback is called on the supplied callback object.
  ///
  /// Confirmation prompts may not be available when accessibility services are running so this
  /// may fail with a ConfirmationNotAvailableException exception even if
  /// \#isSupported returns {@code true}.
  ///@param executor the executor identifying the thread that will receive the callback.
  /// This value must never be {@code null}.
  ///@param callback the callback to use when the prompt is done showing.
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if the prompt text is too long or malfomed.
  ///@throws ConfirmationAlreadyPresentingException if another prompt is being presented.
  ///@throws ConfirmationNotAvailableException if confirmation prompts are not supported.
  void presentPrompt(jni.JniObject executor,
          confirmationcallback_.ConfirmationCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_presentPrompt,
          jni.JniType.voidType,
          [executor.reference, callback.reference]).check();

  static final _id_cancelPrompt =
      jniAccessors.getMethodIDOf(_classRef, "cancelPrompt", "()V");

  /// from: public void cancelPrompt()
  ///
  /// Cancels a prompt currently being displayed.
  ///
  /// On success, the
  /// ConfirmationCallback\#onCanceled onCanceled() method on
  /// the supplied callback object will be called asynchronously.
  ///@throws IllegalStateException if no prompt is currently being presented.
  void cancelPrompt() => jniAccessors.callMethodWithArgs(
      reference, _id_cancelPrompt, jni.JniType.voidType, []).check();

  static final _id_isSupported = jniAccessors.getStaticMethodIDOf(
      _classRef, "isSupported", "(Landroid/content/Context;)Z");

  /// from: static public boolean isSupported(android.content.Context context)
  ///
  /// Checks if the device supports confirmation prompts.
  ///@param context the application context.
  ///@return true if confirmation prompts are supported by the device.
  static bool isSupported(context_.Context context) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isSupported,
          jni.JniType.booleanType, [context.reference]).boolean;
}

/// from: android.security.ConfirmationPrompt$Builder
///
/// A builder that collects arguments, to be shown on the system-provided confirmation prompt.
class ConfirmationPrompt_Builder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/security/ConfirmationPrompt\$Builder");
  ConfirmationPrompt_Builder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a builder for the confirmation prompt.
  ///@param context the application context
  ConfirmationPrompt_Builder(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_setPromptText = jniAccessors.getMethodIDOf(
      _classRef,
      "setPromptText",
      "(Ljava/lang/CharSequence;)Landroid/security/ConfirmationPrompt\$Builder;");

  /// from: public android.security.ConfirmationPrompt.Builder setPromptText(java.lang.CharSequence promptText)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the prompt text for the prompt.
  ///@param promptText the text to present in the prompt.
  ///@return the builder.
  ConfirmationPrompt_Builder setPromptText(jni.JniObject promptText) =>
      ConfirmationPrompt_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setPromptText,
          jni.JniType.objectType,
          [promptText.reference]).object);

  static final _id_setExtraData = jniAccessors.getMethodIDOf(_classRef,
      "setExtraData", "([B)Landroid/security/ConfirmationPrompt\$Builder;");

  /// from: public android.security.ConfirmationPrompt.Builder setExtraData(byte[] extraData)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the extra data for the prompt.
  ///@param extraData data to include in the response data.
  ///@return the builder.
  ConfirmationPrompt_Builder setExtraData(jni.JniObject extraData) =>
      ConfirmationPrompt_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setExtraData,
          jni.JniType.objectType,
          [extraData.reference]).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/security/ConfirmationPrompt;");

  /// from: public android.security.ConfirmationPrompt build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a ConfirmationPrompt with the arguments supplied to this builder.
  ///@return a ConfirmationPrompt
  ///@throws IllegalArgumentException if any of the required fields are not set.
  ConfirmationPrompt build() =>
      ConfirmationPrompt.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_build, jni.JniType.objectType, []).object);
}
