// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../app/Service.dart" as service_;

import "SynthesisRequest.dart" as synthesisrequest_;

import "SynthesisCallback.dart" as synthesiscallback_;

import "../../os/IBinder.dart" as ibinder_;

import "../../content/Intent.dart" as intent_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.speech.tts.TextToSpeechService
///
/// Abstract base class for TTS engine implementations. The following methods
/// need to be implemented:
/// <ul>
/// <li>\#onIsLanguageAvailable</li>
/// <li>\#onLoadLanguage</li>
/// <li>\#onGetLanguage</li>
/// <li>\#onSynthesizeText</li>
/// <li>\#onStop</li>
/// </ul>
/// The first three deal primarily with language management, and are used to
/// query the engine for it's support for a given language and indicate to it
/// that requests in a given language are imminent.
///
/// \#onSynthesizeText is central to the engine implementation. The
/// implementation should synthesize text as per the request parameters and
/// return synthesized data via the supplied callback. This class and its helpers
/// will then consume that data, which might mean queuing it for playback or writing
/// it to a file or similar. All calls to this method will be on a single thread,
/// which will be different from the main thread of the service. Synthesis must be
/// synchronous which means the engine must NOT hold on to the callback or call any
/// methods on it after the method returns.
///
/// \#onStop tells the engine that it should stop
/// all ongoing synthesis, if any. Any pending data from the current synthesis
/// will be discarded.
///
/// \#onGetLanguage is not required as of JELLYBEAN_MR2 (API 18) and later, it is only
/// called on earlier versions of Android.
///
/// API Level 20 adds support for Voice objects. Voices are an abstraction that allow the TTS
/// service to expose multiple backends for a single locale. Each one of them can have a different
/// features set. In order to fully take advantage of voices, an engine should implement
/// the following methods:
/// <ul>
/// <li>\#onGetVoices()</li>
/// <li>\#onIsValidVoiceName(String)</li>
/// <li>\#onLoadVoice(String)</li>
/// <li>\#onGetDefaultVoiceNameFor(String, String, String)</li>
/// </ul>
/// The first three methods are siblings of the \#onGetLanguage,
/// \#onIsLanguageAvailable and \#onLoadLanguage methods. The last one,
/// \#onGetDefaultVoiceNameFor(String, String, String) is a link between locale and voice
/// based methods. Since API level 21 TextToSpeech\#setLanguage is implemented by
/// calling TextToSpeech\#setVoice with the voice returned by
/// \#onGetDefaultVoiceNameFor(String, String, String).
///
/// If the client uses a voice instead of a locale, SynthesisRequest will contain the
/// requested voice name.
///
/// The default implementations of Voice-related methods implement them using the
/// pre-existing locale-based implementation.
class TextToSpeechService extends service_.Service {
  static final _classRef =
      jniAccessors.getClassOf("android/speech/tts/TextToSpeechService");
  TextToSpeechService.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  TextToSpeechService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_onCreate =
      jniAccessors.getMethodIDOf(_classRef, "onCreate", "()V");

  /// from: public void onCreate()
  void onCreate() => jniAccessors.callMethodWithArgs(
      reference, _id_onCreate, jni.JniType.voidType, []).check();

  static final _id_onDestroy =
      jniAccessors.getMethodIDOf(_classRef, "onDestroy", "()V");

  /// from: public void onDestroy()
  void onDestroy() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroy, jni.JniType.voidType, []).check();

  static final _id_onIsLanguageAvailable = jniAccessors.getMethodIDOf(
      _classRef,
      "onIsLanguageAvailable",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I");

  /// from: protected abstract int onIsLanguageAvailable(java.lang.String lang, java.lang.String country, java.lang.String variant)
  ///
  /// Checks whether the engine supports a given language.
  ///
  /// Can be called on multiple threads.
  ///
  /// Its return values HAVE to be consistent with onLoadLanguage.
  ///@param lang ISO-3 language code.
  ///@param country ISO-3 country code. May be empty or null.
  ///@param variant Language variant. May be empty or null.
  ///@return Code indicating the support status for the locale.
  ///         One of TextToSpeech\#LANG_AVAILABLE,
  ///         TextToSpeech\#LANG_COUNTRY_AVAILABLE,
  ///         TextToSpeech\#LANG_COUNTRY_VAR_AVAILABLE,
  ///         TextToSpeech\#LANG_MISSING_DATA
  ///         TextToSpeech\#LANG_NOT_SUPPORTED.
  int onIsLanguageAvailable(
          jni.JniString lang, jni.JniString country, jni.JniString variant) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onIsLanguageAvailable,
          jni.JniType.intType,
          [lang.reference, country.reference, variant.reference]).integer;

  static final _id_onGetLanguage = jniAccessors.getMethodIDOf(
      _classRef, "onGetLanguage", "()[Ljava/lang/String;");

  /// from: protected abstract java.lang.String[] onGetLanguage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the language, country and variant currently being used by the TTS engine.
  ///
  /// This method will be called only on Android 4.2 and before (API <= 17). In later versions
  /// this method is not called by the Android TTS framework.
  ///
  /// Can be called on multiple threads.
  ///@return A 3-element array, containing language (ISO 3-letter code),
  ///         country (ISO 3-letter code) and variant used by the engine.
  ///         The country and variant may be {@code ""}. If country is empty, then variant must
  ///         be empty too.
  ///@see Locale\#getISO3Language()
  ///@see Locale\#getISO3Country()
  ///@see Locale\#getVariant()
  jni.JniObject onGetLanguage() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onGetLanguage, jni.JniType.objectType, []).object);

  static final _id_onLoadLanguage = jniAccessors.getMethodIDOf(
      _classRef,
      "onLoadLanguage",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I");

  /// from: protected abstract int onLoadLanguage(java.lang.String lang, java.lang.String country, java.lang.String variant)
  ///
  /// Notifies the engine that it should load a speech synthesis language. There is no guarantee
  /// that this method is always called before the language is used for synthesis. It is merely
  /// a hint to the engine that it will probably get some synthesis requests for this language
  /// at some point in the future.
  ///
  /// Can be called on multiple threads.
  /// In <= Android 4.2 (<= API 17) can be called on main and service binder threads.
  /// In > Android 4.2 (> API 17) can be called on main and synthesis threads.
  ///@param lang ISO-3 language code.
  ///@param country ISO-3 country code. May be empty or null.
  ///@param variant Language variant. May be empty or null.
  ///@return Code indicating the support status for the locale.
  ///         One of TextToSpeech\#LANG_AVAILABLE,
  ///         TextToSpeech\#LANG_COUNTRY_AVAILABLE,
  ///         TextToSpeech\#LANG_COUNTRY_VAR_AVAILABLE,
  ///         TextToSpeech\#LANG_MISSING_DATA
  ///         TextToSpeech\#LANG_NOT_SUPPORTED.
  int onLoadLanguage(
          jni.JniString lang, jni.JniString country, jni.JniString variant) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onLoadLanguage,
          jni.JniType.intType,
          [lang.reference, country.reference, variant.reference]).integer;

  static final _id_onStop =
      jniAccessors.getMethodIDOf(_classRef, "onStop", "()V");

  /// from: protected abstract void onStop()
  ///
  /// Notifies the service that it should stop any in-progress speech synthesis.
  /// This method can be called even if no speech synthesis is currently in progress.
  ///
  /// Can be called on multiple threads, but not on the synthesis thread.
  void onStop() => jniAccessors.callMethodWithArgs(
      reference, _id_onStop, jni.JniType.voidType, []).check();

  static final _id_onSynthesizeText = jniAccessors.getMethodIDOf(
      _classRef,
      "onSynthesizeText",
      "(Landroid/speech/tts/SynthesisRequest;Landroid/speech/tts/SynthesisCallback;)V");

  /// from: protected abstract void onSynthesizeText(android.speech.tts.SynthesisRequest request, android.speech.tts.SynthesisCallback callback)
  ///
  /// Tells the service to synthesize speech from the given text. This method should block until
  /// the synthesis is finished. Called on the synthesis thread.
  ///@param request The synthesis request.
  ///@param callback The callback that the engine must use to make data available for playback or
  ///     for writing to a file.
  void onSynthesizeText(synthesisrequest_.SynthesisRequest request,
          synthesiscallback_.SynthesisCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onSynthesizeText,
          jni.JniType.voidType,
          [request.reference, callback.reference]).check();

  static final _id_onGetFeaturesForLanguage = jniAccessors.getMethodIDOf(
      _classRef,
      "onGetFeaturesForLanguage",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/util/Set;");

  /// from: protected java.util.Set<java.lang.String> onGetFeaturesForLanguage(java.lang.String lang, java.lang.String country, java.lang.String variant)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Queries the service for a set of features supported for a given language.
  ///
  /// Can be called on multiple threads.
  ///@param lang ISO-3 language code.
  ///@param country ISO-3 country code. May be empty or null.
  ///@param variant Language variant. May be empty or null.
  ///@return A list of features supported for the given language.
  jni.JniObject onGetFeaturesForLanguage(
          jni.JniString lang, jni.JniString country, jni.JniString variant) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onGetFeaturesForLanguage,
          jni.JniType.objectType,
          [lang.reference, country.reference, variant.reference]).object);

  static final _id_onGetVoices = jniAccessors.getMethodIDOf(
      _classRef, "onGetVoices", "()Ljava/util/List;");

  /// from: public java.util.List<android.speech.tts.Voice> onGetVoices()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Queries the service for a set of supported voices.
  ///
  /// Can be called on multiple threads.
  ///
  /// The default implementation tries to enumerate all available locales, pass them to
  /// \#onIsLanguageAvailable(String, String, String) and create Voice instances (using
  /// the locale's BCP-47 language tag as the voice name) for the ones that are supported.
  /// Note, that this implementation is suitable only for engines that don't have multiple voices
  /// for a single locale. Also, this implementation won't work with Locales not listed in the
  /// set returned by the Locale\#getAvailableLocales() method.
  ///@return A list of voices supported.
  jni.JniObject onGetVoices() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onGetVoices, jni.JniType.objectType, []).object);

  static final _id_onGetDefaultVoiceNameFor = jniAccessors.getMethodIDOf(
      _classRef,
      "onGetDefaultVoiceNameFor",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String onGetDefaultVoiceNameFor(java.lang.String lang, java.lang.String country, java.lang.String variant)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a name of the default voice for a given locale.
  ///
  /// This method provides a mapping between locales and available voices. This method is
  /// used in TextToSpeech\#setLanguage, which calls this method and then calls
  /// TextToSpeech\#setVoice with the voice returned by this method.
  ///
  /// Also, it's used by TextToSpeech\#getDefaultVoice() to find a default voice for
  /// the default locale.
  ///@param lang ISO-3 language code.
  ///@param country ISO-3 country code. May be empty or null.
  ///@param variant Language variant. May be empty or null.
  ///@return A name of the default voice for a given locale.
  jni.JniString onGetDefaultVoiceNameFor(
          jni.JniString lang, jni.JniString country, jni.JniString variant) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onGetDefaultVoiceNameFor,
          jni.JniType.objectType,
          [lang.reference, country.reference, variant.reference]).object);

  static final _id_onLoadVoice = jniAccessors.getMethodIDOf(
      _classRef, "onLoadVoice", "(Ljava/lang/String;)I");

  /// from: public int onLoadVoice(java.lang.String voiceName)
  ///
  /// Notifies the engine that it should load a speech synthesis voice. There is no guarantee
  /// that this method is always called before the voice is used for synthesis. It is merely
  /// a hint to the engine that it will probably get some synthesis requests for this voice
  /// at some point in the future.
  ///
  /// Will be called only on synthesis thread.
  ///
  /// The default implementation creates a Locale from the voice name (by interpreting the name as
  /// a BCP-47 tag for the locale), and passes it to
  /// \#onLoadLanguage(String, String, String).
  ///@param voiceName Name of the voice.
  ///@return TextToSpeech\#ERROR or TextToSpeech\#SUCCESS.
  int onLoadVoice(jni.JniString voiceName) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onLoadVoice,
      jni.JniType.intType,
      [voiceName.reference]).integer;

  static final _id_onIsValidVoiceName = jniAccessors.getMethodIDOf(
      _classRef, "onIsValidVoiceName", "(Ljava/lang/String;)I");

  /// from: public int onIsValidVoiceName(java.lang.String voiceName)
  ///
  /// Checks whether the engine supports a voice with a given name.
  ///
  /// Can be called on multiple threads.
  ///
  /// The default implementation treats the voice name as a language tag, creating a Locale from
  /// the voice name, and passes it to \#onIsLanguageAvailable(String, String, String).
  ///@param voiceName Name of the voice.
  ///@return TextToSpeech\#ERROR or TextToSpeech\#SUCCESS.
  int onIsValidVoiceName(jni.JniString voiceName) =>
      jniAccessors.callMethodWithArgs(reference, _id_onIsValidVoiceName,
          jni.JniType.intType, [voiceName.reference]).integer;

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);
}
