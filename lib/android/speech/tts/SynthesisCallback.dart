// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.speech.tts.SynthesisCallback
///
/// A callback to return speech data synthesized by a text to speech engine.
///
/// The engine can provide streaming audio by calling
/// \#start, then \#audioAvailable until all audio has been provided, then finally
/// \#done.
///
/// \#error can be called at any stage in the synthesis process to
/// indicate that an error has occurred, but if the call is made after a call
/// to \#done, it might be discarded.
///
/// \#done must be called at the end of synthesis, regardless of errors.
///
/// All methods can be only called on the synthesis thread.
class SynthesisCallback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/speech/tts/SynthesisCallback");
  SynthesisCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getMaxBufferSize =
      jniAccessors.getMethodIDOf(_classRef, "getMaxBufferSize", "()I");

  /// from: public abstract int getMaxBufferSize()
  ///
  /// @return the maximum number of bytes that the TTS engine can pass in a single call of \#audioAvailable. Calls to \#audioAvailable with data lengths larger than this
  ///     value will not succeed.
  int getMaxBufferSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxBufferSize, jni.JniType.intType, []).integer;

  static final _id_start =
      jniAccessors.getMethodIDOf(_classRef, "start", "(III)I");

  /// from: public abstract int start(int sampleRateInHz, int audioFormat, int channelCount)
  ///
  /// The service should call this when it starts to synthesize audio for this request.
  ///
  /// This method should only be called on the synthesis thread, while in TextToSpeechService\#onSynthesizeText.
  ///@param sampleRateInHz Sample rate in HZ of the generated audio.
  ///@param audioFormat Audio format of the generated audio. Must be one of AudioFormat\#ENCODING_PCM_8BIT or AudioFormat\#ENCODING_PCM_16BIT. Can also be
  ///     AudioFormat\#ENCODING_PCM_FLOAT when targetting Android N and above.
  /// Value is android.media.AudioFormat\#ENCODING_PCM_8BIT, android.media.AudioFormat\#ENCODING_PCM_16BIT, or android.media.AudioFormat\#ENCODING_PCM_FLOAT
  ///@param channelCount The number of channels. Must be {@code 1} or {@code 2}.
  /// Value is between 1 and 2 inclusive
  ///@return android.speech.tts.TextToSpeech\#SUCCESS, android.speech.tts.TextToSpeech\#ERROR or android.speech.tts.TextToSpeech\#STOPPED.
  int start(int sampleRateInHz, int audioFormat, int channelCount) =>
      jniAccessors.callMethodWithArgs(reference, _id_start, jni.JniType.intType,
          [sampleRateInHz, audioFormat, channelCount]).integer;

  static final _id_audioAvailable =
      jniAccessors.getMethodIDOf(_classRef, "audioAvailable", "([BII)I");

  /// from: public abstract int audioAvailable(byte[] buffer, int offset, int length)
  ///
  /// The service should call this method when synthesized audio is ready for consumption.
  ///
  /// This method should only be called on the synthesis thread, while in TextToSpeechService\#onSynthesizeText.
  ///@param buffer The generated audio data. This method will not hold on to {@code buffer}, so the
  ///     caller is free to modify it after this method returns.
  ///@param offset The offset into {@code buffer} where the audio data starts.
  ///@param length The number of bytes of audio data in {@code buffer}. This must be less than or
  ///     equal to the return value of \#getMaxBufferSize.
  ///@return android.speech.tts.TextToSpeech\#SUCCESS, android.speech.tts.TextToSpeech\#ERROR or android.speech.tts.TextToSpeech\#STOPPED.
  int audioAvailable(jni.JniObject buffer, int offset, int length) =>
      jniAccessors.callMethodWithArgs(reference, _id_audioAvailable,
          jni.JniType.intType, [buffer.reference, offset, length]).integer;

  static final _id_done = jniAccessors.getMethodIDOf(_classRef, "done", "()I");

  /// from: public abstract int done()
  ///
  /// The service should call this method when all the synthesized audio for a request has been
  /// passed to \#audioAvailable.
  ///
  /// This method should only be called on the synthesis thread, while in TextToSpeechService\#onSynthesizeText.
  ///
  /// This method has to be called if \#start and/or \#error was called.
  ///@return android.speech.tts.TextToSpeech\#SUCCESS, android.speech.tts.TextToSpeech\#ERROR or android.speech.tts.TextToSpeech\#STOPPED.
  int done() => jniAccessors
      .callMethodWithArgs(reference, _id_done, jni.JniType.intType, []).integer;

  static final _id_error =
      jniAccessors.getMethodIDOf(_classRef, "error", "()V");

  /// from: public abstract void error()
  ///
  /// The service should call this method if the speech synthesis fails.
  ///
  /// This method should only be called on the synthesis thread, while in TextToSpeechService\#onSynthesizeText.
  void error() => jniAccessors.callMethodWithArgs(
      reference, _id_error, jni.JniType.voidType, []).check();

  static final _id_error1 =
      jniAccessors.getMethodIDOf(_classRef, "error", "(I)V");

  /// from: public abstract void error(int errorCode)
  ///
  /// The service should call this method if the speech synthesis fails.
  ///
  /// This method should only be called on the synthesis thread, while in TextToSpeechService\#onSynthesizeText.
  ///@param errorCode Error code to pass to the client. One of the ERROR_ values from android.speech.tts.TextToSpeech
  ///
  /// Value is android.speech.tts.TextToSpeech\#ERROR_SYNTHESIS, android.speech.tts.TextToSpeech\#ERROR_SERVICE, android.speech.tts.TextToSpeech\#ERROR_OUTPUT, android.speech.tts.TextToSpeech\#ERROR_NETWORK, android.speech.tts.TextToSpeech\#ERROR_NETWORK_TIMEOUT, android.speech.tts.TextToSpeech\#ERROR_INVALID_REQUEST, or android.speech.tts.TextToSpeech\#ERROR_NOT_INSTALLED_YET
  void error1(int errorCode) => jniAccessors.callMethodWithArgs(
      reference, _id_error1, jni.JniType.voidType, [errorCode]).check();

  static final _id_hasStarted =
      jniAccessors.getMethodIDOf(_classRef, "hasStarted", "()Z");

  /// from: public abstract boolean hasStarted()
  ///
  /// Check if \#start was called or not.
  ///
  /// This method should only be called on the synthesis thread, while in TextToSpeechService\#onSynthesizeText.
  ///
  /// Useful for checking if a fallback from network request is possible.
  bool hasStarted() => jniAccessors.callMethodWithArgs(
      reference, _id_hasStarted, jni.JniType.booleanType, []).boolean;

  static final _id_hasFinished =
      jniAccessors.getMethodIDOf(_classRef, "hasFinished", "()Z");

  /// from: public abstract boolean hasFinished()
  ///
  /// Check if \#done was called or not.
  ///
  /// This method should only be called on the synthesis thread, while in TextToSpeechService\#onSynthesizeText.
  ///
  /// Useful for checking if a fallback from network request is possible.
  bool hasFinished() => jniAccessors.callMethodWithArgs(
      reference, _id_hasFinished, jni.JniType.booleanType, []).boolean;

  static final _id_rangeStart =
      jniAccessors.getMethodIDOf(_classRef, "rangeStart", "(III)V");

  /// from: default public void rangeStart(int markerInFrames, int start, int end)
  ///
  /// The service may call this method to provide timing information about the spoken text.
  ///
  /// Calling this method means that at the given audio frame, the given range of the input is
  /// about to be spoken. If this method is called the client will receive a callback on the
  /// listener (UtteranceProgressListener\#onRangeStart) at the moment that frame has been
  /// reached by the playback head.
  ///
  /// This information can be used by the client, for example, to highlight ranges of the text
  /// while it is spoken.
  ///
  /// The markerInFrames is a frame index into the audio for this synthesis request, i.e. into
  /// the concatenation of the audio bytes sent to audioAvailable for this synthesis request. The
  /// definition of a frame depends on the format given by \#start. See AudioFormat
  /// for more information.
  ///
  /// This method should only be called on the synthesis thread, while in TextToSpeechService\#onSynthesizeText.
  ///@param markerInFrames The position in frames in the audio where this range is spoken.
  ///@param start The start index of the range in the input text.
  ///@param end The end index (exclusive) of the range in the input text.
  void rangeStart(int markerInFrames, int start, int end) =>
      jniAccessors.callMethodWithArgs(reference, _id_rangeStart,
          jni.JniType.voidType, [markerInFrames, start, end]).check();
}
