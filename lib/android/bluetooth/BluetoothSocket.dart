// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "BluetoothDevice.dart" as bluetoothdevice_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.bluetooth.BluetoothSocket
///
/// A connected or connecting Bluetooth socket.
///
/// The interface for Bluetooth Sockets is similar to that of TCP sockets:
/// java.net.Socket and java.net.ServerSocket. On the server
/// side, use a BluetoothServerSocket to create a listening server
/// socket. When a connection is accepted by the BluetoothServerSocket,
/// it will return a new BluetoothSocket to manage the connection.
/// On the client side, use a single BluetoothSocket to both initiate
/// an outgoing connection and to manage the connection.
///
/// The most common type of Bluetooth socket is RFCOMM, which is the type
/// supported by the Android APIs. RFCOMM is a connection-oriented, streaming
/// transport over Bluetooth. It is also known as the Serial Port Profile (SPP).
///
/// To create a BluetoothSocket for connecting to a known device, use
/// BluetoothDevice\#createRfcommSocketToServiceRecord BluetoothDevice.createRfcommSocketToServiceRecord().
/// Then call \#connect() to attempt a connection to the remote device.
/// This call will block until a connection is established or the connection
/// fails.
///
/// To create a BluetoothSocket as a server (or "host"), see the
/// BluetoothServerSocket documentation.
///
/// Once the socket is connected, whether initiated as a client or accepted
/// as a server, open the IO streams by calling \#getInputStream and
/// \#getOutputStream in order to retrieve java.io.InputStream
/// and java.io.OutputStream objects, respectively, which are
/// automatically connected to the socket.
///
/// BluetoothSocket is thread
/// safe. In particular, \#close will always immediately abort ongoing
/// operations and close the socket.
///
/// <p class="note"><strong>Note:</strong>
/// Requires the android.Manifest.permission\#BLUETOOTH permission.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using Bluetooth, read the
/// <a href="{@docRoot}guide/topics/connectivity/bluetooth.html">Bluetooth</a> developer guide.
///
/// </div>
///
/// {@see BluetoothServerSocket}
/// {@see java.io.InputStream}
/// {@see java.io.OutputStream}
class BluetoothSocket extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/bluetooth/BluetoothSocket");
  BluetoothSocket.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int TYPE_L2CAP
  ///
  /// L2CAP socket
  static const TYPE_L2CAP = 3;

  /// from: static public final int TYPE_RFCOMM
  ///
  /// RFCOMM socket
  static const TYPE_RFCOMM = 1;

  /// from: static public final int TYPE_SCO
  ///
  /// SCO socket
  static const TYPE_SCO = 2;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/bluetooth/BluetoothSocket;)V");

  /// from: void <init>(android.bluetooth.BluetoothSocket s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  BluetoothSocket(BluetoothSocket s)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [s.reference]).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  ///
  /// @hide
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_getRemoteDevice = jniAccessors.getMethodIDOf(
      _classRef, "getRemoteDevice", "()Landroid/bluetooth/BluetoothDevice;");

  /// from: public android.bluetooth.BluetoothDevice getRemoteDevice()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the remote device this socket is connecting, or connected, to.
  ///@return remote device
  bluetoothdevice_.BluetoothDevice getRemoteDevice() =>
      bluetoothdevice_.BluetoothDevice.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getRemoteDevice, jni.JniType.objectType, []).object);

  static final _id_getInputStream = jniAccessors.getMethodIDOf(
      _classRef, "getInputStream", "()Ljava/io/InputStream;");

  /// from: public java.io.InputStream getInputStream()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the input stream associated with this socket.
  /// The input stream will be returned even if the socket is not yet
  /// connected, but operations on that stream will throw IOException until
  /// the associated socket is connected.
  ///@return InputStream
  jni.JniObject getInputStream() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getInputStream, jni.JniType.objectType, []).object);

  static final _id_getOutputStream = jniAccessors.getMethodIDOf(
      _classRef, "getOutputStream", "()Ljava/io/OutputStream;");

  /// from: public java.io.OutputStream getOutputStream()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the output stream associated with this socket.
  /// The output stream will be returned even if the socket is not yet
  /// connected, but operations on that stream will throw IOException until
  /// the associated socket is connected.
  ///@return OutputStream
  jni.JniObject getOutputStream() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getOutputStream, jni.JniType.objectType, []).object);

  static final _id_isConnected =
      jniAccessors.getMethodIDOf(_classRef, "isConnected", "()Z");

  /// from: public boolean isConnected()
  ///
  /// Get the connection status of this socket, ie, whether there is an active connection with
  /// remote device.
  ///@return true if connected false if not connected
  bool isConnected() => jniAccessors.callMethodWithArgs(
      reference, _id_isConnected, jni.JniType.booleanType, []).boolean;

  static final _id_connect =
      jniAccessors.getMethodIDOf(_classRef, "connect", "()V");

  /// from: public void connect()
  ///
  /// Attempt to connect to a remote device.
  /// This method will block until a connection is made or the connection
  /// fails. If this method returns without an exception then this socket
  /// is now connected.
  /// Creating new connections to
  /// remote Bluetooth devices should not be attempted while device discovery
  /// is in progress. Device discovery is a heavyweight procedure on the
  /// Bluetooth adapter and will significantly slow a device connection.
  /// Use BluetoothAdapter\#cancelDiscovery() to cancel an ongoing
  /// discovery. Discovery is not managed by the Activity,
  /// but is run as a system service, so an application should always call
  /// BluetoothAdapter\#cancelDiscovery() even if it
  /// did not directly request a discovery, just to be sure.
  /// \#close can be used to abort this call from another thread.
  ///@throws IOException on error, for example connection failure
  void connect() => jniAccessors.callMethodWithArgs(
      reference, _id_connect, jni.JniType.voidType, []).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_getMaxTransmitPacketSize =
      jniAccessors.getMethodIDOf(_classRef, "getMaxTransmitPacketSize", "()I");

  /// from: public int getMaxTransmitPacketSize()
  ///
  /// Get the maximum supported Transmit packet size for the underlying transport.
  /// Use this to optimize the writes done to the output socket, to avoid sending
  /// half full packets.
  ///@return the maximum supported Transmit packet size for the underlying transport.
  int getMaxTransmitPacketSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxTransmitPacketSize, jni.JniType.intType, []).integer;

  static final _id_getMaxReceivePacketSize =
      jniAccessors.getMethodIDOf(_classRef, "getMaxReceivePacketSize", "()I");

  /// from: public int getMaxReceivePacketSize()
  ///
  /// Get the maximum supported Receive packet size for the underlying transport.
  /// Use this to optimize the reads done on the input stream, as any call to read
  /// will return a maximum of this amount of bytes - or for some transports a
  /// multiple of this value.
  ///@return the maximum supported Receive packet size for the underlying transport.
  int getMaxReceivePacketSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxReceivePacketSize, jni.JniType.intType, []).integer;

  static final _id_getConnectionType =
      jniAccessors.getMethodIDOf(_classRef, "getConnectionType", "()I");

  /// from: public int getConnectionType()
  ///
  /// Get the type of the underlying connection.
  ///@return one of \#TYPE_RFCOMM, \#TYPE_SCO or \#TYPE_L2CAP
  int getConnectionType() => jniAccessors.callMethodWithArgs(
      reference, _id_getConnectionType, jni.JniType.intType, []).integer;
}
