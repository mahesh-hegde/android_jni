// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "BluetoothSocket.dart" as bluetoothsocket_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.bluetooth.BluetoothServerSocket
///
/// A listening Bluetooth socket.
///
/// The interface for Bluetooth Sockets is similar to that of TCP sockets:
/// java.net.Socket and java.net.ServerSocket. On the server
/// side, use a BluetoothServerSocket to create a listening server
/// socket. When a connection is accepted by the BluetoothServerSocket,
/// it will return a new BluetoothSocket to manage the connection.
/// On the client side, use a single BluetoothSocket to both initiate
/// an outgoing connection and to manage the connection.
///
/// The most common type of Bluetooth socket is RFCOMM, which is the type
/// supported by the Android APIs. RFCOMM is a connection-oriented, streaming
/// transport over Bluetooth. It is also known as the Serial Port Profile (SPP).
///
/// To create a listening BluetoothServerSocket that's ready for
/// incoming connections, use
/// BluetoothAdapter\#listenUsingRfcommWithServiceRecord BluetoothAdapter.listenUsingRfcommWithServiceRecord(). Then call
/// \#accept() to listen for incoming connection requests. This call
/// will block until a connection is established, at which point, it will return
/// a BluetoothSocket to manage the connection. Once the BluetoothSocket is acquired, it's a good idea to call \#close() on
/// the BluetoothServerSocket when it's no longer needed for accepting
/// connections. Closing the BluetoothServerSocket will _not_
/// close the returned BluetoothSocket.
///
/// BluetoothServerSocket is thread
/// safe. In particular, \#close will always immediately abort ongoing
/// operations and close the server socket.
///
/// <p class="note"><strong>Note:</strong>
/// Requires the android.Manifest.permission\#BLUETOOTH permission.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using Bluetooth, read the
/// <a href="{@docRoot}guide/topics/connectivity/bluetooth.html">Bluetooth</a> developer guide.
///
/// </div>
///
/// {@see BluetoothSocket}
class BluetoothServerSocket extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/bluetooth/BluetoothServerSocket");
  BluetoothServerSocket.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_accept = jniAccessors.getMethodIDOf(
      _classRef, "accept", "()Landroid/bluetooth/BluetoothSocket;");

  /// from: public android.bluetooth.BluetoothSocket accept()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Block until a connection is established.
  /// Returns a connected BluetoothSocket on successful connection.
  /// Once this call returns, it can be called again to accept subsequent
  /// incoming connections.
  /// \#close can be used to abort this call from another thread.
  ///@return a connected BluetoothSocket
  ///@throws IOException on error, for example this call was aborted, or timeout
  bluetoothsocket_.BluetoothSocket accept() =>
      bluetoothsocket_.BluetoothSocket.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_accept, jni.JniType.objectType, []).object);

  static final _id_accept1 = jniAccessors.getMethodIDOf(
      _classRef, "accept", "(I)Landroid/bluetooth/BluetoothSocket;");

  /// from: public android.bluetooth.BluetoothSocket accept(int timeout)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Block until a connection is established, with timeout.
  /// Returns a connected BluetoothSocket on successful connection.
  /// Once this call returns, it can be called again to accept subsequent
  /// incoming connections.
  /// \#close can be used to abort this call from another thread.
  ///@return a connected BluetoothSocket
  ///@throws IOException on error, for example this call was aborted, or timeout
  bluetoothsocket_.BluetoothSocket accept1(int timeout) =>
      bluetoothsocket_.BluetoothSocket.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_accept1, jni.JniType.objectType, [timeout]).object);

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Immediately close this socket, and release all associated resources.
  /// Causes blocked calls on this socket in other threads to immediately
  /// throw an IOException.
  /// Closing the BluetoothServerSocket will _not_
  /// close any BluetoothSocket received from \#accept().
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
