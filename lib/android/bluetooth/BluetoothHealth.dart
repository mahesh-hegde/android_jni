// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "BluetoothProfile.dart" as bluetoothprofile_;

import "BluetoothHealthCallback.dart" as bluetoothhealthcallback_;

import "BluetoothHealthAppConfiguration.dart"
    as bluetoothhealthappconfiguration_;

import "BluetoothDevice.dart" as bluetoothdevice_;

import "../os/ParcelFileDescriptor.dart" as parcelfiledescriptor_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.bluetooth.BluetoothHealth
///
/// Public API for Bluetooth Health Profile.
///
/// BluetoothHealth is a proxy object for controlling the Bluetooth
/// Service via IPC.
///
///  How to connect to a health device which is acting in the source role.
/// <li> Use BluetoothAdapter\#getProfileProxy to get
/// the BluetoothHealth proxy object. </li>
/// <li> Create an BluetoothHealth callback and call
/// \#registerSinkAppConfiguration to register an application
/// configuration </li>
/// <li> Pair with the remote device. This currently needs to be done manually
/// from Bluetooth Settings </li>
/// <li> Connect to a health device using \#connectChannelToSource. Some
/// devices will connect the channel automatically. The BluetoothHealth
/// callback will inform the application of channel state change. </li>
/// <li> Use the file descriptor provided with a connected channel to read and
/// write data to the health channel. </li>
/// <li> The received data needs to be interpreted using a health manager which
/// implements the IEEE 11073-xxxxx specifications.
/// <li> When done, close the health channel by calling \#disconnectChannel
/// and unregister the application configuration calling
/// \#unregisterAppConfiguration
class BluetoothHealth extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/bluetooth/BluetoothHealth");
  BluetoothHealth.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int APP_CONFIG_REGISTRATION_FAILURE
  ///
  /// Health App Configuration registration failure
  static const APP_CONFIG_REGISTRATION_FAILURE = 1;

  /// from: static public final int APP_CONFIG_REGISTRATION_SUCCESS
  ///
  /// Health App Configuration registration success
  static const APP_CONFIG_REGISTRATION_SUCCESS = 0;

  /// from: static public final int APP_CONFIG_UNREGISTRATION_FAILURE
  ///
  /// Health App Configuration un-registration failure
  static const APP_CONFIG_UNREGISTRATION_FAILURE = 3;

  /// from: static public final int APP_CONFIG_UNREGISTRATION_SUCCESS
  ///
  /// Health App Configuration un-registration success
  static const APP_CONFIG_UNREGISTRATION_SUCCESS = 2;

  /// from: static public final int CHANNEL_TYPE_RELIABLE
  ///
  /// Health Profile - Channel Type used - Reliable
  static const CHANNEL_TYPE_RELIABLE = 10;

  /// from: static public final int CHANNEL_TYPE_STREAMING
  ///
  /// Health Profile - Channel Type used - Streaming
  static const CHANNEL_TYPE_STREAMING = 11;

  /// from: static public final int SINK_ROLE
  ///
  /// Health Profile Sink Role the device talking to the health device.
  static const SINK_ROLE = 2;

  /// from: static public final int SOURCE_ROLE
  ///
  /// Health Profile Source Role - the health device.
  static const SOURCE_ROLE = 1;

  /// from: static public final int STATE_CHANNEL_CONNECTED
  ///
  /// Health Channel Connection State - Connected
  static const STATE_CHANNEL_CONNECTED = 2;

  /// from: static public final int STATE_CHANNEL_CONNECTING
  ///
  /// Health Channel Connection State - Connecting
  static const STATE_CHANNEL_CONNECTING = 1;

  /// from: static public final int STATE_CHANNEL_DISCONNECTED
  ///
  /// Health Channel Connection State - Disconnected
  static const STATE_CHANNEL_DISCONNECTED = 0;

  /// from: static public final int STATE_CHANNEL_DISCONNECTING
  ///
  /// Health Channel Connection State - Disconnecting
  static const STATE_CHANNEL_DISCONNECTING = 3;

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/bluetooth/BluetoothProfile\$ServiceListener;)V");

  /// from: void <init>(android.content.Context context, android.bluetooth.BluetoothProfile.ServiceListener l)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a BluetoothHealth proxy object.
  BluetoothHealth(context_.Context context,
      bluetoothprofile_.BluetoothProfile_ServiceListener l)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference, l.reference]).object);

  static final _id_registerSinkAppConfiguration = jniAccessors.getMethodIDOf(
      _classRef,
      "registerSinkAppConfiguration",
      "(Ljava/lang/String;ILandroid/bluetooth/BluetoothHealthCallback;)Z");

  /// from: public boolean registerSinkAppConfiguration(java.lang.String name, int dataType, android.bluetooth.BluetoothHealthCallback callback)
  ///
  /// Register an application configuration that acts as a Health SINK.
  /// This is the configuration that will be used to communicate with health devices
  /// which will act as the \#SOURCE_ROLE. This is an asynchronous call and so
  /// the callback is used to notify success or failure if the function returns true.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param name The friendly name associated with the application or configuration.
  ///@param dataType The dataType of the Source role of Health Profile to which the sink wants to
  /// connect to.
  ///@param callback A callback to indicate success or failure of the registration and all
  /// operations done on this application configuration.
  ///@return If true, callback will be called.
  bool registerSinkAppConfiguration(jni.JniString name, int dataType,
          bluetoothhealthcallback_.BluetoothHealthCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerSinkAppConfiguration,
          jni.JniType.booleanType,
          [name.reference, dataType, callback.reference]).boolean;

  static final _id_unregisterAppConfiguration = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterAppConfiguration",
      "(Landroid/bluetooth/BluetoothHealthAppConfiguration;)Z");

  /// from: public boolean unregisterAppConfiguration(android.bluetooth.BluetoothHealthAppConfiguration config)
  ///
  /// Unregister an application configuration that has been registered using
  /// \#registerSinkAppConfiguration
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param config The health app configuration
  ///@return Success or failure.
  bool unregisterAppConfiguration(
          bluetoothhealthappconfiguration_.BluetoothHealthAppConfiguration
              config) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterAppConfiguration,
          jni.JniType.booleanType, [config.reference]).boolean;

  static final _id_connectChannelToSource = jniAccessors.getMethodIDOf(
      _classRef,
      "connectChannelToSource",
      "(Landroid/bluetooth/BluetoothDevice;Landroid/bluetooth/BluetoothHealthAppConfiguration;)Z");

  /// from: public boolean connectChannelToSource(android.bluetooth.BluetoothDevice device, android.bluetooth.BluetoothHealthAppConfiguration config)
  ///
  /// Connect to a health device which has the \#SOURCE_ROLE.
  /// This is an asynchronous call. If this function returns true, the callback
  /// associated with the application configuration will be called.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param device The remote Bluetooth device.
  ///@param config The application configuration which has been registered using \#registerSinkAppConfiguration(String, int, BluetoothHealthCallback)
  ///@return If true, the callback associated with the application config will be called.
  bool connectChannelToSource(
          bluetoothdevice_.BluetoothDevice device,
          bluetoothhealthappconfiguration_.BluetoothHealthAppConfiguration
              config) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_connectChannelToSource,
          jni.JniType.booleanType,
          [device.reference, config.reference]).boolean;

  static final _id_disconnectChannel = jniAccessors.getMethodIDOf(
      _classRef,
      "disconnectChannel",
      "(Landroid/bluetooth/BluetoothDevice;Landroid/bluetooth/BluetoothHealthAppConfiguration;I)Z");

  /// from: public boolean disconnectChannel(android.bluetooth.BluetoothDevice device, android.bluetooth.BluetoothHealthAppConfiguration config, int channelId)
  ///
  /// Disconnect a connected health channel.
  /// This is an asynchronous call. If this function returns true, the callback
  /// associated with the application configuration will be called.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param device The remote Bluetooth device.
  ///@param config The application configuration which has been registered using \#registerSinkAppConfiguration(String, int, BluetoothHealthCallback)
  ///@param channelId The channel id associated with the channel
  ///@return If true, the callback associated with the application config will be called.
  bool disconnectChannel(
          bluetoothdevice_.BluetoothDevice device,
          bluetoothhealthappconfiguration_.BluetoothHealthAppConfiguration
              config,
          int channelId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_disconnectChannel,
          jni.JniType.booleanType,
          [device.reference, config.reference, channelId]).boolean;

  static final _id_getMainChannelFd = jniAccessors.getMethodIDOf(
      _classRef,
      "getMainChannelFd",
      "(Landroid/bluetooth/BluetoothDevice;Landroid/bluetooth/BluetoothHealthAppConfiguration;)Landroid/os/ParcelFileDescriptor;");

  /// from: public android.os.ParcelFileDescriptor getMainChannelFd(android.bluetooth.BluetoothDevice device, android.bluetooth.BluetoothHealthAppConfiguration config)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the file descriptor of the main channel associated with the remote device
  /// and application configuration.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///
  ///  Its the responsibility of the caller to close the ParcelFileDescriptor
  /// when done.
  ///@param device The remote Bluetooth health device
  ///@param config The application configuration
  ///@return null on failure, ParcelFileDescriptor on success.
  parcelfiledescriptor_.ParcelFileDescriptor getMainChannelFd(
          bluetoothdevice_.BluetoothDevice device,
          bluetoothhealthappconfiguration_.BluetoothHealthAppConfiguration
              config) =>
      parcelfiledescriptor_.ParcelFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(
              reference,
              _id_getMainChannelFd,
              jni.JniType.objectType,
              [device.reference, config.reference]).object);

  static final _id_getConnectionState = jniAccessors.getMethodIDOf(_classRef,
      "getConnectionState", "(Landroid/bluetooth/BluetoothDevice;)I");

  /// from: public int getConnectionState(android.bluetooth.BluetoothDevice device)
  ///
  /// Get the current connection state of the profile.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///
  /// This is not specific to any application configuration but represents the connection
  /// state of the local Bluetooth adapter with the remote device. This can be used
  /// by applications like status bar which would just like to know the state of the
  /// local adapter.
  ///@param device Remote bluetooth device.
  ///@return State of the profile connection. One of \#STATE_CONNECTED, \#STATE_CONNECTING, \#STATE_DISCONNECTED, \#STATE_DISCONNECTING
  int getConnectionState(bluetoothdevice_.BluetoothDevice device) =>
      jniAccessors.callMethodWithArgs(reference, _id_getConnectionState,
          jni.JniType.intType, [device.reference]).integer;

  static final _id_getConnectedDevices = jniAccessors.getMethodIDOf(
      _classRef, "getConnectedDevices", "()Ljava/util/List;");

  /// from: public java.util.List<android.bluetooth.BluetoothDevice> getConnectedDevices()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get connected devices for the health profile.
  ///
  ///  Return the set of devices which are in state \#STATE_CONNECTED
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///
  /// This is not specific to any application configuration but represents the connection
  /// state of the local Bluetooth adapter for this profile. This can be used
  /// by applications like status bar which would just like to know the state of the
  /// local adapter.
  ///@return List of devices. The list will be empty on error.
  jni.JniObject getConnectedDevices() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getConnectedDevices, jni.JniType.objectType, []).object);

  static final _id_getDevicesMatchingConnectionStates =
      jniAccessors.getMethodIDOf(_classRef,
          "getDevicesMatchingConnectionStates", "([I)Ljava/util/List;");

  /// from: public java.util.List<android.bluetooth.BluetoothDevice> getDevicesMatchingConnectionStates(int[] states)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a list of devices that match any of the given connection
  /// states.
  ///
  ///  If none of the devices match any of the given states,
  /// an empty list will be returned.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  /// This is not specific to any application configuration but represents the connection
  /// state of the local Bluetooth adapter for this profile. This can be used
  /// by applications like status bar which would just like to know the state of the
  /// local adapter.
  ///@param states Array of states. States can be one of \#STATE_CONNECTED, \#STATE_CONNECTING, \#STATE_DISCONNECTED, \#STATE_DISCONNECTING,
  ///@return List of devices. The list will be empty on error.
  jni.JniObject getDevicesMatchingConnectionStates(jni.JniObject states) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDevicesMatchingConnectionStates,
          jni.JniType.objectType,
          [states.reference]).object);
}
