// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "BluetoothDevice.dart" as bluetoothdevice_;

import "le/BluetoothLeAdvertiser.dart" as bluetoothleadvertiser_;

import "le/BluetoothLeScanner.dart" as bluetoothlescanner_;

import "BluetoothServerSocket.dart" as bluetoothserversocket_;

import "../content/Context.dart" as context_;

import "BluetoothProfile.dart" as bluetoothprofile_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.bluetooth.BluetoothAdapter
///
/// Represents the local device Bluetooth adapter. The BluetoothAdapter
/// lets you perform fundamental Bluetooth tasks, such as initiate
/// device discovery, query a list of bonded (paired) devices,
/// instantiate a BluetoothDevice using a known MAC address, and create
/// a BluetoothServerSocket to listen for connection requests from other
/// devices, and start a scan for Bluetooth LE devices.
///
/// To get a BluetoothAdapter representing the local Bluetooth
/// adapter, call the BluetoothManager\#getAdapter function on BluetoothManager.
/// On JELLY_BEAN_MR1 and below you will need to use the static \#getDefaultAdapter
/// method instead.
///
///
/// Fundamentally, this is your starting point for all
/// Bluetooth actions. Once you have the local adapter, you can get a set of
/// BluetoothDevice objects representing all paired devices with
/// \#getBondedDevices(); start device discovery with
/// \#startDiscovery(); or create a BluetoothServerSocket to
/// listen for incoming RFComm connection requests with \#listenUsingRfcommWithServiceRecord(String, UUID); or start a scan for
/// Bluetooth LE devices with \#startLeScan(LeScanCallback callback).
///
///
/// This class is thread safe.
///
/// <p class="note"><strong>Note:</strong>
/// Most methods require the android.Manifest.permission\#BLUETOOTH
/// permission and some also require the
/// android.Manifest.permission\#BLUETOOTH_ADMIN permission.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
///
/// For more information about using Bluetooth, read the <a href="{@docRoot}guide/topics/connectivity/bluetooth.html">Bluetooth</a> developer
/// guide.
///
///
/// </div>
///
/// {@see BluetoothDevice}
/// {@see BluetoothServerSocket}
class BluetoothAdapter extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/bluetooth/BluetoothAdapter");
  BluetoothAdapter.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_CONNECTION_STATE_CHANGED
  ///
  /// Intent used to broadcast the change in connection state of the local
  /// Bluetooth adapter to a profile of the remote device. When the adapter is
  /// not connected to any profiles of any remote devices and it attempts a
  /// connection to a profile this intent will be sent. Once connected, this intent
  /// will not be sent for any more connection attempts to any profiles of any
  /// remote device. When the adapter disconnects from the last profile its
  /// connected to of any remote device, this intent will be sent.
  ///
  ///  This intent is useful for applications that are only concerned about
  /// whether the local adapter is connected to any profile of any device and
  /// are not really concerned about which profile. For example, an application
  /// which displays an icon to display whether Bluetooth is connected or not
  /// can use this intent.
  ///
  /// This intent will have 3 extras:
  /// \#EXTRA_CONNECTION_STATE - The current connection state.
  /// \#EXTRA_PREVIOUS_CONNECTION_STATE- The previous connection state.
  /// BluetoothDevice\#EXTRA_DEVICE - The remote device.
  ///
  /// \#EXTRA_CONNECTION_STATE or \#EXTRA_PREVIOUS_CONNECTION_STATE
  /// can be any of \#STATE_DISCONNECTED, \#STATE_CONNECTING,
  /// \#STATE_CONNECTED, \#STATE_DISCONNECTING.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH to receive.
  static const ACTION_CONNECTION_STATE_CHANGED =
      "android.bluetooth.adapter.action.CONNECTION_STATE_CHANGED";

  /// from: static public final java.lang.String ACTION_DISCOVERY_FINISHED
  ///
  /// Broadcast Action: The local Bluetooth adapter has finished the device
  /// discovery process.
  /// Requires android.Manifest.permission\#BLUETOOTH to receive.
  static const ACTION_DISCOVERY_FINISHED =
      "android.bluetooth.adapter.action.DISCOVERY_FINISHED";

  /// from: static public final java.lang.String ACTION_DISCOVERY_STARTED
  ///
  /// Broadcast Action: The local Bluetooth adapter has started the remote
  /// device discovery process.
  /// This usually involves an inquiry scan of about 12 seconds, followed
  /// by a page scan of each new device to retrieve its Bluetooth name.
  /// Register for BluetoothDevice\#ACTION_FOUND to be notified as
  /// remote Bluetooth devices are found.
  /// Device discovery is a heavyweight procedure. New connections to
  /// remote Bluetooth devices should not be attempted while discovery is in
  /// progress, and existing connections will experience limited bandwidth
  /// and high latency. Use \#cancelDiscovery() to cancel an ongoing
  /// discovery.
  /// Requires android.Manifest.permission\#BLUETOOTH to receive.
  static const ACTION_DISCOVERY_STARTED =
      "android.bluetooth.adapter.action.DISCOVERY_STARTED";

  /// from: static public final java.lang.String ACTION_LOCAL_NAME_CHANGED
  ///
  /// Broadcast Action: The local Bluetooth adapter has changed its friendly
  /// Bluetooth name.
  /// This name is visible to remote Bluetooth devices.
  /// Always contains the extra field \#EXTRA_LOCAL_NAME containing
  /// the name.
  /// Requires android.Manifest.permission\#BLUETOOTH to receive.
  static const ACTION_LOCAL_NAME_CHANGED =
      "android.bluetooth.adapter.action.LOCAL_NAME_CHANGED";

  /// from: static public final java.lang.String ACTION_REQUEST_DISCOVERABLE
  ///
  /// Activity Action: Show a system activity that requests discoverable mode.
  /// This activity will also request the user to turn on Bluetooth if it
  /// is not currently enabled.
  /// Discoverable mode is equivalent to \#SCAN_MODE_CONNECTABLE_DISCOVERABLE. It allows remote devices to see
  /// this Bluetooth adapter when they perform a discovery.
  /// For privacy, Android is not discoverable by default.
  /// The sender of this Intent can optionally use extra field \#EXTRA_DISCOVERABLE_DURATION to request the duration of
  /// discoverability. Currently the default duration is 120 seconds, and
  /// maximum duration is capped at 300 seconds for each request.
  /// Notification of the result of this activity is posted using the
  /// android.app.Activity\#onActivityResult callback. The
  /// <code>resultCode</code>
  /// will be the duration (in seconds) of discoverability or
  /// android.app.Activity\#RESULT_CANCELED if the user rejected
  /// discoverability or an error has occurred.
  /// Applications can also listen for \#ACTION_SCAN_MODE_CHANGED
  /// for global notification whenever the scan mode changes. For example, an
  /// application can be notified when the device has ended discoverability.
  /// Requires android.Manifest.permission\#BLUETOOTH
  static const ACTION_REQUEST_DISCOVERABLE =
      "android.bluetooth.adapter.action.REQUEST_DISCOVERABLE";

  /// from: static public final java.lang.String ACTION_REQUEST_ENABLE
  ///
  /// Activity Action: Show a system activity that allows the user to turn on
  /// Bluetooth.
  /// This system activity will return once Bluetooth has completed turning
  /// on, or the user has decided not to turn Bluetooth on.
  /// Notification of the result of this activity is posted using the
  /// android.app.Activity\#onActivityResult callback. The
  /// <code>resultCode</code>
  /// will be android.app.Activity\#RESULT_OK if Bluetooth has been
  /// turned on or android.app.Activity\#RESULT_CANCELED if the user
  /// has rejected the request or an error has occurred.
  /// Applications can also listen for \#ACTION_STATE_CHANGED
  /// for global notification whenever Bluetooth is turned on or off.
  /// Requires android.Manifest.permission\#BLUETOOTH
  static const ACTION_REQUEST_ENABLE =
      "android.bluetooth.adapter.action.REQUEST_ENABLE";

  /// from: static public final java.lang.String ACTION_SCAN_MODE_CHANGED
  ///
  /// Broadcast Action: Indicates the Bluetooth scan mode of the local Adapter
  /// has changed.
  /// Always contains the extra fields \#EXTRA_SCAN_MODE and \#EXTRA_PREVIOUS_SCAN_MODE containing the new and old scan modes
  /// respectively.
  /// Requires android.Manifest.permission\#BLUETOOTH
  static const ACTION_SCAN_MODE_CHANGED =
      "android.bluetooth.adapter.action.SCAN_MODE_CHANGED";

  /// from: static public final java.lang.String ACTION_STATE_CHANGED
  ///
  /// Broadcast Action: The state of the local Bluetooth adapter has been
  /// changed.
  /// For example, Bluetooth has been turned on or off.
  /// Always contains the extra fields \#EXTRA_STATE and \#EXTRA_PREVIOUS_STATE containing the new and old states
  /// respectively.
  /// Requires android.Manifest.permission\#BLUETOOTH to receive.
  static const ACTION_STATE_CHANGED =
      "android.bluetooth.adapter.action.STATE_CHANGED";

  /// from: static public final int ERROR
  ///
  /// Sentinel error value for this class. Guaranteed to not equal any other
  /// integer constant in this class. Provided as a convenience for functions
  /// that require a sentinel error value, for example:
  /// <code>Intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,
  /// BluetoothAdapter.ERROR)</code>
  static const ERROR = -2147483648;

  /// from: static public final java.lang.String EXTRA_CONNECTION_STATE
  ///
  /// Extra used by \#ACTION_CONNECTION_STATE_CHANGED
  ///
  /// This extra represents the current connection state.
  static const EXTRA_CONNECTION_STATE =
      "android.bluetooth.adapter.extra.CONNECTION_STATE";

  /// from: static public final java.lang.String EXTRA_DISCOVERABLE_DURATION
  ///
  /// Used as an optional int extra field in \#ACTION_REQUEST_DISCOVERABLE intents to request a specific duration
  /// for discoverability in seconds. The current default is 120 seconds, and
  /// requests over 300 seconds will be capped. These values could change.
  static const EXTRA_DISCOVERABLE_DURATION =
      "android.bluetooth.adapter.extra.DISCOVERABLE_DURATION";

  /// from: static public final java.lang.String EXTRA_LOCAL_NAME
  ///
  /// Used as a String extra field in \#ACTION_LOCAL_NAME_CHANGED
  /// intents to request the local Bluetooth name.
  static const EXTRA_LOCAL_NAME = "android.bluetooth.adapter.extra.LOCAL_NAME";

  /// from: static public final java.lang.String EXTRA_PREVIOUS_CONNECTION_STATE
  ///
  /// Extra used by \#ACTION_CONNECTION_STATE_CHANGED
  ///
  /// This extra represents the previous connection state.
  static const EXTRA_PREVIOUS_CONNECTION_STATE =
      "android.bluetooth.adapter.extra.PREVIOUS_CONNECTION_STATE";

  /// from: static public final java.lang.String EXTRA_PREVIOUS_SCAN_MODE
  ///
  /// Used as an int extra field in \#ACTION_SCAN_MODE_CHANGED
  /// intents to request the previous scan mode. Possible values are:
  /// \#SCAN_MODE_NONE,
  /// \#SCAN_MODE_CONNECTABLE,
  /// \#SCAN_MODE_CONNECTABLE_DISCOVERABLE,
  static const EXTRA_PREVIOUS_SCAN_MODE =
      "android.bluetooth.adapter.extra.PREVIOUS_SCAN_MODE";

  /// from: static public final java.lang.String EXTRA_PREVIOUS_STATE
  ///
  /// Used as an int extra field in \#ACTION_STATE_CHANGED
  /// intents to request the previous power state. Possible values are:
  /// \#STATE_OFF,
  /// \#STATE_TURNING_ON,
  /// \#STATE_ON,
  /// \#STATE_TURNING_OFF
  static const EXTRA_PREVIOUS_STATE =
      "android.bluetooth.adapter.extra.PREVIOUS_STATE";

  /// from: static public final java.lang.String EXTRA_SCAN_MODE
  ///
  /// Used as an int extra field in \#ACTION_SCAN_MODE_CHANGED
  /// intents to request the current scan mode. Possible values are:
  /// \#SCAN_MODE_NONE,
  /// \#SCAN_MODE_CONNECTABLE,
  /// \#SCAN_MODE_CONNECTABLE_DISCOVERABLE,
  static const EXTRA_SCAN_MODE = "android.bluetooth.adapter.extra.SCAN_MODE";

  /// from: static public final java.lang.String EXTRA_STATE
  ///
  /// Used as an int extra field in \#ACTION_STATE_CHANGED
  /// intents to request the current power state. Possible values are:
  /// \#STATE_OFF,
  /// \#STATE_TURNING_ON,
  /// \#STATE_ON,
  /// \#STATE_TURNING_OFF,
  static const EXTRA_STATE = "android.bluetooth.adapter.extra.STATE";

  /// from: static public final int SCAN_MODE_CONNECTABLE
  ///
  /// Indicates that inquiry scan is disabled, but page scan is enabled on the
  /// local Bluetooth adapter. Therefore this device is not discoverable from
  /// remote Bluetooth devices, but is connectable from remote devices that
  /// have previously discovered this device.
  static const SCAN_MODE_CONNECTABLE = 21;

  /// from: static public final int SCAN_MODE_CONNECTABLE_DISCOVERABLE
  ///
  /// Indicates that both inquiry scan and page scan are enabled on the local
  /// Bluetooth adapter. Therefore this device is both discoverable and
  /// connectable from remote Bluetooth devices.
  static const SCAN_MODE_CONNECTABLE_DISCOVERABLE = 23;

  /// from: static public final int SCAN_MODE_NONE
  ///
  /// Indicates that both inquiry scan and page scan are disabled on the local
  /// Bluetooth adapter. Therefore this device is neither discoverable
  /// nor connectable from remote Bluetooth devices.
  static const SCAN_MODE_NONE = 20;

  /// from: static public final int STATE_CONNECTED
  ///
  /// The profile is in connected state
  static const STATE_CONNECTED = 2;

  /// from: static public final int STATE_CONNECTING
  ///
  /// The profile is in connecting state
  static const STATE_CONNECTING = 1;

  /// from: static public final int STATE_DISCONNECTED
  ///
  /// The profile is in disconnected state
  static const STATE_DISCONNECTED = 0;

  /// from: static public final int STATE_DISCONNECTING
  ///
  /// The profile is in disconnecting state
  static const STATE_DISCONNECTING = 3;

  /// from: static public final int STATE_OFF
  ///
  /// Indicates the local Bluetooth adapter is off.
  static const STATE_OFF = 10;

  /// from: static public final int STATE_ON
  ///
  /// Indicates the local Bluetooth adapter is on, and ready for use.
  static const STATE_ON = 12;

  /// from: static public final int STATE_TURNING_OFF
  ///
  /// Indicates the local Bluetooth adapter is turning off. Local clients
  /// should immediately attempt graceful disconnection of any remote links.
  static const STATE_TURNING_OFF = 13;

  /// from: static public final int STATE_TURNING_ON
  ///
  /// Indicates the local Bluetooth adapter is turning on. However local
  /// clients should wait for \#STATE_ON before attempting to
  /// use the adapter.
  static const STATE_TURNING_ON = 11;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  BluetoothAdapter()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getDefaultAdapter = jniAccessors.getStaticMethodIDOf(
      _classRef, "getDefaultAdapter", "()Landroid/bluetooth/BluetoothAdapter;");

  /// from: synchronized static public android.bluetooth.BluetoothAdapter getDefaultAdapter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a handle to the default local Bluetooth adapter.
  /// Currently Android only supports one Bluetooth adapter, but the API
  /// could be extended to support more. This will always return the default
  /// adapter.
  ///
  ///
  ///@return the default local adapter, or null if Bluetooth is not supported on this hardware
  /// platform
  static BluetoothAdapter getDefaultAdapter() =>
      BluetoothAdapter.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getDefaultAdapter, jni.JniType.objectType, []).object);

  static final _id_getRemoteDevice = jniAccessors.getMethodIDOf(
      _classRef,
      "getRemoteDevice",
      "(Ljava/lang/String;)Landroid/bluetooth/BluetoothDevice;");

  /// from: public android.bluetooth.BluetoothDevice getRemoteDevice(java.lang.String address)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a BluetoothDevice object for the given Bluetooth hardware
  /// address.
  /// Valid Bluetooth hardware addresses must be upper case, in a format
  /// such as "00:11:22:33:AA:BB". The helper \#checkBluetoothAddress is
  /// available to validate a Bluetooth address.
  /// A BluetoothDevice will always be returned for a valid
  /// hardware address, even if this adapter has never seen that device.
  ///@param address valid Bluetooth MAC address
  ///@throws IllegalArgumentException if address is invalid
  bluetoothdevice_.BluetoothDevice getRemoteDevice(jni.JniString address) =>
      bluetoothdevice_.BluetoothDevice.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getRemoteDevice,
          jni.JniType.objectType,
          [address.reference]).object);

  static final _id_getRemoteDevice1 = jniAccessors.getMethodIDOf(
      _classRef, "getRemoteDevice", "([B)Landroid/bluetooth/BluetoothDevice;");

  /// from: public android.bluetooth.BluetoothDevice getRemoteDevice(byte[] address)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a BluetoothDevice object for the given Bluetooth hardware
  /// address.
  /// Valid Bluetooth hardware addresses must be 6 bytes. This method
  /// expects the address in network byte order (MSB first).
  /// A BluetoothDevice will always be returned for a valid
  /// hardware address, even if this adapter has never seen that device.
  ///@param address Bluetooth MAC address (6 bytes)
  ///@throws IllegalArgumentException if address is invalid
  bluetoothdevice_.BluetoothDevice getRemoteDevice1(jni.JniObject address) =>
      bluetoothdevice_.BluetoothDevice.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getRemoteDevice1,
          jni.JniType.objectType,
          [address.reference]).object);

  static final _id_getBluetoothLeAdvertiser = jniAccessors.getMethodIDOf(
      _classRef,
      "getBluetoothLeAdvertiser",
      "()Landroid/bluetooth/le/BluetoothLeAdvertiser;");

  /// from: public android.bluetooth.le.BluetoothLeAdvertiser getBluetoothLeAdvertiser()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a BluetoothLeAdvertiser object for Bluetooth LE Advertising operations.
  /// Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not
  /// supported on this device.
  ///
  /// Use \#isMultipleAdvertisementSupported() to check whether LE Advertising is supported
  /// on this device before calling this method.
  bluetoothleadvertiser_.BluetoothLeAdvertiser getBluetoothLeAdvertiser() =>
      bluetoothleadvertiser_.BluetoothLeAdvertiser.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getBluetoothLeAdvertiser,
              jni.JniType.objectType, []).object);

  static final _id_getBluetoothLeScanner = jniAccessors.getMethodIDOf(_classRef,
      "getBluetoothLeScanner", "()Landroid/bluetooth/le/BluetoothLeScanner;");

  /// from: public android.bluetooth.le.BluetoothLeScanner getBluetoothLeScanner()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a BluetoothLeScanner object for Bluetooth LE scan operations.
  bluetoothlescanner_.BluetoothLeScanner getBluetoothLeScanner() =>
      bluetoothlescanner_.BluetoothLeScanner.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getBluetoothLeScanner,
              jni.JniType.objectType, []).object);

  static final _id_isEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isEnabled", "()Z");

  /// from: public boolean isEnabled()
  ///
  /// Return true if Bluetooth is currently enabled and ready for use.
  /// Equivalent to:
  /// <code>getBluetoothState() == STATE_ON</code>
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH
  ///@return true if the local adapter is turned on
  bool isEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_getState =
      jniAccessors.getMethodIDOf(_classRef, "getState", "()I");

  /// from: public int getState()
  ///
  /// Get the current state of the local Bluetooth adapter.
  /// Possible return values are
  /// \#STATE_OFF,
  /// \#STATE_TURNING_ON,
  /// \#STATE_ON,
  /// \#STATE_TURNING_OFF.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH
  ///@return current state of Bluetooth adapter
  ///
  /// Value is android.bluetooth.BluetoothAdapter\#STATE_OFF, android.bluetooth.BluetoothAdapter\#STATE_TURNING_ON, android.bluetooth.BluetoothAdapter\#STATE_ON, android.bluetooth.BluetoothAdapter\#STATE_TURNING_OFF, android.bluetooth.BluetoothAdapter.STATE_BLE_TURNING_ON, android.bluetooth.BluetoothAdapter.STATE_BLE_ON, or android.bluetooth.BluetoothAdapter.STATE_BLE_TURNING_OFF
  int getState() => jniAccessors.callMethodWithArgs(
      reference, _id_getState, jni.JniType.intType, []).integer;

  static final _id_enable =
      jniAccessors.getMethodIDOf(_classRef, "enable", "()Z");

  /// from: public boolean enable()
  ///
  /// Turn on the local Bluetooth adapter&mdash;do not use without explicit
  /// user action to turn on Bluetooth.
  /// This powers on the underlying Bluetooth hardware, and starts all
  /// Bluetooth system services.
  /// <p class="caution"><strong>Bluetooth should never be enabled without
  /// direct user consent</strong>. If you want to turn on Bluetooth in order
  /// to create a wireless connection, you should use the \#ACTION_REQUEST_ENABLE Intent, which will raise a dialog that requests
  /// user permission to turn on Bluetooth. The \#enable() method is
  /// provided only for applications that include a user interface for changing
  /// system settings, such as a "power manager" app.
  ///
  /// This is an asynchronous call: it will return immediately, and
  /// clients should listen for \#ACTION_STATE_CHANGED
  /// to be notified of subsequent adapter state changes. If this call returns
  /// true, then the adapter state will immediately transition from \#STATE_OFF to \#STATE_TURNING_ON, and some time
  /// later transition to either \#STATE_OFF or \#STATE_ON. If this call returns false then there was an
  /// immediate problem that will prevent the adapter from being turned on -
  /// such as Airplane mode, or the adapter is already turned on.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH_ADMIN
  ///@return true to indicate adapter startup has begun, or false on immediate error
  bool enable() => jniAccessors.callMethodWithArgs(
      reference, _id_enable, jni.JniType.booleanType, []).boolean;

  static final _id_disable =
      jniAccessors.getMethodIDOf(_classRef, "disable", "()Z");

  /// from: public boolean disable()
  ///
  /// Turn off the local Bluetooth adapter&mdash;do not use without explicit
  /// user action to turn off Bluetooth.
  /// This gracefully shuts down all Bluetooth connections, stops Bluetooth
  /// system services, and powers down the underlying Bluetooth hardware.
  /// <p class="caution"><strong>Bluetooth should never be disabled without
  /// direct user consent</strong>. The \#disable() method is
  /// provided only for applications that include a user interface for changing
  /// system settings, such as a "power manager" app.
  ///
  /// This is an asynchronous call: it will return immediately, and
  /// clients should listen for \#ACTION_STATE_CHANGED
  /// to be notified of subsequent adapter state changes. If this call returns
  /// true, then the adapter state will immediately transition from \#STATE_ON to \#STATE_TURNING_OFF, and some time
  /// later transition to either \#STATE_OFF or \#STATE_ON. If this call returns false then there was an
  /// immediate problem that will prevent the adapter from being turned off -
  /// such as the adapter already being turned off.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH_ADMIN
  ///@return true to indicate adapter shutdown has begun, or false on immediate error
  bool disable() => jniAccessors.callMethodWithArgs(
      reference, _id_disable, jni.JniType.booleanType, []).boolean;

  static final _id_getAddress = jniAccessors.getMethodIDOf(
      _classRef, "getAddress", "()Ljava/lang/String;");

  /// from: public java.lang.String getAddress()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the hardware address of the local Bluetooth adapter.
  /// For example, "00:11:22:AA:BB:CC".
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH
  ///@return Bluetooth hardware address as string
  jni.JniString getAddress() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAddress, jni.JniType.objectType, []).object);

  static final _id_getName =
      jniAccessors.getMethodIDOf(_classRef, "getName", "()Ljava/lang/String;");

  /// from: public java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the friendly Bluetooth name of the local Bluetooth adapter.
  /// This name is visible to remote Bluetooth devices.
  /// Requires android.Manifest.permission\#BLUETOOTH
  ///@return the Bluetooth name, or null on error
  jni.JniString getName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);

  static final _id_setName =
      jniAccessors.getMethodIDOf(_classRef, "setName", "(Ljava/lang/String;)Z");

  /// from: public boolean setName(java.lang.String name)
  ///
  /// Set the friendly Bluetooth name of the local Bluetooth adapter.
  /// This name is visible to remote Bluetooth devices.
  /// Valid Bluetooth names are a maximum of 248 bytes using UTF-8
  /// encoding, although many remote devices can only display the first
  /// 40 characters, and some may be limited to just 20.
  /// If Bluetooth state is not \#STATE_ON, this API
  /// will return false. After turning on Bluetooth,
  /// wait for \#ACTION_STATE_CHANGED with \#STATE_ON
  /// to get the updated value.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH_ADMIN
  ///@param name a valid Bluetooth name
  ///@return true if the name was set, false otherwise
  bool setName(jni.JniString name) => jniAccessors.callMethodWithArgs(reference,
      _id_setName, jni.JniType.booleanType, [name.reference]).boolean;

  static final _id_getScanMode =
      jniAccessors.getMethodIDOf(_classRef, "getScanMode", "()I");

  /// from: public int getScanMode()
  ///
  /// Get the current Bluetooth scan mode of the local Bluetooth adapter.
  /// The Bluetooth scan mode determines if the local adapter is
  /// connectable and/or discoverable from remote Bluetooth devices.
  /// Possible values are:
  /// \#SCAN_MODE_NONE,
  /// \#SCAN_MODE_CONNECTABLE,
  /// \#SCAN_MODE_CONNECTABLE_DISCOVERABLE.
  /// If Bluetooth state is not \#STATE_ON, this API
  /// will return \#SCAN_MODE_NONE. After turning on Bluetooth,
  /// wait for \#ACTION_STATE_CHANGED with \#STATE_ON
  /// to get the updated value.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH
  ///@return scan mode
  ///
  /// Value is android.bluetooth.BluetoothAdapter\#SCAN_MODE_NONE, android.bluetooth.BluetoothAdapter\#SCAN_MODE_CONNECTABLE, or android.bluetooth.BluetoothAdapter\#SCAN_MODE_CONNECTABLE_DISCOVERABLE
  int getScanMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getScanMode, jni.JniType.intType, []).integer;

  static final _id_startDiscovery =
      jniAccessors.getMethodIDOf(_classRef, "startDiscovery", "()Z");

  /// from: public boolean startDiscovery()
  ///
  /// Start the remote device discovery process.
  /// The discovery process usually involves an inquiry scan of about 12
  /// seconds, followed by a page scan of each new device to retrieve its
  /// Bluetooth name.
  /// This is an asynchronous call, it will return immediately. Register
  /// for \#ACTION_DISCOVERY_STARTED and \#ACTION_DISCOVERY_FINISHED intents to determine exactly when the
  /// discovery starts and completes. Register for BluetoothDevice\#ACTION_FOUND to be notified as remote Bluetooth devices
  /// are found.
  /// Device discovery is a heavyweight procedure. New connections to
  /// remote Bluetooth devices should not be attempted while discovery is in
  /// progress, and existing connections will experience limited bandwidth
  /// and high latency. Use \#cancelDiscovery() to cancel an ongoing
  /// discovery. Discovery is not managed by the Activity,
  /// but is run as a system service, so an application should always call
  /// BluetoothAdapter\#cancelDiscovery() even if it
  /// did not directly request a discovery, just to be sure.
  /// Device discovery will only find remote devices that are currently
  /// <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
  /// not discoverable by default, and need to be entered into a special mode.
  /// If Bluetooth state is not \#STATE_ON, this API
  /// will return false. After turning on Bluetooth,
  /// wait for \#ACTION_STATE_CHANGED with \#STATE_ON
  /// to get the updated value.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH_ADMIN
  ///@return true on success, false on error
  bool startDiscovery() => jniAccessors.callMethodWithArgs(
      reference, _id_startDiscovery, jni.JniType.booleanType, []).boolean;

  static final _id_cancelDiscovery =
      jniAccessors.getMethodIDOf(_classRef, "cancelDiscovery", "()Z");

  /// from: public boolean cancelDiscovery()
  ///
  /// Cancel the current device discovery process.
  /// Because discovery is a heavyweight procedure for the Bluetooth
  /// adapter, this method should always be called before attempting to connect
  /// to a remote device with android.bluetooth.BluetoothSocket\#connect(). Discovery is not managed by
  /// the  Activity, but is run as a system service, so an application should
  /// always call cancel discovery even if it did not directly request a
  /// discovery, just to be sure.
  /// If Bluetooth state is not \#STATE_ON, this API
  /// will return false. After turning on Bluetooth,
  /// wait for \#ACTION_STATE_CHANGED with \#STATE_ON
  /// to get the updated value.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH_ADMIN
  ///@return true on success, false on error
  bool cancelDiscovery() => jniAccessors.callMethodWithArgs(
      reference, _id_cancelDiscovery, jni.JniType.booleanType, []).boolean;

  static final _id_isDiscovering =
      jniAccessors.getMethodIDOf(_classRef, "isDiscovering", "()Z");

  /// from: public boolean isDiscovering()
  ///
  /// Return true if the local Bluetooth adapter is currently in the device
  /// discovery process.
  /// Device discovery is a heavyweight procedure. New connections to
  /// remote Bluetooth devices should not be attempted while discovery is in
  /// progress, and existing connections will experience limited bandwidth
  /// and high latency. Use \#cancelDiscovery() to cancel an ongoing
  /// discovery.
  /// Applications can also register for \#ACTION_DISCOVERY_STARTED
  /// or \#ACTION_DISCOVERY_FINISHED to be notified when discovery
  /// starts or completes.
  /// If Bluetooth state is not \#STATE_ON, this API
  /// will return false. After turning on Bluetooth,
  /// wait for \#ACTION_STATE_CHANGED with \#STATE_ON
  /// to get the updated value.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH
  ///@return true if discovering
  bool isDiscovering() => jniAccessors.callMethodWithArgs(
      reference, _id_isDiscovering, jni.JniType.booleanType, []).boolean;

  static final _id_isMultipleAdvertisementSupported = jniAccessors
      .getMethodIDOf(_classRef, "isMultipleAdvertisementSupported", "()Z");

  /// from: public boolean isMultipleAdvertisementSupported()
  ///
  /// Return true if the multi advertisement is supported by the chipset
  ///@return true if Multiple Advertisement feature is supported
  bool isMultipleAdvertisementSupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isMultipleAdvertisementSupported,
      jni.JniType.booleanType, []).boolean;

  static final _id_isOffloadedFilteringSupported = jniAccessors.getMethodIDOf(
      _classRef, "isOffloadedFilteringSupported", "()Z");

  /// from: public boolean isOffloadedFilteringSupported()
  ///
  /// Return true if offloaded filters are supported
  ///@return true if chipset supports on-chip filtering
  bool isOffloadedFilteringSupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isOffloadedFilteringSupported,
      jni.JniType.booleanType, []).boolean;

  static final _id_isOffloadedScanBatchingSupported = jniAccessors
      .getMethodIDOf(_classRef, "isOffloadedScanBatchingSupported", "()Z");

  /// from: public boolean isOffloadedScanBatchingSupported()
  ///
  /// Return true if offloaded scan batching is supported
  ///@return true if chipset supports on-chip scan batching
  bool isOffloadedScanBatchingSupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isOffloadedScanBatchingSupported,
      jni.JniType.booleanType, []).boolean;

  static final _id_isLe2MPhySupported =
      jniAccessors.getMethodIDOf(_classRef, "isLe2MPhySupported", "()Z");

  /// from: public boolean isLe2MPhySupported()
  ///
  /// Return true if LE 2M PHY feature is supported.
  ///@return true if chipset supports LE 2M PHY feature
  bool isLe2MPhySupported() => jniAccessors.callMethodWithArgs(
      reference, _id_isLe2MPhySupported, jni.JniType.booleanType, []).boolean;

  static final _id_isLeCodedPhySupported =
      jniAccessors.getMethodIDOf(_classRef, "isLeCodedPhySupported", "()Z");

  /// from: public boolean isLeCodedPhySupported()
  ///
  /// Return true if LE Coded PHY feature is supported.
  ///@return true if chipset supports LE Coded PHY feature
  bool isLeCodedPhySupported() => jniAccessors.callMethodWithArgs(reference,
      _id_isLeCodedPhySupported, jni.JniType.booleanType, []).boolean;

  static final _id_isLeExtendedAdvertisingSupported = jniAccessors
      .getMethodIDOf(_classRef, "isLeExtendedAdvertisingSupported", "()Z");

  /// from: public boolean isLeExtendedAdvertisingSupported()
  ///
  /// Return true if LE Extended Advertising feature is supported.
  ///@return true if chipset supports LE Extended Advertising feature
  bool isLeExtendedAdvertisingSupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isLeExtendedAdvertisingSupported,
      jni.JniType.booleanType, []).boolean;

  static final _id_isLePeriodicAdvertisingSupported = jniAccessors
      .getMethodIDOf(_classRef, "isLePeriodicAdvertisingSupported", "()Z");

  /// from: public boolean isLePeriodicAdvertisingSupported()
  ///
  /// Return true if LE Periodic Advertising feature is supported.
  ///@return true if chipset supports LE Periodic Advertising feature
  bool isLePeriodicAdvertisingSupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isLePeriodicAdvertisingSupported,
      jni.JniType.booleanType, []).boolean;

  static final _id_getLeMaximumAdvertisingDataLength = jniAccessors
      .getMethodIDOf(_classRef, "getLeMaximumAdvertisingDataLength", "()I");

  /// from: public int getLeMaximumAdvertisingDataLength()
  ///
  /// Return the maximum LE advertising data length in bytes,
  /// if LE Extended Advertising feature is supported, 0 otherwise.
  ///@return the maximum LE advertising data length.
  int getLeMaximumAdvertisingDataLength() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getLeMaximumAdvertisingDataLength,
      jni.JniType.intType, []).integer;

  static final _id_getBondedDevices = jniAccessors.getMethodIDOf(
      _classRef, "getBondedDevices", "()Ljava/util/Set;");

  /// from: public java.util.Set<android.bluetooth.BluetoothDevice> getBondedDevices()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the set of BluetoothDevice objects that are bonded
  /// (paired) to the local adapter.
  /// If Bluetooth state is not \#STATE_ON, this API
  /// will return an empty set. After turning on Bluetooth,
  /// wait for \#ACTION_STATE_CHANGED with \#STATE_ON
  /// to get the updated value.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH
  ///@return unmodifiable set of BluetoothDevice, or null on error
  jni.JniObject getBondedDevices() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBondedDevices, jni.JniType.objectType, []).object);

  static final _id_getProfileConnectionState = jniAccessors.getMethodIDOf(
      _classRef, "getProfileConnectionState", "(I)I");

  /// from: public int getProfileConnectionState(int profile)
  ///
  /// Get the current connection state of a profile.
  /// This function can be used to check whether the local Bluetooth adapter
  /// is connected to any remote device for a specific profile.
  /// Profile can be one of BluetoothProfile\#HEALTH, BluetoothProfile\#HEADSET,
  /// BluetoothProfile\#A2DP.
  ///
  ///  Return value can be one of
  /// BluetoothProfile\#STATE_DISCONNECTED,
  /// BluetoothProfile\#STATE_CONNECTING,
  /// BluetoothProfile\#STATE_CONNECTED,
  /// BluetoothProfile\#STATE_DISCONNECTING
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH
  int getProfileConnectionState(int profile) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getProfileConnectionState,
      jni.JniType.intType,
      [profile]).integer;

  static final _id_listenUsingRfcommWithServiceRecord = jniAccessors.getMethodIDOf(
      _classRef,
      "listenUsingRfcommWithServiceRecord",
      "(Ljava/lang/String;Ljava/util/UUID;)Landroid/bluetooth/BluetoothServerSocket;");

  /// from: public android.bluetooth.BluetoothServerSocket listenUsingRfcommWithServiceRecord(java.lang.String name, java.util.UUID uuid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a listening, secure RFCOMM Bluetooth socket with Service Record.
  /// A remote device connecting to this socket will be authenticated and
  /// communication on this socket will be encrypted.
  /// Use BluetoothServerSocket\#accept to retrieve incoming
  /// connections from a listening BluetoothServerSocket.
  /// The system will assign an unused RFCOMM channel to listen on.
  /// The system will also register a Service Discovery
  /// Protocol (SDP) record with the local SDP server containing the specified
  /// UUID, service name, and auto-assigned channel. Remote Bluetooth devices
  /// can use the same UUID to query our SDP server and discover which channel
  /// to connect to. This SDP record will be removed when this socket is
  /// closed, or if this application closes unexpectedly.
  /// Use BluetoothDevice\#createRfcommSocketToServiceRecord to
  /// connect to this socket from another device using the same UUID.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH
  ///@param name service name for SDP record
  ///@param uuid uuid for SDP record
  ///@return a listening RFCOMM BluetoothServerSocket
  ///@throws IOException on error, for example Bluetooth not available, or insufficient
  /// permissions, or channel in use.
  bluetoothserversocket_.BluetoothServerSocket
      listenUsingRfcommWithServiceRecord(
              jni.JniString name, jni.JniObject uuid) =>
          bluetoothserversocket_.BluetoothServerSocket.fromRef(jniAccessors
              .callMethodWithArgs(
                  reference,
                  _id_listenUsingRfcommWithServiceRecord,
                  jni.JniType.objectType,
                  [name.reference, uuid.reference]).object);

  static final _id_listenUsingInsecureRfcommWithServiceRecord =
      jniAccessors.getMethodIDOf(
          _classRef,
          "listenUsingInsecureRfcommWithServiceRecord",
          "(Ljava/lang/String;Ljava/util/UUID;)Landroid/bluetooth/BluetoothServerSocket;");

  /// from: public android.bluetooth.BluetoothServerSocket listenUsingInsecureRfcommWithServiceRecord(java.lang.String name, java.util.UUID uuid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a listening, insecure RFCOMM Bluetooth socket with Service Record.
  /// The link key is not required to be authenticated, i.e the communication may be
  /// vulnerable to Man In the Middle attacks. For Bluetooth 2.1 devices,
  /// the link will be encrypted, as encryption is mandartory.
  /// For legacy devices (pre Bluetooth 2.1 devices) the link will not
  /// be encrypted. Use \#listenUsingRfcommWithServiceRecord, if an
  /// encrypted and authenticated communication channel is desired.
  /// Use BluetoothServerSocket\#accept to retrieve incoming
  /// connections from a listening BluetoothServerSocket.
  /// The system will assign an unused RFCOMM channel to listen on.
  /// The system will also register a Service Discovery
  /// Protocol (SDP) record with the local SDP server containing the specified
  /// UUID, service name, and auto-assigned channel. Remote Bluetooth devices
  /// can use the same UUID to query our SDP server and discover which channel
  /// to connect to. This SDP record will be removed when this socket is
  /// closed, or if this application closes unexpectedly.
  /// Use BluetoothDevice\#createRfcommSocketToServiceRecord to
  /// connect to this socket from another device using the same UUID.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH
  ///@param name service name for SDP record
  ///@param uuid uuid for SDP record
  ///@return a listening RFCOMM BluetoothServerSocket
  ///@throws IOException on error, for example Bluetooth not available, or insufficient
  /// permissions, or channel in use.
  bluetoothserversocket_.BluetoothServerSocket
      listenUsingInsecureRfcommWithServiceRecord(
              jni.JniString name, jni.JniObject uuid) =>
          bluetoothserversocket_.BluetoothServerSocket.fromRef(jniAccessors
              .callMethodWithArgs(
                  reference,
                  _id_listenUsingInsecureRfcommWithServiceRecord,
                  jni.JniType.objectType,
                  [name.reference, uuid.reference]).object);

  static final _id_getProfileProxy = jniAccessors.getMethodIDOf(
      _classRef,
      "getProfileProxy",
      "(Landroid/content/Context;Landroid/bluetooth/BluetoothProfile\$ServiceListener;I)Z");

  /// from: public boolean getProfileProxy(android.content.Context context, android.bluetooth.BluetoothProfile.ServiceListener listener, int profile)
  ///
  /// Get the profile proxy object associated with the profile.
  ///
  /// Profile can be one of BluetoothProfile\#HEALTH, BluetoothProfile\#HEADSET,
  /// BluetoothProfile\#A2DP, BluetoothProfile\#GATT, or
  /// BluetoothProfile\#GATT_SERVER. Clients must implement
  /// BluetoothProfile.ServiceListener to get notified of
  /// the connection status and to get the proxy object.
  ///@param context Context of the application
  ///@param listener The service Listener for connection callbacks.
  ///@param profile The Bluetooth profile; either BluetoothProfile\#HEALTH, BluetoothProfile\#HEADSET, BluetoothProfile\#A2DP. BluetoothProfile\#GATT or
  /// BluetoothProfile\#GATT_SERVER.
  ///@return true on success, false on error
  bool getProfileProxy(
          context_.Context context,
          bluetoothprofile_.BluetoothProfile_ServiceListener listener,
          int profile) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getProfileProxy,
          jni.JniType.booleanType,
          [context.reference, listener.reference, profile]).boolean;

  static final _id_closeProfileProxy = jniAccessors.getMethodIDOf(_classRef,
      "closeProfileProxy", "(ILandroid/bluetooth/BluetoothProfile;)V");

  /// from: public void closeProfileProxy(int profile, android.bluetooth.BluetoothProfile proxy)
  ///
  /// Close the connection of the profile proxy to the Service.
  ///
  ///  Clients should call this when they are no longer using
  /// the proxy obtained from \#getProfileProxy.
  /// Profile can be one of  BluetoothProfile\#HEALTH, BluetoothProfile\#HEADSET or
  /// BluetoothProfile\#A2DP
  ///@param profile
  ///@param proxy Profile proxy object
  void closeProfileProxy(
          int profile, bluetoothprofile_.BluetoothProfile proxy) =>
      jniAccessors.callMethodWithArgs(reference, _id_closeProfileProxy,
          jni.JniType.voidType, [profile, proxy.reference]).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_checkBluetoothAddress = jniAccessors.getStaticMethodIDOf(
      _classRef, "checkBluetoothAddress", "(Ljava/lang/String;)Z");

  /// from: static public boolean checkBluetoothAddress(java.lang.String address)
  ///
  /// Validate a String Bluetooth address, such as "00:43:A8:23:10:F0"
  /// Alphabetic characters must be uppercase to be valid.
  ///@param address Bluetooth address as string
  ///@return true if the address is valid, false otherwise
  static bool checkBluetoothAddress(jni.JniString address) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_checkBluetoothAddress,
          jni.JniType.booleanType,
          [address.reference]).boolean;

  static final _id_startLeScan = jniAccessors.getMethodIDOf(_classRef,
      "startLeScan", "(Landroid/bluetooth/BluetoothAdapter\$LeScanCallback;)Z");

  /// from: public boolean startLeScan(android.bluetooth.BluetoothAdapter.LeScanCallback callback)
  ///
  /// Starts a scan for Bluetooth LE devices.
  ///
  /// Results of the scan are reported using the
  /// LeScanCallback\#onLeScan callback.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH_ADMIN
  ///@param callback the callback LE scan results are delivered
  ///@return true, if the scan was started successfully
  ///@deprecated use BluetoothLeScanner\#startScan(List, ScanSettings, ScanCallback)
  /// instead.
  bool startLeScan(BluetoothAdapter_LeScanCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_startLeScan,
          jni.JniType.booleanType, [callback.reference]).boolean;

  static final _id_startLeScan1 = jniAccessors.getMethodIDOf(
      _classRef,
      "startLeScan",
      "([Ljava/util/UUID;Landroid/bluetooth/BluetoothAdapter\$LeScanCallback;)Z");

  /// from: public boolean startLeScan(java.util.UUID[] serviceUuids, android.bluetooth.BluetoothAdapter.LeScanCallback callback)
  ///
  /// Starts a scan for Bluetooth LE devices, looking for devices that
  /// advertise given services.
  ///
  /// Devices which advertise all specified services are reported using the
  /// LeScanCallback\#onLeScan callback.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH_ADMIN
  ///@param serviceUuids Array of services to look for
  ///@param callback the callback LE scan results are delivered
  ///@return true, if the scan was started successfully
  ///@deprecated use BluetoothLeScanner\#startScan(List, ScanSettings, ScanCallback)
  /// instead.
  bool startLeScan1(jni.JniObject serviceUuids,
          BluetoothAdapter_LeScanCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_startLeScan1,
          jni.JniType.booleanType,
          [serviceUuids.reference, callback.reference]).boolean;

  static final _id_stopLeScan = jniAccessors.getMethodIDOf(_classRef,
      "stopLeScan", "(Landroid/bluetooth/BluetoothAdapter\$LeScanCallback;)V");

  /// from: public void stopLeScan(android.bluetooth.BluetoothAdapter.LeScanCallback callback)
  ///
  /// Stops an ongoing Bluetooth LE device scan.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH_ADMIN
  ///@param callback used to identify which scan to stop must be the same handle used to start the
  /// scan
  ///@deprecated Use BluetoothLeScanner\#stopScan(ScanCallback) instead.
  void stopLeScan(BluetoothAdapter_LeScanCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_stopLeScan,
          jni.JniType.voidType, [callback.reference]).check();
}

/// from: android.bluetooth.BluetoothAdapter$LeScanCallback
///
/// Callback interface used to deliver LE scan results.
///@see \#startLeScan(LeScanCallback)
///@see \#startLeScan(UUID[], LeScanCallback)
class BluetoothAdapter_LeScanCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/bluetooth/BluetoothAdapter\$LeScanCallback");
  BluetoothAdapter_LeScanCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onLeScan = jniAccessors.getMethodIDOf(
      _classRef, "onLeScan", "(Landroid/bluetooth/BluetoothDevice;I[B)V");

  /// from: public abstract void onLeScan(android.bluetooth.BluetoothDevice device, int rssi, byte[] scanRecord)
  ///
  /// Callback reporting an LE device found during a device scan initiated
  /// by the BluetoothAdapter\#startLeScan function.
  ///@param device Identifies the remote device
  ///@param rssi The RSSI value for the remote device as reported by the Bluetooth hardware. 0
  /// if no RSSI value is available.
  ///@param scanRecord The content of the advertisement record offered by the remote device.
  void onLeScan(bluetoothdevice_.BluetoothDevice device, int rssi,
          jni.JniObject scanRecord) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onLeScan,
          jni.JniType.voidType,
          [device.reference, rssi, scanRecord.reference]).check();
}
