// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "BluetoothDevice.dart" as bluetoothdevice_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.bluetooth.BluetoothA2dp
///
/// This class provides the public APIs to control the Bluetooth A2DP
/// profile.
///
/// BluetoothA2dp is a proxy object for controlling the Bluetooth A2DP
/// Service via IPC. Use BluetoothAdapter\#getProfileProxy to get
/// the BluetoothA2dp proxy object.
///
///  Android only supports one connected Bluetooth A2dp device at a time.
/// Each method is protected with its appropriate permission.
class BluetoothA2dp extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/bluetooth/BluetoothA2dp");
  BluetoothA2dp.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_CONNECTION_STATE_CHANGED
  ///
  /// Intent used to broadcast the change in connection state of the A2DP
  /// profile.
  ///
  /// This intent will have 3 extras:
  /// <ul>
  /// <li> \#EXTRA_STATE - The current state of the profile. </li>
  /// <li> \#EXTRA_PREVIOUS_STATE- The previous state of the profile.</li>
  /// <li> BluetoothDevice\#EXTRA_DEVICE - The remote device. </li>
  /// </ul>
  ///
  /// \#EXTRA_STATE or \#EXTRA_PREVIOUS_STATE can be any of
  /// \#STATE_DISCONNECTED, \#STATE_CONNECTING,
  /// \#STATE_CONNECTED, \#STATE_DISCONNECTING.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission to
  /// receive.
  static const ACTION_CONNECTION_STATE_CHANGED =
      "android.bluetooth.a2dp.profile.action.CONNECTION_STATE_CHANGED";

  /// from: static public final java.lang.String ACTION_PLAYING_STATE_CHANGED
  ///
  /// Intent used to broadcast the change in the Playing state of the A2DP
  /// profile.
  ///
  /// This intent will have 3 extras:
  /// <ul>
  /// <li> \#EXTRA_STATE - The current state of the profile. </li>
  /// <li> \#EXTRA_PREVIOUS_STATE- The previous state of the profile. </li>
  /// <li> BluetoothDevice\#EXTRA_DEVICE - The remote device. </li>
  /// </ul>
  ///
  /// \#EXTRA_STATE or \#EXTRA_PREVIOUS_STATE can be any of
  /// \#STATE_PLAYING, \#STATE_NOT_PLAYING,
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission to
  /// receive.
  static const ACTION_PLAYING_STATE_CHANGED =
      "android.bluetooth.a2dp.profile.action.PLAYING_STATE_CHANGED";

  /// from: static public final int STATE_NOT_PLAYING
  ///
  /// A2DP sink device is NOT streaming music. This state can be one of
  /// \#EXTRA_STATE or \#EXTRA_PREVIOUS_STATE of
  /// \#ACTION_PLAYING_STATE_CHANGED intent.
  static const STATE_NOT_PLAYING = 11;

  /// from: static public final int STATE_PLAYING
  ///
  /// A2DP sink device is streaming music. This state can be one of
  /// \#EXTRA_STATE or \#EXTRA_PREVIOUS_STATE of
  /// \#ACTION_PLAYING_STATE_CHANGED intent.
  static const STATE_PLAYING = 10;

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: public void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_getConnectedDevices = jniAccessors.getMethodIDOf(
      _classRef, "getConnectedDevices", "()Ljava/util/List;");

  /// from: public java.util.List<android.bluetooth.BluetoothDevice> getConnectedDevices()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniObject getConnectedDevices() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getConnectedDevices, jni.JniType.objectType, []).object);

  static final _id_getDevicesMatchingConnectionStates =
      jniAccessors.getMethodIDOf(_classRef,
          "getDevicesMatchingConnectionStates", "([I)Ljava/util/List;");

  /// from: public java.util.List<android.bluetooth.BluetoothDevice> getDevicesMatchingConnectionStates(int[] states)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniObject getDevicesMatchingConnectionStates(jni.JniObject states) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDevicesMatchingConnectionStates,
          jni.JniType.objectType,
          [states.reference]).object);

  static final _id_getConnectionState = jniAccessors.getMethodIDOf(_classRef,
      "getConnectionState", "(Landroid/bluetooth/BluetoothDevice;)I");

  /// from: public int getConnectionState(android.bluetooth.BluetoothDevice device)
  ///
  /// {@inheritDoc}
  int getConnectionState(bluetoothdevice_.BluetoothDevice device) =>
      jniAccessors.callMethodWithArgs(reference, _id_getConnectionState,
          jni.JniType.intType, [device.reference]).integer;

  static final _id_isA2dpPlaying = jniAccessors.getMethodIDOf(
      _classRef, "isA2dpPlaying", "(Landroid/bluetooth/BluetoothDevice;)Z");

  /// from: public boolean isA2dpPlaying(android.bluetooth.BluetoothDevice device)
  ///
  /// Check if A2DP profile is streaming music.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param device BluetoothDevice device
  bool isA2dpPlaying(bluetoothdevice_.BluetoothDevice device) =>
      jniAccessors.callMethodWithArgs(reference, _id_isA2dpPlaying,
          jni.JniType.booleanType, [device.reference]).boolean;
}
