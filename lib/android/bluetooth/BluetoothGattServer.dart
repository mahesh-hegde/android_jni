// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "BluetoothDevice.dart" as bluetoothdevice_;

import "BluetoothGattCharacteristic.dart" as bluetoothgattcharacteristic_;

import "BluetoothGattService.dart" as bluetoothgattservice_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.bluetooth.BluetoothGattServer
///
/// Public API for the Bluetooth GATT Profile server role.
///
/// This class provides Bluetooth GATT server role functionality,
/// allowing applications to create Bluetooth Smart services and
/// characteristics.
///
/// BluetoothGattServer is a proxy object for controlling the Bluetooth Service
/// via IPC.  Use BluetoothManager\#openGattServer to get an instance
/// of this class.
class BluetoothGattServer extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/bluetooth/BluetoothGattServer");
  BluetoothGattServer.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Close this GATT server instance.
  ///
  /// Application should call this method as early as possible after it is done with
  /// this GATT server.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_connect = jniAccessors.getMethodIDOf(
      _classRef, "connect", "(Landroid/bluetooth/BluetoothDevice;Z)Z");

  /// from: public boolean connect(android.bluetooth.BluetoothDevice device, boolean autoConnect)
  ///
  /// Initiate a connection to a Bluetooth GATT capable device.
  ///
  /// The connection may not be established right away, but will be
  /// completed when the remote device is available. A
  /// BluetoothGattServerCallback\#onConnectionStateChange callback will be
  /// invoked when the connection state changes as a result of this function.
  ///
  /// The autoConnect paramter determines whether to actively connect to
  /// the remote device, or rather passively scan and finalize the connection
  /// when the remote device is in range/available. Generally, the first ever
  /// connection to a device should be direct (autoConnect set to false) and
  /// subsequent connections to known devices should be invoked with the
  /// autoConnect parameter set to true.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param autoConnect Whether to directly connect to the remote device (false) or to
  /// automatically connect as soon as the remote device becomes available (true).
  ///@return true, if the connection attempt was initiated successfully
  bool connect(bluetoothdevice_.BluetoothDevice device, bool autoConnect) =>
      jniAccessors.callMethodWithArgs(reference, _id_connect,
          jni.JniType.booleanType, [device.reference, autoConnect]).boolean;

  static final _id_cancelConnection = jniAccessors.getMethodIDOf(
      _classRef, "cancelConnection", "(Landroid/bluetooth/BluetoothDevice;)V");

  /// from: public void cancelConnection(android.bluetooth.BluetoothDevice device)
  ///
  /// Disconnects an established connection, or cancels a connection attempt
  /// currently in progress.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param device Remote device
  void cancelConnection(bluetoothdevice_.BluetoothDevice device) =>
      jniAccessors.callMethodWithArgs(reference, _id_cancelConnection,
          jni.JniType.voidType, [device.reference]).check();

  static final _id_setPreferredPhy = jniAccessors.getMethodIDOf(_classRef,
      "setPreferredPhy", "(Landroid/bluetooth/BluetoothDevice;III)V");

  /// from: public void setPreferredPhy(android.bluetooth.BluetoothDevice device, int txPhy, int rxPhy, int phyOptions)
  ///
  /// Set the preferred connection PHY for this app. Please note that this is just a
  /// recommendation, whether the PHY change will happen depends on other applications peferences,
  /// local and remote controller capabilities. Controller can override these settings.  BluetoothGattServerCallback\#onPhyUpdate will be triggered as a result of this call, even if
  /// no PHY change happens. It is also triggered when remote device updates the PHY.
  ///@param device The remote device to send this response to
  ///@param txPhy preferred transmitter PHY. Bitwise OR of any of BluetoothDevice\#PHY_LE_1M_MASK, BluetoothDevice\#PHY_LE_2M_MASK, and BluetoothDevice\#PHY_LE_CODED_MASK.
  ///@param rxPhy preferred receiver PHY. Bitwise OR of any of BluetoothDevice\#PHY_LE_1M_MASK, BluetoothDevice\#PHY_LE_2M_MASK, and BluetoothDevice\#PHY_LE_CODED_MASK.
  ///@param phyOptions preferred coding to use when transmitting on the LE Coded PHY. Can be one
  /// of BluetoothDevice\#PHY_OPTION_NO_PREFERRED, BluetoothDevice\#PHY_OPTION_S2 or
  /// BluetoothDevice\#PHY_OPTION_S8
  void setPreferredPhy(bluetoothdevice_.BluetoothDevice device, int txPhy,
          int rxPhy, int phyOptions) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setPreferredPhy,
          jni.JniType.voidType,
          [device.reference, txPhy, rxPhy, phyOptions]).check();

  static final _id_readPhy = jniAccessors.getMethodIDOf(
      _classRef, "readPhy", "(Landroid/bluetooth/BluetoothDevice;)V");

  /// from: public void readPhy(android.bluetooth.BluetoothDevice device)
  ///
  /// Read the current transmitter PHY and receiver PHY of the connection. The values are returned
  /// in BluetoothGattServerCallback\#onPhyRead
  ///@param device The remote device to send this response to
  void readPhy(bluetoothdevice_.BluetoothDevice device) =>
      jniAccessors.callMethodWithArgs(reference, _id_readPhy,
          jni.JniType.voidType, [device.reference]).check();

  static final _id_sendResponse = jniAccessors.getMethodIDOf(
      _classRef, "sendResponse", "(Landroid/bluetooth/BluetoothDevice;III[B)Z");

  /// from: public boolean sendResponse(android.bluetooth.BluetoothDevice device, int requestId, int status, int offset, byte[] value)
  ///
  /// Send a response to a read or write request to a remote device.
  ///
  /// This function must be invoked in when a remote read/write request
  /// is received by one of these callback methods:
  ///
  /// <ul>
  /// <li>BluetoothGattServerCallback\#onCharacteristicReadRequest
  /// <li>BluetoothGattServerCallback\#onCharacteristicWriteRequest
  /// <li>BluetoothGattServerCallback\#onDescriptorReadRequest
  /// <li>BluetoothGattServerCallback\#onDescriptorWriteRequest
  /// </ul>
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param device The remote device to send this response to
  ///@param requestId The ID of the request that was received with the callback
  ///@param status The status of the request to be sent to the remote devices
  ///@param offset Value offset for partial read/write response
  ///@param value The value of the attribute that was read/written (optional)
  bool sendResponse(bluetoothdevice_.BluetoothDevice device, int requestId,
          int status, int offset, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_sendResponse, jni.JniType.booleanType, [
        device.reference,
        requestId,
        status,
        offset,
        value.reference
      ]).boolean;

  static final _id_notifyCharacteristicChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "notifyCharacteristicChanged",
      "(Landroid/bluetooth/BluetoothDevice;Landroid/bluetooth/BluetoothGattCharacteristic;Z)Z");

  /// from: public boolean notifyCharacteristicChanged(android.bluetooth.BluetoothDevice device, android.bluetooth.BluetoothGattCharacteristic characteristic, boolean confirm)
  ///
  /// Send a notification or indication that a local characteristic has been
  /// updated.
  ///
  /// A notification or indication is sent to the remote device to signal
  /// that the characteristic has been updated. This function should be invoked
  /// for every client that requests notifications/indications by writing
  /// to the "Client Configuration" descriptor for the given characteristic.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param device The remote device to receive the notification/indication
  ///@param characteristic The local characteristic that has been updated
  ///@param confirm true to request confirmation from the client (indication), false to send a
  /// notification
  ///@return true, if the notification has been triggered successfully
  ///@throws IllegalArgumentException
  bool notifyCharacteristicChanged(
          bluetoothdevice_.BluetoothDevice device,
          bluetoothgattcharacteristic_.BluetoothGattCharacteristic
              characteristic,
          bool confirm) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_notifyCharacteristicChanged,
          jni.JniType.booleanType,
          [device.reference, characteristic.reference, confirm]).boolean;

  static final _id_addService = jniAccessors.getMethodIDOf(
      _classRef, "addService", "(Landroid/bluetooth/BluetoothGattService;)Z");

  /// from: public boolean addService(android.bluetooth.BluetoothGattService service)
  ///
  /// Add a service to the list of services to be hosted.
  ///
  /// Once a service has been addded to the the list, the service and its
  /// included characteristics will be provided by the local device.
  ///
  /// If the local device has already exposed services when this function
  /// is called, a service update notification will be sent to all clients.
  ///
  /// The BluetoothGattServerCallback\#onServiceAdded callback will indicate
  /// whether this service has been added successfully. Do not add another service
  /// before this callback.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param service Service to be added to the list of services provided by this device.
  ///@return true, if the request to add service has been initiated
  bool addService(bluetoothgattservice_.BluetoothGattService service) =>
      jniAccessors.callMethodWithArgs(reference, _id_addService,
          jni.JniType.booleanType, [service.reference]).boolean;

  static final _id_removeService = jniAccessors.getMethodIDOf(_classRef,
      "removeService", "(Landroid/bluetooth/BluetoothGattService;)Z");

  /// from: public boolean removeService(android.bluetooth.BluetoothGattService service)
  ///
  /// Removes a service from the list of services to be provided.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param service Service to be removed.
  ///@return true, if the service has been removed
  bool removeService(bluetoothgattservice_.BluetoothGattService service) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeService,
          jni.JniType.booleanType, [service.reference]).boolean;

  static final _id_clearServices =
      jniAccessors.getMethodIDOf(_classRef, "clearServices", "()V");

  /// from: public void clearServices()
  ///
  /// Remove all services from the list of provided services.
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  void clearServices() => jniAccessors.callMethodWithArgs(
      reference, _id_clearServices, jni.JniType.voidType, []).check();

  static final _id_getServices = jniAccessors.getMethodIDOf(
      _classRef, "getServices", "()Ljava/util/List;");

  /// from: public java.util.List<android.bluetooth.BluetoothGattService> getServices()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of GATT services offered by this device.
  ///
  /// An application must call \#addService to add a serice to the
  /// list of services offered by this device.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@return List of services. Returns an empty list if no services have been added yet.
  jni.JniObject getServices() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getServices, jni.JniType.objectType, []).object);

  static final _id_getService = jniAccessors.getMethodIDOf(
      _classRef,
      "getService",
      "(Ljava/util/UUID;)Landroid/bluetooth/BluetoothGattService;");

  /// from: public android.bluetooth.BluetoothGattService getService(java.util.UUID uuid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a BluetoothGattService from the list of services offered
  /// by this device.
  ///
  /// If multiple instances of the same service (as identified by UUID)
  /// exist, the first instance of the service is returned.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param uuid UUID of the requested service
  ///@return BluetoothGattService if supported, or null if the requested service is not offered by
  /// this device.
  bluetoothgattservice_.BluetoothGattService getService(jni.JniObject uuid) =>
      bluetoothgattservice_.BluetoothGattService.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getService, jni.JniType.objectType,
              [uuid.reference]).object);

  static final _id_getConnectionState = jniAccessors.getMethodIDOf(_classRef,
      "getConnectionState", "(Landroid/bluetooth/BluetoothDevice;)I");

  /// from: public int getConnectionState(android.bluetooth.BluetoothDevice device)
  ///
  /// Not supported - please use BluetoothManager\#getConnectedDevices(int)
  /// with BluetoothProfile\#GATT as argument
  ///@throws UnsupportedOperationException
  int getConnectionState(bluetoothdevice_.BluetoothDevice device) =>
      jniAccessors.callMethodWithArgs(reference, _id_getConnectionState,
          jni.JniType.intType, [device.reference]).integer;

  static final _id_getConnectedDevices = jniAccessors.getMethodIDOf(
      _classRef, "getConnectedDevices", "()Ljava/util/List;");

  /// from: public java.util.List<android.bluetooth.BluetoothDevice> getConnectedDevices()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Not supported - please use BluetoothManager\#getConnectedDevices(int)
  /// with BluetoothProfile\#GATT as argument
  ///@throws UnsupportedOperationException
  jni.JniObject getConnectedDevices() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getConnectedDevices, jni.JniType.objectType, []).object);

  static final _id_getDevicesMatchingConnectionStates =
      jniAccessors.getMethodIDOf(_classRef,
          "getDevicesMatchingConnectionStates", "([I)Ljava/util/List;");

  /// from: public java.util.List<android.bluetooth.BluetoothDevice> getDevicesMatchingConnectionStates(int[] states)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Not supported - please use
  /// BluetoothManager\#getDevicesMatchingConnectionStates(int, int[])
  /// with BluetoothProfile\#GATT as first argument
  ///@throws UnsupportedOperationException
  jni.JniObject getDevicesMatchingConnectionStates(jni.JniObject states) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDevicesMatchingConnectionStates,
          jni.JniType.objectType,
          [states.reference]).object);
}
