// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "BluetoothDevice.dart" as bluetoothdevice_;

import "BluetoothGattService.dart" as bluetoothgattservice_;

import "BluetoothGattCharacteristic.dart" as bluetoothgattcharacteristic_;

import "BluetoothGattDescriptor.dart" as bluetoothgattdescriptor_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.bluetooth.BluetoothGatt
///
/// Public API for the Bluetooth GATT Profile.
///
/// This class provides Bluetooth GATT functionality to enable communication
/// with Bluetooth Smart or Smart Ready devices.
///
/// To connect to a remote peripheral device, create a BluetoothGattCallback
/// and call BluetoothDevice\#connectGatt to get a instance of this class.
/// GATT capable devices can be discovered using the Bluetooth device discovery or BLE
/// scan process.
class BluetoothGatt extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/bluetooth/BluetoothGatt");
  BluetoothGatt.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CONNECTION_PRIORITY_BALANCED
  ///
  /// Connection parameter update - Use the connection parameters recommended by the
  /// Bluetooth SIG. This is the default value if no connection parameter update
  /// is requested.
  static const CONNECTION_PRIORITY_BALANCED = 0;

  /// from: static public final int CONNECTION_PRIORITY_HIGH
  ///
  /// Connection parameter update - Request a high priority, low latency connection.
  /// An application should only request high priority connection parameters to transfer large
  /// amounts of data over LE quickly. Once the transfer is complete, the application should
  /// request BluetoothGatt\#CONNECTION_PRIORITY_BALANCED connection parameters to reduce
  /// energy use.
  static const CONNECTION_PRIORITY_HIGH = 1;

  /// from: static public final int CONNECTION_PRIORITY_LOW_POWER
  ///
  /// Connection parameter update - Request low power, reduced data rate connection parameters.
  static const CONNECTION_PRIORITY_LOW_POWER = 2;

  /// from: static public final int GATT_CONNECTION_CONGESTED
  ///
  /// A remote device connection is congested.
  static const GATT_CONNECTION_CONGESTED = 143;

  /// from: static public final int GATT_FAILURE
  ///
  /// A GATT operation failed, errors other than the above
  static const GATT_FAILURE = 257;

  /// from: static public final int GATT_INSUFFICIENT_AUTHENTICATION
  ///
  /// Insufficient authentication for a given operation
  static const GATT_INSUFFICIENT_AUTHENTICATION = 5;

  /// from: static public final int GATT_INSUFFICIENT_ENCRYPTION
  ///
  /// Insufficient encryption for a given operation
  static const GATT_INSUFFICIENT_ENCRYPTION = 15;

  /// from: static public final int GATT_INVALID_ATTRIBUTE_LENGTH
  ///
  /// A write operation exceeds the maximum length of the attribute
  static const GATT_INVALID_ATTRIBUTE_LENGTH = 13;

  /// from: static public final int GATT_INVALID_OFFSET
  ///
  /// A read or write operation was requested with an invalid offset
  static const GATT_INVALID_OFFSET = 7;

  /// from: static public final int GATT_READ_NOT_PERMITTED
  ///
  /// GATT read operation is not permitted
  static const GATT_READ_NOT_PERMITTED = 2;

  /// from: static public final int GATT_REQUEST_NOT_SUPPORTED
  ///
  /// The given request is not supported
  static const GATT_REQUEST_NOT_SUPPORTED = 6;

  /// from: static public final int GATT_SUCCESS
  ///
  /// A GATT operation completed successfully
  static const GATT_SUCCESS = 0;

  /// from: static public final int GATT_WRITE_NOT_PERMITTED
  ///
  /// GATT write operation is not permitted
  static const GATT_WRITE_NOT_PERMITTED = 3;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  BluetoothGatt()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Close this Bluetooth GATT client.
  ///
  /// Application should call this method as early as possible after it is done with
  /// this GATT client.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_disconnect =
      jniAccessors.getMethodIDOf(_classRef, "disconnect", "()V");

  /// from: public void disconnect()
  ///
  /// Disconnects an established connection, or cancels a connection attempt
  /// currently in progress.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  void disconnect() => jniAccessors.callMethodWithArgs(
      reference, _id_disconnect, jni.JniType.voidType, []).check();

  static final _id_connect =
      jniAccessors.getMethodIDOf(_classRef, "connect", "()Z");

  /// from: public boolean connect()
  ///
  /// Connect back to remote device.
  ///
  /// This method is used to re-connect to a remote device after the
  /// connection has been dropped. If the device is not in range, the
  /// re-connection will be triggered once the device is back in range.
  ///@return true, if the connection attempt was initiated successfully
  bool connect() => jniAccessors.callMethodWithArgs(
      reference, _id_connect, jni.JniType.booleanType, []).boolean;

  static final _id_setPreferredPhy =
      jniAccessors.getMethodIDOf(_classRef, "setPreferredPhy", "(III)V");

  /// from: public void setPreferredPhy(int txPhy, int rxPhy, int phyOptions)
  ///
  /// Set the preferred connection PHY for this app. Please note that this is just a
  /// recommendation, whether the PHY change will happen depends on other applications preferences,
  /// local and remote controller capabilities. Controller can override these settings.
  ///
  /// BluetoothGattCallback\#onPhyUpdate will be triggered as a result of this call, even
  /// if no PHY change happens. It is also triggered when remote device updates the PHY.
  ///@param txPhy preferred transmitter PHY. Bitwise OR of any of BluetoothDevice\#PHY_LE_1M_MASK, BluetoothDevice\#PHY_LE_2M_MASK, and BluetoothDevice\#PHY_LE_CODED_MASK.
  ///@param rxPhy preferred receiver PHY. Bitwise OR of any of BluetoothDevice\#PHY_LE_1M_MASK, BluetoothDevice\#PHY_LE_2M_MASK, and BluetoothDevice\#PHY_LE_CODED_MASK.
  ///@param phyOptions preferred coding to use when transmitting on the LE Coded PHY. Can be one
  /// of BluetoothDevice\#PHY_OPTION_NO_PREFERRED, BluetoothDevice\#PHY_OPTION_S2 or
  /// BluetoothDevice\#PHY_OPTION_S8
  void setPreferredPhy(int txPhy, int rxPhy, int phyOptions) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPreferredPhy,
          jni.JniType.voidType, [txPhy, rxPhy, phyOptions]).check();

  static final _id_readPhy =
      jniAccessors.getMethodIDOf(_classRef, "readPhy", "()V");

  /// from: public void readPhy()
  ///
  /// Read the current transmitter PHY and receiver PHY of the connection. The values are returned
  /// in BluetoothGattCallback\#onPhyRead
  void readPhy() => jniAccessors.callMethodWithArgs(
      reference, _id_readPhy, jni.JniType.voidType, []).check();

  static final _id_getDevice = jniAccessors.getMethodIDOf(
      _classRef, "getDevice", "()Landroid/bluetooth/BluetoothDevice;");

  /// from: public android.bluetooth.BluetoothDevice getDevice()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the remote bluetooth device this GATT client targets to
  ///@return remote bluetooth device
  bluetoothdevice_.BluetoothDevice getDevice() =>
      bluetoothdevice_.BluetoothDevice.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDevice, jni.JniType.objectType, []).object);

  static final _id_discoverServices =
      jniAccessors.getMethodIDOf(_classRef, "discoverServices", "()Z");

  /// from: public boolean discoverServices()
  ///
  /// Discovers services offered by a remote device as well as their
  /// characteristics and descriptors.
  ///
  /// This is an asynchronous operation. Once service discovery is completed,
  /// the BluetoothGattCallback\#onServicesDiscovered callback is
  /// triggered. If the discovery was successful, the remote services can be
  /// retrieved using the \#getServices function.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@return true, if the remote service discovery has been started
  bool discoverServices() => jniAccessors.callMethodWithArgs(
      reference, _id_discoverServices, jni.JniType.booleanType, []).boolean;

  static final _id_getServices = jniAccessors.getMethodIDOf(
      _classRef, "getServices", "()Ljava/util/List;");

  /// from: public java.util.List<android.bluetooth.BluetoothGattService> getServices()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of GATT services offered by the remote device.
  ///
  /// This function requires that service discovery has been completed
  /// for the given device.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@return List of services on the remote device. Returns an empty list if service discovery has
  /// not yet been performed.
  jni.JniObject getServices() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getServices, jni.JniType.objectType, []).object);

  static final _id_getService = jniAccessors.getMethodIDOf(
      _classRef,
      "getService",
      "(Ljava/util/UUID;)Landroid/bluetooth/BluetoothGattService;");

  /// from: public android.bluetooth.BluetoothGattService getService(java.util.UUID uuid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a BluetoothGattService, if the requested UUID is
  /// supported by the remote device.
  ///
  /// This function requires that service discovery has been completed
  /// for the given device.
  ///
  /// If multiple instances of the same service (as identified by UUID)
  /// exist, the first instance of the service is returned.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param uuid UUID of the requested service
  ///@return BluetoothGattService if supported, or null if the requested service is not offered by
  /// the remote device.
  bluetoothgattservice_.BluetoothGattService getService(jni.JniObject uuid) =>
      bluetoothgattservice_.BluetoothGattService.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getService, jni.JniType.objectType,
              [uuid.reference]).object);

  static final _id_readCharacteristic = jniAccessors.getMethodIDOf(
      _classRef,
      "readCharacteristic",
      "(Landroid/bluetooth/BluetoothGattCharacteristic;)Z");

  /// from: public boolean readCharacteristic(android.bluetooth.BluetoothGattCharacteristic characteristic)
  ///
  /// Reads the requested characteristic from the associated remote device.
  ///
  /// This is an asynchronous operation. The result of the read operation
  /// is reported by the BluetoothGattCallback\#onCharacteristicRead
  /// callback.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param characteristic Characteristic to read from the remote device
  ///@return true, if the read operation was initiated successfully
  bool readCharacteristic(
          bluetoothgattcharacteristic_.BluetoothGattCharacteristic
              characteristic) =>
      jniAccessors.callMethodWithArgs(reference, _id_readCharacteristic,
          jni.JniType.booleanType, [characteristic.reference]).boolean;

  static final _id_writeCharacteristic = jniAccessors.getMethodIDOf(
      _classRef,
      "writeCharacteristic",
      "(Landroid/bluetooth/BluetoothGattCharacteristic;)Z");

  /// from: public boolean writeCharacteristic(android.bluetooth.BluetoothGattCharacteristic characteristic)
  ///
  /// Writes a given characteristic and its values to the associated remote device.
  ///
  /// Once the write operation has been completed, the
  /// BluetoothGattCallback\#onCharacteristicWrite callback is invoked,
  /// reporting the result of the operation.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param characteristic Characteristic to write on the remote device
  ///@return true, if the write operation was initiated successfully
  bool writeCharacteristic(
          bluetoothgattcharacteristic_.BluetoothGattCharacteristic
              characteristic) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeCharacteristic,
          jni.JniType.booleanType, [characteristic.reference]).boolean;

  static final _id_readDescriptor = jniAccessors.getMethodIDOf(_classRef,
      "readDescriptor", "(Landroid/bluetooth/BluetoothGattDescriptor;)Z");

  /// from: public boolean readDescriptor(android.bluetooth.BluetoothGattDescriptor descriptor)
  ///
  /// Reads the value for a given descriptor from the associated remote device.
  ///
  /// Once the read operation has been completed, the
  /// BluetoothGattCallback\#onDescriptorRead callback is
  /// triggered, signaling the result of the operation.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param descriptor Descriptor value to read from the remote device
  ///@return true, if the read operation was initiated successfully
  bool readDescriptor(
          bluetoothgattdescriptor_.BluetoothGattDescriptor descriptor) =>
      jniAccessors.callMethodWithArgs(reference, _id_readDescriptor,
          jni.JniType.booleanType, [descriptor.reference]).boolean;

  static final _id_writeDescriptor = jniAccessors.getMethodIDOf(_classRef,
      "writeDescriptor", "(Landroid/bluetooth/BluetoothGattDescriptor;)Z");

  /// from: public boolean writeDescriptor(android.bluetooth.BluetoothGattDescriptor descriptor)
  ///
  /// Write the value of a given descriptor to the associated remote device.
  ///
  /// A BluetoothGattCallback\#onDescriptorWrite callback is
  /// triggered to report the result of the write operation.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param descriptor Descriptor to write to the associated remote device
  ///@return true, if the write operation was initiated successfully
  bool writeDescriptor(
          bluetoothgattdescriptor_.BluetoothGattDescriptor descriptor) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeDescriptor,
          jni.JniType.booleanType, [descriptor.reference]).boolean;

  static final _id_beginReliableWrite =
      jniAccessors.getMethodIDOf(_classRef, "beginReliableWrite", "()Z");

  /// from: public boolean beginReliableWrite()
  ///
  /// Initiates a reliable write transaction for a given remote device.
  ///
  /// Once a reliable write transaction has been initiated, all calls
  /// to \#writeCharacteristic are sent to the remote device for
  /// verification and queued up for atomic execution. The application will
  /// receive an BluetoothGattCallback\#onCharacteristicWrite callback
  /// in response to every \#writeCharacteristic call and is responsible
  /// for verifying if the value has been transmitted accurately.
  ///
  /// After all characteristics have been queued up and verified,
  /// \#executeReliableWrite will execute all writes. If a characteristic
  /// was not written correctly, calling \#abortReliableWrite will
  /// cancel the current transaction without commiting any values on the
  /// remote device.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@return true, if the reliable write transaction has been initiated
  bool beginReliableWrite() => jniAccessors.callMethodWithArgs(
      reference, _id_beginReliableWrite, jni.JniType.booleanType, []).boolean;

  static final _id_executeReliableWrite =
      jniAccessors.getMethodIDOf(_classRef, "executeReliableWrite", "()Z");

  /// from: public boolean executeReliableWrite()
  ///
  /// Executes a reliable write transaction for a given remote device.
  ///
  /// This function will commit all queued up characteristic write
  /// operations for a given remote device.
  ///
  /// A BluetoothGattCallback\#onReliableWriteCompleted callback is
  /// invoked to indicate whether the transaction has been executed correctly.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@return true, if the request to execute the transaction has been sent
  bool executeReliableWrite() => jniAccessors.callMethodWithArgs(
      reference, _id_executeReliableWrite, jni.JniType.booleanType, []).boolean;

  static final _id_abortReliableWrite =
      jniAccessors.getMethodIDOf(_classRef, "abortReliableWrite", "()V");

  /// from: public void abortReliableWrite()
  ///
  /// Cancels a reliable write transaction for a given device.
  ///
  /// Calling this function will discard all queued characteristic write
  /// operations for a given remote device.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  void abortReliableWrite() => jniAccessors.callMethodWithArgs(
      reference, _id_abortReliableWrite, jni.JniType.voidType, []).check();

  static final _id_abortReliableWrite1 = jniAccessors.getMethodIDOf(_classRef,
      "abortReliableWrite", "(Landroid/bluetooth/BluetoothDevice;)V");

  /// from: public void abortReliableWrite(android.bluetooth.BluetoothDevice mDevice)
  ///
  /// @deprecated Use \#abortReliableWrite()
  void abortReliableWrite1(bluetoothdevice_.BluetoothDevice mDevice) =>
      jniAccessors.callMethodWithArgs(reference, _id_abortReliableWrite1,
          jni.JniType.voidType, [mDevice.reference]).check();

  static final _id_setCharacteristicNotification = jniAccessors.getMethodIDOf(
      _classRef,
      "setCharacteristicNotification",
      "(Landroid/bluetooth/BluetoothGattCharacteristic;Z)Z");

  /// from: public boolean setCharacteristicNotification(android.bluetooth.BluetoothGattCharacteristic characteristic, boolean enable)
  ///
  /// Enable or disable notifications/indications for a given characteristic.
  ///
  /// Once notifications are enabled for a characteristic, a
  /// BluetoothGattCallback\#onCharacteristicChanged callback will be
  /// triggered if the remote device indicates that the given characteristic
  /// has changed.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@param characteristic The characteristic for which to enable notifications
  ///@param enable Set to true to enable notifications/indications
  ///@return true, if the requested notification status was set successfully
  bool setCharacteristicNotification(
          bluetoothgattcharacteristic_.BluetoothGattCharacteristic
              characteristic,
          bool enable) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setCharacteristicNotification,
          jni.JniType.booleanType,
          [characteristic.reference, enable]).boolean;

  static final _id_readRemoteRssi =
      jniAccessors.getMethodIDOf(_classRef, "readRemoteRssi", "()Z");

  /// from: public boolean readRemoteRssi()
  ///
  /// Read the RSSI for a connected remote device.
  ///
  /// The BluetoothGattCallback\#onReadRemoteRssi callback will be
  /// invoked when the RSSI value has been read.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@return true, if the RSSI value has been requested successfully
  bool readRemoteRssi() => jniAccessors.callMethodWithArgs(
      reference, _id_readRemoteRssi, jni.JniType.booleanType, []).boolean;

  static final _id_requestMtu =
      jniAccessors.getMethodIDOf(_classRef, "requestMtu", "(I)Z");

  /// from: public boolean requestMtu(int mtu)
  ///
  /// Request an MTU size used for a given connection.
  ///
  /// When performing a write request operation (write without response),
  /// the data sent is truncated to the MTU size. This function may be used
  /// to request a larger MTU size to be able to send more data at once.
  ///
  /// A BluetoothGattCallback\#onMtuChanged callback will indicate
  /// whether this operation was successful.
  ///
  /// Requires android.Manifest.permission\#BLUETOOTH permission.
  ///@return true, if the new MTU value has been requested successfully
  bool requestMtu(int mtu) => jniAccessors.callMethodWithArgs(
      reference, _id_requestMtu, jni.JniType.booleanType, [mtu]).boolean;

  static final _id_requestConnectionPriority = jniAccessors.getMethodIDOf(
      _classRef, "requestConnectionPriority", "(I)Z");

  /// from: public boolean requestConnectionPriority(int connectionPriority)
  ///
  /// Request a connection parameter update.
  ///
  /// This function will send a connection parameter update request to the
  /// remote device.
  ///@param connectionPriority Request a specific connection priority. Must be one of BluetoothGatt\#CONNECTION_PRIORITY_BALANCED, BluetoothGatt\#CONNECTION_PRIORITY_HIGH
  /// or BluetoothGatt\#CONNECTION_PRIORITY_LOW_POWER.
  ///@throws IllegalArgumentException If the parameters are outside of their specified range.
  bool requestConnectionPriority(int connectionPriority) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestConnectionPriority,
          jni.JniType.booleanType, [connectionPriority]).boolean;

  static final _id_getConnectionState = jniAccessors.getMethodIDOf(_classRef,
      "getConnectionState", "(Landroid/bluetooth/BluetoothDevice;)I");

  /// from: public int getConnectionState(android.bluetooth.BluetoothDevice device)
  ///
  /// Not supported - please use BluetoothManager\#getConnectedDevices(int)
  /// with BluetoothProfile\#GATT as argument
  ///@throws UnsupportedOperationException
  int getConnectionState(bluetoothdevice_.BluetoothDevice device) =>
      jniAccessors.callMethodWithArgs(reference, _id_getConnectionState,
          jni.JniType.intType, [device.reference]).integer;

  static final _id_getConnectedDevices = jniAccessors.getMethodIDOf(
      _classRef, "getConnectedDevices", "()Ljava/util/List;");

  /// from: public java.util.List<android.bluetooth.BluetoothDevice> getConnectedDevices()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Not supported - please use BluetoothManager\#getConnectedDevices(int)
  /// with BluetoothProfile\#GATT as argument
  ///@throws UnsupportedOperationException
  jni.JniObject getConnectedDevices() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getConnectedDevices, jni.JniType.objectType, []).object);

  static final _id_getDevicesMatchingConnectionStates =
      jniAccessors.getMethodIDOf(_classRef,
          "getDevicesMatchingConnectionStates", "([I)Ljava/util/List;");

  /// from: public java.util.List<android.bluetooth.BluetoothDevice> getDevicesMatchingConnectionStates(int[] states)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Not supported - please use
  /// BluetoothManager\#getDevicesMatchingConnectionStates(int, int[])
  /// with BluetoothProfile\#GATT as first argument
  ///@throws UnsupportedOperationException
  jni.JniObject getDevicesMatchingConnectionStates(jni.JniObject states) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDevicesMatchingConnectionStates,
          jni.JniType.objectType,
          [states.reference]).object);
}
