// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../widget/EditText.dart" as edittext_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../view/inputmethod/ExtractedText.dart" as extractedtext_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.inputmethodservice.ExtractEditText
///
/// Specialization of EditText for showing and interacting with the
/// extracted text in a full-screen input method.
class ExtractEditText extends edittext_.EditText {
  static final _classRef =
      jniAccessors.getClassOf("android/inputmethodservice/ExtractEditText");
  ExtractEditText.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ExtractEditText(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ExtractEditText.ctor1(
      context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ExtractEditText.ctor2(context_.Context context,
      attributeset_.AttributeSet attrs, int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ExtractEditText.ctor3(context_.Context context,
      attributeset_.AttributeSet attrs, int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_startInternalChanges =
      jniAccessors.getMethodIDOf(_classRef, "startInternalChanges", "()V");

  /// from: public void startInternalChanges()
  ///
  /// Start making changes that will not be reported to the client.  That
  /// is, \#onSelectionChanged(int, int) will not result in sending
  /// the new selection to the client
  void startInternalChanges() => jniAccessors.callMethodWithArgs(
      reference, _id_startInternalChanges, jni.JniType.voidType, []).check();

  static final _id_finishInternalChanges =
      jniAccessors.getMethodIDOf(_classRef, "finishInternalChanges", "()V");

  /// from: public void finishInternalChanges()
  ///
  /// Finish making changes that will not be reported to the client.  That
  /// is, \#onSelectionChanged(int, int) will not result in sending
  /// the new selection to the client
  void finishInternalChanges() => jniAccessors.callMethodWithArgs(
      reference, _id_finishInternalChanges, jni.JniType.voidType, []).check();

  static final _id_setExtractedText1 = jniAccessors.getMethodIDOf(_classRef,
      "setExtractedText", "(Landroid/view/inputmethod/ExtractedText;)V");

  /// from: public void setExtractedText(android.view.inputmethod.ExtractedText text)
  ///
  /// Implement just to keep track of when we are setting text from the
  /// client (vs. seeing changes in ourself from the user).
  void setExtractedText1(extractedtext_.ExtractedText text) =>
      jniAccessors.callMethodWithArgs(reference, _id_setExtractedText1,
          jni.JniType.voidType, [text.reference]).check();

  static final _id_onSelectionChanged1 =
      jniAccessors.getMethodIDOf(_classRef, "onSelectionChanged", "(II)V");

  /// from: protected void onSelectionChanged(int selStart, int selEnd)
  ///
  /// Report to the underlying text editor about selection changes.
  void onSelectionChanged1(int selStart, int selEnd) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSelectionChanged1,
          jni.JniType.voidType, [selStart, selEnd]).check();

  static final _id_performClick1 =
      jniAccessors.getMethodIDOf(_classRef, "performClick", "()Z");

  /// from: public boolean performClick()
  ///
  /// Redirect clicks to the IME for handling there.  First allows any
  /// on click handler to run, though.
  bool performClick1() => jniAccessors.callMethodWithArgs(
      reference, _id_performClick1, jni.JniType.booleanType, []).boolean;

  static final _id_onTextContextMenuItem1 =
      jniAccessors.getMethodIDOf(_classRef, "onTextContextMenuItem", "(I)Z");

  /// from: public boolean onTextContextMenuItem(int id)
  bool onTextContextMenuItem1(int id) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onTextContextMenuItem1,
      jni.JniType.booleanType,
      [id]).boolean;

  static final _id_isInputMethodTarget1 =
      jniAccessors.getMethodIDOf(_classRef, "isInputMethodTarget", "()Z");

  /// from: public boolean isInputMethodTarget()
  ///
  /// We are always considered to be an input method target.
  bool isInputMethodTarget1() => jniAccessors.callMethodWithArgs(
      reference, _id_isInputMethodTarget1, jni.JniType.booleanType, []).boolean;

  static final _id_hasVerticalScrollBar =
      jniAccessors.getMethodIDOf(_classRef, "hasVerticalScrollBar", "()Z");

  /// from: public boolean hasVerticalScrollBar()
  ///
  /// Return true if the edit text is currently showing a scroll bar.
  bool hasVerticalScrollBar() => jniAccessors.callMethodWithArgs(
      reference, _id_hasVerticalScrollBar, jni.JniType.booleanType, []).boolean;

  static final _id_hasWindowFocus1 =
      jniAccessors.getMethodIDOf(_classRef, "hasWindowFocus", "()Z");

  /// from: public boolean hasWindowFocus()
  ///
  /// Pretend like the window this view is in always has focus, so its
  /// highlight and cursor will be displayed.
  bool hasWindowFocus1() => jniAccessors.callMethodWithArgs(
      reference, _id_hasWindowFocus1, jni.JniType.booleanType, []).boolean;

  static final _id_isFocused1 =
      jniAccessors.getMethodIDOf(_classRef, "isFocused", "()Z");

  /// from: public boolean isFocused()
  ///
  /// Pretend like this view always has focus, so its
  /// highlight and cursor will be displayed.
  bool isFocused1() => jniAccessors.callMethodWithArgs(
      reference, _id_isFocused1, jni.JniType.booleanType, []).boolean;

  static final _id_hasFocus1 =
      jniAccessors.getMethodIDOf(_classRef, "hasFocus", "()Z");

  /// from: public boolean hasFocus()
  ///
  /// Pretend like this view always has focus, so its
  /// highlight and cursor will be displayed.
  bool hasFocus1() => jniAccessors.callMethodWithArgs(
      reference, _id_hasFocus1, jni.JniType.booleanType, []).boolean;
}
