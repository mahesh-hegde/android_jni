// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "AbstractInputMethodService.dart" as abstractinputmethodservice_;

import "../content/res/Configuration.dart" as configuration_;

import "../view/LayoutInflater.dart" as layoutinflater_;

import "../app/Dialog.dart" as dialog_;

import "../view/inputmethod/InputBinding.dart" as inputbinding_;

import "../view/inputmethod/InputConnection.dart" as inputconnection_;

import "../view/inputmethod/EditorInfo.dart" as editorinfo_;

import "../view/Window.dart" as window_;

import "../view/inputmethod/InputMethodSubtype.dart" as inputmethodsubtype_;

import "../view/View.dart" as view_;

import "../view/inputmethod/ExtractedText.dart" as extractedtext_;

import "../graphics/Rect.dart" as rect_;

import "../view/inputmethod/CursorAnchorInfo.dart" as cursoranchorinfo_;

import "../view/KeyEvent.dart" as keyevent_;

import "../view/MotionEvent.dart" as motionevent_;

import "../os/Bundle.dart" as bundle_;

import "../graphics/Region.dart" as region_;

import "../os/IBinder.dart" as ibinder_;

import "../os/ResultReceiver.dart" as resultreceiver_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.inputmethodservice.InputMethodService
///
/// InputMethodService provides a standard implementation of an InputMethod,
/// which final implementations can derive from and customize.  See the
/// base class AbstractInputMethodService and the InputMethod
/// interface for more information on the basics of writing input methods.
///
/// In addition to the normal Service lifecycle methods, this class
/// introduces some new specific callbacks that most subclasses will want
/// to make use of:
///
/// <ul>
/// <li> \#onInitializeInterface() for user-interface initialization,
/// in particular to deal with configuration changes while the service is
/// running.
/// <li> \#onBindInput to find out about switching to a new client.
/// <li> \#onStartInput to deal with an input session starting with
/// the client.
/// <li> \#onCreateInputView(), \#onCreateCandidatesView(),
/// and \#onCreateExtractTextView() for non-demand generation of the UI.
/// <li> \#onStartInputView(EditorInfo, boolean) to deal with input
/// starting within the input area of the IME.
/// </ul>
///
/// An input method has significant discretion in how it goes about its
/// work: the android.inputmethodservice.InputMethodService provides
/// a basic framework for standard UI elements (input view, candidates view,
/// and running in fullscreen mode), but it is up to a particular implementor
/// to decide how to use them.  For example, one input method could implement
/// an input area with a keyboard, another could allow the user to draw text,
/// while a third could have no input area (and thus not be visible to the
/// user) but instead listen to audio and perform text to speech conversion.
///
///
/// In the implementation provided here, all of these elements are placed
/// together in a single window managed by the InputMethodService.  It will
/// execute callbacks as it needs information about them, and provides APIs for
/// programmatic control over them.  They layout of these elements is explicitly
/// defined:
///
///
/// <ul>
/// <li>The soft input view, if available, is placed at the bottom of the
/// screen.
/// <li>The candidates view, if currently shown, is placed above the soft
/// input view.
/// <li>If not running fullscreen, the application is moved or resized to be
/// above these views; if running fullscreen, the window will completely cover
/// the application and its top part will contain the extract text of what is
/// currently being edited by the application.
/// </ul>
///
///
/// <a name="SoftInputView"></a>
/// <h3>Soft Input View</h3>
///
/// Central to most input methods is the soft input view.  This is where most
/// user interaction occurs: pressing on soft keys, drawing characters, or
/// however else your input method wants to generate text.  Most implementations
/// will simply have their own view doing all of this work, and return a new
/// instance of it when \#onCreateInputView() is called.  At that point,
/// as long as the input view is visible, you will see user interaction in
/// that view and can call back on the InputMethodService to interact with the
/// application as appropriate.
///
///
/// There are some situations where you want to decide whether or not your
/// soft input view should be shown to the user.  This is done by implementing
/// the \#onEvaluateInputViewShown() to return true or false based on
/// whether it should be shown in the current environment.  If any of your
/// state has changed that may impact this, call
/// \#updateInputViewShown() to have it re-evaluated.  The default
/// implementation always shows the input view unless there is a hard
/// keyboard available, which is the appropriate behavior for most input
/// methods.
///
///
///
/// <a name="CandidatesView"></a>
/// <h3>Candidates View</h3>
///
/// Often while the user is generating raw text, an input method wants to
/// provide them with a list of possible interpretations of that text that can
/// be selected for use.  This is accomplished with the candidates view, and
/// like the soft input view you implement \#onCreateCandidatesView()
/// to instantiate your own view implementing your candidates UI.
///
///
/// Management of the candidates view is a little different than the input
/// view, because the candidates view tends to be more transient, being shown
/// only when there are possible candidates for the current text being entered
/// by the user.  To control whether the candidates view is shown, you use
/// \#setCandidatesViewShown(boolean).  Note that because the candidate
/// view tends to be shown and hidden a lot, it does not impact the application
/// UI in the same way as the soft input view: it will never cause application
/// windows to resize, only cause them to be panned if needed for the user to
/// see the current focus.
///
///
///
/// <a name="FullscreenMode"></a>
/// <h3>Fullscreen Mode</h3>
///
/// Sometimes your input method UI is too large to integrate with the
/// application UI, so you just want to take over the screen.  This is
/// accomplished by switching to full-screen mode, causing the input method
/// window to fill the entire screen and add its own "extracted text" editor
/// showing the user the text that is being typed.  Unlike the other UI elements,
/// there is a standard implementation for the extract editor that you should
/// not need to change.  The editor is placed at the top of the IME, above the
/// input and candidates views.
///
///
/// Similar to the input view, you control whether the IME is running in
/// fullscreen mode by implementing \#onEvaluateFullscreenMode()
/// to return true or false based on
/// whether it should be fullscreen in the current environment.  If any of your
/// state has changed that may impact this, call
/// \#updateFullscreenMode() to have it re-evaluated.  The default
/// implementation selects fullscreen mode when the screen is in a landscape
/// orientation, which is appropriate behavior for most input methods that have
/// a significant input area.
///
///
/// When in fullscreen mode, you have some special requirements because the
/// user can not see the application UI.  In particular, you should implement
/// \#onDisplayCompletions(CompletionInfo[]) to show completions
/// generated by your application, typically in your candidates view like you
/// would normally show candidates.
///
///
/// <a name="GeneratingText"></a>
/// <h3>Generating Text</h3>
///
/// The key part of an IME is of course generating text for the application.
/// This is done through calls to the
/// android.view.inputmethod.InputConnection interface to the
/// application, which can be retrieved from \#getCurrentInputConnection().
/// This interface allows you to generate raw key events or, if the target
/// supports it, directly edit in strings of candidates and committed text.
///
///
/// Information about what the target is expected and supports can be found
/// through the android.view.inputmethod.EditorInfo class, which is
/// retrieved with \#getCurrentInputEditorInfo() method.  The most
/// important part of this is android.view.inputmethod.EditorInfo\#inputType EditorInfo.inputType; in particular, if this is
/// android.view.inputmethod.EditorInfo\#TYPE_NULL EditorInfo.TYPE_NULL,
/// then the target does not support complex edits and you need to only deliver
/// raw key events to it.  An input method will also want to look at other
/// values here, to for example detect password mode, auto complete text views,
/// phone number entry, etc.
///
///
/// When the user switches between input targets, you will receive calls to
/// \#onFinishInput() and \#onStartInput(EditorInfo, boolean).
/// You can use these to reset and initialize your input state for the current
/// target.  For example, you will often want to clear any input state, and
/// update a soft keyboard to be appropriate for the new inputType.
///
///@attr ref android.R.styleable\#InputMethodService_imeFullscreenBackground
///@attr ref android.R.styleable\#InputMethodService_imeExtractEnterAnimation
///@attr ref android.R.styleable\#InputMethodService_imeExtractExitAnimation
class InputMethodService
    extends abstractinputmethodservice_.AbstractInputMethodService {
  static final _classRef =
      jniAccessors.getClassOf("android/inputmethodservice/InputMethodService");
  InputMethodService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int BACK_DISPOSITION_ADJUST_NOTHING
  ///
  /// Asks the system to not adjust the back button affordance even when the software keyboard is
  /// shown.
  ///
  /// This mode is useful for UI modes where IME's main soft input window is used for some
  /// supplemental UI, such as floating candidate window for languages such as Chinese and
  /// Japanese, where users expect the back button is, or at least looks to be, handled by the
  /// target application rather than the UI shown by the IME even while \#isInputViewShown()
  /// returns {@code true}.
  ///
  ///
  /// Note that KeyEvent\#KEYCODE_BACK events continue to be sent to
  /// \#onKeyDown(int, KeyEvent) even when this mode is specified. The default
  /// implementation of \#onKeyDown(int, KeyEvent) for KeyEvent\#KEYCODE_BACK does
  /// not take this mode into account.
  ///
  ///@see \#setBackDisposition(int)
  static const BACK_DISPOSITION_ADJUST_NOTHING = 3;

  /// from: static public final int BACK_DISPOSITION_DEFAULT
  ///
  /// Allows the system to optimize the back button affordance based on the presence of software
  /// keyboard.
  ///
  /// For instance, on devices that have navigation bar and software-rendered back button, the
  /// system may use a different icon while \#isInputViewShown() returns {@code true}, to
  /// indicate that the back button has "dismiss" affordance.
  ///
  ///
  /// Note that KeyEvent\#KEYCODE_BACK events continue to be sent to
  /// \#onKeyDown(int, KeyEvent) even when this mode is specified. The default
  /// implementation of \#onKeyDown(int, KeyEvent) for KeyEvent\#KEYCODE_BACK does
  /// not take this mode into account.
  ///
  ///
  /// For API level android.os.Build.VERSION_CODES\#O_MR1 and lower devices, this is the
  /// only mode you can safely specify without worrying about the compatibility.
  ///
  ///@see \#setBackDisposition(int)
  static const BACK_DISPOSITION_DEFAULT = 0;

  /// from: static public final int BACK_DISPOSITION_WILL_DISMISS
  ///
  /// Deprecated flag.
  ///
  /// To avoid compatibility issues, IME developers should not use this flag.
  ///
  ///@deprecated on android.os.Build.VERSION_CODES\#P and later devices, this flag is
  ///             handled as a synonym of \#BACK_DISPOSITION_DEFAULT. On
  ///             android.os.Build.VERSION_CODES\#O_MR1 and prior devices, expected behavior
  ///             of this mode had not been well defined. In AOSP implementation running on devices
  ///             that have navigation bar, specifying this flag could change the software back
  ///             button to "Dismiss" icon no matter whether the software keyboard is shown or not,
  ///             but there would be no easy way to restore the icon state even after IME lost the
  ///             connection to the application. To avoid user confusions, do not specify this mode
  ///             anyway
  ///@see \#setBackDisposition(int)
  static const BACK_DISPOSITION_WILL_DISMISS = 2;

  /// from: static public final int BACK_DISPOSITION_WILL_NOT_DISMISS
  ///
  /// Deprecated flag.
  ///
  /// To avoid compatibility issues, IME developers should not use this flag.
  ///
  ///@deprecated on android.os.Build.VERSION_CODES\#P and later devices, this flag is
  ///             handled as a synonym of \#BACK_DISPOSITION_DEFAULT. On
  ///             android.os.Build.VERSION_CODES\#O_MR1 and prior devices, expected behavior
  ///             of this mode had not been well defined. Most likely the end result would be the
  ///             same as \#BACK_DISPOSITION_DEFAULT. Either way it is not recommended to
  ///             use this mode
  ///@see \#setBackDisposition(int)
  static const BACK_DISPOSITION_WILL_NOT_DISMISS = 1;

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  InputMethodService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_setTheme1 =
      jniAccessors.getMethodIDOf(_classRef, "setTheme", "(I)V");

  /// from: public void setTheme(int theme)
  ///
  /// You can call this to customize the theme used by your IME's window.
  /// This theme should typically be one that derives from
  /// android.R.style\#Theme_InputMethod, which is the default theme
  /// you will get.  This must be set before \#onCreate, so you
  /// will typically call it in your constructor with the resource ID
  /// of your custom theme.
  void setTheme1(int theme) => jniAccessors.callMethodWithArgs(
      reference, _id_setTheme1, jni.JniType.voidType, [theme]).check();

  static final _id_enableHardwareAcceleration = jniAccessors.getMethodIDOf(
      _classRef, "enableHardwareAcceleration", "()Z");

  /// from: public boolean enableHardwareAcceleration()
  ///
  /// You can call this to try to enable accelerated drawing for your IME. This must be set before
  /// \#onCreate(), so you will typically call it in your constructor.  It is not always
  /// possible to use hardware accelerated drawing in an IME (for example on low-end devices that
  /// do not have the resources to support this), so the call {@code true} if it succeeds otherwise
  /// {@code false} if you will need to draw in software.  You must be able to handle either case.
  ///
  /// In API 21 and later, system may automatically enable hardware accelerated drawing for your
  /// IME on capable devices even if this method is not explicitly called. Make sure that your IME
  /// is able to handle either case.
  ///
  ///@return {@code true} if accelerated drawing is successfully enabled otherwise {@code false}.
  ///         On API 21 and later devices the return value is basically just a hint and your IME
  ///         does not need to change the behavior based on the it
  ///@deprecated Starting in API 21, hardware acceleration is always enabled on capable devices
  bool enableHardwareAcceleration() => jniAccessors.callMethodWithArgs(
      reference,
      _id_enableHardwareAcceleration,
      jni.JniType.booleanType, []).boolean;

  static final _id_onCreate1 =
      jniAccessors.getMethodIDOf(_classRef, "onCreate", "()V");

  /// from: public void onCreate()
  void onCreate1() => jniAccessors.callMethodWithArgs(
      reference, _id_onCreate1, jni.JniType.voidType, []).check();

  static final _id_onInitializeInterface =
      jniAccessors.getMethodIDOf(_classRef, "onInitializeInterface", "()V");

  /// from: public void onInitializeInterface()
  ///
  /// This is a hook that subclasses can use to perform initialization of
  /// their interface.  It is called for you prior to any of your UI objects
  /// being created, both after the service is first created and after a
  /// configuration change happens.
  void onInitializeInterface() => jniAccessors.callMethodWithArgs(
      reference, _id_onInitializeInterface, jni.JniType.voidType, []).check();

  static final _id_onDestroy1 =
      jniAccessors.getMethodIDOf(_classRef, "onDestroy", "()V");

  /// from: public void onDestroy()
  void onDestroy1() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroy1, jni.JniType.voidType, []).check();

  static final _id_onConfigurationChanged1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onConfigurationChanged",
      "(Landroid/content/res/Configuration;)V");

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  ///
  /// Take care of handling configuration changes.  Subclasses of
  /// InputMethodService generally don't need to deal directly with
  /// this on their own; the standard implementation here takes care of
  /// regenerating the input method UI as a result of the configuration
  /// change, so you can rely on your \#onCreateInputView and
  /// other methods being called as appropriate due to a configuration change.
  ///
  /// When a configuration change does happen,
  /// \#onInitializeInterface() is guaranteed to be called the next
  /// time prior to any of the other input or UI creation callbacks.  The
  /// following will be called immediately depending if appropriate for current
  /// state: \#onStartInput if input is active, and
  /// \#onCreateInputView and \#onStartInputView and related
  /// appropriate functions if the UI is displayed.
  void onConfigurationChanged1(configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConfigurationChanged1,
          jni.JniType.voidType, [newConfig.reference]).check();

  static final _id_onCreateInputMethodInterface = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateInputMethodInterface",
      "()Landroid/inputmethodservice/AbstractInputMethodService\$AbstractInputMethodImpl;");

  /// from: public android.inputmethodservice.AbstractInputMethodService.AbstractInputMethodImpl onCreateInputMethodInterface()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement to return our standard InputMethodImpl.  Subclasses
  /// can override to provide their own customized version.
  abstractinputmethodservice_.AbstractInputMethodService_AbstractInputMethodImpl
      onCreateInputMethodInterface() => abstractinputmethodservice_
              .AbstractInputMethodService_AbstractInputMethodImpl
          .fromRef(jniAccessors.callMethodWithArgs(
              reference,
              _id_onCreateInputMethodInterface,
              jni.JniType.objectType, []).object);

  static final _id_onCreateInputMethodSessionInterface = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateInputMethodSessionInterface",
      "()Landroid/inputmethodservice/AbstractInputMethodService\$AbstractInputMethodSessionImpl;");

  /// from: public android.inputmethodservice.AbstractInputMethodService.AbstractInputMethodSessionImpl onCreateInputMethodSessionInterface()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement to return our standard InputMethodSessionImpl.  Subclasses
  /// can override to provide their own customized version.
  abstractinputmethodservice_
          .AbstractInputMethodService_AbstractInputMethodSessionImpl
      onCreateInputMethodSessionInterface() => abstractinputmethodservice_
              .AbstractInputMethodService_AbstractInputMethodSessionImpl
          .fromRef(jniAccessors.callMethodWithArgs(
              reference,
              _id_onCreateInputMethodSessionInterface,
              jni.JniType.objectType, []).object);

  static final _id_getLayoutInflater = jniAccessors.getMethodIDOf(
      _classRef, "getLayoutInflater", "()Landroid/view/LayoutInflater;");

  /// from: public android.view.LayoutInflater getLayoutInflater()
  /// The returned object must be deleted after use, by calling the `delete` method.
  layoutinflater_.LayoutInflater getLayoutInflater() =>
      layoutinflater_.LayoutInflater.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLayoutInflater, jni.JniType.objectType, []).object);

  static final _id_getWindow = jniAccessors.getMethodIDOf(
      _classRef, "getWindow", "()Landroid/app/Dialog;");

  /// from: public android.app.Dialog getWindow()
  /// The returned object must be deleted after use, by calling the `delete` method.
  dialog_.Dialog getWindow() =>
      dialog_.Dialog.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWindow, jni.JniType.objectType, []).object);

  static final _id_setBackDisposition =
      jniAccessors.getMethodIDOf(_classRef, "setBackDisposition", "(I)V");

  /// from: public void setBackDisposition(int disposition)
  ///
  /// Sets the disposition mode that indicates the expected affordance for the back button.
  ///
  /// Keep in mind that specifying this flag does not change the the default behavior of
  /// \#onKeyDown(int, KeyEvent).  It is IME developers' responsibility for making sure that
  /// their custom implementation of \#onKeyDown(int, KeyEvent) is consistent with the mode
  /// specified to this API.
  ///
  ///@see \#getBackDisposition()
  ///@param disposition disposition mode to be set
  ///
  /// Value is android.inputmethodservice.InputMethodService\#BACK_DISPOSITION_DEFAULT, android.inputmethodservice.InputMethodService\#BACK_DISPOSITION_WILL_NOT_DISMISS, android.inputmethodservice.InputMethodService\#BACK_DISPOSITION_WILL_DISMISS, or android.inputmethodservice.InputMethodService\#BACK_DISPOSITION_ADJUST_NOTHING
  void setBackDisposition(int disposition) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setBackDisposition,
      jni.JniType.voidType,
      [disposition]).check();

  static final _id_getBackDisposition =
      jniAccessors.getMethodIDOf(_classRef, "getBackDisposition", "()I");

  /// from: public int getBackDisposition()
  ///
  /// Retrieves the current disposition mode that indicates the expected back button affordance.
  ///@see \#setBackDisposition(int)
  ///@return currently selected disposition mode
  ///
  /// Value is android.inputmethodservice.InputMethodService\#BACK_DISPOSITION_DEFAULT, android.inputmethodservice.InputMethodService\#BACK_DISPOSITION_WILL_NOT_DISMISS, android.inputmethodservice.InputMethodService\#BACK_DISPOSITION_WILL_DISMISS, or android.inputmethodservice.InputMethodService\#BACK_DISPOSITION_ADJUST_NOTHING
  int getBackDisposition() => jniAccessors.callMethodWithArgs(
      reference, _id_getBackDisposition, jni.JniType.intType, []).integer;

  static final _id_getMaxWidth =
      jniAccessors.getMethodIDOf(_classRef, "getMaxWidth", "()I");

  /// from: public int getMaxWidth()
  ///
  /// Return the maximum width, in pixels, available the input method.
  /// Input methods are positioned at the bottom of the screen and, unless
  /// running in fullscreen, will generally want to be as short as possible
  /// so should compute their height based on their contents.  However, they
  /// can stretch as much as needed horizontally.  The function returns to
  /// you the maximum amount of space available horizontally, which you can
  /// use if needed for UI placement.
  ///
  /// In many cases this is not needed, you can just rely on the normal
  /// view layout mechanisms to position your views within the full horizontal
  /// space given to the input method.
  ///
  /// Note that this value can change dynamically, in particular when the
  /// screen orientation changes.
  int getMaxWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxWidth, jni.JniType.intType, []).integer;

  static final _id_getCurrentInputBinding = jniAccessors.getMethodIDOf(
      _classRef,
      "getCurrentInputBinding",
      "()Landroid/view/inputmethod/InputBinding;");

  /// from: public android.view.inputmethod.InputBinding getCurrentInputBinding()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the currently active InputBinding for the input method, or
  /// null if there is none.
  inputbinding_.InputBinding getCurrentInputBinding() =>
      inputbinding_.InputBinding.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCurrentInputBinding,
          jni.JniType.objectType, []).object);

  static final _id_getCurrentInputConnection = jniAccessors.getMethodIDOf(
      _classRef,
      "getCurrentInputConnection",
      "()Landroid/view/inputmethod/InputConnection;");

  /// from: public android.view.inputmethod.InputConnection getCurrentInputConnection()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the currently active InputConnection that is bound to
  /// the input method, or null if there is none.
  inputconnection_.InputConnection getCurrentInputConnection() =>
      inputconnection_.InputConnection.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCurrentInputConnection,
          jni.JniType.objectType, []).object);

  static final _id_switchToPreviousInputMethod = jniAccessors.getMethodIDOf(
      _classRef, "switchToPreviousInputMethod", "()Z");

  /// from: public final boolean switchToPreviousInputMethod()
  ///
  /// Force switch to the last used input method and subtype. If the last input method didn't have
  /// any subtypes, the framework will simply switch to the last input method with no subtype
  /// specified.
  ///@return true if the current input method and subtype was successfully switched to the last
  /// used input method and subtype.
  bool switchToPreviousInputMethod() => jniAccessors.callMethodWithArgs(
      reference,
      _id_switchToPreviousInputMethod,
      jni.JniType.booleanType, []).boolean;

  static final _id_switchToNextInputMethod =
      jniAccessors.getMethodIDOf(_classRef, "switchToNextInputMethod", "(Z)Z");

  /// from: public final boolean switchToNextInputMethod(boolean onlyCurrentIme)
  ///
  /// Force switch to the next input method and subtype. If there is no IME enabled except
  /// current IME and subtype, do nothing.
  ///@param onlyCurrentIme if true, the framework will find the next subtype which
  /// belongs to the current IME
  ///@return true if the current input method and subtype was successfully switched to the next
  /// input method and subtype.
  bool switchToNextInputMethod(bool onlyCurrentIme) =>
      jniAccessors.callMethodWithArgs(reference, _id_switchToNextInputMethod,
          jni.JniType.booleanType, [onlyCurrentIme]).boolean;

  static final _id_shouldOfferSwitchingToNextInputMethod = jniAccessors
      .getMethodIDOf(_classRef, "shouldOfferSwitchingToNextInputMethod", "()Z");

  /// from: public final boolean shouldOfferSwitchingToNextInputMethod()
  ///
  /// Returns true if the current IME needs to offer the users ways to switch to a next input
  /// method (e.g.&nbsp;a globe key.).
  /// When an IME sets supportsSwitchingToNextInputMethod and this method returns true,
  /// the IME has to offer ways to to invoke \#switchToNextInputMethod accordingly.
  ///  Note that the system determines the most appropriate next input method
  /// and subtype in order to provide the consistent user experience in switching
  /// between IMEs and subtypes.
  bool shouldOfferSwitchingToNextInputMethod() =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_shouldOfferSwitchingToNextInputMethod,
          jni.JniType.booleanType, []).boolean;

  static final _id_getCurrentInputStarted =
      jniAccessors.getMethodIDOf(_classRef, "getCurrentInputStarted", "()Z");

  /// from: public boolean getCurrentInputStarted()
  bool getCurrentInputStarted() => jniAccessors.callMethodWithArgs(reference,
      _id_getCurrentInputStarted, jni.JniType.booleanType, []).boolean;

  static final _id_getCurrentInputEditorInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "getCurrentInputEditorInfo",
      "()Landroid/view/inputmethod/EditorInfo;");

  /// from: public android.view.inputmethod.EditorInfo getCurrentInputEditorInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  editorinfo_.EditorInfo getCurrentInputEditorInfo() =>
      editorinfo_.EditorInfo.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCurrentInputEditorInfo, jni.JniType.objectType, []).object);

  static final _id_updateFullscreenMode =
      jniAccessors.getMethodIDOf(_classRef, "updateFullscreenMode", "()V");

  /// from: public void updateFullscreenMode()
  ///
  /// Re-evaluate whether the input method should be running in fullscreen
  /// mode, and update its UI if this has changed since the last time it
  /// was evaluated.  This will call \#onEvaluateFullscreenMode() to
  /// determine whether it should currently run in fullscreen mode.  You
  /// can use \#isFullscreenMode() to determine if the input method
  /// is currently running in fullscreen mode.
  void updateFullscreenMode() => jniAccessors.callMethodWithArgs(
      reference, _id_updateFullscreenMode, jni.JniType.voidType, []).check();

  static final _id_onConfigureWindow = jniAccessors.getMethodIDOf(
      _classRef, "onConfigureWindow", "(Landroid/view/Window;ZZ)V");

  /// from: public void onConfigureWindow(android.view.Window win, boolean isFullscreen, boolean isCandidatesOnly)
  ///
  /// Update the given window's parameters for the given mode.  This is called
  /// when the window is first displayed and each time the fullscreen or
  /// candidates only mode changes.
  ///
  /// The default implementation makes the layout for the window
  /// MATCH_PARENT x MATCH_PARENT when in fullscreen mode, and
  /// MATCH_PARENT x WRAP_CONTENT when in non-fullscreen mode.
  ///@param win The input method's window.
  ///@param isFullscreen If true, the window is running in fullscreen mode
  /// and intended to cover the entire application display.
  ///@param isCandidatesOnly If true, the window is only showing the
  /// candidates view and none of the rest of its UI.  This is mutually
  /// exclusive with fullscreen mode.
  void onConfigureWindow(
          window_.Window win, bool isFullscreen, bool isCandidatesOnly) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onConfigureWindow,
          jni.JniType.voidType,
          [win.reference, isFullscreen, isCandidatesOnly]).check();

  static final _id_isFullscreenMode =
      jniAccessors.getMethodIDOf(_classRef, "isFullscreenMode", "()Z");

  /// from: public boolean isFullscreenMode()
  ///
  /// Return whether the input method is _currently_ running in
  /// fullscreen mode.  This is the mode that was last determined and
  /// applied by \#updateFullscreenMode().
  bool isFullscreenMode() => jniAccessors.callMethodWithArgs(
      reference, _id_isFullscreenMode, jni.JniType.booleanType, []).boolean;

  static final _id_onEvaluateFullscreenMode =
      jniAccessors.getMethodIDOf(_classRef, "onEvaluateFullscreenMode", "()Z");

  /// from: public boolean onEvaluateFullscreenMode()
  ///
  /// Override this to control when the input method should run in
  /// fullscreen mode.  The default implementation runs in fullsceen only
  /// when the screen is in landscape mode.  If you change what
  /// this returns, you will need to call \#updateFullscreenMode()
  /// yourself whenever the returned value may have changed to have it
  /// re-evaluated and applied.
  bool onEvaluateFullscreenMode() => jniAccessors.callMethodWithArgs(reference,
      _id_onEvaluateFullscreenMode, jni.JniType.booleanType, []).boolean;

  static final _id_setExtractViewShown =
      jniAccessors.getMethodIDOf(_classRef, "setExtractViewShown", "(Z)V");

  /// from: public void setExtractViewShown(boolean shown)
  ///
  /// Controls the visibility of the extracted text area.  This only applies
  /// when the input method is in fullscreen mode, and thus showing extracted
  /// text.  When false, the extracted text will not be shown, allowing some
  /// of the application to be seen behind.  This is normally set for you
  /// by \#onUpdateExtractingVisibility.  This controls the visibility
  /// of both the extracted text and candidate view; the latter since it is
  /// not useful if there is no text to see.
  void setExtractViewShown(bool shown) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setExtractViewShown,
      jni.JniType.voidType,
      [shown]).check();

  static final _id_isExtractViewShown =
      jniAccessors.getMethodIDOf(_classRef, "isExtractViewShown", "()Z");

  /// from: public boolean isExtractViewShown()
  ///
  /// Return whether the fullscreen extract view is shown.  This will only
  /// return true if \#isFullscreenMode() returns true, and in that
  /// case its value depends on the last call to
  /// \#setExtractViewShown(boolean).  This effectively lets you
  /// determine if the application window is entirely covered (when this
  /// returns true) or if some part of it may be shown (if this returns
  /// false, though if \#isFullscreenMode() returns true in that case
  /// then it is probably only a sliver of the application).
  bool isExtractViewShown() => jniAccessors.callMethodWithArgs(
      reference, _id_isExtractViewShown, jni.JniType.booleanType, []).boolean;

  static final _id_onComputeInsets = jniAccessors.getMethodIDOf(
      _classRef,
      "onComputeInsets",
      "(Landroid/inputmethodservice/InputMethodService\$Insets;)V");

  /// from: public void onComputeInsets(android.inputmethodservice.InputMethodService.Insets outInsets)
  ///
  /// Compute the interesting insets into your UI.  The default implementation
  /// uses the top of the candidates frame for the visible insets, and the
  /// top of the input frame for the content insets.  The default touchable
  /// insets are Insets\#TOUCHABLE_INSETS_VISIBLE.
  ///
  /// Note that this method is not called when
  /// \#isExtractViewShown returns true, since
  /// in that case the application is left as-is behind the input method and
  /// not impacted by anything in its UI.
  ///@param outInsets Fill in with the current UI insets.
  void onComputeInsets(InputMethodService_Insets outInsets) =>
      jniAccessors.callMethodWithArgs(reference, _id_onComputeInsets,
          jni.JniType.voidType, [outInsets.reference]).check();

  static final _id_updateInputViewShown =
      jniAccessors.getMethodIDOf(_classRef, "updateInputViewShown", "()V");

  /// from: public void updateInputViewShown()
  ///
  /// Re-evaluate whether the soft input area should currently be shown, and
  /// update its UI if this has changed since the last time it
  /// was evaluated.  This will call \#onEvaluateInputViewShown() to
  /// determine whether the input view should currently be shown.  You
  /// can use \#isInputViewShown() to determine if the input view
  /// is currently shown.
  void updateInputViewShown() => jniAccessors.callMethodWithArgs(
      reference, _id_updateInputViewShown, jni.JniType.voidType, []).check();

  static final _id_isShowInputRequested =
      jniAccessors.getMethodIDOf(_classRef, "isShowInputRequested", "()Z");

  /// from: public boolean isShowInputRequested()
  ///
  /// Returns true if we have been asked to show our input view.
  bool isShowInputRequested() => jniAccessors.callMethodWithArgs(
      reference, _id_isShowInputRequested, jni.JniType.booleanType, []).boolean;

  static final _id_isInputViewShown =
      jniAccessors.getMethodIDOf(_classRef, "isInputViewShown", "()Z");

  /// from: public boolean isInputViewShown()
  ///
  /// Return whether the soft input view is _currently_ shown to the
  /// user.  This is the state that was last determined and
  /// applied by \#updateInputViewShown().
  bool isInputViewShown() => jniAccessors.callMethodWithArgs(
      reference, _id_isInputViewShown, jni.JniType.booleanType, []).boolean;

  static final _id_onEvaluateInputViewShown =
      jniAccessors.getMethodIDOf(_classRef, "onEvaluateInputViewShown", "()Z");

  /// from: public boolean onEvaluateInputViewShown()
  ///
  /// Override this to control when the soft input area should be shown to the user.  The default
  /// implementation returns {@code false} when there is no hard keyboard or the keyboard is hidden
  /// unless the user shows an intention to use software keyboard.  If you change what this
  /// returns, you will need to call \#updateInputViewShown() yourself whenever the returned
  /// value may have changed to have it re-evaluated and applied.
  ///
  /// When you override this method, it is recommended to call
  /// {@code super.onEvaluateInputViewShown()} and return {@code true} when {@code true} is
  /// returned.
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  bool onEvaluateInputViewShown() => jniAccessors.callMethodWithArgs(reference,
      _id_onEvaluateInputViewShown, jni.JniType.booleanType, []).boolean;

  static final _id_setCandidatesViewShown =
      jniAccessors.getMethodIDOf(_classRef, "setCandidatesViewShown", "(Z)V");

  /// from: public void setCandidatesViewShown(boolean shown)
  ///
  /// Controls the visibility of the candidates display area.  By default
  /// it is hidden.
  void setCandidatesViewShown(bool shown) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setCandidatesViewShown,
      jni.JniType.voidType,
      [shown]).check();

  static final _id_getCandidatesHiddenVisibility = jniAccessors.getMethodIDOf(
      _classRef, "getCandidatesHiddenVisibility", "()I");

  /// from: public int getCandidatesHiddenVisibility()
  ///
  /// Returns the visibility mode (either View\#INVISIBLE View.INVISIBLE
  /// or View\#GONE View.GONE) of the candidates view when it is not
  /// shown.  The default implementation returns GONE when
  /// \#isExtractViewShown returns true,
  /// otherwise VISIBLE.  Be careful if you change this to return GONE in
  /// other situations -- if showing or hiding the candidates view causes
  /// your window to resize, this can cause temporary drawing artifacts as
  /// the resize takes place.
  int getCandidatesHiddenVisibility() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getCandidatesHiddenVisibility,
      jni.JniType.intType, []).integer;

  static final _id_showStatusIcon =
      jniAccessors.getMethodIDOf(_classRef, "showStatusIcon", "(I)V");

  /// from: public void showStatusIcon(int iconResId)
  void showStatusIcon(int iconResId) => jniAccessors.callMethodWithArgs(
      reference, _id_showStatusIcon, jni.JniType.voidType, [iconResId]).check();

  static final _id_hideStatusIcon =
      jniAccessors.getMethodIDOf(_classRef, "hideStatusIcon", "()V");

  /// from: public void hideStatusIcon()
  void hideStatusIcon() => jniAccessors.callMethodWithArgs(
      reference, _id_hideStatusIcon, jni.JniType.voidType, []).check();

  static final _id_switchInputMethod = jniAccessors.getMethodIDOf(
      _classRef, "switchInputMethod", "(Ljava/lang/String;)V");

  /// from: public void switchInputMethod(java.lang.String id)
  ///
  /// Force switch to a new input method, as identified by <var>id</var>.  This
  /// input method will be destroyed, and the requested one started on the
  /// current input field.
  ///@param id Unique identifier of the new input method to start.
  void switchInputMethod(jni.JniString id) => jniAccessors.callMethodWithArgs(
      reference,
      _id_switchInputMethod,
      jni.JniType.voidType,
      [id.reference]).check();

  static final _id_switchInputMethod1 = jniAccessors.getMethodIDOf(
      _classRef,
      "switchInputMethod",
      "(Ljava/lang/String;Landroid/view/inputmethod/InputMethodSubtype;)V");

  /// from: public final void switchInputMethod(java.lang.String id, android.view.inputmethod.InputMethodSubtype subtype)
  ///
  /// Force switch to a new input method, as identified by {@code id}.  This
  /// input method will be destroyed, and the requested one started on the
  /// current input field.
  ///@param id Unique identifier of the new input method to start.
  ///@param subtype The new subtype of the new input method to be switched to.
  void switchInputMethod1(
          jni.JniString id, inputmethodsubtype_.InputMethodSubtype subtype) =>
      jniAccessors.callMethodWithArgs(reference, _id_switchInputMethod1,
          jni.JniType.voidType, [id.reference, subtype.reference]).check();

  static final _id_setExtractView = jniAccessors.getMethodIDOf(
      _classRef, "setExtractView", "(Landroid/view/View;)V");

  /// from: public void setExtractView(android.view.View view)
  void setExtractView(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setExtractView,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_setCandidatesView = jniAccessors.getMethodIDOf(
      _classRef, "setCandidatesView", "(Landroid/view/View;)V");

  /// from: public void setCandidatesView(android.view.View view)
  ///
  /// Replaces the current candidates view with a new one.  You only need to
  /// call this when dynamically changing the view; normally, you should
  /// implement \#onCreateCandidatesView() and create your view when
  /// first needed by the input method.
  void setCandidatesView(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setCandidatesView,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_setInputView = jniAccessors.getMethodIDOf(
      _classRef, "setInputView", "(Landroid/view/View;)V");

  /// from: public void setInputView(android.view.View view)
  ///
  /// Replaces the current input view with a new one.  You only need to
  /// call this when dynamically changing the view; normally, you should
  /// implement \#onCreateInputView() and create your view when
  /// first needed by the input method.
  void setInputView(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setInputView,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_onCreateExtractTextView = jniAccessors.getMethodIDOf(
      _classRef, "onCreateExtractTextView", "()Landroid/view/View;");

  /// from: public android.view.View onCreateExtractTextView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by the framework to create the layout for showing extacted text.
  /// Only called when in fullscreen mode.  The returned view hierarchy must
  /// have an ExtractEditText whose ID is
  /// android.R.id\#inputExtractEditText.
  view_.View onCreateExtractTextView() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onCreateExtractTextView, jni.JniType.objectType, []).object);

  static final _id_onCreateCandidatesView = jniAccessors.getMethodIDOf(
      _classRef, "onCreateCandidatesView", "()Landroid/view/View;");

  /// from: public android.view.View onCreateCandidatesView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create and return the view hierarchy used to show candidates.  This will
  /// be called once, when the candidates are first displayed.  You can return
  /// null to have no candidates view; the default implementation returns null.
  ///
  /// To control when the candidates view is displayed, use
  /// \#setCandidatesViewShown(boolean).
  /// To change the candidates view after the first one is created by this
  /// function, use \#setCandidatesView(View).
  view_.View onCreateCandidatesView() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onCreateCandidatesView, jni.JniType.objectType, []).object);

  static final _id_onCreateInputView = jniAccessors.getMethodIDOf(
      _classRef, "onCreateInputView", "()Landroid/view/View;");

  /// from: public android.view.View onCreateInputView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create and return the view hierarchy used for the input area (such as
  /// a soft keyboard).  This will be called once, when the input area is
  /// first displayed.  You can return null to have no input area; the default
  /// implementation returns null.
  ///
  /// To control when the input view is displayed, implement
  /// \#onEvaluateInputViewShown().
  /// To change the input view after the first one is created by this
  /// function, use \#setInputView(View).
  view_.View onCreateInputView() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onCreateInputView, jni.JniType.objectType, []).object);

  static final _id_onStartInputView = jniAccessors.getMethodIDOf(_classRef,
      "onStartInputView", "(Landroid/view/inputmethod/EditorInfo;Z)V");

  /// from: public void onStartInputView(android.view.inputmethod.EditorInfo info, boolean restarting)
  ///
  /// Called when the input view is being shown and input has started on
  /// a new editor.  This will always be called after \#onStartInput,
  /// allowing you to do your general setup there and just view-specific
  /// setup here.  You are guaranteed that \#onCreateInputView() will
  /// have been called some time before this function is called.
  ///@param info Description of the type of text being edited.
  ///@param restarting Set to true if we are restarting input on the
  /// same text field as before.
  void onStartInputView(editorinfo_.EditorInfo info, bool restarting) =>
      jniAccessors.callMethodWithArgs(reference, _id_onStartInputView,
          jni.JniType.voidType, [info.reference, restarting]).check();

  static final _id_onFinishInputView =
      jniAccessors.getMethodIDOf(_classRef, "onFinishInputView", "(Z)V");

  /// from: public void onFinishInputView(boolean finishingInput)
  ///
  /// Called when the input view is being hidden from the user.  This will
  /// be called either prior to hiding the window, or prior to switching to
  /// another target for editing.
  ///
  /// The default
  /// implementation uses the InputConnection to clear any active composing
  /// text; you can override this (not calling the base class implementation)
  /// to perform whatever behavior you would like.
  ///@param finishingInput If true, \#onFinishInput will be
  /// called immediately after.
  void onFinishInputView(bool finishingInput) =>
      jniAccessors.callMethodWithArgs(reference, _id_onFinishInputView,
          jni.JniType.voidType, [finishingInput]).check();

  static final _id_onStartCandidatesView = jniAccessors.getMethodIDOf(_classRef,
      "onStartCandidatesView", "(Landroid/view/inputmethod/EditorInfo;Z)V");

  /// from: public void onStartCandidatesView(android.view.inputmethod.EditorInfo info, boolean restarting)
  ///
  /// Called when only the candidates view has been shown for showing
  /// processing as the user enters text through a hard keyboard.
  /// This will always be called after \#onStartInput,
  /// allowing you to do your general setup there and just view-specific
  /// setup here.  You are guaranteed that \#onCreateCandidatesView()
  /// will have been called some time before this function is called.
  ///
  /// Note that this will _not_ be called when the input method
  /// is running in full editing mode, and thus receiving
  /// \#onStartInputView to initiate that operation.  This is only
  /// for the case when candidates are being shown while the input method
  /// editor is hidden but wants to show its candidates UI as text is
  /// entered through some other mechanism.
  ///@param info Description of the type of text being edited.
  ///@param restarting Set to true if we are restarting input on the
  /// same text field as before.
  void onStartCandidatesView(editorinfo_.EditorInfo info, bool restarting) =>
      jniAccessors.callMethodWithArgs(reference, _id_onStartCandidatesView,
          jni.JniType.voidType, [info.reference, restarting]).check();

  static final _id_onFinishCandidatesView =
      jniAccessors.getMethodIDOf(_classRef, "onFinishCandidatesView", "(Z)V");

  /// from: public void onFinishCandidatesView(boolean finishingInput)
  ///
  /// Called when the candidates view is being hidden from the user.  This will
  /// be called either prior to hiding the window, or prior to switching to
  /// another target for editing.
  ///
  /// The default
  /// implementation uses the InputConnection to clear any active composing
  /// text; you can override this (not calling the base class implementation)
  /// to perform whatever behavior you would like.
  ///@param finishingInput If true, \#onFinishInput will be
  /// called immediately after.
  void onFinishCandidatesView(bool finishingInput) =>
      jniAccessors.callMethodWithArgs(reference, _id_onFinishCandidatesView,
          jni.JniType.voidType, [finishingInput]).check();

  static final _id_onShowInputRequested =
      jniAccessors.getMethodIDOf(_classRef, "onShowInputRequested", "(IZ)Z");

  /// from: public boolean onShowInputRequested(int flags, boolean configChange)
  ///
  /// The system has decided that it may be time to show your input method.
  /// This is called due to a corresponding call to your
  /// InputMethod\#showSoftInput InputMethod.showSoftInput()
  /// method.  The default implementation uses
  /// \#onEvaluateInputViewShown(), \#onEvaluateFullscreenMode(),
  /// and the current configuration to decide whether the input view should
  /// be shown at this point.
  ///@param flags Provides additional information about the show request,
  /// as per InputMethod\#showSoftInput InputMethod.showSoftInput().
  ///@param configChange This is true if we are re-showing due to a
  /// configuration change.
  ///@return Returns true to indicate that the window should be shown.
  bool onShowInputRequested(int flags, bool configChange) =>
      jniAccessors.callMethodWithArgs(reference, _id_onShowInputRequested,
          jni.JniType.booleanType, [flags, configChange]).boolean;

  static final _id_showWindow =
      jniAccessors.getMethodIDOf(_classRef, "showWindow", "(Z)V");

  /// from: public void showWindow(boolean showInput)
  void showWindow(bool showInput) => jniAccessors.callMethodWithArgs(
      reference, _id_showWindow, jni.JniType.voidType, [showInput]).check();

  static final _id_hideWindow =
      jniAccessors.getMethodIDOf(_classRef, "hideWindow", "()V");

  /// from: public void hideWindow()
  void hideWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_hideWindow, jni.JniType.voidType, []).check();

  static final _id_onWindowShown =
      jniAccessors.getMethodIDOf(_classRef, "onWindowShown", "()V");

  /// from: public void onWindowShown()
  ///
  /// Called immediately before the input method window is shown to the user.
  /// You could override this to prepare for the window to be shown
  /// (update view structure etc).
  void onWindowShown() => jniAccessors.callMethodWithArgs(
      reference, _id_onWindowShown, jni.JniType.voidType, []).check();

  static final _id_onWindowHidden =
      jniAccessors.getMethodIDOf(_classRef, "onWindowHidden", "()V");

  /// from: public void onWindowHidden()
  ///
  /// Called when the input method window has been hidden from the user,
  /// after previously being visible.
  void onWindowHidden() => jniAccessors.callMethodWithArgs(
      reference, _id_onWindowHidden, jni.JniType.voidType, []).check();

  static final _id_onBindInput =
      jniAccessors.getMethodIDOf(_classRef, "onBindInput", "()V");

  /// from: public void onBindInput()
  ///
  /// Called when a new client has bound to the input method.  This
  /// may be followed by a series of \#onStartInput(EditorInfo, boolean)
  /// and \#onFinishInput() calls as the user navigates through its
  /// UI.  Upon this call you know that \#getCurrentInputBinding
  /// and \#getCurrentInputConnection return valid objects.
  void onBindInput() => jniAccessors.callMethodWithArgs(
      reference, _id_onBindInput, jni.JniType.voidType, []).check();

  static final _id_onUnbindInput =
      jniAccessors.getMethodIDOf(_classRef, "onUnbindInput", "()V");

  /// from: public void onUnbindInput()
  ///
  /// Called when the previous bound client is no longer associated
  /// with the input method.  After returning \#getCurrentInputBinding
  /// and \#getCurrentInputConnection will no longer return
  /// valid objects.
  void onUnbindInput() => jniAccessors.callMethodWithArgs(
      reference, _id_onUnbindInput, jni.JniType.voidType, []).check();

  static final _id_onStartInput = jniAccessors.getMethodIDOf(
      _classRef, "onStartInput", "(Landroid/view/inputmethod/EditorInfo;Z)V");

  /// from: public void onStartInput(android.view.inputmethod.EditorInfo attribute, boolean restarting)
  ///
  /// Called to inform the input method that text input has started in an
  /// editor.  You should use this callback to initialize the state of your
  /// input to match the state of the editor given to it.
  ///@param attribute The attributes of the editor that input is starting
  /// in.
  ///@param restarting Set to true if input is restarting in the same
  /// editor such as because the application has changed the text in
  /// the editor.  Otherwise will be false, indicating this is a new
  /// session with the editor.
  void onStartInput(editorinfo_.EditorInfo attribute, bool restarting) =>
      jniAccessors.callMethodWithArgs(reference, _id_onStartInput,
          jni.JniType.voidType, [attribute.reference, restarting]).check();

  static final _id_onFinishInput =
      jniAccessors.getMethodIDOf(_classRef, "onFinishInput", "()V");

  /// from: public void onFinishInput()
  ///
  /// Called to inform the input method that text input has finished in
  /// the last editor.  At this point there may be a call to
  /// \#onStartInput(EditorInfo, boolean) to perform input in a
  /// new editor, or the input method may be left idle.  This method is
  /// _not_ called when input restarts in the same editor.
  ///
  /// The default
  /// implementation uses the InputConnection to clear any active composing
  /// text; you can override this (not calling the base class implementation)
  /// to perform whatever behavior you would like.
  void onFinishInput() => jniAccessors.callMethodWithArgs(
      reference, _id_onFinishInput, jni.JniType.voidType, []).check();

  static final _id_onDisplayCompletions = jniAccessors.getMethodIDOf(_classRef,
      "onDisplayCompletions", "([Landroid/view/inputmethod/CompletionInfo;)V");

  /// from: public void onDisplayCompletions(android.view.inputmethod.CompletionInfo[] completions)
  ///
  /// Called when the application has reported auto-completion candidates that
  /// it would like to have the input method displayed.  Typically these are
  /// only used when an input method is running in full-screen mode, since
  /// otherwise the user can see and interact with the pop-up window of
  /// completions shown by the application.
  ///
  /// The default implementation here does nothing.
  void onDisplayCompletions(jni.JniObject completions) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDisplayCompletions,
          jni.JniType.voidType, [completions.reference]).check();

  static final _id_onUpdateExtractedText = jniAccessors.getMethodIDOf(_classRef,
      "onUpdateExtractedText", "(ILandroid/view/inputmethod/ExtractedText;)V");

  /// from: public void onUpdateExtractedText(int token, android.view.inputmethod.ExtractedText text)
  ///
  /// Called when the application has reported new extracted text to be shown
  /// due to changes in its current text state.  The default implementation
  /// here places the new text in the extract edit text, when the input
  /// method is running in fullscreen mode.
  void onUpdateExtractedText(int token, extractedtext_.ExtractedText text) =>
      jniAccessors.callMethodWithArgs(reference, _id_onUpdateExtractedText,
          jni.JniType.voidType, [token, text.reference]).check();

  static final _id_onUpdateSelection =
      jniAccessors.getMethodIDOf(_classRef, "onUpdateSelection", "(IIIIII)V");

  /// from: public void onUpdateSelection(int oldSelStart, int oldSelEnd, int newSelStart, int newSelEnd, int candidatesStart, int candidatesEnd)
  ///
  /// Called when the application has reported a new selection region of
  /// the text.  This is called whether or not the input method has requested
  /// extracted text updates, although if so it will not receive this call
  /// if the extracted text has changed as well.
  ///
  /// Be careful about changing the text in reaction to this call with
  /// methods such as setComposingText, commitText or
  /// deleteSurroundingText. If the cursor moves as a result, this method
  /// will be called again, which may result in an infinite loop.
  ///
  /// The default implementation takes care of updating the cursor in
  /// the extract text, if it is being shown.
  void onUpdateSelection(int oldSelStart, int oldSelEnd, int newSelStart,
          int newSelEnd, int candidatesStart, int candidatesEnd) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onUpdateSelection, jni.JniType.voidType, [
        oldSelStart,
        oldSelEnd,
        newSelStart,
        newSelEnd,
        candidatesStart,
        candidatesEnd
      ]).check();

  static final _id_onViewClicked =
      jniAccessors.getMethodIDOf(_classRef, "onViewClicked", "(Z)V");

  /// from: public void onViewClicked(boolean focusChanged)
  ///
  /// Called when the user tapped or clicked a text view.
  /// IMEs can't rely on this method being called because this was not part of the original IME
  /// protocol, so applications with custom text editing written before this method appeared will
  /// not call to inform the IME of this interaction.
  ///@param focusChanged true if the user changed the focused view by this click.
  void onViewClicked(bool focusChanged) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onViewClicked,
      jni.JniType.voidType,
      [focusChanged]).check();

  static final _id_onUpdateCursor = jniAccessors.getMethodIDOf(
      _classRef, "onUpdateCursor", "(Landroid/graphics/Rect;)V");

  /// from: public void onUpdateCursor(android.graphics.Rect newCursor)
  ///
  /// Called when the application has reported a new location of its text
  /// cursor.  This is only called if explicitly requested by the input method.
  /// The default implementation does nothing.
  ///@deprecated Use {\#link onUpdateCursorAnchorInfo(CursorAnchorInfo)} instead.
  void onUpdateCursor(rect_.Rect newCursor) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onUpdateCursor,
      jni.JniType.voidType,
      [newCursor.reference]).check();

  static final _id_onUpdateCursorAnchorInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "onUpdateCursorAnchorInfo",
      "(Landroid/view/inputmethod/CursorAnchorInfo;)V");

  /// from: public void onUpdateCursorAnchorInfo(android.view.inputmethod.CursorAnchorInfo cursorAnchorInfo)
  ///
  /// Called when the application has reported a new location of its text insertion point and
  /// characters in the composition string.  This is only called if explicitly requested by the
  /// input method. The default implementation does nothing.
  ///@param cursorAnchorInfo The positional information of the text insertion point and the
  /// composition string.
  void onUpdateCursorAnchorInfo(
          cursoranchorinfo_.CursorAnchorInfo cursorAnchorInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_onUpdateCursorAnchorInfo,
          jni.JniType.voidType, [cursorAnchorInfo.reference]).check();

  static final _id_requestHideSelf =
      jniAccessors.getMethodIDOf(_classRef, "requestHideSelf", "(I)V");

  /// from: public void requestHideSelf(int flags)
  ///
  /// Close this input method's soft input area, removing it from the display.
  ///
  /// The input method will continue running, but the user can no longer use it to generate input
  /// by touching the screen.
  ///@see InputMethodManager\#HIDE_IMPLICIT_ONLY
  ///@see InputMethodManager\#HIDE_NOT_ALWAYS
  ///@param flags Provides additional operating flags.
  void requestHideSelf(int flags) => jniAccessors.callMethodWithArgs(
      reference, _id_requestHideSelf, jni.JniType.voidType, [flags]).check();

  static final _id_requestShowSelf =
      jniAccessors.getMethodIDOf(_classRef, "requestShowSelf", "(I)V");

  /// from: public final void requestShowSelf(int flags)
  ///
  /// Show the input method's soft input area, so the user sees the input method window and can
  /// interact with it.
  ///@see InputMethodManager\#SHOW_IMPLICIT
  ///@see InputMethodManager\#SHOW_FORCED
  ///@param flags Provides additional operating flags.
  void requestShowSelf(int flags) => jniAccessors.callMethodWithArgs(
      reference, _id_requestShowSelf, jni.JniType.voidType, [flags]).check();

  static final _id_onKeyDown = jniAccessors.getMethodIDOf(
      _classRef, "onKeyDown", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  ///
  /// Called back when a KeyEvent is forwarded from the target application.
  ///
  /// The default implementation intercepts KeyEvent\#KEYCODE_BACK if the IME is
  /// currently shown , to possibly hide it when the key goes up (if not canceled or long pressed).
  /// In addition, in fullscreen mode only, it will consume DPAD movement events to move the cursor
  /// in the extracted text view, not allowing them to perform navigation in the underlying
  /// application.
  ///
  ///
  /// The default implementation does not take flags specified to
  /// \#setBackDisposition(int) into account, even on API version
  /// android.os.Build.VERSION_CODES\#P and later devices.  IME developers are responsible
  /// for making sure that their special handling for KeyEvent\#KEYCODE_BACK are consistent
  /// with the flag they specified to \#setBackDisposition(int).
  ///
  ///@param keyCode The value in {@code event.getKeyCode()}
  ///@param event Description of the key event
  ///@return {@code true} if the event is consumed by the IME and the application no longer needs
  ///         to consume it.  Return {@code false} when the event should be handled as if the IME
  ///         had not seen the event at all.
  bool onKeyDown(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyDown,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyLongPress = jniAccessors.getMethodIDOf(
      _classRef, "onKeyLongPress", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyLongPress(int keyCode, android.view.KeyEvent event)
  ///
  /// Default implementation of KeyEvent.Callback\#onKeyLongPress(int, KeyEvent) KeyEvent.Callback.onKeyLongPress(): always returns false (doesn't handle
  /// the event).
  bool onKeyLongPress(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyLongPress,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyMultiple = jniAccessors.getMethodIDOf(
      _classRef, "onKeyMultiple", "(IILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyMultiple(int keyCode, int count, android.view.KeyEvent event)
  ///
  /// Override this to intercept special key multiple events before they are
  /// processed by the
  /// application.  If you return true, the application will not itself
  /// process the event.  If you return false, the normal application processing
  /// will occur as if the IME had not seen the event at all.
  ///
  /// The default implementation always returns false, except when
  /// in fullscreen mode, where it will consume DPAD movement
  /// events to move the cursor in the extracted text view, not allowing
  /// them to perform navigation in the underlying application.
  bool onKeyMultiple(int keyCode, int count, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyMultiple,
          jni.JniType.booleanType, [keyCode, count, event.reference]).boolean;

  static final _id_onKeyUp = jniAccessors.getMethodIDOf(
      _classRef, "onKeyUp", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyUp(int keyCode, android.view.KeyEvent event)
  ///
  /// Override this to intercept key up events before they are processed by the
  /// application.  If you return true, the application will not itself
  /// process the event.  If you return false, the normal application processing
  /// will occur as if the IME had not seen the event at all.
  ///
  /// The default implementation intercepts KeyEvent\#KEYCODE_BACK KeyEvent.KEYCODE_BACK to hide the current IME UI if it is shown.  In
  /// addition, in fullscreen mode only, it will consume DPAD movement
  /// events to move the cursor in the extracted text view, not allowing
  /// them to perform navigation in the underlying application.
  bool onKeyUp(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyUp,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onTrackballEvent = jniAccessors.getMethodIDOf(
      _classRef, "onTrackballEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTrackballEvent(android.view.MotionEvent event)
  ///
  /// Override this to intercept trackball motion events before they are
  /// processed by the application.
  /// If you return true, the application will not itself process the event.
  /// If you return false, the normal application processing will occur as if
  /// the IME had not seen the event at all.
  bool onTrackballEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTrackballEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onGenericMotionEvent = jniAccessors.getMethodIDOf(
      _classRef, "onGenericMotionEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent event)
  ///
  /// Override this to intercept generic motion events before they are
  /// processed by the application.
  /// If you return true, the application will not itself process the event.
  /// If you return false, the normal application processing will occur as if
  /// the IME had not seen the event at all.
  bool onGenericMotionEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onGenericMotionEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onAppPrivateCommand = jniAccessors.getMethodIDOf(_classRef,
      "onAppPrivateCommand", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void onAppPrivateCommand(java.lang.String action, android.os.Bundle data)
  void onAppPrivateCommand(jni.JniString action, bundle_.Bundle data) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAppPrivateCommand,
          jni.JniType.voidType, [action.reference, data.reference]).check();

  static final _id_sendDownUpKeyEvents =
      jniAccessors.getMethodIDOf(_classRef, "sendDownUpKeyEvents", "(I)V");

  /// from: public void sendDownUpKeyEvents(int keyEventCode)
  ///
  /// Send the given key event code (as defined by KeyEvent) to the
  /// current input connection is a key down + key up event pair.  The sent
  /// events have KeyEvent\#FLAG_SOFT_KEYBOARD KeyEvent.FLAG_SOFT_KEYBOARD
  /// set, so that the recipient can identify them as coming from a software
  /// input method, and
  /// KeyEvent\#FLAG_KEEP_TOUCH_MODE KeyEvent.FLAG_KEEP_TOUCH_MODE, so
  /// that they don't impact the current touch mode of the UI.
  ///
  /// Note that it's discouraged to send such key events in normal operation;
  /// this is mainly for use with android.text.InputType\#TYPE_NULL type
  /// text fields, or for non-rich input methods. A reasonably capable software
  /// input method should use the
  /// android.view.inputmethod.InputConnection\#commitText family of methods
  /// to send text to an application, rather than sending key events.
  ///
  ///@param keyEventCode The raw key code to send, as defined by
  /// KeyEvent.
  void sendDownUpKeyEvents(int keyEventCode) => jniAccessors.callMethodWithArgs(
      reference,
      _id_sendDownUpKeyEvents,
      jni.JniType.voidType,
      [keyEventCode]).check();

  static final _id_sendDefaultEditorAction =
      jniAccessors.getMethodIDOf(_classRef, "sendDefaultEditorAction", "(Z)Z");

  /// from: public boolean sendDefaultEditorAction(boolean fromEnterKey)
  ///
  /// Ask the input target to execute its default action via
  /// InputConnection\#performEditorAction InputConnection.performEditorAction().
  ///@param fromEnterKey If true, this will be executed as if the user had
  /// pressed an enter key on the keyboard, that is it will _not_
  /// be done if the editor has set EditorInfo\#IME_FLAG_NO_ENTER_ACTION EditorInfo.IME_FLAG_NO_ENTER_ACTION.  If false, the action will be
  /// sent regardless of how the editor has set that flag.
  ///@return Returns a boolean indicating whether an action has been sent.
  /// If false, either the editor did not specify a default action or it
  /// does not want an action from the enter key.  If true, the action was
  /// sent (or there was no input connection at all).
  bool sendDefaultEditorAction(bool fromEnterKey) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendDefaultEditorAction,
          jni.JniType.booleanType, [fromEnterKey]).boolean;

  static final _id_sendKeyChar =
      jniAccessors.getMethodIDOf(_classRef, "sendKeyChar", "(C)V");

  /// from: public void sendKeyChar(char charCode)
  ///
  /// Send the given UTF-16 character to the current input connection.  Most
  /// characters will be delivered simply by calling
  /// InputConnection\#commitText InputConnection.commitText() with
  /// the character; some, however, may be handled different.  In particular,
  /// the enter character ('\n') will either be delivered as an action code
  /// or a raw key event, as appropriate.  Consider this as a convenience
  /// method for IMEs that do not have a full implementation of actions; a
  /// fully complying IME will decide of the right action for each event and
  /// will likely never call this method except maybe to handle events coming
  /// from an actual hardware keyboard.
  ///@param charCode The UTF-16 character code to send.
  void sendKeyChar(int charCode) => jniAccessors.callMethodWithArgs(
      reference, _id_sendKeyChar, jni.JniType.voidType, [charCode]).check();

  static final _id_onExtractedSelectionChanged = jniAccessors.getMethodIDOf(
      _classRef, "onExtractedSelectionChanged", "(II)V");

  /// from: public void onExtractedSelectionChanged(int start, int end)
  ///
  /// This is called when the user has moved the cursor in the extracted
  /// text view, when running in fullsreen mode.  The default implementation
  /// performs the corresponding selection change on the underlying text
  /// editor.
  void onExtractedSelectionChanged(int start, int end) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onExtractedSelectionChanged,
          jni.JniType.voidType,
          [start, end]).check();

  static final _id_onExtractedTextClicked =
      jniAccessors.getMethodIDOf(_classRef, "onExtractedTextClicked", "()V");

  /// from: public void onExtractedTextClicked()
  ///
  /// This is called when the user has clicked on the extracted text view,
  /// when running in fullscreen mode.  The default implementation hides
  /// the candidates view when this happens, but only if the extracted text
  /// editor has a vertical scroll bar because its text doesn't fit.
  /// Re-implement this to provide whatever behavior you want.
  void onExtractedTextClicked() => jniAccessors.callMethodWithArgs(
      reference, _id_onExtractedTextClicked, jni.JniType.voidType, []).check();

  static final _id_onExtractedCursorMovement = jniAccessors.getMethodIDOf(
      _classRef, "onExtractedCursorMovement", "(II)V");

  /// from: public void onExtractedCursorMovement(int dx, int dy)
  ///
  /// This is called when the user has performed a cursor movement in the
  /// extracted text view, when it is running in fullscreen mode.  The default
  /// implementation hides the candidates view when a vertical movement
  /// happens, but only if the extracted text editor has a vertical scroll bar
  /// because its text doesn't fit.
  /// Re-implement this to provide whatever behavior you want.
  ///@param dx The amount of cursor movement in the x dimension.
  ///@param dy The amount of cursor movement in the y dimension.
  void onExtractedCursorMovement(int dx, int dy) =>
      jniAccessors.callMethodWithArgs(reference, _id_onExtractedCursorMovement,
          jni.JniType.voidType, [dx, dy]).check();

  static final _id_onExtractTextContextMenuItem = jniAccessors.getMethodIDOf(
      _classRef, "onExtractTextContextMenuItem", "(I)Z");

  /// from: public boolean onExtractTextContextMenuItem(int id)
  ///
  /// This is called when the user has selected a context menu item from the
  /// extracted text view, when running in fullscreen mode.  The default
  /// implementation sends this action to the current InputConnection's
  /// InputConnection\#performContextMenuAction(int), for it
  /// to be processed in underlying "real" editor.  Re-implement this to
  /// provide whatever behavior you want.
  bool onExtractTextContextMenuItem(int id) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onExtractTextContextMenuItem,
      jni.JniType.booleanType,
      [id]).boolean;

  static final _id_getTextForImeAction = jniAccessors.getMethodIDOf(
      _classRef, "getTextForImeAction", "(I)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getTextForImeAction(int imeOptions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return text that can be used as a button label for the given
  /// EditorInfo\#imeOptions EditorInfo.imeOptions.  Returns null
  /// if there is no action requested.  Note that there is no guarantee that
  /// the returned text will be relatively short, so you probably do not
  /// want to use it as text on a soft keyboard key label.
  ///@param imeOptions The value from EditorInfo\#imeOptions EditorInfo.imeOptions.
  ///@return Returns a label to use, or null if there is no action.
  jni.JniObject getTextForImeAction(int imeOptions) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getTextForImeAction,
          jni.JniType.objectType,
          [imeOptions]).object);

  static final _id_onUpdateExtractingVisibility = jniAccessors.getMethodIDOf(
      _classRef,
      "onUpdateExtractingVisibility",
      "(Landroid/view/inputmethod/EditorInfo;)V");

  /// from: public void onUpdateExtractingVisibility(android.view.inputmethod.EditorInfo ei)
  ///
  /// Called when the fullscreen-mode extracting editor info has changed,
  /// to determine whether the extracting (extract text and candidates) portion
  /// of the UI should be shown.  The standard implementation hides or shows
  /// the extract area depending on whether it makes sense for the
  /// current editor.  In particular, a InputType\#TYPE_NULL
  /// input type or EditorInfo\#IME_FLAG_NO_EXTRACT_UI flag will
  /// turn off the extract area since there is no text to be shown.
  void onUpdateExtractingVisibility(editorinfo_.EditorInfo ei) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onUpdateExtractingVisibility,
          jni.JniType.voidType,
          [ei.reference]).check();

  static final _id_onUpdateExtractingViews = jniAccessors.getMethodIDOf(
      _classRef,
      "onUpdateExtractingViews",
      "(Landroid/view/inputmethod/EditorInfo;)V");

  /// from: public void onUpdateExtractingViews(android.view.inputmethod.EditorInfo ei)
  ///
  /// Called when the fullscreen-mode extracting editor info has changed,
  /// to update the state of its UI such as the action buttons shown.
  /// You do not need to deal with this if you are using the standard
  /// full screen extract UI.  If replacing it, you will need to re-implement
  /// this to put the appropriate action button in your own UI and handle it,
  /// and perform any other changes.
  ///
  /// The standard implementation turns on or off its accessory area
  /// depending on whether there is an action button, and hides or shows
  /// the entire extract area depending on whether it makes sense for the
  /// current editor.  In particular, a InputType\#TYPE_NULL or
  /// InputType\#TYPE_TEXT_VARIATION_FILTER input type will turn off the
  /// extract area since there is no text to be shown.
  void onUpdateExtractingViews(editorinfo_.EditorInfo ei) =>
      jniAccessors.callMethodWithArgs(reference, _id_onUpdateExtractingViews,
          jni.JniType.voidType, [ei.reference]).check();

  static final _id_onExtractingInputChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onExtractingInputChanged",
      "(Landroid/view/inputmethod/EditorInfo;)V");

  /// from: public void onExtractingInputChanged(android.view.inputmethod.EditorInfo ei)
  ///
  /// This is called when, while currently displayed in extract mode, the
  /// current input target changes.  The default implementation will
  /// auto-hide the IME if the new target is not a full editor, since this
  /// can be a confusing experience for the user.
  void onExtractingInputChanged(editorinfo_.EditorInfo ei) =>
      jniAccessors.callMethodWithArgs(reference, _id_onExtractingInputChanged,
          jni.JniType.voidType, [ei.reference]).check();

  static final _id_onCurrentInputMethodSubtypeChanged =
      jniAccessors.getMethodIDOf(
          _classRef,
          "onCurrentInputMethodSubtypeChanged",
          "(Landroid/view/inputmethod/InputMethodSubtype;)V");

  /// from: protected void onCurrentInputMethodSubtypeChanged(android.view.inputmethod.InputMethodSubtype newSubtype)
  ///
  /// Called when the subtype was changed.
  ///@param newSubtype the subtype which is being changed to.
  void onCurrentInputMethodSubtypeChanged(
          inputmethodsubtype_.InputMethodSubtype newSubtype) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCurrentInputMethodSubtypeChanged,
          jni.JniType.voidType,
          [newSubtype.reference]).check();

  static final _id_getInputMethodWindowRecommendedHeight = jniAccessors
      .getMethodIDOf(_classRef, "getInputMethodWindowRecommendedHeight", "()I");

  /// from: public int getInputMethodWindowRecommendedHeight()
  ///
  /// @return The recommended height of the input method window.
  /// An IME author can get the last input method's height as the recommended height
  /// by calling this in
  /// android.inputmethodservice.InputMethodService\#onStartInputView(EditorInfo, boolean).
  /// If you don't need to use a predefined fixed height, you can avoid the window-resizing of IME
  /// switching by using this value as a visible inset height. It's efficient for the smooth
  /// transition between different IMEs. However, note that this may return 0 (or possibly
  /// unexpectedly low height). You should thus avoid relying on the return value of this method
  /// all the time. Please make sure to use a reasonable height for the IME.
  int getInputMethodWindowRecommendedHeight() =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getInputMethodWindowRecommendedHeight,
          jni.JniType.intType, []).integer;

  static final _id_dump = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: protected void dump(java.io.FileDescriptor fd, java.io.PrintWriter fout, java.lang.String[] args)
  ///
  /// Performs a dump of the InputMethodService's internal state.  Override
  /// to add your own information to the dump.
  void dump(jni.JniObject fd, jni.JniObject fout, jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(reference, _id_dump, jni.JniType.voidType,
          [fd.reference, fout.reference, args.reference]).check();
}

/// from: android.inputmethodservice.InputMethodService$Insets
///
/// Information about where interesting parts of the input method UI appear.
class InputMethodService_Insets extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/inputmethodservice/InputMethodService\$Insets");
  InputMethodService_Insets.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int TOUCHABLE_INSETS_CONTENT
  ///
  /// Option for \#touchableInsets: the area inside of
  /// the content insets can be touched.
  static const TOUCHABLE_INSETS_CONTENT = 1;

  /// from: static public final int TOUCHABLE_INSETS_FRAME
  ///
  /// Option for \#touchableInsets: the entire window frame
  /// can be touched.
  static const TOUCHABLE_INSETS_FRAME = 0;

  /// from: static public final int TOUCHABLE_INSETS_REGION
  ///
  /// Option for \#touchableInsets: the region specified by
  /// \#touchableRegion can be touched.
  static const TOUCHABLE_INSETS_REGION = 3;

  /// from: static public final int TOUCHABLE_INSETS_VISIBLE
  ///
  /// Option for \#touchableInsets: the area inside of
  /// the visible insets can be touched.
  static const TOUCHABLE_INSETS_VISIBLE = 2;

  static final _id_contentTopInsets =
      jniAccessors.getFieldIDOf(_classRef, "contentTopInsets", "I");

  /// from: public int contentTopInsets
  ///
  /// This is the top part of the UI that is the main content.  It is
  /// used to determine the basic space needed, to resize/pan the
  /// application behind.  It is assumed that this inset does not
  /// change very much, since any change will cause a full resize/pan
  /// of the application behind.  This value is relative to the top edge
  /// of the input method window.
  int get contentTopInsets => jniAccessors
      .getField(reference, _id_contentTopInsets, jni.JniType.intType)
      .integer;

  /// from: public int contentTopInsets
  ///
  /// This is the top part of the UI that is the main content.  It is
  /// used to determine the basic space needed, to resize/pan the
  /// application behind.  It is assumed that this inset does not
  /// change very much, since any change will cause a full resize/pan
  /// of the application behind.  This value is relative to the top edge
  /// of the input method window.
  set contentTopInsets(int value) =>
      jniEnv.SetIntField(reference, _id_contentTopInsets, value);

  static final _id_touchableInsets =
      jniAccessors.getFieldIDOf(_classRef, "touchableInsets", "I");

  /// from: public int touchableInsets
  ///
  /// Determine which area of the window is touchable by the user.  May
  /// be one of: \#TOUCHABLE_INSETS_FRAME,
  /// \#TOUCHABLE_INSETS_CONTENT, \#TOUCHABLE_INSETS_VISIBLE,
  /// or \#TOUCHABLE_INSETS_REGION.
  int get touchableInsets => jniAccessors
      .getField(reference, _id_touchableInsets, jni.JniType.intType)
      .integer;

  /// from: public int touchableInsets
  ///
  /// Determine which area of the window is touchable by the user.  May
  /// be one of: \#TOUCHABLE_INSETS_FRAME,
  /// \#TOUCHABLE_INSETS_CONTENT, \#TOUCHABLE_INSETS_VISIBLE,
  /// or \#TOUCHABLE_INSETS_REGION.
  set touchableInsets(int value) =>
      jniEnv.SetIntField(reference, _id_touchableInsets, value);

  static final _id_touchableRegion = jniAccessors.getFieldIDOf(
      _classRef, "touchableRegion", "Landroid/graphics/Region;");

  /// from: public final android.graphics.Region touchableRegion
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This is the region of the UI that is touchable.  It is used when
  /// \#touchableInsets is set to \#TOUCHABLE_INSETS_REGION.
  /// The region should be specified relative to the origin of the window frame.
  region_.Region get touchableRegion => region_.Region.fromRef(jniAccessors
      .getField(reference, _id_touchableRegion, jni.JniType.objectType)
      .object);

  static final _id_visibleTopInsets =
      jniAccessors.getFieldIDOf(_classRef, "visibleTopInsets", "I");

  /// from: public int visibleTopInsets
  ///
  /// This is the top part of the UI that is visibly covering the
  /// application behind it.  This provides finer-grained control over
  /// visibility, allowing you to change it relatively frequently (such
  /// as hiding or showing candidates) without disrupting the underlying
  /// UI too much.  For example, this will never resize the application
  /// UI, will only pan if needed to make the current focus visible, and
  /// will not aggressively move the pan position when this changes unless
  /// needed to make the focus visible.  This value is relative to the top edge
  /// of the input method window.
  int get visibleTopInsets => jniAccessors
      .getField(reference, _id_visibleTopInsets, jni.JniType.intType)
      .integer;

  /// from: public int visibleTopInsets
  ///
  /// This is the top part of the UI that is visibly covering the
  /// application behind it.  This provides finer-grained control over
  /// visibility, allowing you to change it relatively frequently (such
  /// as hiding or showing candidates) without disrupting the underlying
  /// UI too much.  For example, this will never resize the application
  /// UI, will only pan if needed to make the current focus visible, and
  /// will not aggressively move the pan position when this changes unless
  /// needed to make the focus visible.  This value is relative to the top edge
  /// of the input method window.
  set visibleTopInsets(int value) =>
      jniEnv.SetIntField(reference, _id_visibleTopInsets, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  InputMethodService_Insets()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.inputmethodservice.InputMethodService$InputMethodSessionImpl
///
/// Concrete implementation of
/// AbstractInputMethodService.AbstractInputMethodSessionImpl that provides
/// all of the standard behavior for an input method session.
class InputMethodService_InputMethodSessionImpl
    extends abstractinputmethodservice_
        .AbstractInputMethodService_AbstractInputMethodSessionImpl {
  static final _classRef = jniAccessors.getClassOf(
      "android/inputmethodservice/InputMethodService\$InputMethodSessionImpl");
  InputMethodService_InputMethodSessionImpl.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  InputMethodService_InputMethodSessionImpl()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_finishInput =
      jniAccessors.getMethodIDOf(_classRef, "finishInput", "()V");

  /// from: public void finishInput()
  void finishInput() => jniAccessors.callMethodWithArgs(
      reference, _id_finishInput, jni.JniType.voidType, []).check();

  static final _id_displayCompletions = jniAccessors.getMethodIDOf(_classRef,
      "displayCompletions", "([Landroid/view/inputmethod/CompletionInfo;)V");

  /// from: public void displayCompletions(android.view.inputmethod.CompletionInfo[] completions)
  ///
  /// Call InputMethodService\#onDisplayCompletions InputMethodService.onDisplayCompletions().
  void displayCompletions(jni.JniObject completions) =>
      jniAccessors.callMethodWithArgs(reference, _id_displayCompletions,
          jni.JniType.voidType, [completions.reference]).check();

  static final _id_updateExtractedText = jniAccessors.getMethodIDOf(_classRef,
      "updateExtractedText", "(ILandroid/view/inputmethod/ExtractedText;)V");

  /// from: public void updateExtractedText(int token, android.view.inputmethod.ExtractedText text)
  ///
  /// Call InputMethodService\#onUpdateExtractedText InputMethodService.onUpdateExtractedText().
  void updateExtractedText(int token, extractedtext_.ExtractedText text) =>
      jniAccessors.callMethodWithArgs(reference, _id_updateExtractedText,
          jni.JniType.voidType, [token, text.reference]).check();

  static final _id_updateSelection =
      jniAccessors.getMethodIDOf(_classRef, "updateSelection", "(IIIIII)V");

  /// from: public void updateSelection(int oldSelStart, int oldSelEnd, int newSelStart, int newSelEnd, int candidatesStart, int candidatesEnd)
  ///
  /// Call InputMethodService\#onUpdateSelection InputMethodService.onUpdateSelection().
  void updateSelection(int oldSelStart, int oldSelEnd, int newSelStart,
          int newSelEnd, int candidatesStart, int candidatesEnd) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_updateSelection, jni.JniType.voidType, [
        oldSelStart,
        oldSelEnd,
        newSelStart,
        newSelEnd,
        candidatesStart,
        candidatesEnd
      ]).check();

  static final _id_viewClicked =
      jniAccessors.getMethodIDOf(_classRef, "viewClicked", "(Z)V");

  /// from: public void viewClicked(boolean focusChanged)
  void viewClicked(bool focusChanged) => jniAccessors.callMethodWithArgs(
      reference, _id_viewClicked, jni.JniType.voidType, [focusChanged]).check();

  static final _id_updateCursor = jniAccessors.getMethodIDOf(
      _classRef, "updateCursor", "(Landroid/graphics/Rect;)V");

  /// from: public void updateCursor(android.graphics.Rect newCursor)
  ///
  /// Call InputMethodService\#onUpdateCursor InputMethodService.onUpdateCursor().
  void updateCursor(rect_.Rect newCursor) => jniAccessors.callMethodWithArgs(
      reference,
      _id_updateCursor,
      jni.JniType.voidType,
      [newCursor.reference]).check();

  static final _id_appPrivateCommand = jniAccessors.getMethodIDOf(_classRef,
      "appPrivateCommand", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void appPrivateCommand(java.lang.String action, android.os.Bundle data)
  ///
  /// Call InputMethodService\#onAppPrivateCommand InputMethodService.onAppPrivateCommand().
  void appPrivateCommand(jni.JniString action, bundle_.Bundle data) =>
      jniAccessors.callMethodWithArgs(reference, _id_appPrivateCommand,
          jni.JniType.voidType, [action.reference, data.reference]).check();

  static final _id_toggleSoftInput =
      jniAccessors.getMethodIDOf(_classRef, "toggleSoftInput", "(II)V");

  /// from: public void toggleSoftInput(int showFlags, int hideFlags)
  ///
  ///
  void toggleSoftInput(int showFlags, int hideFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_toggleSoftInput,
          jni.JniType.voidType, [showFlags, hideFlags]).check();

  static final _id_updateCursorAnchorInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "updateCursorAnchorInfo",
      "(Landroid/view/inputmethod/CursorAnchorInfo;)V");

  /// from: public void updateCursorAnchorInfo(android.view.inputmethod.CursorAnchorInfo info)
  ///
  /// Call InputMethodService\#onUpdateCursorAnchorInfo InputMethodService.onUpdateCursorAnchorInfo().
  void updateCursorAnchorInfo(cursoranchorinfo_.CursorAnchorInfo info) =>
      jniAccessors.callMethodWithArgs(reference, _id_updateCursorAnchorInfo,
          jni.JniType.voidType, [info.reference]).check();
}

/// from: android.inputmethodservice.InputMethodService$InputMethodImpl
///
/// Concrete implementation of
/// AbstractInputMethodService.AbstractInputMethodImpl that provides
/// all of the standard behavior for an input method.
class InputMethodService_InputMethodImpl extends abstractinputmethodservice_
    .AbstractInputMethodService_AbstractInputMethodImpl {
  static final _classRef = jniAccessors.getClassOf(
      "android/inputmethodservice/InputMethodService\$InputMethodImpl");
  InputMethodService_InputMethodImpl.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  InputMethodService_InputMethodImpl()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_attachToken = jniAccessors.getMethodIDOf(
      _classRef, "attachToken", "(Landroid/os/IBinder;)V");

  /// from: public void attachToken(android.os.IBinder token)
  ///
  /// {@inheritDoc}
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  void attachToken(ibinder_.IBinder token) => jniAccessors.callMethodWithArgs(
      reference,
      _id_attachToken,
      jni.JniType.voidType,
      [token.reference]).check();

  static final _id_bindInput = jniAccessors.getMethodIDOf(
      _classRef, "bindInput", "(Landroid/view/inputmethod/InputBinding;)V");

  /// from: public void bindInput(android.view.inputmethod.InputBinding binding)
  ///
  /// {@inheritDoc}
  ///
  /// Calls InputMethodService\#onBindInput() when done.
  ///
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  void bindInput(inputbinding_.InputBinding binding) =>
      jniAccessors.callMethodWithArgs(reference, _id_bindInput,
          jni.JniType.voidType, [binding.reference]).check();

  static final _id_unbindInput =
      jniAccessors.getMethodIDOf(_classRef, "unbindInput", "()V");

  /// from: public void unbindInput()
  ///
  /// {@inheritDoc}
  ///
  /// Calls InputMethodService\#onUnbindInput() when done.
  ///
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  void unbindInput() => jniAccessors.callMethodWithArgs(
      reference, _id_unbindInput, jni.JniType.voidType, []).check();

  static final _id_startInput = jniAccessors.getMethodIDOf(
      _classRef,
      "startInput",
      "(Landroid/view/inputmethod/InputConnection;Landroid/view/inputmethod/EditorInfo;)V");

  /// from: public void startInput(android.view.inputmethod.InputConnection ic, android.view.inputmethod.EditorInfo attribute)
  ///
  /// {@inheritDoc}
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  void startInput(inputconnection_.InputConnection ic,
          editorinfo_.EditorInfo attribute) =>
      jniAccessors.callMethodWithArgs(reference, _id_startInput,
          jni.JniType.voidType, [ic.reference, attribute.reference]).check();

  static final _id_restartInput = jniAccessors.getMethodIDOf(
      _classRef,
      "restartInput",
      "(Landroid/view/inputmethod/InputConnection;Landroid/view/inputmethod/EditorInfo;)V");

  /// from: public void restartInput(android.view.inputmethod.InputConnection ic, android.view.inputmethod.EditorInfo attribute)
  ///
  /// {@inheritDoc}
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  void restartInput(inputconnection_.InputConnection ic,
          editorinfo_.EditorInfo attribute) =>
      jniAccessors.callMethodWithArgs(reference, _id_restartInput,
          jni.JniType.voidType, [ic.reference, attribute.reference]).check();

  static final _id_hideSoftInput = jniAccessors.getMethodIDOf(
      _classRef, "hideSoftInput", "(ILandroid/os/ResultReceiver;)V");

  /// from: public void hideSoftInput(int flags, android.os.ResultReceiver resultReceiver)
  ///
  /// {@inheritDoc}
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  void hideSoftInput(
          int flags, resultreceiver_.ResultReceiver resultReceiver) =>
      jniAccessors.callMethodWithArgs(reference, _id_hideSoftInput,
          jni.JniType.voidType, [flags, resultReceiver.reference]).check();

  static final _id_showSoftInput = jniAccessors.getMethodIDOf(
      _classRef, "showSoftInput", "(ILandroid/os/ResultReceiver;)V");

  /// from: public void showSoftInput(int flags, android.os.ResultReceiver resultReceiver)
  ///
  /// {@inheritDoc}
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  void showSoftInput(
          int flags, resultreceiver_.ResultReceiver resultReceiver) =>
      jniAccessors.callMethodWithArgs(reference, _id_showSoftInput,
          jni.JniType.voidType, [flags, resultReceiver.reference]).check();

  static final _id_changeInputMethodSubtype = jniAccessors.getMethodIDOf(
      _classRef,
      "changeInputMethodSubtype",
      "(Landroid/view/inputmethod/InputMethodSubtype;)V");

  /// from: public void changeInputMethodSubtype(android.view.inputmethod.InputMethodSubtype subtype)
  ///
  /// {@inheritDoc}
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  void changeInputMethodSubtype(
          inputmethodsubtype_.InputMethodSubtype subtype) =>
      jniAccessors.callMethodWithArgs(reference, _id_changeInputMethodSubtype,
          jni.JniType.voidType, [subtype.reference]).check();
}
