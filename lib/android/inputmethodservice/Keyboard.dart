// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../content/res/Resources.dart" as resources_;

import "../content/res/XmlResourceParser.dart" as xmlresourceparser_;

import "../graphics/drawable/Drawable.dart" as drawable_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.inputmethodservice.Keyboard
///
/// Loads an XML description of a keyboard and stores the attributes of the keys. A keyboard
/// consists of rows of keys.
/// The layout file for a keyboard contains XML that looks like the following snippet:
///
/// <pre>
/// &lt;Keyboard
///         android:keyWidth="%10p"
///         android:keyHeight="50px"
///         android:horizontalGap="2px"
///         android:verticalGap="2px" &gt;
///     &lt;Row android:keyWidth="32px" &gt;
///         &lt;Key android:keyLabel="A" /&gt;
///         ...
///     &lt;/Row&gt;
///     ...
/// &lt;/Keyboard&gt;
/// </pre>
///@attr ref android.R.styleable\#Keyboard_keyWidth
///@attr ref android.R.styleable\#Keyboard_keyHeight
///@attr ref android.R.styleable\#Keyboard_horizontalGap
///@attr ref android.R.styleable\#Keyboard_verticalGap
class Keyboard extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/inputmethodservice/Keyboard");
  Keyboard.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int EDGE_BOTTOM
  static const EDGE_BOTTOM = 8;

  /// from: static public final int EDGE_LEFT
  static const EDGE_LEFT = 1;

  /// from: static public final int EDGE_RIGHT
  static const EDGE_RIGHT = 2;

  /// from: static public final int EDGE_TOP
  static const EDGE_TOP = 4;

  /// from: static public final int KEYCODE_ALT
  static const KEYCODE_ALT = -6;

  /// from: static public final int KEYCODE_CANCEL
  static const KEYCODE_CANCEL = -3;

  /// from: static public final int KEYCODE_DELETE
  static const KEYCODE_DELETE = -5;

  /// from: static public final int KEYCODE_DONE
  static const KEYCODE_DONE = -4;

  /// from: static public final int KEYCODE_MODE_CHANGE
  static const KEYCODE_MODE_CHANGE = -2;

  /// from: static public final int KEYCODE_SHIFT
  static const KEYCODE_SHIFT = -1;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;I)V");

  /// from: public void <init>(android.content.Context context, int xmlLayoutResId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a keyboard from the given xml key layout file.
  ///@param context the application or service context
  ///@param xmlLayoutResId the resource file that contains the keyboard layout and keys.
  Keyboard(context_.Context context, int xmlLayoutResId)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference, xmlLayoutResId]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;IIII)V");

  /// from: public void <init>(android.content.Context context, int xmlLayoutResId, int modeId, int width, int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a keyboard from the given xml key layout file. Weeds out rows
  /// that have a keyboard mode defined but don't match the specified mode.
  ///@param context the application or service context
  ///@param xmlLayoutResId the resource file that contains the keyboard layout and keys.
  ///@param modeId keyboard mode identifier
  ///@param width sets width of keyboard
  ///@param height sets height of keyboard
  Keyboard.ctor1(context_.Context context, int xmlLayoutResId, int modeId,
      int width, int height)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [context.reference, xmlLayoutResId, modeId, width, height]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;II)V");

  /// from: public void <init>(android.content.Context context, int xmlLayoutResId, int modeId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a keyboard from the given xml key layout file. Weeds out rows
  /// that have a keyboard mode defined but don't match the specified mode.
  ///@param context the application or service context
  ///@param xmlLayoutResId the resource file that contains the keyboard layout and keys.
  ///@param modeId keyboard mode identifier
  Keyboard.ctor2(context_.Context context, int xmlLayoutResId, int modeId)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, xmlLayoutResId, modeId]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;ILjava/lang/CharSequence;II)V");

  /// from: public void <init>(android.content.Context context, int layoutTemplateResId, java.lang.CharSequence characters, int columns, int horizontalPadding)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a blank keyboard from the given resource file and populates it with the specified
  /// characters in left-to-right, top-to-bottom fashion, using the specified number of columns.
  ///
  ///
  /// If the specified number of columns is -1, then the keyboard will fit as many keys as
  /// possible in each row.
  ///
  ///@param context the application or service context
  ///@param layoutTemplateResId the layout template file, containing no keys.
  ///@param characters the list of characters to display on the keyboard. One key will be created
  /// for each character.
  ///@param columns the number of columns of keys to display. If this number is greater than the
  /// number of keys that can fit in a row, it will be ignored. If this number is -1, the
  /// keyboard will fit as many keys as possible in each row.
  Keyboard.ctor3(context_.Context context, int layoutTemplateResId,
      jni.JniObject characters, int columns, int horizontalPadding)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          layoutTemplateResId,
          characters.reference,
          columns,
          horizontalPadding
        ]).object);

  static final _id_getKeys =
      jniAccessors.getMethodIDOf(_classRef, "getKeys", "()Ljava/util/List;");

  /// from: public java.util.List<android.inputmethodservice.Keyboard.Key> getKeys()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getKeys() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getKeys, jni.JniType.objectType, []).object);

  static final _id_getModifierKeys = jniAccessors.getMethodIDOf(
      _classRef, "getModifierKeys", "()Ljava/util/List;");

  /// from: public java.util.List<android.inputmethodservice.Keyboard.Key> getModifierKeys()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getModifierKeys() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getModifierKeys, jni.JniType.objectType, []).object);

  static final _id_getHorizontalGap =
      jniAccessors.getMethodIDOf(_classRef, "getHorizontalGap", "()I");

  /// from: protected int getHorizontalGap()
  int getHorizontalGap() => jniAccessors.callMethodWithArgs(
      reference, _id_getHorizontalGap, jni.JniType.intType, []).integer;

  static final _id_setHorizontalGap =
      jniAccessors.getMethodIDOf(_classRef, "setHorizontalGap", "(I)V");

  /// from: protected void setHorizontalGap(int gap)
  void setHorizontalGap(int gap) => jniAccessors.callMethodWithArgs(
      reference, _id_setHorizontalGap, jni.JniType.voidType, [gap]).check();

  static final _id_getVerticalGap =
      jniAccessors.getMethodIDOf(_classRef, "getVerticalGap", "()I");

  /// from: protected int getVerticalGap()
  int getVerticalGap() => jniAccessors.callMethodWithArgs(
      reference, _id_getVerticalGap, jni.JniType.intType, []).integer;

  static final _id_setVerticalGap =
      jniAccessors.getMethodIDOf(_classRef, "setVerticalGap", "(I)V");

  /// from: protected void setVerticalGap(int gap)
  void setVerticalGap(int gap) => jniAccessors.callMethodWithArgs(
      reference, _id_setVerticalGap, jni.JniType.voidType, [gap]).check();

  static final _id_getKeyHeight =
      jniAccessors.getMethodIDOf(_classRef, "getKeyHeight", "()I");

  /// from: protected int getKeyHeight()
  int getKeyHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getKeyHeight, jni.JniType.intType, []).integer;

  static final _id_setKeyHeight =
      jniAccessors.getMethodIDOf(_classRef, "setKeyHeight", "(I)V");

  /// from: protected void setKeyHeight(int height)
  void setKeyHeight(int height) => jniAccessors.callMethodWithArgs(
      reference, _id_setKeyHeight, jni.JniType.voidType, [height]).check();

  static final _id_getKeyWidth =
      jniAccessors.getMethodIDOf(_classRef, "getKeyWidth", "()I");

  /// from: protected int getKeyWidth()
  int getKeyWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getKeyWidth, jni.JniType.intType, []).integer;

  static final _id_setKeyWidth =
      jniAccessors.getMethodIDOf(_classRef, "setKeyWidth", "(I)V");

  /// from: protected void setKeyWidth(int width)
  void setKeyWidth(int width) => jniAccessors.callMethodWithArgs(
      reference, _id_setKeyWidth, jni.JniType.voidType, [width]).check();

  static final _id_getHeight =
      jniAccessors.getMethodIDOf(_classRef, "getHeight", "()I");

  /// from: public int getHeight()
  ///
  /// Returns the total height of the keyboard
  ///@return the total height of the keyboard
  int getHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getHeight, jni.JniType.intType, []).integer;

  static final _id_getMinWidth =
      jniAccessors.getMethodIDOf(_classRef, "getMinWidth", "()I");

  /// from: public int getMinWidth()
  int getMinWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinWidth, jni.JniType.intType, []).integer;

  static final _id_setShifted =
      jniAccessors.getMethodIDOf(_classRef, "setShifted", "(Z)Z");

  /// from: public boolean setShifted(boolean shiftState)
  bool setShifted(bool shiftState) => jniAccessors.callMethodWithArgs(
      reference, _id_setShifted, jni.JniType.booleanType, [shiftState]).boolean;

  static final _id_isShifted =
      jniAccessors.getMethodIDOf(_classRef, "isShifted", "()Z");

  /// from: public boolean isShifted()
  bool isShifted() => jniAccessors.callMethodWithArgs(
      reference, _id_isShifted, jni.JniType.booleanType, []).boolean;

  static final _id_getShiftKeyIndex =
      jniAccessors.getMethodIDOf(_classRef, "getShiftKeyIndex", "()I");

  /// from: public int getShiftKeyIndex()
  int getShiftKeyIndex() => jniAccessors.callMethodWithArgs(
      reference, _id_getShiftKeyIndex, jni.JniType.intType, []).integer;

  static final _id_getNearestKeys =
      jniAccessors.getMethodIDOf(_classRef, "getNearestKeys", "(II)[I");

  /// from: public int[] getNearestKeys(int x, int y)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the indices of the keys that are closest to the given point.
  ///@param x the x-coordinate of the point
  ///@param y the y-coordinate of the point
  ///@return the array of integer indices for the nearest keys to the given point. If the given
  /// point is out of range, then an array of size zero is returned.
  jni.JniObject getNearestKeys(int x, int y) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getNearestKeys, jni.JniType.objectType, [x, y]).object);

  static final _id_createRowFromXml = jniAccessors.getMethodIDOf(
      _classRef,
      "createRowFromXml",
      "(Landroid/content/res/Resources;Landroid/content/res/XmlResourceParser;)Landroid/inputmethodservice/Keyboard\$Row;");

  /// from: protected android.inputmethodservice.Keyboard.Row createRowFromXml(android.content.res.Resources res, android.content.res.XmlResourceParser parser)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Keyboard_Row createRowFromXml(resources_.Resources res,
          xmlresourceparser_.XmlResourceParser parser) =>
      Keyboard_Row.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createRowFromXml,
          jni.JniType.objectType,
          [res.reference, parser.reference]).object);

  static final _id_createKeyFromXml = jniAccessors.getMethodIDOf(
      _classRef,
      "createKeyFromXml",
      "(Landroid/content/res/Resources;Landroid/inputmethodservice/Keyboard\$Row;IILandroid/content/res/XmlResourceParser;)Landroid/inputmethodservice/Keyboard\$Key;");

  /// from: protected android.inputmethodservice.Keyboard.Key createKeyFromXml(android.content.res.Resources res, android.inputmethodservice.Keyboard.Row parent, int x, int y, android.content.res.XmlResourceParser parser)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Keyboard_Key createKeyFromXml(resources_.Resources res, Keyboard_Row parent,
          int x, int y, xmlresourceparser_.XmlResourceParser parser) =>
      Keyboard_Key.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createKeyFromXml,
          jni.JniType.objectType,
          [res.reference, parent.reference, x, y, parser.reference]).object);
}

/// from: android.inputmethodservice.Keyboard$Row
///
/// Container for keys in the keyboard. All keys in a row are at the same Y-coordinate.
/// Some of the key size defaults can be overridden per row from what the Keyboard
/// defines.
///@attr ref android.R.styleable\#Keyboard_keyWidth
///@attr ref android.R.styleable\#Keyboard_keyHeight
///@attr ref android.R.styleable\#Keyboard_horizontalGap
///@attr ref android.R.styleable\#Keyboard_verticalGap
///@attr ref android.R.styleable\#Keyboard_Row_rowEdgeFlags
///@attr ref android.R.styleable\#Keyboard_Row_keyboardMode
class Keyboard_Row extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/inputmethodservice/Keyboard\$Row");
  Keyboard_Row.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_defaultHeight =
      jniAccessors.getFieldIDOf(_classRef, "defaultHeight", "I");

  /// from: public int defaultHeight
  ///
  /// Default height of a key in this row.
  int get defaultHeight => jniAccessors
      .getField(reference, _id_defaultHeight, jni.JniType.intType)
      .integer;

  /// from: public int defaultHeight
  ///
  /// Default height of a key in this row.
  set defaultHeight(int value) =>
      jniEnv.SetIntField(reference, _id_defaultHeight, value);

  static final _id_defaultHorizontalGap =
      jniAccessors.getFieldIDOf(_classRef, "defaultHorizontalGap", "I");

  /// from: public int defaultHorizontalGap
  ///
  /// Default horizontal gap between keys in this row.
  int get defaultHorizontalGap => jniAccessors
      .getField(reference, _id_defaultHorizontalGap, jni.JniType.intType)
      .integer;

  /// from: public int defaultHorizontalGap
  ///
  /// Default horizontal gap between keys in this row.
  set defaultHorizontalGap(int value) =>
      jniEnv.SetIntField(reference, _id_defaultHorizontalGap, value);

  static final _id_defaultWidth =
      jniAccessors.getFieldIDOf(_classRef, "defaultWidth", "I");

  /// from: public int defaultWidth
  ///
  /// Default width of a key in this row.
  int get defaultWidth => jniAccessors
      .getField(reference, _id_defaultWidth, jni.JniType.intType)
      .integer;

  /// from: public int defaultWidth
  ///
  /// Default width of a key in this row.
  set defaultWidth(int value) =>
      jniEnv.SetIntField(reference, _id_defaultWidth, value);

  static final _id_mode = jniAccessors.getFieldIDOf(_classRef, "mode", "I");

  /// from: public int mode
  ///
  /// The keyboard mode for this row
  int get mode =>
      jniAccessors.getField(reference, _id_mode, jni.JniType.intType).integer;

  /// from: public int mode
  ///
  /// The keyboard mode for this row
  set mode(int value) => jniEnv.SetIntField(reference, _id_mode, value);

  static final _id_rowEdgeFlags =
      jniAccessors.getFieldIDOf(_classRef, "rowEdgeFlags", "I");

  /// from: public int rowEdgeFlags
  ///
  /// Edge flags for this row of keys. Possible values that can be assigned are
  /// Keyboard\#EDGE_TOP EDGE_TOP and Keyboard\#EDGE_BOTTOM EDGE_BOTTOM
  int get rowEdgeFlags => jniAccessors
      .getField(reference, _id_rowEdgeFlags, jni.JniType.intType)
      .integer;

  /// from: public int rowEdgeFlags
  ///
  /// Edge flags for this row of keys. Possible values that can be assigned are
  /// Keyboard\#EDGE_TOP EDGE_TOP and Keyboard\#EDGE_BOTTOM EDGE_BOTTOM
  set rowEdgeFlags(int value) =>
      jniEnv.SetIntField(reference, _id_rowEdgeFlags, value);

  static final _id_verticalGap =
      jniAccessors.getFieldIDOf(_classRef, "verticalGap", "I");

  /// from: public int verticalGap
  ///
  /// Vertical gap following this row.
  int get verticalGap => jniAccessors
      .getField(reference, _id_verticalGap, jni.JniType.intType)
      .integer;

  /// from: public int verticalGap
  ///
  /// Vertical gap following this row.
  set verticalGap(int value) =>
      jniEnv.SetIntField(reference, _id_verticalGap, value);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/inputmethodservice/Keyboard;)V");

  /// from: public void <init>(android.inputmethodservice.Keyboard parent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Keyboard_Row(Keyboard parent)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [parent.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/res/Resources;Landroid/inputmethodservice/Keyboard;Landroid/content/res/XmlResourceParser;)V");

  /// from: public void <init>(android.content.res.Resources res, android.inputmethodservice.Keyboard parent, android.content.res.XmlResourceParser parser)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Keyboard_Row.ctor1(resources_.Resources res, Keyboard parent,
      xmlresourceparser_.XmlResourceParser parser)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [res.reference, parent.reference, parser.reference]).object);
}

/// from: android.inputmethodservice.Keyboard$Key
///
/// Class for describing the position and characteristics of a single key in the keyboard.
///@attr ref android.R.styleable\#Keyboard_keyWidth
///@attr ref android.R.styleable\#Keyboard_keyHeight
///@attr ref android.R.styleable\#Keyboard_horizontalGap
///@attr ref android.R.styleable\#Keyboard_Key_codes
///@attr ref android.R.styleable\#Keyboard_Key_keyIcon
///@attr ref android.R.styleable\#Keyboard_Key_keyLabel
///@attr ref android.R.styleable\#Keyboard_Key_iconPreview
///@attr ref android.R.styleable\#Keyboard_Key_isSticky
///@attr ref android.R.styleable\#Keyboard_Key_isRepeatable
///@attr ref android.R.styleable\#Keyboard_Key_isModifier
///@attr ref android.R.styleable\#Keyboard_Key_popupKeyboard
///@attr ref android.R.styleable\#Keyboard_Key_popupCharacters
///@attr ref android.R.styleable\#Keyboard_Key_keyOutputText
///@attr ref android.R.styleable\#Keyboard_Key_keyEdgeFlags
class Keyboard_Key extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/inputmethodservice/Keyboard\$Key");
  Keyboard_Key.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_codes = jniAccessors.getFieldIDOf(_classRef, "codes", "[I");

  /// from: public int[] codes
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// All the key codes (unicode or custom code) that this key could generate, zero'th
  /// being the most important.
  jni.JniObject get codes => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_codes, jni.JniType.objectType)
      .object);

  /// from: public int[] codes
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// All the key codes (unicode or custom code) that this key could generate, zero'th
  /// being the most important.
  set codes(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_codes, value.reference);

  static final _id_edgeFlags =
      jniAccessors.getFieldIDOf(_classRef, "edgeFlags", "I");

  /// from: public int edgeFlags
  ///
  /// Flags that specify the anchoring to edges of the keyboard for detecting touch events
  /// that are just out of the boundary of the key. This is a bit mask of
  /// Keyboard\#EDGE_LEFT, Keyboard\#EDGE_RIGHT, Keyboard\#EDGE_TOP and
  /// Keyboard\#EDGE_BOTTOM.
  int get edgeFlags => jniAccessors
      .getField(reference, _id_edgeFlags, jni.JniType.intType)
      .integer;

  /// from: public int edgeFlags
  ///
  /// Flags that specify the anchoring to edges of the keyboard for detecting touch events
  /// that are just out of the boundary of the key. This is a bit mask of
  /// Keyboard\#EDGE_LEFT, Keyboard\#EDGE_RIGHT, Keyboard\#EDGE_TOP and
  /// Keyboard\#EDGE_BOTTOM.
  set edgeFlags(int value) =>
      jniEnv.SetIntField(reference, _id_edgeFlags, value);

  static final _id_gap = jniAccessors.getFieldIDOf(_classRef, "gap", "I");

  /// from: public int gap
  ///
  /// The horizontal gap before this key
  int get gap =>
      jniAccessors.getField(reference, _id_gap, jni.JniType.intType).integer;

  /// from: public int gap
  ///
  /// The horizontal gap before this key
  set gap(int value) => jniEnv.SetIntField(reference, _id_gap, value);

  static final _id_height = jniAccessors.getFieldIDOf(_classRef, "height", "I");

  /// from: public int height
  ///
  /// Height of the key, not including the gap
  int get height =>
      jniAccessors.getField(reference, _id_height, jni.JniType.intType).integer;

  /// from: public int height
  ///
  /// Height of the key, not including the gap
  set height(int value) => jniEnv.SetIntField(reference, _id_height, value);

  static final _id_icon = jniAccessors.getFieldIDOf(
      _classRef, "icon", "Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable icon
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Icon to display instead of a label. Icon takes precedence over a label
  drawable_.Drawable get icon => drawable_.Drawable.fromRef(jniAccessors
      .getField(reference, _id_icon, jni.JniType.objectType)
      .object);

  /// from: public android.graphics.drawable.Drawable icon
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Icon to display instead of a label. Icon takes precedence over a label
  set icon(drawable_.Drawable value) =>
      jniEnv.SetObjectField(reference, _id_icon, value.reference);

  static final _id_iconPreview = jniAccessors.getFieldIDOf(
      _classRef, "iconPreview", "Landroid/graphics/drawable/Drawable;");

  /// from: public android.graphics.drawable.Drawable iconPreview
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Preview version of the icon, for the preview popup
  drawable_.Drawable get iconPreview => drawable_.Drawable.fromRef(jniAccessors
      .getField(reference, _id_iconPreview, jni.JniType.objectType)
      .object);

  /// from: public android.graphics.drawable.Drawable iconPreview
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Preview version of the icon, for the preview popup
  set iconPreview(drawable_.Drawable value) =>
      jniEnv.SetObjectField(reference, _id_iconPreview, value.reference);

  static final _id_label =
      jniAccessors.getFieldIDOf(_classRef, "label", "Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence label
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Label to display
  jni.JniObject get label => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_label, jni.JniType.objectType)
      .object);

  /// from: public java.lang.CharSequence label
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Label to display
  set label(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_label, value.reference);

  static final _id_modifier =
      jniAccessors.getFieldIDOf(_classRef, "modifier", "Z");

  /// from: public boolean modifier
  ///
  /// Whether this is a modifier key, such as Shift or Alt
  bool get modifier => jniAccessors
      .getField(reference, _id_modifier, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean modifier
  ///
  /// Whether this is a modifier key, such as Shift or Alt
  set modifier(bool value) =>
      jniEnv.SetBooleanField(reference, _id_modifier, value ? 1 : 0);

  static final _id_on0 = jniAccessors.getFieldIDOf(_classRef, "on", "Z");

  /// from: public boolean on
  ///
  /// If this is a sticky key, is it on?
  bool get on0 => jniAccessors
      .getField(reference, _id_on0, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean on
  ///
  /// If this is a sticky key, is it on?
  set on0(bool value) =>
      jniEnv.SetBooleanField(reference, _id_on0, value ? 1 : 0);

  static final _id_popupCharacters = jniAccessors.getFieldIDOf(
      _classRef, "popupCharacters", "Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence popupCharacters
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Popup characters
  jni.JniObject get popupCharacters => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_popupCharacters, jni.JniType.objectType)
      .object);

  /// from: public java.lang.CharSequence popupCharacters
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Popup characters
  set popupCharacters(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_popupCharacters, value.reference);

  static final _id_popupResId =
      jniAccessors.getFieldIDOf(_classRef, "popupResId", "I");

  /// from: public int popupResId
  ///
  /// If this key pops up a mini keyboard, this is the resource id for the XML layout for that
  /// keyboard.
  int get popupResId => jniAccessors
      .getField(reference, _id_popupResId, jni.JniType.intType)
      .integer;

  /// from: public int popupResId
  ///
  /// If this key pops up a mini keyboard, this is the resource id for the XML layout for that
  /// keyboard.
  set popupResId(int value) =>
      jniEnv.SetIntField(reference, _id_popupResId, value);

  static final _id_pressed =
      jniAccessors.getFieldIDOf(_classRef, "pressed", "Z");

  /// from: public boolean pressed
  ///
  /// The current pressed state of this key
  bool get pressed => jniAccessors
      .getField(reference, _id_pressed, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean pressed
  ///
  /// The current pressed state of this key
  set pressed(bool value) =>
      jniEnv.SetBooleanField(reference, _id_pressed, value ? 1 : 0);

  static final _id_repeatable =
      jniAccessors.getFieldIDOf(_classRef, "repeatable", "Z");

  /// from: public boolean repeatable
  ///
  /// Whether this key repeats itself when held down
  bool get repeatable => jniAccessors
      .getField(reference, _id_repeatable, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean repeatable
  ///
  /// Whether this key repeats itself when held down
  set repeatable(bool value) =>
      jniEnv.SetBooleanField(reference, _id_repeatable, value ? 1 : 0);

  static final _id_sticky = jniAccessors.getFieldIDOf(_classRef, "sticky", "Z");

  /// from: public boolean sticky
  ///
  /// Whether this key is sticky, i.e., a toggle key
  bool get sticky => jniAccessors
      .getField(reference, _id_sticky, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean sticky
  ///
  /// Whether this key is sticky, i.e., a toggle key
  set sticky(bool value) =>
      jniEnv.SetBooleanField(reference, _id_sticky, value ? 1 : 0);

  static final _id_text =
      jniAccessors.getFieldIDOf(_classRef, "text", "Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence text
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Text to output when pressed. This can be multiple characters, like ".com"
  jni.JniObject get text => jni.JniObject.fromRef(jniAccessors
      .getField(reference, _id_text, jni.JniType.objectType)
      .object);

  /// from: public java.lang.CharSequence text
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Text to output when pressed. This can be multiple characters, like ".com"
  set text(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_text, value.reference);

  static final _id_width = jniAccessors.getFieldIDOf(_classRef, "width", "I");

  /// from: public int width
  ///
  /// Width of the key, not including the gap
  int get width =>
      jniAccessors.getField(reference, _id_width, jni.JniType.intType).integer;

  /// from: public int width
  ///
  /// Width of the key, not including the gap
  set width(int value) => jniEnv.SetIntField(reference, _id_width, value);

  static final _id_x = jniAccessors.getFieldIDOf(_classRef, "x", "I");

  /// from: public int x
  ///
  /// X coordinate of the key in the keyboard layout
  int get x =>
      jniAccessors.getField(reference, _id_x, jni.JniType.intType).integer;

  /// from: public int x
  ///
  /// X coordinate of the key in the keyboard layout
  set x(int value) => jniEnv.SetIntField(reference, _id_x, value);

  static final _id_y = jniAccessors.getFieldIDOf(_classRef, "y", "I");

  /// from: public int y
  ///
  /// Y coordinate of the key in the keyboard layout
  int get y =>
      jniAccessors.getField(reference, _id_y, jni.JniType.intType).integer;

  /// from: public int y
  ///
  /// Y coordinate of the key in the keyboard layout
  set y(int value) => jniEnv.SetIntField(reference, _id_y, value);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/inputmethodservice/Keyboard\$Row;)V");

  /// from: public void <init>(android.inputmethodservice.Keyboard.Row parent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an empty key with no attributes.
  Keyboard_Key(Keyboard_Row parent)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [parent.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/res/Resources;Landroid/inputmethodservice/Keyboard\$Row;IILandroid/content/res/XmlResourceParser;)V");

  /// from: public void <init>(android.content.res.Resources res, android.inputmethodservice.Keyboard.Row parent, int x, int y, android.content.res.XmlResourceParser parser)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a key with the given top-left coordinate and extract its attributes from
  /// the XML parser.
  ///@param res resources associated with the caller's context
  ///@param parent the row that this key belongs to. The row must already be attached to
  /// a Keyboard.
  ///@param x the x coordinate of the top-left
  ///@param y the y coordinate of the top-left
  ///@param parser the XML parser containing the attributes for this key
  Keyboard_Key.ctor1(resources_.Resources res, Keyboard_Row parent, int x,
      int y, xmlresourceparser_.XmlResourceParser parser)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [res.reference, parent.reference, x, y, parser.reference]).object);

  static final _id_onPressed =
      jniAccessors.getMethodIDOf(_classRef, "onPressed", "()V");

  /// from: public void onPressed()
  ///
  /// Informs the key that it has been pressed, in case it needs to change its appearance or
  /// state.
  ///@see \#onReleased(boolean)
  void onPressed() => jniAccessors.callMethodWithArgs(
      reference, _id_onPressed, jni.JniType.voidType, []).check();

  static final _id_onReleased =
      jniAccessors.getMethodIDOf(_classRef, "onReleased", "(Z)V");

  /// from: public void onReleased(boolean inside)
  ///
  /// Changes the pressed state of the key.
  ///
  /// Toggled state of the key will be flipped when all the following conditions are
  /// fulfilled:
  ///
  ///
  /// <ul>
  ///     <li>This is a sticky key, that is, \#sticky is {@code true}.
  ///     <li>The parameter {@code inside} is {@code true}.
  ///     <li>android.os.Build.VERSION\#SDK_INT is greater than
  ///         android.os.Build.VERSION_CODES\#LOLLIPOP_MR1.
  /// </ul>
  ///@param inside whether the finger was released inside the key. Works only on Android M and
  /// later. See the method document for details.
  ///@see \#onPressed()
  void onReleased(bool inside) => jniAccessors.callMethodWithArgs(
      reference, _id_onReleased, jni.JniType.voidType, [inside]).check();

  static final _id_isInside =
      jniAccessors.getMethodIDOf(_classRef, "isInside", "(II)Z");

  /// from: public boolean isInside(int x, int y)
  ///
  /// Detects if a point falls inside this key.
  ///@param x the x-coordinate of the point
  ///@param y the y-coordinate of the point
  ///@return whether or not the point falls inside the key. If the key is attached to an edge,
  /// it will assume that all points between the key and the edge are considered to be inside
  /// the key.
  bool isInside(int x, int y) => jniAccessors.callMethodWithArgs(
      reference, _id_isInside, jni.JniType.booleanType, [x, y]).boolean;

  static final _id_squaredDistanceFrom =
      jniAccessors.getMethodIDOf(_classRef, "squaredDistanceFrom", "(II)I");

  /// from: public int squaredDistanceFrom(int x, int y)
  ///
  /// Returns the square of the distance between the center of the key and the given point.
  ///@param x the x-coordinate of the point
  ///@param y the y-coordinate of the point
  ///@return the square of the distance of the point from the center of the key
  int squaredDistanceFrom(int x, int y) => jniAccessors.callMethodWithArgs(
      reference, _id_squaredDistanceFrom, jni.JniType.intType, [x, y]).integer;

  static final _id_getCurrentDrawableState =
      jniAccessors.getMethodIDOf(_classRef, "getCurrentDrawableState", "()[I");

  /// from: public int[] getCurrentDrawableState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the drawable state for the key, based on the current state and type of the key.
  ///@return the drawable state of the key.
  ///@see android.graphics.drawable.StateListDrawable\#setState(int[])
  jni.JniObject getCurrentDrawableState() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCurrentDrawableState, jni.JniType.objectType, []).object);
}
