// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "CursorWindow.dart" as cursorwindow_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.database.CrossProcessCursor
///
/// A cross process cursor is an extension of a Cursor that also supports
/// usage from remote processes.
///
/// The contents of a cross process cursor are marshalled to the remote process by
/// filling CursorWindow objects using \#fillWindow.  As an optimization,
/// the cursor can provide a pre-filled window to use via \#getWindow thereby
/// obviating the need to copy the data to yet another cursor window.
class CrossProcessCursor extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/database/CrossProcessCursor");
  CrossProcessCursor.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getWindow = jniAccessors.getMethodIDOf(
      _classRef, "getWindow", "()Landroid/database/CursorWindow;");

  /// from: public abstract android.database.CursorWindow getWindow()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a pre-filled window that contains the data within this cursor.
  ///
  /// In particular, the window contains the row indicated by Cursor\#getPosition.
  /// The window's contents are automatically scrolled whenever the current
  /// row moved outside the range covered by the window.
  ///
  ///
  ///@return The pre-filled window, or null if none.
  cursorwindow_.CursorWindow getWindow() =>
      cursorwindow_.CursorWindow.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWindow, jni.JniType.objectType, []).object);

  static final _id_fillWindow = jniAccessors.getMethodIDOf(
      _classRef, "fillWindow", "(ILandroid/database/CursorWindow;)V");

  /// from: public abstract void fillWindow(int position, android.database.CursorWindow window)
  ///
  /// Copies cursor data into the window.
  ///
  /// Clears the window and fills it with data beginning at the requested
  /// row position until all of the data in the cursor is exhausted
  /// or the window runs out of space.
  ///
  ///
  /// The filled window uses the same row indices as the original cursor.
  /// For example, if you fill a window starting from row 5 from the cursor,
  /// you can query the contents of row 5 from the window just by asking it
  /// for row 5 because there is a direct correspondence between the row indices
  /// used by the cursor and the window.
  ///
  ///
  /// The current position of the cursor, as returned by \#getPosition,
  /// is not changed by this method.
  ///
  ///
  ///@param position The zero-based index of the first row to copy into the window.
  ///@param window The window to fill.
  void fillWindow(int position, cursorwindow_.CursorWindow window) =>
      jniAccessors.callMethodWithArgs(reference, _id_fillWindow,
          jni.JniType.voidType, [position, window.reference]).check();

  static final _id_onMove =
      jniAccessors.getMethodIDOf(_classRef, "onMove", "(II)Z");

  /// from: public abstract boolean onMove(int oldPosition, int newPosition)
  ///
  /// This function is called every time the cursor is successfully scrolled
  /// to a new position, giving the subclass a chance to update any state it
  /// may have.  If it returns false the move function will also do so and the
  /// cursor will scroll to the beforeFirst position.
  ///
  /// This function should be called by methods such as \#moveToPosition(int),
  /// so it will typically not be called from outside of the cursor class itself.
  ///
  ///
  ///@param oldPosition The position that we're moving from.
  ///@param newPosition The position that we're moving to.
  ///@return True if the move is successful, false otherwise.
  bool onMove(int oldPosition, int newPosition) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMove,
          jni.JniType.booleanType, [oldPosition, newPosition]).boolean;
}
