// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "SQLiteClosable.dart" as sqliteclosable_;

import "../DatabaseErrorHandler.dart" as databaseerrorhandler_;

import "SQLiteTransactionListener.dart" as sqlitetransactionlistener_;

import "SQLiteStatement.dart" as sqlitestatement_;

import "../Cursor.dart" as cursor_;

import "../../os/CancellationSignal.dart" as cancellationsignal_;

import "../../content/ContentValues.dart" as contentvalues_;

import "SQLiteCursorDriver.dart" as sqlitecursordriver_;

import "SQLiteQuery.dart" as sqlitequery_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.database.sqlite.SQLiteDatabase
///
/// Exposes methods to manage a SQLite database.
///
///
/// SQLiteDatabase has methods to create, delete, execute SQL commands, and
/// perform other common database management tasks.
///
///
/// See the Notepad sample application in the SDK for an example of creating
/// and managing a database.
///
///
/// Database names must be unique within an application, not across all applications.
///
///
///
/// <h3>Localized Collation - ORDER BY</h3>
///
/// In addition to SQLite's default <code>BINARY</code> collator, Android supplies
/// two more, <code>LOCALIZED</code>, which changes with the system's current locale,
/// and <code>UNICODE</code>, which is the Unicode Collation Algorithm and not tailored
/// to the current locale.
///
///
class SQLiteDatabase extends sqliteclosable_.SQLiteClosable {
  static final _classRef =
      jniAccessors.getClassOf("android/database/sqlite/SQLiteDatabase");
  SQLiteDatabase.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CONFLICT_ABORT
  ///
  /// When a constraint violation occurs,no ROLLBACK is executed
  /// so changes from prior commands within the same transaction
  /// are preserved. This is the default behavior.
  static const CONFLICT_ABORT = 2;

  /// from: static public final int CONFLICT_FAIL
  ///
  /// When a constraint violation occurs, the command aborts with a return
  /// code SQLITE_CONSTRAINT. But any changes to the database that
  /// the command made prior to encountering the constraint violation
  /// are preserved and are not backed out.
  static const CONFLICT_FAIL = 3;

  /// from: static public final int CONFLICT_IGNORE
  ///
  /// When a constraint violation occurs, the one row that contains
  /// the constraint violation is not inserted or changed.
  /// But the command continues executing normally. Other rows before and
  /// after the row that contained the constraint violation continue to be
  /// inserted or updated normally. No error is returned.
  static const CONFLICT_IGNORE = 4;

  /// from: static public final int CONFLICT_NONE
  ///
  /// Use the following when no conflict action is specified.
  static const CONFLICT_NONE = 0;

  /// from: static public final int CONFLICT_REPLACE
  ///
  /// When a UNIQUE constraint violation occurs, the pre-existing rows that
  /// are causing the constraint violation are removed prior to inserting
  /// or updating the current row. Thus the insert or update always occurs.
  /// The command continues executing normally. No error is returned.
  /// If a NOT NULL constraint violation occurs, the NULL value is replaced
  /// by the default value for that column. If the column has no default
  /// value, then the ABORT algorithm is used. If a CHECK constraint
  /// violation occurs then the IGNORE algorithm is used. When this conflict
  /// resolution strategy deletes rows in order to satisfy a constraint,
  /// it does not invoke delete triggers on those rows.
  /// This behavior might change in a future release.
  static const CONFLICT_REPLACE = 5;

  /// from: static public final int CONFLICT_ROLLBACK
  ///
  /// When a constraint violation occurs, an immediate ROLLBACK occurs,
  /// thus ending the current transaction, and the command aborts with a
  /// return code of SQLITE_CONSTRAINT. If no transaction is active
  /// (other than the implied transaction that is created on every command)
  /// then this algorithm works the same as ABORT.
  static const CONFLICT_ROLLBACK = 1;

  /// from: static public final int CREATE_IF_NECESSARY
  ///
  /// Open flag: Flag for \#openDatabase to create the database file if it does not
  /// already exist.
  static const CREATE_IF_NECESSARY = 268435456;

  /// from: static public final int ENABLE_WRITE_AHEAD_LOGGING
  ///
  /// Open flag: Flag for \#openDatabase to open the database file with
  /// write-ahead logging enabled by default.  Using this flag is more efficient
  /// than calling \#enableWriteAheadLogging.
  ///
  /// Write-ahead logging cannot be used with read-only databases so the value of
  /// this flag is ignored if the database is opened read-only.
  ///@see \#enableWriteAheadLogging
  static const ENABLE_WRITE_AHEAD_LOGGING = 536870912;

  /// from: static public final int MAX_SQL_CACHE_SIZE
  ///
  /// Absolute max value that can be set by \#setMaxSqlCacheSize(int).
  ///
  /// Each prepared-statement is between 1K - 6K, depending on the complexity of the
  /// SQL statement & schema.  A large SQL cache may use a significant amount of memory.
  static const MAX_SQL_CACHE_SIZE = 100;

  /// from: static public final int NO_LOCALIZED_COLLATORS
  ///
  /// Open flag: Flag for \#openDatabase to open the database without support for
  /// localized collators.
  ///
  /// {@more } This causes the collator <code>LOCALIZED</code> not to be created.
  /// You must be consistent when using this flag to use the setting the database was
  /// created with.  If this is set, \#setLocale will do nothing.
  static const NO_LOCALIZED_COLLATORS = 16;

  /// from: static public final int OPEN_READONLY
  ///
  /// Open flag: Flag for \#openDatabase to open the database for reading only.
  /// This is the only reliable way to open a database if the disk may be full.
  static const OPEN_READONLY = 1;

  /// from: static public final int OPEN_READWRITE
  ///
  /// Open flag: Flag for \#openDatabase to open the database for reading and writing.
  /// If the disk is full, this may fail even before you actually write anything.
  ///
  /// {@more } Note that the value of this flag is 0, so it is the default.
  static const OPEN_READWRITE = 0;

  /// from: static public final int SQLITE_MAX_LIKE_PATTERN_LENGTH
  ///
  /// Maximum Length Of A LIKE Or GLOB Pattern
  /// The pattern matching algorithm used in the default LIKE and GLOB implementation
  /// of SQLite can exhibit O(N^2) performance (where N is the number of characters in
  /// the pattern) for certain pathological cases. To avoid denial-of-service attacks
  /// the length of the LIKE or GLOB pattern is limited to SQLITE_MAX_LIKE_PATTERN_LENGTH bytes.
  /// The default value of this limit is 50000. A modern workstation can evaluate
  /// even a pathological LIKE or GLOB pattern of 50000 bytes relatively quickly.
  /// The denial of service problem only comes into play when the pattern length gets
  /// into millions of bytes. Nevertheless, since most useful LIKE or GLOB patterns
  /// are at most a few dozen bytes in length, paranoid application developers may
  /// want to reduce this parameter to something in the range of a few hundred
  /// if they know that external users are able to generate arbitrary patterns.
  static const SQLITE_MAX_LIKE_PATTERN_LENGTH = 50000;

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;ILandroid/database/sqlite/SQLiteDatabase\$CursorFactory;Landroid/database/DatabaseErrorHandler;IIJLjava/lang/String;Ljava/lang/String;)V");

  /// from: void <init>(java.lang.String path, int openFlags, android.database.sqlite.SQLiteDatabase.CursorFactory cursorFactory, android.database.DatabaseErrorHandler errorHandler, int lookasideSlotSize, int lookasideSlotCount, long idleConnectionTimeoutMs, java.lang.String journalMode, java.lang.String syncMode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SQLiteDatabase.ctor1(
      jni.JniString path,
      int openFlags,
      SQLiteDatabase_CursorFactory cursorFactory,
      databaseerrorhandler_.DatabaseErrorHandler errorHandler,
      int lookasideSlotSize,
      int lookasideSlotCount,
      int idleConnectionTimeoutMs,
      jni.JniString journalMode,
      jni.JniString syncMode)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1, [
          path.reference,
          openFlags,
          cursorFactory.reference,
          errorHandler.reference,
          lookasideSlotSize,
          lookasideSlotCount,
          idleConnectionTimeoutMs,
          journalMode.reference,
          syncMode.reference
        ]).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_onAllReferencesReleased =
      jniAccessors.getMethodIDOf(_classRef, "onAllReferencesReleased", "()V");

  /// from: protected void onAllReferencesReleased()
  void onAllReferencesReleased() => jniAccessors.callMethodWithArgs(
      reference, _id_onAllReferencesReleased, jni.JniType.voidType, []).check();

  static final _id_releaseMemory =
      jniAccessors.getStaticMethodIDOf(_classRef, "releaseMemory", "()I");

  /// from: static public int releaseMemory()
  ///
  /// Attempts to release memory that SQLite holds but does not require to
  /// operate properly. Typically this memory will come from the page cache.
  ///@return the number of bytes actually released
  static int releaseMemory() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_releaseMemory, jni.JniType.intType, []).integer;

  static final _id_setLockingEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setLockingEnabled", "(Z)V");

  /// from: public void setLockingEnabled(boolean lockingEnabled)
  ///
  /// Control whether or not the SQLiteDatabase is made thread-safe by using locks
  /// around critical sections. This is pretty expensive, so if you know that your
  /// DB will only be used by a single thread then you should set this to false.
  /// The default is true.
  ///@param lockingEnabled set to true to enable locks, false otherwise
  ///@deprecated This method now does nothing.  Do not use.
  void setLockingEnabled(bool lockingEnabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLockingEnabled,
          jni.JniType.voidType, [lockingEnabled]).check();

  static final _id_beginTransaction =
      jniAccessors.getMethodIDOf(_classRef, "beginTransaction", "()V");

  /// from: public void beginTransaction()
  ///
  /// Begins a transaction in EXCLUSIVE mode.
  ///
  /// Transactions can be nested.
  /// When the outer transaction is ended all of
  /// the work done in that transaction and all of the nested transactions will be committed or
  /// rolled back. The changes will be rolled back if any transaction is ended without being
  /// marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed.
  ///
  ///
  /// Here is the standard idiom for transactions:
  ///
  /// <pre>
  ///   db.beginTransaction();
  ///   try {
  ///     ...
  ///     db.setTransactionSuccessful();
  ///   } finally {
  ///     db.endTransaction();
  ///   }
  /// </pre>
  void beginTransaction() => jniAccessors.callMethodWithArgs(
      reference, _id_beginTransaction, jni.JniType.voidType, []).check();

  static final _id_beginTransactionNonExclusive = jniAccessors.getMethodIDOf(
      _classRef, "beginTransactionNonExclusive", "()V");

  /// from: public void beginTransactionNonExclusive()
  ///
  /// Begins a transaction in IMMEDIATE mode. Transactions can be nested. When
  /// the outer transaction is ended all of the work done in that transaction
  /// and all of the nested transactions will be committed or rolled back. The
  /// changes will be rolled back if any transaction is ended without being
  /// marked as clean (by calling setTransactionSuccessful). Otherwise they
  /// will be committed.
  ///
  /// Here is the standard idiom for transactions:
  ///
  /// <pre>
  ///   db.beginTransactionNonExclusive();
  ///   try {
  ///     ...
  ///     db.setTransactionSuccessful();
  ///   } finally {
  ///     db.endTransaction();
  ///   }
  /// </pre>
  void beginTransactionNonExclusive() => jniAccessors.callMethodWithArgs(
      reference,
      _id_beginTransactionNonExclusive,
      jni.JniType.voidType, []).check();

  static final _id_beginTransactionWithListener = jniAccessors.getMethodIDOf(
      _classRef,
      "beginTransactionWithListener",
      "(Landroid/database/sqlite/SQLiteTransactionListener;)V");

  /// from: public void beginTransactionWithListener(android.database.sqlite.SQLiteTransactionListener transactionListener)
  ///
  /// Begins a transaction in EXCLUSIVE mode.
  ///
  /// Transactions can be nested.
  /// When the outer transaction is ended all of
  /// the work done in that transaction and all of the nested transactions will be committed or
  /// rolled back. The changes will be rolled back if any transaction is ended without being
  /// marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed.
  ///
  ///
  /// Here is the standard idiom for transactions:
  ///
  /// <pre>
  ///   db.beginTransactionWithListener(listener);
  ///   try {
  ///     ...
  ///     db.setTransactionSuccessful();
  ///   } finally {
  ///     db.endTransaction();
  ///   }
  /// </pre>
  ///@param transactionListener listener that should be notified when the transaction begins,
  /// commits, or is rolled back, either explicitly or by a call to
  /// \#yieldIfContendedSafely.
  void beginTransactionWithListener(
          sqlitetransactionlistener_.SQLiteTransactionListener
              transactionListener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_beginTransactionWithListener,
          jni.JniType.voidType,
          [transactionListener.reference]).check();

  static final _id_beginTransactionWithListenerNonExclusive =
      jniAccessors.getMethodIDOf(
          _classRef,
          "beginTransactionWithListenerNonExclusive",
          "(Landroid/database/sqlite/SQLiteTransactionListener;)V");

  /// from: public void beginTransactionWithListenerNonExclusive(android.database.sqlite.SQLiteTransactionListener transactionListener)
  ///
  /// Begins a transaction in IMMEDIATE mode. Transactions can be nested. When
  /// the outer transaction is ended all of the work done in that transaction
  /// and all of the nested transactions will be committed or rolled back. The
  /// changes will be rolled back if any transaction is ended without being
  /// marked as clean (by calling setTransactionSuccessful). Otherwise they
  /// will be committed.
  ///
  /// Here is the standard idiom for transactions:
  ///
  /// <pre>
  ///   db.beginTransactionWithListenerNonExclusive(listener);
  ///   try {
  ///     ...
  ///     db.setTransactionSuccessful();
  ///   } finally {
  ///     db.endTransaction();
  ///   }
  /// </pre>
  ///@param transactionListener listener that should be notified when the
  ///            transaction begins, commits, or is rolled back, either
  ///            explicitly or by a call to \#yieldIfContendedSafely.
  void beginTransactionWithListenerNonExclusive(
          sqlitetransactionlistener_.SQLiteTransactionListener
              transactionListener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_beginTransactionWithListenerNonExclusive,
          jni.JniType.voidType,
          [transactionListener.reference]).check();

  static final _id_endTransaction =
      jniAccessors.getMethodIDOf(_classRef, "endTransaction", "()V");

  /// from: public void endTransaction()
  ///
  /// End a transaction. See beginTransaction for notes about how to use this and when transactions
  /// are committed and rolled back.
  void endTransaction() => jniAccessors.callMethodWithArgs(
      reference, _id_endTransaction, jni.JniType.voidType, []).check();

  static final _id_setTransactionSuccessful =
      jniAccessors.getMethodIDOf(_classRef, "setTransactionSuccessful", "()V");

  /// from: public void setTransactionSuccessful()
  ///
  /// Marks the current transaction as successful. Do not do any more database work between
  /// calling this and calling endTransaction. Do as little non-database work as possible in that
  /// situation too. If any errors are encountered between this and endTransaction the transaction
  /// will still be committed.
  ///@throws IllegalStateException if the current thread is not in a transaction or the
  /// transaction is already marked as successful.
  void setTransactionSuccessful() => jniAccessors.callMethodWithArgs(reference,
      _id_setTransactionSuccessful, jni.JniType.voidType, []).check();

  static final _id_inTransaction =
      jniAccessors.getMethodIDOf(_classRef, "inTransaction", "()Z");

  /// from: public boolean inTransaction()
  ///
  /// Returns true if the current thread has a transaction pending.
  ///@return True if the current thread is in a transaction.
  bool inTransaction() => jniAccessors.callMethodWithArgs(
      reference, _id_inTransaction, jni.JniType.booleanType, []).boolean;

  static final _id_isDbLockedByCurrentThread =
      jniAccessors.getMethodIDOf(_classRef, "isDbLockedByCurrentThread", "()Z");

  /// from: public boolean isDbLockedByCurrentThread()
  ///
  /// Returns true if the current thread is holding an active connection to the database.
  ///
  /// The name of this method comes from a time when having an active connection
  /// to the database meant that the thread was holding an actual lock on the
  /// database.  Nowadays, there is no longer a true "database lock" although threads
  /// may block if they cannot acquire a database connection to perform a
  /// particular operation.
  ///
  ///
  ///@return True if the current thread is holding an active connection to the database.
  bool isDbLockedByCurrentThread() => jniAccessors.callMethodWithArgs(reference,
      _id_isDbLockedByCurrentThread, jni.JniType.booleanType, []).boolean;

  static final _id_isDbLockedByOtherThreads =
      jniAccessors.getMethodIDOf(_classRef, "isDbLockedByOtherThreads", "()Z");

  /// from: public boolean isDbLockedByOtherThreads()
  ///
  /// Always returns false.
  ///
  /// There is no longer the concept of a database lock, so this method always returns false.
  ///
  ///
  ///@return False.
  ///@deprecated Always returns false.  Do not use this method.
  bool isDbLockedByOtherThreads() => jniAccessors.callMethodWithArgs(reference,
      _id_isDbLockedByOtherThreads, jni.JniType.booleanType, []).boolean;

  static final _id_yieldIfContended =
      jniAccessors.getMethodIDOf(_classRef, "yieldIfContended", "()Z");

  /// from: public boolean yieldIfContended()
  ///
  /// Temporarily end the transaction to let other threads run. The transaction is assumed to be
  /// successful so far. Do not call setTransactionSuccessful before calling this. When this
  /// returns a new transaction will have been created but not marked as successful.
  ///@return true if the transaction was yielded
  ///@deprecated if the db is locked more than once (becuase of nested transactions) then the lock
  ///   will not be yielded. Use yieldIfContendedSafely instead.
  bool yieldIfContended() => jniAccessors.callMethodWithArgs(
      reference, _id_yieldIfContended, jni.JniType.booleanType, []).boolean;

  static final _id_yieldIfContendedSafely =
      jniAccessors.getMethodIDOf(_classRef, "yieldIfContendedSafely", "()Z");

  /// from: public boolean yieldIfContendedSafely()
  ///
  /// Temporarily end the transaction to let other threads run. The transaction is assumed to be
  /// successful so far. Do not call setTransactionSuccessful before calling this. When this
  /// returns a new transaction will have been created but not marked as successful. This assumes
  /// that there are no nested transactions (beginTransaction has only been called once) and will
  /// throw an exception if that is not the case.
  ///@return true if the transaction was yielded
  bool yieldIfContendedSafely() => jniAccessors.callMethodWithArgs(reference,
      _id_yieldIfContendedSafely, jni.JniType.booleanType, []).boolean;

  static final _id_yieldIfContendedSafely1 =
      jniAccessors.getMethodIDOf(_classRef, "yieldIfContendedSafely", "(J)Z");

  /// from: public boolean yieldIfContendedSafely(long sleepAfterYieldDelay)
  ///
  /// Temporarily end the transaction to let other threads run. The transaction is assumed to be
  /// successful so far. Do not call setTransactionSuccessful before calling this. When this
  /// returns a new transaction will have been created but not marked as successful. This assumes
  /// that there are no nested transactions (beginTransaction has only been called once) and will
  /// throw an exception if that is not the case.
  ///@param sleepAfterYieldDelay if > 0, sleep this long before starting a new transaction if
  ///   the lock was actually yielded. This will allow other background threads to make some
  ///   more progress than they would if we started the transaction immediately.
  ///@return true if the transaction was yielded
  bool yieldIfContendedSafely1(int sleepAfterYieldDelay) =>
      jniAccessors.callMethodWithArgs(reference, _id_yieldIfContendedSafely1,
          jni.JniType.booleanType, [sleepAfterYieldDelay]).boolean;

  static final _id_getSyncedTables = jniAccessors.getMethodIDOf(
      _classRef, "getSyncedTables", "()Ljava/util/Map;");

  /// from: public java.util.Map<java.lang.String,java.lang.String> getSyncedTables()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Deprecated.
  ///@deprecated This method no longer serves any useful purpose and has been deprecated.
  jni.JniObject getSyncedTables() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSyncedTables, jni.JniType.objectType, []).object);

  static final _id_openDatabase = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "openDatabase",
      "(Ljava/lang/String;Landroid/database/sqlite/SQLiteDatabase\$CursorFactory;I)Landroid/database/sqlite/SQLiteDatabase;");

  /// from: static public android.database.sqlite.SQLiteDatabase openDatabase(java.lang.String path, android.database.sqlite.SQLiteDatabase.CursorFactory factory, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open the database according to the flags \#OPEN_READWRITE
  /// \#OPEN_READONLY \#CREATE_IF_NECESSARY and/or \#NO_LOCALIZED_COLLATORS.
  ///
  /// Sets the locale of the database to the  the system's current locale.
  /// Call \#setLocale if you would like something else.
  ///
  ///@param path to database file to open and/or create
  /// This value must never be {@code null}.
  ///@param factory an optional factory class that is called to instantiate a
  ///            cursor when query is called, or null for default
  /// This value may be {@code null}.
  ///@param flags to control database access mode
  /// Value is either <code>0</code> or a combination of android.database.sqlite.SQLiteDatabase\#OPEN_READWRITE, android.database.sqlite.SQLiteDatabase\#OPEN_READONLY, android.database.sqlite.SQLiteDatabase\#CREATE_IF_NECESSARY, android.database.sqlite.SQLiteDatabase\#NO_LOCALIZED_COLLATORS, and android.database.sqlite.SQLiteDatabase\#ENABLE_WRITE_AHEAD_LOGGING
  ///@return the newly opened database
  ///@throws SQLiteException if the database cannot be opened
  static SQLiteDatabase openDatabase(jni.JniString path,
          SQLiteDatabase_CursorFactory factory0, int flags) =>
      SQLiteDatabase.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_openDatabase,
          jni.JniType.objectType,
          [path.reference, factory0.reference, flags]).object);

  static final _id_openDatabase1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "openDatabase",
      "(Ljava/io/File;Landroid/database/sqlite/SQLiteDatabase\$OpenParams;)Landroid/database/sqlite/SQLiteDatabase;");

  /// from: static public android.database.sqlite.SQLiteDatabase openDatabase(java.io.File path, android.database.sqlite.SQLiteDatabase.OpenParams openParams)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open the database according to the specified OpenParams parameters
  ///@param path path to database file to open and/or create.
  /// <strong>Important:</strong> The file should be constructed either from an absolute path or
  /// by using android.content.Context\#getDatabasePath(String).
  /// This value must never be {@code null}.
  ///@param openParams configuration parameters that are used for opening SQLiteDatabase
  /// This value must never be {@code null}.
  ///@return the newly opened database
  ///@throws SQLiteException if the database cannot be opened
  static SQLiteDatabase openDatabase1(
          jni.JniObject path, SQLiteDatabase_OpenParams openParams) =>
      SQLiteDatabase.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_openDatabase1,
          jni.JniType.objectType,
          [path.reference, openParams.reference]).object);

  static final _id_openDatabase2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "openDatabase",
      "(Ljava/lang/String;Landroid/database/sqlite/SQLiteDatabase\$CursorFactory;ILandroid/database/DatabaseErrorHandler;)Landroid/database/sqlite/SQLiteDatabase;");

  /// from: static public android.database.sqlite.SQLiteDatabase openDatabase(java.lang.String path, android.database.sqlite.SQLiteDatabase.CursorFactory factory, int flags, android.database.DatabaseErrorHandler errorHandler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open the database according to the flags \#OPEN_READWRITE
  /// \#OPEN_READONLY \#CREATE_IF_NECESSARY and/or \#NO_LOCALIZED_COLLATORS.
  ///
  /// Sets the locale of the database to the  the system's current locale.
  /// Call \#setLocale if you would like something else.
  ///
  ///
  /// Accepts input param: a concrete instance of DatabaseErrorHandler to be
  /// used to handle corruption when sqlite reports database corruption.
  ///
  ///@param path to database file to open and/or create
  /// This value must never be {@code null}.
  ///@param factory an optional factory class that is called to instantiate a
  ///            cursor when query is called, or null for default
  /// This value may be {@code null}.
  ///@param flags to control database access mode
  /// Value is either <code>0</code> or a combination of android.database.sqlite.SQLiteDatabase\#OPEN_READWRITE, android.database.sqlite.SQLiteDatabase\#OPEN_READONLY, android.database.sqlite.SQLiteDatabase\#CREATE_IF_NECESSARY, android.database.sqlite.SQLiteDatabase\#NO_LOCALIZED_COLLATORS, and android.database.sqlite.SQLiteDatabase\#ENABLE_WRITE_AHEAD_LOGGING
  ///@param errorHandler the DatabaseErrorHandler obj to be used to handle corruption
  /// when sqlite reports database corruption
  /// This value may be {@code null}.
  ///@return the newly opened database
  ///@throws SQLiteException if the database cannot be opened
  static SQLiteDatabase openDatabase2(
          jni.JniString path,
          SQLiteDatabase_CursorFactory factory0,
          int flags,
          databaseerrorhandler_.DatabaseErrorHandler errorHandler) =>
      SQLiteDatabase.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_openDatabase2, jni.JniType.objectType, [
        path.reference,
        factory0.reference,
        flags,
        errorHandler.reference
      ]).object);

  static final _id_openOrCreateDatabase = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "openOrCreateDatabase",
      "(Ljava/io/File;Landroid/database/sqlite/SQLiteDatabase\$CursorFactory;)Landroid/database/sqlite/SQLiteDatabase;");

  /// from: static public android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.io.File file, android.database.sqlite.SQLiteDatabase.CursorFactory factory)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Equivalent to openDatabase(file.getPath(), factory, CREATE_IF_NECESSARY).
  ///@param file This value must never be {@code null}.
  ///@param factory This value may be {@code null}.
  static SQLiteDatabase openOrCreateDatabase(
          jni.JniObject file, SQLiteDatabase_CursorFactory factory0) =>
      SQLiteDatabase.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_openOrCreateDatabase,
          jni.JniType.objectType,
          [file.reference, factory0.reference]).object);

  static final _id_openOrCreateDatabase1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "openOrCreateDatabase",
      "(Ljava/lang/String;Landroid/database/sqlite/SQLiteDatabase\$CursorFactory;)Landroid/database/sqlite/SQLiteDatabase;");

  /// from: static public android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.lang.String path, android.database.sqlite.SQLiteDatabase.CursorFactory factory)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Equivalent to openDatabase(path, factory, CREATE_IF_NECESSARY).
  ///@param path This value must never be {@code null}.
  ///@param factory This value may be {@code null}.
  static SQLiteDatabase openOrCreateDatabase1(
          jni.JniString path, SQLiteDatabase_CursorFactory factory0) =>
      SQLiteDatabase.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_openOrCreateDatabase1,
          jni.JniType.objectType,
          [path.reference, factory0.reference]).object);

  static final _id_openOrCreateDatabase2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "openOrCreateDatabase",
      "(Ljava/lang/String;Landroid/database/sqlite/SQLiteDatabase\$CursorFactory;Landroid/database/DatabaseErrorHandler;)Landroid/database/sqlite/SQLiteDatabase;");

  /// from: static public android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.lang.String path, android.database.sqlite.SQLiteDatabase.CursorFactory factory, android.database.DatabaseErrorHandler errorHandler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Equivalent to openDatabase(path, factory, CREATE_IF_NECESSARY, errorHandler).
  ///@param path This value must never be {@code null}.
  ///@param factory This value may be {@code null}.
  ///@param errorHandler This value may be {@code null}.
  static SQLiteDatabase openOrCreateDatabase2(
          jni.JniString path,
          SQLiteDatabase_CursorFactory factory0,
          databaseerrorhandler_.DatabaseErrorHandler errorHandler) =>
      SQLiteDatabase.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_openOrCreateDatabase2,
          jni.JniType.objectType,
          [path.reference, factory0.reference, errorHandler.reference]).object);

  static final _id_deleteDatabase = jniAccessors.getStaticMethodIDOf(
      _classRef, "deleteDatabase", "(Ljava/io/File;)Z");

  /// from: static public boolean deleteDatabase(java.io.File file)
  ///
  /// Deletes a database including its journal file and other auxiliary files
  /// that may have been created by the database engine.
  ///@param file The database file path.
  /// This value must never be {@code null}.
  ///@return True if the database was successfully deleted.
  static bool deleteDatabase(jni.JniObject file) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_deleteDatabase,
          jni.JniType.booleanType, [file.reference]).boolean;

  static final _id_create = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "create",
      "(Landroid/database/sqlite/SQLiteDatabase\$CursorFactory;)Landroid/database/sqlite/SQLiteDatabase;");

  /// from: static public android.database.sqlite.SQLiteDatabase create(android.database.sqlite.SQLiteDatabase.CursorFactory factory)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a memory backed SQLite database.  Its contents will be destroyed
  /// when the database is closed.
  ///
  /// Sets the locale of the database to the  the system's current locale.
  /// Call \#setLocale if you would like something else.
  ///
  ///@param factory an optional factory class that is called to instantiate a
  ///            cursor when query is called
  /// This value may be {@code null}.
  ///@return a SQLiteDatabase instance
  /// This value will never be {@code null}.
  ///@throws SQLiteException if the database cannot be created
  static SQLiteDatabase create(SQLiteDatabase_CursorFactory factory0) =>
      SQLiteDatabase.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_create, jni.JniType.objectType, [factory0.reference]).object);

  static final _id_createInMemory = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createInMemory",
      "(Landroid/database/sqlite/SQLiteDatabase\$OpenParams;)Landroid/database/sqlite/SQLiteDatabase;");

  /// from: static public android.database.sqlite.SQLiteDatabase createInMemory(android.database.sqlite.SQLiteDatabase.OpenParams openParams)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a memory backed SQLite database.  Its contents will be destroyed
  /// when the database is closed.
  ///
  /// Sets the locale of the database to the  the system's current locale.
  /// Call \#setLocale if you would like something else.
  ///
  ///@param openParams configuration parameters that are used for opening SQLiteDatabase
  /// This value must never be {@code null}.
  ///@return a SQLiteDatabase instance
  /// This value will never be {@code null}.
  ///@throws SQLException if the database cannot be created
  static SQLiteDatabase createInMemory(SQLiteDatabase_OpenParams openParams) =>
      SQLiteDatabase.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createInMemory,
          jni.JniType.objectType,
          [openParams.reference]).object);

  static final _id_getVersion =
      jniAccessors.getMethodIDOf(_classRef, "getVersion", "()I");

  /// from: public int getVersion()
  ///
  /// Gets the database version.
  ///@return the database version
  int getVersion() => jniAccessors.callMethodWithArgs(
      reference, _id_getVersion, jni.JniType.intType, []).integer;

  static final _id_setVersion =
      jniAccessors.getMethodIDOf(_classRef, "setVersion", "(I)V");

  /// from: public void setVersion(int version)
  ///
  /// Sets the database version.
  ///@param version the new database version
  void setVersion(int version) => jniAccessors.callMethodWithArgs(
      reference, _id_setVersion, jni.JniType.voidType, [version]).check();

  static final _id_getMaximumSize =
      jniAccessors.getMethodIDOf(_classRef, "getMaximumSize", "()J");

  /// from: public long getMaximumSize()
  ///
  /// Returns the maximum size the database may grow to.
  ///@return the new maximum database size
  int getMaximumSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaximumSize, jni.JniType.longType, []).long;

  static final _id_setMaximumSize =
      jniAccessors.getMethodIDOf(_classRef, "setMaximumSize", "(J)J");

  /// from: public long setMaximumSize(long numBytes)
  ///
  /// Sets the maximum size the database will grow to. The maximum size cannot
  /// be set below the current size.
  ///@param numBytes the maximum database size, in bytes
  ///@return the new maximum database size
  int setMaximumSize(int numBytes) => jniAccessors.callMethodWithArgs(
      reference, _id_setMaximumSize, jni.JniType.longType, [numBytes]).long;

  static final _id_getPageSize =
      jniAccessors.getMethodIDOf(_classRef, "getPageSize", "()J");

  /// from: public long getPageSize()
  ///
  /// Returns the current database page size, in bytes.
  ///@return the database page size, in bytes
  int getPageSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getPageSize, jni.JniType.longType, []).long;

  static final _id_setPageSize =
      jniAccessors.getMethodIDOf(_classRef, "setPageSize", "(J)V");

  /// from: public void setPageSize(long numBytes)
  ///
  /// Sets the database page size. The page size must be a power of two. This
  /// method does not work if any data has been written to the database file,
  /// and must be called right after the database has been created.
  ///@param numBytes the database page size, in bytes
  void setPageSize(int numBytes) => jniAccessors.callMethodWithArgs(
      reference, _id_setPageSize, jni.JniType.voidType, [numBytes]).check();

  static final _id_markTableSyncable = jniAccessors.getMethodIDOf(_classRef,
      "markTableSyncable", "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void markTableSyncable(java.lang.String table, java.lang.String deletedTable)
  ///
  /// Mark this table as syncable. When an update occurs in this table the
  /// _sync_dirty field will be set to ensure proper syncing operation.
  ///@param table the table to mark as syncable
  ///@param deletedTable The deleted table that corresponds to the
  ///          syncable table
  ///@deprecated This method no longer serves any useful purpose and has been deprecated.
  void markTableSyncable(jni.JniString table, jni.JniString deletedTable) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_markTableSyncable,
          jni.JniType.voidType,
          [table.reference, deletedTable.reference]).check();

  static final _id_markTableSyncable1 = jniAccessors.getMethodIDOf(
      _classRef,
      "markTableSyncable",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void markTableSyncable(java.lang.String table, java.lang.String foreignKey, java.lang.String updateTable)
  ///
  /// Mark this table as syncable, with the _sync_dirty residing in another
  /// table. When an update occurs in this table the _sync_dirty field of the
  /// row in updateTable with the _id in foreignKey will be set to
  /// ensure proper syncing operation.
  ///@param table an update on this table will trigger a sync time removal
  ///@param foreignKey this is the column in table whose value is an _id in
  ///          updateTable
  ///@param updateTable this is the table that will have its _sync_dirty
  ///@deprecated This method no longer serves any useful purpose and has been deprecated.
  void markTableSyncable1(jni.JniString table, jni.JniString foreignKey,
          jni.JniString updateTable) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_markTableSyncable1, jni.JniType.voidType, [
        table.reference,
        foreignKey.reference,
        updateTable.reference
      ]).check();

  static final _id_findEditTable = jniAccessors.getStaticMethodIDOf(
      _classRef, "findEditTable", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String findEditTable(java.lang.String tables)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Finds the name of the first table, which is editable.
  ///@param tables a list of tables
  ///@return the first table listed
  static jni.JniString findEditTable(jni.JniString tables) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_findEditTable,
          jni.JniType.objectType,
          [tables.reference]).object);

  static final _id_compileStatement = jniAccessors.getMethodIDOf(
      _classRef,
      "compileStatement",
      "(Ljava/lang/String;)Landroid/database/sqlite/SQLiteStatement;");

  /// from: public android.database.sqlite.SQLiteStatement compileStatement(java.lang.String sql)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Compiles an SQL statement into a reusable pre-compiled statement object.
  /// The parameters are identical to \#execSQL(String). You may put ?s in the
  /// statement and fill in those values with SQLiteProgram\#bindString
  /// and SQLiteProgram\#bindLong each time you want to run the
  /// statement. Statements may not return result sets larger than 1x1.
  ///
  /// No two threads should be using the same SQLiteStatement at the same time.
  ///@param sql The raw SQL statement, may contain ? for unknown values to be
  ///            bound later.
  ///@return A pre-compiled SQLiteStatement object. Note that
  /// SQLiteStatements are not synchronized, see the documentation for more details.
  sqlitestatement_.SQLiteStatement compileStatement(jni.JniString sql) =>
      sqlitestatement_.SQLiteStatement.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_compileStatement,
          jni.JniType.objectType,
          [sql.reference]).object);

  static final _id_query = jniAccessors.getMethodIDOf(_classRef, "query",
      "(ZLjava/lang/String;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor query(boolean distinct, java.lang.String table, java.lang.String[] columns, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String groupBy, java.lang.String having, java.lang.String orderBy, java.lang.String limit)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the given URL, returning a Cursor over the result set.
  ///@param distinct true if you want each row to be unique, false otherwise.
  ///@param table The table name to compile the query against.
  ///@param columns A list of which columns to return. Passing null will
  ///            return all columns, which is discouraged to prevent reading
  ///            data from storage that isn't going to be used.
  ///@param selection A filter declaring which rows to return, formatted as an
  ///            SQL WHERE clause (excluding the WHERE itself). Passing null
  ///            will return all rows for the given table.
  ///@param selectionArgs You may include ?s in selection, which will be
  ///         replaced by the values from selectionArgs, in order that they
  ///         appear in the selection. The values will be bound as Strings.
  ///@param groupBy A filter declaring how to group rows, formatted as an SQL
  ///            GROUP BY clause (excluding the GROUP BY itself). Passing null
  ///            will cause the rows to not be grouped.
  ///@param having A filter declare which row groups to include in the cursor,
  ///            if row grouping is being used, formatted as an SQL HAVING
  ///            clause (excluding the HAVING itself). Passing null will cause
  ///            all row groups to be included, and is required when row
  ///            grouping is not being used.
  ///@param orderBy How to order the rows, formatted as an SQL ORDER BY clause
  ///            (excluding the ORDER BY itself). Passing null will use the
  ///            default sort order, which may be unordered.
  ///@param limit Limits the number of rows returned by the query,
  ///            formatted as LIMIT clause. Passing null denotes no LIMIT clause.
  ///@return A Cursor object, which is positioned before the first entry. Note that
  /// Cursors are not synchronized, see the documentation for more details.
  ///@see Cursor
  cursor_.Cursor query(
          bool distinct,
          jni.JniString table,
          jni.JniObject columns,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString groupBy,
          jni.JniString having,
          jni.JniString orderBy,
          jni.JniString limit) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query, jni.JniType.objectType, [
        distinct,
        table.reference,
        columns.reference,
        selection.reference,
        selectionArgs.reference,
        groupBy.reference,
        having.reference,
        orderBy.reference,
        limit.reference
      ]).object);

  static final _id_query1 = jniAccessors.getMethodIDOf(_classRef, "query",
      "(ZLjava/lang/String;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor query(boolean distinct, java.lang.String table, java.lang.String[] columns, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String groupBy, java.lang.String having, java.lang.String orderBy, java.lang.String limit, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the given URL, returning a Cursor over the result set.
  ///@param distinct true if you want each row to be unique, false otherwise.
  ///@param table The table name to compile the query against.
  ///@param columns A list of which columns to return. Passing null will
  ///            return all columns, which is discouraged to prevent reading
  ///            data from storage that isn't going to be used.
  ///@param selection A filter declaring which rows to return, formatted as an
  ///            SQL WHERE clause (excluding the WHERE itself). Passing null
  ///            will return all rows for the given table.
  ///@param selectionArgs You may include ?s in selection, which will be
  ///         replaced by the values from selectionArgs, in order that they
  ///         appear in the selection. The values will be bound as Strings.
  ///@param groupBy A filter declaring how to group rows, formatted as an SQL
  ///            GROUP BY clause (excluding the GROUP BY itself). Passing null
  ///            will cause the rows to not be grouped.
  ///@param having A filter declare which row groups to include in the cursor,
  ///            if row grouping is being used, formatted as an SQL HAVING
  ///            clause (excluding the HAVING itself). Passing null will cause
  ///            all row groups to be included, and is required when row
  ///            grouping is not being used.
  ///@param orderBy How to order the rows, formatted as an SQL ORDER BY clause
  ///            (excluding the ORDER BY itself). Passing null will use the
  ///            default sort order, which may be unordered.
  ///@param limit Limits the number of rows returned by the query,
  ///            formatted as LIMIT clause. Passing null denotes no LIMIT clause.
  ///@param cancellationSignal A signal to cancel the operation in progress, or null if none.
  /// If the operation is canceled, then OperationCanceledException will be thrown
  /// when the query is executed.
  ///@return A Cursor object, which is positioned before the first entry. Note that
  /// Cursors are not synchronized, see the documentation for more details.
  ///@see Cursor
  cursor_.Cursor query1(
          bool distinct,
          jni.JniString table,
          jni.JniObject columns,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString groupBy,
          jni.JniString having,
          jni.JniString orderBy,
          jni.JniString limit,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query1, jni.JniType.objectType, [
        distinct,
        table.reference,
        columns.reference,
        selection.reference,
        selectionArgs.reference,
        groupBy.reference,
        having.reference,
        orderBy.reference,
        limit.reference,
        cancellationSignal.reference
      ]).object);

  static final _id_queryWithFactory = jniAccessors.getMethodIDOf(
      _classRef,
      "queryWithFactory",
      "(Landroid/database/sqlite/SQLiteDatabase\$CursorFactory;ZLjava/lang/String;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor queryWithFactory(android.database.sqlite.SQLiteDatabase.CursorFactory cursorFactory, boolean distinct, java.lang.String table, java.lang.String[] columns, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String groupBy, java.lang.String having, java.lang.String orderBy, java.lang.String limit)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the given URL, returning a Cursor over the result set.
  ///@param cursorFactory the cursor factory to use, or null for the default factory
  ///@param distinct true if you want each row to be unique, false otherwise.
  ///@param table The table name to compile the query against.
  ///@param columns A list of which columns to return. Passing null will
  ///            return all columns, which is discouraged to prevent reading
  ///            data from storage that isn't going to be used.
  ///@param selection A filter declaring which rows to return, formatted as an
  ///            SQL WHERE clause (excluding the WHERE itself). Passing null
  ///            will return all rows for the given table.
  ///@param selectionArgs You may include ?s in selection, which will be
  ///         replaced by the values from selectionArgs, in order that they
  ///         appear in the selection. The values will be bound as Strings.
  ///@param groupBy A filter declaring how to group rows, formatted as an SQL
  ///            GROUP BY clause (excluding the GROUP BY itself). Passing null
  ///            will cause the rows to not be grouped.
  ///@param having A filter declare which row groups to include in the cursor,
  ///            if row grouping is being used, formatted as an SQL HAVING
  ///            clause (excluding the HAVING itself). Passing null will cause
  ///            all row groups to be included, and is required when row
  ///            grouping is not being used.
  ///@param orderBy How to order the rows, formatted as an SQL ORDER BY clause
  ///            (excluding the ORDER BY itself). Passing null will use the
  ///            default sort order, which may be unordered.
  ///@param limit Limits the number of rows returned by the query,
  ///            formatted as LIMIT clause. Passing null denotes no LIMIT clause.
  ///@return A Cursor object, which is positioned before the first entry. Note that
  /// Cursors are not synchronized, see the documentation for more details.
  ///@see Cursor
  cursor_.Cursor queryWithFactory(
          SQLiteDatabase_CursorFactory cursorFactory,
          bool distinct,
          jni.JniString table,
          jni.JniObject columns,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString groupBy,
          jni.JniString having,
          jni.JniString orderBy,
          jni.JniString limit) =>
      cursor_.Cursor.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_queryWithFactory, jni.JniType.objectType, [
        cursorFactory.reference,
        distinct,
        table.reference,
        columns.reference,
        selection.reference,
        selectionArgs.reference,
        groupBy.reference,
        having.reference,
        orderBy.reference,
        limit.reference
      ]).object);

  static final _id_queryWithFactory1 = jniAccessors.getMethodIDOf(
      _classRef,
      "queryWithFactory",
      "(Landroid/database/sqlite/SQLiteDatabase\$CursorFactory;ZLjava/lang/String;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor queryWithFactory(android.database.sqlite.SQLiteDatabase.CursorFactory cursorFactory, boolean distinct, java.lang.String table, java.lang.String[] columns, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String groupBy, java.lang.String having, java.lang.String orderBy, java.lang.String limit, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the given URL, returning a Cursor over the result set.
  ///@param cursorFactory the cursor factory to use, or null for the default factory
  ///@param distinct true if you want each row to be unique, false otherwise.
  ///@param table The table name to compile the query against.
  ///@param columns A list of which columns to return. Passing null will
  ///            return all columns, which is discouraged to prevent reading
  ///            data from storage that isn't going to be used.
  ///@param selection A filter declaring which rows to return, formatted as an
  ///            SQL WHERE clause (excluding the WHERE itself). Passing null
  ///            will return all rows for the given table.
  ///@param selectionArgs You may include ?s in selection, which will be
  ///         replaced by the values from selectionArgs, in order that they
  ///         appear in the selection. The values will be bound as Strings.
  ///@param groupBy A filter declaring how to group rows, formatted as an SQL
  ///            GROUP BY clause (excluding the GROUP BY itself). Passing null
  ///            will cause the rows to not be grouped.
  ///@param having A filter declare which row groups to include in the cursor,
  ///            if row grouping is being used, formatted as an SQL HAVING
  ///            clause (excluding the HAVING itself). Passing null will cause
  ///            all row groups to be included, and is required when row
  ///            grouping is not being used.
  ///@param orderBy How to order the rows, formatted as an SQL ORDER BY clause
  ///            (excluding the ORDER BY itself). Passing null will use the
  ///            default sort order, which may be unordered.
  ///@param limit Limits the number of rows returned by the query,
  ///            formatted as LIMIT clause. Passing null denotes no LIMIT clause.
  ///@param cancellationSignal A signal to cancel the operation in progress, or null if none.
  /// If the operation is canceled, then OperationCanceledException will be thrown
  /// when the query is executed.
  ///@return A Cursor object, which is positioned before the first entry. Note that
  /// Cursors are not synchronized, see the documentation for more details.
  ///@see Cursor
  cursor_.Cursor queryWithFactory1(
          SQLiteDatabase_CursorFactory cursorFactory,
          bool distinct,
          jni.JniString table,
          jni.JniObject columns,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString groupBy,
          jni.JniString having,
          jni.JniString orderBy,
          jni.JniString limit,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      cursor_.Cursor.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_queryWithFactory1, jni.JniType.objectType, [
        cursorFactory.reference,
        distinct,
        table.reference,
        columns.reference,
        selection.reference,
        selectionArgs.reference,
        groupBy.reference,
        having.reference,
        orderBy.reference,
        limit.reference,
        cancellationSignal.reference
      ]).object);

  static final _id_query2 = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor query(java.lang.String table, java.lang.String[] columns, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String groupBy, java.lang.String having, java.lang.String orderBy)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the given table, returning a Cursor over the result set.
  ///@param table The table name to compile the query against.
  ///@param columns A list of which columns to return. Passing null will
  ///            return all columns, which is discouraged to prevent reading
  ///            data from storage that isn't going to be used.
  ///@param selection A filter declaring which rows to return, formatted as an
  ///            SQL WHERE clause (excluding the WHERE itself). Passing null
  ///            will return all rows for the given table.
  ///@param selectionArgs You may include ?s in selection, which will be
  ///         replaced by the values from selectionArgs, in order that they
  ///         appear in the selection. The values will be bound as Strings.
  ///@param groupBy A filter declaring how to group rows, formatted as an SQL
  ///            GROUP BY clause (excluding the GROUP BY itself). Passing null
  ///            will cause the rows to not be grouped.
  ///@param having A filter declare which row groups to include in the cursor,
  ///            if row grouping is being used, formatted as an SQL HAVING
  ///            clause (excluding the HAVING itself). Passing null will cause
  ///            all row groups to be included, and is required when row
  ///            grouping is not being used.
  ///@param orderBy How to order the rows, formatted as an SQL ORDER BY clause
  ///            (excluding the ORDER BY itself). Passing null will use the
  ///            default sort order, which may be unordered.
  ///@return A Cursor object, which is positioned before the first entry. Note that
  /// Cursors are not synchronized, see the documentation for more details.
  ///@see Cursor
  cursor_.Cursor query2(
          jni.JniString table,
          jni.JniObject columns,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString groupBy,
          jni.JniString having,
          jni.JniString orderBy) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query2, jni.JniType.objectType, [
        table.reference,
        columns.reference,
        selection.reference,
        selectionArgs.reference,
        groupBy.reference,
        having.reference,
        orderBy.reference
      ]).object);

  static final _id_query3 = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor query(java.lang.String table, java.lang.String[] columns, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String groupBy, java.lang.String having, java.lang.String orderBy, java.lang.String limit)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the given table, returning a Cursor over the result set.
  ///@param table The table name to compile the query against.
  ///@param columns A list of which columns to return. Passing null will
  ///            return all columns, which is discouraged to prevent reading
  ///            data from storage that isn't going to be used.
  ///@param selection A filter declaring which rows to return, formatted as an
  ///            SQL WHERE clause (excluding the WHERE itself). Passing null
  ///            will return all rows for the given table.
  ///@param selectionArgs You may include ?s in selection, which will be
  ///         replaced by the values from selectionArgs, in order that they
  ///         appear in the selection. The values will be bound as Strings.
  ///@param groupBy A filter declaring how to group rows, formatted as an SQL
  ///            GROUP BY clause (excluding the GROUP BY itself). Passing null
  ///            will cause the rows to not be grouped.
  ///@param having A filter declare which row groups to include in the cursor,
  ///            if row grouping is being used, formatted as an SQL HAVING
  ///            clause (excluding the HAVING itself). Passing null will cause
  ///            all row groups to be included, and is required when row
  ///            grouping is not being used.
  ///@param orderBy How to order the rows, formatted as an SQL ORDER BY clause
  ///            (excluding the ORDER BY itself). Passing null will use the
  ///            default sort order, which may be unordered.
  ///@param limit Limits the number of rows returned by the query,
  ///            formatted as LIMIT clause. Passing null denotes no LIMIT clause.
  ///@return A Cursor object, which is positioned before the first entry. Note that
  /// Cursors are not synchronized, see the documentation for more details.
  ///@see Cursor
  cursor_.Cursor query3(
          jni.JniString table,
          jni.JniObject columns,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString groupBy,
          jni.JniString having,
          jni.JniString orderBy,
          jni.JniString limit) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query3, jni.JniType.objectType, [
        table.reference,
        columns.reference,
        selection.reference,
        selectionArgs.reference,
        groupBy.reference,
        having.reference,
        orderBy.reference,
        limit.reference
      ]).object);

  static final _id_rawQuery = jniAccessors.getMethodIDOf(_classRef, "rawQuery",
      "(Ljava/lang/String;[Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor rawQuery(java.lang.String sql, java.lang.String[] selectionArgs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Runs the provided SQL and returns a Cursor over the result set.
  ///@param sql the SQL query. The SQL string must not be ; terminated
  ///@param selectionArgs You may include ?s in where clause in the query,
  ///     which will be replaced by the values from selectionArgs. The
  ///     values will be bound as Strings.
  ///@return A Cursor object, which is positioned before the first entry. Note that
  /// Cursors are not synchronized, see the documentation for more details.
  cursor_.Cursor rawQuery(jni.JniString sql, jni.JniObject selectionArgs) =>
      cursor_.Cursor.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_rawQuery,
          jni.JniType.objectType,
          [sql.reference, selectionArgs.reference]).object);

  static final _id_rawQuery1 = jniAccessors.getMethodIDOf(_classRef, "rawQuery",
      "(Ljava/lang/String;[Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor rawQuery(java.lang.String sql, java.lang.String[] selectionArgs, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Runs the provided SQL and returns a Cursor over the result set.
  ///@param sql the SQL query. The SQL string must not be ; terminated
  ///@param selectionArgs You may include ?s in where clause in the query,
  ///     which will be replaced by the values from selectionArgs. The
  ///     values will be bound as Strings.
  ///@param cancellationSignal A signal to cancel the operation in progress, or null if none.
  /// If the operation is canceled, then OperationCanceledException will be thrown
  /// when the query is executed.
  ///@return A Cursor object, which is positioned before the first entry. Note that
  /// Cursors are not synchronized, see the documentation for more details.
  cursor_.Cursor rawQuery1(jni.JniString sql, jni.JniObject selectionArgs,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      cursor_.Cursor.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_rawQuery1, jni.JniType.objectType, [
        sql.reference,
        selectionArgs.reference,
        cancellationSignal.reference
      ]).object);

  static final _id_rawQueryWithFactory = jniAccessors.getMethodIDOf(
      _classRef,
      "rawQueryWithFactory",
      "(Landroid/database/sqlite/SQLiteDatabase\$CursorFactory;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor rawQueryWithFactory(android.database.sqlite.SQLiteDatabase.CursorFactory cursorFactory, java.lang.String sql, java.lang.String[] selectionArgs, java.lang.String editTable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Runs the provided SQL and returns a cursor over the result set.
  ///@param cursorFactory the cursor factory to use, or null for the default factory
  ///@param sql the SQL query. The SQL string must not be ; terminated
  ///@param selectionArgs You may include ?s in where clause in the query,
  ///     which will be replaced by the values from selectionArgs. The
  ///     values will be bound as Strings.
  ///@param editTable the name of the first table, which is editable
  ///@return A Cursor object, which is positioned before the first entry. Note that
  /// Cursors are not synchronized, see the documentation for more details.
  cursor_.Cursor rawQueryWithFactory(
          SQLiteDatabase_CursorFactory cursorFactory,
          jni.JniString sql,
          jni.JniObject selectionArgs,
          jni.JniString editTable) =>
      cursor_.Cursor.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_rawQueryWithFactory, jni.JniType.objectType, [
        cursorFactory.reference,
        sql.reference,
        selectionArgs.reference,
        editTable.reference
      ]).object);

  static final _id_rawQueryWithFactory1 = jniAccessors.getMethodIDOf(
      _classRef,
      "rawQueryWithFactory",
      "(Landroid/database/sqlite/SQLiteDatabase\$CursorFactory;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor rawQueryWithFactory(android.database.sqlite.SQLiteDatabase.CursorFactory cursorFactory, java.lang.String sql, java.lang.String[] selectionArgs, java.lang.String editTable, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Runs the provided SQL and returns a cursor over the result set.
  ///@param cursorFactory the cursor factory to use, or null for the default factory
  ///@param sql the SQL query. The SQL string must not be ; terminated
  ///@param selectionArgs You may include ?s in where clause in the query,
  ///     which will be replaced by the values from selectionArgs. The
  ///     values will be bound as Strings.
  ///@param editTable the name of the first table, which is editable
  ///@param cancellationSignal A signal to cancel the operation in progress, or null if none.
  /// If the operation is canceled, then OperationCanceledException will be thrown
  /// when the query is executed.
  ///@return A Cursor object, which is positioned before the first entry. Note that
  /// Cursors are not synchronized, see the documentation for more details.
  cursor_.Cursor rawQueryWithFactory1(
          SQLiteDatabase_CursorFactory cursorFactory,
          jni.JniString sql,
          jni.JniObject selectionArgs,
          jni.JniString editTable,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      cursor_.Cursor.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_rawQueryWithFactory1, jni.JniType.objectType, [
        cursorFactory.reference,
        sql.reference,
        selectionArgs.reference,
        editTable.reference,
        cancellationSignal.reference
      ]).object);

  static final _id_insert = jniAccessors.getMethodIDOf(_classRef, "insert",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/content/ContentValues;)J");

  /// from: public long insert(java.lang.String table, java.lang.String nullColumnHack, android.content.ContentValues values)
  ///
  /// Convenience method for inserting a row into the database.
  ///@param table the table to insert the row into
  ///@param nullColumnHack optional; may be <code>null</code>.
  ///            SQL doesn't allow inserting a completely empty row without
  ///            naming at least one column name.  If your provided <code>values</code> is
  ///            empty, no column names are known and an empty row can't be inserted.
  ///            If not set to null, the <code>nullColumnHack</code> parameter
  ///            provides the name of nullable column name to explicitly insert a NULL into
  ///            in the case where your <code>values</code> is empty.
  ///@param values this map contains the initial column values for the
  ///            row. The keys should be the column names and the values the
  ///            column values
  ///@return the row ID of the newly inserted row, or -1 if an error occurred
  int insert(jni.JniString table, jni.JniString nullColumnHack,
          contentvalues_.ContentValues values) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_insert,
          jni.JniType.longType,
          [table.reference, nullColumnHack.reference, values.reference]).long;

  static final _id_insertOrThrow = jniAccessors.getMethodIDOf(
      _classRef,
      "insertOrThrow",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/content/ContentValues;)J");

  /// from: public long insertOrThrow(java.lang.String table, java.lang.String nullColumnHack, android.content.ContentValues values)
  ///
  /// Convenience method for inserting a row into the database.
  ///@param table the table to insert the row into
  ///@param nullColumnHack optional; may be <code>null</code>.
  ///            SQL doesn't allow inserting a completely empty row without
  ///            naming at least one column name.  If your provided <code>values</code> is
  ///            empty, no column names are known and an empty row can't be inserted.
  ///            If not set to null, the <code>nullColumnHack</code> parameter
  ///            provides the name of nullable column name to explicitly insert a NULL into
  ///            in the case where your <code>values</code> is empty.
  ///@param values this map contains the initial column values for the
  ///            row. The keys should be the column names and the values the
  ///            column values
  ///@throws SQLException
  ///@return the row ID of the newly inserted row, or -1 if an error occurred
  int insertOrThrow(jni.JniString table, jni.JniString nullColumnHack,
          contentvalues_.ContentValues values) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_insertOrThrow,
          jni.JniType.longType,
          [table.reference, nullColumnHack.reference, values.reference]).long;

  static final _id_replace = jniAccessors.getMethodIDOf(_classRef, "replace",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/content/ContentValues;)J");

  /// from: public long replace(java.lang.String table, java.lang.String nullColumnHack, android.content.ContentValues initialValues)
  ///
  /// Convenience method for replacing a row in the database.
  /// Inserts a new row if a row does not already exist.
  ///@param table the table in which to replace the row
  ///@param nullColumnHack optional; may be <code>null</code>.
  ///            SQL doesn't allow inserting a completely empty row without
  ///            naming at least one column name.  If your provided <code>initialValues</code> is
  ///            empty, no column names are known and an empty row can't be inserted.
  ///            If not set to null, the <code>nullColumnHack</code> parameter
  ///            provides the name of nullable column name to explicitly insert a NULL into
  ///            in the case where your <code>initialValues</code> is empty.
  ///@param initialValues this map contains the initial column values for
  ///   the row. The keys should be the column names and the values the column values.
  ///@return the row ID of the newly inserted row, or -1 if an error occurred
  int replace(jni.JniString table, jni.JniString nullColumnHack,
          contentvalues_.ContentValues initialValues) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_replace, jni.JniType.longType, [
        table.reference,
        nullColumnHack.reference,
        initialValues.reference
      ]).long;

  static final _id_replaceOrThrow = jniAccessors.getMethodIDOf(
      _classRef,
      "replaceOrThrow",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/content/ContentValues;)J");

  /// from: public long replaceOrThrow(java.lang.String table, java.lang.String nullColumnHack, android.content.ContentValues initialValues)
  ///
  /// Convenience method for replacing a row in the database.
  /// Inserts a new row if a row does not already exist.
  ///@param table the table in which to replace the row
  ///@param nullColumnHack optional; may be <code>null</code>.
  ///            SQL doesn't allow inserting a completely empty row without
  ///            naming at least one column name.  If your provided <code>initialValues</code> is
  ///            empty, no column names are known and an empty row can't be inserted.
  ///            If not set to null, the <code>nullColumnHack</code> parameter
  ///            provides the name of nullable column name to explicitly insert a NULL into
  ///            in the case where your <code>initialValues</code> is empty.
  ///@param initialValues this map contains the initial column values for
  ///   the row. The keys should be the column names and the values the column values.
  ///@throws SQLException
  ///@return the row ID of the newly inserted row, or -1 if an error occurred
  int replaceOrThrow(jni.JniString table, jni.JniString nullColumnHack,
          contentvalues_.ContentValues initialValues) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_replaceOrThrow, jni.JniType.longType, [
        table.reference,
        nullColumnHack.reference,
        initialValues.reference
      ]).long;

  static final _id_insertWithOnConflict = jniAccessors.getMethodIDOf(
      _classRef,
      "insertWithOnConflict",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/content/ContentValues;I)J");

  /// from: public long insertWithOnConflict(java.lang.String table, java.lang.String nullColumnHack, android.content.ContentValues initialValues, int conflictAlgorithm)
  ///
  /// General method for inserting a row into the database.
  ///@param table the table to insert the row into
  ///@param nullColumnHack optional; may be <code>null</code>.
  ///            SQL doesn't allow inserting a completely empty row without
  ///            naming at least one column name.  If your provided <code>initialValues</code> is
  ///            empty, no column names are known and an empty row can't be inserted.
  ///            If not set to null, the <code>nullColumnHack</code> parameter
  ///            provides the name of nullable column name to explicitly insert a NULL into
  ///            in the case where your <code>initialValues</code> is empty.
  ///@param initialValues this map contains the initial column values for the
  ///            row. The keys should be the column names and the values the
  ///            column values
  ///@param conflictAlgorithm for insert conflict resolver
  ///@return the row ID of the newly inserted row OR <code>-1</code> if either the
  ///            input parameter <code>conflictAlgorithm</code> = \#CONFLICT_IGNORE
  ///            or an error occurred.
  int insertWithOnConflict(jni.JniString table, jni.JniString nullColumnHack,
          contentvalues_.ContentValues initialValues, int conflictAlgorithm) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_insertWithOnConflict, jni.JniType.longType, [
        table.reference,
        nullColumnHack.reference,
        initialValues.reference,
        conflictAlgorithm
      ]).long;

  static final _id_delete1 = jniAccessors.getMethodIDOf(_classRef, "delete",
      "(Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)I");

  /// from: public int delete(java.lang.String table, java.lang.String whereClause, java.lang.String[] whereArgs)
  ///
  /// Convenience method for deleting rows in the database.
  ///@param table the table to delete from
  ///@param whereClause the optional WHERE clause to apply when deleting.
  ///            Passing null will delete all rows.
  ///@param whereArgs You may include ?s in the where clause, which
  ///            will be replaced by the values from whereArgs. The values
  ///            will be bound as Strings.
  ///@return the number of rows affected if a whereClause is passed in, 0
  ///         otherwise. To remove all rows and get a count pass "1" as the
  ///         whereClause.
  int delete1(jni.JniString table, jni.JniString whereClause,
          jni.JniObject whereArgs) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_delete1, jni.JniType.intType, [
        table.reference,
        whereClause.reference,
        whereArgs.reference
      ]).integer;

  static final _id_update = jniAccessors.getMethodIDOf(_classRef, "update",
      "(Ljava/lang/String;Landroid/content/ContentValues;Ljava/lang/String;[Ljava/lang/String;)I");

  /// from: public int update(java.lang.String table, android.content.ContentValues values, java.lang.String whereClause, java.lang.String[] whereArgs)
  ///
  /// Convenience method for updating rows in the database.
  ///@param table the table to update in
  ///@param values a map from column names to new column values. null is a
  ///            valid value that will be translated to NULL.
  ///@param whereClause the optional WHERE clause to apply when updating.
  ///            Passing null will update all rows.
  ///@param whereArgs You may include ?s in the where clause, which
  ///            will be replaced by the values from whereArgs. The values
  ///            will be bound as Strings.
  ///@return the number of rows affected
  int update(jni.JniString table, contentvalues_.ContentValues values,
          jni.JniString whereClause, jni.JniObject whereArgs) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_update, jni.JniType.intType, [
        table.reference,
        values.reference,
        whereClause.reference,
        whereArgs.reference
      ]).integer;

  static final _id_updateWithOnConflict = jniAccessors.getMethodIDOf(
      _classRef,
      "updateWithOnConflict",
      "(Ljava/lang/String;Landroid/content/ContentValues;Ljava/lang/String;[Ljava/lang/String;I)I");

  /// from: public int updateWithOnConflict(java.lang.String table, android.content.ContentValues values, java.lang.String whereClause, java.lang.String[] whereArgs, int conflictAlgorithm)
  ///
  /// Convenience method for updating rows in the database.
  ///@param table the table to update in
  ///@param values a map from column names to new column values. null is a
  ///            valid value that will be translated to NULL.
  ///@param whereClause the optional WHERE clause to apply when updating.
  ///            Passing null will update all rows.
  ///@param whereArgs You may include ?s in the where clause, which
  ///            will be replaced by the values from whereArgs. The values
  ///            will be bound as Strings.
  ///@param conflictAlgorithm for update conflict resolver
  ///@return the number of rows affected
  int updateWithOnConflict(
          jni.JniString table,
          contentvalues_.ContentValues values,
          jni.JniString whereClause,
          jni.JniObject whereArgs,
          int conflictAlgorithm) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_updateWithOnConflict, jni.JniType.intType, [
        table.reference,
        values.reference,
        whereClause.reference,
        whereArgs.reference,
        conflictAlgorithm
      ]).integer;

  static final _id_execSQL =
      jniAccessors.getMethodIDOf(_classRef, "execSQL", "(Ljava/lang/String;)V");

  /// from: public void execSQL(java.lang.String sql)
  ///
  /// Execute a single SQL statement that is NOT a SELECT
  /// or any other SQL statement that returns data.
  ///
  /// It has no means to return any data (such as the number of affected rows).
  /// Instead, you're encouraged to use \#insert(String, String, ContentValues),
  /// \#update(String, ContentValues, String, String[]), et al, when possible.
  ///
  ///
  ///
  /// When using \#enableWriteAheadLogging(), journal_mode is
  /// automatically managed by this class. So, do not set journal_mode
  /// using "PRAGMA journal_mode'<value>" statement if your app is using
  /// \#enableWriteAheadLogging()
  ///
  ///
  ///@param sql the SQL statement to be executed. Multiple statements separated by semicolons are
  /// not supported.
  ///@throws SQLException if the SQL string is invalid
  void execSQL(jni.JniString sql) => jniAccessors.callMethodWithArgs(
      reference, _id_execSQL, jni.JniType.voidType, [sql.reference]).check();

  static final _id_execSQL1 = jniAccessors.getMethodIDOf(
      _classRef, "execSQL", "(Ljava/lang/String;[Ljava/lang/Object;)V");

  /// from: public void execSQL(java.lang.String sql, java.lang.Object[] bindArgs)
  ///
  /// Execute a single SQL statement that is NOT a SELECT/INSERT/UPDATE/DELETE.
  ///
  /// For INSERT statements, use any of the following instead.
  /// <ul>
  ///   <li>\#insert(String, String, ContentValues)</li>
  ///   <li>\#insertOrThrow(String, String, ContentValues)</li>
  ///   <li>\#insertWithOnConflict(String, String, ContentValues, int)</li>
  /// </ul>
  ///
  /// For UPDATE statements, use any of the following instead.
  /// <ul>
  ///   <li>\#update(String, ContentValues, String, String[])</li>
  ///   <li>\#updateWithOnConflict(String, ContentValues, String, String[], int)</li>
  /// </ul>
  ///
  /// For DELETE statements, use any of the following instead.
  /// <ul>
  ///   <li>\#delete(String, String, String[])</li>
  /// </ul>
  ///
  /// For example, the following are good candidates for using this method:
  /// <ul>
  ///   <li>ALTER TABLE</li>
  ///   <li>CREATE or DROP table / trigger / view / index / virtual table</li>
  ///   <li>REINDEX</li>
  ///   <li>RELEASE</li>
  ///   <li>SAVEPOINT</li>
  ///   <li>PRAGMA that returns no data</li>
  /// </ul>
  ///
  ///
  ///
  /// When using \#enableWriteAheadLogging(), journal_mode is
  /// automatically managed by this class. So, do not set journal_mode
  /// using "PRAGMA journal_mode'<value>" statement if your app is using
  /// \#enableWriteAheadLogging()
  ///
  ///
  ///@param sql the SQL statement to be executed. Multiple statements separated by semicolons are
  /// not supported.
  ///@param bindArgs only byte[], String, Long and Double are supported in bindArgs.
  ///@throws SQLException if the SQL string is invalid
  void execSQL1(jni.JniString sql, jni.JniObject bindArgs) =>
      jniAccessors.callMethodWithArgs(reference, _id_execSQL1,
          jni.JniType.voidType, [sql.reference, bindArgs.reference]).check();

  static final _id_validateSql = jniAccessors.getMethodIDOf(_classRef,
      "validateSql", "(Ljava/lang/String;Landroid/os/CancellationSignal;)V");

  /// from: public void validateSql(java.lang.String sql, android.os.CancellationSignal cancellationSignal)
  ///
  /// Verifies that a SQL SELECT statement is valid by compiling it.
  /// If the SQL statement is not valid, this method will throw a SQLiteException.
  ///@param sql SQL to be validated
  /// This value must never be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress, or null if none.
  /// If the operation is canceled, then OperationCanceledException will be thrown
  /// when the query is executed.
  /// This value may be {@code null}.
  ///@throws SQLiteException if {@code sql} is invalid
  void validateSql(jni.JniString sql,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_validateSql,
          jni.JniType.voidType,
          [sql.reference, cancellationSignal.reference]).check();

  static final _id_isReadOnly =
      jniAccessors.getMethodIDOf(_classRef, "isReadOnly", "()Z");

  /// from: public boolean isReadOnly()
  ///
  /// Returns true if the database is opened as read only.
  ///@return True if database is opened as read only.
  bool isReadOnly() => jniAccessors.callMethodWithArgs(
      reference, _id_isReadOnly, jni.JniType.booleanType, []).boolean;

  static final _id_isOpen =
      jniAccessors.getMethodIDOf(_classRef, "isOpen", "()Z");

  /// from: public boolean isOpen()
  ///
  /// Returns true if the database is currently open.
  ///@return True if the database is currently open (has not been closed).
  bool isOpen() => jniAccessors.callMethodWithArgs(
      reference, _id_isOpen, jni.JniType.booleanType, []).boolean;

  static final _id_needUpgrade =
      jniAccessors.getMethodIDOf(_classRef, "needUpgrade", "(I)Z");

  /// from: public boolean needUpgrade(int newVersion)
  ///
  /// Returns true if the new version code is greater than the current database version.
  ///@param newVersion The new version code.
  ///@return True if the new version code is greater than the current database version.
  bool needUpgrade(int newVersion) => jniAccessors.callMethodWithArgs(reference,
      _id_needUpgrade, jni.JniType.booleanType, [newVersion]).boolean;

  static final _id_getPath =
      jniAccessors.getMethodIDOf(_classRef, "getPath", "()Ljava/lang/String;");

  /// from: public java.lang.String getPath()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the path to the database file.
  ///@return The path to the database file.
  jni.JniString getPath() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPath, jni.JniType.objectType, []).object);

  static final _id_setLocale = jniAccessors.getMethodIDOf(
      _classRef, "setLocale", "(Ljava/util/Locale;)V");

  /// from: public void setLocale(java.util.Locale locale)
  ///
  /// Sets the locale for this database.  Does nothing if this database has
  /// the \#NO_LOCALIZED_COLLATORS flag set or was opened read only.
  ///@param locale The new locale.
  ///@throws SQLException if the locale could not be set.  The most common reason
  /// for this is that there is no collator available for the locale you requested.
  /// In this case the database remains unchanged.
  void setLocale(jni.JniObject locale) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLocale,
      jni.JniType.voidType,
      [locale.reference]).check();

  static final _id_setMaxSqlCacheSize =
      jniAccessors.getMethodIDOf(_classRef, "setMaxSqlCacheSize", "(I)V");

  /// from: public void setMaxSqlCacheSize(int cacheSize)
  ///
  /// Sets the maximum size of the prepared-statement cache for this database.
  /// (size of the cache = number of compiled-sql-statements stored in the cache).
  ///
  /// Maximum cache size can ONLY be increased from its current size (default = 10).
  /// If this method is called with smaller size than the current maximum value,
  /// then IllegalStateException is thrown.
  ///
  /// This method is thread-safe.
  ///@param cacheSize the size of the cache. can be (0 to \#MAX_SQL_CACHE_SIZE)
  ///@throws IllegalStateException if input cacheSize > \#MAX_SQL_CACHE_SIZE.
  void setMaxSqlCacheSize(int cacheSize) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMaxSqlCacheSize,
      jni.JniType.voidType,
      [cacheSize]).check();

  static final _id_setForeignKeyConstraintsEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setForeignKeyConstraintsEnabled", "(Z)V");

  /// from: public void setForeignKeyConstraintsEnabled(boolean enable)
  ///
  /// Sets whether foreign key constraints are enabled for the database.
  ///
  /// By default, foreign key constraints are not enforced by the database.
  /// This method allows an application to enable foreign key constraints.
  /// It must be called each time the database is opened to ensure that foreign
  /// key constraints are enabled for the session.
  ///
  ///
  /// A good time to call this method is right after calling \#openOrCreateDatabase
  /// or in the SQLiteOpenHelper\#onConfigure callback.
  ///
  ///
  /// When foreign key constraints are disabled, the database does not check whether
  /// changes to the database will violate foreign key constraints.  Likewise, when
  /// foreign key constraints are disabled, the database will not execute cascade
  /// delete or update triggers.  As a result, it is possible for the database
  /// state to become inconsistent.  To perform a database integrity check,
  /// call \#isDatabaseIntegrityOk.
  ///
  ///
  /// This method must not be called while a transaction is in progress.
  ///
  ///
  /// See also <a href="http://sqlite.org/foreignkeys.html">SQLite Foreign Key Constraints</a>
  /// for more details about foreign key constraint support.
  ///
  ///
  ///@param enable True to enable foreign key constraints, false to disable them.
  ///@throws IllegalStateException if the are transactions is in progress
  /// when this method is called.
  void setForeignKeyConstraintsEnabled(bool enable) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setForeignKeyConstraintsEnabled,
          jni.JniType.voidType,
          [enable]).check();

  static final _id_enableWriteAheadLogging =
      jniAccessors.getMethodIDOf(_classRef, "enableWriteAheadLogging", "()Z");

  /// from: public boolean enableWriteAheadLogging()
  ///
  /// This method enables parallel execution of queries from multiple threads on the
  /// same database.  It does this by opening multiple connections to the database
  /// and using a different database connection for each query.  The database
  /// journal mode is also changed to enable writes to proceed concurrently with reads.
  ///
  /// When write-ahead logging is not enabled (the default), it is not possible for
  /// reads and writes to occur on the database at the same time.  Before modifying the
  /// database, the writer implicitly acquires an exclusive lock on the database which
  /// prevents readers from accessing the database until the write is completed.
  ///
  ///
  /// In contrast, when write-ahead logging is enabled (by calling this method), write
  /// operations occur in a separate log file which allows reads to proceed concurrently.
  /// While a write is in progress, readers on other threads will perceive the state
  /// of the database as it was before the write began.  When the write completes, readers
  /// on other threads will then perceive the new state of the database.
  ///
  ///
  /// It is a good idea to enable write-ahead logging whenever a database will be
  /// concurrently accessed and modified by multiple threads at the same time.
  /// However, write-ahead logging uses significantly more memory than ordinary
  /// journaling because there are multiple connections to the same database.
  /// So if a database will only be used by a single thread, or if optimizing
  /// concurrency is not very important, then write-ahead logging should be disabled.
  ///
  ///
  /// After calling this method, execution of queries in parallel is enabled as long as
  /// the database remains open.  To disable execution of queries in parallel, either
  /// call \#disableWriteAheadLogging or close the database and reopen it.
  ///
  ///
  /// The maximum number of connections used to execute queries in parallel is
  /// dependent upon the device memory and possibly other properties.
  ///
  ///
  /// If a query is part of a transaction, then it is executed on the same database handle the
  /// transaction was begun.
  ///
  ///
  /// Writers should use \#beginTransactionNonExclusive() or
  /// \#beginTransactionWithListenerNonExclusive(SQLiteTransactionListener)
  /// to start a transaction.  Non-exclusive mode allows database file to be in readable
  /// by other threads executing queries.
  ///
  ///
  /// If the database has any attached databases, then execution of queries in parallel is NOT
  /// possible.  Likewise, write-ahead logging is not supported for read-only databases
  /// or memory databases.  In such cases, \#enableWriteAheadLogging returns false.
  ///
  ///
  /// The best way to enable write-ahead logging is to pass the
  /// \#ENABLE_WRITE_AHEAD_LOGGING flag to \#openDatabase.  This is
  /// more efficient than calling \#enableWriteAheadLogging.
  /// <code><pre>
  ///     SQLiteDatabase db = SQLiteDatabase.openDatabase("db_filename", cursorFactory,
  ///             SQLiteDatabase.CREATE_IF_NECESSARY | SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING,
  ///             myDatabaseErrorHandler);
  /// </pre></code>
  ///
  ///
  /// Another way to enable write-ahead logging is to call \#enableWriteAheadLogging
  /// after opening the database.
  /// <code><pre>
  ///     SQLiteDatabase db = SQLiteDatabase.openDatabase("db_filename", cursorFactory,
  ///             SQLiteDatabase.CREATE_IF_NECESSARY, myDatabaseErrorHandler);
  ///     db.enableWriteAheadLogging();
  /// </pre></code>
  ///
  ///
  /// See also <a href="http://sqlite.org/wal.html">SQLite Write-Ahead Logging</a> for
  /// more details about how write-ahead logging works.
  ///
  ///
  ///@return True if write-ahead logging is enabled.
  ///@throws IllegalStateException if there are transactions in progress at the
  /// time this method is called.  WAL mode can only be changed when there are no
  /// transactions in progress.
  ///@see \#ENABLE_WRITE_AHEAD_LOGGING
  ///@see \#disableWriteAheadLogging
  bool enableWriteAheadLogging() => jniAccessors.callMethodWithArgs(reference,
      _id_enableWriteAheadLogging, jni.JniType.booleanType, []).boolean;

  static final _id_disableWriteAheadLogging =
      jniAccessors.getMethodIDOf(_classRef, "disableWriteAheadLogging", "()V");

  /// from: public void disableWriteAheadLogging()
  ///
  /// This method disables the features enabled by \#enableWriteAheadLogging().
  ///@throws IllegalStateException if there are transactions in progress at the
  /// time this method is called.  WAL mode can only be changed when there are no
  /// transactions in progress.
  ///@see \#enableWriteAheadLogging
  void disableWriteAheadLogging() => jniAccessors.callMethodWithArgs(reference,
      _id_disableWriteAheadLogging, jni.JniType.voidType, []).check();

  static final _id_isWriteAheadLoggingEnabled = jniAccessors.getMethodIDOf(
      _classRef, "isWriteAheadLoggingEnabled", "()Z");

  /// from: public boolean isWriteAheadLoggingEnabled()
  ///
  /// Returns true if write-ahead logging has been enabled for this database.
  ///@return True if write-ahead logging has been enabled for this database.
  ///@see \#enableWriteAheadLogging
  ///@see \#ENABLE_WRITE_AHEAD_LOGGING
  bool isWriteAheadLoggingEnabled() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isWriteAheadLoggingEnabled,
      jni.JniType.booleanType, []).boolean;

  static final _id_getAttachedDbs = jniAccessors.getMethodIDOf(
      _classRef, "getAttachedDbs", "()Ljava/util/List;");

  /// from: public java.util.List<android.util.Pair<java.lang.String,java.lang.String>> getAttachedDbs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns list of full pathnames of all attached databases including the main database
  /// by executing 'pragma database_list' on the database.
  ///@return ArrayList of pairs of (database name, database file path) or null if the database
  /// is not open.
  jni.JniObject getAttachedDbs() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAttachedDbs, jni.JniType.objectType, []).object);

  static final _id_isDatabaseIntegrityOk =
      jniAccessors.getMethodIDOf(_classRef, "isDatabaseIntegrityOk", "()Z");

  /// from: public boolean isDatabaseIntegrityOk()
  ///
  /// Runs 'pragma integrity_check' on the given database (and all the attached databases)
  /// and returns true if the given database (and all its attached databases) pass integrity_check,
  /// false otherwise.
  ///
  /// If the result is false, then this method logs the errors reported by the integrity_check
  /// command execution.
  ///
  /// Note that 'pragma integrity_check' on a database can take a long time.
  ///@return true if the given database (and all its attached databases) pass integrity_check,
  /// false otherwise.
  bool isDatabaseIntegrityOk() => jniAccessors.callMethodWithArgs(reference,
      _id_isDatabaseIntegrityOk, jni.JniType.booleanType, []).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.database.sqlite.SQLiteDatabase$OpenParams
///
/// Wrapper for configuration parameters that are used for opening SQLiteDatabase
class SQLiteDatabase_OpenParams extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/database/sqlite/SQLiteDatabase\$OpenParams");
  SQLiteDatabase_OpenParams.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(ILandroid/database/sqlite/SQLiteDatabase\$CursorFactory;Landroid/database/DatabaseErrorHandler;IIJLjava/lang/String;Ljava/lang/String;)V");

  /// from: void <init>(int openFlags, android.database.sqlite.SQLiteDatabase.CursorFactory cursorFactory, android.database.DatabaseErrorHandler errorHandler, int lookasideSlotSize, int lookasideSlotCount, long idleConnectionTimeout, java.lang.String journalMode, java.lang.String syncMode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SQLiteDatabase_OpenParams(
      int openFlags,
      SQLiteDatabase_CursorFactory cursorFactory,
      databaseerrorhandler_.DatabaseErrorHandler errorHandler,
      int lookasideSlotSize,
      int lookasideSlotCount,
      int idleConnectionTimeout,
      jni.JniString journalMode,
      jni.JniString syncMode)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [
          openFlags,
          cursorFactory.reference,
          errorHandler.reference,
          lookasideSlotSize,
          lookasideSlotCount,
          idleConnectionTimeout,
          journalMode.reference,
          syncMode.reference
        ]).object);

  static final _id_getLookasideSlotSize =
      jniAccessors.getMethodIDOf(_classRef, "getLookasideSlotSize", "()I");

  /// from: public int getLookasideSlotSize()
  ///
  /// Returns size in bytes of each lookaside slot or -1 if not set.
  ///@see Builder\#setLookasideConfig(int, int)
  ///@return Value is -1 or greater
  int getLookasideSlotSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getLookasideSlotSize, jni.JniType.intType, []).integer;

  static final _id_getLookasideSlotCount =
      jniAccessors.getMethodIDOf(_classRef, "getLookasideSlotCount", "()I");

  /// from: public int getLookasideSlotCount()
  ///
  /// Returns total number of lookaside memory slots per database connection or -1 if not
  /// set.
  ///@see Builder\#setLookasideConfig(int, int)
  ///@return Value is -1 or greater
  int getLookasideSlotCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getLookasideSlotCount, jni.JniType.intType, []).integer;

  static final _id_getOpenFlags =
      jniAccessors.getMethodIDOf(_classRef, "getOpenFlags", "()I");

  /// from: public int getOpenFlags()
  ///
  /// Returns flags to control database access mode. Default value is 0.
  ///@see Builder\#setOpenFlags(int)
  ///@return Value is either <code>0</code> or a combination of android.database.sqlite.SQLiteDatabase\#OPEN_READWRITE, android.database.sqlite.SQLiteDatabase\#OPEN_READONLY, android.database.sqlite.SQLiteDatabase\#CREATE_IF_NECESSARY, android.database.sqlite.SQLiteDatabase\#NO_LOCALIZED_COLLATORS, and android.database.sqlite.SQLiteDatabase\#ENABLE_WRITE_AHEAD_LOGGING
  int getOpenFlags() => jniAccessors.callMethodWithArgs(
      reference, _id_getOpenFlags, jni.JniType.intType, []).integer;

  static final _id_getCursorFactory = jniAccessors.getMethodIDOf(
      _classRef,
      "getCursorFactory",
      "()Landroid/database/sqlite/SQLiteDatabase\$CursorFactory;");

  /// from: public android.database.sqlite.SQLiteDatabase.CursorFactory getCursorFactory()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an optional factory class that is called to instantiate a cursor when query
  /// is called
  ///@see Builder\#setCursorFactory(CursorFactory)
  ///@return This value may be {@code null}.
  SQLiteDatabase_CursorFactory getCursorFactory() =>
      SQLiteDatabase_CursorFactory.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCursorFactory, jni.JniType.objectType, []).object);

  static final _id_getErrorHandler = jniAccessors.getMethodIDOf(_classRef,
      "getErrorHandler", "()Landroid/database/DatabaseErrorHandler;");

  /// from: public android.database.DatabaseErrorHandler getErrorHandler()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns handler for database corruption errors
  ///@see Builder\#setErrorHandler(DatabaseErrorHandler)
  ///@return This value may be {@code null}.
  databaseerrorhandler_.DatabaseErrorHandler getErrorHandler() =>
      databaseerrorhandler_.DatabaseErrorHandler.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getErrorHandler,
              jni.JniType.objectType, []).object);

  static final _id_getIdleConnectionTimeout =
      jniAccessors.getMethodIDOf(_classRef, "getIdleConnectionTimeout", "()J");

  /// from: public long getIdleConnectionTimeout()
  ///
  /// Returns maximum number of milliseconds that SQLite connection is allowed to be idle
  /// before it is closed and removed from the pool.
  /// If the value isn't set, the timeout defaults to the system wide timeout
  ///@return timeout in milliseconds or -1 if the value wasn't set.
  int getIdleConnectionTimeout() => jniAccessors.callMethodWithArgs(
      reference, _id_getIdleConnectionTimeout, jni.JniType.longType, []).long;

  static final _id_getJournalMode = jniAccessors.getMethodIDOf(
      _classRef, "getJournalMode", "()Ljava/lang/String;");

  /// from: public java.lang.String getJournalMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns <a href="https://sqlite.org/pragma.html\#pragma_journal_mode">journal mode</a>.
  /// This journal mode will only be used if SQLiteDatabase\#ENABLE_WRITE_AHEAD_LOGGING
  /// flag is not set, otherwise a platform will use "WAL" journal mode.
  ///@see Builder\#setJournalMode(String)
  ///@return This value may be {@code null}.
  jni.JniString getJournalMode() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getJournalMode, jni.JniType.objectType, []).object);

  static final _id_getSynchronousMode = jniAccessors.getMethodIDOf(
      _classRef, "getSynchronousMode", "()Ljava/lang/String;");

  /// from: public java.lang.String getSynchronousMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns <a href="https://sqlite.org/pragma.html\#pragma_synchronous">synchronous mode</a>.
  /// If not set, a system wide default will be used.
  ///@see Builder\#setSynchronousMode(String)
  ///@return This value may be {@code null}.
  jni.JniString getSynchronousMode() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSynchronousMode, jni.JniType.objectType, []).object);
}

/// from: android.database.sqlite.SQLiteDatabase$OpenParams$Builder
///
/// Builder for OpenParams.
class SQLiteDatabase_OpenParams_Builder extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/database/sqlite/SQLiteDatabase\$OpenParams\$Builder");
  SQLiteDatabase_OpenParams_Builder.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  SQLiteDatabase_OpenParams_Builder()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/database/sqlite/SQLiteDatabase\$OpenParams;)V");

  /// from: public void <init>(android.database.sqlite.SQLiteDatabase.OpenParams params)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SQLiteDatabase_OpenParams_Builder.ctor1(SQLiteDatabase_OpenParams params)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [params.reference]).object);

  static final _id_setLookasideConfig = jniAccessors.getMethodIDOf(
      _classRef,
      "setLookasideConfig",
      "(II)Landroid/database/sqlite/SQLiteDatabase\$OpenParams\$Builder;");

  /// from: public android.database.sqlite.SQLiteDatabase.OpenParams.Builder setLookasideConfig(int slotSize, int slotCount)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Configures
  /// <a href="https://sqlite.org/malloc.html\#lookaside">lookaside memory allocator</a>
  ///
  /// SQLite default settings will be used, if this method isn't called.
  /// Use {@code setLookasideConfig(0,0)} to disable lookaside
  ///
  /// <strong>Note:</strong> Provided slotSize/slotCount configuration is just a
  /// recommendation. The system may choose different values depending on a device, e.g.
  /// lookaside allocations can be disabled on low-RAM devices
  ///@param slotSize The size in bytes of each lookaside slot.
  /// Value is 0 or greater
  ///@param slotCount The total number of lookaside memory slots per database connection.
  ///
  /// Value is 0 or greater
  SQLiteDatabase_OpenParams_Builder setLookasideConfig(
          int slotSize, int slotCount) =>
      SQLiteDatabase_OpenParams_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setLookasideConfig,
          jni.JniType.objectType,
          [slotSize, slotCount]).object);

  static final _id_setOpenFlags = jniAccessors.getMethodIDOf(
      _classRef,
      "setOpenFlags",
      "(I)Landroid/database/sqlite/SQLiteDatabase\$OpenParams\$Builder;");

  /// from: public android.database.sqlite.SQLiteDatabase.OpenParams.Builder setOpenFlags(int openFlags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets flags to control database access mode
  ///@param openFlags The new flags to set
  /// Value is either <code>0</code> or a combination of android.database.sqlite.SQLiteDatabase\#OPEN_READWRITE, android.database.sqlite.SQLiteDatabase\#OPEN_READONLY, android.database.sqlite.SQLiteDatabase\#CREATE_IF_NECESSARY, android.database.sqlite.SQLiteDatabase\#NO_LOCALIZED_COLLATORS, and android.database.sqlite.SQLiteDatabase\#ENABLE_WRITE_AHEAD_LOGGING
  ///@see \#OPEN_READWRITE
  ///@see \#OPEN_READONLY
  ///@see \#CREATE_IF_NECESSARY
  ///@see \#NO_LOCALIZED_COLLATORS
  ///@see \#ENABLE_WRITE_AHEAD_LOGGING
  ///@return same builder instance for chaining multiple calls into a single statement
  ///
  /// This value will never be {@code null}.
  SQLiteDatabase_OpenParams_Builder setOpenFlags(int openFlags) =>
      SQLiteDatabase_OpenParams_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setOpenFlags,
          jni.JniType.objectType,
          [openFlags]).object);

  static final _id_addOpenFlags = jniAccessors.getMethodIDOf(
      _classRef,
      "addOpenFlags",
      "(I)Landroid/database/sqlite/SQLiteDatabase\$OpenParams\$Builder;");

  /// from: public android.database.sqlite.SQLiteDatabase.OpenParams.Builder addOpenFlags(int openFlags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds flags to control database access mode
  ///@param openFlags The new flags to add
  /// Value is either <code>0</code> or a combination of android.database.sqlite.SQLiteDatabase\#OPEN_READWRITE, android.database.sqlite.SQLiteDatabase\#OPEN_READONLY, android.database.sqlite.SQLiteDatabase\#CREATE_IF_NECESSARY, android.database.sqlite.SQLiteDatabase\#NO_LOCALIZED_COLLATORS, and android.database.sqlite.SQLiteDatabase\#ENABLE_WRITE_AHEAD_LOGGING
  ///@return same builder instance for chaining multiple calls into a single statement
  ///
  /// This value will never be {@code null}.
  SQLiteDatabase_OpenParams_Builder addOpenFlags(int openFlags) =>
      SQLiteDatabase_OpenParams_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addOpenFlags,
          jni.JniType.objectType,
          [openFlags]).object);

  static final _id_removeOpenFlags = jniAccessors.getMethodIDOf(
      _classRef,
      "removeOpenFlags",
      "(I)Landroid/database/sqlite/SQLiteDatabase\$OpenParams\$Builder;");

  /// from: public android.database.sqlite.SQLiteDatabase.OpenParams.Builder removeOpenFlags(int openFlags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes database access mode flags
  ///@param openFlags Flags to remove
  /// Value is either <code>0</code> or a combination of android.database.sqlite.SQLiteDatabase\#OPEN_READWRITE, android.database.sqlite.SQLiteDatabase\#OPEN_READONLY, android.database.sqlite.SQLiteDatabase\#CREATE_IF_NECESSARY, android.database.sqlite.SQLiteDatabase\#NO_LOCALIZED_COLLATORS, and android.database.sqlite.SQLiteDatabase\#ENABLE_WRITE_AHEAD_LOGGING
  ///@return same builder instance for chaining multiple calls into a single statement
  ///
  /// This value will never be {@code null}.
  SQLiteDatabase_OpenParams_Builder removeOpenFlags(int openFlags) =>
      SQLiteDatabase_OpenParams_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_removeOpenFlags,
          jni.JniType.objectType,
          [openFlags]).object);

  static final _id_setCursorFactory = jniAccessors.getMethodIDOf(
      _classRef,
      "setCursorFactory",
      "(Landroid/database/sqlite/SQLiteDatabase\$CursorFactory;)Landroid/database/sqlite/SQLiteDatabase\$OpenParams\$Builder;");

  /// from: public android.database.sqlite.SQLiteDatabase.OpenParams.Builder setCursorFactory(android.database.sqlite.SQLiteDatabase.CursorFactory cursorFactory)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set an optional factory class that is called to instantiate a cursor when query
  /// is called.
  ///@param cursorFactory instance
  /// This value may be {@code null}.
  ///@return same builder instance for chaining multiple calls into a single statement
  ///
  /// This value will never be {@code null}.
  SQLiteDatabase_OpenParams_Builder setCursorFactory(
          SQLiteDatabase_CursorFactory cursorFactory) =>
      SQLiteDatabase_OpenParams_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setCursorFactory,
          jni.JniType.objectType,
          [cursorFactory.reference]).object);

  static final _id_setErrorHandler = jniAccessors.getMethodIDOf(
      _classRef,
      "setErrorHandler",
      "(Landroid/database/DatabaseErrorHandler;)Landroid/database/sqlite/SQLiteDatabase\$OpenParams\$Builder;");

  /// from: public android.database.sqlite.SQLiteDatabase.OpenParams.Builder setErrorHandler(android.database.DatabaseErrorHandler errorHandler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets DatabaseErrorHandler object to handle db corruption errors
  ///@param errorHandler This value may be {@code null}.
  ///@return This value will never be {@code null}.
  SQLiteDatabase_OpenParams_Builder setErrorHandler(
          databaseerrorhandler_.DatabaseErrorHandler errorHandler) =>
      SQLiteDatabase_OpenParams_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setErrorHandler,
          jni.JniType.objectType,
          [errorHandler.reference]).object);

  static final _id_setIdleConnectionTimeout = jniAccessors.getMethodIDOf(
      _classRef,
      "setIdleConnectionTimeout",
      "(J)Landroid/database/sqlite/SQLiteDatabase\$OpenParams\$Builder;");

  /// from: public android.database.sqlite.SQLiteDatabase.OpenParams.Builder setIdleConnectionTimeout(long idleConnectionTimeoutMs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the maximum number of milliseconds that SQLite connection is allowed to be idle
  /// before it is closed and removed from the pool.
  ///@param idleConnectionTimeoutMs timeout in milliseconds. Use Long\#MAX_VALUE
  /// to allow unlimited idle connections.
  ///
  /// Value is 0 or greater
  ///@return This value will never be {@code null}.
  SQLiteDatabase_OpenParams_Builder setIdleConnectionTimeout(
          int idleConnectionTimeoutMs) =>
      SQLiteDatabase_OpenParams_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setIdleConnectionTimeout,
          jni.JniType.objectType,
          [idleConnectionTimeoutMs]).object);

  static final _id_setJournalMode = jniAccessors.getMethodIDOf(
      _classRef,
      "setJournalMode",
      "(Ljava/lang/String;)Landroid/database/sqlite/SQLiteDatabase\$OpenParams\$Builder;");

  /// from: public android.database.sqlite.SQLiteDatabase.OpenParams.Builder setJournalMode(java.lang.String journalMode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets <a href="https://sqlite.org/pragma.html\#pragma_journal_mode">journal mode</a>
  /// to use when SQLiteDatabase\#ENABLE_WRITE_AHEAD_LOGGING flag is not set.
  ///@param journalMode This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  SQLiteDatabase_OpenParams_Builder setJournalMode(jni.JniString journalMode) =>
      SQLiteDatabase_OpenParams_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setJournalMode,
          jni.JniType.objectType,
          [journalMode.reference]).object);

  static final _id_setSynchronousMode = jniAccessors.getMethodIDOf(
      _classRef,
      "setSynchronousMode",
      "(Ljava/lang/String;)Landroid/database/sqlite/SQLiteDatabase\$OpenParams\$Builder;");

  /// from: public android.database.sqlite.SQLiteDatabase.OpenParams.Builder setSynchronousMode(java.lang.String syncMode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets <a href="https://sqlite.org/pragma.html\#pragma_synchronous">synchronous mode</a>
  /// .
  ///@param syncMode This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  SQLiteDatabase_OpenParams_Builder setSynchronousMode(
          jni.JniString syncMode) =>
      SQLiteDatabase_OpenParams_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setSynchronousMode,
          jni.JniType.objectType,
          [syncMode.reference]).object);

  static final _id_build = jniAccessors.getMethodIDOf(_classRef, "build",
      "()Landroid/database/sqlite/SQLiteDatabase\$OpenParams;");

  /// from: public android.database.sqlite.SQLiteDatabase.OpenParams build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an instance of OpenParams with the options that were previously set
  /// on this builder
  ///@return This value will never be {@code null}.
  SQLiteDatabase_OpenParams build() =>
      SQLiteDatabase_OpenParams.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_build, jni.JniType.objectType, []).object);
}

/// from: android.database.sqlite.SQLiteDatabase$CursorFactory
///
/// Used to allow returning sub-classes of Cursor when calling query.
class SQLiteDatabase_CursorFactory extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/database/sqlite/SQLiteDatabase\$CursorFactory");
  SQLiteDatabase_CursorFactory.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_newCursor = jniAccessors.getMethodIDOf(
      _classRef,
      "newCursor",
      "(Landroid/database/sqlite/SQLiteDatabase;Landroid/database/sqlite/SQLiteCursorDriver;Ljava/lang/String;Landroid/database/sqlite/SQLiteQuery;)Landroid/database/Cursor;");

  /// from: public abstract android.database.Cursor newCursor(android.database.sqlite.SQLiteDatabase db, android.database.sqlite.SQLiteCursorDriver masterQuery, java.lang.String editTable, android.database.sqlite.SQLiteQuery query)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See SQLiteCursor\#SQLiteCursor(SQLiteCursorDriver, String, SQLiteQuery).
  cursor_.Cursor newCursor(
          SQLiteDatabase db,
          sqlitecursordriver_.SQLiteCursorDriver masterQuery,
          jni.JniString editTable,
          sqlitequery_.SQLiteQuery query) =>
      cursor_.Cursor.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_newCursor, jni.JniType.objectType, [
        db.reference,
        masterQuery.reference,
        editTable.reference,
        query.reference
      ]).object);
}
