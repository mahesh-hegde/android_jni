// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "SQLiteDatabase.dart" as sqlitedatabase_;

import "../Cursor.dart" as cursor_;

import "../../os/CancellationSignal.dart" as cancellationsignal_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.database.sqlite.SQLiteQueryBuilder
///
/// This is a convenience class that helps build SQL queries to be sent to
/// SQLiteDatabase objects.
class SQLiteQueryBuilder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/database/sqlite/SQLiteQueryBuilder");
  SQLiteQueryBuilder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  SQLiteQueryBuilder()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setDistinct =
      jniAccessors.getMethodIDOf(_classRef, "setDistinct", "(Z)V");

  /// from: public void setDistinct(boolean distinct)
  ///
  /// Mark the query as DISTINCT.
  ///@param distinct if true the query is DISTINCT, otherwise it isn't
  void setDistinct(bool distinct) => jniAccessors.callMethodWithArgs(
      reference, _id_setDistinct, jni.JniType.voidType, [distinct]).check();

  static final _id_getTables = jniAccessors.getMethodIDOf(
      _classRef, "getTables", "()Ljava/lang/String;");

  /// from: public java.lang.String getTables()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of tables being queried
  ///@return the list of tables being queried
  jni.JniString getTables() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTables, jni.JniType.objectType, []).object);

  static final _id_setTables = jniAccessors.getMethodIDOf(
      _classRef, "setTables", "(Ljava/lang/String;)V");

  /// from: public void setTables(java.lang.String inTables)
  ///
  /// Sets the list of tables to query. Multiple tables can be specified to perform a join.
  /// For example:
  ///   setTables("foo, bar")
  ///   setTables("foo LEFT OUTER JOIN bar ON (foo.id = bar.foo_id)")
  ///@param inTables the list of tables to query on
  void setTables(jni.JniString inTables) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTables,
      jni.JniType.voidType,
      [inTables.reference]).check();

  static final _id_appendWhere = jniAccessors.getMethodIDOf(
      _classRef, "appendWhere", "(Ljava/lang/CharSequence;)V");

  /// from: public void appendWhere(java.lang.CharSequence inWhere)
  ///
  /// Append a chunk to the WHERE clause of the query. All chunks appended are surrounded
  /// by parenthesis and ANDed with the selection passed to \#query. The final
  /// WHERE clause looks like:
  ///
  /// WHERE (&lt;append chunk 1>&lt;append chunk2>) AND (&lt;query() selection parameter>)
  ///@param inWhere the chunk of text to append to the WHERE clause.
  void appendWhere(jni.JniObject inWhere) => jniAccessors.callMethodWithArgs(
      reference,
      _id_appendWhere,
      jni.JniType.voidType,
      [inWhere.reference]).check();

  static final _id_appendWhereEscapeString = jniAccessors.getMethodIDOf(
      _classRef, "appendWhereEscapeString", "(Ljava/lang/String;)V");

  /// from: public void appendWhereEscapeString(java.lang.String inWhere)
  ///
  /// Append a chunk to the WHERE clause of the query. All chunks appended are surrounded
  /// by parenthesis and ANDed with the selection passed to \#query. The final
  /// WHERE clause looks like:
  ///
  /// WHERE (&lt;append chunk 1>&lt;append chunk2>) AND (&lt;query() selection parameter>)
  ///@param inWhere the chunk of text to append to the WHERE clause. it will be escaped
  /// to avoid SQL injection attacks
  void appendWhereEscapeString(jni.JniString inWhere) =>
      jniAccessors.callMethodWithArgs(reference, _id_appendWhereEscapeString,
          jni.JniType.voidType, [inWhere.reference]).check();

  static final _id_setProjectionMap = jniAccessors.getMethodIDOf(
      _classRef, "setProjectionMap", "(Ljava/util/Map;)V");

  /// from: public void setProjectionMap(java.util.Map<java.lang.String,java.lang.String> columnMap)
  ///
  /// Sets the projection map for the query.  The projection map maps
  /// from column names that the caller passes into query to database
  /// column names. This is useful for renaming columns as well as
  /// disambiguating column names when doing joins. For example you
  /// could map "name" to "people.name".  If a projection map is set
  /// it must contain all column names the user may request, even if
  /// the key and value are the same.
  ///@param columnMap maps from the user column names to the database column names
  void setProjectionMap(jni.JniObject columnMap) =>
      jniAccessors.callMethodWithArgs(reference, _id_setProjectionMap,
          jni.JniType.voidType, [columnMap.reference]).check();

  static final _id_setCursorFactory = jniAccessors.getMethodIDOf(
      _classRef,
      "setCursorFactory",
      "(Landroid/database/sqlite/SQLiteDatabase\$CursorFactory;)V");

  /// from: public void setCursorFactory(android.database.sqlite.SQLiteDatabase.CursorFactory factory)
  ///
  /// Sets the cursor factory to be used for the query.  You can use
  /// one factory for all queries on a database but it is normally
  /// easier to specify the factory when doing this query.
  ///@param factory the factory to use.
  void setCursorFactory(
          sqlitedatabase_.SQLiteDatabase_CursorFactory factory0) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCursorFactory,
          jni.JniType.voidType, [factory0.reference]).check();

  static final _id_setStrict =
      jniAccessors.getMethodIDOf(_classRef, "setStrict", "(Z)V");

  /// from: public void setStrict(boolean flag)
  ///
  /// When set, the selection is verified against malicious arguments.
  /// When using this class to create a statement using
  /// \#buildQueryString(boolean, String, String[], String, String, String, String, String),
  /// non-numeric limits will raise an exception. If a projection map is specified, fields
  /// not in that map will be ignored.
  /// If this class is used to execute the statement directly using
  /// \#query(SQLiteDatabase, String[], String, String[], String, String, String)
  /// or
  /// \#query(SQLiteDatabase, String[], String, String[], String, String, String, String),
  /// additionally also parenthesis escaping selection are caught.
  ///
  /// To summarize: To get maximum protection against malicious third party apps (for example
  /// content provider consumers), make sure to do the following:
  /// <ul>
  /// <li>Set this value to true</li>
  /// <li>Use a projection map</li>
  /// <li>Use one of the query overloads instead of getting the statement as a sql string</li>
  /// </ul>
  /// By default, this value is false.
  void setStrict(bool flag) => jniAccessors.callMethodWithArgs(
      reference, _id_setStrict, jni.JniType.voidType, [flag]).check();

  static final _id_buildQueryString = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "buildQueryString",
      "(ZLjava/lang/String;[Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String buildQueryString(boolean distinct, java.lang.String tables, java.lang.String[] columns, java.lang.String where, java.lang.String groupBy, java.lang.String having, java.lang.String orderBy, java.lang.String limit)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Build an SQL query string from the given clauses.
  ///@param distinct true if you want each row to be unique, false otherwise.
  ///@param tables The table names to compile the query against.
  ///@param columns A list of which columns to return. Passing null will
  ///            return all columns, which is discouraged to prevent reading
  ///            data from storage that isn't going to be used.
  ///@param where A filter declaring which rows to return, formatted as an SQL
  ///            WHERE clause (excluding the WHERE itself). Passing null will
  ///            return all rows for the given URL.
  ///@param groupBy A filter declaring how to group rows, formatted as an SQL
  ///            GROUP BY clause (excluding the GROUP BY itself). Passing null
  ///            will cause the rows to not be grouped.
  ///@param having A filter declare which row groups to include in the cursor,
  ///            if row grouping is being used, formatted as an SQL HAVING
  ///            clause (excluding the HAVING itself). Passing null will cause
  ///            all row groups to be included, and is required when row
  ///            grouping is not being used.
  ///@param orderBy How to order the rows, formatted as an SQL ORDER BY clause
  ///            (excluding the ORDER BY itself). Passing null will use the
  ///            default sort order, which may be unordered.
  ///@param limit Limits the number of rows returned by the query,
  ///            formatted as LIMIT clause. Passing null denotes no LIMIT clause.
  ///@return the SQL query string
  static jni.JniString buildQueryString(
          bool distinct,
          jni.JniString tables,
          jni.JniObject columns,
          jni.JniString where,
          jni.JniString groupBy,
          jni.JniString having,
          jni.JniString orderBy,
          jni.JniString limit) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_buildQueryString, jni.JniType.objectType, [
        distinct,
        tables.reference,
        columns.reference,
        where.reference,
        groupBy.reference,
        having.reference,
        orderBy.reference,
        limit.reference
      ]).object);

  static final _id_appendColumns = jniAccessors.getStaticMethodIDOf(_classRef,
      "appendColumns", "(Ljava/lang/StringBuilder;[Ljava/lang/String;)V");

  /// from: static public void appendColumns(java.lang.StringBuilder s, java.lang.String[] columns)
  ///
  /// Add the names that are non-null in columns to s, separating
  /// them with commas.
  static void appendColumns(jni.JniObject s, jni.JniObject columns) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_appendColumns,
          jni.JniType.voidType, [s.reference, columns.reference]).check();

  static final _id_query = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/database/sqlite/SQLiteDatabase;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor query(android.database.sqlite.SQLiteDatabase db, java.lang.String[] projectionIn, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String groupBy, java.lang.String having, java.lang.String sortOrder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform a query by combining all current settings and the
  /// information passed into this method.
  ///@param db the database to query on
  ///@param projectionIn A list of which columns to return. Passing
  ///   null will return all columns, which is discouraged to prevent
  ///   reading data from storage that isn't going to be used.
  ///@param selection A filter declaring which rows to return,
  ///   formatted as an SQL WHERE clause (excluding the WHERE
  ///   itself). Passing null will return all rows for the given URL.
  ///@param selectionArgs You may include ?s in selection, which
  ///   will be replaced by the values from selectionArgs, in order
  ///   that they appear in the selection. The values will be bound
  ///   as Strings.
  ///@param groupBy A filter declaring how to group rows, formatted
  ///   as an SQL GROUP BY clause (excluding the GROUP BY
  ///   itself). Passing null will cause the rows to not be grouped.
  ///@param having A filter declare which row groups to include in
  ///   the cursor, if row grouping is being used, formatted as an
  ///   SQL HAVING clause (excluding the HAVING itself).  Passing
  ///   null will cause all row groups to be included, and is
  ///   required when row grouping is not being used.
  ///@param sortOrder How to order the rows, formatted as an SQL
  ///   ORDER BY clause (excluding the ORDER BY itself). Passing null
  ///   will use the default sort order, which may be unordered.
  ///@return a cursor over the result set
  ///@see android.content.ContentResolver\#query(android.net.Uri, String[],
  ///      String, String[], String)
  cursor_.Cursor query(
          sqlitedatabase_.SQLiteDatabase db,
          jni.JniObject projectionIn,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString groupBy,
          jni.JniString having,
          jni.JniString sortOrder) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query, jni.JniType.objectType, [
        db.reference,
        projectionIn.reference,
        selection.reference,
        selectionArgs.reference,
        groupBy.reference,
        having.reference,
        sortOrder.reference
      ]).object);

  static final _id_query1 = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/database/sqlite/SQLiteDatabase;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor query(android.database.sqlite.SQLiteDatabase db, java.lang.String[] projectionIn, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String groupBy, java.lang.String having, java.lang.String sortOrder, java.lang.String limit)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform a query by combining all current settings and the
  /// information passed into this method.
  ///@param db the database to query on
  ///@param projectionIn A list of which columns to return. Passing
  ///   null will return all columns, which is discouraged to prevent
  ///   reading data from storage that isn't going to be used.
  ///@param selection A filter declaring which rows to return,
  ///   formatted as an SQL WHERE clause (excluding the WHERE
  ///   itself). Passing null will return all rows for the given URL.
  ///@param selectionArgs You may include ?s in selection, which
  ///   will be replaced by the values from selectionArgs, in order
  ///   that they appear in the selection. The values will be bound
  ///   as Strings.
  ///@param groupBy A filter declaring how to group rows, formatted
  ///   as an SQL GROUP BY clause (excluding the GROUP BY
  ///   itself). Passing null will cause the rows to not be grouped.
  ///@param having A filter declare which row groups to include in
  ///   the cursor, if row grouping is being used, formatted as an
  ///   SQL HAVING clause (excluding the HAVING itself).  Passing
  ///   null will cause all row groups to be included, and is
  ///   required when row grouping is not being used.
  ///@param sortOrder How to order the rows, formatted as an SQL
  ///   ORDER BY clause (excluding the ORDER BY itself). Passing null
  ///   will use the default sort order, which may be unordered.
  ///@param limit Limits the number of rows returned by the query,
  ///   formatted as LIMIT clause. Passing null denotes no LIMIT clause.
  ///@return a cursor over the result set
  ///@see android.content.ContentResolver\#query(android.net.Uri, String[],
  ///      String, String[], String)
  cursor_.Cursor query1(
          sqlitedatabase_.SQLiteDatabase db,
          jni.JniObject projectionIn,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString groupBy,
          jni.JniString having,
          jni.JniString sortOrder,
          jni.JniString limit) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query1, jni.JniType.objectType, [
        db.reference,
        projectionIn.reference,
        selection.reference,
        selectionArgs.reference,
        groupBy.reference,
        having.reference,
        sortOrder.reference,
        limit.reference
      ]).object);

  static final _id_query2 = jniAccessors.getMethodIDOf(_classRef, "query",
      "(Landroid/database/sqlite/SQLiteDatabase;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/database/Cursor;");

  /// from: public android.database.Cursor query(android.database.sqlite.SQLiteDatabase db, java.lang.String[] projectionIn, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String groupBy, java.lang.String having, java.lang.String sortOrder, java.lang.String limit, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform a query by combining all current settings and the
  /// information passed into this method.
  ///@param db the database to query on
  ///@param projectionIn A list of which columns to return. Passing
  ///   null will return all columns, which is discouraged to prevent
  ///   reading data from storage that isn't going to be used.
  ///@param selection A filter declaring which rows to return,
  ///   formatted as an SQL WHERE clause (excluding the WHERE
  ///   itself). Passing null will return all rows for the given URL.
  ///@param selectionArgs You may include ?s in selection, which
  ///   will be replaced by the values from selectionArgs, in order
  ///   that they appear in the selection. The values will be bound
  ///   as Strings.
  ///@param groupBy A filter declaring how to group rows, formatted
  ///   as an SQL GROUP BY clause (excluding the GROUP BY
  ///   itself). Passing null will cause the rows to not be grouped.
  ///@param having A filter declare which row groups to include in
  ///   the cursor, if row grouping is being used, formatted as an
  ///   SQL HAVING clause (excluding the HAVING itself).  Passing
  ///   null will cause all row groups to be included, and is
  ///   required when row grouping is not being used.
  ///@param sortOrder How to order the rows, formatted as an SQL
  ///   ORDER BY clause (excluding the ORDER BY itself). Passing null
  ///   will use the default sort order, which may be unordered.
  ///@param limit Limits the number of rows returned by the query,
  ///   formatted as LIMIT clause. Passing null denotes no LIMIT clause.
  ///@param cancellationSignal A signal to cancel the operation in progress, or null if none.
  /// If the operation is canceled, then OperationCanceledException will be thrown
  /// when the query is executed.
  ///@return a cursor over the result set
  ///@see android.content.ContentResolver\#query(android.net.Uri, String[],
  ///      String, String[], String)
  cursor_.Cursor query2(
          sqlitedatabase_.SQLiteDatabase db,
          jni.JniObject projectionIn,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString groupBy,
          jni.JniString having,
          jni.JniString sortOrder,
          jni.JniString limit,
          cancellationsignal_.CancellationSignal cancellationSignal) =>
      cursor_.Cursor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_query2, jni.JniType.objectType, [
        db.reference,
        projectionIn.reference,
        selection.reference,
        selectionArgs.reference,
        groupBy.reference,
        having.reference,
        sortOrder.reference,
        limit.reference,
        cancellationSignal.reference
      ]).object);

  static final _id_buildQuery = jniAccessors.getMethodIDOf(
      _classRef,
      "buildQuery",
      "([Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String buildQuery(java.lang.String[] projectionIn, java.lang.String selection, java.lang.String groupBy, java.lang.String having, java.lang.String sortOrder, java.lang.String limit)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a SELECT statement suitable for use in a group of
  /// SELECT statements that will be joined through UNION operators
  /// in buildUnionQuery.
  ///@param projectionIn A list of which columns to return. Passing
  ///    null will return all columns, which is discouraged to
  ///    prevent reading data from storage that isn't going to be
  ///    used.
  ///@param selection A filter declaring which rows to return,
  ///   formatted as an SQL WHERE clause (excluding the WHERE
  ///   itself).  Passing null will return all rows for the given
  ///   URL.
  ///@param groupBy A filter declaring how to group rows, formatted
  ///   as an SQL GROUP BY clause (excluding the GROUP BY itself).
  ///   Passing null will cause the rows to not be grouped.
  ///@param having A filter declare which row groups to include in
  ///   the cursor, if row grouping is being used, formatted as an
  ///   SQL HAVING clause (excluding the HAVING itself).  Passing
  ///   null will cause all row groups to be included, and is
  ///   required when row grouping is not being used.
  ///@param sortOrder How to order the rows, formatted as an SQL
  ///   ORDER BY clause (excluding the ORDER BY itself). Passing null
  ///   will use the default sort order, which may be unordered.
  ///@param limit Limits the number of rows returned by the query,
  ///   formatted as LIMIT clause. Passing null denotes no LIMIT clause.
  ///@return the resulting SQL SELECT statement
  jni.JniString buildQuery(
          jni.JniObject projectionIn,
          jni.JniString selection,
          jni.JniString groupBy,
          jni.JniString having,
          jni.JniString sortOrder,
          jni.JniString limit) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_buildQuery, jni.JniType.objectType, [
        projectionIn.reference,
        selection.reference,
        groupBy.reference,
        having.reference,
        sortOrder.reference,
        limit.reference
      ]).object);

  static final _id_buildQuery1 = jniAccessors.getMethodIDOf(
      _classRef,
      "buildQuery",
      "([Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String buildQuery(java.lang.String[] projectionIn, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String groupBy, java.lang.String having, java.lang.String sortOrder, java.lang.String limit)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated This method's signature is misleading since no SQL parameter
  /// substitution is carried out.  The selection arguments parameter does not get
  /// used at all.  To avoid confusion, call
  /// \#buildQuery(String[], String, String, String, String, String) instead.
  jni.JniString buildQuery1(
          jni.JniObject projectionIn,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString groupBy,
          jni.JniString having,
          jni.JniString sortOrder,
          jni.JniString limit) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_buildQuery1, jni.JniType.objectType, [
        projectionIn.reference,
        selection.reference,
        selectionArgs.reference,
        groupBy.reference,
        having.reference,
        sortOrder.reference,
        limit.reference
      ]).object);

  static final _id_buildUnionSubQuery = jniAccessors.getMethodIDOf(
      _classRef,
      "buildUnionSubQuery",
      "(Ljava/lang/String;[Ljava/lang/String;Ljava/util/Set;ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String buildUnionSubQuery(java.lang.String typeDiscriminatorColumn, java.lang.String[] unionColumns, java.util.Set<java.lang.String> columnsPresentInTable, int computedColumnsOffset, java.lang.String typeDiscriminatorValue, java.lang.String selection, java.lang.String groupBy, java.lang.String having)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a SELECT statement suitable for use in a group of
  /// SELECT statements that will be joined through UNION operators
  /// in buildUnionQuery.
  ///@param typeDiscriminatorColumn the name of the result column
  ///   whose cells will contain the name of the table from which
  ///   each row was drawn.
  ///@param unionColumns the names of the columns to appear in the
  ///   result.  This may include columns that do not appear in the
  ///   table this SELECT is querying (i.e. mTables), but that do
  ///   appear in one of the other tables in the UNION query that we
  ///   are constructing.
  ///@param columnsPresentInTable a Set of the names of the columns
  ///   that appear in this table (i.e. in the table whose name is
  ///   mTables).  Since columns in unionColumns include columns that
  ///   appear only in other tables, we use this array to distinguish
  ///   which ones actually are present.  Other columns will have
  ///   NULL values for results from this subquery.
  ///@param computedColumnsOffset all columns in unionColumns before
  ///   this index are included under the assumption that they're
  ///   computed and therefore won't appear in columnsPresentInTable,
  ///   e.g. "date * 1000 as normalized_date"
  ///@param typeDiscriminatorValue the value used for the
  ///   type-discriminator column in this subquery
  ///@param selection A filter declaring which rows to return,
  ///   formatted as an SQL WHERE clause (excluding the WHERE
  ///   itself).  Passing null will return all rows for the given
  ///   URL.
  ///@param groupBy A filter declaring how to group rows, formatted
  ///   as an SQL GROUP BY clause (excluding the GROUP BY itself).
  ///   Passing null will cause the rows to not be grouped.
  ///@param having A filter declare which row groups to include in
  ///   the cursor, if row grouping is being used, formatted as an
  ///   SQL HAVING clause (excluding the HAVING itself).  Passing
  ///   null will cause all row groups to be included, and is
  ///   required when row grouping is not being used.
  ///@return the resulting SQL SELECT statement
  jni.JniString buildUnionSubQuery(
          jni.JniString typeDiscriminatorColumn,
          jni.JniObject unionColumns,
          jni.JniObject columnsPresentInTable,
          int computedColumnsOffset,
          jni.JniString typeDiscriminatorValue,
          jni.JniString selection,
          jni.JniString groupBy,
          jni.JniString having) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_buildUnionSubQuery, jni.JniType.objectType, [
        typeDiscriminatorColumn.reference,
        unionColumns.reference,
        columnsPresentInTable.reference,
        computedColumnsOffset,
        typeDiscriminatorValue.reference,
        selection.reference,
        groupBy.reference,
        having.reference
      ]).object);

  static final _id_buildUnionSubQuery1 = jniAccessors.getMethodIDOf(
      _classRef,
      "buildUnionSubQuery",
      "(Ljava/lang/String;[Ljava/lang/String;Ljava/util/Set;ILjava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String buildUnionSubQuery(java.lang.String typeDiscriminatorColumn, java.lang.String[] unionColumns, java.util.Set<java.lang.String> columnsPresentInTable, int computedColumnsOffset, java.lang.String typeDiscriminatorValue, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String groupBy, java.lang.String having)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated This method's signature is misleading since no SQL parameter
  /// substitution is carried out.  The selection arguments parameter does not get
  /// used at all.  To avoid confusion, call
  /// \#buildUnionSubQuery
  /// instead.
  jni.JniString buildUnionSubQuery1(
          jni.JniString typeDiscriminatorColumn,
          jni.JniObject unionColumns,
          jni.JniObject columnsPresentInTable,
          int computedColumnsOffset,
          jni.JniString typeDiscriminatorValue,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString groupBy,
          jni.JniString having) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_buildUnionSubQuery1, jni.JniType.objectType, [
        typeDiscriminatorColumn.reference,
        unionColumns.reference,
        columnsPresentInTable.reference,
        computedColumnsOffset,
        typeDiscriminatorValue.reference,
        selection.reference,
        selectionArgs.reference,
        groupBy.reference,
        having.reference
      ]).object);

  static final _id_buildUnionQuery = jniAccessors.getMethodIDOf(
      _classRef,
      "buildUnionQuery",
      "([Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String buildUnionQuery(java.lang.String[] subQueries, java.lang.String sortOrder, java.lang.String limit)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Given a set of subqueries, all of which are SELECT statements,
  /// construct a query that returns the union of what those
  /// subqueries return.
  ///@param subQueries an array of SQL SELECT statements, all of
  ///   which must have the same columns as the same positions in
  ///   their results
  ///@param sortOrder How to order the rows, formatted as an SQL
  ///   ORDER BY clause (excluding the ORDER BY itself).  Passing
  ///   null will use the default sort order, which may be unordered.
  ///@param limit The limit clause, which applies to the entire union result set
  ///@return the resulting SQL SELECT statement
  jni.JniString buildUnionQuery(jni.JniObject subQueries,
          jni.JniString sortOrder, jni.JniString limit) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_buildUnionQuery,
          jni.JniType.objectType,
          [subQueries.reference, sortOrder.reference, limit.reference]).object);
}
