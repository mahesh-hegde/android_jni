// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../content/Context.dart" as context_;

import "SQLiteDatabase.dart" as sqlitedatabase_;

import "../DatabaseErrorHandler.dart" as databaseerrorhandler_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.database.sqlite.SQLiteOpenHelper
///
/// A helper class to manage database creation and version management.
///
/// You create a subclass implementing \#onCreate, \#onUpgrade and
/// optionally \#onOpen, and this class takes care of opening the database
/// if it exists, creating it if it does not, and upgrading it as necessary.
/// Transactions are used to make sure the database is always in a sensible state.
///
/// This class makes it easy for android.content.ContentProvider
/// implementations to defer opening and upgrading the database until first use,
/// to avoid blocking application startup with long-running database upgrades.
///
/// For an example, see the NotePadProvider class in the NotePad sample application,
/// in the _samples/_ directory of the SDK.
///
///
/// <p class="note"><strong>Note:</strong> this class assumes
/// monotonically increasing version numbers for upgrades.
///
class SQLiteOpenHelper extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/database/sqlite/SQLiteOpenHelper");
  SQLiteOpenHelper.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Ljava/lang/String;Landroid/database/sqlite/SQLiteDatabase\$CursorFactory;I)V");

  /// from: public void <init>(android.content.Context context, java.lang.String name, android.database.sqlite.SQLiteDatabase.CursorFactory factory, int version)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a helper object to create, open, and/or manage a database.
  /// This method always returns very quickly.  The database is not actually
  /// created or opened until one of \#getWritableDatabase or
  /// \#getReadableDatabase is called.
  ///@param context to use for locating paths to the the database
  /// This value may be {@code null}.
  ///@param name of the database file, or null for an in-memory database
  /// This value may be {@code null}.
  ///@param factory to use for creating cursor objects, or null for the default
  /// This value may be {@code null}.
  ///@param version number of the database (starting at 1); if the database is older,
  ///     \#onUpgrade will be used to upgrade the database; if the database is
  ///     newer, \#onDowngrade will be used to downgrade the database
  SQLiteOpenHelper(context_.Context context, jni.JniString name,
      sqlitedatabase_.SQLiteDatabase_CursorFactory factory0, int version)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [
          context.reference,
          name.reference,
          factory0.reference,
          version
        ]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Ljava/lang/String;Landroid/database/sqlite/SQLiteDatabase\$CursorFactory;ILandroid/database/DatabaseErrorHandler;)V");

  /// from: public void <init>(android.content.Context context, java.lang.String name, android.database.sqlite.SQLiteDatabase.CursorFactory factory, int version, android.database.DatabaseErrorHandler errorHandler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a helper object to create, open, and/or manage a database.
  /// The database is not actually created or opened until one of
  /// \#getWritableDatabase or \#getReadableDatabase is called.
  ///
  /// Accepts input param: a concrete instance of DatabaseErrorHandler to be
  /// used to handle corruption when sqlite reports database corruption.
  ///
  ///@param context to use for locating paths to the the database
  /// This value may be {@code null}.
  ///@param name of the database file, or null for an in-memory database
  /// This value may be {@code null}.
  ///@param factory to use for creating cursor objects, or null for the default
  /// This value may be {@code null}.
  ///@param version number of the database (starting at 1); if the database is older,
  ///     \#onUpgrade will be used to upgrade the database; if the database is
  ///     newer, \#onDowngrade will be used to downgrade the database
  ///@param errorHandler the DatabaseErrorHandler to be used when sqlite reports database
  /// corruption, or null to use the default error handler.
  ///
  /// This value may be {@code null}.
  SQLiteOpenHelper.ctor1(
      context_.Context context,
      jni.JniString name,
      sqlitedatabase_.SQLiteDatabase_CursorFactory factory0,
      int version,
      databaseerrorhandler_.DatabaseErrorHandler errorHandler)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1, [
          context.reference,
          name.reference,
          factory0.reference,
          version,
          errorHandler.reference
        ]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Ljava/lang/String;ILandroid/database/sqlite/SQLiteDatabase\$OpenParams;)V");

  /// from: public void <init>(android.content.Context context, java.lang.String name, int version, android.database.sqlite.SQLiteDatabase.OpenParams openParams)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a helper object to create, open, and/or manage a database.
  /// This method always returns very quickly.  The database is not actually
  /// created or opened until one of \#getWritableDatabase or
  /// \#getReadableDatabase is called.
  ///@param context to use for locating paths to the the database
  /// This value may be {@code null}.
  ///@param name of the database file, or null for an in-memory database
  /// This value may be {@code null}.
  ///@param version number of the database (starting at 1); if the database is older,
  ///     \#onUpgrade will be used to upgrade the database; if the database is
  ///     newer, \#onDowngrade will be used to downgrade the database
  ///@param openParams configuration parameters that are used for opening SQLiteDatabase.
  ///        Please note that SQLiteDatabase\#CREATE_IF_NECESSARY flag will always be
  ///        set when the helper opens the database
  ///
  /// This value must never be {@code null}.
  SQLiteOpenHelper.ctor2(context_.Context context, jni.JniString name,
      int version, sqlitedatabase_.SQLiteDatabase_OpenParams openParams)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, [
          context.reference,
          name.reference,
          version,
          openParams.reference
        ]).object);

  static final _id_getDatabaseName = jniAccessors.getMethodIDOf(
      _classRef, "getDatabaseName", "()Ljava/lang/String;");

  /// from: public java.lang.String getDatabaseName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the name of the SQLite database being opened, as given to
  /// the constructor.
  jni.JniString getDatabaseName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDatabaseName, jni.JniType.objectType, []).object);

  static final _id_setWriteAheadLoggingEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setWriteAheadLoggingEnabled", "(Z)V");

  /// from: public void setWriteAheadLoggingEnabled(boolean enabled)
  ///
  /// Enables or disables the use of write-ahead logging for the database.
  ///
  /// Write-ahead logging cannot be used with read-only databases so the value of
  /// this flag is ignored if the database is opened read-only.
  ///@param enabled True if write-ahead logging should be enabled, false if it
  /// should be disabled.
  ///@see SQLiteDatabase\#enableWriteAheadLogging()
  void setWriteAheadLoggingEnabled(bool enabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setWriteAheadLoggingEnabled,
          jni.JniType.voidType,
          [enabled]).check();

  static final _id_setLookasideConfig =
      jniAccessors.getMethodIDOf(_classRef, "setLookasideConfig", "(II)V");

  /// from: public void setLookasideConfig(int slotSize, int slotCount)
  ///
  /// Configures <a href="https://sqlite.org/malloc.html\#lookaside">lookaside memory allocator</a>
  ///
  /// This method should be called from the constructor of the subclass,
  /// before opening the database, since lookaside memory configuration can only be changed
  /// when no connection is using it
  ///
  /// SQLite default settings will be used, if this method isn't called.
  /// Use {@code setLookasideConfig(0,0)} to disable lookaside
  ///
  /// <strong>Note:</strong> Provided slotSize/slotCount configuration is just a recommendation.
  /// The system may choose different values depending on a device, e.g. lookaside allocations
  /// can be disabled on low-RAM devices
  ///@param slotSize The size in bytes of each lookaside slot.
  /// Value is 0 or greater
  ///@param slotCount The total number of lookaside memory slots per database connection.
  ///
  /// Value is 0 or greater
  void setLookasideConfig(int slotSize, int slotCount) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLookasideConfig,
          jni.JniType.voidType, [slotSize, slotCount]).check();

  static final _id_setOpenParams = jniAccessors.getMethodIDOf(
      _classRef,
      "setOpenParams",
      "(Landroid/database/sqlite/SQLiteDatabase\$OpenParams;)V");

  /// from: public void setOpenParams(android.database.sqlite.SQLiteDatabase.OpenParams openParams)
  ///
  /// Sets configuration parameters that are used for opening SQLiteDatabase.
  /// Please note that SQLiteDatabase\#CREATE_IF_NECESSARY flag will always be set when
  /// opening the database
  ///@param openParams configuration parameters that are used for opening SQLiteDatabase.
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if the database is already open
  void setOpenParams(sqlitedatabase_.SQLiteDatabase_OpenParams openParams) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOpenParams,
          jni.JniType.voidType, [openParams.reference]).check();

  static final _id_setIdleConnectionTimeout =
      jniAccessors.getMethodIDOf(_classRef, "setIdleConnectionTimeout", "(J)V");

  /// from: public void setIdleConnectionTimeout(long idleConnectionTimeoutMs)
  ///
  /// Sets the maximum number of milliseconds that SQLite connection is allowed to be idle
  /// before it is closed and removed from the pool.
  ///
  /// This method should be called from the constructor of the subclass,
  /// before opening the database
  ///@param idleConnectionTimeoutMs timeout in milliseconds. Use Long\#MAX_VALUE value
  /// to allow unlimited idle connections.
  ///
  /// Value is 0 or greater
  void setIdleConnectionTimeout(int idleConnectionTimeoutMs) =>
      jniAccessors.callMethodWithArgs(reference, _id_setIdleConnectionTimeout,
          jni.JniType.voidType, [idleConnectionTimeoutMs]).check();

  static final _id_getWritableDatabase = jniAccessors.getMethodIDOf(_classRef,
      "getWritableDatabase", "()Landroid/database/sqlite/SQLiteDatabase;");

  /// from: public android.database.sqlite.SQLiteDatabase getWritableDatabase()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create and/or open a database that will be used for reading and writing.
  /// The first time this is called, the database will be opened and
  /// \#onCreate, \#onUpgrade and/or \#onOpen will be
  /// called.
  ///
  /// Once opened successfully, the database is cached, so you can
  /// call this method every time you need to write to the database.
  /// (Make sure to call \#close when you no longer need the database.)
  /// Errors such as bad permissions or a full disk may cause this method
  /// to fail, but future attempts may succeed if the problem is fixed.
  ///
  ///
  /// <p class="caution">Database upgrade may take a long time, you
  /// should not call this method from the application main thread, including
  /// from android.content.ContentProvider\#onCreate ContentProvider.onCreate().
  ///@throws SQLiteException if the database cannot be opened for writing
  ///@return a read/write database object valid until \#close is called
  sqlitedatabase_.SQLiteDatabase getWritableDatabase() =>
      sqlitedatabase_.SQLiteDatabase.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getWritableDatabase,
          jni.JniType.objectType, []).object);

  static final _id_getReadableDatabase = jniAccessors.getMethodIDOf(_classRef,
      "getReadableDatabase", "()Landroid/database/sqlite/SQLiteDatabase;");

  /// from: public android.database.sqlite.SQLiteDatabase getReadableDatabase()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create and/or open a database.  This will be the same object returned by
  /// \#getWritableDatabase unless some problem, such as a full disk,
  /// requires the database to be opened read-only.  In that case, a read-only
  /// database object will be returned.  If the problem is fixed, a future call
  /// to \#getWritableDatabase may succeed, in which case the read-only
  /// database object will be closed and the read/write object will be returned
  /// in the future.
  ///
  /// <p class="caution">Like \#getWritableDatabase, this method may
  /// take a long time to return, so you should not call it from the
  /// application main thread, including from
  /// android.content.ContentProvider\#onCreate ContentProvider.onCreate().
  ///@throws SQLiteException if the database cannot be opened
  ///@return a database object valid until \#getWritableDatabase
  ///     or \#close is called.
  sqlitedatabase_.SQLiteDatabase getReadableDatabase() =>
      sqlitedatabase_.SQLiteDatabase.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getReadableDatabase,
          jni.JniType.objectType, []).object);

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: synchronized public void close()
  ///
  /// Close any open database object.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_onConfigure = jniAccessors.getMethodIDOf(
      _classRef, "onConfigure", "(Landroid/database/sqlite/SQLiteDatabase;)V");

  /// from: public void onConfigure(android.database.sqlite.SQLiteDatabase db)
  ///
  /// Called when the database connection is being configured, to enable features such as
  /// write-ahead logging or foreign key support.
  ///
  /// This method is called before \#onCreate, \#onUpgrade, \#onDowngrade, or
  /// \#onOpen are called. It should not modify the database except to configure the
  /// database connection as required.
  ///
  ///
  ///
  /// This method should only call methods that configure the parameters of the database
  /// connection, such as SQLiteDatabase\#enableWriteAheadLogging
  /// SQLiteDatabase\#setForeignKeyConstraintsEnabled, SQLiteDatabase\#setLocale,
  /// SQLiteDatabase\#setMaximumSize, or executing PRAGMA statements.
  ///
  ///
  ///@param db The database.
  void onConfigure(sqlitedatabase_.SQLiteDatabase db) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConfigure,
          jni.JniType.voidType, [db.reference]).check();

  static final _id_onCreate = jniAccessors.getMethodIDOf(
      _classRef, "onCreate", "(Landroid/database/sqlite/SQLiteDatabase;)V");

  /// from: public abstract void onCreate(android.database.sqlite.SQLiteDatabase db)
  ///
  /// Called when the database is created for the first time. This is where the
  /// creation of tables and the initial population of the tables should happen.
  ///@param db The database.
  void onCreate(sqlitedatabase_.SQLiteDatabase db) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCreate,
          jni.JniType.voidType, [db.reference]).check();

  static final _id_onUpgrade = jniAccessors.getMethodIDOf(
      _classRef, "onUpgrade", "(Landroid/database/sqlite/SQLiteDatabase;II)V");

  /// from: public abstract void onUpgrade(android.database.sqlite.SQLiteDatabase db, int oldVersion, int newVersion)
  ///
  /// Called when the database needs to be upgraded. The implementation
  /// should use this method to drop tables, add tables, or do anything else it
  /// needs to upgrade to the new schema version.
  ///
  ///
  /// The SQLite ALTER TABLE documentation can be found
  /// <a href="http://sqlite.org/lang_altertable.html">here</a>. If you add new columns
  /// you can use ALTER TABLE to insert them into a live table. If you rename or remove columns
  /// you can use ALTER TABLE to rename the old table, then create the new table and then
  /// populate the new table with the contents of the old table.
  ///
  ///
  /// This method executes within a transaction.  If an exception is thrown, all changes
  /// will automatically be rolled back.
  ///
  ///
  ///@param db The database.
  ///@param oldVersion The old database version.
  ///@param newVersion The new database version.
  void onUpgrade(
          sqlitedatabase_.SQLiteDatabase db, int oldVersion, int newVersion) =>
      jniAccessors.callMethodWithArgs(reference, _id_onUpgrade,
          jni.JniType.voidType, [db.reference, oldVersion, newVersion]).check();

  static final _id_onDowngrade = jniAccessors.getMethodIDOf(_classRef,
      "onDowngrade", "(Landroid/database/sqlite/SQLiteDatabase;II)V");

  /// from: public void onDowngrade(android.database.sqlite.SQLiteDatabase db, int oldVersion, int newVersion)
  ///
  /// Called when the database needs to be downgraded. This is strictly similar to
  /// \#onUpgrade method, but is called whenever current version is newer than requested one.
  /// However, this method is not abstract, so it is not mandatory for a customer to
  /// implement it. If not overridden, default implementation will reject downgrade and
  /// throws SQLiteException
  ///
  ///
  /// This method executes within a transaction.  If an exception is thrown, all changes
  /// will automatically be rolled back.
  ///
  ///
  ///@param db The database.
  ///@param oldVersion The old database version.
  ///@param newVersion The new database version.
  void onDowngrade(
          sqlitedatabase_.SQLiteDatabase db, int oldVersion, int newVersion) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDowngrade,
          jni.JniType.voidType, [db.reference, oldVersion, newVersion]).check();

  static final _id_onOpen = jniAccessors.getMethodIDOf(
      _classRef, "onOpen", "(Landroid/database/sqlite/SQLiteDatabase;)V");

  /// from: public void onOpen(android.database.sqlite.SQLiteDatabase db)
  ///
  /// Called when the database has been opened.  The implementation
  /// should check SQLiteDatabase\#isReadOnly before updating the
  /// database.
  ///
  /// This method is called after the database connection has been configured
  /// and after the database schema has been created, upgraded or downgraded as necessary.
  /// If the database connection must be configured in some way before the schema
  /// is created, upgraded, or downgraded, do it in \#onConfigure instead.
  ///
  ///
  ///@param db The database.
  void onOpen(sqlitedatabase_.SQLiteDatabase db) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onOpen, jni.JniType.voidType, [db.reference]).check();
}
