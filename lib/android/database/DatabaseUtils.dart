// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../os/Parcel.dart" as parcel_;

import "sqlite/SQLiteProgram.dart" as sqliteprogram_;

import "Cursor.dart" as cursor_;

import "../content/ContentValues.dart" as contentvalues_;

import "sqlite/SQLiteDatabase.dart" as sqlitedatabase_;

import "sqlite/SQLiteStatement.dart" as sqlitestatement_;

import "../os/ParcelFileDescriptor.dart" as parcelfiledescriptor_;

import "../content/Context.dart" as context_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.database.DatabaseUtils
///
/// Static utility methods for dealing with databases and Cursors.
class DatabaseUtils extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/database/DatabaseUtils");
  DatabaseUtils.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int STATEMENT_ABORT
  ///
  /// One of the values returned by \#getSqlStatementType(String).
  static const STATEMENT_ABORT = 6;

  /// from: static public final int STATEMENT_ATTACH
  ///
  /// One of the values returned by \#getSqlStatementType(String).
  static const STATEMENT_ATTACH = 3;

  /// from: static public final int STATEMENT_BEGIN
  ///
  /// One of the values returned by \#getSqlStatementType(String).
  static const STATEMENT_BEGIN = 4;

  /// from: static public final int STATEMENT_COMMIT
  ///
  /// One of the values returned by \#getSqlStatementType(String).
  static const STATEMENT_COMMIT = 5;

  /// from: static public final int STATEMENT_DDL
  ///
  /// One of the values returned by \#getSqlStatementType(String).
  static const STATEMENT_DDL = 8;

  /// from: static public final int STATEMENT_OTHER
  ///
  /// One of the values returned by \#getSqlStatementType(String).
  static const STATEMENT_OTHER = 99;

  /// from: static public final int STATEMENT_PRAGMA
  ///
  /// One of the values returned by \#getSqlStatementType(String).
  static const STATEMENT_PRAGMA = 7;

  /// from: static public final int STATEMENT_SELECT
  ///
  /// One of the values returned by \#getSqlStatementType(String).
  static const STATEMENT_SELECT = 1;

  /// from: static public final int STATEMENT_UNPREPARED
  ///
  /// One of the values returned by \#getSqlStatementType(String).
  static const STATEMENT_UNPREPARED = 9;

  /// from: static public final int STATEMENT_UPDATE
  ///
  /// One of the values returned by \#getSqlStatementType(String).
  static const STATEMENT_UPDATE = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  DatabaseUtils()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_writeExceptionToParcel = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "writeExceptionToParcel",
      "(Landroid/os/Parcel;Ljava/lang/Exception;)V");

  /// from: static public final void writeExceptionToParcel(android.os.Parcel reply, java.lang.Exception e)
  ///
  /// Special function for writing an exception result at the header of
  /// a parcel, to be used when returning an exception from a transaction.
  /// exception will be re-thrown by the function in another process
  ///@param reply Parcel to write to
  ///@param e The Exception to be written.
  ///@see Parcel\#writeNoException
  ///@see Parcel\#writeException
  static void writeExceptionToParcel(parcel_.Parcel reply, jni.JniObject e) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_writeExceptionToParcel,
          jni.JniType.voidType,
          [reply.reference, e.reference]).check();

  static final _id_readExceptionFromParcel = jniAccessors.getStaticMethodIDOf(
      _classRef, "readExceptionFromParcel", "(Landroid/os/Parcel;)V");

  /// from: static public final void readExceptionFromParcel(android.os.Parcel reply)
  ///
  /// Special function for reading an exception result from the header of
  /// a parcel, to be used after receiving the result of a transaction.  This
  /// will throw the exception for you if it had been written to the Parcel,
  /// otherwise return and let you read the normal result data from the Parcel.
  ///@param reply Parcel to read from
  ///@see Parcel\#writeNoException
  ///@see Parcel\#readException
  static void readExceptionFromParcel(parcel_.Parcel reply) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_readExceptionFromParcel,
          jni.JniType.voidType,
          [reply.reference]).check();

  static final _id_readExceptionWithFileNotFoundExceptionFromParcel =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "readExceptionWithFileNotFoundExceptionFromParcel",
          "(Landroid/os/Parcel;)V");

  /// from: static public void readExceptionWithFileNotFoundExceptionFromParcel(android.os.Parcel reply)
  static void readExceptionWithFileNotFoundExceptionFromParcel(
          parcel_.Parcel reply) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_readExceptionWithFileNotFoundExceptionFromParcel,
          jni.JniType.voidType,
          [reply.reference]).check();

  static final _id_readExceptionWithOperationApplicationExceptionFromParcel =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "readExceptionWithOperationApplicationExceptionFromParcel",
          "(Landroid/os/Parcel;)V");

  /// from: static public void readExceptionWithOperationApplicationExceptionFromParcel(android.os.Parcel reply)
  static void readExceptionWithOperationApplicationExceptionFromParcel(
          parcel_.Parcel reply) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_readExceptionWithOperationApplicationExceptionFromParcel,
          jni.JniType.voidType,
          [reply.reference]).check();

  static final _id_bindObjectToProgram = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "bindObjectToProgram",
      "(Landroid/database/sqlite/SQLiteProgram;ILjava/lang/Object;)V");

  /// from: static public void bindObjectToProgram(android.database.sqlite.SQLiteProgram prog, int index, java.lang.Object value)
  ///
  /// Binds the given Object to the given SQLiteProgram using the proper
  /// typing. For example, bind numbers as longs/doubles, and everything else
  /// as a string by call toString() on it.
  ///@param prog the program to bind the object to
  ///@param index the 1-based index to bind at
  ///@param value the value to bind
  static void bindObjectToProgram(
          sqliteprogram_.SQLiteProgram prog, int index, jni.JniObject value) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_bindObjectToProgram,
          jni.JniType.voidType,
          [prog.reference, index, value.reference]).check();

  static final _id_appendEscapedSQLString = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "appendEscapedSQLString",
      "(Ljava/lang/StringBuilder;Ljava/lang/String;)V");

  /// from: static public void appendEscapedSQLString(java.lang.StringBuilder sb, java.lang.String sqlString)
  ///
  /// Appends an SQL string to the given StringBuilder, including the opening
  /// and closing single quotes. Any single quotes internal to sqlString will
  /// be escaped.
  ///
  /// This method is deprecated because we want to encourage everyone
  /// to use the "?" binding form.  However, when implementing a
  /// ContentProvider, one may want to add WHERE clauses that were
  /// not provided by the caller.  Since "?" is a positional form,
  /// using it in this case could break the caller because the
  /// indexes would be shifted to accomodate the ContentProvider's
  /// internal bindings.  In that case, it may be necessary to
  /// construct a WHERE clause manually.  This method is useful for
  /// those cases.
  ///@param sb the StringBuilder that the SQL string will be appended to
  ///@param sqlString the raw string to be appended, which may contain single
  ///                  quotes
  static void appendEscapedSQLString(
          jni.JniObject sb, jni.JniString sqlString) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_appendEscapedSQLString,
          jni.JniType.voidType,
          [sb.reference, sqlString.reference]).check();

  static final _id_sqlEscapeString = jniAccessors.getStaticMethodIDOf(
      _classRef, "sqlEscapeString", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String sqlEscapeString(java.lang.String value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// SQL-escape a string.
  static jni.JniString sqlEscapeString(jni.JniString value) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_sqlEscapeString,
          jni.JniType.objectType,
          [value.reference]).object);

  static final _id_appendValueToSql = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "appendValueToSql",
      "(Ljava/lang/StringBuilder;Ljava/lang/Object;)V");

  /// from: static public final void appendValueToSql(java.lang.StringBuilder sql, java.lang.Object value)
  ///
  /// Appends an Object to an SQL string with the proper escaping, etc.
  static void appendValueToSql(jni.JniObject sql, jni.JniObject value) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_appendValueToSql,
          jni.JniType.voidType, [sql.reference, value.reference]).check();

  static final _id_concatenateWhere = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "concatenateWhere",
      "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String concatenateWhere(java.lang.String a, java.lang.String b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Concatenates two SQL WHERE clauses, handling empty or null values.
  static jni.JniString concatenateWhere(jni.JniString a, jni.JniString b) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_concatenateWhere,
          jni.JniType.objectType,
          [a.reference, b.reference]).object);

  static final _id_getCollationKey = jniAccessors.getStaticMethodIDOf(
      _classRef, "getCollationKey", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String getCollationKey(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// return the collation key
  ///@param name
  ///@return the collation key
  static jni.JniString getCollationKey(jni.JniString name) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getCollationKey,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_getHexCollationKey = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getHexCollationKey",
      "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String getHexCollationKey(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// return the collation key in hex format
  ///@param name
  ///@return the collation key in hex format
  static jni.JniString getHexCollationKey(jni.JniString name) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getHexCollationKey,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_dumpCursor = jniAccessors.getStaticMethodIDOf(
      _classRef, "dumpCursor", "(Landroid/database/Cursor;)V");

  /// from: static public void dumpCursor(android.database.Cursor cursor)
  ///
  /// Prints the contents of a Cursor to System.out. The position is restored
  /// after printing.
  ///@param cursor the cursor to print
  static void dumpCursor(cursor_.Cursor cursor) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_dumpCursor,
          jni.JniType.voidType, [cursor.reference]).check();

  static final _id_dumpCursor1 = jniAccessors.getStaticMethodIDOf(_classRef,
      "dumpCursor", "(Landroid/database/Cursor;Ljava/io/PrintStream;)V");

  /// from: static public void dumpCursor(android.database.Cursor cursor, java.io.PrintStream stream)
  ///
  /// Prints the contents of a Cursor to a PrintSteam. The position is restored
  /// after printing.
  ///@param cursor the cursor to print
  ///@param stream the stream to print to
  static void dumpCursor1(cursor_.Cursor cursor, jni.JniObject stream) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_dumpCursor1,
          jni.JniType.voidType, [cursor.reference, stream.reference]).check();

  static final _id_dumpCursor2 = jniAccessors.getStaticMethodIDOf(_classRef,
      "dumpCursor", "(Landroid/database/Cursor;Ljava/lang/StringBuilder;)V");

  /// from: static public void dumpCursor(android.database.Cursor cursor, java.lang.StringBuilder sb)
  ///
  /// Prints the contents of a Cursor to a StringBuilder. The position
  /// is restored after printing.
  ///@param cursor the cursor to print
  ///@param sb the StringBuilder to print to
  static void dumpCursor2(cursor_.Cursor cursor, jni.JniObject sb) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_dumpCursor2,
          jni.JniType.voidType, [cursor.reference, sb.reference]).check();

  static final _id_dumpCursorToString = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "dumpCursorToString",
      "(Landroid/database/Cursor;)Ljava/lang/String;");

  /// from: static public java.lang.String dumpCursorToString(android.database.Cursor cursor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Prints the contents of a Cursor to a String. The position is restored
  /// after printing.
  ///@param cursor the cursor to print
  ///@return a String that contains the dumped cursor
  static jni.JniString dumpCursorToString(cursor_.Cursor cursor) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_dumpCursorToString,
          jni.JniType.objectType,
          [cursor.reference]).object);

  static final _id_dumpCurrentRow = jniAccessors.getStaticMethodIDOf(
      _classRef, "dumpCurrentRow", "(Landroid/database/Cursor;)V");

  /// from: static public void dumpCurrentRow(android.database.Cursor cursor)
  ///
  /// Prints the contents of a Cursor's current row to System.out.
  ///@param cursor the cursor to print from
  static void dumpCurrentRow(cursor_.Cursor cursor) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_dumpCurrentRow,
          jni.JniType.voidType, [cursor.reference]).check();

  static final _id_dumpCurrentRow1 = jniAccessors.getStaticMethodIDOf(_classRef,
      "dumpCurrentRow", "(Landroid/database/Cursor;Ljava/io/PrintStream;)V");

  /// from: static public void dumpCurrentRow(android.database.Cursor cursor, java.io.PrintStream stream)
  ///
  /// Prints the contents of a Cursor's current row to a PrintSteam.
  ///@param cursor the cursor to print
  ///@param stream the stream to print to
  static void dumpCurrentRow1(cursor_.Cursor cursor, jni.JniObject stream) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_dumpCurrentRow1,
          jni.JniType.voidType, [cursor.reference, stream.reference]).check();

  static final _id_dumpCurrentRow2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "dumpCurrentRow",
      "(Landroid/database/Cursor;Ljava/lang/StringBuilder;)V");

  /// from: static public void dumpCurrentRow(android.database.Cursor cursor, java.lang.StringBuilder sb)
  ///
  /// Prints the contents of a Cursor's current row to a StringBuilder.
  ///@param cursor the cursor to print
  ///@param sb the StringBuilder to print to
  static void dumpCurrentRow2(cursor_.Cursor cursor, jni.JniObject sb) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_dumpCurrentRow2,
          jni.JniType.voidType, [cursor.reference, sb.reference]).check();

  static final _id_dumpCurrentRowToString = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "dumpCurrentRowToString",
      "(Landroid/database/Cursor;)Ljava/lang/String;");

  /// from: static public java.lang.String dumpCurrentRowToString(android.database.Cursor cursor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Dump the contents of a Cursor's current row to a String.
  ///@param cursor the cursor to print
  ///@return a String that contains the dumped cursor row
  static jni.JniString dumpCurrentRowToString(cursor_.Cursor cursor) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_dumpCurrentRowToString,
          jni.JniType.objectType,
          [cursor.reference]).object);

  static final _id_cursorStringToContentValues = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "cursorStringToContentValues",
      "(Landroid/database/Cursor;Ljava/lang/String;Landroid/content/ContentValues;)V");

  /// from: static public void cursorStringToContentValues(android.database.Cursor cursor, java.lang.String field, android.content.ContentValues values)
  ///
  /// Reads a String out of a field in a Cursor and writes it to a Map.
  ///@param cursor The cursor to read from
  ///@param field The TEXT field to read
  ///@param values The ContentValues to put the value into, with the field as the key
  static void cursorStringToContentValues(cursor_.Cursor cursor,
          jni.JniString field, contentvalues_.ContentValues values) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_cursorStringToContentValues,
          jni.JniType.voidType,
          [cursor.reference, field.reference, values.reference]).check();

  static final _id_cursorStringToInsertHelper = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "cursorStringToInsertHelper",
      "(Landroid/database/Cursor;Ljava/lang/String;Landroid/database/DatabaseUtils\$InsertHelper;I)V");

  /// from: static public void cursorStringToInsertHelper(android.database.Cursor cursor, java.lang.String field, android.database.DatabaseUtils.InsertHelper inserter, int index)
  ///
  /// Reads a String out of a field in a Cursor and writes it to an InsertHelper.
  ///@param cursor The cursor to read from
  ///@param field The TEXT field to read
  ///@param inserter The InsertHelper to bind into
  ///@param index the index of the bind entry in the InsertHelper
  static void cursorStringToInsertHelper(
          cursor_.Cursor cursor,
          jni.JniString field,
          DatabaseUtils_InsertHelper inserter,
          int index) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_cursorStringToInsertHelper, jni.JniType.voidType, [
        cursor.reference,
        field.reference,
        inserter.reference,
        index
      ]).check();

  static final _id_cursorStringToContentValues1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "cursorStringToContentValues",
      "(Landroid/database/Cursor;Ljava/lang/String;Landroid/content/ContentValues;Ljava/lang/String;)V");

  /// from: static public void cursorStringToContentValues(android.database.Cursor cursor, java.lang.String field, android.content.ContentValues values, java.lang.String key)
  ///
  /// Reads a String out of a field in a Cursor and writes it to a Map.
  ///@param cursor The cursor to read from
  ///@param field The TEXT field to read
  ///@param values The ContentValues to put the value into, with the field as the key
  ///@param key The key to store the value with in the map
  static void cursorStringToContentValues1(
          cursor_.Cursor cursor,
          jni.JniString field,
          contentvalues_.ContentValues values,
          jni.JniString key) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_cursorStringToContentValues1, jni.JniType.voidType, [
        cursor.reference,
        field.reference,
        values.reference,
        key.reference
      ]).check();

  static final _id_cursorIntToContentValues = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "cursorIntToContentValues",
      "(Landroid/database/Cursor;Ljava/lang/String;Landroid/content/ContentValues;)V");

  /// from: static public void cursorIntToContentValues(android.database.Cursor cursor, java.lang.String field, android.content.ContentValues values)
  ///
  /// Reads an Integer out of a field in a Cursor and writes it to a Map.
  ///@param cursor The cursor to read from
  ///@param field The INTEGER field to read
  ///@param values The ContentValues to put the value into, with the field as the key
  static void cursorIntToContentValues(cursor_.Cursor cursor,
          jni.JniString field, contentvalues_.ContentValues values) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_cursorIntToContentValues,
          jni.JniType.voidType,
          [cursor.reference, field.reference, values.reference]).check();

  static final _id_cursorIntToContentValues1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "cursorIntToContentValues",
      "(Landroid/database/Cursor;Ljava/lang/String;Landroid/content/ContentValues;Ljava/lang/String;)V");

  /// from: static public void cursorIntToContentValues(android.database.Cursor cursor, java.lang.String field, android.content.ContentValues values, java.lang.String key)
  ///
  /// Reads a Integer out of a field in a Cursor and writes it to a Map.
  ///@param cursor The cursor to read from
  ///@param field The INTEGER field to read
  ///@param values The ContentValues to put the value into, with the field as the key
  ///@param key The key to store the value with in the map
  static void cursorIntToContentValues1(
          cursor_.Cursor cursor,
          jni.JniString field,
          contentvalues_.ContentValues values,
          jni.JniString key) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_cursorIntToContentValues1, jni.JniType.voidType, [
        cursor.reference,
        field.reference,
        values.reference,
        key.reference
      ]).check();

  static final _id_cursorLongToContentValues = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "cursorLongToContentValues",
      "(Landroid/database/Cursor;Ljava/lang/String;Landroid/content/ContentValues;)V");

  /// from: static public void cursorLongToContentValues(android.database.Cursor cursor, java.lang.String field, android.content.ContentValues values)
  ///
  /// Reads a Long out of a field in a Cursor and writes it to a Map.
  ///@param cursor The cursor to read from
  ///@param field The INTEGER field to read
  ///@param values The ContentValues to put the value into, with the field as the key
  static void cursorLongToContentValues(cursor_.Cursor cursor,
          jni.JniString field, contentvalues_.ContentValues values) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_cursorLongToContentValues,
          jni.JniType.voidType,
          [cursor.reference, field.reference, values.reference]).check();

  static final _id_cursorLongToContentValues1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "cursorLongToContentValues",
      "(Landroid/database/Cursor;Ljava/lang/String;Landroid/content/ContentValues;Ljava/lang/String;)V");

  /// from: static public void cursorLongToContentValues(android.database.Cursor cursor, java.lang.String field, android.content.ContentValues values, java.lang.String key)
  ///
  /// Reads a Long out of a field in a Cursor and writes it to a Map.
  ///@param cursor The cursor to read from
  ///@param field The INTEGER field to read
  ///@param values The ContentValues to put the value into
  ///@param key The key to store the value with in the map
  static void cursorLongToContentValues1(
          cursor_.Cursor cursor,
          jni.JniString field,
          contentvalues_.ContentValues values,
          jni.JniString key) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_cursorLongToContentValues1, jni.JniType.voidType, [
        cursor.reference,
        field.reference,
        values.reference,
        key.reference
      ]).check();

  static final _id_cursorDoubleToCursorValues = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "cursorDoubleToCursorValues",
      "(Landroid/database/Cursor;Ljava/lang/String;Landroid/content/ContentValues;)V");

  /// from: static public void cursorDoubleToCursorValues(android.database.Cursor cursor, java.lang.String field, android.content.ContentValues values)
  ///
  /// Reads a Double out of a field in a Cursor and writes it to a Map.
  ///@param cursor The cursor to read from
  ///@param field The REAL field to read
  ///@param values The ContentValues to put the value into
  static void cursorDoubleToCursorValues(cursor_.Cursor cursor,
          jni.JniString field, contentvalues_.ContentValues values) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_cursorDoubleToCursorValues,
          jni.JniType.voidType,
          [cursor.reference, field.reference, values.reference]).check();

  static final _id_cursorDoubleToContentValues = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "cursorDoubleToContentValues",
      "(Landroid/database/Cursor;Ljava/lang/String;Landroid/content/ContentValues;Ljava/lang/String;)V");

  /// from: static public void cursorDoubleToContentValues(android.database.Cursor cursor, java.lang.String field, android.content.ContentValues values, java.lang.String key)
  ///
  /// Reads a Double out of a field in a Cursor and writes it to a Map.
  ///@param cursor The cursor to read from
  ///@param field The REAL field to read
  ///@param values The ContentValues to put the value into
  ///@param key The key to store the value with in the map
  static void cursorDoubleToContentValues(
          cursor_.Cursor cursor,
          jni.JniString field,
          contentvalues_.ContentValues values,
          jni.JniString key) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_cursorDoubleToContentValues, jni.JniType.voidType, [
        cursor.reference,
        field.reference,
        values.reference,
        key.reference
      ]).check();

  static final _id_cursorRowToContentValues = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "cursorRowToContentValues",
      "(Landroid/database/Cursor;Landroid/content/ContentValues;)V");

  /// from: static public void cursorRowToContentValues(android.database.Cursor cursor, android.content.ContentValues values)
  ///
  /// Read the entire contents of a cursor row and store them in a ContentValues.
  ///@param cursor the cursor to read from.
  ///@param values the ContentValues to put the row into.
  static void cursorRowToContentValues(
          cursor_.Cursor cursor, contentvalues_.ContentValues values) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_cursorRowToContentValues,
          jni.JniType.voidType,
          [cursor.reference, values.reference]).check();

  static final _id_queryNumEntries = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "queryNumEntries",
      "(Landroid/database/sqlite/SQLiteDatabase;Ljava/lang/String;)J");

  /// from: static public long queryNumEntries(android.database.sqlite.SQLiteDatabase db, java.lang.String table)
  ///
  /// Query the table for the number of rows in the table.
  ///@param db the database the table is in
  ///@param table the name of the table to query
  ///@return the number of rows in the table
  static int queryNumEntries(
          sqlitedatabase_.SQLiteDatabase db, jni.JniString table) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_queryNumEntries,
          jni.JniType.longType, [db.reference, table.reference]).long;

  static final _id_queryNumEntries1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "queryNumEntries",
      "(Landroid/database/sqlite/SQLiteDatabase;Ljava/lang/String;Ljava/lang/String;)J");

  /// from: static public long queryNumEntries(android.database.sqlite.SQLiteDatabase db, java.lang.String table, java.lang.String selection)
  ///
  /// Query the table for the number of rows in the table.
  ///@param db the database the table is in
  ///@param table the name of the table to query
  ///@param selection A filter declaring which rows to return,
  ///              formatted as an SQL WHERE clause (excluding the WHERE itself).
  ///              Passing null will count all rows for the given table
  ///@return the number of rows in the table filtered by the selection
  static int queryNumEntries1(sqlitedatabase_.SQLiteDatabase db,
          jni.JniString table, jni.JniString selection) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_queryNumEntries1,
          jni.JniType.longType,
          [db.reference, table.reference, selection.reference]).long;

  static final _id_queryNumEntries2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "queryNumEntries",
      "(Landroid/database/sqlite/SQLiteDatabase;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)J");

  /// from: static public long queryNumEntries(android.database.sqlite.SQLiteDatabase db, java.lang.String table, java.lang.String selection, java.lang.String[] selectionArgs)
  ///
  /// Query the table for the number of rows in the table.
  ///@param db the database the table is in
  ///@param table the name of the table to query
  ///@param selection A filter declaring which rows to return,
  ///              formatted as an SQL WHERE clause (excluding the WHERE itself).
  ///              Passing null will count all rows for the given table
  ///@param selectionArgs You may include ?s in selection,
  ///              which will be replaced by the values from selectionArgs,
  ///              in order that they appear in the selection.
  ///              The values will be bound as Strings.
  ///@return the number of rows in the table filtered by the selection
  static int queryNumEntries2(
          sqlitedatabase_.SQLiteDatabase db,
          jni.JniString table,
          jni.JniString selection,
          jni.JniObject selectionArgs) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_queryNumEntries2, jni.JniType.longType, [
        db.reference,
        table.reference,
        selection.reference,
        selectionArgs.reference
      ]).long;

  static final _id_longForQuery = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "longForQuery",
      "(Landroid/database/sqlite/SQLiteDatabase;Ljava/lang/String;[Ljava/lang/String;)J");

  /// from: static public long longForQuery(android.database.sqlite.SQLiteDatabase db, java.lang.String query, java.lang.String[] selectionArgs)
  ///
  /// Utility method to run the query on the db and return the value in the
  /// first column of the first row.
  static int longForQuery(sqlitedatabase_.SQLiteDatabase db,
          jni.JniString query, jni.JniObject selectionArgs) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_longForQuery,
          jni.JniType.longType,
          [db.reference, query.reference, selectionArgs.reference]).long;

  static final _id_longForQuery1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "longForQuery",
      "(Landroid/database/sqlite/SQLiteStatement;[Ljava/lang/String;)J");

  /// from: static public long longForQuery(android.database.sqlite.SQLiteStatement prog, java.lang.String[] selectionArgs)
  ///
  /// Utility method to run the pre-compiled query and return the value in the
  /// first column of the first row.
  static int longForQuery1(
          sqlitestatement_.SQLiteStatement prog, jni.JniObject selectionArgs) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_longForQuery1,
          jni.JniType.longType, [prog.reference, selectionArgs.reference]).long;

  static final _id_stringForQuery = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "stringForQuery",
      "(Landroid/database/sqlite/SQLiteDatabase;Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String stringForQuery(android.database.sqlite.SQLiteDatabase db, java.lang.String query, java.lang.String[] selectionArgs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Utility method to run the query on the db and return the value in the
  /// first column of the first row.
  static jni.JniString stringForQuery(sqlitedatabase_.SQLiteDatabase db,
          jni.JniString query, jni.JniObject selectionArgs) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_stringForQuery,
          jni.JniType.objectType,
          [db.reference, query.reference, selectionArgs.reference]).object);

  static final _id_stringForQuery1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "stringForQuery",
      "(Landroid/database/sqlite/SQLiteStatement;[Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String stringForQuery(android.database.sqlite.SQLiteStatement prog, java.lang.String[] selectionArgs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Utility method to run the pre-compiled query and return the value in the
  /// first column of the first row.
  static jni.JniString stringForQuery1(
          sqlitestatement_.SQLiteStatement prog, jni.JniObject selectionArgs) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_stringForQuery1,
          jni.JniType.objectType,
          [prog.reference, selectionArgs.reference]).object);

  static final _id_blobFileDescriptorForQuery = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "blobFileDescriptorForQuery",
      "(Landroid/database/sqlite/SQLiteDatabase;Ljava/lang/String;[Ljava/lang/String;)Landroid/os/ParcelFileDescriptor;");

  /// from: static public android.os.ParcelFileDescriptor blobFileDescriptorForQuery(android.database.sqlite.SQLiteDatabase db, java.lang.String query, java.lang.String[] selectionArgs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Utility method to run the query on the db and return the blob value in the
  /// first column of the first row.
  ///@return A read-only file descriptor for a copy of the blob value.
  static parcelfiledescriptor_.ParcelFileDescriptor blobFileDescriptorForQuery(
          sqlitedatabase_.SQLiteDatabase db,
          jni.JniString query,
          jni.JniObject selectionArgs) =>
      parcelfiledescriptor_.ParcelFileDescriptor.fromRef(jniAccessors
          .callStaticMethodWithArgs(
              _classRef,
              _id_blobFileDescriptorForQuery,
              jni.JniType.objectType,
              [db.reference, query.reference, selectionArgs.reference]).object);

  static final _id_blobFileDescriptorForQuery1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "blobFileDescriptorForQuery",
      "(Landroid/database/sqlite/SQLiteStatement;[Ljava/lang/String;)Landroid/os/ParcelFileDescriptor;");

  /// from: static public android.os.ParcelFileDescriptor blobFileDescriptorForQuery(android.database.sqlite.SQLiteStatement prog, java.lang.String[] selectionArgs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Utility method to run the pre-compiled query and return the blob value in the
  /// first column of the first row.
  ///@return A read-only file descriptor for a copy of the blob value.
  static parcelfiledescriptor_.ParcelFileDescriptor blobFileDescriptorForQuery1(
          sqlitestatement_.SQLiteStatement prog, jni.JniObject selectionArgs) =>
      parcelfiledescriptor_.ParcelFileDescriptor.fromRef(jniAccessors
          .callStaticMethodWithArgs(
              _classRef,
              _id_blobFileDescriptorForQuery1,
              jni.JniType.objectType,
              [prog.reference, selectionArgs.reference]).object);

  static final _id_cursorStringToContentValuesIfPresent =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "cursorStringToContentValuesIfPresent",
          "(Landroid/database/Cursor;Landroid/content/ContentValues;Ljava/lang/String;)V");

  /// from: static public void cursorStringToContentValuesIfPresent(android.database.Cursor cursor, android.content.ContentValues values, java.lang.String column)
  ///
  /// Reads a String out of a column in a Cursor and writes it to a ContentValues.
  /// Adds nothing to the ContentValues if the column isn't present or if its value is null.
  ///@param cursor The cursor to read from
  ///@param column The column to read
  ///@param values The ContentValues to put the value into
  static void cursorStringToContentValuesIfPresent(cursor_.Cursor cursor,
          contentvalues_.ContentValues values, jni.JniString column) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_cursorStringToContentValuesIfPresent,
          jni.JniType.voidType,
          [cursor.reference, values.reference, column.reference]).check();

  static final _id_cursorLongToContentValuesIfPresent =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "cursorLongToContentValuesIfPresent",
          "(Landroid/database/Cursor;Landroid/content/ContentValues;Ljava/lang/String;)V");

  /// from: static public void cursorLongToContentValuesIfPresent(android.database.Cursor cursor, android.content.ContentValues values, java.lang.String column)
  ///
  /// Reads a Long out of a column in a Cursor and writes it to a ContentValues.
  /// Adds nothing to the ContentValues if the column isn't present or if its value is null.
  ///@param cursor The cursor to read from
  ///@param column The column to read
  ///@param values The ContentValues to put the value into
  static void cursorLongToContentValuesIfPresent(cursor_.Cursor cursor,
          contentvalues_.ContentValues values, jni.JniString column) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_cursorLongToContentValuesIfPresent,
          jni.JniType.voidType,
          [cursor.reference, values.reference, column.reference]).check();

  static final _id_cursorShortToContentValuesIfPresent =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "cursorShortToContentValuesIfPresent",
          "(Landroid/database/Cursor;Landroid/content/ContentValues;Ljava/lang/String;)V");

  /// from: static public void cursorShortToContentValuesIfPresent(android.database.Cursor cursor, android.content.ContentValues values, java.lang.String column)
  ///
  /// Reads a Short out of a column in a Cursor and writes it to a ContentValues.
  /// Adds nothing to the ContentValues if the column isn't present or if its value is null.
  ///@param cursor The cursor to read from
  ///@param column The column to read
  ///@param values The ContentValues to put the value into
  static void cursorShortToContentValuesIfPresent(cursor_.Cursor cursor,
          contentvalues_.ContentValues values, jni.JniString column) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_cursorShortToContentValuesIfPresent,
          jni.JniType.voidType,
          [cursor.reference, values.reference, column.reference]).check();

  static final _id_cursorIntToContentValuesIfPresent =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "cursorIntToContentValuesIfPresent",
          "(Landroid/database/Cursor;Landroid/content/ContentValues;Ljava/lang/String;)V");

  /// from: static public void cursorIntToContentValuesIfPresent(android.database.Cursor cursor, android.content.ContentValues values, java.lang.String column)
  ///
  /// Reads a Integer out of a column in a Cursor and writes it to a ContentValues.
  /// Adds nothing to the ContentValues if the column isn't present or if its value is null.
  ///@param cursor The cursor to read from
  ///@param column The column to read
  ///@param values The ContentValues to put the value into
  static void cursorIntToContentValuesIfPresent(cursor_.Cursor cursor,
          contentvalues_.ContentValues values, jni.JniString column) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_cursorIntToContentValuesIfPresent,
          jni.JniType.voidType,
          [cursor.reference, values.reference, column.reference]).check();

  static final _id_cursorFloatToContentValuesIfPresent =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "cursorFloatToContentValuesIfPresent",
          "(Landroid/database/Cursor;Landroid/content/ContentValues;Ljava/lang/String;)V");

  /// from: static public void cursorFloatToContentValuesIfPresent(android.database.Cursor cursor, android.content.ContentValues values, java.lang.String column)
  ///
  /// Reads a Float out of a column in a Cursor and writes it to a ContentValues.
  /// Adds nothing to the ContentValues if the column isn't present or if its value is null.
  ///@param cursor The cursor to read from
  ///@param column The column to read
  ///@param values The ContentValues to put the value into
  static void cursorFloatToContentValuesIfPresent(cursor_.Cursor cursor,
          contentvalues_.ContentValues values, jni.JniString column) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_cursorFloatToContentValuesIfPresent,
          jni.JniType.voidType,
          [cursor.reference, values.reference, column.reference]).check();

  static final _id_cursorDoubleToContentValuesIfPresent =
      jniAccessors.getStaticMethodIDOf(
          _classRef,
          "cursorDoubleToContentValuesIfPresent",
          "(Landroid/database/Cursor;Landroid/content/ContentValues;Ljava/lang/String;)V");

  /// from: static public void cursorDoubleToContentValuesIfPresent(android.database.Cursor cursor, android.content.ContentValues values, java.lang.String column)
  ///
  /// Reads a Double out of a column in a Cursor and writes it to a ContentValues.
  /// Adds nothing to the ContentValues if the column isn't present or if its value is null.
  ///@param cursor The cursor to read from
  ///@param column The column to read
  ///@param values The ContentValues to put the value into
  static void cursorDoubleToContentValuesIfPresent(cursor_.Cursor cursor,
          contentvalues_.ContentValues values, jni.JniString column) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_cursorDoubleToContentValuesIfPresent,
          jni.JniType.voidType,
          [cursor.reference, values.reference, column.reference]).check();

  static final _id_createDbFromSqlStatements = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createDbFromSqlStatements",
      "(Landroid/content/Context;Ljava/lang/String;ILjava/lang/String;)V");

  /// from: static public void createDbFromSqlStatements(android.content.Context context, java.lang.String dbName, int dbVersion, java.lang.String sqlStatements)
  ///
  /// Creates a db and populates it with the sql statements in sqlStatements.
  ///@param context the context to use to create the db
  ///@param dbName the name of the db to create
  ///@param dbVersion the version to set on the db
  ///@param sqlStatements the statements to use to populate the db. This should be a single string
  ///   of the form returned by sqlite3's <tt>.dump</tt> command (statements separated by
  ///   semicolons)
  static void createDbFromSqlStatements(context_.Context context,
          jni.JniString dbName, int dbVersion, jni.JniString sqlStatements) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_createDbFromSqlStatements, jni.JniType.voidType, [
        context.reference,
        dbName.reference,
        dbVersion,
        sqlStatements.reference
      ]).check();

  static final _id_getSqlStatementType = jniAccessors.getStaticMethodIDOf(
      _classRef, "getSqlStatementType", "(Ljava/lang/String;)I");

  /// from: static public int getSqlStatementType(java.lang.String sql)
  ///
  /// Returns one of the following which represent the type of the given SQL statement.
  /// <ol>
  ///   <li>\#STATEMENT_SELECT</li>
  ///   <li>\#STATEMENT_UPDATE</li>
  ///   <li>\#STATEMENT_ATTACH</li>
  ///   <li>\#STATEMENT_BEGIN</li>
  ///   <li>\#STATEMENT_COMMIT</li>
  ///   <li>\#STATEMENT_ABORT</li>
  ///   <li>\#STATEMENT_OTHER</li>
  /// </ol>
  ///@param sql the SQL statement whose type is returned by this method
  ///@return one of the values listed above
  static int getSqlStatementType(jni.JniString sql) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getSqlStatementType,
          jni.JniType.intType, [sql.reference]).integer;

  static final _id_appendSelectionArgs = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "appendSelectionArgs",
      "([Ljava/lang/String;[Ljava/lang/String;)[Ljava/lang/String;");

  /// from: static public java.lang.String[] appendSelectionArgs(java.lang.String[] originalValues, java.lang.String[] newValues)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Appends one set of selection args to another. This is useful when adding a selection
  /// argument to a user provided set.
  static jni.JniObject appendSelectionArgs(
          jni.JniObject originalValues, jni.JniObject newValues) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_appendSelectionArgs,
          jni.JniType.objectType,
          [originalValues.reference, newValues.reference]).object);
}

/// from: android.database.DatabaseUtils$InsertHelper
///
/// This class allows users to do multiple inserts into a table using
/// the same statement.
///
/// This class is not thread-safe.
///
///
///@deprecated Use SQLiteStatement instead.
class DatabaseUtils_InsertHelper extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/database/DatabaseUtils\$InsertHelper");
  DatabaseUtils_InsertHelper.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/database/sqlite/SQLiteDatabase;Ljava/lang/String;)V");

  /// from: public void <init>(android.database.sqlite.SQLiteDatabase db, java.lang.String tableName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param db the SQLiteDatabase to insert into
  ///@param tableName the name of the table to insert into
  DatabaseUtils_InsertHelper(
      sqlitedatabase_.SQLiteDatabase db, jni.JniString tableName)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [db.reference, tableName.reference]).object);

  static final _id_getColumnIndex = jniAccessors.getMethodIDOf(
      _classRef, "getColumnIndex", "(Ljava/lang/String;)I");

  /// from: public int getColumnIndex(java.lang.String key)
  ///
  /// Returns the index of the specified column. This is index is suitagble for use
  /// in calls to bind().
  ///@param key the column name
  ///@return the index of the column
  int getColumnIndex(jni.JniString key) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getColumnIndex,
      jni.JniType.intType,
      [key.reference]).integer;

  static final _id_bind =
      jniAccessors.getMethodIDOf(_classRef, "bind", "(ID)V");

  /// from: public void bind(int index, double value)
  ///
  /// Bind the value to an index. A prepareForInsert() or prepareForReplace()
  /// without a matching execute() must have already have been called.
  ///@param index the index of the slot to which to bind
  ///@param value the value to bind
  void bind(int index, double value) => jniAccessors.callMethodWithArgs(
      reference, _id_bind, jni.JniType.voidType, [index, value]).check();

  static final _id_bind1 =
      jniAccessors.getMethodIDOf(_classRef, "bind", "(IF)V");

  /// from: public void bind(int index, float value)
  ///
  /// Bind the value to an index. A prepareForInsert() or prepareForReplace()
  /// without a matching execute() must have already have been called.
  ///@param index the index of the slot to which to bind
  ///@param value the value to bind
  void bind1(int index, double value) => jniAccessors.callMethodWithArgs(
      reference, _id_bind1, jni.JniType.voidType, [index, value]).check();

  static final _id_bind2 =
      jniAccessors.getMethodIDOf(_classRef, "bind", "(IJ)V");

  /// from: public void bind(int index, long value)
  ///
  /// Bind the value to an index. A prepareForInsert() or prepareForReplace()
  /// without a matching execute() must have already have been called.
  ///@param index the index of the slot to which to bind
  ///@param value the value to bind
  void bind2(int index, int value) => jniAccessors.callMethodWithArgs(
      reference, _id_bind2, jni.JniType.voidType, [index, value]).check();

  static final _id_bind3 =
      jniAccessors.getMethodIDOf(_classRef, "bind", "(II)V");

  /// from: public void bind(int index, int value)
  ///
  /// Bind the value to an index. A prepareForInsert() or prepareForReplace()
  /// without a matching execute() must have already have been called.
  ///@param index the index of the slot to which to bind
  ///@param value the value to bind
  void bind3(int index, int value) => jniAccessors.callMethodWithArgs(
      reference, _id_bind3, jni.JniType.voidType, [index, value]).check();

  static final _id_bind4 =
      jniAccessors.getMethodIDOf(_classRef, "bind", "(IZ)V");

  /// from: public void bind(int index, boolean value)
  ///
  /// Bind the value to an index. A prepareForInsert() or prepareForReplace()
  /// without a matching execute() must have already have been called.
  ///@param index the index of the slot to which to bind
  ///@param value the value to bind
  void bind4(int index, bool value) => jniAccessors.callMethodWithArgs(
      reference, _id_bind4, jni.JniType.voidType, [index, value]).check();

  static final _id_bindNull =
      jniAccessors.getMethodIDOf(_classRef, "bindNull", "(I)V");

  /// from: public void bindNull(int index)
  ///
  /// Bind null to an index. A prepareForInsert() or prepareForReplace()
  /// without a matching execute() must have already have been called.
  ///@param index the index of the slot to which to bind
  void bindNull(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_bindNull, jni.JniType.voidType, [index]).check();

  static final _id_bind5 =
      jniAccessors.getMethodIDOf(_classRef, "bind", "(I[B)V");

  /// from: public void bind(int index, byte[] value)
  ///
  /// Bind the value to an index. A prepareForInsert() or prepareForReplace()
  /// without a matching execute() must have already have been called.
  ///@param index the index of the slot to which to bind
  ///@param value the value to bind
  void bind5(int index, jni.JniObject value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_bind5,
      jni.JniType.voidType,
      [index, value.reference]).check();

  static final _id_bind6 =
      jniAccessors.getMethodIDOf(_classRef, "bind", "(ILjava/lang/String;)V");

  /// from: public void bind(int index, java.lang.String value)
  ///
  /// Bind the value to an index. A prepareForInsert() or prepareForReplace()
  /// without a matching execute() must have already have been called.
  ///@param index the index of the slot to which to bind
  ///@param value the value to bind
  void bind6(int index, jni.JniString value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_bind6,
      jni.JniType.voidType,
      [index, value.reference]).check();

  static final _id_insert = jniAccessors.getMethodIDOf(
      _classRef, "insert", "(Landroid/content/ContentValues;)J");

  /// from: public long insert(android.content.ContentValues values)
  ///
  /// Performs an insert, adding a new row with the given values.
  /// If the table contains conflicting rows, an error is
  /// returned.
  ///@param values the set of values with which to populate the
  /// new row
  ///@return the row ID of the newly inserted row, or -1 if an
  /// error occurred
  int insert(contentvalues_.ContentValues values) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_insert, jni.JniType.longType, [values.reference]).long;

  static final _id_execute =
      jniAccessors.getMethodIDOf(_classRef, "execute", "()J");

  /// from: public long execute()
  ///
  /// Execute the previously prepared insert or replace using the bound values
  /// since the last call to prepareForInsert or prepareForReplace.
  ///
  /// Note that calling bind() and then execute() is not thread-safe. The only thread-safe
  /// way to use this class is to call insert() or replace().
  ///@return the row ID of the newly inserted row, or -1 if an
  /// error occurred
  int execute() => jniAccessors.callMethodWithArgs(
      reference, _id_execute, jni.JniType.longType, []).long;

  static final _id_prepareForInsert =
      jniAccessors.getMethodIDOf(_classRef, "prepareForInsert", "()V");

  /// from: public void prepareForInsert()
  ///
  /// Prepare the InsertHelper for an insert. The pattern for this is:
  /// <ul>
  /// <li>prepareForInsert()
  /// <li>bind(index, value);
  /// <li>bind(index, value);
  /// <li>...
  /// <li>bind(index, value);
  /// <li>execute();
  /// </ul>
  void prepareForInsert() => jniAccessors.callMethodWithArgs(
      reference, _id_prepareForInsert, jni.JniType.voidType, []).check();

  static final _id_prepareForReplace =
      jniAccessors.getMethodIDOf(_classRef, "prepareForReplace", "()V");

  /// from: public void prepareForReplace()
  ///
  /// Prepare the InsertHelper for a replace. The pattern for this is:
  /// <ul>
  /// <li>prepareForReplace()
  /// <li>bind(index, value);
  /// <li>bind(index, value);
  /// <li>...
  /// <li>bind(index, value);
  /// <li>execute();
  /// </ul>
  void prepareForReplace() => jniAccessors.callMethodWithArgs(
      reference, _id_prepareForReplace, jni.JniType.voidType, []).check();

  static final _id_replace = jniAccessors.getMethodIDOf(
      _classRef, "replace", "(Landroid/content/ContentValues;)J");

  /// from: public long replace(android.content.ContentValues values)
  ///
  /// Performs an insert, adding a new row with the given values.
  /// If the table contains conflicting rows, they are deleted
  /// and replaced with the new row.
  ///@param values the set of values with which to populate the
  /// new row
  ///@return the row ID of the newly inserted row, or -1 if an
  /// error occurred
  int replace(contentvalues_.ContentValues values) =>
      jniAccessors.callMethodWithArgs(reference, _id_replace,
          jni.JniType.longType, [values.reference]).long;

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Close this object and release any resources associated with
  /// it.  The behavior of calling <code>insert()</code> after
  /// calling this method is undefined.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();
}
