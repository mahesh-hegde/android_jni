// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/ContentResolver.dart" as contentresolver_;

import "CursorWindow.dart" as cursorwindow_;

import "CharArrayBuffer.dart" as chararraybuffer_;

import "ContentObserver.dart" as contentobserver_;

import "DataSetObserver.dart" as datasetobserver_;

import "../net/Uri.dart" as uri_;

import "../os/Bundle.dart" as bundle_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.database.AbstractCursor
///
/// This is an abstract cursor class that handles a lot of the common code
/// that all cursors need to deal with and is provided for convenience reasons.
class AbstractCursor extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/database/AbstractCursor");
  AbstractCursor.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_mClosed =
      jniAccessors.getFieldIDOf(_classRef, "mClosed", "Z");

  /// from: protected boolean mClosed
  ///
  /// @deprecated Use \#isClosed() instead.
  bool get mClosed => jniAccessors
      .getField(reference, _id_mClosed, jni.JniType.booleanType)
      .boolean;

  /// from: protected boolean mClosed
  ///
  /// @deprecated Use \#isClosed() instead.
  set mClosed(bool value) =>
      jniEnv.SetBooleanField(reference, _id_mClosed, value ? 1 : 0);

  static final _id_mContentResolver = jniAccessors.getFieldIDOf(
      _classRef, "mContentResolver", "Landroid/content/ContentResolver;");

  /// from: protected android.content.ContentResolver mContentResolver
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Do not use.
  contentresolver_.ContentResolver get mContentResolver =>
      contentresolver_.ContentResolver.fromRef(jniAccessors
          .getField(reference, _id_mContentResolver, jni.JniType.objectType)
          .object);

  /// from: protected android.content.ContentResolver mContentResolver
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Do not use.
  set mContentResolver(contentresolver_.ContentResolver value) =>
      jniEnv.SetObjectField(reference, _id_mContentResolver, value.reference);

  static final _id_mPos = jniAccessors.getFieldIDOf(_classRef, "mPos", "I");

  /// from: protected int mPos
  ///
  /// @deprecated Use \#getPosition() instead.
  int get mPos =>
      jniAccessors.getField(reference, _id_mPos, jni.JniType.intType).integer;

  /// from: protected int mPos
  ///
  /// @deprecated Use \#getPosition() instead.
  set mPos(int value) => jniEnv.SetIntField(reference, _id_mPos, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AbstractCursor()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getCount =
      jniAccessors.getMethodIDOf(_classRef, "getCount", "()I");

  /// from: public abstract int getCount()
  int getCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getCount, jni.JniType.intType, []).integer;

  static final _id_getColumnNames = jniAccessors.getMethodIDOf(
      _classRef, "getColumnNames", "()[Ljava/lang/String;");

  /// from: public abstract java.lang.String[] getColumnNames()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getColumnNames() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getColumnNames, jni.JniType.objectType, []).object);

  static final _id_getString = jniAccessors.getMethodIDOf(
      _classRef, "getString", "(I)Ljava/lang/String;");

  /// from: public abstract java.lang.String getString(int column)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getString(int column) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getString, jni.JniType.objectType, [column]).object);

  static final _id_getShort =
      jniAccessors.getMethodIDOf(_classRef, "getShort", "(I)S");

  /// from: public abstract short getShort(int column)
  int getShort(int column) => jniAccessors.callMethodWithArgs(
      reference, _id_getShort, jni.JniType.shortType, [column]).short;

  static final _id_getInt =
      jniAccessors.getMethodIDOf(_classRef, "getInt", "(I)I");

  /// from: public abstract int getInt(int column)
  int getInt(int column) => jniAccessors.callMethodWithArgs(
      reference, _id_getInt, jni.JniType.intType, [column]).integer;

  static final _id_getLong =
      jniAccessors.getMethodIDOf(_classRef, "getLong", "(I)J");

  /// from: public abstract long getLong(int column)
  int getLong(int column) => jniAccessors.callMethodWithArgs(
      reference, _id_getLong, jni.JniType.longType, [column]).long;

  static final _id_getFloat =
      jniAccessors.getMethodIDOf(_classRef, "getFloat", "(I)F");

  /// from: public abstract float getFloat(int column)
  double getFloat(int column) => jniAccessors.callMethodWithArgs(
      reference, _id_getFloat, jni.JniType.floatType, [column]).float;

  static final _id_getDouble =
      jniAccessors.getMethodIDOf(_classRef, "getDouble", "(I)D");

  /// from: public abstract double getDouble(int column)
  double getDouble(int column) => jniAccessors.callMethodWithArgs(
      reference, _id_getDouble, jni.JniType.doubleType, [column]).doubleFloat;

  static final _id_isNull1 =
      jniAccessors.getMethodIDOf(_classRef, "isNull", "(I)Z");

  /// from: public abstract boolean isNull(int column)
  bool isNull1(int column) => jniAccessors.callMethodWithArgs(
      reference, _id_isNull1, jni.JniType.booleanType, [column]).boolean;

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "(I)I");

  /// from: public int getType(int column)
  int getType(int column) => jniAccessors.callMethodWithArgs(
      reference, _id_getType, jni.JniType.intType, [column]).integer;

  static final _id_getBlob =
      jniAccessors.getMethodIDOf(_classRef, "getBlob", "(I)[B");

  /// from: public byte[] getBlob(int column)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getBlob(int column) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBlob, jni.JniType.objectType, [column]).object);

  static final _id_getWindow = jniAccessors.getMethodIDOf(
      _classRef, "getWindow", "()Landroid/database/CursorWindow;");

  /// from: public android.database.CursorWindow getWindow()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If the cursor is backed by a CursorWindow, returns a pre-filled
  /// window with the contents of the cursor, otherwise null.
  ///@return The pre-filled window that backs this cursor, or null if none.
  cursorwindow_.CursorWindow getWindow() =>
      cursorwindow_.CursorWindow.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWindow, jni.JniType.objectType, []).object);

  static final _id_getColumnCount =
      jniAccessors.getMethodIDOf(_classRef, "getColumnCount", "()I");

  /// from: public int getColumnCount()
  int getColumnCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getColumnCount, jni.JniType.intType, []).integer;

  static final _id_deactivate =
      jniAccessors.getMethodIDOf(_classRef, "deactivate", "()V");

  /// from: public void deactivate()
  void deactivate() => jniAccessors.callMethodWithArgs(
      reference, _id_deactivate, jni.JniType.voidType, []).check();

  static final _id_requery =
      jniAccessors.getMethodIDOf(_classRef, "requery", "()Z");

  /// from: public boolean requery()
  bool requery() => jniAccessors.callMethodWithArgs(
      reference, _id_requery, jni.JniType.booleanType, []).boolean;

  static final _id_isClosed =
      jniAccessors.getMethodIDOf(_classRef, "isClosed", "()Z");

  /// from: public boolean isClosed()
  bool isClosed() => jniAccessors.callMethodWithArgs(
      reference, _id_isClosed, jni.JniType.booleanType, []).boolean;

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_onMove =
      jniAccessors.getMethodIDOf(_classRef, "onMove", "(II)Z");

  /// from: public boolean onMove(int oldPosition, int newPosition)
  ///
  /// This function is called every time the cursor is successfully scrolled
  /// to a new position, giving the subclass a chance to update any state it
  /// may have. If it returns false the move function will also do so and the
  /// cursor will scroll to the beforeFirst position.
  ///@param oldPosition the position that we're moving from
  ///@param newPosition the position that we're moving to
  ///@return true if the move is successful, false otherwise
  bool onMove(int oldPosition, int newPosition) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMove,
          jni.JniType.booleanType, [oldPosition, newPosition]).boolean;

  static final _id_copyStringToBuffer = jniAccessors.getMethodIDOf(_classRef,
      "copyStringToBuffer", "(ILandroid/database/CharArrayBuffer;)V");

  /// from: public void copyStringToBuffer(int columnIndex, android.database.CharArrayBuffer buffer)
  void copyStringToBuffer(
          int columnIndex, chararraybuffer_.CharArrayBuffer buffer) =>
      jniAccessors.callMethodWithArgs(reference, _id_copyStringToBuffer,
          jni.JniType.voidType, [columnIndex, buffer.reference]).check();

  static final _id_getPosition =
      jniAccessors.getMethodIDOf(_classRef, "getPosition", "()I");

  /// from: public final int getPosition()
  int getPosition() => jniAccessors.callMethodWithArgs(
      reference, _id_getPosition, jni.JniType.intType, []).integer;

  static final _id_moveToPosition =
      jniAccessors.getMethodIDOf(_classRef, "moveToPosition", "(I)Z");

  /// from: public final boolean moveToPosition(int position)
  bool moveToPosition(int position) => jniAccessors.callMethodWithArgs(
      reference,
      _id_moveToPosition,
      jni.JniType.booleanType,
      [position]).boolean;

  static final _id_fillWindow = jniAccessors.getMethodIDOf(
      _classRef, "fillWindow", "(ILandroid/database/CursorWindow;)V");

  /// from: public void fillWindow(int position, android.database.CursorWindow window)
  void fillWindow(int position, cursorwindow_.CursorWindow window) =>
      jniAccessors.callMethodWithArgs(reference, _id_fillWindow,
          jni.JniType.voidType, [position, window.reference]).check();

  static final _id_move = jniAccessors.getMethodIDOf(_classRef, "move", "(I)Z");

  /// from: public final boolean move(int offset)
  bool move(int offset) => jniAccessors.callMethodWithArgs(
      reference, _id_move, jni.JniType.booleanType, [offset]).boolean;

  static final _id_moveToFirst =
      jniAccessors.getMethodIDOf(_classRef, "moveToFirst", "()Z");

  /// from: public final boolean moveToFirst()
  bool moveToFirst() => jniAccessors.callMethodWithArgs(
      reference, _id_moveToFirst, jni.JniType.booleanType, []).boolean;

  static final _id_moveToLast =
      jniAccessors.getMethodIDOf(_classRef, "moveToLast", "()Z");

  /// from: public final boolean moveToLast()
  bool moveToLast() => jniAccessors.callMethodWithArgs(
      reference, _id_moveToLast, jni.JniType.booleanType, []).boolean;

  static final _id_moveToNext =
      jniAccessors.getMethodIDOf(_classRef, "moveToNext", "()Z");

  /// from: public final boolean moveToNext()
  bool moveToNext() => jniAccessors.callMethodWithArgs(
      reference, _id_moveToNext, jni.JniType.booleanType, []).boolean;

  static final _id_moveToPrevious =
      jniAccessors.getMethodIDOf(_classRef, "moveToPrevious", "()Z");

  /// from: public final boolean moveToPrevious()
  bool moveToPrevious() => jniAccessors.callMethodWithArgs(
      reference, _id_moveToPrevious, jni.JniType.booleanType, []).boolean;

  static final _id_isFirst =
      jniAccessors.getMethodIDOf(_classRef, "isFirst", "()Z");

  /// from: public final boolean isFirst()
  bool isFirst() => jniAccessors.callMethodWithArgs(
      reference, _id_isFirst, jni.JniType.booleanType, []).boolean;

  static final _id_isLast =
      jniAccessors.getMethodIDOf(_classRef, "isLast", "()Z");

  /// from: public final boolean isLast()
  bool isLast() => jniAccessors.callMethodWithArgs(
      reference, _id_isLast, jni.JniType.booleanType, []).boolean;

  static final _id_isBeforeFirst =
      jniAccessors.getMethodIDOf(_classRef, "isBeforeFirst", "()Z");

  /// from: public final boolean isBeforeFirst()
  bool isBeforeFirst() => jniAccessors.callMethodWithArgs(
      reference, _id_isBeforeFirst, jni.JniType.booleanType, []).boolean;

  static final _id_isAfterLast =
      jniAccessors.getMethodIDOf(_classRef, "isAfterLast", "()Z");

  /// from: public final boolean isAfterLast()
  bool isAfterLast() => jniAccessors.callMethodWithArgs(
      reference, _id_isAfterLast, jni.JniType.booleanType, []).boolean;

  static final _id_getColumnIndex = jniAccessors.getMethodIDOf(
      _classRef, "getColumnIndex", "(Ljava/lang/String;)I");

  /// from: public int getColumnIndex(java.lang.String columnName)
  int getColumnIndex(jni.JniString columnName) =>
      jniAccessors.callMethodWithArgs(reference, _id_getColumnIndex,
          jni.JniType.intType, [columnName.reference]).integer;

  static final _id_getColumnIndexOrThrow = jniAccessors.getMethodIDOf(
      _classRef, "getColumnIndexOrThrow", "(Ljava/lang/String;)I");

  /// from: public int getColumnIndexOrThrow(java.lang.String columnName)
  int getColumnIndexOrThrow(jni.JniString columnName) =>
      jniAccessors.callMethodWithArgs(reference, _id_getColumnIndexOrThrow,
          jni.JniType.intType, [columnName.reference]).integer;

  static final _id_getColumnName = jniAccessors.getMethodIDOf(
      _classRef, "getColumnName", "(I)Ljava/lang/String;");

  /// from: public java.lang.String getColumnName(int columnIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getColumnName(int columnIndex) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getColumnName, jni.JniType.objectType, [columnIndex]).object);

  static final _id_registerContentObserver = jniAccessors.getMethodIDOf(
      _classRef,
      "registerContentObserver",
      "(Landroid/database/ContentObserver;)V");

  /// from: public void registerContentObserver(android.database.ContentObserver observer)
  void registerContentObserver(contentobserver_.ContentObserver observer) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerContentObserver,
          jni.JniType.voidType, [observer.reference]).check();

  static final _id_unregisterContentObserver = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterContentObserver",
      "(Landroid/database/ContentObserver;)V");

  /// from: public void unregisterContentObserver(android.database.ContentObserver observer)
  void unregisterContentObserver(contentobserver_.ContentObserver observer) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterContentObserver,
          jni.JniType.voidType, [observer.reference]).check();

  static final _id_registerDataSetObserver = jniAccessors.getMethodIDOf(
      _classRef,
      "registerDataSetObserver",
      "(Landroid/database/DataSetObserver;)V");

  /// from: public void registerDataSetObserver(android.database.DataSetObserver observer)
  void registerDataSetObserver(datasetobserver_.DataSetObserver observer) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerDataSetObserver,
          jni.JniType.voidType, [observer.reference]).check();

  static final _id_unregisterDataSetObserver = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterDataSetObserver",
      "(Landroid/database/DataSetObserver;)V");

  /// from: public void unregisterDataSetObserver(android.database.DataSetObserver observer)
  void unregisterDataSetObserver(datasetobserver_.DataSetObserver observer) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterDataSetObserver,
          jni.JniType.voidType, [observer.reference]).check();

  static final _id_onChange =
      jniAccessors.getMethodIDOf(_classRef, "onChange", "(Z)V");

  /// from: protected void onChange(boolean selfChange)
  ///
  /// Subclasses must call this method when they finish committing updates to notify all
  /// observers.
  ///@param selfChange
  void onChange(bool selfChange) => jniAccessors.callMethodWithArgs(
      reference, _id_onChange, jni.JniType.voidType, [selfChange]).check();

  static final _id_setNotificationUri = jniAccessors.getMethodIDOf(
      _classRef,
      "setNotificationUri",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;)V");

  /// from: public void setNotificationUri(android.content.ContentResolver cr, android.net.Uri notifyUri)
  ///
  /// Specifies a content URI to watch for changes.
  ///@param cr The content resolver from the caller's context.
  ///@param notifyUri The URI to watch for changes. This can be a
  /// specific row URI, or a base URI for a whole class of content.
  void setNotificationUri(
          contentresolver_.ContentResolver cr, uri_.Uri notifyUri) =>
      jniAccessors.callMethodWithArgs(reference, _id_setNotificationUri,
          jni.JniType.voidType, [cr.reference, notifyUri.reference]).check();

  static final _id_getNotificationUri = jniAccessors.getMethodIDOf(
      _classRef, "getNotificationUri", "()Landroid/net/Uri;");

  /// from: public android.net.Uri getNotificationUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  uri_.Uri getNotificationUri() =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getNotificationUri, jni.JniType.objectType, []).object);

  static final _id_getWantsAllOnMoveCalls =
      jniAccessors.getMethodIDOf(_classRef, "getWantsAllOnMoveCalls", "()Z");

  /// from: public boolean getWantsAllOnMoveCalls()
  bool getWantsAllOnMoveCalls() => jniAccessors.callMethodWithArgs(reference,
      _id_getWantsAllOnMoveCalls, jni.JniType.booleanType, []).boolean;

  static final _id_setExtras = jniAccessors.getMethodIDOf(
      _classRef, "setExtras", "(Landroid/os/Bundle;)V");

  /// from: public void setExtras(android.os.Bundle extras)
  void setExtras(bundle_.Bundle extras) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setExtras,
      jni.JniType.voidType,
      [extras.reference]).check();

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_respond = jniAccessors.getMethodIDOf(
      _classRef, "respond", "(Landroid/os/Bundle;)Landroid/os/Bundle;");

  /// from: public android.os.Bundle respond(android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  bundle_.Bundle respond(bundle_.Bundle extras) =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_respond, jni.JniType.objectType, [extras.reference]).object);

  static final _id_isFieldUpdated =
      jniAccessors.getMethodIDOf(_classRef, "isFieldUpdated", "(I)Z");

  /// from: protected boolean isFieldUpdated(int columnIndex)
  ///
  /// @deprecated Always returns false since Cursors do not support updating rows
  bool isFieldUpdated(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference,
      _id_isFieldUpdated,
      jni.JniType.booleanType,
      [columnIndex]).boolean;

  static final _id_getUpdatedField = jniAccessors.getMethodIDOf(
      _classRef, "getUpdatedField", "(I)Ljava/lang/Object;");

  /// from: protected java.lang.Object getUpdatedField(int columnIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Always returns null since Cursors do not support updating rows
  jni.JniObject getUpdatedField(int columnIndex) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getUpdatedField, jni.JniType.objectType, [columnIndex]).object);

  static final _id_checkPosition =
      jniAccessors.getMethodIDOf(_classRef, "checkPosition", "()V");

  /// from: protected void checkPosition()
  ///
  /// This function throws CursorIndexOutOfBoundsException if
  /// the cursor position is out of bounds. Subclass implementations of
  /// the get functions should call this before attempting
  /// to retrieve data.
  ///@throws CursorIndexOutOfBoundsException
  void checkPosition() => jniAccessors.callMethodWithArgs(
      reference, _id_checkPosition, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}

/// from: android.database.AbstractCursor$SelfContentObserver
///
/// Cursors use this class to track changes others make to their URI.
class AbstractCursor_SelfContentObserver
    extends contentobserver_.ContentObserver {
  static final _classRef = jniAccessors
      .getClassOf("android/database/AbstractCursor\$SelfContentObserver");
  AbstractCursor_SelfContentObserver.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/database/AbstractCursor;)V");

  /// from: public void <init>(android.database.AbstractCursor cursor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  AbstractCursor_SelfContentObserver.ctor1(AbstractCursor cursor)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [cursor.reference]).object);

  static final _id_deliverSelfNotifications =
      jniAccessors.getMethodIDOf(_classRef, "deliverSelfNotifications", "()Z");

  /// from: public boolean deliverSelfNotifications()
  bool deliverSelfNotifications() => jniAccessors.callMethodWithArgs(reference,
      _id_deliverSelfNotifications, jni.JniType.booleanType, []).boolean;

  static final _id_onChange =
      jniAccessors.getMethodIDOf(_classRef, "onChange", "(Z)V");

  /// from: public void onChange(boolean selfChange)
  void onChange(bool selfChange) => jniAccessors.callMethodWithArgs(
      reference, _id_onChange, jni.JniType.voidType, [selfChange]).check();
}
