// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Cursor.dart" as cursor_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.database.CursorJoiner
///
/// Does a join on two cursors using the specified columns. The cursors must already
/// be sorted on each of the specified columns in ascending order. This joiner only
/// supports the case where the tuple of key column values is unique.
///
/// Typical usage:
///
/// <pre>
/// CursorJoiner joiner = new CursorJoiner(cursorA, keyColumnsofA, cursorB, keyColumnsofB);
/// for (CursorJoiner.Result joinerResult : joiner) {
///     switch (joinerResult) {
///         case LEFT:
///             // handle case where a row in cursorA is unique
///             break;
///         case RIGHT:
///             // handle case where a row in cursorB is unique
///             break;
///         case BOTH:
///             // handle case where a row with the same key is in both cursors
///             break;
///     }
/// }
/// </pre>
class CursorJoiner extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/database/CursorJoiner");
  CursorJoiner.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/database/Cursor;[Ljava/lang/String;Landroid/database/Cursor;[Ljava/lang/String;)V");

  /// from: public void <init>(android.database.Cursor cursorLeft, java.lang.String[] columnNamesLeft, android.database.Cursor cursorRight, java.lang.String[] columnNamesRight)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Initializes the CursorJoiner and resets the cursors to the first row. The left and right
  /// column name arrays must have the same number of columns.
  ///@param cursorLeft The left cursor to compare
  ///@param columnNamesLeft The column names to compare from the left cursor
  ///@param cursorRight The right cursor to compare
  ///@param columnNamesRight The column names to compare from the right cursor
  CursorJoiner(cursor_.Cursor cursorLeft, jni.JniObject columnNamesLeft,
      cursor_.Cursor cursorRight, jni.JniObject columnNamesRight)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [
          cursorLeft.reference,
          columnNamesLeft.reference,
          cursorRight.reference,
          columnNamesRight.reference
        ]).object);

  static final _id_iterator = jniAccessors.getMethodIDOf(
      _classRef, "iterator", "()Ljava/util/Iterator;");

  /// from: public java.util.Iterator<android.database.CursorJoiner.Result> iterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject iterator() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_iterator, jni.JniType.objectType, []).object);

  static final _id_hasNext =
      jniAccessors.getMethodIDOf(_classRef, "hasNext", "()Z");

  /// from: public boolean hasNext()
  ///
  /// Returns whether or not there are more rows to compare using next().
  ///@return true if there are more rows to compare
  bool hasNext() => jniAccessors.callMethodWithArgs(
      reference, _id_hasNext, jni.JniType.booleanType, []).boolean;

  static final _id_next = jniAccessors.getMethodIDOf(
      _classRef, "next", "()Landroid/database/CursorJoiner\$Result;");

  /// from: public android.database.CursorJoiner.Result next()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the comparison result of the next row from each cursor. If one cursor
  /// has no more rows but the other does then subsequent calls to this will indicate that
  /// the remaining rows are unique.
  ///
  /// The caller must check that hasNext() returns true before calling this.
  ///
  /// Once next() has been called the cursors specified in the result of the call to
  /// next() are guaranteed to point to the row that was indicated. Reading values
  /// from the cursor that was not indicated in the call to next() will result in
  /// undefined behavior.
  ///@return LEFT, if the row pointed to by the left cursor is unique, RIGHT
  ///   if the row pointed to by the right cursor is unique, BOTH if the rows in both
  ///   cursors are the same.
  CursorJoiner_Result next() =>
      CursorJoiner_Result.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_next, jni.JniType.objectType, []).object);

  static final _id_remove =
      jniAccessors.getMethodIDOf(_classRef, "remove", "()V");

  /// from: public void remove()
  void remove() => jniAccessors.callMethodWithArgs(
      reference, _id_remove, jni.JniType.voidType, []).check();
}

/// from: android.database.CursorJoiner$Result
///
/// The result of a call to next().
class CursorJoiner_Result extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/database/CursorJoiner\$Result");
  CursorJoiner_Result.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/database/CursorJoiner\$Result;");

  /// from: static public android.database.CursorJoiner.Result[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/database/CursorJoiner\$Result;");

  /// from: static public android.database.CursorJoiner.Result valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static CursorJoiner_Result valueOf(jni.JniString name) =>
      CursorJoiner_Result.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);
}
