// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "CharArrayBuffer.dart" as chararraybuffer_;

import "ContentObserver.dart" as contentobserver_;

import "DataSetObserver.dart" as datasetobserver_;

import "../content/ContentResolver.dart" as contentresolver_;

import "../net/Uri.dart" as uri_;

import "../os/Bundle.dart" as bundle_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.database.Cursor
///
/// This interface provides random read-write access to the result set returned
/// by a database query.
///
/// Cursor implementations are not required to be synchronized so code using a Cursor from multiple
/// threads should perform its own synchronization when using the Cursor.
///
///
/// Implementations should subclass AbstractCursor.
///
///
class Cursor extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/database/Cursor");
  Cursor.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int FIELD_TYPE_BLOB
  ///
  /// Value returned by \#getType(int) if the specified column type is blob
  static const FIELD_TYPE_BLOB = 4;

  /// from: static public final int FIELD_TYPE_FLOAT
  ///
  /// Value returned by \#getType(int) if the specified column type is float
  static const FIELD_TYPE_FLOAT = 2;

  /// from: static public final int FIELD_TYPE_INTEGER
  ///
  /// Value returned by \#getType(int) if the specified  column type is integer
  static const FIELD_TYPE_INTEGER = 1;

  /// from: static public final int FIELD_TYPE_NULL
  ///
  /// Value returned by \#getType(int) if the specified column is null
  static const FIELD_TYPE_NULL = 0;

  /// from: static public final int FIELD_TYPE_STRING
  ///
  /// Value returned by \#getType(int) if the specified column type is string
  static const FIELD_TYPE_STRING = 3;

  static final _id_getCount =
      jniAccessors.getMethodIDOf(_classRef, "getCount", "()I");

  /// from: public abstract int getCount()
  ///
  /// Returns the numbers of rows in the cursor.
  ///@return the number of rows in the cursor.
  int getCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getCount, jni.JniType.intType, []).integer;

  static final _id_getPosition =
      jniAccessors.getMethodIDOf(_classRef, "getPosition", "()I");

  /// from: public abstract int getPosition()
  ///
  /// Returns the current position of the cursor in the row set.
  /// The value is zero-based. When the row set is first returned the cursor
  /// will be at positon -1, which is before the first row. After the
  /// last row is returned another call to next() will leave the cursor past
  /// the last entry, at a position of count().
  ///@return the current cursor position.
  int getPosition() => jniAccessors.callMethodWithArgs(
      reference, _id_getPosition, jni.JniType.intType, []).integer;

  static final _id_move = jniAccessors.getMethodIDOf(_classRef, "move", "(I)Z");

  /// from: public abstract boolean move(int offset)
  ///
  /// Move the cursor by a relative amount, forward or backward, from the
  /// current position. Positive offsets move forwards, negative offsets move
  /// backwards. If the final position is outside of the bounds of the result
  /// set then the resultant position will be pinned to -1 or count() depending
  /// on whether the value is off the front or end of the set, respectively.
  ///
  /// This method will return true if the requested destination was
  /// reachable, otherwise, it returns false. For example, if the cursor is at
  /// currently on the second entry in the result set and move(-5) is called,
  /// the position will be pinned at -1, and false will be returned.
  ///@param offset the offset to be applied from the current position.
  ///@return whether the requested move fully succeeded.
  bool move(int offset) => jniAccessors.callMethodWithArgs(
      reference, _id_move, jni.JniType.booleanType, [offset]).boolean;

  static final _id_moveToPosition =
      jniAccessors.getMethodIDOf(_classRef, "moveToPosition", "(I)Z");

  /// from: public abstract boolean moveToPosition(int position)
  ///
  /// Move the cursor to an absolute position. The valid
  /// range of values is -1 &lt;= position &lt;= count.
  ///
  /// This method will return true if the request destination was reachable,
  /// otherwise, it returns false.
  ///@param position the zero-based position to move to.
  ///@return whether the requested move fully succeeded.
  bool moveToPosition(int position) => jniAccessors.callMethodWithArgs(
      reference,
      _id_moveToPosition,
      jni.JniType.booleanType,
      [position]).boolean;

  static final _id_moveToFirst =
      jniAccessors.getMethodIDOf(_classRef, "moveToFirst", "()Z");

  /// from: public abstract boolean moveToFirst()
  ///
  /// Move the cursor to the first row.
  ///
  /// This method will return false if the cursor is empty.
  ///@return whether the move succeeded.
  bool moveToFirst() => jniAccessors.callMethodWithArgs(
      reference, _id_moveToFirst, jni.JniType.booleanType, []).boolean;

  static final _id_moveToLast =
      jniAccessors.getMethodIDOf(_classRef, "moveToLast", "()Z");

  /// from: public abstract boolean moveToLast()
  ///
  /// Move the cursor to the last row.
  ///
  /// This method will return false if the cursor is empty.
  ///@return whether the move succeeded.
  bool moveToLast() => jniAccessors.callMethodWithArgs(
      reference, _id_moveToLast, jni.JniType.booleanType, []).boolean;

  static final _id_moveToNext =
      jniAccessors.getMethodIDOf(_classRef, "moveToNext", "()Z");

  /// from: public abstract boolean moveToNext()
  ///
  /// Move the cursor to the next row.
  ///
  /// This method will return false if the cursor is already past the
  /// last entry in the result set.
  ///@return whether the move succeeded.
  bool moveToNext() => jniAccessors.callMethodWithArgs(
      reference, _id_moveToNext, jni.JniType.booleanType, []).boolean;

  static final _id_moveToPrevious =
      jniAccessors.getMethodIDOf(_classRef, "moveToPrevious", "()Z");

  /// from: public abstract boolean moveToPrevious()
  ///
  /// Move the cursor to the previous row.
  ///
  /// This method will return false if the cursor is already before the
  /// first entry in the result set.
  ///@return whether the move succeeded.
  bool moveToPrevious() => jniAccessors.callMethodWithArgs(
      reference, _id_moveToPrevious, jni.JniType.booleanType, []).boolean;

  static final _id_isFirst =
      jniAccessors.getMethodIDOf(_classRef, "isFirst", "()Z");

  /// from: public abstract boolean isFirst()
  ///
  /// Returns whether the cursor is pointing to the first row.
  ///@return whether the cursor is pointing at the first entry.
  bool isFirst() => jniAccessors.callMethodWithArgs(
      reference, _id_isFirst, jni.JniType.booleanType, []).boolean;

  static final _id_isLast =
      jniAccessors.getMethodIDOf(_classRef, "isLast", "()Z");

  /// from: public abstract boolean isLast()
  ///
  /// Returns whether the cursor is pointing to the last row.
  ///@return whether the cursor is pointing at the last entry.
  bool isLast() => jniAccessors.callMethodWithArgs(
      reference, _id_isLast, jni.JniType.booleanType, []).boolean;

  static final _id_isBeforeFirst =
      jniAccessors.getMethodIDOf(_classRef, "isBeforeFirst", "()Z");

  /// from: public abstract boolean isBeforeFirst()
  ///
  /// Returns whether the cursor is pointing to the position before the first
  /// row.
  ///@return whether the cursor is before the first result.
  bool isBeforeFirst() => jniAccessors.callMethodWithArgs(
      reference, _id_isBeforeFirst, jni.JniType.booleanType, []).boolean;

  static final _id_isAfterLast =
      jniAccessors.getMethodIDOf(_classRef, "isAfterLast", "()Z");

  /// from: public abstract boolean isAfterLast()
  ///
  /// Returns whether the cursor is pointing to the position after the last
  /// row.
  ///@return whether the cursor is after the last result.
  bool isAfterLast() => jniAccessors.callMethodWithArgs(
      reference, _id_isAfterLast, jni.JniType.booleanType, []).boolean;

  static final _id_getColumnIndex = jniAccessors.getMethodIDOf(
      _classRef, "getColumnIndex", "(Ljava/lang/String;)I");

  /// from: public abstract int getColumnIndex(java.lang.String columnName)
  ///
  /// Returns the zero-based index for the given column name, or -1 if the column doesn't exist.
  /// If you expect the column to exist use \#getColumnIndexOrThrow(String) instead, which
  /// will make the error more clear.
  ///@param columnName the name of the target column.
  ///@return the zero-based column index for the given column name, or -1 if
  /// the column name does not exist.
  ///@see \#getColumnIndexOrThrow(String)
  int getColumnIndex(jni.JniString columnName) =>
      jniAccessors.callMethodWithArgs(reference, _id_getColumnIndex,
          jni.JniType.intType, [columnName.reference]).integer;

  static final _id_getColumnIndexOrThrow = jniAccessors.getMethodIDOf(
      _classRef, "getColumnIndexOrThrow", "(Ljava/lang/String;)I");

  /// from: public abstract int getColumnIndexOrThrow(java.lang.String columnName)
  ///
  /// Returns the zero-based index for the given column name, or throws
  /// IllegalArgumentException if the column doesn't exist. If you're not sure if
  /// a column will exist or not use \#getColumnIndex(String) and check for -1, which
  /// is more efficient than catching the exceptions.
  ///@param columnName the name of the target column.
  ///@return the zero-based column index for the given column name
  ///@see \#getColumnIndex(String)
  ///@throws IllegalArgumentException if the column does not exist
  int getColumnIndexOrThrow(jni.JniString columnName) =>
      jniAccessors.callMethodWithArgs(reference, _id_getColumnIndexOrThrow,
          jni.JniType.intType, [columnName.reference]).integer;

  static final _id_getColumnName = jniAccessors.getMethodIDOf(
      _classRef, "getColumnName", "(I)Ljava/lang/String;");

  /// from: public abstract java.lang.String getColumnName(int columnIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the column name at the given zero-based column index.
  ///@param columnIndex the zero-based index of the target column.
  ///@return the column name for the given column index.
  jni.JniString getColumnName(int columnIndex) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getColumnName, jni.JniType.objectType, [columnIndex]).object);

  static final _id_getColumnNames = jniAccessors.getMethodIDOf(
      _classRef, "getColumnNames", "()[Ljava/lang/String;");

  /// from: public abstract java.lang.String[] getColumnNames()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a string array holding the names of all of the columns in the
  /// result set in the order in which they were listed in the result.
  ///@return the names of the columns returned in this query.
  jni.JniObject getColumnNames() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getColumnNames, jni.JniType.objectType, []).object);

  static final _id_getColumnCount =
      jniAccessors.getMethodIDOf(_classRef, "getColumnCount", "()I");

  /// from: public abstract int getColumnCount()
  ///
  /// Return total number of columns
  ///@return number of columns
  int getColumnCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getColumnCount, jni.JniType.intType, []).integer;

  static final _id_getBlob =
      jniAccessors.getMethodIDOf(_classRef, "getBlob", "(I)[B");

  /// from: public abstract byte[] getBlob(int columnIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value of the requested column as a byte array.
  ///
  /// The result and whether this method throws an exception when the
  /// column value is null or the column type is not a blob type is
  /// implementation-defined.
  ///@param columnIndex the zero-based index of the target column.
  ///@return the value of that column as a byte array.
  jni.JniObject getBlob(int columnIndex) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getBlob, jni.JniType.objectType, [columnIndex]).object);

  static final _id_getString = jniAccessors.getMethodIDOf(
      _classRef, "getString", "(I)Ljava/lang/String;");

  /// from: public abstract java.lang.String getString(int columnIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value of the requested column as a String.
  ///
  /// The result and whether this method throws an exception when the
  /// column value is null or the column type is not a string type is
  /// implementation-defined.
  ///@param columnIndex the zero-based index of the target column.
  ///@return the value of that column as a String.
  jni.JniString getString(int columnIndex) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getString, jni.JniType.objectType, [columnIndex]).object);

  static final _id_copyStringToBuffer = jniAccessors.getMethodIDOf(_classRef,
      "copyStringToBuffer", "(ILandroid/database/CharArrayBuffer;)V");

  /// from: public abstract void copyStringToBuffer(int columnIndex, android.database.CharArrayBuffer buffer)
  ///
  /// Retrieves the requested column text and stores it in the buffer provided.
  /// If the buffer size is not sufficient, a new char buffer will be allocated
  /// and assigned to CharArrayBuffer.data
  ///@param columnIndex the zero-based index of the target column.
  ///        if the target column is null, return buffer
  ///@param buffer the buffer to copy the text into.
  void copyStringToBuffer(
          int columnIndex, chararraybuffer_.CharArrayBuffer buffer) =>
      jniAccessors.callMethodWithArgs(reference, _id_copyStringToBuffer,
          jni.JniType.voidType, [columnIndex, buffer.reference]).check();

  static final _id_getShort =
      jniAccessors.getMethodIDOf(_classRef, "getShort", "(I)S");

  /// from: public abstract short getShort(int columnIndex)
  ///
  /// Returns the value of the requested column as a short.
  ///
  /// The result and whether this method throws an exception when the
  /// column value is null, the column type is not an integral type, or the
  /// integer value is outside the range [<code>Short.MIN_VALUE</code>,
  /// <code>Short.MAX_VALUE</code>] is implementation-defined.
  ///@param columnIndex the zero-based index of the target column.
  ///@return the value of that column as a short.
  int getShort(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_getShort, jni.JniType.shortType, [columnIndex]).short;

  static final _id_getInt =
      jniAccessors.getMethodIDOf(_classRef, "getInt", "(I)I");

  /// from: public abstract int getInt(int columnIndex)
  ///
  /// Returns the value of the requested column as an int.
  ///
  /// The result and whether this method throws an exception when the
  /// column value is null, the column type is not an integral type, or the
  /// integer value is outside the range [<code>Integer.MIN_VALUE</code>,
  /// <code>Integer.MAX_VALUE</code>] is implementation-defined.
  ///@param columnIndex the zero-based index of the target column.
  ///@return the value of that column as an int.
  int getInt(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_getInt, jni.JniType.intType, [columnIndex]).integer;

  static final _id_getLong =
      jniAccessors.getMethodIDOf(_classRef, "getLong", "(I)J");

  /// from: public abstract long getLong(int columnIndex)
  ///
  /// Returns the value of the requested column as a long.
  ///
  /// The result and whether this method throws an exception when the
  /// column value is null, the column type is not an integral type, or the
  /// integer value is outside the range [<code>Long.MIN_VALUE</code>,
  /// <code>Long.MAX_VALUE</code>] is implementation-defined.
  ///@param columnIndex the zero-based index of the target column.
  ///@return the value of that column as a long.
  int getLong(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_getLong, jni.JniType.longType, [columnIndex]).long;

  static final _id_getFloat =
      jniAccessors.getMethodIDOf(_classRef, "getFloat", "(I)F");

  /// from: public abstract float getFloat(int columnIndex)
  ///
  /// Returns the value of the requested column as a float.
  ///
  /// The result and whether this method throws an exception when the
  /// column value is null, the column type is not a floating-point type, or the
  /// floating-point value is not representable as a <code>float</code> value is
  /// implementation-defined.
  ///@param columnIndex the zero-based index of the target column.
  ///@return the value of that column as a float.
  double getFloat(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_getFloat, jni.JniType.floatType, [columnIndex]).float;

  static final _id_getDouble =
      jniAccessors.getMethodIDOf(_classRef, "getDouble", "(I)D");

  /// from: public abstract double getDouble(int columnIndex)
  ///
  /// Returns the value of the requested column as a double.
  ///
  /// The result and whether this method throws an exception when the
  /// column value is null, the column type is not a floating-point type, or the
  /// floating-point value is not representable as a <code>double</code> value is
  /// implementation-defined.
  ///@param columnIndex the zero-based index of the target column.
  ///@return the value of that column as a double.
  double getDouble(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getDouble,
      jni.JniType.doubleType,
      [columnIndex]).doubleFloat;

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "(I)I");

  /// from: public abstract int getType(int columnIndex)
  ///
  /// Returns data type of the given column's value.
  /// The preferred type of the column is returned but the data may be converted to other types
  /// as documented in the get-type methods such as \#getInt(int), \#getFloat(int)
  /// etc.
  ///
  /// Returned column types are
  /// <ul>
  ///   <li>\#FIELD_TYPE_NULL</li>
  ///   <li>\#FIELD_TYPE_INTEGER</li>
  ///   <li>\#FIELD_TYPE_FLOAT</li>
  ///   <li>\#FIELD_TYPE_STRING</li>
  ///   <li>\#FIELD_TYPE_BLOB</li>
  ///</ul>
  ///
  ///
  ///@param columnIndex the zero-based index of the target column.
  ///@return column value type
  int getType(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_getType, jni.JniType.intType, [columnIndex]).integer;

  static final _id_isNull1 =
      jniAccessors.getMethodIDOf(_classRef, "isNull", "(I)Z");

  /// from: public abstract boolean isNull(int columnIndex)
  ///
  /// Returns <code>true</code> if the value in the indicated column is null.
  ///@param columnIndex the zero-based index of the target column.
  ///@return whether the column value is null.
  bool isNull1(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_isNull1, jni.JniType.booleanType, [columnIndex]).boolean;

  static final _id_deactivate =
      jniAccessors.getMethodIDOf(_classRef, "deactivate", "()V");

  /// from: public abstract void deactivate()
  ///
  /// Deactivates the Cursor, making all calls on it fail until \#requery is called.
  /// Inactive Cursors use fewer resources than active Cursors.
  /// Calling \#requery will make the cursor active again.
  ///@deprecated Since \#requery() is deprecated, so too is this.
  void deactivate() => jniAccessors.callMethodWithArgs(
      reference, _id_deactivate, jni.JniType.voidType, []).check();

  static final _id_requery =
      jniAccessors.getMethodIDOf(_classRef, "requery", "()Z");

  /// from: public abstract boolean requery()
  ///
  /// Performs the query that created the cursor again, refreshing its
  /// contents. This may be done at any time, including after a call to \#deactivate.
  ///
  /// Since this method could execute a query on the database and potentially take
  /// a while, it could cause ANR if it is called on Main (UI) thread.
  /// A warning is printed if this method is being executed on Main thread.
  ///@return true if the requery succeeded, false if not, in which case the
  ///         cursor becomes invalid.
  ///@deprecated Don't use this. Just request a new cursor, so you can do this
  /// asynchronously and update your list view once the new cursor comes back.
  bool requery() => jniAccessors.callMethodWithArgs(
      reference, _id_requery, jni.JniType.booleanType, []).boolean;

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public abstract void close()
  ///
  /// Closes the Cursor, releasing all of its resources and making it completely invalid.
  /// Unlike \#deactivate() a call to \#requery() will not make the Cursor valid
  /// again.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_isClosed =
      jniAccessors.getMethodIDOf(_classRef, "isClosed", "()Z");

  /// from: public abstract boolean isClosed()
  ///
  /// return true if the cursor is closed
  ///@return true if the cursor is closed.
  bool isClosed() => jniAccessors.callMethodWithArgs(
      reference, _id_isClosed, jni.JniType.booleanType, []).boolean;

  static final _id_registerContentObserver = jniAccessors.getMethodIDOf(
      _classRef,
      "registerContentObserver",
      "(Landroid/database/ContentObserver;)V");

  /// from: public abstract void registerContentObserver(android.database.ContentObserver observer)
  ///
  /// Register an observer that is called when changes happen to the content backing this cursor.
  /// Typically the data set won't change until \#requery() is called.
  ///@param observer the object that gets notified when the content backing the cursor changes.
  ///@see \#unregisterContentObserver(ContentObserver)
  void registerContentObserver(contentobserver_.ContentObserver observer) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerContentObserver,
          jni.JniType.voidType, [observer.reference]).check();

  static final _id_unregisterContentObserver = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterContentObserver",
      "(Landroid/database/ContentObserver;)V");

  /// from: public abstract void unregisterContentObserver(android.database.ContentObserver observer)
  ///
  /// Unregister an observer that has previously been registered with this
  /// cursor via \#registerContentObserver.
  ///@param observer the object to unregister.
  ///@see \#registerContentObserver(ContentObserver)
  void unregisterContentObserver(contentobserver_.ContentObserver observer) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterContentObserver,
          jni.JniType.voidType, [observer.reference]).check();

  static final _id_registerDataSetObserver = jniAccessors.getMethodIDOf(
      _classRef,
      "registerDataSetObserver",
      "(Landroid/database/DataSetObserver;)V");

  /// from: public abstract void registerDataSetObserver(android.database.DataSetObserver observer)
  ///
  /// Register an observer that is called when changes happen to the contents
  /// of the this cursors data set, for example, when the data set is changed via
  /// \#requery(), \#deactivate(), or \#close().
  ///@param observer the object that gets notified when the cursors data set changes.
  ///@see \#unregisterDataSetObserver(DataSetObserver)
  void registerDataSetObserver(datasetobserver_.DataSetObserver observer) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerDataSetObserver,
          jni.JniType.voidType, [observer.reference]).check();

  static final _id_unregisterDataSetObserver = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterDataSetObserver",
      "(Landroid/database/DataSetObserver;)V");

  /// from: public abstract void unregisterDataSetObserver(android.database.DataSetObserver observer)
  ///
  /// Unregister an observer that has previously been registered with this
  /// cursor via \#registerContentObserver.
  ///@param observer the object to unregister.
  ///@see \#registerDataSetObserver(DataSetObserver)
  void unregisterDataSetObserver(datasetobserver_.DataSetObserver observer) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterDataSetObserver,
          jni.JniType.voidType, [observer.reference]).check();

  static final _id_setNotificationUri = jniAccessors.getMethodIDOf(
      _classRef,
      "setNotificationUri",
      "(Landroid/content/ContentResolver;Landroid/net/Uri;)V");

  /// from: public abstract void setNotificationUri(android.content.ContentResolver cr, android.net.Uri uri)
  ///
  /// Register to watch a content URI for changes. This can be the URI of a specific data row (for
  /// example, "content://my_provider_type/23"), or a a generic URI for a content type.
  ///@param cr The content resolver from the caller's context. The listener attached to
  /// this resolver will be notified.
  ///@param uri The content URI to watch.
  void setNotificationUri(contentresolver_.ContentResolver cr, uri_.Uri uri) =>
      jniAccessors.callMethodWithArgs(reference, _id_setNotificationUri,
          jni.JniType.voidType, [cr.reference, uri.reference]).check();

  static final _id_getNotificationUri = jniAccessors.getMethodIDOf(
      _classRef, "getNotificationUri", "()Landroid/net/Uri;");

  /// from: public abstract android.net.Uri getNotificationUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the URI at which notifications of changes in this Cursor's data
  /// will be delivered, as previously set by \#setNotificationUri.
  ///@return Returns a URI that can be used with
  /// ContentResolver\#registerContentObserver(android.net.Uri, boolean, ContentObserver) ContentResolver.registerContentObserver to find out about changes to this Cursor's
  /// data.  May be null if no notification URI has been set.
  uri_.Uri getNotificationUri() =>
      uri_.Uri.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getNotificationUri, jni.JniType.objectType, []).object);

  static final _id_getWantsAllOnMoveCalls =
      jniAccessors.getMethodIDOf(_classRef, "getWantsAllOnMoveCalls", "()Z");

  /// from: public abstract boolean getWantsAllOnMoveCalls()
  ///
  /// onMove() will only be called across processes if this method returns true.
  ///@return whether all cursor movement should result in a call to onMove().
  bool getWantsAllOnMoveCalls() => jniAccessors.callMethodWithArgs(reference,
      _id_getWantsAllOnMoveCalls, jni.JniType.booleanType, []).boolean;

  static final _id_setExtras = jniAccessors.getMethodIDOf(
      _classRef, "setExtras", "(Landroid/os/Bundle;)V");

  /// from: public abstract void setExtras(android.os.Bundle extras)
  ///
  /// Sets a Bundle that will be returned by \#getExtras().
  ///@param extras Bundle to set, or null to set an empty bundle.
  void setExtras(bundle_.Bundle extras) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setExtras,
      jni.JniType.voidType,
      [extras.reference]).check();

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public abstract android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a bundle of extra values. This is an optional way for cursors to provide out-of-band
  /// metadata to their users. One use of this is for reporting on the progress of network requests
  /// that are required to fetch data for the cursor.
  ///
  /// These values may only change when requery is called.
  ///@return cursor-defined values, or android.os.Bundle\#EMPTY Bundle.EMPTY if there
  ///         are no values. Never <code>null</code>.
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_respond = jniAccessors.getMethodIDOf(
      _classRef, "respond", "(Landroid/os/Bundle;)Landroid/os/Bundle;");

  /// from: public abstract android.os.Bundle respond(android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This is an out-of-band way for the the user of a cursor to communicate with the cursor. The
  /// structure of each bundle is entirely defined by the cursor.
  ///
  /// One use of this is to tell a cursor that it should retry its network request after it
  /// reported an error.
  ///@param extras extra values, or android.os.Bundle\#EMPTY Bundle.EMPTY.
  ///         Never <code>null</code>.
  ///@return extra values, or android.os.Bundle\#EMPTY Bundle.EMPTY.
  ///         Never <code>null</code>.
  bundle_.Bundle respond(bundle_.Bundle extras) =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_respond, jni.JniType.objectType, [extras.reference]).object);
}
