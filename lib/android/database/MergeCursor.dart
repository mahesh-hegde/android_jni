// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "AbstractCursor.dart" as abstractcursor_;

import "ContentObserver.dart" as contentobserver_;

import "DataSetObserver.dart" as datasetobserver_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.database.MergeCursor
///
/// A convenience class that lets you present an array of Cursors as a single linear Cursor.
/// The schema of the cursors presented is entirely up to the creator of the MergeCursor, and
/// may be different if that is desired. Calls to getColumns, getColumnIndex, etc will return the
/// value for the row that the MergeCursor is currently pointing at.
class MergeCursor extends abstractcursor_.AbstractCursor {
  static final _classRef =
      jniAccessors.getClassOf("android/database/MergeCursor");
  MergeCursor.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "([Landroid/database/Cursor;)V");

  /// from: public void <init>(android.database.Cursor[] cursors)
  /// The returned object must be deleted after use, by calling the `delete` method.
  MergeCursor.ctor1(jni.JniObject cursors)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [cursors.reference]).object);

  static final _id_getCount =
      jniAccessors.getMethodIDOf(_classRef, "getCount", "()I");

  /// from: public int getCount()
  int getCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getCount, jni.JniType.intType, []).integer;

  static final _id_onMove =
      jniAccessors.getMethodIDOf(_classRef, "onMove", "(II)Z");

  /// from: public boolean onMove(int oldPosition, int newPosition)
  bool onMove(int oldPosition, int newPosition) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMove,
          jni.JniType.booleanType, [oldPosition, newPosition]).boolean;

  static final _id_getString = jniAccessors.getMethodIDOf(
      _classRef, "getString", "(I)Ljava/lang/String;");

  /// from: public java.lang.String getString(int column)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getString(int column) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getString, jni.JniType.objectType, [column]).object);

  static final _id_getShort =
      jniAccessors.getMethodIDOf(_classRef, "getShort", "(I)S");

  /// from: public short getShort(int column)
  int getShort(int column) => jniAccessors.callMethodWithArgs(
      reference, _id_getShort, jni.JniType.shortType, [column]).short;

  static final _id_getInt =
      jniAccessors.getMethodIDOf(_classRef, "getInt", "(I)I");

  /// from: public int getInt(int column)
  int getInt(int column) => jniAccessors.callMethodWithArgs(
      reference, _id_getInt, jni.JniType.intType, [column]).integer;

  static final _id_getLong =
      jniAccessors.getMethodIDOf(_classRef, "getLong", "(I)J");

  /// from: public long getLong(int column)
  int getLong(int column) => jniAccessors.callMethodWithArgs(
      reference, _id_getLong, jni.JniType.longType, [column]).long;

  static final _id_getFloat =
      jniAccessors.getMethodIDOf(_classRef, "getFloat", "(I)F");

  /// from: public float getFloat(int column)
  double getFloat(int column) => jniAccessors.callMethodWithArgs(
      reference, _id_getFloat, jni.JniType.floatType, [column]).float;

  static final _id_getDouble =
      jniAccessors.getMethodIDOf(_classRef, "getDouble", "(I)D");

  /// from: public double getDouble(int column)
  double getDouble(int column) => jniAccessors.callMethodWithArgs(
      reference, _id_getDouble, jni.JniType.doubleType, [column]).doubleFloat;

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "(I)I");

  /// from: public int getType(int column)
  int getType(int column) => jniAccessors.callMethodWithArgs(
      reference, _id_getType, jni.JniType.intType, [column]).integer;

  static final _id_isNull1 =
      jniAccessors.getMethodIDOf(_classRef, "isNull", "(I)Z");

  /// from: public boolean isNull(int column)
  bool isNull1(int column) => jniAccessors.callMethodWithArgs(
      reference, _id_isNull1, jni.JniType.booleanType, [column]).boolean;

  static final _id_getBlob =
      jniAccessors.getMethodIDOf(_classRef, "getBlob", "(I)[B");

  /// from: public byte[] getBlob(int column)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getBlob(int column) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBlob, jni.JniType.objectType, [column]).object);

  static final _id_getColumnNames = jniAccessors.getMethodIDOf(
      _classRef, "getColumnNames", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getColumnNames()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getColumnNames() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getColumnNames, jni.JniType.objectType, []).object);

  static final _id_deactivate =
      jniAccessors.getMethodIDOf(_classRef, "deactivate", "()V");

  /// from: public void deactivate()
  void deactivate() => jniAccessors.callMethodWithArgs(
      reference, _id_deactivate, jni.JniType.voidType, []).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_registerContentObserver = jniAccessors.getMethodIDOf(
      _classRef,
      "registerContentObserver",
      "(Landroid/database/ContentObserver;)V");

  /// from: public void registerContentObserver(android.database.ContentObserver observer)
  void registerContentObserver(contentobserver_.ContentObserver observer) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerContentObserver,
          jni.JniType.voidType, [observer.reference]).check();

  static final _id_unregisterContentObserver = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterContentObserver",
      "(Landroid/database/ContentObserver;)V");

  /// from: public void unregisterContentObserver(android.database.ContentObserver observer)
  void unregisterContentObserver(contentobserver_.ContentObserver observer) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterContentObserver,
          jni.JniType.voidType, [observer.reference]).check();

  static final _id_registerDataSetObserver = jniAccessors.getMethodIDOf(
      _classRef,
      "registerDataSetObserver",
      "(Landroid/database/DataSetObserver;)V");

  /// from: public void registerDataSetObserver(android.database.DataSetObserver observer)
  void registerDataSetObserver(datasetobserver_.DataSetObserver observer) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerDataSetObserver,
          jni.JniType.voidType, [observer.reference]).check();

  static final _id_unregisterDataSetObserver = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterDataSetObserver",
      "(Landroid/database/DataSetObserver;)V");

  /// from: public void unregisterDataSetObserver(android.database.DataSetObserver observer)
  void unregisterDataSetObserver(datasetobserver_.DataSetObserver observer) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterDataSetObserver,
          jni.JniType.voidType, [observer.reference]).check();

  static final _id_requery =
      jniAccessors.getMethodIDOf(_classRef, "requery", "()Z");

  /// from: public boolean requery()
  bool requery() => jniAccessors.callMethodWithArgs(
      reference, _id_requery, jni.JniType.booleanType, []).boolean;
}
