// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "AbstractCursor.dart" as abstractcursor_;

import "CursorWindow.dart" as cursorwindow_;

import "CharArrayBuffer.dart" as chararraybuffer_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.database.AbstractWindowedCursor
///
/// A base class for Cursors that store their data in CursorWindows.
///
/// The cursor owns the cursor window it uses.  When the cursor is closed,
/// its window is also closed.  Likewise, when the window used by the cursor is
/// changed, its old window is closed.  This policy of strict ownership ensures
/// that cursor windows are not leaked.
///
///
/// Subclasses are responsible for filling the cursor window with data during
/// \#onMove(int, int), allocating a new cursor window if necessary.
/// During \#requery(), the existing cursor window should be cleared and
/// filled with new data.
///
///
/// If the contents of the cursor change or become invalid, the old window must be closed
/// (because it is owned by the cursor) and set to null.
///
///
class AbstractWindowedCursor extends abstractcursor_.AbstractCursor {
  static final _classRef =
      jniAccessors.getClassOf("android/database/AbstractWindowedCursor");
  AbstractWindowedCursor.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_mWindow = jniAccessors.getFieldIDOf(
      _classRef, "mWindow", "Landroid/database/CursorWindow;");

  /// from: protected android.database.CursorWindow mWindow
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The cursor window owned by this cursor.
  cursorwindow_.CursorWindow get mWindow =>
      cursorwindow_.CursorWindow.fromRef(jniAccessors
          .getField(reference, _id_mWindow, jni.JniType.objectType)
          .object);

  /// from: protected android.database.CursorWindow mWindow
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The cursor window owned by this cursor.
  set mWindow(cursorwindow_.CursorWindow value) =>
      jniEnv.SetObjectField(reference, _id_mWindow, value.reference);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AbstractWindowedCursor()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getBlob =
      jniAccessors.getMethodIDOf(_classRef, "getBlob", "(I)[B");

  /// from: public byte[] getBlob(int columnIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getBlob(int columnIndex) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getBlob, jni.JniType.objectType, [columnIndex]).object);

  static final _id_getString = jniAccessors.getMethodIDOf(
      _classRef, "getString", "(I)Ljava/lang/String;");

  /// from: public java.lang.String getString(int columnIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getString(int columnIndex) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getString, jni.JniType.objectType, [columnIndex]).object);

  static final _id_copyStringToBuffer = jniAccessors.getMethodIDOf(_classRef,
      "copyStringToBuffer", "(ILandroid/database/CharArrayBuffer;)V");

  /// from: public void copyStringToBuffer(int columnIndex, android.database.CharArrayBuffer buffer)
  void copyStringToBuffer(
          int columnIndex, chararraybuffer_.CharArrayBuffer buffer) =>
      jniAccessors.callMethodWithArgs(reference, _id_copyStringToBuffer,
          jni.JniType.voidType, [columnIndex, buffer.reference]).check();

  static final _id_getShort =
      jniAccessors.getMethodIDOf(_classRef, "getShort", "(I)S");

  /// from: public short getShort(int columnIndex)
  int getShort(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_getShort, jni.JniType.shortType, [columnIndex]).short;

  static final _id_getInt =
      jniAccessors.getMethodIDOf(_classRef, "getInt", "(I)I");

  /// from: public int getInt(int columnIndex)
  int getInt(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_getInt, jni.JniType.intType, [columnIndex]).integer;

  static final _id_getLong =
      jniAccessors.getMethodIDOf(_classRef, "getLong", "(I)J");

  /// from: public long getLong(int columnIndex)
  int getLong(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_getLong, jni.JniType.longType, [columnIndex]).long;

  static final _id_getFloat =
      jniAccessors.getMethodIDOf(_classRef, "getFloat", "(I)F");

  /// from: public float getFloat(int columnIndex)
  double getFloat(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_getFloat, jni.JniType.floatType, [columnIndex]).float;

  static final _id_getDouble =
      jniAccessors.getMethodIDOf(_classRef, "getDouble", "(I)D");

  /// from: public double getDouble(int columnIndex)
  double getDouble(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getDouble,
      jni.JniType.doubleType,
      [columnIndex]).doubleFloat;

  static final _id_isNull1 =
      jniAccessors.getMethodIDOf(_classRef, "isNull", "(I)Z");

  /// from: public boolean isNull(int columnIndex)
  bool isNull1(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_isNull1, jni.JniType.booleanType, [columnIndex]).boolean;

  static final _id_isBlob =
      jniAccessors.getMethodIDOf(_classRef, "isBlob", "(I)Z");

  /// from: public boolean isBlob(int columnIndex)
  ///
  /// @deprecated Use \#getType
  bool isBlob(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_isBlob, jni.JniType.booleanType, [columnIndex]).boolean;

  static final _id_isString =
      jniAccessors.getMethodIDOf(_classRef, "isString", "(I)Z");

  /// from: public boolean isString(int columnIndex)
  ///
  /// @deprecated Use \#getType
  bool isString(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_isString, jni.JniType.booleanType, [columnIndex]).boolean;

  static final _id_isLong =
      jniAccessors.getMethodIDOf(_classRef, "isLong", "(I)Z");

  /// from: public boolean isLong(int columnIndex)
  ///
  /// @deprecated Use \#getType
  bool isLong(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_isLong, jni.JniType.booleanType, [columnIndex]).boolean;

  static final _id_isFloat =
      jniAccessors.getMethodIDOf(_classRef, "isFloat", "(I)Z");

  /// from: public boolean isFloat(int columnIndex)
  ///
  /// @deprecated Use \#getType
  bool isFloat(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_isFloat, jni.JniType.booleanType, [columnIndex]).boolean;

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "(I)I");

  /// from: public int getType(int columnIndex)
  int getType(int columnIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_getType, jni.JniType.intType, [columnIndex]).integer;

  static final _id_checkPosition =
      jniAccessors.getMethodIDOf(_classRef, "checkPosition", "()V");

  /// from: protected void checkPosition()
  void checkPosition() => jniAccessors.callMethodWithArgs(
      reference, _id_checkPosition, jni.JniType.voidType, []).check();

  static final _id_getWindow = jniAccessors.getMethodIDOf(
      _classRef, "getWindow", "()Landroid/database/CursorWindow;");

  /// from: public android.database.CursorWindow getWindow()
  /// The returned object must be deleted after use, by calling the `delete` method.
  cursorwindow_.CursorWindow getWindow() =>
      cursorwindow_.CursorWindow.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWindow, jni.JniType.objectType, []).object);

  static final _id_setWindow = jniAccessors.getMethodIDOf(
      _classRef, "setWindow", "(Landroid/database/CursorWindow;)V");

  /// from: public void setWindow(android.database.CursorWindow window)
  ///
  /// Sets a new cursor window for the cursor to use.
  ///
  /// The cursor takes ownership of the provided cursor window; the cursor window
  /// will be closed when the cursor is closed or when the cursor adopts a new
  /// cursor window.
  ///
  ///
  /// If the cursor previously had a cursor window, then it is closed when the
  /// new cursor window is assigned.
  ///
  ///
  ///@param window The new cursor window, typically a remote cursor window.
  void setWindow(cursorwindow_.CursorWindow window) =>
      jniAccessors.callMethodWithArgs(reference, _id_setWindow,
          jni.JniType.voidType, [window.reference]).check();

  static final _id_hasWindow =
      jniAccessors.getMethodIDOf(_classRef, "hasWindow", "()Z");

  /// from: public boolean hasWindow()
  ///
  /// Returns true if the cursor has an associated cursor window.
  ///@return True if the cursor has an associated cursor window.
  bool hasWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_hasWindow, jni.JniType.booleanType, []).boolean;
}
