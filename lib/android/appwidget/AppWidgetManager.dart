// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../widget/RemoteViews.dart" as remoteviews_;

import "../os/Bundle.dart" as bundle_;

import "../content/ComponentName.dart" as componentname_;

import "../os/UserHandle.dart" as userhandle_;

import "AppWidgetProviderInfo.dart" as appwidgetproviderinfo_;

import "../app/PendingIntent.dart" as pendingintent_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.appwidget.AppWidgetManager
///
/// Updates AppWidget state; gets information about installed AppWidget providers and other
/// AppWidget related state.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about creating app widgets, read the
/// <a href="{@docRoot}guide/topics/appwidgets/index.html">App Widgets</a> developer guide.
///
/// </div>
///
/// Requires the android.content.pm.PackageManager\#FEATURE_APP_WIDGETS PackageManager\#FEATURE_APP_WIDGETS feature which can be detected using android.content.pm.PackageManager\#hasSystemFeature(String) PackageManager.hasSystemFeature(String).
class AppWidgetManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/appwidget/AppWidgetManager");
  AppWidgetManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_APPWIDGET_BIND
  ///
  /// Activity action to launch from your AppWidgetHost activity when you want to bind
  /// an AppWidget to display and bindAppWidgetIdIfAllowed returns false.
  ///
  /// You must supply the following extras:
  /// <table>
  ///   <tr>
  ///     <td>\#EXTRA_APPWIDGET_ID</td>
  ///     <td>A newly allocated appWidgetId, which will be bound to the AppWidget provider
  ///         you provide.</td>
  ///  </tr>
  ///  <tr>
  ///     <td>\#EXTRA_APPWIDGET_PROVIDER</td>
  ///     <td>The BroadcastReceiver that will be the AppWidget provider for this AppWidget.
  ///     </td>
  ///  </tr>
  ///  <tr>
  ///     <td>\#EXTRA_APPWIDGET_PROVIDER_PROFILE</td>
  ///     <td>An optional handle to a user profile under which runs the provider
  ///     for this AppWidget.
  ///     </td>
  ///  </tr>
  /// </table>
  ///
  ///
  /// The system will respond with an onActivityResult call with the following extras in
  /// the intent:
  /// <table>
  ///   <tr>
  ///     <td>\#EXTRA_APPWIDGET_ID</td>
  ///     <td>The appWidgetId that you supplied in the original intent.</td>
  ///  </tr>
  /// </table>
  ///
  /// When you receive the result from the AppWidget bind activity, if the resultCode is
  /// android.app.Activity\#RESULT_OK, the AppWidget has been bound.  You should then
  /// check the AppWidgetProviderInfo for the returned AppWidget, and if it has one, launch its
  /// configuration activity.  If android.app.Activity\#RESULT_CANCELED is returned, you
  /// should delete the appWidgetId.
  ///@see \#ACTION_APPWIDGET_CONFIGURE
  static const ACTION_APPWIDGET_BIND =
      "android.appwidget.action.APPWIDGET_BIND";

  /// from: static public final java.lang.String ACTION_APPWIDGET_CONFIGURE
  ///
  /// Sent when it is time to configure your AppWidget while it is being added to a host.
  /// This action is not sent as a broadcast to the AppWidget provider, but as a startActivity
  /// to the activity specified in the AppWidgetProviderInfo AppWidgetProviderInfo
  /// meta-data.
  ///
  ///
  /// The intent will contain the following extras:
  /// <table>
  ///   <tr>
  ///     <td>\#EXTRA_APPWIDGET_ID</td>
  ///     <td>The appWidgetId to configure.</td>
  ///  </tr>
  /// </table>
  ///
  /// If you return android.app.Activity\#RESULT_OK using
  /// android.app.Activity\#setResult Activity.setResult(), the AppWidget will be added,
  /// and you will receive an \#ACTION_APPWIDGET_UPDATE broadcast for this AppWidget.
  /// If you return android.app.Activity\#RESULT_CANCELED, the host will cancel the add
  /// and not display this AppWidget, and you will receive a \#ACTION_APPWIDGET_DELETED
  /// broadcast.
  static const ACTION_APPWIDGET_CONFIGURE =
      "android.appwidget.action.APPWIDGET_CONFIGURE";

  /// from: static public final java.lang.String ACTION_APPWIDGET_DELETED
  ///
  /// Sent when an instance of an AppWidget is deleted from its host.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  ///@see AppWidgetProvider\#onDeleted AppWidgetProvider.onDeleted(Context context, int[] appWidgetIds)
  static const ACTION_APPWIDGET_DELETED =
      "android.appwidget.action.APPWIDGET_DELETED";

  /// from: static public final java.lang.String ACTION_APPWIDGET_DISABLED
  ///
  /// Sent when the last AppWidget of this provider is removed from the last host.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  ///@see AppWidgetProvider\#onEnabled AppWidgetProvider.onDisabled(Context context)
  static const ACTION_APPWIDGET_DISABLED =
      "android.appwidget.action.APPWIDGET_DISABLED";

  /// from: static public final java.lang.String ACTION_APPWIDGET_ENABLED
  ///
  /// Sent when an instance of an AppWidget is added to a host for the first time.
  /// This broadcast is sent at boot time if there is a AppWidgetHost installed with
  /// an instance for this provider.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  ///@see AppWidgetProvider\#onEnabled AppWidgetProvider.onEnabled(Context context)
  static const ACTION_APPWIDGET_ENABLED =
      "android.appwidget.action.APPWIDGET_ENABLED";

  /// from: static public final java.lang.String ACTION_APPWIDGET_HOST_RESTORED
  ///
  /// Sent to widget hosts after AppWidget state related to the host has been restored from
  /// backup. The intent contains information about how to translate AppWidget ids from the
  /// restored data to their new equivalents.  If an application maintains multiple separate
  /// widget host instances, it will receive this broadcast separately for each one.
  ///
  /// The intent will contain the following extras:
  ///
  /// <table>
  ///   <tr>
  ///     <td>\#EXTRA_APPWIDGET_OLD_IDS</td>
  ///     <td>The set of appWidgetIds represented in a restored backup that have been successfully
  ///     incorporated into the current environment.  This may be all of the AppWidgets known
  ///     to this application, or just a subset.  Each entry in this array of appWidgetIds has
  ///     a corresponding entry in the \#EXTRA_APPWIDGET_IDS extra.</td>
  ///  </tr>
  ///   <tr>
  ///     <td>\#EXTRA_APPWIDGET_IDS</td>
  ///     <td>The set of appWidgetIds now valid for this application.  The app should look at
  ///     its restored widget configuration and translate each appWidgetId in the
  ///     \#EXTRA_APPWIDGET_OLD_IDS array to its new value found at the corresponding
  ///     index within this array.</td>
  ///  </tr>
  ///  <tr>
  ///     <td>\#EXTRA_HOST_ID</td>
  ///     <td>The integer ID of the widget host instance whose state has just been restored.</td>
  ///  </tr>
  /// </table>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  ///@see \#ACTION_APPWIDGET_RESTORED
  static const ACTION_APPWIDGET_HOST_RESTORED =
      "android.appwidget.action.APPWIDGET_HOST_RESTORED";

  /// from: static public final java.lang.String ACTION_APPWIDGET_OPTIONS_CHANGED
  ///
  /// Sent when the custom extras for an AppWidget change.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  ///@see AppWidgetProvider\#onAppWidgetOptionsChanged AppWidgetProvider.onAppWidgetOptionsChanged(Context context,
  ///      AppWidgetManager appWidgetManager, int appWidgetId, Bundle newExtras)
  static const ACTION_APPWIDGET_OPTIONS_CHANGED =
      "android.appwidget.action.APPWIDGET_UPDATE_OPTIONS";

  /// from: static public final java.lang.String ACTION_APPWIDGET_PICK
  ///
  /// Activity action to launch from your AppWidgetHost activity when you want to
  /// pick an AppWidget to display.  The AppWidget picker activity will be launched.
  ///
  /// You must supply the following extras:
  /// <table>
  ///   <tr>
  ///     <td>\#EXTRA_APPWIDGET_ID</td>
  ///     <td>A newly allocated appWidgetId, which will be bound to the AppWidget provider
  ///         once the user has selected one.</td>
  ///  </tr>
  /// </table>
  ///
  ///
  /// The system will respond with an onActivityResult call with the following extras in
  /// the intent:
  /// <table>
  ///   <tr>
  ///     <td>\#EXTRA_APPWIDGET_ID</td>
  ///     <td>The appWidgetId that you supplied in the original intent.</td>
  ///  </tr>
  /// </table>
  ///
  /// When you receive the result from the AppWidget pick activity, if the resultCode is
  /// android.app.Activity\#RESULT_OK, an AppWidget has been selected.  You should then
  /// check the AppWidgetProviderInfo for the returned AppWidget, and if it has one, launch its
  /// configuration activity.  If android.app.Activity\#RESULT_CANCELED is returned, you
  /// should delete the appWidgetId.
  ///@see \#ACTION_APPWIDGET_CONFIGURE
  static const ACTION_APPWIDGET_PICK =
      "android.appwidget.action.APPWIDGET_PICK";

  /// from: static public final java.lang.String ACTION_APPWIDGET_RESTORED
  ///
  /// Sent to an AppWidgetProvider after AppWidget state related to that provider has
  /// been restored from backup. The intent contains information about how to translate AppWidget
  /// ids from the restored data to their new equivalents.
  ///
  /// The intent will contain the following extras:
  ///
  /// <table>
  ///   <tr>
  ///     <td>\#EXTRA_APPWIDGET_OLD_IDS</td>
  ///     <td>The set of appWidgetIds represented in a restored backup that have been successfully
  ///     incorporated into the current environment.  This may be all of the AppWidgets known
  ///     to this application, or just a subset.  Each entry in this array of appWidgetIds has
  ///     a corresponding entry in the \#EXTRA_APPWIDGET_IDS extra.</td>
  ///  </tr>
  ///   <tr>
  ///     <td>\#EXTRA_APPWIDGET_IDS</td>
  ///     <td>The set of appWidgetIds now valid for this application.  The app should look at
  ///     its restored widget configuration and translate each appWidgetId in the
  ///     \#EXTRA_APPWIDGET_OLD_IDS array to its new value found at the corresponding
  ///     index within this array.</td>
  ///  </tr>
  /// </table>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  ///@see \#ACTION_APPWIDGET_HOST_RESTORED
  static const ACTION_APPWIDGET_RESTORED =
      "android.appwidget.action.APPWIDGET_RESTORED";

  /// from: static public final java.lang.String ACTION_APPWIDGET_UPDATE
  ///
  /// Sent when it is time to update your AppWidget.
  ///
  /// This may be sent in response to a new instance for this AppWidget provider having
  /// been instantiated, the requested AppWidgetProviderInfo\#updatePeriodMillis update interval
  /// having lapsed, or the system booting.
  ///
  ///
  /// The intent will contain the following extras:
  /// <table>
  ///   <tr>
  ///     <td>\#EXTRA_APPWIDGET_IDS</td>
  ///     <td>The appWidgetIds to update.  This may be all of the AppWidgets created for this
  ///     provider, or just a subset.  The system tries to send updates for as few AppWidget
  ///     instances as possible.</td>
  ///  </tr>
  /// </table>
  ///@see AppWidgetProvider\#onUpdate AppWidgetProvider.onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds)
  static const ACTION_APPWIDGET_UPDATE =
      "android.appwidget.action.APPWIDGET_UPDATE";

  /// from: static public final java.lang.String EXTRA_APPWIDGET_ID
  ///
  /// An intent extra that contains one appWidgetId.
  ///
  /// The value will be an int that can be retrieved like this:
  /// {@sample frameworks/base/tests/appwidgets/AppWidgetHostTest/src/com/android/tests/appwidgethost/AppWidgetHostActivity.java getExtra_EXTRA_APPWIDGET_ID}
  static const EXTRA_APPWIDGET_ID = "appWidgetId";

  /// from: static public final java.lang.String EXTRA_APPWIDGET_IDS
  ///
  /// An intent extra that contains multiple appWidgetIds.
  ///
  /// The value will be an int array that can be retrieved like this:
  /// {@sample frameworks/base/tests/appwidgets/AppWidgetHostTest/src/com/android/tests/appwidgethost/TestAppWidgetProvider.java getExtra_EXTRA_APPWIDGET_IDS}
  static const EXTRA_APPWIDGET_IDS = "appWidgetIds";

  /// from: static public final java.lang.String EXTRA_APPWIDGET_OLD_IDS
  ///
  /// An intent extra that contains multiple appWidgetIds.  These are id values as
  /// they were provided to the application during a recent restore from backup.  It is
  /// attached to the \#ACTION_APPWIDGET_RESTORED broadcast intent.
  ///
  ///
  /// The value will be an int array that can be retrieved like this:
  /// {@sample frameworks/base/tests/appwidgets/AppWidgetHostTest/src/com/android/tests/appwidgethost/TestAppWidgetProvider.java getExtra_EXTRA_APPWIDGET_IDS}
  static const EXTRA_APPWIDGET_OLD_IDS = "appWidgetOldIds";

  /// from: static public final java.lang.String EXTRA_APPWIDGET_OPTIONS
  ///
  /// An intent extra which points to a bundle of extra information for a particular widget id.
  /// In particular this bundle can contain \#OPTION_APPWIDGET_MIN_WIDTH,
  /// \#OPTION_APPWIDGET_MIN_HEIGHT, \#OPTION_APPWIDGET_MAX_WIDTH,
  /// \#OPTION_APPWIDGET_MAX_HEIGHT.
  static const EXTRA_APPWIDGET_OPTIONS = "appWidgetOptions";

  /// from: static public final java.lang.String EXTRA_APPWIDGET_PREVIEW
  ///
  /// An extra that can be passed to
  /// \#requestPinAppWidget(ComponentName, Bundle, PendingIntent). This would allow the
  /// launcher app to present a custom preview to the user.
  ///
  ///
  /// The value should be a RemoteViews similar to what is used with
  /// \#updateAppWidget calls.
  static const EXTRA_APPWIDGET_PREVIEW = "appWidgetPreview";

  /// from: static public final java.lang.String EXTRA_APPWIDGET_PROVIDER
  ///
  /// An intent extra that contains the component name of a AppWidget provider.
  ///
  /// The value will be an android.content.ComponentName.
  static const EXTRA_APPWIDGET_PROVIDER = "appWidgetProvider";

  /// from: static public final java.lang.String EXTRA_APPWIDGET_PROVIDER_PROFILE
  ///
  /// An intent extra that contains the user handle of the profile under
  /// which an AppWidget provider is registered.
  ///
  /// The value will be a android.os.UserHandle.
  static const EXTRA_APPWIDGET_PROVIDER_PROFILE = "appWidgetProviderProfile";

  /// from: static public final java.lang.String EXTRA_CUSTOM_EXTRAS
  ///
  /// An intent extra to pass to the AppWidget picker containing a java.util.List of
  /// android.os.Bundle objects to mix in to the list of AppWidgets that are
  /// installed.  It will be added to the extras object on the android.content.Intent
  /// that is returned from the picker activity.
  ///
  /// {@more }
  static const EXTRA_CUSTOM_EXTRAS = "customExtras";

  /// from: static public final java.lang.String EXTRA_CUSTOM_INFO
  ///
  /// An intent extra to pass to the AppWidget picker containing a java.util.List of
  /// AppWidgetProviderInfo objects to mix in to the list of AppWidgets that are
  /// installed.  (This is how the launcher shows the search widget).
  static const EXTRA_CUSTOM_INFO = "customInfo";

  /// from: static public final java.lang.String EXTRA_HOST_ID
  ///
  /// An intent extra attached to the \#ACTION_APPWIDGET_HOST_RESTORED broadcast,
  /// indicating the integer ID of the host whose widgets have just been restored.
  static const EXTRA_HOST_ID = "hostId";

  /// from: static public final int INVALID_APPWIDGET_ID
  ///
  /// A sentinel value that the AppWidget manager will never return as a appWidgetId.
  static const INVALID_APPWIDGET_ID = 0;

  /// from: static public final java.lang.String META_DATA_APPWIDGET_PROVIDER
  ///
  /// Field for the manifest meta-data tag.
  ///@see AppWidgetProviderInfo
  static const META_DATA_APPWIDGET_PROVIDER = "android.appwidget.provider";

  /// from: static public final java.lang.String OPTION_APPWIDGET_HOST_CATEGORY
  ///
  /// A bundle extra that hints to the AppWidgetProvider the category of host that owns this
  /// this widget. Can have the value AppWidgetProviderInfo\#WIDGET_CATEGORY_HOME_SCREEN or AppWidgetProviderInfo\#WIDGET_CATEGORY_KEYGUARD or AppWidgetProviderInfo\#WIDGET_CATEGORY_SEARCHBOX.
  static const OPTION_APPWIDGET_HOST_CATEGORY = "appWidgetCategory";

  /// from: static public final java.lang.String OPTION_APPWIDGET_MAX_HEIGHT
  ///
  /// A bundle extra that contains the upper bound on the current width, in dips, of a widget instance.
  static const OPTION_APPWIDGET_MAX_HEIGHT = "appWidgetMaxHeight";

  /// from: static public final java.lang.String OPTION_APPWIDGET_MAX_WIDTH
  ///
  /// A bundle extra that contains the upper bound on the current width, in dips, of a widget instance.
  static const OPTION_APPWIDGET_MAX_WIDTH = "appWidgetMaxWidth";

  /// from: static public final java.lang.String OPTION_APPWIDGET_MIN_HEIGHT
  ///
  /// A bundle extra that contains the lower bound on the current height, in dips, of a widget instance.
  static const OPTION_APPWIDGET_MIN_HEIGHT = "appWidgetMinHeight";

  /// from: static public final java.lang.String OPTION_APPWIDGET_MIN_WIDTH
  ///
  /// A bundle extra that contains the lower bound on the current width, in dips, of a widget instance.
  static const OPTION_APPWIDGET_MIN_WIDTH = "appWidgetMinWidth";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AppWidgetManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getInstance = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getInstance",
      "(Landroid/content/Context;)Landroid/appwidget/AppWidgetManager;");

  /// from: static public android.appwidget.AppWidgetManager getInstance(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the AppWidgetManager instance to use for the supplied android.content.Context Context object.
  static AppWidgetManager getInstance(context_.Context context) =>
      AppWidgetManager.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getInstance, jni.JniType.objectType, [context.reference]).object);

  static final _id_updateAppWidget = jniAccessors.getMethodIDOf(
      _classRef, "updateAppWidget", "([ILandroid/widget/RemoteViews;)V");

  /// from: public void updateAppWidget(int[] appWidgetIds, android.widget.RemoteViews views)
  ///
  /// Set the RemoteViews to use for the specified appWidgetIds.
  ///
  /// Note that the RemoteViews parameter will be cached by the AppWidgetService, and hence should
  /// contain a complete representation of the widget. For performing partial widget updates, see
  /// \#partiallyUpdateAppWidget(int[], RemoteViews).
  ///
  ///
  /// It is okay to call this method both inside an \#ACTION_APPWIDGET_UPDATE broadcast,
  /// and outside of the handler.
  /// This method will only work when called from the uid that owns the AppWidget provider.
  ///
  ///
  /// The total Bitmap memory used by the RemoteViews object cannot exceed that required to
  /// fill the screen 1.5 times, ie. (screen width x screen height x 4 x 1.5) bytes.
  ///@param appWidgetIds The AppWidget instances for which to set the RemoteViews.
  ///@param views The RemoteViews object to show.
  void updateAppWidget(
          jni.JniObject appWidgetIds, remoteviews_.RemoteViews views) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_updateAppWidget,
          jni.JniType.voidType,
          [appWidgetIds.reference, views.reference]).check();

  static final _id_updateAppWidgetOptions = jniAccessors.getMethodIDOf(
      _classRef, "updateAppWidgetOptions", "(ILandroid/os/Bundle;)V");

  /// from: public void updateAppWidgetOptions(int appWidgetId, android.os.Bundle options)
  ///
  /// Update the extras for a given widget instance.
  ///
  /// The extras can be used to embed additional information about this widget to be accessed
  /// by the associated widget's AppWidgetProvider.
  ///@see \#getAppWidgetOptions(int)
  ///@param appWidgetId The AppWidget instances for which to set the RemoteViews.
  ///@param options The options to associate with this widget
  void updateAppWidgetOptions(int appWidgetId, bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(reference, _id_updateAppWidgetOptions,
          jni.JniType.voidType, [appWidgetId, options.reference]).check();

  static final _id_getAppWidgetOptions = jniAccessors.getMethodIDOf(
      _classRef, "getAppWidgetOptions", "(I)Landroid/os/Bundle;");

  /// from: public android.os.Bundle getAppWidgetOptions(int appWidgetId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the extras associated with a given widget instance.
  ///
  /// The extras can be used to embed additional information about this widget to be accessed
  /// by the associated widget's AppWidgetProvider.
  ///@see \#updateAppWidgetOptions(int, Bundle)
  ///@param appWidgetId The AppWidget instances for which to set the RemoteViews.
  ///@return The options associated with the given widget instance.
  bundle_.Bundle getAppWidgetOptions(int appWidgetId) =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAppWidgetOptions,
          jni.JniType.objectType,
          [appWidgetId]).object);

  static final _id_updateAppWidget1 = jniAccessors.getMethodIDOf(
      _classRef, "updateAppWidget", "(ILandroid/widget/RemoteViews;)V");

  /// from: public void updateAppWidget(int appWidgetId, android.widget.RemoteViews views)
  ///
  /// Set the RemoteViews to use for the specified appWidgetId.
  ///
  /// Note that the RemoteViews parameter will be cached by the AppWidgetService, and hence should
  /// contain a complete representation of the widget. For performing partial widget updates, see
  /// \#partiallyUpdateAppWidget(int, RemoteViews).
  ///
  ///
  /// It is okay to call this method both inside an \#ACTION_APPWIDGET_UPDATE broadcast,
  /// and outside of the handler.
  /// This method will only work when called from the uid that owns the AppWidget provider.
  ///
  ///
  /// The total Bitmap memory used by the RemoteViews object cannot exceed that required to
  /// fill the screen 1.5 times, ie. (screen width x screen height x 4 x 1.5) bytes.
  ///@param appWidgetId The AppWidget instance for which to set the RemoteViews.
  ///@param views The RemoteViews object to show.
  void updateAppWidget1(int appWidgetId, remoteviews_.RemoteViews views) =>
      jniAccessors.callMethodWithArgs(reference, _id_updateAppWidget1,
          jni.JniType.voidType, [appWidgetId, views.reference]).check();

  static final _id_partiallyUpdateAppWidget = jniAccessors.getMethodIDOf(
      _classRef,
      "partiallyUpdateAppWidget",
      "([ILandroid/widget/RemoteViews;)V");

  /// from: public void partiallyUpdateAppWidget(int[] appWidgetIds, android.widget.RemoteViews views)
  ///
  /// Perform an incremental update or command on the widget(s) specified by appWidgetIds.
  ///
  /// This update  differs from \#updateAppWidget(int[], RemoteViews) in that the
  /// RemoteViews object which is passed is understood to be an incomplete representation of the
  /// widget, and hence does not replace the cached representation of the widget. As of API
  /// level 17, the new properties set within the views objects will be appended to the cached
  /// representation of the widget, and hence will persist.
  ///
  /// Use with RemoteViews\#showNext(int), RemoteViews\#showPrevious(int),
  /// RemoteViews\#setScrollPosition(int, int) and similar commands.
  ///
  ///
  /// It is okay to call this method both inside an \#ACTION_APPWIDGET_UPDATE broadcast,
  /// and outside of the handler.
  /// This method will only work when called from the uid that owns the AppWidget provider.
  ///
  ///
  /// This method will be ignored if a widget has not received a full update via
  /// \#updateAppWidget(int[], RemoteViews).
  ///@param appWidgetIds The AppWidget instances for which to set the RemoteViews.
  ///@param views The RemoteViews object containing the incremental update / command.
  void partiallyUpdateAppWidget(
          jni.JniObject appWidgetIds, remoteviews_.RemoteViews views) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_partiallyUpdateAppWidget,
          jni.JniType.voidType,
          [appWidgetIds.reference, views.reference]).check();

  static final _id_partiallyUpdateAppWidget1 = jniAccessors.getMethodIDOf(
      _classRef,
      "partiallyUpdateAppWidget",
      "(ILandroid/widget/RemoteViews;)V");

  /// from: public void partiallyUpdateAppWidget(int appWidgetId, android.widget.RemoteViews views)
  ///
  /// Perform an incremental update or command on the widget specified by appWidgetId.
  ///
  /// This update  differs from \#updateAppWidget(int, RemoteViews) in that the RemoteViews
  /// object which is passed is understood to be an incomplete representation of the widget, and
  /// hence is not cached by the AppWidgetService. Note that because these updates are not cached,
  /// any state that they modify that is not restored by restoreInstanceState will not persist in
  /// the case that the widgets are restored using the cached version in AppWidgetService.
  ///
  /// Use with RemoteViews\#showNext(int), RemoteViews\#showPrevious(int),
  /// RemoteViews\#setScrollPosition(int, int) and similar commands.
  ///
  ///
  /// It is okay to call this method both inside an \#ACTION_APPWIDGET_UPDATE broadcast,
  /// and outside of the handler.
  /// This method will only work when called from the uid that owns the AppWidget provider.
  ///
  ///
  /// This method will be ignored if a widget has not received a full update via
  /// \#updateAppWidget(int[], RemoteViews).
  ///@param appWidgetId The AppWidget instance for which to set the RemoteViews.
  ///@param views The RemoteViews object containing the incremental update / command.
  void partiallyUpdateAppWidget1(
          int appWidgetId, remoteviews_.RemoteViews views) =>
      jniAccessors.callMethodWithArgs(reference, _id_partiallyUpdateAppWidget1,
          jni.JniType.voidType, [appWidgetId, views.reference]).check();

  static final _id_updateAppWidget2 = jniAccessors.getMethodIDOf(
      _classRef,
      "updateAppWidget",
      "(Landroid/content/ComponentName;Landroid/widget/RemoteViews;)V");

  /// from: public void updateAppWidget(android.content.ComponentName provider, android.widget.RemoteViews views)
  ///
  /// Set the RemoteViews to use for all AppWidget instances for the supplied AppWidget provider.
  ///
  ///
  /// It is okay to call this method both inside an \#ACTION_APPWIDGET_UPDATE broadcast,
  /// and outside of the handler.
  /// This method will only work when called from the uid that owns the AppWidget provider.
  ///@param provider The ComponentName for the android.content.BroadcastReceiver BroadcastReceiver provider
  ///                      for your AppWidget.
  ///@param views The RemoteViews object to show.
  void updateAppWidget2(componentname_.ComponentName provider,
          remoteviews_.RemoteViews views) =>
      jniAccessors.callMethodWithArgs(reference, _id_updateAppWidget2,
          jni.JniType.voidType, [provider.reference, views.reference]).check();

  static final _id_updateAppWidgetProviderInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "updateAppWidgetProviderInfo",
      "(Landroid/content/ComponentName;Ljava/lang/String;)V");

  /// from: public void updateAppWidgetProviderInfo(android.content.ComponentName provider, java.lang.String metaDataKey)
  ///
  /// Updates the info for the supplied AppWidget provider. Apps can use this to change the default
  /// behavior of the widget based on the state of the app (for e.g., if the user is logged in
  /// or not). Calling this API completely replaces the previous definition.
  ///
  ///
  /// The manifest entry of the provider should contain an additional meta-data tag similar to
  /// \#META_DATA_APPWIDGET_PROVIDER which should point to any alternative definitions for
  /// the provider.
  ///
  ///
  /// This is persisted across device reboots and app updates. If this meta-data key is not
  /// present in the manifest entry, the info reverts to default.
  ///@param provider ComponentName for the android.content.BroadcastReceiver BroadcastReceiver provider for your AppWidget.
  ///@param metaDataKey key for the meta-data tag pointing to the new provider info. Use null
  ///    to reset any previously set info.
  ///
  /// This value may be {@code null}.
  void updateAppWidgetProviderInfo(
          componentname_.ComponentName provider, jni.JniString metaDataKey) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_updateAppWidgetProviderInfo,
          jni.JniType.voidType,
          [provider.reference, metaDataKey.reference]).check();

  static final _id_notifyAppWidgetViewDataChanged = jniAccessors.getMethodIDOf(
      _classRef, "notifyAppWidgetViewDataChanged", "([II)V");

  /// from: public void notifyAppWidgetViewDataChanged(int[] appWidgetIds, int viewId)
  ///
  /// Notifies the specified collection view in all the specified AppWidget instances
  /// to invalidate their data.
  ///@param appWidgetIds The AppWidget instances to notify of view data changes.
  ///@param viewId The collection view id.
  void notifyAppWidgetViewDataChanged(jni.JniObject appWidgetIds, int viewId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_notifyAppWidgetViewDataChanged,
          jni.JniType.voidType,
          [appWidgetIds.reference, viewId]).check();

  static final _id_notifyAppWidgetViewDataChanged1 = jniAccessors.getMethodIDOf(
      _classRef, "notifyAppWidgetViewDataChanged", "(II)V");

  /// from: public void notifyAppWidgetViewDataChanged(int appWidgetId, int viewId)
  ///
  /// Notifies the specified collection view in the specified AppWidget instance
  /// to invalidate its data.
  ///@param appWidgetId The AppWidget instance to notify of view data changes.
  ///@param viewId The collection view id.
  void notifyAppWidgetViewDataChanged1(int appWidgetId, int viewId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_notifyAppWidgetViewDataChanged1,
          jni.JniType.voidType,
          [appWidgetId, viewId]).check();

  static final _id_getInstalledProvidersForProfile = jniAccessors.getMethodIDOf(
      _classRef,
      "getInstalledProvidersForProfile",
      "(Landroid/os/UserHandle;)Ljava/util/List;");

  /// from: public java.util.List<android.appwidget.AppWidgetProviderInfo> getInstalledProvidersForProfile(android.os.UserHandle profile)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the AppWidget providers for the given user profile. User profile can only
  /// be the current user or a profile of the current user. For example, the current
  /// user may have a corporate profile. In this case the parent user profile has a
  /// child profile, the corporate one.
  ///@param profile The profile for which to get providers. Passing null is equivalent
  ///        to querying for only the calling user.
  /// This value may be {@code null}.
  ///@return The installed providers, or an empty list if none are found for the given user.
  ///@see android.os.Process\#myUserHandle()
  ///@see android.os.UserManager\#getUserProfiles()
  jni.JniObject getInstalledProvidersForProfile(
          userhandle_.UserHandle profile) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getInstalledProvidersForProfile,
          jni.JniType.objectType,
          [profile.reference]).object);

  static final _id_getInstalledProvidersForPackage = jniAccessors.getMethodIDOf(
      _classRef,
      "getInstalledProvidersForPackage",
      "(Ljava/lang/String;Landroid/os/UserHandle;)Ljava/util/List;");

  /// from: public java.util.List<android.appwidget.AppWidgetProviderInfo> getInstalledProvidersForPackage(java.lang.String packageName, android.os.UserHandle profile)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the AppWidget providers for the given package and user profile. User
  /// profile can only be the current user or a profile of the current user. For
  /// example, the current user may have a corporate profile. In this case the
  /// parent user profile has a child profile, the corporate one.
  ///@param packageName The package for which to get providers. If null, this method is
  ///        equivalent to \#getInstalledProvidersForProfile(UserHandle).
  /// This value must never be {@code null}.
  ///@param profile The profile for which to get providers. Passing null is equivalent
  ///        to querying for only the calling user.
  /// This value may be {@code null}.
  ///@return The installed providers, or an empty list if none are found for the given
  ///         package and user.
  ///@throws NullPointerException if the provided package name is null
  ///@see android.os.Process\#myUserHandle()
  ///@see android.os.UserManager\#getUserProfiles()
  jni.JniObject getInstalledProvidersForPackage(
          jni.JniString packageName, userhandle_.UserHandle profile) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getInstalledProvidersForPackage,
          jni.JniType.objectType,
          [packageName.reference, profile.reference]).object);

  static final _id_getInstalledProviders = jniAccessors.getMethodIDOf(
      _classRef, "getInstalledProviders", "()Ljava/util/List;");

  /// from: public java.util.List<android.appwidget.AppWidgetProviderInfo> getInstalledProviders()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a list of the AppWidget providers that are currently installed.
  jni.JniObject getInstalledProviders() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getInstalledProviders, jni.JniType.objectType, []).object);

  static final _id_getAppWidgetInfo = jniAccessors.getMethodIDOf(_classRef,
      "getAppWidgetInfo", "(I)Landroid/appwidget/AppWidgetProviderInfo;");

  /// from: public android.appwidget.AppWidgetProviderInfo getAppWidgetInfo(int appWidgetId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the available info about the AppWidget.
  ///@return A appWidgetId.  If the appWidgetId has not been bound to a provider yet, or
  /// you don't have access to that appWidgetId, null is returned.
  appwidgetproviderinfo_.AppWidgetProviderInfo getAppWidgetInfo(
          int appWidgetId) =>
      appwidgetproviderinfo_.AppWidgetProviderInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getAppWidgetInfo,
              jni.JniType.objectType, [appWidgetId]).object);

  static final _id_bindAppWidgetIdIfAllowed = jniAccessors.getMethodIDOf(
      _classRef,
      "bindAppWidgetIdIfAllowed",
      "(ILandroid/content/ComponentName;)Z");

  /// from: public boolean bindAppWidgetIdIfAllowed(int appWidgetId, android.content.ComponentName provider)
  ///
  /// Set the component for a given appWidgetId.
  ///
  /// <p class="note">You need the BIND_APPWIDGET permission or the user must have enabled binding
  ///         widgets always for your component. Should be used by apps that host widgets; if this
  ///         method returns false, call \#ACTION_APPWIDGET_BIND to request permission to
  ///         bind
  ///@param appWidgetId The AppWidget id under which to bind the provider.
  ///@param provider The android.content.BroadcastReceiver that will be the AppWidget
  ///                      provider for this AppWidget.
  ///@return true if this component has permission to bind the AppWidget
  bool bindAppWidgetIdIfAllowed(
          int appWidgetId, componentname_.ComponentName provider) =>
      jniAccessors.callMethodWithArgs(reference, _id_bindAppWidgetIdIfAllowed,
          jni.JniType.booleanType, [appWidgetId, provider.reference]).boolean;

  static final _id_bindAppWidgetIdIfAllowed1 = jniAccessors.getMethodIDOf(
      _classRef,
      "bindAppWidgetIdIfAllowed",
      "(ILandroid/content/ComponentName;Landroid/os/Bundle;)Z");

  /// from: public boolean bindAppWidgetIdIfAllowed(int appWidgetId, android.content.ComponentName provider, android.os.Bundle options)
  ///
  /// Set the component for a given appWidgetId.
  ///
  /// <p class="note">You need the BIND_APPWIDGET permission or the user must have enabled binding
  ///         widgets always for your component. Should be used by apps that host widgets; if this
  ///         method returns false, call \#ACTION_APPWIDGET_BIND to request permission to
  ///         bind
  ///@param appWidgetId The AppWidget id under which to bind the provider.
  ///@param provider The android.content.BroadcastReceiver that will be the AppWidget
  ///                      provider for this AppWidget.
  ///@param options Bundle containing options for the AppWidget. See also
  ///                      \#updateAppWidgetOptions(int, Bundle)
  ///@return true if this component has permission to bind the AppWidget
  bool bindAppWidgetIdIfAllowed1(int appWidgetId,
          componentname_.ComponentName provider, bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_bindAppWidgetIdIfAllowed1,
          jni.JniType.booleanType,
          [appWidgetId, provider.reference, options.reference]).boolean;

  static final _id_bindAppWidgetIdIfAllowed2 = jniAccessors.getMethodIDOf(
      _classRef,
      "bindAppWidgetIdIfAllowed",
      "(ILandroid/os/UserHandle;Landroid/content/ComponentName;Landroid/os/Bundle;)Z");

  /// from: public boolean bindAppWidgetIdIfAllowed(int appWidgetId, android.os.UserHandle user, android.content.ComponentName provider, android.os.Bundle options)
  ///
  /// Set the provider for a given appWidgetId if the caller has a permission.
  ///
  /// <strong>Note:</strong> You need the android.Manifest.permission\#BIND_APPWIDGET
  /// permission or the user must have enabled binding widgets always for your component.
  /// Should be used by apps that host widgets. If this method returns false, call \#ACTION_APPWIDGET_BIND to request permission to bind.
  ///
  ///
  ///@param appWidgetId The AppWidget id under which to bind the provider.
  ///@param user The user id in which the provider resides.
  ///@param provider The component name of the provider.
  ///@param options An optional Bundle containing options for the AppWidget.
  ///@return true if this component has permission to bind the AppWidget
  bool bindAppWidgetIdIfAllowed2(int appWidgetId, userhandle_.UserHandle user,
          componentname_.ComponentName provider, bundle_.Bundle options) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_bindAppWidgetIdIfAllowed2, jni.JniType.booleanType, [
        appWidgetId,
        user.reference,
        provider.reference,
        options.reference
      ]).boolean;

  static final _id_getAppWidgetIds = jniAccessors.getMethodIDOf(
      _classRef, "getAppWidgetIds", "(Landroid/content/ComponentName;)[I");

  /// from: public int[] getAppWidgetIds(android.content.ComponentName provider)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the list of appWidgetIds that have been bound to the given AppWidget
  /// provider.
  ///@param provider The android.content.BroadcastReceiver that is the
  ///            AppWidget provider to find appWidgetIds for.
  jni.JniObject getAppWidgetIds(componentname_.ComponentName provider) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAppWidgetIds,
          jni.JniType.objectType,
          [provider.reference]).object);

  static final _id_isRequestPinAppWidgetSupported = jniAccessors.getMethodIDOf(
      _classRef, "isRequestPinAppWidgetSupported", "()Z");

  /// from: public boolean isRequestPinAppWidgetSupported()
  ///
  /// Return {@code TRUE} if the default launcher supports
  /// \#requestPinAppWidget(ComponentName, Bundle, PendingIntent)
  bool isRequestPinAppWidgetSupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isRequestPinAppWidgetSupported,
      jni.JniType.booleanType, []).boolean;

  static final _id_requestPinAppWidget = jniAccessors.getMethodIDOf(
      _classRef,
      "requestPinAppWidget",
      "(Landroid/content/ComponentName;Landroid/os/Bundle;Landroid/app/PendingIntent;)Z");

  /// from: public boolean requestPinAppWidget(android.content.ComponentName provider, android.os.Bundle extras, android.app.PendingIntent successCallback)
  ///
  /// Request to pin an app widget on the current launcher. It's up to the launcher to accept this
  /// request (optionally showing a user confirmation). If the request is accepted, the caller will
  /// get a confirmation with extra \#EXTRA_APPWIDGET_ID.
  ///
  /// When a request is denied by the user, the caller app will not get any response.
  ///
  /// Only apps with a foreground activity or a foreground service can call it.  Otherwise
  /// it'll throw IllegalStateException.
  ///
  /// It's up to the launcher how to handle previous pending requests when the same package
  /// calls this API multiple times in a row.  It may ignore the previous requests,
  /// for example.
  ///
  /// Launcher will not show the configuration activity associated with the provider in this
  /// case. The app could either show the configuration activity as a response to the callback,
  /// or show if before calling the API (various configurations can be encapsulated in
  /// {@code successCallback} to avoid persisting them before the widgetId is known).
  ///@param provider The ComponentName for the android.content.BroadcastReceiver BroadcastReceiver provider for your AppWidget.
  /// This value must never be {@code null}.
  ///@param extras In not null, this is passed to the launcher app. For eg \#EXTRA_APPWIDGET_PREVIEW can be used for a custom preview.
  /// This value may be {@code null}.
  ///@param successCallback If not null, this intent will be sent when the widget is created.
  ///
  /// This value may be {@code null}.
  ///@return {@code TRUE} if the launcher supports this feature. Note the API will return without
  ///    waiting for the user to respond, so getting {@code TRUE} from this API does *not* mean
  ///    the shortcut is pinned. {@code FALSE} if the launcher doesn't support this feature.
  ///@see android.content.pm.ShortcutManager\#isRequestPinShortcutSupported()
  ///@see android.content.pm.ShortcutManager\#requestPinShortcut(ShortcutInfo, IntentSender)
  ///@see \#isRequestPinAppWidgetSupported()
  ///@throws IllegalStateException The caller doesn't have a foreground activity or a foreground
  /// service or when the user is locked.
  bool requestPinAppWidget(
          componentname_.ComponentName provider,
          bundle_.Bundle extras,
          pendingintent_.PendingIntent successCallback) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_requestPinAppWidget, jni.JniType.booleanType, [
        provider.reference,
        extras.reference,
        successCallback.reference
      ]).boolean;
}
