// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "UFormat.dart" as uformat_;

import "../util/ULocale.dart" as ulocale_;

import "MessagePattern.dart" as messagepattern_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.text.MessageFormat
///
/// <strong>[icu enhancement]</strong> ICU's replacement for java.text.MessageFormat.&nbsp;Methods, fields, and other functionality specific to ICU are labeled '<strong>[icu]</strong>'.
///
/// MessageFormat prepares strings for display to users,
/// with optional arguments (variables/placeholders).
/// The arguments can occur in any order, which is necessary for translation
/// into languages with different grammars.
///
/// A MessageFormat is constructed from a _pattern_ string
/// with arguments in {curly braces} which will be replaced by formatted values.
///
/// <code>MessageFormat</code> differs from the other <code>Format</code>
/// classes in that you create a <code>MessageFormat</code> object with one
/// of its constructors (not with a <code>getInstance</code> style factory
/// method). Factory methods aren't necessary because <code>MessageFormat</code>
/// itself doesn't implement locale-specific behavior. Any locale-specific
/// behavior is defined by the pattern that you provide and the
/// subformats used for inserted arguments.
///
/// Arguments can be named (using identifiers) or numbered (using small ASCII-digit integers).
/// Some of the API methods work only with argument numbers and throw an exception
/// if the pattern has named arguments (see \#usesNamedArguments()).
///
/// An argument might not specify any format type. In this case,
/// a Number value is formatted with a default (for the locale) NumberFormat,
/// a Date value is formatted with a default (for the locale) DateFormat,
/// and for any other value its toString() value is used.
///
/// An argument might specify a "simple" type for which the specified
/// Format object is created, cached and used.
///
/// An argument might have a "complex" type with nested MessageFormat sub-patterns.
/// During formatting, one of these sub-messages is selected according to the argument value
/// and recursively formatted.
///
/// After construction, a custom Format object can be set for
/// a top-level argument, overriding the default formatting and parsing behavior
/// for that argument.
/// However, custom formatting can be achieved more simply by writing
/// a typeless argument in the pattern string
/// and supplying it with a preformatted string value.
///
/// When formatting, MessageFormat takes a collection of argument values
/// and writes an output string.
/// The argument values may be passed as an array
/// (when the pattern contains only numbered arguments)
/// or as a Map (which works for both named and numbered arguments).
///
/// Each argument is matched with one of the input values by array index or map key
/// and formatted according to its pattern specification
/// (or using a custom Format object if one was set).
/// A numbered pattern argument is matched with a map key that contains that number
/// as an ASCII-decimal-digit string (without leading zero).
///
/// <h3><a name="patterns">Patterns and Their Interpretation</a></h3>
///
/// <code>MessageFormat</code> uses patterns of the following form:
/// <blockquote><pre>
/// message = messageText (argument messageText)*
/// argument = noneArg | simpleArg | complexArg
/// complexArg = choiceArg | pluralArg | selectArg | selectordinalArg
///
/// noneArg = '{' argNameOrNumber '}'
/// simpleArg = '{' argNameOrNumber ',' argType [',' argStyle] '}'
/// choiceArg = '{' argNameOrNumber ',' "choice" ',' choiceStyle '}'
/// pluralArg = '{' argNameOrNumber ',' "plural" ',' pluralStyle '}'
/// selectArg = '{' argNameOrNumber ',' "select" ',' selectStyle '}'
/// selectordinalArg = '{' argNameOrNumber ',' "selectordinal" ',' pluralStyle '}'
///
/// choiceStyle: see ChoiceFormat
/// pluralStyle: see PluralFormat
/// selectStyle: see SelectFormat
///
/// argNameOrNumber = argName | argNumber
/// argName = [^[[:Pattern_Syntax:][:Pattern_White_Space:]]]+
/// argNumber = '0' | ('1'..'9' ('0'..'9')*)
///
/// argType = "number" | "date" | "time" | "spellout" | "ordinal" | "duration"
/// argStyle = "short" | "medium" | "long" | "full" | "integer" | "currency" | "percent" | argStyleText
/// </pre></blockquote>
///
/// <ul>
///   <li>messageText can contain quoted literal strings including syntax characters.
///       A quoted literal string begins with an ASCII apostrophe and a syntax character
///       (usually a {curly brace}) and continues until the next single apostrophe.
///       A double ASCII apostrohpe inside or outside of a quoted string represents
///       one literal apostrophe.
///   <li>Quotable syntax characters are the {curly braces} in all messageText parts,
///       plus the '\#' sign in a messageText immediately inside a pluralStyle,
///       and the '|' symbol in a messageText immediately inside a choiceStyle.
///   <li>See also MessagePattern.ApostropheMode
///   <li>In argStyleText, every single ASCII apostrophe begins and ends quoted literal text,
///       and unquoted {curly braces} must occur in matched pairs.
/// </ul>
///
/// Recommendation: Use the real apostrophe (single quote) character \\u2019 for
/// human-readable text, and use the ASCII apostrophe (\\u0027 ' )
/// only in program syntax, like quoting in MessageFormat.
/// See the annotations for U+0027 Apostrophe in The Unicode Standard.
///
/// The <code>choice</code> argument type is deprecated.
/// Use <code>plural</code> arguments for proper plural selection,
/// and <code>select</code> arguments for simple selection among a fixed set of choices.
///
/// The <code>argType</code> and <code>argStyle</code> values are used to create
/// a <code>Format</code> instance for the format element. The following
/// table shows how the values map to Format instances. Combinations not
/// shown in the table are illegal. Any <code>argStyleText</code> must
/// be a valid pattern string for the Format subclass used.
///
/// <table border=1>
///    <tr>
///       <th>argType
///       <th>argStyle
///       <th>resulting Format object
///    <tr>
///       <td colspan=2><i>(none)</i>
///       <td><code>null</code>
///    <tr>
///       <td rowspan=5><code>number</code>
///       <td><i>(none)</i>
///       <td><code>NumberFormat.getInstance(getLocale())</code>
///    <tr>
///       <td><code>integer</code>
///       <td><code>NumberFormat.getIntegerInstance(getLocale())</code>
///    <tr>
///       <td><code>currency</code>
///       <td><code>NumberFormat.getCurrencyInstance(getLocale())</code>
///    <tr>
///       <td><code>percent</code>
///       <td><code>NumberFormat.getPercentInstance(getLocale())</code>
///    <tr>
///       <td><i>argStyleText</i>
///       <td><code>new DecimalFormat(argStyleText, new DecimalFormatSymbols(getLocale()))</code>
///    <tr>
///       <td rowspan=6><code>date</code>
///       <td><i>(none)</i>
///       <td><code>DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())</code>
///    <tr>
///       <td><code>short</code>
///       <td><code>DateFormat.getDateInstance(DateFormat.SHORT, getLocale())</code>
///    <tr>
///       <td><code>medium</code>
///       <td><code>DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())</code>
///    <tr>
///       <td><code>long</code>
///       <td><code>DateFormat.getDateInstance(DateFormat.LONG, getLocale())</code>
///    <tr>
///       <td><code>full</code>
///       <td><code>DateFormat.getDateInstance(DateFormat.FULL, getLocale())</code>
///    <tr>
///       <td><i>argStyleText</i>
///       <td><code>new SimpleDateFormat(argStyleText, getLocale())</code>
///    <tr>
///       <td rowspan=6><code>time</code>
///       <td><i>(none)</i>
///       <td><code>DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())</code>
///    <tr>
///       <td><code>short</code>
///       <td><code>DateFormat.getTimeInstance(DateFormat.SHORT, getLocale())</code>
///    <tr>
///       <td><code>medium</code>
///       <td><code>DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())</code>
///    <tr>
///       <td><code>long</code>
///       <td><code>DateFormat.getTimeInstance(DateFormat.LONG, getLocale())</code>
///    <tr>
///       <td><code>full</code>
///       <td><code>DateFormat.getTimeInstance(DateFormat.FULL, getLocale())</code>
///    <tr>
///       <td><i>argStyleText</i>
///       <td><code>new SimpleDateFormat(argStyleText, getLocale())</code>
///    <tr>
///       <td><code>spellout</code>
///       <td><i>argStyleText (optional)</i>
///       <td><code>new RuleBasedNumberFormat(getLocale(), RuleBasedNumberFormat.SPELLOUT)
///           <br>&nbsp;&nbsp;&nbsp;&nbsp;.setDefaultRuleset(argStyleText);</code>
///    <tr>
///       <td><code>ordinal</code>
///       <td><i>argStyleText (optional)</i>
///       <td><code>new RuleBasedNumberFormat(getLocale(), RuleBasedNumberFormat.ORDINAL)
///           <br>&nbsp;&nbsp;&nbsp;&nbsp;.setDefaultRuleset(argStyleText);</code>
///    <tr>
///       <td><code>duration</code>
///       <td><i>argStyleText (optional)</i>
///       <td><code>new RuleBasedNumberFormat(getLocale(), RuleBasedNumberFormat.DURATION)
///           <br>&nbsp;&nbsp;&nbsp;&nbsp;.setDefaultRuleset(argStyleText);</code>
/// </table>
///
/// <h4><a name="diffsjdk">Differences from java.text.MessageFormat</a></h4>
///
/// The ICU MessageFormat supports both named and numbered arguments,
/// while the JDK MessageFormat only supports numbered arguments.
/// Named arguments make patterns more readable.
///
/// ICU implements a more user-friendly apostrophe quoting syntax.
/// In message text, an apostrophe only begins quoting literal text
/// if it immediately precedes a syntax character (mostly {curly braces}).<br>
/// In the JDK MessageFormat, an apostrophe always begins quoting,
/// which requires common text like "don't" and "aujourd'hui"
/// to be written with doubled apostrophes like "don''t" and "aujourd''hui".
/// For more details see MessagePattern.ApostropheMode.
///
/// ICU does not create a ChoiceFormat object for a choiceArg, pluralArg or selectArg
/// but rather handles such arguments itself.
/// The JDK MessageFormat does create and use a ChoiceFormat object
/// (<code>new ChoiceFormat(argStyleText)</code>).
/// The JDK does not support plural and select arguments at all.
///
/// <h4>Usage Information</h4>
///
/// Here are some examples of usage:
/// <blockquote>
/// <pre>
/// Object[] arguments = {
///     7,
///     new Date(System.currentTimeMillis()),
///     "a disturbance in the Force"
/// };
///
/// String result = MessageFormat.format(
///     "At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.",
///     arguments);
///
/// _output_: At 12:30 PM on Jul 3, 2053, there was a disturbance
///           in the Force on planet 7.
///
/// </pre>
/// </blockquote>
/// Typically, the message format will come from resources, and the
/// arguments will be dynamically set at runtime.
///
/// Example 2:
/// <blockquote>
/// <pre>
/// Object[] testArgs = { 3, "MyDisk" };
///
/// MessageFormat form = new MessageFormat(
///     "The disk \"{1}\" contains {0} file(s).");
///
/// System.out.println(form.format(testArgs));
///
/// // output, with different testArgs
/// _output_: The disk "MyDisk" contains 0 file(s).
/// _output_: The disk "MyDisk" contains 1 file(s).
/// _output_: The disk "MyDisk" contains 1,273 file(s).
/// </pre>
/// </blockquote>
///
/// For messages that include plural forms, you can use a plural argument:
/// <pre>
/// MessageFormat msgFmt = new MessageFormat(
///     "{num_files, plural, " +
///     "=0{There are no files on disk \"{disk_name}\".}" +
///     "=1{There is one file on disk \"{disk_name}\".}" +
///     "other{There are \# files on disk \"{disk_name}\".}}",
///     ULocale.ENGLISH);
/// Map args = new HashMap();
/// args.put("num_files", 0);
/// args.put("disk_name", "MyDisk");
/// System.out.println(msgFmt.format(args));
/// args.put("num_files", 3);
/// System.out.println(msgFmt.format(args));
///
/// _output_:
/// There are no files on disk "MyDisk".
/// There are 3 files on "MyDisk".
/// </pre>
/// See PluralFormat and PluralRules for details.
///
/// <h4><a name="synchronization">Synchronization</a></h4>
///
/// MessageFormats are not synchronized.
/// It is recommended to create separate format instances for each thread.
/// If multiple threads access a format concurrently, it must be synchronized
/// externally.
///@see java.util.Locale
///@see Format
///@see NumberFormat
///@see DecimalFormat
///@see ChoiceFormat
///@see PluralFormat
///@see SelectFormat
///@author Mark Davis
///@author Markus Scherer
class MessageFormat extends uformat_.UFormat {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/MessageFormat");
  MessageFormat.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String pattern)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a MessageFormat for the default <code>FORMAT</code> locale and the
  /// specified pattern.
  /// Sets the locale and calls applyPattern(pattern).
  ///@param pattern the pattern for this message format
  ///@exception IllegalArgumentException if the pattern is invalid
  ///@see Category\#FORMAT
  MessageFormat.ctor1(jni.JniString pattern)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [pattern.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/String;Ljava/util/Locale;)V");

  /// from: public void <init>(java.lang.String pattern, java.util.Locale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a MessageFormat for the specified locale and
  /// pattern.
  /// Sets the locale and calls applyPattern(pattern).
  ///@param pattern the pattern for this message format
  ///@param locale the locale for this message format
  ///@exception IllegalArgumentException if the pattern is invalid
  MessageFormat.ctor2(jni.JniString pattern, jni.JniObject locale)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [pattern.reference, locale.reference]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/String;Landroid/icu/util/ULocale;)V");

  /// from: public void <init>(java.lang.String pattern, android.icu.util.ULocale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a MessageFormat for the specified locale and
  /// pattern.
  /// Sets the locale and calls applyPattern(pattern).
  ///@param pattern the pattern for this message format
  ///@param locale the locale for this message format
  ///@exception IllegalArgumentException if the pattern is invalid
  MessageFormat.ctor3(jni.JniString pattern, ulocale_.ULocale locale)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3,
            [pattern.reference, locale.reference]).object);

  static final _id_setLocale = jniAccessors.getMethodIDOf(
      _classRef, "setLocale", "(Ljava/util/Locale;)V");

  /// from: public void setLocale(java.util.Locale locale)
  ///
  /// Sets the locale to be used for creating argument Format objects.
  /// This affects subsequent calls to the \#applyPattern applyPattern
  /// method as well as to the <code>format</code> and
  /// \#formatToCharacterIterator formatToCharacterIterator methods.
  ///@param locale the locale to be used when creating or comparing subformats
  void setLocale(jni.JniObject locale) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLocale,
      jni.JniType.voidType,
      [locale.reference]).check();

  static final _id_setLocale1 = jniAccessors.getMethodIDOf(
      _classRef, "setLocale", "(Landroid/icu/util/ULocale;)V");

  /// from: public void setLocale(android.icu.util.ULocale locale)
  ///
  /// Sets the locale to be used for creating argument Format objects.
  /// This affects subsequent calls to the \#applyPattern applyPattern
  /// method as well as to the <code>format</code> and
  /// \#formatToCharacterIterator formatToCharacterIterator methods.
  ///@param locale the locale to be used when creating or comparing subformats
  void setLocale1(ulocale_.ULocale locale) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLocale1,
      jni.JniType.voidType,
      [locale.reference]).check();

  static final _id_getLocale = jniAccessors.getMethodIDOf(
      _classRef, "getLocale", "()Ljava/util/Locale;");

  /// from: public java.util.Locale getLocale()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the locale that's used when creating or comparing subformats.
  ///@return the locale used when creating or comparing subformats
  jni.JniObject getLocale() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLocale, jni.JniType.objectType, []).object);

  static final _id_getULocale = jniAccessors.getMethodIDOf(
      _classRef, "getULocale", "()Landroid/icu/util/ULocale;");

  /// from: public android.icu.util.ULocale getULocale()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the locale that's used when creating argument Format objects.
  ///@return the locale used when creating or comparing subformats
  ulocale_.ULocale getULocale() =>
      ulocale_.ULocale.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getULocale, jni.JniType.objectType, []).object);

  static final _id_applyPattern = jniAccessors.getMethodIDOf(
      _classRef, "applyPattern", "(Ljava/lang/String;)V");

  /// from: public void applyPattern(java.lang.String pttrn)
  ///
  /// Sets the pattern used by this message format.
  /// Parses the pattern and caches Format objects for simple argument types.
  /// Patterns and their interpretation are specified in the
  /// <a href="\#patterns">class description</a>.
  ///@param pttrn the pattern for this message format
  ///@throws IllegalArgumentException if the pattern is invalid
  void applyPattern(jni.JniString pttrn) => jniAccessors.callMethodWithArgs(
      reference,
      _id_applyPattern,
      jni.JniType.voidType,
      [pttrn.reference]).check();

  static final _id_applyPattern1 = jniAccessors.getMethodIDOf(
      _classRef,
      "applyPattern",
      "(Ljava/lang/String;Landroid/icu/text/MessagePattern\$ApostropheMode;)V");

  /// from: public void applyPattern(java.lang.String pattern, android.icu.text.MessagePattern.ApostropheMode aposMode)
  ///
  /// <strong>[icu]</strong> Sets the ApostropheMode and the pattern used by this message format.
  /// Parses the pattern and caches Format objects for simple argument types.
  /// Patterns and their interpretation are specified in the
  /// <a href="\#patterns">class description</a>.
  ///
  /// This method is best used only once on a given object to avoid confusion about the mode,
  /// and after constructing the object with an empty pattern string to minimize overhead.
  ///@param pattern the pattern for this message format
  ///@param aposMode the new ApostropheMode
  ///@throws IllegalArgumentException if the pattern is invalid
  ///@see MessagePattern.ApostropheMode
  void applyPattern1(jni.JniString pattern,
          messagepattern_.MessagePattern_ApostropheMode aposMode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_applyPattern1,
          jni.JniType.voidType,
          [pattern.reference, aposMode.reference]).check();

  static final _id_getApostropheMode = jniAccessors.getMethodIDOf(
      _classRef,
      "getApostropheMode",
      "()Landroid/icu/text/MessagePattern\$ApostropheMode;");

  /// from: public android.icu.text.MessagePattern.ApostropheMode getApostropheMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong>
  ///@return this instance's ApostropheMode.
  messagepattern_.MessagePattern_ApostropheMode getApostropheMode() =>
      messagepattern_.MessagePattern_ApostropheMode.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getApostropheMode,
              jni.JniType.objectType, []).object);

  static final _id_toPattern = jniAccessors.getMethodIDOf(
      _classRef, "toPattern", "()Ljava/lang/String;");

  /// from: public java.lang.String toPattern()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the applied pattern string.
  ///@return the pattern string
  ///@throws IllegalStateException after custom Format objects have been set
  ///         via setFormat() or similar APIs
  jni.JniString toPattern() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toPattern, jni.JniType.objectType, []).object);

  static final _id_setFormatsByArgumentIndex = jniAccessors.getMethodIDOf(
      _classRef, "setFormatsByArgumentIndex", "([Ljava/text/Format;)V");

  /// from: public void setFormatsByArgumentIndex(java.text.Format[] newFormats)
  ///
  /// Sets the Format objects to use for the values passed into
  /// <code>format</code> methods or returned from <code>parse</code>
  /// methods. The indices of elements in <code>newFormats</code>
  /// correspond to the argument indices used in the previously set
  /// pattern string.
  /// The order of formats in <code>newFormats</code> thus corresponds to
  /// the order of elements in the <code>arguments</code> array passed
  /// to the <code>format</code> methods or the result array returned
  /// by the <code>parse</code> methods.
  ///
  /// If an argument index is used for more than one format element
  /// in the pattern string, then the corresponding new format is used
  /// for all such format elements. If an argument index is not used
  /// for any format element in the pattern string, then the
  /// corresponding new format is ignored. If fewer formats are provided
  /// than needed, then only the formats for argument indices less
  /// than <code>newFormats.length</code> are replaced.
  ///
  /// This method is only supported if the format does not use
  /// named arguments, otherwise an IllegalArgumentException is thrown.
  ///@param newFormats the new formats to use
  ///@throws NullPointerException if <code>newFormats</code> is null
  ///@throws IllegalArgumentException if this formatter uses named arguments
  void setFormatsByArgumentIndex(jni.JniObject newFormats) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFormatsByArgumentIndex,
          jni.JniType.voidType, [newFormats.reference]).check();

  static final _id_setFormatsByArgumentName = jniAccessors.getMethodIDOf(
      _classRef, "setFormatsByArgumentName", "(Ljava/util/Map;)V");

  /// from: public void setFormatsByArgumentName(java.util.Map<java.lang.String,java.text.Format> newFormats)
  ///
  /// <strong>[icu]</strong> Sets the Format objects to use for the values passed into
  /// <code>format</code> methods or returned from <code>parse</code>
  /// methods. The keys in <code>newFormats</code> are the argument
  /// names in the previously set pattern string, and the values
  /// are the formats.
  ///
  /// Only argument names from the pattern string are considered.
  /// Extra keys in <code>newFormats</code> that do not correspond
  /// to an argument name are ignored.  Similarly, if there is no
  /// format in newFormats for an argument name, the formatter
  /// for that argument remains unchanged.
  ///
  /// This may be called on formats that do not use named arguments.
  /// In this case the map will be queried for key Strings that
  /// represent argument indices, e.g. "0", "1", "2" etc.
  ///@param newFormats a map from String to Format providing new
  ///        formats for named arguments.
  void setFormatsByArgumentName(jni.JniObject newFormats) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFormatsByArgumentName,
          jni.JniType.voidType, [newFormats.reference]).check();

  static final _id_setFormats = jniAccessors.getMethodIDOf(
      _classRef, "setFormats", "([Ljava/text/Format;)V");

  /// from: public void setFormats(java.text.Format[] newFormats)
  ///
  /// Sets the Format objects to use for the format elements in the
  /// previously set pattern string.
  /// The order of formats in <code>newFormats</code> corresponds to
  /// the order of format elements in the pattern string.
  ///
  /// If more formats are provided than needed by the pattern string,
  /// the remaining ones are ignored. If fewer formats are provided
  /// than needed, then only the first <code>newFormats.length</code>
  /// formats are replaced.
  ///
  /// Since the order of format elements in a pattern string often
  /// changes during localization, it is generally better to use the
  /// \#setFormatsByArgumentIndex setFormatsByArgumentIndex
  /// method, which assumes an order of formats corresponding to the
  /// order of elements in the <code>arguments</code> array passed to
  /// the <code>format</code> methods or the result array returned by
  /// the <code>parse</code> methods.
  ///@param newFormats the new formats to use
  ///@exception NullPointerException if <code>newFormats</code> is null
  void setFormats(jni.JniObject newFormats) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFormats,
      jni.JniType.voidType,
      [newFormats.reference]).check();

  static final _id_setFormatByArgumentIndex = jniAccessors.getMethodIDOf(
      _classRef, "setFormatByArgumentIndex", "(ILjava/text/Format;)V");

  /// from: public void setFormatByArgumentIndex(int argumentIndex, java.text.Format newFormat)
  ///
  /// Sets the Format object to use for the format elements within the
  /// previously set pattern string that use the given argument
  /// index.
  /// The argument index is part of the format element definition and
  /// represents an index into the <code>arguments</code> array passed
  /// to the <code>format</code> methods or the result array returned
  /// by the <code>parse</code> methods.
  ///
  /// If the argument index is used for more than one format element
  /// in the pattern string, then the new format is used for all such
  /// format elements. If the argument index is not used for any format
  /// element in the pattern string, then the new format is ignored.
  ///
  /// This method is only supported when exclusively numbers are used for
  /// argument names. Otherwise an IllegalArgumentException is thrown.
  ///@param argumentIndex the argument index for which to use the new format
  ///@param newFormat the new format to use
  ///@throws IllegalArgumentException if this format uses named arguments
  void setFormatByArgumentIndex(int argumentIndex, jni.JniObject newFormat) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFormatByArgumentIndex,
          jni.JniType.voidType, [argumentIndex, newFormat.reference]).check();

  static final _id_setFormatByArgumentName = jniAccessors.getMethodIDOf(
      _classRef,
      "setFormatByArgumentName",
      "(Ljava/lang/String;Ljava/text/Format;)V");

  /// from: public void setFormatByArgumentName(java.lang.String argumentName, java.text.Format newFormat)
  ///
  /// <strong>[icu]</strong> Sets the Format object to use for the format elements within the
  /// previously set pattern string that use the given argument
  /// name.
  ///
  /// If the argument name is used for more than one format element
  /// in the pattern string, then the new format is used for all such
  /// format elements. If the argument name is not used for any format
  /// element in the pattern string, then the new format is ignored.
  ///
  /// This API may be used on formats that do not use named arguments.
  /// In this case <code>argumentName</code> should be a String that names
  /// an argument index, e.g. "0", "1", "2"... etc.  If it does not name
  /// a valid index, the format will be ignored.  No error is thrown.
  ///@param argumentName the name of the argument to change
  ///@param newFormat the new format to use
  void setFormatByArgumentName(
          jni.JniString argumentName, jni.JniObject newFormat) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setFormatByArgumentName,
          jni.JniType.voidType,
          [argumentName.reference, newFormat.reference]).check();

  static final _id_setFormat = jniAccessors.getMethodIDOf(
      _classRef, "setFormat", "(ILjava/text/Format;)V");

  /// from: public void setFormat(int formatElementIndex, java.text.Format newFormat)
  ///
  /// Sets the Format object to use for the format element with the given
  /// format element index within the previously set pattern string.
  /// The format element index is the zero-based number of the format
  /// element counting from the start of the pattern string.
  ///
  /// Since the order of format elements in a pattern string often
  /// changes during localization, it is generally better to use the
  /// \#setFormatByArgumentIndex setFormatByArgumentIndex
  /// method, which accesses format elements based on the argument
  /// index they specify.
  ///@param formatElementIndex the index of a format element within the pattern
  ///@param newFormat the format to use for the specified format element
  ///@exception ArrayIndexOutOfBoundsException if formatElementIndex is equal to or
  ///            larger than the number of format elements in the pattern string
  void setFormat(int formatElementIndex, jni.JniObject newFormat) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setFormat,
          jni.JniType.voidType,
          [formatElementIndex, newFormat.reference]).check();

  static final _id_getFormatsByArgumentIndex = jniAccessors.getMethodIDOf(
      _classRef, "getFormatsByArgumentIndex", "()[Ljava/text/Format;");

  /// from: public java.text.Format[] getFormatsByArgumentIndex()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Format objects used for the values passed into
  /// <code>format</code> methods or returned from <code>parse</code>
  /// methods. The indices of elements in the returned array
  /// correspond to the argument indices used in the previously set
  /// pattern string.
  /// The order of formats in the returned array thus corresponds to
  /// the order of elements in the <code>arguments</code> array passed
  /// to the <code>format</code> methods or the result array returned
  /// by the <code>parse</code> methods.
  ///
  /// If an argument index is used for more than one format element
  /// in the pattern string, then the format used for the last such
  /// format element is returned in the array. If an argument index
  /// is not used for any format element in the pattern string, then
  /// null is returned in the array.
  ///
  /// This method is only supported when exclusively numbers are used for
  /// argument names. Otherwise an IllegalArgumentException is thrown.
  ///@return the formats used for the arguments within the pattern
  ///@throws IllegalArgumentException if this format uses named arguments
  jni.JniObject getFormatsByArgumentIndex() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getFormatsByArgumentIndex, jni.JniType.objectType, []).object);

  static final _id_getFormats = jniAccessors.getMethodIDOf(
      _classRef, "getFormats", "()[Ljava/text/Format;");

  /// from: public java.text.Format[] getFormats()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Format objects used for the format elements in the
  /// previously set pattern string.
  /// The order of formats in the returned array corresponds to
  /// the order of format elements in the pattern string.
  ///
  /// Since the order of format elements in a pattern string often
  /// changes during localization, it's generally better to use the
  /// \#getFormatsByArgumentIndex()
  /// method, which assumes an order of formats corresponding to the
  /// order of elements in the <code>arguments</code> array passed to
  /// the <code>format</code> methods or the result array returned by
  /// the <code>parse</code> methods.
  ///
  /// This method is only supported when exclusively numbers are used for
  /// argument names. Otherwise an IllegalArgumentException is thrown.
  ///@return the formats used for the format elements in the pattern
  ///@throws IllegalArgumentException if this format uses named arguments
  jni.JniObject getFormats() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFormats, jni.JniType.objectType, []).object);

  static final _id_getArgumentNames = jniAccessors.getMethodIDOf(
      _classRef, "getArgumentNames", "()Ljava/util/Set;");

  /// from: public java.util.Set<java.lang.String> getArgumentNames()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the top-level argument names. For more details, see
  /// \#setFormatByArgumentName(String, Format).
  ///@return a Set of argument names
  jni.JniObject getArgumentNames() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getArgumentNames, jni.JniType.objectType, []).object);

  static final _id_getFormatByArgumentName = jniAccessors.getMethodIDOf(
      _classRef,
      "getFormatByArgumentName",
      "(Ljava/lang/String;)Ljava/text/Format;");

  /// from: public java.text.Format getFormatByArgumentName(java.lang.String argumentName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the first top-level format associated with the given argument name.
  /// For more details, see \#setFormatByArgumentName(String, Format).
  ///@param argumentName The name of the desired argument.
  ///@return the Format associated with the name, or null if there isn't one.
  jni.JniObject getFormatByArgumentName(jni.JniString argumentName) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getFormatByArgumentName,
          jni.JniType.objectType,
          [argumentName.reference]).object);

  static final _id_format = jniAccessors.getMethodIDOf(_classRef, "format",
      "([Ljava/lang/Object;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;");

  /// from: public final java.lang.StringBuffer format(java.lang.Object[] arguments, java.lang.StringBuffer result, java.text.FieldPosition pos)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formats an array of objects and appends the <code>MessageFormat</code>'s
  /// pattern, with arguments replaced by the formatted objects, to the
  /// provided <code>StringBuffer</code>.
  ///
  /// The text substituted for the individual format elements is derived from
  /// the current subformat of the format element and the
  /// <code>arguments</code> element at the format element's argument index
  /// as indicated by the first matching line of the following table. An
  /// argument is <i>unavailable</i> if <code>arguments</code> is
  /// <code>null</code> or has fewer than argumentIndex+1 elements.  When
  /// an argument is unavailable no substitution is performed.
  ///
  /// <table border=1>
  ///    <tr>
  ///       <th>argType or Format
  ///       <th>value object
  ///       <th>Formatted Text
  ///    <tr>
  ///       <td><i>any</i>
  ///       <td><i>unavailable</i>
  ///       <td><code>"{" + argNameOrNumber + "}"</code>
  ///    <tr>
  ///       <td><i>any</i>
  ///       <td><code>null</code>
  ///       <td><code>"null"</code>
  ///    <tr>
  ///       <td>custom Format <code>!= null</code>
  ///       <td><i>any</i>
  ///       <td><code>customFormat.format(argument)</code>
  ///    <tr>
  ///       <td>noneArg, or custom Format <code>== null</code>
  ///       <td><code>instanceof Number</code>
  ///       <td><code>NumberFormat.getInstance(getLocale()).format(argument)</code>
  ///    <tr>
  ///       <td>noneArg, or custom Format <code>== null</code>
  ///       <td><code>instanceof Date</code>
  ///       <td><code>DateFormat.getDateTimeInstance(DateFormat.SHORT,
  ///           DateFormat.SHORT, getLocale()).format(argument)</code>
  ///    <tr>
  ///       <td>noneArg, or custom Format <code>== null</code>
  ///       <td><code>instanceof String</code>
  ///       <td><code>argument</code>
  ///    <tr>
  ///       <td>noneArg, or custom Format <code>== null</code>
  ///       <td><i>any</i>
  ///       <td><code>argument.toString()</code>
  ///    <tr>
  ///       <td>complexArg
  ///       <td><i>any</i>
  ///       <td>result of recursive formatting of a selected sub-message
  /// </table>
  ///
  /// If <code>pos</code> is non-null, and refers to
  /// <code>Field.ARGUMENT</code>, the location of the first formatted
  /// string will be returned.
  ///
  /// This method is only supported when the format does not use named
  /// arguments, otherwise an IllegalArgumentException is thrown.
  ///@param arguments an array of objects to be formatted and substituted.
  ///@param result where text is appended.
  ///@param pos On input: an alignment field, if desired.
  ///            On output: the offsets of the alignment field.
  ///@throws IllegalArgumentException if a value in the
  ///         <code>arguments</code> array is not of the type
  ///         expected by the corresponding argument or custom Format object.
  ///@throws IllegalArgumentException if this format uses named arguments
  jni.JniObject format(
          jni.JniObject arguments, jni.JniObject result, jni.JniObject pos) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_format,
          jni.JniType.objectType,
          [arguments.reference, result.reference, pos.reference]).object);

  static final _id_format1 = jniAccessors.getMethodIDOf(_classRef, "format",
      "(Ljava/util/Map;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;");

  /// from: public final java.lang.StringBuffer format(java.util.Map<java.lang.String,java.lang.Object> arguments, java.lang.StringBuffer result, java.text.FieldPosition pos)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formats a map of objects and appends the <code>MessageFormat</code>'s
  /// pattern, with arguments replaced by the formatted objects, to the
  /// provided <code>StringBuffer</code>.
  ///
  /// The text substituted for the individual format elements is derived from
  /// the current subformat of the format element and the
  /// <code>arguments</code> value corresopnding to the format element's
  /// argument name.
  ///
  /// A numbered pattern argument is matched with a map key that contains that number
  /// as an ASCII-decimal-digit string (without leading zero).
  ///
  /// An argument is <i>unavailable</i> if <code>arguments</code> is
  /// <code>null</code> or does not have a value corresponding to an argument
  /// name in the pattern.  When an argument is unavailable no substitution
  /// is performed.
  ///@param arguments a map of objects to be formatted and substituted.
  ///@param result where text is appended.
  ///@param pos On input: an alignment field, if desired.
  ///            On output: the offsets of the alignment field.
  ///@throws IllegalArgumentException if a value in the
  ///         <code>arguments</code> array is not of the type
  ///         expected by the corresponding argument or custom Format object.
  ///@return the passed-in StringBuffer
  jni.JniObject format1(
          jni.JniObject arguments, jni.JniObject result, jni.JniObject pos) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_format1,
          jni.JniType.objectType,
          [arguments.reference, result.reference, pos.reference]).object);

  static final _id_format2 = jniAccessors.getStaticMethodIDOf(_classRef,
      "format", "(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;");

  /// from: static public java.lang.String format(java.lang.String pattern, java.lang.Object[] arguments)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a MessageFormat with the given pattern and uses it
  /// to format the given arguments. This is equivalent to
  /// <blockquote>
  ///     <code>(new \#MessageFormat(String) MessageFormat(pattern)).\#format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format(arguments, new StringBuffer(), null).toString()</code>
  /// </blockquote>
  ///@throws IllegalArgumentException if the pattern is invalid
  ///@throws IllegalArgumentException if a value in the
  ///         <code>arguments</code> array is not of the type
  ///         expected by the corresponding argument or custom Format object.
  ///@throws IllegalArgumentException if this format uses named arguments
  static jni.JniString format2(
          jni.JniString pattern, jni.JniObject arguments) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_format2,
          jni.JniType.objectType,
          [pattern.reference, arguments.reference]).object);

  static final _id_format3 = jniAccessors.getStaticMethodIDOf(_classRef,
      "format", "(Ljava/lang/String;Ljava/util/Map;)Ljava/lang/String;");

  /// from: static public java.lang.String format(java.lang.String pattern, java.util.Map<java.lang.String,java.lang.Object> arguments)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a MessageFormat with the given pattern and uses it to
  /// format the given arguments.  The pattern must identifyarguments
  /// by name instead of by number.
  ///
  ///@throws IllegalArgumentException if the pattern is invalid
  ///@throws IllegalArgumentException if a value in the
  ///         <code>arguments</code> array is not of the type
  ///         expected by the corresponding argument or custom Format object.
  ///@see \#format(Map, StringBuffer, FieldPosition)
  ///@see \#format(String, Object[])
  static jni.JniString format3(
          jni.JniString pattern, jni.JniObject arguments) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_format3,
          jni.JniType.objectType,
          [pattern.reference, arguments.reference]).object);

  static final _id_usesNamedArguments =
      jniAccessors.getMethodIDOf(_classRef, "usesNamedArguments", "()Z");

  /// from: public boolean usesNamedArguments()
  ///
  /// <strong>[icu]</strong> Returns true if this MessageFormat uses named arguments,
  /// and false otherwise.  See class description.
  ///@return true if named arguments are used.
  bool usesNamedArguments() => jniAccessors.callMethodWithArgs(
      reference, _id_usesNamedArguments, jni.JniType.booleanType, []).boolean;

  static final _id_format4 = jniAccessors.getMethodIDOf(_classRef, "format",
      "(Ljava/lang/Object;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;");

  /// from: public final java.lang.StringBuffer format(java.lang.Object arguments, java.lang.StringBuffer result, java.text.FieldPosition pos)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formats a map or array of objects and appends the <code>MessageFormat</code>'s
  /// pattern, with format elements replaced by the formatted objects, to the
  /// provided <code>StringBuffer</code>.
  /// This is equivalent to either of
  /// <blockquote>
  ///     <code>\#format(java.lang.Object[], java.lang.StringBuffer,
  ///     java.text.FieldPosition) format((Object[]) arguments, result, pos)</code>
  ///     <code>\#format(java.util.Map, java.lang.StringBuffer,
  ///     java.text.FieldPosition) format((Map) arguments, result, pos)</code>
  /// </blockquote>
  /// A map must be provided if this format uses named arguments, otherwise
  /// an IllegalArgumentException will be thrown.
  ///@param arguments a map or array of objects to be formatted
  ///@param result where text is appended
  ///@param pos On input: an alignment field, if desired
  ///            On output: the offsets of the alignment field
  ///@throws IllegalArgumentException if an argument in
  ///         <code>arguments</code> is not of the type
  ///         expected by the format element(s) that use it
  ///@throws IllegalArgumentException if <code>arguments</code> is
  ///         an array of Object and this format uses named arguments
  jni.JniObject format4(
          jni.JniObject arguments, jni.JniObject result, jni.JniObject pos) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_format4,
          jni.JniType.objectType,
          [arguments.reference, result.reference, pos.reference]).object);

  static final _id_formatToCharacterIterator = jniAccessors.getMethodIDOf(
      _classRef,
      "formatToCharacterIterator",
      "(Ljava/lang/Object;)Ljava/text/AttributedCharacterIterator;");

  /// from: public java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object arguments)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formats an array of objects and inserts them into the
  /// <code>MessageFormat</code>'s pattern, producing an
  /// <code>AttributedCharacterIterator</code>.
  /// You can use the returned <code>AttributedCharacterIterator</code>
  /// to build the resulting String, as well as to determine information
  /// about the resulting String.
  ///
  /// The text of the returned <code>AttributedCharacterIterator</code> is
  /// the same that would be returned by
  /// <blockquote>
  ///     <code>\#format(java.lang.Object[], java.lang.StringBuffer,
  ///     java.text.FieldPosition) format(arguments, new StringBuffer(), null).toString()</code>
  /// </blockquote>
  ///
  /// In addition, the <code>AttributedCharacterIterator</code> contains at
  /// least attributes indicating where text was generated from an
  /// argument in the <code>arguments</code> array. The keys of these attributes are of
  /// type <code>MessageFormat.Field</code>, their values are
  /// <code>Integer</code> objects indicating the index in the <code>arguments</code>
  /// array of the argument from which the text was generated.
  ///
  /// The attributes/value from the underlying <code>Format</code>
  /// instances that <code>MessageFormat</code> uses will also be
  /// placed in the resulting <code>AttributedCharacterIterator</code>.
  /// This allows you to not only find where an argument is placed in the
  /// resulting String, but also which fields it contains in turn.
  ///@param arguments an array of objects to be formatted and substituted.
  ///@return AttributedCharacterIterator describing the formatted value.
  ///@exception NullPointerException if <code>arguments</code> is null.
  ///@throws IllegalArgumentException if a value in the
  ///         <code>arguments</code> array is not of the type
  ///         expected by the corresponding argument or custom Format object.
  jni.JniObject formatToCharacterIterator(jni.JniObject arguments) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_formatToCharacterIterator,
          jni.JniType.objectType,
          [arguments.reference]).object);

  static final _id_parse = jniAccessors.getMethodIDOf(_classRef, "parse",
      "(Ljava/lang/String;Ljava/text/ParsePosition;)[Ljava/lang/Object;");

  /// from: public java.lang.Object[] parse(java.lang.String source, java.text.ParsePosition pos)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses the string.
  ///
  /// Caveats: The parse may fail in a number of circumstances.
  /// For example:
  /// <ul>
  /// <li>If one of the arguments does not occur in the pattern.
  /// <li>If the format of an argument loses information, such as
  ///     with a choice format where a large number formats to "many".
  /// <li>Does not yet handle recursion (where
  ///     the substituted strings contain {n} references.)
  /// <li>Will not always find a match (or the correct match)
  ///     if some part of the parse is ambiguous.
  ///     For example, if the pattern "{1},{2}" is used with the
  ///     string arguments {"a,b", "c"}, it will format as "a,b,c".
  ///     When the result is parsed, it will return {"a", "b,c"}.
  /// <li>If a single argument is parsed more than once in the string,
  ///     then the later parse wins.
  /// </ul>
  /// When the parse fails, use ParsePosition.getErrorIndex() to find out
  /// where in the string did the parsing failed. The returned error
  /// index is the starting offset of the sub-patterns that the string
  /// is comparing with. For example, if the parsing string "AAA {0} BBB"
  /// is comparing against the pattern "AAD {0} BBB", the error index is
  /// 0. When an error occurs, the call to this method will return null.
  /// If the source is null, return an empty array.
  ///@throws IllegalArgumentException if this format uses named arguments
  jni.JniObject parse(jni.JniString source, jni.JniObject pos) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_parse,
          jni.JniType.objectType,
          [source.reference, pos.reference]).object);

  static final _id_parseToMap = jniAccessors.getMethodIDOf(
      _classRef,
      "parseToMap",
      "(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/util/Map;");

  /// from: public java.util.Map<java.lang.String,java.lang.Object> parseToMap(java.lang.String source, java.text.ParsePosition pos)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Parses the string, returning the results in a Map.
  /// This is similar to the version that returns an array
  /// of Object.  This supports both named and numbered
  /// arguments-- if numbered, the keys in the map are the
  /// corresponding ASCII-decimal-digit strings (e.g. "0", "1", "2"...).
  ///@param source the text to parse
  ///@param pos the position at which to start parsing.  on return,
  ///        contains the result of the parse.
  ///@return a Map containing key/value pairs for each parsed argument.
  jni.JniObject parseToMap(jni.JniString source, jni.JniObject pos) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_parseToMap,
          jni.JniType.objectType,
          [source.reference, pos.reference]).object);

  static final _id_parse1 = jniAccessors.getMethodIDOf(
      _classRef, "parse", "(Ljava/lang/String;)[Ljava/lang/Object;");

  /// from: public java.lang.Object[] parse(java.lang.String source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses text from the beginning of the given string to produce an object
  /// array.
  /// The method may not use the entire text of the given string.
  ///
  /// See the \#parse(String, ParsePosition) method for more information
  /// on message parsing.
  ///@param source A <code>String</code> whose beginning should be parsed.
  ///@return An <code>Object</code> array parsed from the string.
  ///@exception ParseException if the beginning of the specified string cannot be parsed.
  ///@exception IllegalArgumentException if this format uses named arguments
  jni.JniObject parse1(jni.JniString source) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_parse1, jni.JniType.objectType, [source.reference]).object);

  static final _id_parseToMap1 = jniAccessors.getMethodIDOf(
      _classRef, "parseToMap", "(Ljava/lang/String;)Ljava/util/Map;");

  /// from: public java.util.Map<java.lang.String,java.lang.Object> parseToMap(java.lang.String source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Parses text from the beginning of the given string to produce a map from
  /// argument to values. The method may not use the entire text of the given string.
  ///
  /// See the \#parse(String, ParsePosition) method for more information on
  /// message parsing.
  ///@param source A <code>String</code> whose beginning should be parsed.
  ///@return A <code>Map</code> parsed from the string.
  ///@throws ParseException if the beginning of the specified string cannot
  ///         be parsed.
  ///@see \#parseToMap(String, ParsePosition)
  jni.JniObject parseToMap1(jni.JniString source) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_parseToMap1, jni.JniType.objectType, [source.reference]).object);

  static final _id_parseObject = jniAccessors.getMethodIDOf(
      _classRef,
      "parseObject",
      "(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/lang/Object;");

  /// from: public java.lang.Object parseObject(java.lang.String source, java.text.ParsePosition pos)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses text from a string to produce an object array or Map.
  ///
  /// The method attempts to parse text starting at the index given by
  /// <code>pos</code>.
  /// If parsing succeeds, then the index of <code>pos</code> is updated
  /// to the index after the last character used (parsing does not necessarily
  /// use all characters up to the end of the string), and the parsed
  /// object array is returned. The updated <code>pos</code> can be used to
  /// indicate the starting point for the next call to this method.
  /// If an error occurs, then the index of <code>pos</code> is not
  /// changed, the error index of <code>pos</code> is set to the index of
  /// the character where the error occurred, and null is returned.
  ///
  /// See the \#parse(String, ParsePosition) method for more information
  /// on message parsing.
  ///@param source A <code>String</code>, part of which should be parsed.
  ///@param pos A <code>ParsePosition</code> object with index and error
  ///            index information as described above.
  ///@return An <code>Object</code> parsed from the string, either an
  ///         array of Object, or a Map, depending on whether named
  ///         arguments are used.  This can be queried using <code>usesNamedArguments</code>.
  ///         In case of error, returns null.
  ///@throws NullPointerException if <code>pos</code> is null.
  jni.JniObject parseObject(jni.JniString source, jni.JniObject pos) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_parseObject,
          jni.JniType.objectType,
          [source.reference, pos.reference]).object);

  static final _id_clone =
      jniAccessors.getMethodIDOf(_classRef, "clone", "()Ljava/lang/Object;");

  /// from: public java.lang.Object clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniObject clone() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// {@inheritDoc}
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// {@inheritDoc}
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_autoQuoteApostrophe = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "autoQuoteApostrophe",
      "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String autoQuoteApostrophe(java.lang.String pattern)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Converts an 'apostrophe-friendly' pattern into a standard
  /// pattern.
  /// _This is obsolete for ICU 4.8 and higher MessageFormat pattern strings._
  /// It can still be useful together with java.text.MessageFormat.
  ///
  /// See the class description for more about apostrophes and quoting,
  /// and differences between ICU and java.text.MessageFormat.
  ///
  /// java.text.MessageFormat and ICU 4.6 and earlier MessageFormat
  /// treat all ASCII apostrophes as
  /// quotes, which is problematic in some languages, e.g.
  /// French, where apostrophe is commonly used.  This utility
  /// assumes that only an unpaired apostrophe immediately before
  /// a brace is a true quote.  Other unpaired apostrophes are paired,
  /// and the resulting standard pattern string is returned.
  ///
  /// __Note__: It is not guaranteed that the returned pattern
  /// is indeed a valid pattern.  The only effect is to convert
  /// between patterns having different quoting semantics.
  ///
  /// __Note__: This method only works on top-level messageText,
  /// not messageText nested inside a complexArg.
  ///@param pattern the 'apostrophe-friendly' pattern to convert
  ///@return the standard equivalent of the original pattern
  static jni.JniString autoQuoteApostrophe(jni.JniString pattern) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_autoQuoteApostrophe,
          jni.JniType.objectType,
          [pattern.reference]).object);
}

/// from: android.icu.text.MessageFormat$Field
///
/// Defines constants that are used as attribute keys in the
/// <code>AttributedCharacterIterator</code> returned
/// from <code>MessageFormat.formatToCharacterIterator</code>.
class MessageFormat_Field extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/MessageFormat\$Field");
  MessageFormat_Field.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ARGUMENT = jniAccessors.getStaticFieldIDOf(
      _classRef, "ARGUMENT", "Landroid/icu/text/MessageFormat\$Field;");

  /// from: static public final android.icu.text.MessageFormat.Field ARGUMENT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constant identifying a portion of a message that was generated
  /// from an argument passed into <code>formatToCharacterIterator</code>.
  /// The value associated with the key will be an <code>Integer</code>
  /// indicating the index in the <code>arguments</code> array of the
  /// argument from which the text was generated.
  static MessageFormat_Field get ARGUMENT =>
      MessageFormat_Field.fromRef(jniAccessors
          .getStaticField(_classRef, _id_ARGUMENT, jni.JniType.objectType)
          .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: protected void <init>(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a <code>Field</code> with the specified name.
  ///@param name The name of the attribute
  MessageFormat_Field(jni.JniString name)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [name.reference]).object);

  static final _id_readResolve = jniAccessors.getMethodIDOf(
      _classRef, "readResolve", "()Ljava/lang/Object;");

  /// from: protected java.lang.Object readResolve()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Resolves instances being deserialized to the predefined constants.
  ///@return resolved MessageFormat.Field constant
  ///@throws InvalidObjectException if the constant could not be resolved.
  jni.JniObject readResolve() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_readResolve, jni.JniType.objectType, []).object);
}
