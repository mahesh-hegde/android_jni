// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../util/ULocale.dart" as ulocale_;

import "UnicodeSet.dart" as unicodeset_;

import "CollationKey.dart" as collationkey_;

import "../util/VersionInfo.dart" as versioninfo_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.text.Collator
///
/// <strong>[icu enhancement]</strong> ICU's replacement for java.text.Collator.&nbsp;Methods, fields, and other functionality specific to ICU are labeled '<strong>[icu]</strong>'.
///
/// Collator performs locale-sensitive string comparison. A concrete
/// subclass, RuleBasedCollator, allows customization of the collation
/// ordering by the use of rule sets.
///
/// A Collator is thread-safe only when frozen. See \#isFrozen() and Freezable.
///
/// Following the <a href=http://www.unicode.org>Unicode
/// Consortium</a>'s specifications for the
/// <a href="http://www.unicode.org/unicode/reports/tr10/">Unicode Collation
/// Algorithm (UCA)</a>, there are 5 different levels of strength used
/// in comparisons:
///
/// <ul>
/// <li>PRIMARY strength: Typically, this is used to denote differences between
///     base characters (for example, "a" &lt; "b").
///     It is the strongest difference. For example, dictionaries are divided
///     into different sections by base character.
/// <li>SECONDARY strength: Accents in the characters are considered secondary
///     differences (for example, "as" &lt; "&agrave;s" &lt; "at"). Other
///     differences
///     between letters can also be considered secondary differences, depending
///     on the language. A secondary difference is ignored when there is a
///     primary difference anywhere in the strings.
/// <li>TERTIARY strength: Upper and lower case differences in characters are
///     distinguished at tertiary strength (for example, "ao" &lt; "Ao" &lt;
///     "a&ograve;"). In addition, a variant of a letter differs from the base
///     form on the tertiary strength (such as "A" and "\u24b6"). Another
///     example is the
///     difference between large and small Kana. A tertiary difference is ignored
///     when there is a primary or secondary difference anywhere in the strings.
/// <li>QUATERNARY strength: When punctuation is ignored
///     (see <a href="http://userguide.icu-project.org/collation/concepts\#TOC-Ignoring-Punctuation">
///     Ignoring Punctuations in the User Guide</a>) at PRIMARY to TERTIARY
///     strength, an additional strength level can
///     be used to distinguish words with and without punctuation (for example,
///     "ab" &lt; "a-b" &lt; "aB").
///     This difference is ignored when there is a PRIMARY, SECONDARY or TERTIARY
///     difference. The QUATERNARY strength should only be used if ignoring
///     punctuation is required.
/// <li>IDENTICAL strength:
///     When all other strengths are equal, the IDENTICAL strength is used as a
///     tiebreaker. The Unicode code point values of the NFD form of each string
///     are compared, just in case there is no difference.
///     For example, Hebrew cantellation marks are only distinguished at this
///     strength. This strength should be used sparingly, as only code point
///     value differences between two strings is an extremely rare occurrence.
///     Using this strength substantially decreases the performance for both
///     comparison and collation key generation APIs. This strength also
///     increases the size of the collation key.
/// </ul>
///
/// Unlike the JDK, ICU4J's Collator deals only with 2 decomposition modes,
/// the canonical decomposition mode and one that does not use any decomposition.
/// The compatibility decomposition mode, java.text.Collator.FULL_DECOMPOSITION
/// is not supported here. If the canonical
/// decomposition mode is set, the Collator handles un-normalized text properly,
/// producing the same results as if the text were normalized in NFD. If
/// canonical decomposition is turned off, it is the user's responsibility to
/// ensure that all text is already in the appropriate form before performing
/// a comparison or before getting a CollationKey.
///
/// For more information about the collation service see the
/// <a href="http://userguide.icu-project.org/collation">User Guide</a>.
///
/// Examples of use
/// <pre>
/// // Get the Collator for US English and set its strength to PRIMARY
/// Collator usCollator = Collator.getInstance(Locale.US);
/// usCollator.setStrength(Collator.PRIMARY);
/// if (usCollator.compare("abc", "ABC") == 0) {
///     System.out.println("Strings are equivalent");
/// }
///
/// The following example shows how to compare two strings using the
/// Collator for the default locale.
///
/// // Compare two strings in the default locale
/// Collator myCollator = Collator.getInstance();
/// myCollator.setDecomposition(NO_DECOMPOSITION);
/// if (myCollator.compare("&agrave;&\#92;u0325", "a&\#92;u0325&\#768;") != 0) {
///     System.out.println("&agrave;&\#92;u0325 is not equals to a&\#92;u0325&\#768; without decomposition");
///     myCollator.setDecomposition(CANONICAL_DECOMPOSITION);
///     if (myCollator.compare("&agrave;&\#92;u0325", "a&\#92;u0325&\#768;") != 0) {
///         System.out.println("Error: &agrave;&\#92;u0325 should be equals to a&\#92;u0325&\#768; with decomposition");
///     }
///     else {
///         System.out.println("&agrave;&\#92;u0325 is equals to a&\#92;u0325&\#768; with decomposition");
///     }
/// }
/// else {
///     System.out.println("Error: &agrave;&\#92;u0325 should be not equals to a&\#92;u0325&\#768; without decomposition");
/// }
/// </pre>
///@see RuleBasedCollator
///@see CollationKey
///@author Syn Wee Quek
class Collator extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/icu/text/Collator");
  Collator.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CANONICAL_DECOMPOSITION
  ///
  /// Decomposition mode value. With CANONICAL_DECOMPOSITION set,
  /// characters that are canonical variants according to the Unicode standard
  /// will be decomposed for collation.
  ///
  /// CANONICAL_DECOMPOSITION corresponds to Normalization Form D as
  /// described in <a href="http://www.unicode.org/unicode/reports/tr15/">
  /// Unicode Technical Report \#15</a>.
  ///@see \#NO_DECOMPOSITION
  ///@see \#getDecomposition
  ///@see \#setDecomposition
  static const CANONICAL_DECOMPOSITION = 17;

  /// from: static public final int FULL_DECOMPOSITION
  ///
  /// <strong>[icu] Note:</strong> This is for backwards compatibility with Java APIs only.  It
  /// should not be used, IDENTICAL should be used instead.  ICU's
  /// collation does not support Java's FULL_DECOMPOSITION mode.
  static const FULL_DECOMPOSITION = 15;

  /// from: static public final int IDENTICAL
  ///
  /// Smallest Collator strength value. When all other strengths are equal,
  /// the IDENTICAL strength is used as a tiebreaker. The Unicode code point
  /// values of the NFD form of each string are compared, just in case there
  /// is no difference.
  /// See class documentation for more explanation.
  ///
  /// Note this value is different from JDK's
  static const IDENTICAL = 15;

  /// from: static public final int NO_DECOMPOSITION
  ///
  /// Decomposition mode value. With NO_DECOMPOSITION set, Strings
  /// will not be decomposed for collation. This is the default
  /// decomposition setting unless otherwise specified by the locale
  /// used to create the Collator.
  ///
  /// <strong>Note</strong> this value is different from the JDK's.
  ///@see \#CANONICAL_DECOMPOSITION
  ///@see \#getDecomposition
  ///@see \#setDecomposition
  static const NO_DECOMPOSITION = 16;

  /// from: static public final int PRIMARY
  ///
  /// Strongest collator strength value. Typically used to denote differences
  /// between base characters. See class documentation for more explanation.
  ///@see \#setStrength
  ///@see \#getStrength
  static const PRIMARY = 0;

  /// from: static public final int QUATERNARY
  ///
  /// <strong>[icu]</strong> Fourth level collator strength value.
  /// When punctuation is ignored
  /// (see <a href="http://userguide.icu-project.org/collation/concepts\#TOC-Ignoring-Punctuation">
  /// Ignoring Punctuation in the User Guide</a>) at PRIMARY to TERTIARY
  /// strength, an additional strength level can
  /// be used to distinguish words with and without punctuation.
  /// See class documentation for more explanation.
  ///@see \#setStrength
  ///@see \#getStrength
  static const QUATERNARY = 3;

  /// from: static public final int SECONDARY
  ///
  /// Second level collator strength value.
  /// Accents in the characters are considered secondary differences.
  /// Other differences between letters can also be considered secondary
  /// differences, depending on the language.
  /// See class documentation for more explanation.
  ///@see \#setStrength
  ///@see \#getStrength
  static const SECONDARY = 1;

  /// from: static public final int TERTIARY
  ///
  /// Third level collator strength value.
  /// Upper and lower case differences in characters are distinguished at this
  /// strength level. In addition, a variant of a letter differs from the base
  /// form on the tertiary level.
  /// See class documentation for more explanation.
  ///@see \#setStrength
  ///@see \#getStrength
  static const TERTIARY = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: protected void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Empty default constructor to make javadocs happy
  Collator()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// Compares the equality of two Collator objects. Collator objects are equal if they have the same
  /// collation (sorting &amp; searching) behavior.
  ///
  /// The base class checks for null and for equal types.
  /// Subclasses should override.
  ///@param obj the Collator to compare to.
  ///@return true if this Collator has exactly the same collation behavior as obj, false otherwise.
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// Generates a hash code for this Collator object.
  ///
  /// The implementation exists just for consistency with \#equals(Object)
  /// implementation in this class and does not generate a useful hash code.
  /// Subclasses should override this implementation.
  ///@return a hash code value.
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_setStrength =
      jniAccessors.getMethodIDOf(_classRef, "setStrength", "(I)V");

  /// from: public void setStrength(int newStrength)
  ///
  /// Sets this Collator's strength attribute. The strength attribute
  /// determines the minimum level of difference considered significant
  /// during comparison.
  ///
  /// The base class method does nothing. Subclasses should override it if appropriate.
  ///
  /// See the Collator class description for an example of use.
  ///@param newStrength the new strength value.
  ///@see \#getStrength
  ///@see \#PRIMARY
  ///@see \#SECONDARY
  ///@see \#TERTIARY
  ///@see \#QUATERNARY
  ///@see \#IDENTICAL
  ///@throws IllegalArgumentException if the new strength value is not valid.
  void setStrength(int newStrength) => jniAccessors.callMethodWithArgs(
      reference, _id_setStrength, jni.JniType.voidType, [newStrength]).check();

  static final _id_setDecomposition =
      jniAccessors.getMethodIDOf(_classRef, "setDecomposition", "(I)V");

  /// from: public void setDecomposition(int decomposition)
  ///
  /// Sets the decomposition mode of this Collator.  Setting this
  /// decomposition attribute with CANONICAL_DECOMPOSITION allows the
  /// Collator to handle un-normalized text properly, producing the
  /// same results as if the text were normalized. If
  /// NO_DECOMPOSITION is set, it is the user's responsibility to
  /// insure that all text is already in the appropriate form before
  /// a comparison or before getting a CollationKey. Adjusting
  /// decomposition mode allows the user to select between faster and
  /// more complete collation behavior.
  ///
  /// Since a great many of the world's languages do not require
  /// text normalization, most locales set NO_DECOMPOSITION as the
  /// default decomposition mode.
  ///
  /// The base class method does nothing. Subclasses should override it if appropriate.
  ///
  /// See getDecomposition for a description of decomposition
  /// mode.
  ///@param decomposition the new decomposition mode
  ///@see \#getDecomposition
  ///@see \#NO_DECOMPOSITION
  ///@see \#CANONICAL_DECOMPOSITION
  ///@throws IllegalArgumentException If the given value is not a valid
  ///            decomposition mode.
  void setDecomposition(int decomposition) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDecomposition,
      jni.JniType.voidType,
      [decomposition]).check();

  static final _id_setReorderCodes =
      jniAccessors.getMethodIDOf(_classRef, "setReorderCodes", "([I)V");

  /// from: public void setReorderCodes(int[] order)
  ///
  /// Sets the reordering codes for this collator.
  /// Collation reordering allows scripts and some other groups of characters
  /// to be moved relative to each other. This reordering is done on top of
  /// the DUCET/CLDR standard collation order. Reordering can specify groups to be placed
  /// at the start and/or the end of the collation order. These groups are specified using
  /// UScript codes and Collator.ReorderCodes entries.
  ///
  /// By default, reordering codes specified for the start of the order are placed in the
  /// order given after several special non-script blocks. These special groups of characters
  /// are space, punctuation, symbol, currency, and digit. These special groups are represented with
  /// Collator.ReorderCodes entries. Script groups can be intermingled with
  /// these special non-script groups if those special groups are explicitly specified in the reordering.
  ///
  /// The special code Collator.ReorderCodes\#OTHERS OTHERS
  /// stands for any script that is not explicitly
  /// mentioned in the list of reordering codes given. Anything that is after OTHERS
  /// will go at the very end of the reordering in the order given.
  ///
  /// The special reorder code Collator.ReorderCodes\#DEFAULT DEFAULT
  /// will reset the reordering for this collator
  /// to the default for this collator. The default reordering may be the DUCET/CLDR order or may be a reordering that
  /// was specified when this collator was created from resource data or from rules. The
  /// DEFAULT code __must__ be the sole code supplied when it is used.
  /// If not, then an IllegalArgumentException will be thrown.
  ///
  /// The special reorder code Collator.ReorderCodes\#NONE NONE
  /// will remove any reordering for this collator.
  /// The result of setting no reordering will be to have the DUCET/CLDR ordering used. The
  /// NONE code __must__ be the sole code supplied when it is used.
  ///@param order the reordering codes to apply to this collator; if this is null or an empty array
  /// then this clears any existing reordering
  ///@see \#getReorderCodes
  ///@see \#getEquivalentReorderCodes
  ///@see Collator.ReorderCodes
  ///@see UScript
  void setReorderCodes(jni.JniObject order) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setReorderCodes,
      jni.JniType.voidType,
      [order.reference]).check();

  static final _id_getInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getInstance", "()Landroid/icu/text/Collator;");

  /// from: static public final android.icu.text.Collator getInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Collator for the current default locale.
  /// The default locale is determined by java.util.Locale.getDefault().
  ///@return the Collator for the default locale (for example, en_US) if it
  ///         is created successfully. Otherwise if there is no Collator
  ///         associated with the current locale, the root collator
  ///         will be returned.
  ///@see java.util.Locale\#getDefault()
  ///@see \#getInstance(Locale)
  static Collator getInstance() =>
      Collator.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getInstance, jni.JniType.objectType, []).object);

  static final _id_clone =
      jniAccessors.getMethodIDOf(_classRef, "clone", "()Ljava/lang/Object;");

  /// from: public java.lang.Object clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Clones the collator.
  ///@return a clone of this collator.
  jni.JniObject clone() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_getInstance1 = jniAccessors.getStaticMethodIDOf(_classRef,
      "getInstance", "(Landroid/icu/util/ULocale;)Landroid/icu/text/Collator;");

  /// from: static public final android.icu.text.Collator getInstance(android.icu.util.ULocale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the Collator for the desired locale.
  ///
  /// For some languages, multiple collation types are available;
  /// for example, "de@collation=phonebook".
  /// Starting with ICU 54, collation attributes can be specified via locale keywords as well,
  /// in the old locale extension syntax ("el@colCaseFirst=upper")
  /// or in language tag syntax ("el-u-kf-upper").
  /// See <a href="http://userguide.icu-project.org/collation/api">User Guide: Collation API</a>.
  ///@param locale the desired locale.
  ///@return Collator for the desired locale if it is created successfully.
  ///         Otherwise if there is no Collator
  ///         associated with the current locale, the root collator will
  ///         be returned.
  ///@see java.util.Locale
  ///@see java.util.ResourceBundle
  ///@see \#getInstance(Locale)
  ///@see \#getInstance()
  static Collator getInstance1(ulocale_.ULocale locale) =>
      Collator.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getInstance1, jni.JniType.objectType, [locale.reference]).object);

  static final _id_getInstance2 = jniAccessors.getStaticMethodIDOf(_classRef,
      "getInstance", "(Ljava/util/Locale;)Landroid/icu/text/Collator;");

  /// from: static public final android.icu.text.Collator getInstance(java.util.Locale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Collator for the desired locale.
  ///
  /// For some languages, multiple collation types are available;
  /// for example, "de-u-co-phonebk".
  /// Starting with ICU 54, collation attributes can be specified via locale keywords as well,
  /// in the old locale extension syntax ("el@colCaseFirst=upper", only with ULocale)
  /// or in language tag syntax ("el-u-kf-upper").
  /// See <a href="http://userguide.icu-project.org/collation/api">User Guide: Collation API</a>.
  ///@param locale the desired locale.
  ///@return Collator for the desired locale if it is created successfully.
  ///         Otherwise if there is no Collator
  ///         associated with the current locale, the root collator will
  ///         be returned.
  ///@see java.util.Locale
  ///@see java.util.ResourceBundle
  ///@see \#getInstance(ULocale)
  ///@see \#getInstance()
  static Collator getInstance2(jni.JniObject locale) =>
      Collator.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getInstance2, jni.JniType.objectType, [locale.reference]).object);

  static final _id_getAvailableLocales = jniAccessors.getStaticMethodIDOf(
      _classRef, "getAvailableLocales", "()[Ljava/util/Locale;");

  /// from: static public java.util.Locale[] getAvailableLocales()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the set of locales, as Locale objects, for which collators
  /// are installed.  Note that Locale objects do not support RFC 3066.
  ///@return the list of locales in which collators are installed.
  /// This list includes any that have been registered, in addition to
  /// those that are installed with ICU4J.
  static jni.JniObject getAvailableLocales() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getAvailableLocales, jni.JniType.objectType, []).object);

  static final _id_getAvailableULocales = jniAccessors.getStaticMethodIDOf(
      _classRef, "getAvailableULocales", "()[Landroid/icu/util/ULocale;");

  /// from: static public final android.icu.util.ULocale[] getAvailableULocales()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the set of locales, as ULocale objects, for which collators
  /// are installed.  ULocale objects support RFC 3066.
  ///@return the list of locales in which collators are installed.
  /// This list includes any that have been registered, in addition to
  /// those that are installed with ICU4J.
  static jni.JniObject getAvailableULocales() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getAvailableULocales, jni.JniType.objectType, []).object);

  static final _id_getKeywords = jniAccessors.getStaticMethodIDOf(
      _classRef, "getKeywords", "()[Ljava/lang/String;");

  /// from: static public final java.lang.String[] getKeywords()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns an array of all possible keywords that are relevant to
  /// collation. At this point, the only recognized keyword for this
  /// service is "collation".
  ///@return an array of valid collation keywords.
  ///@see \#getKeywordValues
  static jni.JniObject getKeywords() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getKeywords, jni.JniType.objectType, []).object);

  static final _id_getKeywordValues = jniAccessors.getStaticMethodIDOf(
      _classRef, "getKeywordValues", "(Ljava/lang/String;)[Ljava/lang/String;");

  /// from: static public final java.lang.String[] getKeywordValues(java.lang.String keyword)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Given a keyword, returns an array of all values for
  /// that keyword that are currently in use.
  ///@param keyword one of the keywords returned by getKeywords.
  ///@see \#getKeywords
  static jni.JniObject getKeywordValues(jni.JniString keyword) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getKeywordValues,
          jni.JniType.objectType,
          [keyword.reference]).object);

  static final _id_getKeywordValuesForLocale = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getKeywordValuesForLocale",
      "(Ljava/lang/String;Landroid/icu/util/ULocale;Z)[Ljava/lang/String;");

  /// from: static public final java.lang.String[] getKeywordValuesForLocale(java.lang.String key, android.icu.util.ULocale locale, boolean commonlyUsed)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Given a key and a locale, returns an array of string values in a preferred
  /// order that would make a difference. These are all and only those values where
  /// the open (creation) of the service with the locale formed from the input locale
  /// plus input keyword and that value has different behavior than creation with the
  /// input locale alone.
  ///@param key one of the keys supported by this service.  For now, only
  ///                      "collation" is supported.
  ///@param locale the locale
  ///@param commonlyUsed if set to true it will return only commonly used values
  ///                      with the given locale in preferred order.  Otherwise,
  ///                      it will return all the available values for the locale.
  ///@return an array of string values for the given key and the locale.
  static jni.JniObject getKeywordValuesForLocale(
          jni.JniString key, ulocale_.ULocale locale, bool commonlyUsed) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getKeywordValuesForLocale,
          jni.JniType.objectType,
          [key.reference, locale.reference, commonlyUsed]).object);

  static final _id_getFunctionalEquivalent = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getFunctionalEquivalent",
      "(Ljava/lang/String;Landroid/icu/util/ULocale;[Z)Landroid/icu/util/ULocale;");

  /// from: static public final android.icu.util.ULocale getFunctionalEquivalent(java.lang.String keyword, android.icu.util.ULocale locID, boolean[] isAvailable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the functionally equivalent locale for the given
  /// requested locale, with respect to given keyword, for the
  /// collation service.  If two locales return the same result, then
  /// collators instantiated for these locales will behave
  /// equivalently.  The converse is not always true; two collators
  /// may in fact be equivalent, but return different results, due to
  /// internal details.  The return result has no other meaning than
  /// that stated above, and implies nothing as to the relationship
  /// between the two locales.  This is intended for use by
  /// applications who wish to cache collators, or otherwise reuse
  /// collators when possible.  The functional equivalent may change
  /// over time.  For more information, please see the <a href="http://userguide.icu-project.org/locale\#TOC-Locales-and-Services">
  /// Locales and Services</a> section of the ICU User Guide.
  ///@param keyword a particular keyword as enumerated by
  /// getKeywords.
  ///@param locID The requested locale
  ///@param isAvailable If non-null, isAvailable[0] will receive and
  /// output boolean that indicates whether the requested locale was
  /// 'available' to the collation service. If non-null, isAvailable
  /// must have length &gt;= 1.
  ///@return the locale
  static ulocale_.ULocale getFunctionalEquivalent(jni.JniString keyword,
          ulocale_.ULocale locID, jni.JniObject isAvailable) =>
      ulocale_.ULocale.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getFunctionalEquivalent,
          jni.JniType.objectType,
          [keyword.reference, locID.reference, isAvailable.reference]).object);

  static final _id_getFunctionalEquivalent1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getFunctionalEquivalent",
      "(Ljava/lang/String;Landroid/icu/util/ULocale;)Landroid/icu/util/ULocale;");

  /// from: static public final android.icu.util.ULocale getFunctionalEquivalent(java.lang.String keyword, android.icu.util.ULocale locID)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the functionally equivalent locale for the given
  /// requested locale, with respect to given keyword, for the
  /// collation service.
  ///@param keyword a particular keyword as enumerated by
  /// getKeywords.
  ///@param locID The requested locale
  ///@return the locale
  ///@see \#getFunctionalEquivalent(String,ULocale,boolean[])
  static ulocale_.ULocale getFunctionalEquivalent1(
          jni.JniString keyword, ulocale_.ULocale locID) =>
      ulocale_.ULocale.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getFunctionalEquivalent1,
          jni.JniType.objectType,
          [keyword.reference, locID.reference]).object);

  static final _id_getDisplayName = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getDisplayName",
      "(Ljava/util/Locale;Ljava/util/Locale;)Ljava/lang/String;");

  /// from: static public java.lang.String getDisplayName(java.util.Locale objectLocale, java.util.Locale displayLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the name of the collator for the objectLocale, localized for the
  /// displayLocale.
  ///@param objectLocale the locale of the collator
  ///@param displayLocale the locale for the collator's display name
  ///@return the display name
  static jni.JniString getDisplayName(
          jni.JniObject objectLocale, jni.JniObject displayLocale) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getDisplayName,
          jni.JniType.objectType,
          [objectLocale.reference, displayLocale.reference]).object);

  static final _id_getDisplayName1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getDisplayName",
      "(Landroid/icu/util/ULocale;Landroid/icu/util/ULocale;)Ljava/lang/String;");

  /// from: static public java.lang.String getDisplayName(android.icu.util.ULocale objectLocale, android.icu.util.ULocale displayLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the name of the collator for the objectLocale, localized for the
  /// displayLocale.
  ///@param objectLocale the locale of the collator
  ///@param displayLocale the locale for the collator's display name
  ///@return the display name
  static jni.JniString getDisplayName1(
          ulocale_.ULocale objectLocale, ulocale_.ULocale displayLocale) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getDisplayName1,
          jni.JniType.objectType,
          [objectLocale.reference, displayLocale.reference]).object);

  static final _id_getDisplayName2 = jniAccessors.getStaticMethodIDOf(
      _classRef, "getDisplayName", "(Ljava/util/Locale;)Ljava/lang/String;");

  /// from: static public java.lang.String getDisplayName(java.util.Locale objectLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the name of the collator for the objectLocale, localized for the
  /// default <code>DISPLAY</code> locale.
  ///@param objectLocale the locale of the collator
  ///@return the display name
  ///@see android.icu.util.ULocale.Category\#DISPLAY
  static jni.JniString getDisplayName2(jni.JniObject objectLocale) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getDisplayName2,
          jni.JniType.objectType,
          [objectLocale.reference]).object);

  static final _id_getDisplayName3 = jniAccessors.getStaticMethodIDOf(_classRef,
      "getDisplayName", "(Landroid/icu/util/ULocale;)Ljava/lang/String;");

  /// from: static public java.lang.String getDisplayName(android.icu.util.ULocale objectLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the name of the collator for the objectLocale, localized for the
  /// default <code>DISPLAY</code> locale.
  ///@param objectLocale the locale of the collator
  ///@return the display name
  ///@see android.icu.util.ULocale.Category\#DISPLAY
  static jni.JniString getDisplayName3(ulocale_.ULocale objectLocale) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getDisplayName3,
          jni.JniType.objectType,
          [objectLocale.reference]).object);

  static final _id_getStrength =
      jniAccessors.getMethodIDOf(_classRef, "getStrength", "()I");

  /// from: public int getStrength()
  ///
  /// Returns this Collator's strength attribute. The strength attribute
  /// determines the minimum level of difference considered significant.
  /// <strong>[icu] Note:</strong> This can return QUATERNARY strength, which is not supported by the
  /// JDK version.
  ///
  /// See the Collator class description for more details.
  /// The base class method always returns \#TERTIARY.
  /// Subclasses should override it if appropriate.
  ///@return this Collator's current strength attribute.
  ///@see \#setStrength
  ///@see \#PRIMARY
  ///@see \#SECONDARY
  ///@see \#TERTIARY
  ///@see \#QUATERNARY
  ///@see \#IDENTICAL
  int getStrength() => jniAccessors.callMethodWithArgs(
      reference, _id_getStrength, jni.JniType.intType, []).integer;

  static final _id_getDecomposition =
      jniAccessors.getMethodIDOf(_classRef, "getDecomposition", "()I");

  /// from: public int getDecomposition()
  ///
  /// Returns the decomposition mode of this Collator. The decomposition mode
  /// determines how Unicode composed characters are handled.
  ///
  /// See the Collator class description for more details.
  /// The base class method always returns \#NO_DECOMPOSITION.
  /// Subclasses should override it if appropriate.
  ///@return the decomposition mode
  ///@see \#setDecomposition
  ///@see \#NO_DECOMPOSITION
  ///@see \#CANONICAL_DECOMPOSITION
  int getDecomposition() => jniAccessors.callMethodWithArgs(
      reference, _id_getDecomposition, jni.JniType.intType, []).integer;

  static final _id_equals2 = jniAccessors.getMethodIDOf(
      _classRef, "equals", "(Ljava/lang/String;Ljava/lang/String;)Z");

  /// from: public boolean equals(java.lang.String source, java.lang.String target)
  ///
  /// Compares the equality of two text Strings using
  /// this Collator's rules, strength and decomposition mode.  Convenience method.
  ///@param source the source string to be compared.
  ///@param target the target string to be compared.
  ///@return true if the strings are equal according to the collation
  ///         rules, otherwise false.
  ///@see \#compare
  ///@throws NullPointerException thrown if either arguments is null.
  bool equals2(jni.JniString source, jni.JniString target) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_equals2,
          jni.JniType.booleanType,
          [source.reference, target.reference]).boolean;

  static final _id_getTailoredSet = jniAccessors.getMethodIDOf(
      _classRef, "getTailoredSet", "()Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet getTailoredSet()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns a UnicodeSet that contains all the characters and sequences tailored
  /// in this collator.
  ///@return a pointer to a UnicodeSet object containing all the
  ///         code points and sequences that may sort differently than
  ///         in the root collator.
  unicodeset_.UnicodeSet getTailoredSet() =>
      unicodeset_.UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTailoredSet, jni.JniType.objectType, []).object);

  static final _id_compare = jniAccessors.getMethodIDOf(
      _classRef, "compare", "(Ljava/lang/String;Ljava/lang/String;)I");

  /// from: public abstract int compare(java.lang.String source, java.lang.String target)
  ///
  /// Compares the source text String to the target text String according to
  /// this Collator's rules, strength and decomposition mode.
  /// Returns an integer less than,
  /// equal to or greater than zero depending on whether the source String is
  /// less than, equal to or greater than the target String. See the Collator
  /// class description for an example of use.
  ///@param source the source String.
  ///@param target the target String.
  ///@return Returns an integer value. Value is less than zero if source is
  ///         less than target, value is zero if source and target are equal,
  ///         value is greater than zero if source is greater than target.
  ///@see CollationKey
  ///@see \#getCollationKey
  ///@throws NullPointerException thrown if either argument is null.
  int compare(jni.JniString source, jni.JniString target) =>
      jniAccessors.callMethodWithArgs(reference, _id_compare,
          jni.JniType.intType, [source.reference, target.reference]).integer;

  static final _id_compare1 = jniAccessors.getMethodIDOf(
      _classRef, "compare", "(Ljava/lang/Object;Ljava/lang/Object;)I");

  /// from: public int compare(java.lang.Object source, java.lang.Object target)
  ///
  /// Compares the source Object to the target Object.
  ///@param source the source Object.
  ///@param target the target Object.
  ///@return Returns an integer value. Value is less than zero if source is
  ///         less than target, value is zero if source and target are equal,
  ///         value is greater than zero if source is greater than target.
  ///@throws ClassCastException thrown if either arguments cannot be cast to CharSequence.
  int compare1(jni.JniObject source, jni.JniObject target) =>
      jniAccessors.callMethodWithArgs(reference, _id_compare1,
          jni.JniType.intType, [source.reference, target.reference]).integer;

  static final _id_getCollationKey = jniAccessors.getMethodIDOf(_classRef,
      "getCollationKey", "(Ljava/lang/String;)Landroid/icu/text/CollationKey;");

  /// from: public abstract android.icu.text.CollationKey getCollationKey(java.lang.String source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  /// Transforms the String into a CollationKey suitable for efficient
  /// repeated comparison.  The resulting key depends on the collator's
  /// rules, strength and decomposition mode.
  ///
  /// Note that collation keys are often less efficient than simply doing comparison.
  /// For more details, see the ICU User Guide.
  ///
  /// See the CollationKey class documentation for more information.
  ///@param source the string to be transformed into a CollationKey.
  ///@return the CollationKey for the given String based on this Collator's
  ///         collation rules. If the source String is null, a null
  ///         CollationKey is returned.
  ///@see CollationKey
  ///@see \#compare(String, String)
  collationkey_.CollationKey getCollationKey(jni.JniString source) =>
      collationkey_.CollationKey.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCollationKey,
          jni.JniType.objectType,
          [source.reference]).object);

  static final _id_setMaxVariable = jniAccessors.getMethodIDOf(
      _classRef, "setMaxVariable", "(I)Landroid/icu/text/Collator;");

  /// from: public android.icu.text.Collator setMaxVariable(int group)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Sets the variable top to the top of the specified reordering group.
  /// The variable top determines the highest-sorting character
  /// which is affected by the alternate handling behavior.
  /// If that attribute is set to UCOL_NON_IGNORABLE, then the variable top has no effect.
  ///
  /// The base class implementation throws an UnsupportedOperationException.
  ///@param group one of Collator.ReorderCodes.SPACE, Collator.ReorderCodes.PUNCTUATION,
  ///              Collator.ReorderCodes.SYMBOL, Collator.ReorderCodes.CURRENCY;
  ///              or Collator.ReorderCodes.DEFAULT to restore the default max variable group
  ///@return this
  ///@see \#getMaxVariable
  Collator setMaxVariable(int group) =>
      Collator.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setMaxVariable, jni.JniType.objectType, [group]).object);

  static final _id_getMaxVariable =
      jniAccessors.getMethodIDOf(_classRef, "getMaxVariable", "()I");

  /// from: public int getMaxVariable()
  ///
  /// <strong>[icu]</strong> Returns the maximum reordering group whose characters are affected by
  /// the alternate handling behavior.
  ///
  /// The base class implementation returns Collator.ReorderCodes.PUNCTUATION.
  ///@return the maximum variable reordering group.
  ///@see \#setMaxVariable
  int getMaxVariable() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxVariable, jni.JniType.intType, []).integer;

  static final _id_getVariableTop =
      jniAccessors.getMethodIDOf(_classRef, "getVariableTop", "()I");

  /// from: public abstract int getVariableTop()
  ///
  /// <strong>[icu]</strong> Gets the variable top value of a Collator.
  ///@return the variable top primary weight
  ///@see \#getMaxVariable
  int getVariableTop() => jniAccessors.callMethodWithArgs(
      reference, _id_getVariableTop, jni.JniType.intType, []).integer;

  static final _id_getVersion = jniAccessors.getMethodIDOf(
      _classRef, "getVersion", "()Landroid/icu/util/VersionInfo;");

  /// from: public abstract android.icu.util.VersionInfo getVersion()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the version of this collator object.
  ///@return the version object associated with this collator
  versioninfo_.VersionInfo getVersion() =>
      versioninfo_.VersionInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getVersion, jni.JniType.objectType, []).object);

  static final _id_getUCAVersion = jniAccessors.getMethodIDOf(
      _classRef, "getUCAVersion", "()Landroid/icu/util/VersionInfo;");

  /// from: public abstract android.icu.util.VersionInfo getUCAVersion()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the UCA version of this collator object.
  ///@return the version object associated with this collator
  versioninfo_.VersionInfo getUCAVersion() =>
      versioninfo_.VersionInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getUCAVersion, jni.JniType.objectType, []).object);

  static final _id_getReorderCodes =
      jniAccessors.getMethodIDOf(_classRef, "getReorderCodes", "()[I");

  /// from: public int[] getReorderCodes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the reordering codes for this collator.
  /// These reordering codes are a combination of UScript codes and ReorderCodes.
  ///@return a copy of the reordering codes for this collator;
  /// if none are set then returns an empty array
  ///@see \#setReorderCodes
  ///@see \#getEquivalentReorderCodes
  ///@see Collator.ReorderCodes
  ///@see UScript
  jni.JniObject getReorderCodes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getReorderCodes, jni.JniType.objectType, []).object);

  static final _id_getEquivalentReorderCodes = jniAccessors.getStaticMethodIDOf(
      _classRef, "getEquivalentReorderCodes", "(I)[I");

  /// from: static public int[] getEquivalentReorderCodes(int reorderCode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves all the reorder codes that are grouped with the given reorder code. Some reorder
  /// codes are grouped and must reorder together.
  /// Beginning with ICU 55, scripts only reorder together if they are primary-equal,
  /// for example Hiragana and Katakana.
  ///@param reorderCode The reorder code to determine equivalence for.
  ///@return the set of all reorder codes in the same group as the given reorder code.
  ///@see \#setReorderCodes
  ///@see \#getReorderCodes
  ///@see Collator.ReorderCodes
  ///@see UScript
  static jni.JniObject getEquivalentReorderCodes(int reorderCode) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getEquivalentReorderCodes,
          jni.JniType.objectType,
          [reorderCode]).object);

  static final _id_isFrozen =
      jniAccessors.getMethodIDOf(_classRef, "isFrozen", "()Z");

  /// from: public boolean isFrozen()
  ///
  /// Determines whether the object has been frozen or not.
  ///
  /// An unfrozen Collator is mutable and not thread-safe.
  /// A frozen Collator is immutable and thread-safe.
  bool isFrozen() => jniAccessors.callMethodWithArgs(
      reference, _id_isFrozen, jni.JniType.booleanType, []).boolean;

  static final _id_freeze = jniAccessors.getMethodIDOf(
      _classRef, "freeze", "()Landroid/icu/text/Collator;");

  /// from: public android.icu.text.Collator freeze()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Freezes the collator.
  ///@return the collator itself.
  Collator freeze() => Collator.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_freeze, jni.JniType.objectType, []).object);

  static final _id_cloneAsThawed = jniAccessors.getMethodIDOf(
      _classRef, "cloneAsThawed", "()Landroid/icu/text/Collator;");

  /// from: public android.icu.text.Collator cloneAsThawed()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provides for the clone operation. Any clone is initially unfrozen.
  Collator cloneAsThawed() => Collator.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_cloneAsThawed, jni.JniType.objectType, []).object);
}

/// from: android.icu.text.Collator$ReorderCodes
///
/// Reordering codes for non-script groups that can be reordered under collation.
///@see \#getReorderCodes
///@see \#setReorderCodes
///@see \#getEquivalentReorderCodes
class Collator_ReorderCodes extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/Collator\$ReorderCodes");
  Collator_ReorderCodes.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CURRENCY
  ///
  /// Characters with the currency property.
  /// This is equivalent to the rule value "currency".
  static const CURRENCY = 4099;

  /// from: static public final int DEFAULT
  ///
  /// A special reordering code that is used to specify the default reordering codes for a locale.
  static const DEFAULT = -1;

  /// from: static public final int DIGIT
  ///
  /// Characters with the digit property.
  /// This is equivalent to the rule value "digit".
  static const DIGIT = 4100;

  /// from: static public final int FIRST
  ///
  /// The first entry in the enumeration of reordering groups. This is intended for use in
  /// range checking and enumeration of the reorder codes.
  static const FIRST = 4096;

  /// from: static public final int NONE
  ///
  /// A special reordering code that is used to specify no reordering codes.
  static const NONE = 103;

  /// from: static public final int OTHERS
  ///
  /// A special reordering code that is used to specify all other codes used for reordering except
  /// for the codes listed as ReorderingCodes and those listed explicitly in a reordering.
  static const OTHERS = 103;

  /// from: static public final int PUNCTUATION
  ///
  /// Characters with the punctuation property.
  /// This is equivalent to the rule value "punct".
  static const PUNCTUATION = 4097;

  /// from: static public final int SPACE
  ///
  /// Characters with the space property.
  /// This is equivalent to the rule value "space".
  static const SPACE = 4096;

  /// from: static public final int SYMBOL
  ///
  /// Characters with the symbol property.
  /// This is equivalent to the rule value "symbol".
  static const SYMBOL = 4098;
}
