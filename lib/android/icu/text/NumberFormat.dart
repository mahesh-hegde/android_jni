// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "UFormat.dart" as uformat_;

import "../math/BigDecimal.dart" as bigdecimal_;

import "../util/CurrencyAmount.dart" as currencyamount_;

import "DisplayContext.dart" as displaycontext_;

import "../util/ULocale.dart" as ulocale_;

import "../util/Currency.dart" as currency_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.text.NumberFormat
///
/// <strong>[icu enhancement]</strong> ICU's replacement for java.text.NumberFormat.&nbsp;Methods, fields, and other functionality specific to ICU are labeled '<strong>[icu]</strong>'.
///
/// <code>NumberFormat</code> is the abstract base class for all number
/// formats. This class provides the interface for formatting and parsing
/// numbers. <code>NumberFormat</code> also provides methods for determining
/// which locales have number formats, and what their names are.
///
/// <code>NumberFormat</code> helps you to format and parse numbers for any locale.
/// Your code can be completely independent of the locale conventions for
/// decimal points, thousands-separators, or even the particular decimal
/// digits used, or whether the number format is even decimal.
///
///
/// To format a number for the current Locale, use one of the factory
/// class methods:
/// <blockquote>
/// <pre>
///  myString = NumberFormat.getInstance().format(myNumber);
/// </pre>
/// </blockquote>
/// If you are formatting multiple numbers, it is
/// more efficient to get the format and use it multiple times so that
/// the system doesn't have to fetch the information about the local
/// language and country conventions multiple times.
/// <blockquote>
/// <pre>
/// NumberFormat nf = NumberFormat.getInstance();
/// for (int i = 0; i &lt; a.length; ++i) {
///     output.println(nf.format(myNumber[i]) + "; ");
/// }
/// </pre>
/// </blockquote>
/// To format a number for a different Locale, specify it in the
/// call to <code>getInstance</code>.
/// <blockquote>
/// <pre>
/// NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);
/// </pre>
/// </blockquote>
/// You can also use a <code>NumberFormat</code> to parse numbers:
/// <blockquote>
/// <pre>
/// myNumber = nf.parse(myString);
/// </pre>
/// </blockquote>
/// Use <code>getInstance</code> or <code>getNumberInstance</code> to get the
/// normal number format. Use <code>getIntegerInstance</code> to get an
/// integer number format. Use <code>getCurrencyInstance</code> to get the
/// currency number format. And use <code>getPercentInstance</code> to get a
/// format for displaying percentages. Some factory methods are found within
/// subclasses of NumberFormat. With this format, a fraction like
/// 0.53 is displayed as 53%.
///
///
/// Starting from ICU 4.2, you can use getInstance() by passing in a 'style'
/// as parameter to get the correct instance.
/// For example,
/// use getInstance(...NUMBERSTYLE) to get the normal number format,
/// getInstance(...PERCENTSTYLE) to get a format for displaying percentage,
/// getInstance(...SCIENTIFICSTYLE) to get a format for displaying scientific number,
/// getInstance(...INTEGERSTYLE) to get an integer number format,
/// getInstance(...CURRENCYSTYLE) to get the currency number format,
/// in which the currency is represented by its symbol, for example, "$3.00".
/// getInstance(...ISOCURRENCYSTYLE)  to get the currency number format,
/// in which the currency is represented by its ISO code, for example "USD3.00".
/// getInstance(...PLURALCURRENCYSTYLE) to get the currency number format,
/// in which the currency is represented by its full name in plural format,
/// for example, "3.00 US dollars" or "1.00 US dollar".
///
///
///
/// You can also control the display of numbers with such methods as
/// <code>setMinimumFractionDigits</code>.
/// If you want even more control over the format or parsing,
/// or want to give your users more control,
/// you can try casting the <code>NumberFormat</code> you get from the factory methods
/// to a <code>DecimalFormat</code>. This will work for the vast majority
/// of locales; just remember to put it in a <code>try</code> block in case you
/// encounter an unusual one.
///
///
/// NumberFormat is designed such that some controls
/// work for formatting and others work for parsing.  The following is
/// the detailed description for each these control methods,
///
/// setParseIntegerOnly : only affects parsing, e.g.
/// if true,  "3456.78" -&gt; 3456 (and leaves the parse position just after '6')
/// if false, "3456.78" -&gt; 3456.78 (and leaves the parse position just after '8')
/// This is independent of formatting.  If you want to not show a decimal point
/// where there might be no digits after the decimal point, use
/// setDecimalSeparatorAlwaysShown on DecimalFormat.
///
/// You can also use forms of the <code>parse</code> and <code>format</code>
/// methods with <code>ParsePosition</code> and <code>FieldPosition</code> to
/// allow you to:
/// <ul>
/// <li> progressively parse through pieces of a string
/// <li> align the decimal point and other areas
/// </ul>
/// For example, you can align numbers in two ways:
/// <ol>
/// <li> If you are using a monospaced font with spacing for alignment,
///      you can pass the <code>FieldPosition</code> in your format call, with
///      <code>field</code> = <code>INTEGER_FIELD</code>. On output,
///      <code>getEndIndex</code> will be set to the offset between the
///      last character of the integer and the decimal. Add
///      (desiredSpaceCount - getEndIndex) spaces at the front of the string.
///
/// <li> If you are using proportional fonts,
///      instead of padding with spaces, measure the width
///      of the string in pixels from the start to <code>getEndIndex</code>.
///      Then move the pen by
///      (desiredPixelWidth - widthToAlignmentPoint) before drawing the text.
///      It also works where there is no decimal, but possibly additional
///      characters at the end, e.g., with parentheses in negative
///      numbers: "(12)" for -12.
/// </ol>
///
/// <h3>Synchronization</h3>
///
/// Number formats are generally not synchronized. It is recommended to create
/// separate format instances for each thread. If multiple threads access a format
/// concurrently, it must be synchronized externally.
///
/// <h4>DecimalFormat</h4>
/// DecimalFormat is the concrete implementation of NumberFormat, and the
/// NumberFormat API is essentially an abstraction from DecimalFormat's API.
/// Refer to DecimalFormat for more information about this API.
///
///
/// see          DecimalFormat
/// see          java.text.ChoiceFormat
///@author Mark Davis
///@author Helena Shih
///@author Alan Liu
class NumberFormat extends uformat_.UFormat {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/NumberFormat");
  NumberFormat.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ACCOUNTINGCURRENCYSTYLE
  ///
  /// <strong>[icu]</strong> Constant to specify currency style of format which uses currency symbol
  /// to represent currency for accounting, for example: "($3.00), instead of
  /// "-$3.00" (\#CURRENCYSTYLE).
  /// Overrides any style specified using -cf- key in locale.
  static const ACCOUNTINGCURRENCYSTYLE = 7;

  /// from: static public final int CASHCURRENCYSTYLE
  ///
  /// <strong>[icu]</strong> Constant to specify currency cash style of format which uses currency
  /// ISO code to represent currency, for example: "NT$3" instead of "NT$3.23".
  static const CASHCURRENCYSTYLE = 8;

  /// from: static public final int CURRENCYSTYLE
  ///
  /// <strong>[icu]</strong> Constant to specify general currency style of format. Defaults to
  /// STANDARDCURRENCYSTYLE, using currency symbol, for example "$3.00", with
  /// non-accounting style for negative values (e.g. minus sign).
  /// The specific style may be specified using the -cf- locale key.
  static const CURRENCYSTYLE = 1;

  /// from: static public final int FRACTION_FIELD
  ///
  /// Field constant used to construct a FieldPosition object. Signifies that
  /// the position of the fraction part of a formatted number should be returned.
  ///@see java.text.FieldPosition
  static const FRACTION_FIELD = 1;

  /// from: static public final int INTEGERSTYLE
  ///
  /// <strong>[icu]</strong> Constant to specify a integer number style format.
  static const INTEGERSTYLE = 4;

  /// from: static public final int INTEGER_FIELD
  ///
  /// Field constant used to construct a FieldPosition object. Signifies that
  /// the position of the integer part of a formatted number should be returned.
  ///@see java.text.FieldPosition
  static const INTEGER_FIELD = 0;

  /// from: static public final int ISOCURRENCYSTYLE
  ///
  /// <strong>[icu]</strong> Constant to specify currency style of format which uses currency
  /// ISO code to represent currency, for example: "USD3.00".
  static const ISOCURRENCYSTYLE = 5;

  /// from: static public final int NUMBERSTYLE
  ///
  /// <strong>[icu]</strong> Constant to specify normal number style of format.
  static const NUMBERSTYLE = 0;

  /// from: static public final int PERCENTSTYLE
  ///
  /// <strong>[icu]</strong> Constant to specify a style of format to display percent.
  static const PERCENTSTYLE = 2;

  /// from: static public final int PLURALCURRENCYSTYLE
  ///
  /// <strong>[icu]</strong> Constant to specify currency style of format which uses currency
  /// long name with plural format to represent currency, for example,
  /// "3.00 US Dollars".
  static const PLURALCURRENCYSTYLE = 6;

  /// from: static public final int SCIENTIFICSTYLE
  ///
  /// <strong>[icu]</strong> Constant to specify a style of format to display scientific number.
  static const SCIENTIFICSTYLE = 3;

  /// from: static public final int STANDARDCURRENCYSTYLE
  ///
  /// <strong>[icu]</strong> Constant to specify currency style of format which uses currency symbol
  /// to represent currency, for example "$3.00", using non-accounting style for
  /// negative values (e.g. minus sign).
  /// Overrides any style specified using -cf- key in locale.
  static const STANDARDCURRENCYSTYLE = 9;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Empty constructor.  Public for API compatibility with historic versions of
  /// java.text.NumberFormat which had public constructor even though this is
  /// an abstract class.
  NumberFormat()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_format = jniAccessors.getMethodIDOf(_classRef, "format",
      "(Ljava/lang/Object;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;");

  /// from: public java.lang.StringBuffer format(java.lang.Object number, java.lang.StringBuffer toAppendTo, java.text.FieldPosition pos)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formats a number and appends the resulting text to the given string buffer.
  /// <strong>[icu] Note:</strong> recognizes <code>BigInteger</code>
  /// and <code>BigDecimal</code> objects.
  ///@see java.text.Format\#format(Object, StringBuffer, FieldPosition)
  jni.JniObject format(
          jni.JniObject number, jni.JniObject toAppendTo, jni.JniObject pos) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_format,
          jni.JniType.objectType,
          [number.reference, toAppendTo.reference, pos.reference]).object);

  static final _id_parseObject = jniAccessors.getMethodIDOf(
      _classRef,
      "parseObject",
      "(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/lang/Object;");

  /// from: public final java.lang.Object parseObject(java.lang.String source, java.text.ParsePosition parsePosition)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses text from a string to produce a number.
  ///@param source the String to parse
  ///@param parsePosition the position at which to start the parse
  ///@return the parsed number, or null
  ///@see java.text.NumberFormat\#parseObject(String, ParsePosition)
  jni.JniObject parseObject(
          jni.JniString source, jni.JniObject parsePosition) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_parseObject,
          jni.JniType.objectType,
          [source.reference, parsePosition.reference]).object);

  static final _id_format1 =
      jniAccessors.getMethodIDOf(_classRef, "format", "(D)Ljava/lang/String;");

  /// from: public final java.lang.String format(double number)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specialization of format.
  ///@see java.text.Format\#format(Object)
  jni.JniString format1(double number) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_format1, jni.JniType.objectType, [number]).object);

  static final _id_format2 =
      jniAccessors.getMethodIDOf(_classRef, "format", "(J)Ljava/lang/String;");

  /// from: public final java.lang.String format(long number)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specialization of format.
  ///@see java.text.Format\#format(Object)
  jni.JniString format2(int number) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_format2, jni.JniType.objectType, [number]).object);

  static final _id_format3 = jniAccessors.getMethodIDOf(
      _classRef, "format", "(Ljava/math/BigInteger;)Ljava/lang/String;");

  /// from: public final java.lang.String format(java.math.BigInteger number)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Convenience method to format a BigInteger.
  jni.JniString format3(jni.JniObject number) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_format3, jni.JniType.objectType, [number.reference]).object);

  static final _id_format4 = jniAccessors.getMethodIDOf(
      _classRef, "format", "(Ljava/math/BigDecimal;)Ljava/lang/String;");

  /// from: public final java.lang.String format(java.math.BigDecimal number)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience method to format a BigDecimal.
  jni.JniString format4(jni.JniObject number) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_format4, jni.JniType.objectType, [number.reference]).object);

  static final _id_format5 = jniAccessors.getMethodIDOf(
      _classRef, "format", "(Landroid/icu/math/BigDecimal;)Ljava/lang/String;");

  /// from: public final java.lang.String format(android.icu.math.BigDecimal number)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Convenience method to format an ICU BigDecimal.
  jni.JniString format5(bigdecimal_.BigDecimal number) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_format5, jni.JniType.objectType, [number.reference]).object);

  static final _id_format6 = jniAccessors.getMethodIDOf(_classRef, "format",
      "(Landroid/icu/util/CurrencyAmount;)Ljava/lang/String;");

  /// from: public final java.lang.String format(android.icu.util.CurrencyAmount currAmt)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Convenience method to format a CurrencyAmount.
  jni.JniString format6(currencyamount_.CurrencyAmount currAmt) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_format6, jni.JniType.objectType, [currAmt.reference]).object);

  static final _id_format7 = jniAccessors.getMethodIDOf(_classRef, "format",
      "(DLjava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;");

  /// from: public abstract java.lang.StringBuffer format(double number, java.lang.StringBuffer toAppendTo, java.text.FieldPosition pos)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specialization of format.
  ///@see java.text.Format\#format(Object, StringBuffer, FieldPosition)
  jni.JniObject format7(
          double number, jni.JniObject toAppendTo, jni.JniObject pos) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_format7,
          jni.JniType.objectType,
          [number, toAppendTo.reference, pos.reference]).object);

  static final _id_format8 = jniAccessors.getMethodIDOf(_classRef, "format",
      "(JLjava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;");

  /// from: public abstract java.lang.StringBuffer format(long number, java.lang.StringBuffer toAppendTo, java.text.FieldPosition pos)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specialization of format.
  ///@see java.text.Format\#format(Object, StringBuffer, FieldPosition)
  jni.JniObject format8(
          int number, jni.JniObject toAppendTo, jni.JniObject pos) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_format8,
          jni.JniType.objectType,
          [number, toAppendTo.reference, pos.reference]).object);

  static final _id_format9 = jniAccessors.getMethodIDOf(_classRef, "format",
      "(Ljava/math/BigInteger;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;");

  /// from: public abstract java.lang.StringBuffer format(java.math.BigInteger number, java.lang.StringBuffer toAppendTo, java.text.FieldPosition pos)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Formats a BigInteger. Specialization of format.
  ///@see java.text.Format\#format(Object, StringBuffer, FieldPosition)
  jni.JniObject format9(
          jni.JniObject number, jni.JniObject toAppendTo, jni.JniObject pos) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_format9,
          jni.JniType.objectType,
          [number.reference, toAppendTo.reference, pos.reference]).object);

  static final _id_format10 = jniAccessors.getMethodIDOf(_classRef, "format",
      "(Ljava/math/BigDecimal;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;");

  /// from: public abstract java.lang.StringBuffer format(java.math.BigDecimal number, java.lang.StringBuffer toAppendTo, java.text.FieldPosition pos)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Formats a BigDecimal. Specialization of format.
  ///@see java.text.Format\#format(Object, StringBuffer, FieldPosition)
  jni.JniObject format10(
          jni.JniObject number, jni.JniObject toAppendTo, jni.JniObject pos) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_format10,
          jni.JniType.objectType,
          [number.reference, toAppendTo.reference, pos.reference]).object);

  static final _id_format11 = jniAccessors.getMethodIDOf(_classRef, "format",
      "(Landroid/icu/math/BigDecimal;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;");

  /// from: public abstract java.lang.StringBuffer format(android.icu.math.BigDecimal number, java.lang.StringBuffer toAppendTo, java.text.FieldPosition pos)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Formats an ICU BigDecimal. Specialization of format.
  ///@see java.text.Format\#format(Object, StringBuffer, FieldPosition)
  jni.JniObject format11(bigdecimal_.BigDecimal number,
          jni.JniObject toAppendTo, jni.JniObject pos) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_format11,
          jni.JniType.objectType,
          [number.reference, toAppendTo.reference, pos.reference]).object);

  static final _id_format12 = jniAccessors.getMethodIDOf(_classRef, "format",
      "(Landroid/icu/util/CurrencyAmount;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;");

  /// from: public java.lang.StringBuffer format(android.icu.util.CurrencyAmount currAmt, java.lang.StringBuffer toAppendTo, java.text.FieldPosition pos)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Formats a CurrencyAmount. Specialization of format.
  ///@see java.text.Format\#format(Object, StringBuffer, FieldPosition)
  jni.JniObject format12(currencyamount_.CurrencyAmount currAmt,
          jni.JniObject toAppendTo, jni.JniObject pos) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_format12,
          jni.JniType.objectType,
          [currAmt.reference, toAppendTo.reference, pos.reference]).object);

  static final _id_parse = jniAccessors.getMethodIDOf(_classRef, "parse",
      "(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/lang/Number;");

  /// from: public abstract java.lang.Number parse(java.lang.String text, java.text.ParsePosition parsePosition)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Long if possible (e.g., within the range [Long.MIN_VALUE,
  /// Long.MAX_VALUE] and with no decimals); otherwise, returns another type,
  /// such as a BigDecimal, BigInteger, or Double. The return type is not
  /// guaranteed other than for the Long case.
  ///
  /// If IntegerOnly is set, will stop at a decimal
  /// point (or equivalent; e.g., for rational numbers "1 2/3", will stop
  /// after the 1).
  ///
  /// Does not throw an exception; if no object can be parsed, index is
  /// unchanged!
  ///
  /// For more detail on parsing, see the "Parsing" header in the class
  /// documentation of DecimalFormat.
  ///@see \#isParseIntegerOnly
  ///@see DecimalFormat\#setParseBigDecimal
  ///@see java.text.Format\#parseObject(String, ParsePosition)
  jni.JniObject parse(jni.JniString text, jni.JniObject parsePosition) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_parse,
          jni.JniType.objectType,
          [text.reference, parsePosition.reference]).object);

  static final _id_parse1 = jniAccessors.getMethodIDOf(
      _classRef, "parse", "(Ljava/lang/String;)Ljava/lang/Number;");

  /// from: public java.lang.Number parse(java.lang.String text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses text from the beginning of the given string to produce a number.
  /// The method might not use the entire text of the given string.
  ///@param text A String whose beginning should be parsed.
  ///@return A Number parsed from the string.
  ///@throws ParseException if the beginning of the specified string
  /// cannot be parsed.
  ///@see \#format
  jni.JniObject parse1(jni.JniString text) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_parse1, jni.JniType.objectType, [text.reference]).object);

  static final _id_parseCurrency = jniAccessors.getMethodIDOf(
      _classRef,
      "parseCurrency",
      "(Ljava/lang/CharSequence;Ljava/text/ParsePosition;)Landroid/icu/util/CurrencyAmount;");

  /// from: public android.icu.util.CurrencyAmount parseCurrency(java.lang.CharSequence text, java.text.ParsePosition pos)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses text from the given string as a CurrencyAmount.  Unlike
  /// the parse() method, this method will attempt to parse a generic
  /// currency name, searching for a match of this object's locale's
  /// currency display names, or for a 3-letter ISO currency code.
  /// This method will fail if this format is not a currency format,
  /// that is, if it does not contain the currency pattern symbol
  /// (U+00A4) in its prefix or suffix.
  ///@param text the text to parse
  ///@param pos input-output position; on input, the position within
  /// text to match; must have 0 &lt;= pos.getIndex() &lt; text.length();
  /// on output, the position after the last matched character. If
  /// the parse fails, the position in unchanged upon output.
  ///@return a CurrencyAmount, or null upon failure
  currencyamount_.CurrencyAmount parseCurrency(
          jni.JniObject text, jni.JniObject pos) =>
      currencyamount_.CurrencyAmount.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_parseCurrency,
          jni.JniType.objectType,
          [text.reference, pos.reference]).object);

  static final _id_isParseIntegerOnly =
      jniAccessors.getMethodIDOf(_classRef, "isParseIntegerOnly", "()Z");

  /// from: public boolean isParseIntegerOnly()
  ///
  /// Returns true if this format will parse numbers as integers only.
  /// For example in the English locale, with ParseIntegerOnly true, the
  /// string "1234." would be parsed as the integer value 1234 and parsing
  /// would stop at the "." character.  The decimal separator accepted
  /// by the parse operation is locale-dependent and determined by the
  /// subclass.
  ///@return true if this will parse integers only
  bool isParseIntegerOnly() => jniAccessors.callMethodWithArgs(
      reference, _id_isParseIntegerOnly, jni.JniType.booleanType, []).boolean;

  static final _id_setParseIntegerOnly =
      jniAccessors.getMethodIDOf(_classRef, "setParseIntegerOnly", "(Z)V");

  /// from: public void setParseIntegerOnly(boolean value)
  ///
  /// Sets whether to ignore the fraction part of a number when parsing
  /// (defaults to false). If a string contains a decimal point, parsing will stop before the decimal
  /// point. Note that determining whether a character is a decimal point depends on the locale.
  ///
  /// For example, in _en-US_, parsing the string "123.45" will return the number 123 and
  /// parse position 3.
  ///@param value true if this should parse integers only
  ///@see \#isParseIntegerOnly
  void setParseIntegerOnly(bool value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setParseIntegerOnly,
      jni.JniType.voidType,
      [value]).check();

  static final _id_setParseStrict =
      jniAccessors.getMethodIDOf(_classRef, "setParseStrict", "(Z)V");

  /// from: public void setParseStrict(boolean value)
  ///
  /// <strong>[icu]</strong> Sets whether strict parsing is in effect.  When this is true, the string
  /// is required to be a stronger match to the pattern than when lenient parsing is in
  /// effect.  More specifically, the following conditions cause a parse failure relative
  /// to lenient mode (examples use the pattern "\#,\#\#0.\#"):<ul>
  /// <li>The presence and position of special symbols, including currency, must match the
  /// pattern.<br>
  /// '+123' fails (there is no plus sign in the pattern)</li>
  /// <li>Leading or doubled grouping separators<br>
  /// ',123' and '1,,234" fail</li>
  /// <li>Groups of incorrect length when grouping is used<br>
  /// '1,23' and '1234,567' fail, but '1234' passes</li>
  /// <li>Grouping separators used in numbers followed by exponents<br>
  /// '1,234E5' fails, but '1234E5' and '1,234E' pass ('E' is not an exponent when
  /// not followed by a number)</li>
  /// </ul>
  /// When strict parsing is off,  all grouping separators are ignored.
  /// This is the default behavior.
  ///@param value True to enable strict parsing.  Default is false.
  ///@see \#isParseStrict
  void setParseStrict(bool value) => jniAccessors.callMethodWithArgs(
      reference, _id_setParseStrict, jni.JniType.voidType, [value]).check();

  static final _id_isParseStrict =
      jniAccessors.getMethodIDOf(_classRef, "isParseStrict", "()Z");

  /// from: public boolean isParseStrict()
  ///
  /// <strong>[icu]</strong> Returns whether strict parsing is in effect.
  ///@return true if strict parsing is in effect
  ///@see \#setParseStrict
  bool isParseStrict() => jniAccessors.callMethodWithArgs(
      reference, _id_isParseStrict, jni.JniType.booleanType, []).boolean;

  static final _id_setContext = jniAccessors.getMethodIDOf(
      _classRef, "setContext", "(Landroid/icu/text/DisplayContext;)V");

  /// from: public void setContext(android.icu.text.DisplayContext context)
  ///
  /// <strong>[icu]</strong> Set a particular DisplayContext value in the formatter,
  /// such as CAPITALIZATION_FOR_STANDALONE.
  ///@param context The DisplayContext value to set.
  void setContext(displaycontext_.DisplayContext context) =>
      jniAccessors.callMethodWithArgs(reference, _id_setContext,
          jni.JniType.voidType, [context.reference]).check();

  static final _id_getContext = jniAccessors.getMethodIDOf(
      _classRef,
      "getContext",
      "(Landroid/icu/text/DisplayContext\$Type;)Landroid/icu/text/DisplayContext;");

  /// from: public android.icu.text.DisplayContext getContext(android.icu.text.DisplayContext.Type type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Get the formatter's DisplayContext value for the specified DisplayContext.Type,
  /// such as CAPITALIZATION.
  ///@param type the DisplayContext.Type whose value to return
  ///@return the current DisplayContext setting for the specified type
  displaycontext_.DisplayContext getContext(
          displaycontext_.DisplayContext_Type type) =>
      displaycontext_.DisplayContext.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getContext,
          jni.JniType.objectType,
          [type.reference]).object);

  static final _id_getInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getInstance", "()Landroid/icu/text/NumberFormat;");

  /// from: static public final android.icu.text.NumberFormat getInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the default number format for the current default <code>FORMAT</code> locale.
  /// The default format is one of the styles provided by the other
  /// factory methods: getNumberInstance, getIntegerInstance,
  /// getCurrencyInstance or getPercentInstance.
  /// Exactly which one is locale-dependent.
  ///@see Category\#FORMAT
  static NumberFormat getInstance() =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getInstance, jni.JniType.objectType, []).object);

  static final _id_getInstance1 = jniAccessors.getStaticMethodIDOf(_classRef,
      "getInstance", "(Ljava/util/Locale;)Landroid/icu/text/NumberFormat;");

  /// from: static public android.icu.text.NumberFormat getInstance(java.util.Locale inLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the default number format for the specified locale.
  /// The default format is one of the styles provided by the other
  /// factory methods: getNumberInstance, getCurrencyInstance or getPercentInstance.
  /// Exactly which one is locale-dependent.
  static NumberFormat getInstance1(jni.JniObject inLocale) =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getInstance1,
          jni.JniType.objectType,
          [inLocale.reference]).object);

  static final _id_getInstance2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getInstance",
      "(Landroid/icu/util/ULocale;)Landroid/icu/text/NumberFormat;");

  /// from: static public android.icu.text.NumberFormat getInstance(android.icu.util.ULocale inLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the default number format for the specified locale.
  /// The default format is one of the styles provided by the other
  /// factory methods: getNumberInstance, getCurrencyInstance or getPercentInstance.
  /// Exactly which one is locale-dependent.
  static NumberFormat getInstance2(ulocale_.ULocale inLocale) =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getInstance2,
          jni.JniType.objectType,
          [inLocale.reference]).object);

  static final _id_getInstance3 = jniAccessors.getStaticMethodIDOf(
      _classRef, "getInstance", "(I)Landroid/icu/text/NumberFormat;");

  /// from: static public final android.icu.text.NumberFormat getInstance(int style)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns a specific style number format for default <code>FORMAT</code> locale.
  ///@param style number format style
  ///@see Category\#FORMAT
  static NumberFormat getInstance3(int style) =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getInstance3, jni.JniType.objectType, [style]).object);

  static final _id_getInstance4 = jniAccessors.getStaticMethodIDOf(_classRef,
      "getInstance", "(Ljava/util/Locale;I)Landroid/icu/text/NumberFormat;");

  /// from: static public android.icu.text.NumberFormat getInstance(java.util.Locale inLocale, int style)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns a specific style number format for a specific locale.
  ///@param inLocale the specific locale.
  ///@param style number format style
  static NumberFormat getInstance4(jni.JniObject inLocale, int style) =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getInstance4,
          jni.JniType.objectType,
          [inLocale.reference, style]).object);

  static final _id_getNumberInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getNumberInstance", "()Landroid/icu/text/NumberFormat;");

  /// from: static public final android.icu.text.NumberFormat getNumberInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a general-purpose number format for the current default <code>FORMAT</code> locale.
  ///@see Category\#FORMAT
  static NumberFormat getNumberInstance() =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getNumberInstance, jni.JniType.objectType, []).object);

  static final _id_getNumberInstance1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getNumberInstance",
      "(Ljava/util/Locale;)Landroid/icu/text/NumberFormat;");

  /// from: static public android.icu.text.NumberFormat getNumberInstance(java.util.Locale inLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a general-purpose number format for the specified locale.
  static NumberFormat getNumberInstance1(jni.JniObject inLocale) =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getNumberInstance1,
          jni.JniType.objectType,
          [inLocale.reference]).object);

  static final _id_getNumberInstance2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getNumberInstance",
      "(Landroid/icu/util/ULocale;)Landroid/icu/text/NumberFormat;");

  /// from: static public android.icu.text.NumberFormat getNumberInstance(android.icu.util.ULocale inLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns a general-purpose number format for the specified locale.
  static NumberFormat getNumberInstance2(ulocale_.ULocale inLocale) =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getNumberInstance2,
          jni.JniType.objectType,
          [inLocale.reference]).object);

  static final _id_getIntegerInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getIntegerInstance", "()Landroid/icu/text/NumberFormat;");

  /// from: static public final android.icu.text.NumberFormat getIntegerInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an integer number format for the current default <code>FORMAT</code> locale. The
  /// returned number format is configured to round floating point numbers
  /// to the nearest integer using IEEE half-even rounding (see android.icu.math.BigDecimal\#ROUND_HALF_EVEN ROUND_HALF_EVEN) for formatting,
  /// and to parse only the integer part of an input string (see \#isParseIntegerOnly isParseIntegerOnly).
  ///@return a number format for integer values
  ///@see Category\#FORMAT
  static NumberFormat getIntegerInstance() =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getIntegerInstance, jni.JniType.objectType, []).object);

  static final _id_getIntegerInstance1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getIntegerInstance",
      "(Ljava/util/Locale;)Landroid/icu/text/NumberFormat;");

  /// from: static public android.icu.text.NumberFormat getIntegerInstance(java.util.Locale inLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an integer number format for the specified locale. The
  /// returned number format is configured to round floating point numbers
  /// to the nearest integer using IEEE half-even rounding (see android.icu.math.BigDecimal\#ROUND_HALF_EVEN ROUND_HALF_EVEN) for formatting,
  /// and to parse only the integer part of an input string (see \#isParseIntegerOnly isParseIntegerOnly).
  ///@param inLocale the locale for which a number format is needed
  ///@return a number format for integer values
  static NumberFormat getIntegerInstance1(jni.JniObject inLocale) =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getIntegerInstance1,
          jni.JniType.objectType,
          [inLocale.reference]).object);

  static final _id_getIntegerInstance2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getIntegerInstance",
      "(Landroid/icu/util/ULocale;)Landroid/icu/text/NumberFormat;");

  /// from: static public android.icu.text.NumberFormat getIntegerInstance(android.icu.util.ULocale inLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns an integer number format for the specified locale. The
  /// returned number format is configured to round floating point numbers
  /// to the nearest integer using IEEE half-even rounding (see android.icu.math.BigDecimal\#ROUND_HALF_EVEN ROUND_HALF_EVEN) for formatting,
  /// and to parse only the integer part of an input string (see \#isParseIntegerOnly isParseIntegerOnly).
  ///@param inLocale the locale for which a number format is needed
  ///@return a number format for integer values
  static NumberFormat getIntegerInstance2(ulocale_.ULocale inLocale) =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getIntegerInstance2,
          jni.JniType.objectType,
          [inLocale.reference]).object);

  static final _id_getCurrencyInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getCurrencyInstance", "()Landroid/icu/text/NumberFormat;");

  /// from: static public final android.icu.text.NumberFormat getCurrencyInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a currency format for the current default <code>FORMAT</code> locale.
  ///@return a number format for currency
  ///@see Category\#FORMAT
  static NumberFormat getCurrencyInstance() =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getCurrencyInstance, jni.JniType.objectType, []).object);

  static final _id_getCurrencyInstance1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getCurrencyInstance",
      "(Ljava/util/Locale;)Landroid/icu/text/NumberFormat;");

  /// from: static public android.icu.text.NumberFormat getCurrencyInstance(java.util.Locale inLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a currency format for the specified locale.
  ///@return a number format for currency
  static NumberFormat getCurrencyInstance1(jni.JniObject inLocale) =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getCurrencyInstance1,
          jni.JniType.objectType,
          [inLocale.reference]).object);

  static final _id_getCurrencyInstance2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getCurrencyInstance",
      "(Landroid/icu/util/ULocale;)Landroid/icu/text/NumberFormat;");

  /// from: static public android.icu.text.NumberFormat getCurrencyInstance(android.icu.util.ULocale inLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns a currency format for the specified locale.
  ///@return a number format for currency
  static NumberFormat getCurrencyInstance2(ulocale_.ULocale inLocale) =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getCurrencyInstance2,
          jni.JniType.objectType,
          [inLocale.reference]).object);

  static final _id_getPercentInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getPercentInstance", "()Landroid/icu/text/NumberFormat;");

  /// from: static public final android.icu.text.NumberFormat getPercentInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a percentage format for the current default <code>FORMAT</code> locale.
  ///@return a number format for percents
  ///@see Category\#FORMAT
  static NumberFormat getPercentInstance() =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getPercentInstance, jni.JniType.objectType, []).object);

  static final _id_getPercentInstance1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getPercentInstance",
      "(Ljava/util/Locale;)Landroid/icu/text/NumberFormat;");

  /// from: static public android.icu.text.NumberFormat getPercentInstance(java.util.Locale inLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a percentage format for the specified locale.
  ///@return a number format for percents
  static NumberFormat getPercentInstance1(jni.JniObject inLocale) =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getPercentInstance1,
          jni.JniType.objectType,
          [inLocale.reference]).object);

  static final _id_getPercentInstance2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getPercentInstance",
      "(Landroid/icu/util/ULocale;)Landroid/icu/text/NumberFormat;");

  /// from: static public android.icu.text.NumberFormat getPercentInstance(android.icu.util.ULocale inLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns a percentage format for the specified locale.
  ///@return a number format for percents
  static NumberFormat getPercentInstance2(ulocale_.ULocale inLocale) =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getPercentInstance2,
          jni.JniType.objectType,
          [inLocale.reference]).object);

  static final _id_getScientificInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getScientificInstance", "()Landroid/icu/text/NumberFormat;");

  /// from: static public final android.icu.text.NumberFormat getScientificInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns a scientific format for the current default <code>FORMAT</code> locale.
  ///@return a scientific number format
  ///@see Category\#FORMAT
  static NumberFormat getScientificInstance() =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getScientificInstance, jni.JniType.objectType, []).object);

  static final _id_getScientificInstance1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getScientificInstance",
      "(Ljava/util/Locale;)Landroid/icu/text/NumberFormat;");

  /// from: static public android.icu.text.NumberFormat getScientificInstance(java.util.Locale inLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns a scientific format for the specified locale.
  ///@return a scientific number format
  static NumberFormat getScientificInstance1(jni.JniObject inLocale) =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getScientificInstance1,
          jni.JniType.objectType,
          [inLocale.reference]).object);

  static final _id_getScientificInstance2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getScientificInstance",
      "(Landroid/icu/util/ULocale;)Landroid/icu/text/NumberFormat;");

  /// from: static public android.icu.text.NumberFormat getScientificInstance(android.icu.util.ULocale inLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns a scientific format for the specified locale.
  ///@return a scientific number format
  static NumberFormat getScientificInstance2(ulocale_.ULocale inLocale) =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getScientificInstance2,
          jni.JniType.objectType,
          [inLocale.reference]).object);

  static final _id_getAvailableLocales = jniAccessors.getStaticMethodIDOf(
      _classRef, "getAvailableLocales", "()[Ljava/util/Locale;");

  /// from: static public java.util.Locale[] getAvailableLocales()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of Locales for which NumberFormats are available.
  ///@return the available locales
  static jni.JniObject getAvailableLocales() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getAvailableLocales, jni.JniType.objectType, []).object);

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// {@inheritDoc}
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// Overrides equals.
  /// Two NumberFormats are equal if they are of the same class
  /// and the settings (groupingUsed, parseIntegerOnly, maximumIntegerDigits, etc.
  /// are equal.
  ///@param obj the object to compare against
  ///@return true if the object is equal to this.
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_clone =
      jniAccessors.getMethodIDOf(_classRef, "clone", "()Ljava/lang/Object;");

  /// from: public java.lang.Object clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Overrides clone.
  jni.JniObject clone() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_isGroupingUsed =
      jniAccessors.getMethodIDOf(_classRef, "isGroupingUsed", "()Z");

  /// from: public boolean isGroupingUsed()
  ///
  /// Returns true if grouping is used in this format. For example, in the
  /// en_US locale, with grouping on, the number 1234567 will be formatted
  /// as "1,234,567". The grouping separator as well as the size of each group
  /// is locale-dependent and is determined by subclasses of NumberFormat.
  /// Grouping affects both parsing and formatting.
  ///@return true if grouping is used
  ///@see \#setGroupingUsed
  bool isGroupingUsed() => jniAccessors.callMethodWithArgs(
      reference, _id_isGroupingUsed, jni.JniType.booleanType, []).boolean;

  static final _id_setGroupingUsed =
      jniAccessors.getMethodIDOf(_classRef, "setGroupingUsed", "(Z)V");

  /// from: public void setGroupingUsed(boolean newValue)
  ///
  /// Sets whether or not grouping will be used in this format.  Grouping
  /// affects both parsing and formatting.
  ///@see \#isGroupingUsed
  ///@param newValue true to use grouping.
  void setGroupingUsed(bool newValue) => jniAccessors.callMethodWithArgs(
      reference, _id_setGroupingUsed, jni.JniType.voidType, [newValue]).check();

  static final _id_getMaximumIntegerDigits =
      jniAccessors.getMethodIDOf(_classRef, "getMaximumIntegerDigits", "()I");

  /// from: public int getMaximumIntegerDigits()
  ///
  /// Returns the maximum number of digits allowed in the integer portion of a
  /// number.  The default value is 40, which subclasses can override.
  ///
  /// When formatting, if the number of digits exceeds this value, the highest-
  /// significance digits are truncated until the limit is reached, in accordance
  /// with UTS\#35.
  ///
  /// This setting has no effect on parsing.
  ///@return the maximum number of integer digits
  ///@see \#setMaximumIntegerDigits
  int getMaximumIntegerDigits() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaximumIntegerDigits, jni.JniType.intType, []).integer;

  static final _id_setMaximumIntegerDigits =
      jniAccessors.getMethodIDOf(_classRef, "setMaximumIntegerDigits", "(I)V");

  /// from: public void setMaximumIntegerDigits(int newValue)
  ///
  /// Sets the maximum number of digits allowed in the integer portion of a
  /// number. This must be &gt;= minimumIntegerDigits.  If the
  /// new value for maximumIntegerDigits is less than the current value
  /// of minimumIntegerDigits, then minimumIntegerDigits will also be set to
  /// the new value.
  ///@param newValue the maximum number of integer digits to be shown; if
  /// less than zero, then zero is used.  Subclasses might enforce an
  /// upper limit to this value appropriate to the numeric type being formatted.
  ///@see \#getMaximumIntegerDigits
  void setMaximumIntegerDigits(int newValue) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMaximumIntegerDigits,
      jni.JniType.voidType,
      [newValue]).check();

  static final _id_getMinimumIntegerDigits =
      jniAccessors.getMethodIDOf(_classRef, "getMinimumIntegerDigits", "()I");

  /// from: public int getMinimumIntegerDigits()
  ///
  /// Returns the minimum number of digits allowed in the integer portion of a
  /// number.  The default value is 1, which subclasses can override.
  /// When formatting, if this value is not reached, numbers are padded on the
  /// left with the locale-specific '0' character to ensure at least this
  /// number of integer digits.  When parsing, this has no effect.
  ///@return the minimum number of integer digits
  ///@see \#setMinimumIntegerDigits
  int getMinimumIntegerDigits() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinimumIntegerDigits, jni.JniType.intType, []).integer;

  static final _id_setMinimumIntegerDigits =
      jniAccessors.getMethodIDOf(_classRef, "setMinimumIntegerDigits", "(I)V");

  /// from: public void setMinimumIntegerDigits(int newValue)
  ///
  /// Sets the minimum number of digits allowed in the integer portion of a
  /// number.  This must be &lt;= maximumIntegerDigits.  If the
  /// new value for minimumIntegerDigits is more than the current value
  /// of maximumIntegerDigits, then maximumIntegerDigits will also be set to
  /// the new value.
  ///@param newValue the minimum number of integer digits to be shown; if
  /// less than zero, then zero is used. Subclasses might enforce an
  /// upper limit to this value appropriate to the numeric type being formatted.
  ///@see \#getMinimumIntegerDigits
  void setMinimumIntegerDigits(int newValue) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMinimumIntegerDigits,
      jni.JniType.voidType,
      [newValue]).check();

  static final _id_getMaximumFractionDigits =
      jniAccessors.getMethodIDOf(_classRef, "getMaximumFractionDigits", "()I");

  /// from: public int getMaximumFractionDigits()
  ///
  /// Returns the maximum number of digits allowed in the fraction
  /// portion of a number.  The default value is 3, which subclasses
  /// can override.  When formatting, the exact behavior when this
  /// value is exceeded is subclass-specific.  When parsing, this has
  /// no effect.
  ///@return the maximum number of fraction digits
  ///@see \#setMaximumFractionDigits
  int getMaximumFractionDigits() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaximumFractionDigits, jni.JniType.intType, []).integer;

  static final _id_setMaximumFractionDigits =
      jniAccessors.getMethodIDOf(_classRef, "setMaximumFractionDigits", "(I)V");

  /// from: public void setMaximumFractionDigits(int newValue)
  ///
  /// Sets the maximum number of digits allowed in the fraction portion of a
  /// number. This must be &gt;= minimumFractionDigits.  If the
  /// new value for maximumFractionDigits is less than the current value
  /// of minimumFractionDigits, then minimumFractionDigits will also be set to
  /// the new value.
  ///@param newValue the maximum number of fraction digits to be shown; if
  /// less than zero, then zero is used. The concrete subclass may enforce an
  /// upper limit to this value appropriate to the numeric type being formatted.
  ///@see \#getMaximumFractionDigits
  void setMaximumFractionDigits(int newValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMaximumFractionDigits,
          jni.JniType.voidType, [newValue]).check();

  static final _id_getMinimumFractionDigits =
      jniAccessors.getMethodIDOf(_classRef, "getMinimumFractionDigits", "()I");

  /// from: public int getMinimumFractionDigits()
  ///
  /// Returns the minimum number of digits allowed in the fraction portion of a
  /// number.  The default value is 0, which subclasses can override.
  /// When formatting, if this value is not reached, numbers are padded on
  /// the right with the locale-specific '0' character to ensure at least
  /// this number of fraction digits.  When parsing, this has no effect.
  ///@return the minimum number of fraction digits
  ///@see \#setMinimumFractionDigits
  int getMinimumFractionDigits() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinimumFractionDigits, jni.JniType.intType, []).integer;

  static final _id_setMinimumFractionDigits =
      jniAccessors.getMethodIDOf(_classRef, "setMinimumFractionDigits", "(I)V");

  /// from: public void setMinimumFractionDigits(int newValue)
  ///
  /// Sets the minimum number of digits allowed in the fraction portion of a
  /// number.  This must be &lt;= maximumFractionDigits.  If the
  /// new value for minimumFractionDigits exceeds the current value
  /// of maximumFractionDigits, then maximumFractionDigits will also be set to
  /// the new value.
  ///@param newValue the minimum number of fraction digits to be shown; if
  /// less than zero, then zero is used.  Subclasses might enforce an
  /// upper limit to this value appropriate to the numeric type being formatted.
  ///@see \#getMinimumFractionDigits
  void setMinimumFractionDigits(int newValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMinimumFractionDigits,
          jni.JniType.voidType, [newValue]).check();

  static final _id_setCurrency = jniAccessors.getMethodIDOf(
      _classRef, "setCurrency", "(Landroid/icu/util/Currency;)V");

  /// from: public void setCurrency(android.icu.util.Currency theCurrency)
  ///
  /// Sets the <tt>Currency</tt> object used to display currency
  /// amounts.  This takes effect immediately, if this format is a
  /// currency format.  If this format is not a currency format, then
  /// the currency object is used if and when this object becomes a
  /// currency format.
  ///@param theCurrency new currency object to use.  May be null for
  /// some subclasses.
  void setCurrency(currency_.Currency theCurrency) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCurrency,
          jni.JniType.voidType, [theCurrency.reference]).check();

  static final _id_getCurrency = jniAccessors.getMethodIDOf(
      _classRef, "getCurrency", "()Landroid/icu/util/Currency;");

  /// from: public android.icu.util.Currency getCurrency()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the <tt>Currency</tt> object used to display currency
  /// amounts.  This may be null.
  currency_.Currency getCurrency() =>
      currency_.Currency.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCurrency, jni.JniType.objectType, []).object);

  static final _id_getRoundingMode =
      jniAccessors.getMethodIDOf(_classRef, "getRoundingMode", "()I");

  /// from: public int getRoundingMode()
  ///
  /// Returns the rounding mode used in this NumberFormat.  The default implementation of
  /// tis method in NumberFormat always throws <code>UnsupportedOperationException</code>.
  ///@return A rounding mode, between <code>BigDecimal.ROUND_UP</code>
  /// and <code>BigDecimal.ROUND_UNNECESSARY</code>.
  ///@see \#setRoundingMode(int)
  int getRoundingMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getRoundingMode, jni.JniType.intType, []).integer;

  static final _id_setRoundingMode =
      jniAccessors.getMethodIDOf(_classRef, "setRoundingMode", "(I)V");

  /// from: public void setRoundingMode(int roundingMode)
  ///
  /// Set the rounding mode used in this NumberFormat.  The default implementation of
  /// tis method in NumberFormat always throws <code>UnsupportedOperationException</code>.
  ///@param roundingMode A rounding mode, between
  /// <code>BigDecimal.ROUND_UP</code> and
  /// <code>BigDecimal.ROUND_UNNECESSARY</code>.
  ///@see \#getRoundingMode()
  void setRoundingMode(int roundingMode) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setRoundingMode,
      jni.JniType.voidType,
      [roundingMode]).check();

  static final _id_getInstance5 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getInstance",
      "(Landroid/icu/util/ULocale;I)Landroid/icu/text/NumberFormat;");

  /// from: static public android.icu.text.NumberFormat getInstance(android.icu.util.ULocale desiredLocale, int choice)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a specific style number format for a specific locale.
  ///@param desiredLocale the specific locale.
  ///@param choice number format style
  ///@throws IllegalArgumentException if choice is not one of
  ///                                   NUMBERSTYLE, CURRENCYSTYLE,
  ///                                   PERCENTSTYLE, SCIENTIFICSTYLE,
  ///                                   INTEGERSTYLE, ISOCURRENCYSTYLE,
  ///                                   PLURALCURRENCYSTYLE, ACCOUNTINGCURRENCYSTYLE.
  ///                                   CASHCURRENCYSTYLE, STANDARDCURRENCYSTYLE.
  static NumberFormat getInstance5(
          ulocale_.ULocale desiredLocale, int choice) =>
      NumberFormat.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getInstance5,
          jni.JniType.objectType,
          [desiredLocale.reference, choice]).object);

  static final _id_getPattern = jniAccessors.getStaticMethodIDOf(_classRef,
      "getPattern", "(Landroid/icu/util/ULocale;I)Ljava/lang/String;");

  /// from: static protected java.lang.String getPattern(android.icu.util.ULocale forLocale, int choice)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the pattern for the provided locale and choice.
  ///@param forLocale the locale of the data.
  ///@param choice the pattern format.
  ///@return the pattern
  static jni.JniString getPattern(ulocale_.ULocale forLocale, int choice) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getPattern,
          jni.JniType.objectType,
          [forLocale.reference, choice]).object);
}

/// from: android.icu.text.NumberFormat$Field
///
/// The instances of this inner class are used as attribute keys and values
/// in AttributedCharacterIterator that
/// NumberFormat.formatToCharacterIterator() method returns.
///
/// There is no public constructor to this class, the only instances are the
/// constants defined here.
///
class NumberFormat_Field extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/NumberFormat\$Field");
  NumberFormat_Field.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CURRENCY = jniAccessors.getStaticFieldIDOf(
      _classRef, "CURRENCY", "Landroid/icu/text/NumberFormat\$Field;");

  /// from: static public final android.icu.text.NumberFormat.Field CURRENCY
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  static NumberFormat_Field get CURRENCY =>
      NumberFormat_Field.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CURRENCY, jni.JniType.objectType)
          .object);

  static final _id_DECIMAL_SEPARATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "DECIMAL_SEPARATOR", "Landroid/icu/text/NumberFormat\$Field;");

  /// from: static public final android.icu.text.NumberFormat.Field DECIMAL_SEPARATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  static NumberFormat_Field get DECIMAL_SEPARATOR =>
      NumberFormat_Field.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_DECIMAL_SEPARATOR, jni.JniType.objectType)
          .object);

  static final _id_EXPONENT = jniAccessors.getStaticFieldIDOf(
      _classRef, "EXPONENT", "Landroid/icu/text/NumberFormat\$Field;");

  /// from: static public final android.icu.text.NumberFormat.Field EXPONENT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  static NumberFormat_Field get EXPONENT =>
      NumberFormat_Field.fromRef(jniAccessors
          .getStaticField(_classRef, _id_EXPONENT, jni.JniType.objectType)
          .object);

  static final _id_EXPONENT_SIGN = jniAccessors.getStaticFieldIDOf(
      _classRef, "EXPONENT_SIGN", "Landroid/icu/text/NumberFormat\$Field;");

  /// from: static public final android.icu.text.NumberFormat.Field EXPONENT_SIGN
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  static NumberFormat_Field get EXPONENT_SIGN =>
      NumberFormat_Field.fromRef(jniAccessors
          .getStaticField(_classRef, _id_EXPONENT_SIGN, jni.JniType.objectType)
          .object);

  static final _id_EXPONENT_SYMBOL = jniAccessors.getStaticFieldIDOf(
      _classRef, "EXPONENT_SYMBOL", "Landroid/icu/text/NumberFormat\$Field;");

  /// from: static public final android.icu.text.NumberFormat.Field EXPONENT_SYMBOL
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  static NumberFormat_Field get EXPONENT_SYMBOL =>
      NumberFormat_Field.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_EXPONENT_SYMBOL, jni.JniType.objectType)
          .object);

  static final _id_FRACTION = jniAccessors.getStaticFieldIDOf(
      _classRef, "FRACTION", "Landroid/icu/text/NumberFormat\$Field;");

  /// from: static public final android.icu.text.NumberFormat.Field FRACTION
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  static NumberFormat_Field get FRACTION =>
      NumberFormat_Field.fromRef(jniAccessors
          .getStaticField(_classRef, _id_FRACTION, jni.JniType.objectType)
          .object);

  static final _id_GROUPING_SEPARATOR = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "GROUPING_SEPARATOR",
      "Landroid/icu/text/NumberFormat\$Field;");

  /// from: static public final android.icu.text.NumberFormat.Field GROUPING_SEPARATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  static NumberFormat_Field get GROUPING_SEPARATOR =>
      NumberFormat_Field.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_GROUPING_SEPARATOR, jni.JniType.objectType)
          .object);

  static final _id_INTEGER = jniAccessors.getStaticFieldIDOf(
      _classRef, "INTEGER", "Landroid/icu/text/NumberFormat\$Field;");

  /// from: static public final android.icu.text.NumberFormat.Field INTEGER
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  static NumberFormat_Field get INTEGER =>
      NumberFormat_Field.fromRef(jniAccessors
          .getStaticField(_classRef, _id_INTEGER, jni.JniType.objectType)
          .object);

  static final _id_PERCENT = jniAccessors.getStaticFieldIDOf(
      _classRef, "PERCENT", "Landroid/icu/text/NumberFormat\$Field;");

  /// from: static public final android.icu.text.NumberFormat.Field PERCENT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  static NumberFormat_Field get PERCENT =>
      NumberFormat_Field.fromRef(jniAccessors
          .getStaticField(_classRef, _id_PERCENT, jni.JniType.objectType)
          .object);

  static final _id_PERMILLE = jniAccessors.getStaticFieldIDOf(
      _classRef, "PERMILLE", "Landroid/icu/text/NumberFormat\$Field;");

  /// from: static public final android.icu.text.NumberFormat.Field PERMILLE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  static NumberFormat_Field get PERMILLE =>
      NumberFormat_Field.fromRef(jniAccessors
          .getStaticField(_classRef, _id_PERMILLE, jni.JniType.objectType)
          .object);

  static final _id_SIGN = jniAccessors.getStaticFieldIDOf(
      _classRef, "SIGN", "Landroid/icu/text/NumberFormat\$Field;");

  /// from: static public final android.icu.text.NumberFormat.Field SIGN
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  static NumberFormat_Field get SIGN => NumberFormat_Field.fromRef(jniAccessors
      .getStaticField(_classRef, _id_SIGN, jni.JniType.objectType)
      .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: protected void <init>(java.lang.String fieldName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new instance of NumberFormat.Field with the given field
  /// name.
  NumberFormat_Field(jni.JniString fieldName)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [fieldName.reference]).object);

  static final _id_readResolve = jniAccessors.getMethodIDOf(
      _classRef, "readResolve", "()Ljava/lang/Object;");

  /// from: protected java.lang.Object readResolve()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// serizalization method resolve instances to the constant
  /// NumberFormat.Field values
  jni.JniObject readResolve() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_readResolve, jni.JniType.objectType, []).object);
}
