// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../util/ULocale.dart" as ulocale_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.text.DateTimePatternGenerator
///
/// This class provides flexible generation of date format patterns, like
/// "yy-MM-dd". The user can build up the generator by adding successive
/// patterns. Once that is done, a query can be made using a "skeleton", which is
/// a pattern which just includes the desired fields and lengths. The generator
/// will return the "best fit" pattern corresponding to that skeleton.
///
/// The main method people will use is getBestPattern(String skeleton), since
/// normally this class is pre-built with data from a particular locale. However,
/// generators can be built directly from other data as well.
class DateTimePatternGenerator extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/DateTimePatternGenerator");
  DateTimePatternGenerator.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DAY
  ///
  ///
  static const DAY = 7;

  /// from: static public final int DAYPERIOD
  ///
  ///
  static const DAYPERIOD = 10;

  /// from: static public final int DAY_OF_WEEK_IN_MONTH
  ///
  ///
  static const DAY_OF_WEEK_IN_MONTH = 9;

  /// from: static public final int DAY_OF_YEAR
  ///
  ///
  static const DAY_OF_YEAR = 8;

  /// from: static public final int ERA
  ///
  ///
  static const ERA = 0;

  /// from: static public final int FRACTIONAL_SECOND
  ///
  ///
  static const FRACTIONAL_SECOND = 14;

  /// from: static public final int HOUR
  ///
  ///
  static const HOUR = 11;

  /// from: static public final int MATCH_ALL_FIELDS_LENGTH
  ///
  /// Option mask for forcing the width of all date and time fields.
  ///@see \#getBestPattern(String, int)
  ///@see \#replaceFieldTypes(String, String, int)
  static const MATCH_ALL_FIELDS_LENGTH = 65535;

  /// from: static public final int MATCH_HOUR_FIELD_LENGTH
  ///
  /// Option mask for forcing the width of hour field.
  ///@see \#getBestPattern(String, int)
  ///@see \#replaceFieldTypes(String, String, int)
  static const MATCH_HOUR_FIELD_LENGTH = 2048;

  /// from: static public final int MATCH_NO_OPTIONS
  ///
  /// Default option mask used for \#getBestPattern(String, int)
  /// and \#replaceFieldTypes(String, String, int).
  ///@see \#getBestPattern(String, int)
  ///@see \#replaceFieldTypes(String, String, int)
  static const MATCH_NO_OPTIONS = 0;

  /// from: static public final int MINUTE
  ///
  ///
  static const MINUTE = 12;

  /// from: static public final int MONTH
  ///
  ///
  static const MONTH = 3;

  /// from: static public final int QUARTER
  ///
  ///
  static const QUARTER = 2;

  /// from: static public final int SECOND
  ///
  ///
  static const SECOND = 13;

  /// from: static public final int WEEKDAY
  ///
  ///
  static const WEEKDAY = 6;

  /// from: static public final int WEEK_OF_MONTH
  ///
  ///
  static const WEEK_OF_MONTH = 5;

  /// from: static public final int WEEK_OF_YEAR
  ///
  ///
  static const WEEK_OF_YEAR = 4;

  /// from: static public final int YEAR
  ///
  ///
  static const YEAR = 1;

  /// from: static public final int ZONE
  ///
  ///
  static const ZONE = 15;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: protected void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Only for use by subclasses
  DateTimePatternGenerator()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getEmptyInstance = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getEmptyInstance",
      "()Landroid/icu/text/DateTimePatternGenerator;");

  /// from: static public android.icu.text.DateTimePatternGenerator getEmptyInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create empty generator, to be constructed with addPattern(...) etc.
  static DateTimePatternGenerator getEmptyInstance() =>
      DateTimePatternGenerator.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getEmptyInstance, jni.JniType.objectType, []).object);

  static final _id_getInstance = jniAccessors.getStaticMethodIDOf(_classRef,
      "getInstance", "()Landroid/icu/text/DateTimePatternGenerator;");

  /// from: static public android.icu.text.DateTimePatternGenerator getInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a flexible generator according to data for the default <code>FORMAT</code> locale.
  ///@see Category\#FORMAT
  static DateTimePatternGenerator getInstance() =>
      DateTimePatternGenerator.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getInstance, jni.JniType.objectType, []).object);

  static final _id_getInstance1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getInstance",
      "(Landroid/icu/util/ULocale;)Landroid/icu/text/DateTimePatternGenerator;");

  /// from: static public android.icu.text.DateTimePatternGenerator getInstance(android.icu.util.ULocale uLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a flexible generator according to data for a given locale.
  ///@param uLocale The locale to pass.
  static DateTimePatternGenerator getInstance1(ulocale_.ULocale uLocale) =>
      DateTimePatternGenerator.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getInstance1,
          jni.JniType.objectType,
          [uLocale.reference]).object);

  static final _id_getInstance2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getInstance",
      "(Ljava/util/Locale;)Landroid/icu/text/DateTimePatternGenerator;");

  /// from: static public android.icu.text.DateTimePatternGenerator getInstance(java.util.Locale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a flexible generator according to data for a given locale.
  ///@param locale The java.util.Locale to pass.
  static DateTimePatternGenerator getInstance2(jni.JniObject locale) =>
      DateTimePatternGenerator.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getInstance2,
          jni.JniType.objectType,
          [locale.reference]).object);

  static final _id_getBestPattern = jniAccessors.getMethodIDOf(
      _classRef, "getBestPattern", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String getBestPattern(java.lang.String skeleton)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the best pattern matching the input skeleton. It is guaranteed to
  /// have all of the fields in the skeleton.
  /// Example code:{@sample external/icu/android_icu4j/src/samples/java/android/icu/samples/text/datetimepatterngenerator/DateTimePatternGeneratorSample.java getBestPatternExample}
  ///@param skeleton The skeleton is a pattern containing only the variable fields.
  ///            For example, "MMMdd" and "mmhh" are skeletons.
  ///@return Best pattern matching the input skeleton.
  jni.JniString getBestPattern(jni.JniString skeleton) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getBestPattern,
          jni.JniType.objectType,
          [skeleton.reference]).object);

  static final _id_getBestPattern1 = jniAccessors.getMethodIDOf(
      _classRef, "getBestPattern", "(Ljava/lang/String;I)Ljava/lang/String;");

  /// from: public java.lang.String getBestPattern(java.lang.String skeleton, int options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the best pattern matching the input skeleton. It is guaranteed to
  /// have all of the fields in the skeleton.
  ///@param skeleton The skeleton is a pattern containing only the variable fields.
  ///            For example, "MMMdd" and "mmhh" are skeletons.
  ///@param options MATCH_xxx options for forcing the length of specified fields in
  ///            the returned pattern to match those in the skeleton (when this would
  ///            not happen otherwise). For default behavior, use MATCH_NO_OPTIONS.
  ///@return Best pattern matching the input skeleton (and options).
  jni.JniString getBestPattern1(jni.JniString skeleton, int options) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getBestPattern1,
          jni.JniType.objectType,
          [skeleton.reference, options]).object);

  static final _id_addPattern = jniAccessors.getMethodIDOf(
      _classRef,
      "addPattern",
      "(Ljava/lang/String;ZLandroid/icu/text/DateTimePatternGenerator\$PatternInfo;)Landroid/icu/text/DateTimePatternGenerator;");

  /// from: public android.icu.text.DateTimePatternGenerator addPattern(java.lang.String pattern, boolean override, android.icu.text.DateTimePatternGenerator.PatternInfo returnInfo)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds a pattern to the generator. If the pattern has the same skeleton as
  /// an existing pattern, and the override parameter is set, then the previous
  /// value is overridden. Otherwise, the previous value is retained. In either
  /// case, the conflicting information is returned in PatternInfo.
  ///
  /// Note that single-field patterns (like "MMM") are automatically added, and
  /// don't need to be added explicitly!
  /// * Example code:{@sample external/icu/android_icu4j/src/samples/java/android/icu/samples/text/datetimepatterngenerator/DateTimePatternGeneratorSample.java addPatternExample}
  ///@param pattern Pattern to add.
  ///@param override When existing values are to be overridden use true, otherwise
  ///            use false.
  ///@param returnInfo Returned information.
  DateTimePatternGenerator addPattern(jni.JniString pattern, bool override,
          DateTimePatternGenerator_PatternInfo returnInfo) =>
      DateTimePatternGenerator.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addPattern,
          jni.JniType.objectType,
          [pattern.reference, override, returnInfo.reference]).object);

  static final _id_getSkeleton = jniAccessors.getMethodIDOf(
      _classRef, "getSkeleton", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String getSkeleton(java.lang.String pattern)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Utility to return a unique skeleton from a given pattern. For example,
  /// both "MMM-dd" and "dd/MMM" produce the skeleton "MMMdd".
  ///@param pattern Input pattern, such as "dd/MMM"
  ///@return skeleton, such as "MMMdd"
  jni.JniString getSkeleton(jni.JniString pattern) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSkeleton, jni.JniType.objectType, [pattern.reference]).object);

  static final _id_getBaseSkeleton = jniAccessors.getMethodIDOf(
      _classRef, "getBaseSkeleton", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String getBaseSkeleton(java.lang.String pattern)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Utility to return a unique base skeleton from a given pattern. This is
  /// the same as the skeleton, except that differences in length are minimized
  /// so as to only preserve the difference between string and numeric form. So
  /// for example, both "MMM-dd" and "d/MMM" produce the skeleton "MMMd"
  /// (notice the single d).
  ///@param pattern Input pattern, such as "dd/MMM"
  ///@return skeleton, such as "MMMdd"
  jni.JniString getBaseSkeleton(jni.JniString pattern) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getBaseSkeleton,
          jni.JniType.objectType,
          [pattern.reference]).object);

  static final _id_getSkeletons = jniAccessors.getMethodIDOf(
      _classRef, "getSkeletons", "(Ljava/util/Map;)Ljava/util/Map;");

  /// from: public java.util.Map<java.lang.String,java.lang.String> getSkeletons(java.util.Map<java.lang.String,java.lang.String> result)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a list of all the skeletons (in canonical form) from this class,
  /// and the patterns that they map to.
  ///@param result an output Map in which to place the mapping from skeleton to
  ///            pattern. If you want to see the internal order being used,
  ///            supply a LinkedHashMap. If the input value is null, then a
  ///            LinkedHashMap is allocated.
  ///
  ///            <i>Issue: an alternate API would be to just return a list of
  ///            the skeletons, and then have a separate routine to get from
  ///            skeleton to pattern.</i>
  ///@return the input Map containing the values.
  jni.JniObject getSkeletons(jni.JniObject result) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSkeletons, jni.JniType.objectType, [result.reference]).object);

  static final _id_getBaseSkeletons = jniAccessors.getMethodIDOf(
      _classRef, "getBaseSkeletons", "(Ljava/util/Set;)Ljava/util/Set;");

  /// from: public java.util.Set<java.lang.String> getBaseSkeletons(java.util.Set<java.lang.String> result)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a list of all the base skeletons (in canonical form) from this class
  jni.JniObject getBaseSkeletons(jni.JniObject result) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getBaseSkeletons,
          jni.JniType.objectType,
          [result.reference]).object);

  static final _id_replaceFieldTypes = jniAccessors.getMethodIDOf(
      _classRef,
      "replaceFieldTypes",
      "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String replaceFieldTypes(java.lang.String pattern, java.lang.String skeleton)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adjusts the field types (width and subtype) of a pattern to match what is
  /// in a skeleton. That is, if you supply a pattern like "d-M H:m", and a
  /// skeleton of "MMMMddhhmm", then the input pattern is adjusted to be
  /// "dd-MMMM hh:mm". This is used internally to get the best match for the
  /// input skeleton, but can also be used externally.
  /// Example code:{@sample external/icu/android_icu4j/src/samples/java/android/icu/samples/text/datetimepatterngenerator/DateTimePatternGeneratorSample.java replaceFieldTypesExample}
  ///@param pattern input pattern
  ///@param skeleton For the pattern to match to.
  ///@return pattern adjusted to match the skeleton fields widths and subtypes.
  jni.JniString replaceFieldTypes(
          jni.JniString pattern, jni.JniString skeleton) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_replaceFieldTypes,
          jni.JniType.objectType,
          [pattern.reference, skeleton.reference]).object);

  static final _id_replaceFieldTypes1 = jniAccessors.getMethodIDOf(
      _classRef,
      "replaceFieldTypes",
      "(Ljava/lang/String;Ljava/lang/String;I)Ljava/lang/String;");

  /// from: public java.lang.String replaceFieldTypes(java.lang.String pattern, java.lang.String skeleton, int options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adjusts the field types (width and subtype) of a pattern to match what is
  /// in a skeleton. That is, if you supply a pattern like "d-M H:m", and a
  /// skeleton of "MMMMddhhmm", then the input pattern is adjusted to be
  /// "dd-MMMM hh:mm". This is used internally to get the best match for the
  /// input skeleton, but can also be used externally.
  ///@param pattern input pattern
  ///@param skeleton For the pattern to match to.
  ///@param options MATCH_xxx options for forcing the length of specified fields in
  ///            the returned pattern to match those in the skeleton (when this would
  ///            not happen otherwise). For default behavior, use MATCH_NO_OPTIONS.
  ///@return pattern adjusted to match the skeleton fields widths and subtypes.
  jni.JniString replaceFieldTypes1(
          jni.JniString pattern, jni.JniString skeleton, int options) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_replaceFieldTypes1,
          jni.JniType.objectType,
          [pattern.reference, skeleton.reference, options]).object);

  static final _id_setDateTimeFormat = jniAccessors.getMethodIDOf(
      _classRef, "setDateTimeFormat", "(Ljava/lang/String;)V");

  /// from: public void setDateTimeFormat(java.lang.String dateTimeFormat)
  ///
  /// The date time format is a message format pattern used to compose date and
  /// time patterns. The default value is "{1} {0}", where {1} will be replaced
  /// by the date pattern and {0} will be replaced by the time pattern.
  ///
  /// This is used when the input skeleton contains both date and time fields,
  /// but there is not a close match among the added patterns. For example,
  /// suppose that this object was created by adding "dd-MMM" and "hh:mm", and
  /// its datetimeFormat is the default "{1} {0}". Then if the input skeleton
  /// is "MMMdhmm", there is not an exact match, so the input skeleton is
  /// broken up into two components "MMMd" and "hmm". There are close matches
  /// for those two skeletons, so the result is put together with this pattern,
  /// resulting in "d-MMM h:mm".
  ///@param dateTimeFormat message format pattern, where {1} will be replaced by the date
  ///            pattern and {0} will be replaced by the time pattern.
  void setDateTimeFormat(jni.JniString dateTimeFormat) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDateTimeFormat,
          jni.JniType.voidType, [dateTimeFormat.reference]).check();

  static final _id_getDateTimeFormat = jniAccessors.getMethodIDOf(
      _classRef, "getDateTimeFormat", "()Ljava/lang/String;");

  /// from: public java.lang.String getDateTimeFormat()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Getter corresponding to setDateTimeFormat.
  ///@return pattern
  jni.JniString getDateTimeFormat() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDateTimeFormat, jni.JniType.objectType, []).object);

  static final _id_setDecimal = jniAccessors.getMethodIDOf(
      _classRef, "setDecimal", "(Ljava/lang/String;)V");

  /// from: public void setDecimal(java.lang.String decimal)
  ///
  /// The decimal value is used in formatting fractions of seconds. If the
  /// skeleton contains fractional seconds, then this is used with the
  /// fractional seconds. For example, suppose that the input pattern is
  /// "hhmmssSSSS", and the best matching pattern internally is "H:mm:ss", and
  /// the decimal string is ",". Then the resulting pattern is modified to be
  /// "H:mm:ss,SSSS"
  ///@param decimal The decimal to set to.
  void setDecimal(jni.JniString decimal) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDecimal,
      jni.JniType.voidType,
      [decimal.reference]).check();

  static final _id_getDecimal = jniAccessors.getMethodIDOf(
      _classRef, "getDecimal", "()Ljava/lang/String;");

  /// from: public java.lang.String getDecimal()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Getter corresponding to setDecimal.
  ///@return string corresponding to the decimal point
  jni.JniString getDecimal() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDecimal, jni.JniType.objectType, []).object);

  static final _id_setAppendItemFormat = jniAccessors.getMethodIDOf(
      _classRef, "setAppendItemFormat", "(ILjava/lang/String;)V");

  /// from: public void setAppendItemFormat(int field, java.lang.String value)
  ///
  /// An AppendItem format is a pattern used to append a field if there is no
  /// good match. For example, suppose that the input skeleton is "GyyyyMMMd",
  /// and there is no matching pattern internally, but there is a pattern
  /// matching "yyyyMMMd", say "d-MM-yyyy". Then that pattern is used, plus the
  /// G. The way these two are conjoined is by using the AppendItemFormat for G
  /// (era). So if that value is, say "{0}, {1}" then the final resulting
  /// pattern is "d-MM-yyyy, G".
  ///
  /// There are actually three available variables: {0} is the pattern so far,
  /// {1} is the element we are adding, and {2} is the name of the element.
  ///
  /// This reflects the way that the CLDR data is organized.
  ///@param field such as ERA
  ///@param value pattern, such as "{0}, {1}"
  void setAppendItemFormat(int field, jni.JniString value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAppendItemFormat,
          jni.JniType.voidType, [field, value.reference]).check();

  static final _id_getAppendItemFormat = jniAccessors.getMethodIDOf(
      _classRef, "getAppendItemFormat", "(I)Ljava/lang/String;");

  /// from: public java.lang.String getAppendItemFormat(int field)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Getter corresponding to setAppendItemFormats. Values below 0 or at or
  /// above TYPE_LIMIT are illegal arguments.
  ///@param field The index to retrieve the append item formats.
  ///@return append pattern for field
  jni.JniString getAppendItemFormat(int field) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAppendItemFormat, jni.JniType.objectType, [field]).object);

  static final _id_setAppendItemName = jniAccessors.getMethodIDOf(
      _classRef, "setAppendItemName", "(ILjava/lang/String;)V");

  /// from: public void setAppendItemName(int field, java.lang.String value)
  ///
  /// Sets the names of fields, eg "era" in English for ERA. These are only
  /// used if the corresponding AppendItemFormat is used, and if it contains a
  /// {2} variable.
  ///
  /// This reflects the way that the CLDR data is organized.
  ///@param field Index of the append item names.
  ///@param value The value to set the item to.
  void setAppendItemName(int field, jni.JniString value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAppendItemName,
          jni.JniType.voidType, [field, value.reference]).check();

  static final _id_getAppendItemName = jniAccessors.getMethodIDOf(
      _classRef, "getAppendItemName", "(I)Ljava/lang/String;");

  /// from: public java.lang.String getAppendItemName(int field)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Getter corresponding to setAppendItemNames. Values below 0 or at or above
  /// TYPE_LIMIT are illegal arguments.
  ///@param field The index to get the append item name.
  ///@return name for field
  jni.JniString getAppendItemName(int field) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAppendItemName, jni.JniType.objectType, [field]).object);

  static final _id_isFrozen =
      jniAccessors.getMethodIDOf(_classRef, "isFrozen", "()Z");

  /// from: public boolean isFrozen()
  ///
  /// {@inheritDoc}
  bool isFrozen() => jniAccessors.callMethodWithArgs(
      reference, _id_isFrozen, jni.JniType.booleanType, []).boolean;

  static final _id_freeze = jniAccessors.getMethodIDOf(
      _classRef, "freeze", "()Landroid/icu/text/DateTimePatternGenerator;");

  /// from: public android.icu.text.DateTimePatternGenerator freeze()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  DateTimePatternGenerator freeze() =>
      DateTimePatternGenerator.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_freeze, jni.JniType.objectType, []).object);

  static final _id_cloneAsThawed = jniAccessors.getMethodIDOf(_classRef,
      "cloneAsThawed", "()Landroid/icu/text/DateTimePatternGenerator;");

  /// from: public android.icu.text.DateTimePatternGenerator cloneAsThawed()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  DateTimePatternGenerator cloneAsThawed() =>
      DateTimePatternGenerator.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_cloneAsThawed, jni.JniType.objectType, []).object);

  static final _id_clone =
      jniAccessors.getMethodIDOf(_classRef, "clone", "()Ljava/lang/Object;");

  /// from: public java.lang.Object clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a copy of this <code>DateTimePatternGenerator</code> object.
  ///@return A copy of this <code>DateTimePatternGenerator</code> object.
  jni.JniObject clone() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);
}

/// from: android.icu.text.DateTimePatternGenerator$PatternInfo
///
/// PatternInfo supplies output parameters for addPattern(...). It is used because
/// Java doesn't have real output parameters. It is treated like a struct (eg
/// Point), so all fields are public.
class DateTimePatternGenerator_PatternInfo extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/icu/text/DateTimePatternGenerator\$PatternInfo");
  DateTimePatternGenerator_PatternInfo.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final int BASE_CONFLICT
  ///
  ///
  static const BASE_CONFLICT = 1;

  /// from: static public final int CONFLICT
  ///
  ///
  static const CONFLICT = 2;

  /// from: static public final int OK
  ///
  ///
  static const OK = 0;

  static final _id_conflictingPattern = jniAccessors.getFieldIDOf(
      _classRef, "conflictingPattern", "Ljava/lang/String;");

  /// from: public java.lang.String conflictingPattern
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  jni.JniString get conflictingPattern => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_conflictingPattern, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String conflictingPattern
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  set conflictingPattern(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_conflictingPattern, value.reference);

  static final _id_status = jniAccessors.getFieldIDOf(_classRef, "status", "I");

  /// from: public int status
  ///
  ///
  int get status =>
      jniAccessors.getField(reference, _id_status, jni.JniType.intType).integer;

  /// from: public int status
  ///
  ///
  set status(int value) => jniEnv.SetIntField(reference, _id_status, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Simple constructor, since this is treated like a struct.
  DateTimePatternGenerator_PatternInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
