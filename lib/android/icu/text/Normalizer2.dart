// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Normalizer.dart" as normalizer_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.text.Normalizer2
///
/// Unicode normalization functionality for standard Unicode normalization or
/// for using custom mapping tables.
/// All instances of this class are unmodifiable/immutable.
/// The Normalizer2 class is not intended for public subclassing.
///
/// The primary functions are to produce a normalized string and to detect whether
/// a string is already normalized.
/// The most commonly used normalization forms are those defined in
/// http://www.unicode.org/unicode/reports/tr15/
/// However, this API supports additional normalization forms for specialized purposes.
/// For example, NFKC_Casefold is provided via getInstance("nfkc_cf", COMPOSE)
/// and can be used in implementations of UTS \#46.
///
/// Not only are the standard compose and decompose modes supplied,
/// but additional modes are provided as documented in the Mode enum.
///
/// Some of the functions in this class identify normalization boundaries.
/// At a normalization boundary, the portions of the string
/// before it and starting from it do not interact and can be handled independently.
///
/// The spanQuickCheckYes() stops at a normalization boundary.
/// When the goal is a normalized string, then the text before the boundary
/// can be copied, and the remainder can be processed with normalizeSecondAndAppend().
///
/// The hasBoundaryBefore(), hasBoundaryAfter() and isInert() functions test whether
/// a character is guaranteed to be at a normalization boundary,
/// regardless of context.
/// This is used for moving from one normalization boundary to the next
/// or preceding boundary, and for performing iterative normalization.
///
/// Iterative normalization is useful when only a small portion of a
/// longer string needs to be processed.
/// For example, in ICU, iterative normalization is used by the NormalizationTransliterator
/// (to avoid replacing already-normalized text) and ucol_nextSortKeyPart()
/// (to process only the substring for which sort key bytes are computed).
///
/// The set of normalization boundaries returned by these functions may not be
/// complete: There may be more boundaries that could be returned.
/// Different functions may return different boundaries.
///@author Markus W. Scherer
class Normalizer2 extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/Normalizer2");
  Normalizer2.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sole constructor.  (For invocation by subclass constructors,
  /// typically implicit.)
  ///@deprecated This API is ICU internal only.
  ///@hide original deprecated declaration
  ///@hide draft / provisional / internal are hidden on Android
  Normalizer2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getNFCInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getNFCInstance", "()Landroid/icu/text/Normalizer2;");

  /// from: static public android.icu.text.Normalizer2 getNFCInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Normalizer2 instance for Unicode NFC normalization.
  /// Same as getInstance(null, "nfc", Mode.COMPOSE).
  /// Returns an unmodifiable singleton instance.
  ///@return the requested Normalizer2, if successful
  static Normalizer2 getNFCInstance() =>
      Normalizer2.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getNFCInstance, jni.JniType.objectType, []).object);

  static final _id_getNFDInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getNFDInstance", "()Landroid/icu/text/Normalizer2;");

  /// from: static public android.icu.text.Normalizer2 getNFDInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Normalizer2 instance for Unicode NFD normalization.
  /// Same as getInstance(null, "nfc", Mode.DECOMPOSE).
  /// Returns an unmodifiable singleton instance.
  ///@return the requested Normalizer2, if successful
  static Normalizer2 getNFDInstance() =>
      Normalizer2.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getNFDInstance, jni.JniType.objectType, []).object);

  static final _id_getNFKCInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getNFKCInstance", "()Landroid/icu/text/Normalizer2;");

  /// from: static public android.icu.text.Normalizer2 getNFKCInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Normalizer2 instance for Unicode NFKC normalization.
  /// Same as getInstance(null, "nfkc", Mode.COMPOSE).
  /// Returns an unmodifiable singleton instance.
  ///@return the requested Normalizer2, if successful
  static Normalizer2 getNFKCInstance() =>
      Normalizer2.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getNFKCInstance, jni.JniType.objectType, []).object);

  static final _id_getNFKDInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getNFKDInstance", "()Landroid/icu/text/Normalizer2;");

  /// from: static public android.icu.text.Normalizer2 getNFKDInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Normalizer2 instance for Unicode NFKD normalization.
  /// Same as getInstance(null, "nfkc", Mode.DECOMPOSE).
  /// Returns an unmodifiable singleton instance.
  ///@return the requested Normalizer2, if successful
  static Normalizer2 getNFKDInstance() =>
      Normalizer2.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getNFKDInstance, jni.JniType.objectType, []).object);

  static final _id_getNFKCCasefoldInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getNFKCCasefoldInstance", "()Landroid/icu/text/Normalizer2;");

  /// from: static public android.icu.text.Normalizer2 getNFKCCasefoldInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Normalizer2 instance for Unicode NFKC_Casefold normalization.
  /// Same as getInstance(null, "nfkc_cf", Mode.COMPOSE).
  /// Returns an unmodifiable singleton instance.
  ///@return the requested Normalizer2, if successful
  static Normalizer2 getNFKCCasefoldInstance() =>
      Normalizer2.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getNFKCCasefoldInstance, jni.JniType.objectType, []).object);

  static final _id_getInstance = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getInstance",
      "(Ljava/io/InputStream;Ljava/lang/String;Landroid/icu/text/Normalizer2\$Mode;)Landroid/icu/text/Normalizer2;");

  /// from: static public android.icu.text.Normalizer2 getInstance(java.io.InputStream data, java.lang.String name, android.icu.text.Normalizer2.Mode mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Normalizer2 instance which uses the specified data file
  /// (an ICU data file if data=null, or else custom binary data)
  /// and which composes or decomposes text according to the specified mode.
  /// Returns an unmodifiable singleton instance.
  /// <ul>
  /// <li>Use data=null for data files that are part of ICU's own data.
  /// <li>Use name="nfc" and COMPOSE/DECOMPOSE for Unicode standard NFC/NFD.
  /// <li>Use name="nfkc" and COMPOSE/DECOMPOSE for Unicode standard NFKC/NFKD.
  /// <li>Use name="nfkc_cf" and COMPOSE for Unicode standard NFKC_CF=NFKC_Casefold.
  /// </ul>
  /// If data!=null, then the binary data is read once and cached using the provided
  /// name as the key.
  /// If you know or expect the data to be cached already, you can use data!=null
  /// for non-ICU data as well.
  /// Any java.io.IOException is wrapped into a android.icu.util.ICUUncheckedIOException.
  ///@param data the binary, big-endian normalization (.nrm file) data, or null for ICU data
  ///@param name "nfc" or "nfkc" or "nfkc_cf" or name of custom data file
  ///@param mode normalization mode (compose or decompose etc.)
  ///@return the requested Normalizer2, if successful
  static Normalizer2 getInstance(
          jni.JniObject data, jni.JniString name, Normalizer2_Mode mode) =>
      Normalizer2.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getInstance,
          jni.JniType.objectType,
          [data.reference, name.reference, mode.reference]).object);

  static final _id_normalize = jniAccessors.getMethodIDOf(
      _classRef, "normalize", "(Ljava/lang/CharSequence;)Ljava/lang/String;");

  /// from: public java.lang.String normalize(java.lang.CharSequence src)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the normalized form of the source string.
  ///@param src source string
  ///@return normalized src
  jni.JniString normalize(jni.JniObject src) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_normalize, jni.JniType.objectType, [src.reference]).object);

  static final _id_normalize1 = jniAccessors.getMethodIDOf(
      _classRef,
      "normalize",
      "(Ljava/lang/CharSequence;Ljava/lang/StringBuilder;)Ljava/lang/StringBuilder;");

  /// from: public abstract java.lang.StringBuilder normalize(java.lang.CharSequence src, java.lang.StringBuilder dest)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Writes the normalized form of the source string to the destination string
  /// (replacing its contents) and returns the destination string.
  /// The source and destination strings must be different objects.
  ///@param src source string
  ///@param dest destination string; its contents is replaced with normalized src
  ///@return dest
  jni.JniObject normalize1(jni.JniObject src, jni.JniObject dest) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_normalize1,
          jni.JniType.objectType,
          [src.reference, dest.reference]).object);

  static final _id_normalize2 = jniAccessors.getMethodIDOf(
      _classRef,
      "normalize",
      "(Ljava/lang/CharSequence;Ljava/lang/Appendable;)Ljava/lang/Appendable;");

  /// from: public abstract java.lang.Appendable normalize(java.lang.CharSequence src, java.lang.Appendable dest)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Writes the normalized form of the source string to the destination Appendable
  /// and returns the destination Appendable.
  /// The source and destination strings must be different objects.
  ///
  /// Any java.io.IOException is wrapped into a android.icu.util.ICUUncheckedIOException.
  ///@param src source string
  ///@param dest destination Appendable; gets normalized src appended
  ///@return dest
  jni.JniObject normalize2(jni.JniObject src, jni.JniObject dest) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_normalize2,
          jni.JniType.objectType,
          [src.reference, dest.reference]).object);

  static final _id_normalizeSecondAndAppend = jniAccessors.getMethodIDOf(
      _classRef,
      "normalizeSecondAndAppend",
      "(Ljava/lang/StringBuilder;Ljava/lang/CharSequence;)Ljava/lang/StringBuilder;");

  /// from: public abstract java.lang.StringBuilder normalizeSecondAndAppend(java.lang.StringBuilder first, java.lang.CharSequence second)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Appends the normalized form of the second string to the first string
  /// (merging them at the boundary) and returns the first string.
  /// The result is normalized if the first string was normalized.
  /// The first and second strings must be different objects.
  ///@param first string, should be normalized
  ///@param second string, will be normalized
  ///@return first
  jni.JniObject normalizeSecondAndAppend(
          jni.JniObject first, jni.JniObject second) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_normalizeSecondAndAppend,
          jni.JniType.objectType,
          [first.reference, second.reference]).object);

  static final _id_append = jniAccessors.getMethodIDOf(_classRef, "append",
      "(Ljava/lang/StringBuilder;Ljava/lang/CharSequence;)Ljava/lang/StringBuilder;");

  /// from: public abstract java.lang.StringBuilder append(java.lang.StringBuilder first, java.lang.CharSequence second)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Appends the second string to the first string
  /// (merging them at the boundary) and returns the first string.
  /// The result is normalized if both the strings were normalized.
  /// The first and second strings must be different objects.
  ///@param first string, should be normalized
  ///@param second string, should be normalized
  ///@return first
  jni.JniObject append(jni.JniObject first, jni.JniObject second) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_append,
          jni.JniType.objectType,
          [first.reference, second.reference]).object);

  static final _id_getDecomposition = jniAccessors.getMethodIDOf(
      _classRef, "getDecomposition", "(I)Ljava/lang/String;");

  /// from: public abstract java.lang.String getDecomposition(int c)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the decomposition mapping of c.
  /// Roughly equivalent to normalizing the String form of c
  /// on a DECOMPOSE Normalizer2 instance, but much faster, and except that this function
  /// returns null if c does not have a decomposition mapping in this instance's data.
  /// This function is independent of the mode of the Normalizer2.
  ///@param c code point
  ///@return c's decomposition mapping, if any; otherwise null
  jni.JniString getDecomposition(int c) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDecomposition, jni.JniType.objectType, [c]).object);

  static final _id_getRawDecomposition = jniAccessors.getMethodIDOf(
      _classRef, "getRawDecomposition", "(I)Ljava/lang/String;");

  /// from: public java.lang.String getRawDecomposition(int c)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the raw decomposition mapping of c.
  ///
  /// This is similar to the getDecomposition() method but returns the
  /// raw decomposition mapping as specified in UnicodeData.txt or
  /// (for custom data) in the mapping files processed by the gennorm2 tool.
  /// By contrast, getDecomposition() returns the processed,
  /// recursively-decomposed version of this mapping.
  ///
  /// When used on a standard NFKC Normalizer2 instance,
  /// getRawDecomposition() returns the Unicode Decomposition_Mapping (dm) property.
  ///
  /// When used on a standard NFC Normalizer2 instance,
  /// it returns the Decomposition_Mapping only if the Decomposition_Type (dt) is Canonical (Can);
  /// in this case, the result contains either one or two code points (=1..4 Java chars).
  ///
  /// This function is independent of the mode of the Normalizer2.
  /// The default implementation returns null.
  ///@param c code point
  ///@return c's raw decomposition mapping, if any; otherwise null
  jni.JniString getRawDecomposition(int c) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getRawDecomposition, jni.JniType.objectType, [c]).object);

  static final _id_composePair =
      jniAccessors.getMethodIDOf(_classRef, "composePair", "(II)I");

  /// from: public int composePair(int a, int b)
  ///
  /// Performs pairwise composition of a &amp; b and returns the composite if there is one.
  ///
  /// Returns a composite code point c only if c has a two-way mapping to a+b.
  /// In standard Unicode normalization, this means that
  /// c has a canonical decomposition to a+b
  /// and c does not have the Full_Composition_Exclusion property.
  ///
  /// This function is independent of the mode of the Normalizer2.
  /// The default implementation returns a negative value.
  ///@param a A (normalization starter) code point.
  ///@param b Another code point.
  ///@return The non-negative composite code point if there is one; otherwise a negative value.
  int composePair(int a, int b) => jniAccessors.callMethodWithArgs(
      reference, _id_composePair, jni.JniType.intType, [a, b]).integer;

  static final _id_getCombiningClass =
      jniAccessors.getMethodIDOf(_classRef, "getCombiningClass", "(I)I");

  /// from: public int getCombiningClass(int c)
  ///
  /// Gets the combining class of c.
  /// The default implementation returns 0
  /// but all standard implementations return the Unicode Canonical_Combining_Class value.
  ///@param c code point
  ///@return c's combining class
  int getCombiningClass(int c) => jniAccessors.callMethodWithArgs(
      reference, _id_getCombiningClass, jni.JniType.intType, [c]).integer;

  static final _id_isNormalized = jniAccessors.getMethodIDOf(
      _classRef, "isNormalized", "(Ljava/lang/CharSequence;)Z");

  /// from: public abstract boolean isNormalized(java.lang.CharSequence s)
  ///
  /// Tests if the string is normalized.
  /// Internally, in cases where the quickCheck() method would return "maybe"
  /// (which is only possible for the two COMPOSE modes) this method
  /// resolves to "yes" or "no" to provide a definitive result,
  /// at the cost of doing more work in those cases.
  ///@param s input string
  ///@return true if s is normalized
  bool isNormalized(jni.JniObject s) => jniAccessors.callMethodWithArgs(
      reference,
      _id_isNormalized,
      jni.JniType.booleanType,
      [s.reference]).boolean;

  static final _id_quickCheck = jniAccessors.getMethodIDOf(
      _classRef,
      "quickCheck",
      "(Ljava/lang/CharSequence;)Landroid/icu/text/Normalizer\$QuickCheckResult;");

  /// from: public abstract android.icu.text.Normalizer.QuickCheckResult quickCheck(java.lang.CharSequence s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Tests if the string is normalized.
  /// For the two COMPOSE modes, the result could be "maybe" in cases that
  /// would take a little more work to resolve definitively.
  /// Use spanQuickCheckYes() and normalizeSecondAndAppend() for a faster
  /// combination of quick check + normalization, to avoid
  /// re-checking the "yes" prefix.
  ///@param s input string
  ///@return the quick check result
  normalizer_.Normalizer_QuickCheckResult quickCheck(jni.JniObject s) =>
      normalizer_.Normalizer_QuickCheckResult.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_quickCheck, jni.JniType.objectType,
              [s.reference]).object);

  static final _id_spanQuickCheckYes = jniAccessors.getMethodIDOf(
      _classRef, "spanQuickCheckYes", "(Ljava/lang/CharSequence;)I");

  /// from: public abstract int spanQuickCheckYes(java.lang.CharSequence s)
  ///
  /// Returns the end of the normalized substring of the input string.
  /// In other words, with <code>end=spanQuickCheckYes(s);</code>
  /// the substring <code>s.subSequence(0, end)</code>
  /// will pass the quick check with a "yes" result.
  ///
  /// The returned end index is usually one or more characters before the
  /// "no" or "maybe" character: The end index is at a normalization boundary.
  /// (See the class documentation for more about normalization boundaries.)
  ///
  /// When the goal is a normalized string and most input strings are expected
  /// to be normalized already, then call this method,
  /// and if it returns a prefix shorter than the input string,
  /// copy that prefix and use normalizeSecondAndAppend() for the remainder.
  ///@param s input string
  ///@return "yes" span end index
  int spanQuickCheckYes(jni.JniObject s) => jniAccessors.callMethodWithArgs(
      reference,
      _id_spanQuickCheckYes,
      jni.JniType.intType,
      [s.reference]).integer;

  static final _id_hasBoundaryBefore =
      jniAccessors.getMethodIDOf(_classRef, "hasBoundaryBefore", "(I)Z");

  /// from: public abstract boolean hasBoundaryBefore(int c)
  ///
  /// Tests if the character always has a normalization boundary before it,
  /// regardless of context.
  /// If true, then the character does not normalization-interact with
  /// preceding characters.
  /// In other words, a string containing this character can be normalized
  /// by processing portions before this character and starting from this
  /// character independently.
  /// This is used for iterative normalization. See the class documentation for details.
  ///@param c character to test
  ///@return true if c has a normalization boundary before it
  bool hasBoundaryBefore(int c) => jniAccessors.callMethodWithArgs(
      reference, _id_hasBoundaryBefore, jni.JniType.booleanType, [c]).boolean;

  static final _id_hasBoundaryAfter =
      jniAccessors.getMethodIDOf(_classRef, "hasBoundaryAfter", "(I)Z");

  /// from: public abstract boolean hasBoundaryAfter(int c)
  ///
  /// Tests if the character always has a normalization boundary after it,
  /// regardless of context.
  /// If true, then the character does not normalization-interact with
  /// following characters.
  /// In other words, a string containing this character can be normalized
  /// by processing portions up to this character and after this
  /// character independently.
  /// This is used for iterative normalization. See the class documentation for details.
  ///
  /// Note that this operation may be significantly slower than hasBoundaryBefore().
  ///@param c character to test
  ///@return true if c has a normalization boundary after it
  bool hasBoundaryAfter(int c) => jniAccessors.callMethodWithArgs(
      reference, _id_hasBoundaryAfter, jni.JniType.booleanType, [c]).boolean;

  static final _id_isInert =
      jniAccessors.getMethodIDOf(_classRef, "isInert", "(I)Z");

  /// from: public abstract boolean isInert(int c)
  ///
  /// Tests if the character is normalization-inert.
  /// If true, then the character does not change, nor normalization-interact with
  /// preceding or following characters.
  /// In other words, a string containing this character can be normalized
  /// by processing portions before this character and after this
  /// character independently.
  /// This is used for iterative normalization. See the class documentation for details.
  ///
  /// Note that this operation may be significantly slower than hasBoundaryBefore().
  ///@param c character to test
  ///@return true if c is normalization-inert
  bool isInert(int c) => jniAccessors.callMethodWithArgs(
      reference, _id_isInert, jni.JniType.booleanType, [c]).boolean;
}

/// from: android.icu.text.Normalizer2$Mode
///
/// Constants for normalization modes.
/// For details about standard Unicode normalization forms
/// and about the algorithms which are also used with custom mapping tables
/// see http://www.unicode.org/unicode/reports/tr15/
class Normalizer2_Mode extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/Normalizer2\$Mode");
  Normalizer2_Mode.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/icu/text/Normalizer2\$Mode;");

  /// from: static public android.icu.text.Normalizer2.Mode[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/icu/text/Normalizer2\$Mode;");

  /// from: static public android.icu.text.Normalizer2.Mode valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Normalizer2_Mode valueOf(jni.JniString name) =>
      Normalizer2_Mode.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Normalizer2_Mode()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
