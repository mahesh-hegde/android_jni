// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../util/ULocale.dart" as ulocale_;

import "RuleBasedCollator.dart" as rulebasedcollator_;

import "UnicodeSet.dart" as unicodeset_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.text.AlphabeticIndex
///
/// AlphabeticIndex supports the creation of a UI index appropriate for a given language.
/// It can support either direct use, or use with a client that doesn't support localized collation.
/// The following is an example of what an index might look like in a UI:
///
/// <pre>
///  __... A B C D E F G H I J K L M N O P Q R S T U V W X Y Z  ...__
///
///  __A__
///     Addison
///     Albertson
///     Azensky
///  __B__
///     Baecker
///  ...
/// </pre>
///
/// The class can generate a list of labels for use as a UI "index", that is, a list of
/// clickable characters (or character sequences) that allow the user to see a segment
/// (bucket) of a larger "target" list. That is, each label corresponds to a bucket in
/// the target list, where everything in the bucket is greater than or equal to the character
/// (according to the locale's collation). Strings can be added to the index;
/// they will be in sorted order in the right bucket.
///
/// The class also supports having buckets for strings before the first (underflow),
/// after the last (overflow), and between scripts (inflow). For example, if the index
/// is constructed with labels for Russian and English, Greek characters would fall
/// into an inflow bucket between the other two scripts.
///
/// _Note:_ If you expect to have a lot of ASCII or Latin characters
/// as well as characters from the user's language,
/// then it is a good idea to call addLabels(ULocale.English).
///
/// <h2>Direct Use</h2>
/// The following shows an example of building an index directly.
///  The "show..." methods below are just to illustrate usage.
///
/// <pre>
/// // Create a simple index where the values for the strings are Integers, and add the strings
///
/// AlphabeticIndex&lt;Integer&gt; index = new AlphabeticIndex&lt;Integer&gt;(desiredLocale).addLabels(additionalLocale);
/// int counter = 0;
/// for (String item : test) {
///     index.addRecord(item, counter++);
/// }
/// ...
/// // Show index at top. We could skip or gray out empty buckets
///
/// for (AlphabeticIndex.Bucket&lt;Integer&gt; bucket : index) {
///     if (showAll || bucket.size() != 0) {
///         showLabelAtTop(UI, bucket.getLabel());
///     }
/// }
///  ...
/// // Show the buckets with their contents, skipping empty buckets
///
/// for (AlphabeticIndex.Bucket&lt;Integer&gt; bucket : index) {
///     if (bucket.size() != 0) {
///         showLabelInList(UI, bucket.getLabel());
///         for (AlphabeticIndex.Record&lt;Integer&gt; item : bucket) {
///             showIndexedItem(UI, item.getName(), item.getData());
///         }
/// </pre>
///
/// The caller can build different UIs using this class.
/// For example, an index character could be omitted or grayed-out
/// if its bucket is empty. Small buckets could also be combined based on size, such as:
///
/// <pre>
/// __... A-F G-N O-Z ...__
/// </pre>
///
/// <h2>Client Support</h2>
/// Callers can also use the AlphabeticIndex.ImmutableIndex, or the AlphabeticIndex itself,
/// to support sorting on a client that doesn't support AlphabeticIndex functionality.
///
/// The ImmutableIndex is both immutable and thread-safe.
/// The corresponding AlphabeticIndex methods are not thread-safe because
/// they "lazily" build the index buckets.
/// <ul>
/// <li>ImmutableIndex.getBucket(index) provides random access to all
///     buckets and their labels and label types.
/// <li>AlphabeticIndex.getBucketLabels() or the bucket iterator on either class
///     can be used to get a list of the labels,
///     such as "...", "A", "B",..., and send that list to the client.
/// <li>When the client has a new name, it sends that name to the server.
/// The server needs to call the following methods,
/// and communicate the bucketIndex and collationKey back to the client.
///
/// <pre>
/// int bucketIndex = index.getBucketIndex(name);
/// String label = immutableIndex.getBucket(bucketIndex).getLabel();  // optional
/// RawCollationKey collationKey = collator.getRawCollationKey(name, null);
/// </pre>
///
/// <li>The client would put the name (and associated information) into its bucket for bucketIndex. The collationKey is a
/// sequence of bytes that can be compared with a binary compare, and produce the right localized result.</li>
/// </ul>
///@author Mark Davis
class AlphabeticIndex extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/AlphabeticIndex");
  AlphabeticIndex.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/icu/util/ULocale;)V");

  /// from: public void <init>(android.icu.util.ULocale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create the index object.
  ///@param locale The locale for the index.
  AlphabeticIndex(ulocale_.ULocale locale)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [locale.reference]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/util/Locale;)V");

  /// from: public void <init>(java.util.Locale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create the index object.
  ///@param locale The locale for the index.
  AlphabeticIndex.ctor1(jni.JniObject locale)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [locale.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/icu/text/RuleBasedCollator;)V");

  /// from: public void <init>(android.icu.text.RuleBasedCollator collator)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an AlphabeticIndex that uses a specific collator.
  ///
  /// The index will be created with no labels; the addLabels() function must be called
  /// after creation to add the desired labels to the index.
  ///
  /// The index will work directly with the supplied collator. If the caller will need to
  /// continue working with the collator it should be cloned first, so that the
  /// collator provided to the AlphabeticIndex remains unchanged after creation of the index.
  ///@param collator The collator to use to order the contents of this index.
  AlphabeticIndex.ctor2(rulebasedcollator_.RuleBasedCollator collator)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [collator.reference]).object);

  static final _id_addLabels = jniAccessors.getMethodIDOf(
      _classRef,
      "addLabels",
      "(Landroid/icu/text/UnicodeSet;)Landroid/icu/text/AlphabeticIndex;");

  /// from: public android.icu.text.AlphabeticIndex<V> addLabels(android.icu.text.UnicodeSet additions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add more index characters (aside from what are in the locale)
  ///@param additions additional characters to add to the index, such as A-Z.
  ///@return this, for chaining
  AlphabeticIndex addLabels(unicodeset_.UnicodeSet additions) =>
      AlphabeticIndex.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_addLabels, jni.JniType.objectType, [additions.reference]).object);

  static final _id_addLabels1 = jniAccessors.getMethodIDOf(
      _classRef,
      "addLabels",
      "([Landroid/icu/util/ULocale;)Landroid/icu/text/AlphabeticIndex;");

  /// from: public android.icu.text.AlphabeticIndex<V> addLabels(android.icu.util.ULocale[] additions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add more index characters (aside from what are in the locale)
  ///@param additions additional characters to add to the index, such as those in Swedish.
  ///@return this, for chaining
  AlphabeticIndex addLabels1(jni.JniObject additions) =>
      AlphabeticIndex.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addLabels1,
          jni.JniType.objectType,
          [additions.reference]).object);

  static final _id_addLabels2 = jniAccessors.getMethodIDOf(_classRef,
      "addLabels", "([Ljava/util/Locale;)Landroid/icu/text/AlphabeticIndex;");

  /// from: public android.icu.text.AlphabeticIndex<V> addLabels(java.util.Locale[] additions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add more index characters (aside from what are in the locale)
  ///@param additions additional characters to add to the index, such as those in Swedish.
  ///@return this, for chaining
  AlphabeticIndex addLabels2(jni.JniObject additions) =>
      AlphabeticIndex.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addLabels2,
          jni.JniType.objectType,
          [additions.reference]).object);

  static final _id_setOverflowLabel = jniAccessors.getMethodIDOf(
      _classRef,
      "setOverflowLabel",
      "(Ljava/lang/String;)Landroid/icu/text/AlphabeticIndex;");

  /// from: public android.icu.text.AlphabeticIndex<V> setOverflowLabel(java.lang.String overflowLabel)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the overflow label
  ///@param overflowLabel see class description
  ///@return this, for chaining
  AlphabeticIndex setOverflowLabel(jni.JniString overflowLabel) =>
      AlphabeticIndex.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setOverflowLabel,
          jni.JniType.objectType,
          [overflowLabel.reference]).object);

  static final _id_getUnderflowLabel = jniAccessors.getMethodIDOf(
      _classRef, "getUnderflowLabel", "()Ljava/lang/String;");

  /// from: public java.lang.String getUnderflowLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the default label used in the IndexCharacters' locale for underflow, eg the last item in: X Y Z ...
  ///@return underflow label
  jni.JniString getUnderflowLabel() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getUnderflowLabel, jni.JniType.objectType, []).object);

  static final _id_setUnderflowLabel = jniAccessors.getMethodIDOf(
      _classRef,
      "setUnderflowLabel",
      "(Ljava/lang/String;)Landroid/icu/text/AlphabeticIndex;");

  /// from: public android.icu.text.AlphabeticIndex<V> setUnderflowLabel(java.lang.String underflowLabel)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the underflowLabel label
  ///@param underflowLabel see class description
  ///@return this, for chaining
  AlphabeticIndex setUnderflowLabel(jni.JniString underflowLabel) =>
      AlphabeticIndex.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setUnderflowLabel,
          jni.JniType.objectType,
          [underflowLabel.reference]).object);

  static final _id_getOverflowLabel = jniAccessors.getMethodIDOf(
      _classRef, "getOverflowLabel", "()Ljava/lang/String;");

  /// from: public java.lang.String getOverflowLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the default label used in the IndexCharacters' locale for overflow, eg the first item in: ... A B C
  ///@return overflow label
  jni.JniString getOverflowLabel() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getOverflowLabel, jni.JniType.objectType, []).object);

  static final _id_setInflowLabel = jniAccessors.getMethodIDOf(
      _classRef,
      "setInflowLabel",
      "(Ljava/lang/String;)Landroid/icu/text/AlphabeticIndex;");

  /// from: public android.icu.text.AlphabeticIndex<V> setInflowLabel(java.lang.String inflowLabel)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the inflowLabel label
  ///@param inflowLabel see class description
  ///@return this, for chaining
  AlphabeticIndex setInflowLabel(jni.JniString inflowLabel) =>
      AlphabeticIndex.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setInflowLabel,
          jni.JniType.objectType,
          [inflowLabel.reference]).object);

  static final _id_getInflowLabel = jniAccessors.getMethodIDOf(
      _classRef, "getInflowLabel", "()Ljava/lang/String;");

  /// from: public java.lang.String getInflowLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the default label used for abbreviated buckets <i>between</i> other labels. For example, consider the labels
  /// for Latin and Greek are used: X Y Z ... &\#x0391; &\#x0392; &\#x0393;.
  ///@return inflow label
  jni.JniString getInflowLabel() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getInflowLabel, jni.JniType.objectType, []).object);

  static final _id_getMaxLabelCount =
      jniAccessors.getMethodIDOf(_classRef, "getMaxLabelCount", "()I");

  /// from: public int getMaxLabelCount()
  ///
  /// Get the limit on the number of labels in the index. The number of buckets can be slightly larger: see getBucketCount().
  ///@return maxLabelCount maximum number of labels.
  int getMaxLabelCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxLabelCount, jni.JniType.intType, []).integer;

  static final _id_setMaxLabelCount = jniAccessors.getMethodIDOf(
      _classRef, "setMaxLabelCount", "(I)Landroid/icu/text/AlphabeticIndex;");

  /// from: public android.icu.text.AlphabeticIndex<V> setMaxLabelCount(int maxLabelCount)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a limit on the number of labels in the index. The number of buckets can be slightly larger: see
  /// getBucketCount().
  ///@param maxLabelCount Set the maximum number of labels. Currently, if the number is exceeded, then every
  ///         nth item is removed to bring the count down. A more sophisticated mechanism may be available in the
  ///         future.
  ///@return this, for chaining
  AlphabeticIndex setMaxLabelCount(int maxLabelCount) =>
      AlphabeticIndex.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setMaxLabelCount,
          jni.JniType.objectType,
          [maxLabelCount]).object);

  static final _id_buildImmutableIndex = jniAccessors.getMethodIDOf(
      _classRef,
      "buildImmutableIndex",
      "()Landroid/icu/text/AlphabeticIndex\$ImmutableIndex;");

  /// from: public android.icu.text.AlphabeticIndex.ImmutableIndex<V> buildImmutableIndex()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Builds an immutable, thread-safe version of this instance, without data records.
  ///@return an immutable index instance
  AlphabeticIndex_ImmutableIndex buildImmutableIndex() =>
      AlphabeticIndex_ImmutableIndex.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_buildImmutableIndex,
          jni.JniType.objectType, []).object);

  static final _id_getBucketLabels = jniAccessors.getMethodIDOf(
      _classRef, "getBucketLabels", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getBucketLabels()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the labels.
  ///@return The list of bucket labels, after processing.
  jni.JniObject getBucketLabels() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBucketLabels, jni.JniType.objectType, []).object);

  static final _id_getCollator = jniAccessors.getMethodIDOf(
      _classRef, "getCollator", "()Landroid/icu/text/RuleBasedCollator;");

  /// from: public android.icu.text.RuleBasedCollator getCollator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a clone of the collator used internally. Note that for performance reasons, the clone is only done once, and
  /// then stored. The next time it is accessed, the same instance is returned.
  ///
  /// __<i>Don't use this method across threads if you are changing the settings on the collator, at least not without
  /// synchronizing.</i>__
  ///@return a clone of the collator used internally
  rulebasedcollator_.RuleBasedCollator getCollator() =>
      rulebasedcollator_.RuleBasedCollator.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getCollator, jni.JniType.objectType, []).object);

  static final _id_getBucketIndex = jniAccessors.getMethodIDOf(
      _classRef, "getBucketIndex", "(Ljava/lang/CharSequence;)I");

  /// from: public int getBucketIndex(java.lang.CharSequence name)
  ///
  /// Get the bucket number for the given name. This routine permits callers to implement their own bucket handling
  /// mechanisms, including client-server handling. For example, when a new name is created on the client, it can ask
  /// the server for the bucket for that name, and the sortkey (using getCollator). Once the client has that
  /// information, it can put the name into the right bucket, and sort it within that bucket, without having access to
  /// the index or collator.
  ///
  /// Note that the bucket number (and sort key) are only valid for the settings of the current AlphabeticIndex; if
  /// those are changed, then the bucket number and sort key must be regenerated.
  ///@param name Name, such as a name
  ///@return the bucket index for the name
  int getBucketIndex(jni.JniObject name) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getBucketIndex,
      jni.JniType.intType,
      [name.reference]).integer;

  static final _id_clearRecords = jniAccessors.getMethodIDOf(
      _classRef, "clearRecords", "()Landroid/icu/text/AlphabeticIndex;");

  /// from: public android.icu.text.AlphabeticIndex<V> clearRecords()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Clear the index.
  ///@return this, for chaining
  AlphabeticIndex clearRecords() =>
      AlphabeticIndex.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clearRecords, jni.JniType.objectType, []).object);

  static final _id_getBucketCount =
      jniAccessors.getMethodIDOf(_classRef, "getBucketCount", "()I");

  /// from: public int getBucketCount()
  ///
  /// Return the number of buckets in the index. This will be the same as the number of labels, plus buckets for the underflow, overflow, and inflow(s).
  ///@return number of buckets
  int getBucketCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getBucketCount, jni.JniType.intType, []).integer;

  static final _id_getRecordCount =
      jniAccessors.getMethodIDOf(_classRef, "getRecordCount", "()I");

  /// from: public int getRecordCount()
  ///
  /// Return the number of records in the index: that is, the total number of distinct &lt;name,data&gt; pairs added with addRecord(...), over all the buckets.
  ///@return total number of records in buckets
  int getRecordCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getRecordCount, jni.JniType.intType, []).integer;

  static final _id_iterator = jniAccessors.getMethodIDOf(
      _classRef, "iterator", "()Ljava/util/Iterator;");

  /// from: public java.util.Iterator<android.icu.text.AlphabeticIndex.Bucket<V>> iterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an iterator over the buckets.
  ///@return iterator over buckets.
  jni.JniObject iterator() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_iterator, jni.JniType.objectType, []).object);
}

/// from: android.icu.text.AlphabeticIndex$Record
///
/// A (name, data) pair, to be sorted by name into one of the index buckets.
/// The user data is not used by the index implementation.
class AlphabeticIndex_Record extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/AlphabeticIndex\$Record");
  AlphabeticIndex_Record.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getName = jniAccessors.getMethodIDOf(
      _classRef, "getName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the name
  ///@return the name
  jni.JniObject getName() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard toString()
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.icu.text.AlphabeticIndex$ImmutableIndex
///
/// Immutable, thread-safe version of AlphabeticIndex.
/// This class provides thread-safe methods for bucketing,
/// and random access to buckets and their properties,
/// but does not offer adding records to the index.
///@param <V> The Record value type is unused. It can be omitted for this class
/// if it was omitted for the AlphabeticIndex that built it.
class AlphabeticIndex_ImmutableIndex extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/icu/text/AlphabeticIndex\$ImmutableIndex");
  AlphabeticIndex_ImmutableIndex.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getBucketCount =
      jniAccessors.getMethodIDOf(_classRef, "getBucketCount", "()I");

  /// from: public int getBucketCount()
  ///
  /// Returns the number of index buckets and labels, including underflow/inflow/overflow.
  ///@return the number of index buckets
  int getBucketCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getBucketCount, jni.JniType.intType, []).integer;

  static final _id_getBucketIndex = jniAccessors.getMethodIDOf(
      _classRef, "getBucketIndex", "(Ljava/lang/CharSequence;)I");

  /// from: public int getBucketIndex(java.lang.CharSequence name)
  ///
  /// Finds the index bucket for the given name and returns the number of that bucket.
  /// Use \#getBucket(int) to get the bucket's properties.
  ///@param name the string to be sorted into an index bucket
  ///@return the bucket number for the name
  int getBucketIndex(jni.JniObject name) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getBucketIndex,
      jni.JniType.intType,
      [name.reference]).integer;

  static final _id_getBucket = jniAccessors.getMethodIDOf(
      _classRef, "getBucket", "(I)Landroid/icu/text/AlphabeticIndex\$Bucket;");

  /// from: public android.icu.text.AlphabeticIndex.Bucket<V> getBucket(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the index-th bucket. Returns null if the index is out of range.
  ///@param index bucket number
  ///@return the index-th bucket
  AlphabeticIndex_Bucket getBucket(int index) =>
      AlphabeticIndex_Bucket.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBucket, jni.JniType.objectType, [index]).object);

  static final _id_iterator = jniAccessors.getMethodIDOf(
      _classRef, "iterator", "()Ljava/util/Iterator;");

  /// from: public java.util.Iterator<android.icu.text.AlphabeticIndex.Bucket<V>> iterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniObject iterator() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_iterator, jni.JniType.objectType, []).object);
}

/// from: android.icu.text.AlphabeticIndex$Bucket
///
/// An index "bucket" with a label string and type.
/// It is referenced by AlphabeticIndex\#getBucketIndex(CharSequence)
/// and AlphabeticIndex.ImmutableIndex\#getBucketIndex(CharSequence),
/// returned by AlphabeticIndex.ImmutableIndex\#getBucket(int),
/// and AlphabeticIndex\#addRecord(CharSequence, Object) adds a record
/// into a bucket according to the record's name.
///@param <V> Data type
class AlphabeticIndex_Bucket extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/AlphabeticIndex\$Bucket");
  AlphabeticIndex_Bucket.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getLabel =
      jniAccessors.getMethodIDOf(_classRef, "getLabel", "()Ljava/lang/String;");

  /// from: public java.lang.String getLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the label
  ///@return label for the bucket
  jni.JniString getLabel() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLabel, jni.JniType.objectType, []).object);

  static final _id_getLabelType = jniAccessors.getMethodIDOf(
      _classRef,
      "getLabelType",
      "()Landroid/icu/text/AlphabeticIndex\$Bucket\$LabelType;");

  /// from: public android.icu.text.AlphabeticIndex.Bucket.LabelType getLabelType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Is a normal, underflow, overflow, or inflow bucket
  ///@return is an underflow, overflow, or inflow bucket
  AlphabeticIndex_Bucket_LabelType getLabelType() =>
      AlphabeticIndex_Bucket_LabelType.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLabelType, jni.JniType.objectType, []).object);

  static final _id_size = jniAccessors.getMethodIDOf(_classRef, "size", "()I");

  /// from: public int size()
  ///
  /// Get the number of records in the bucket.
  ///@return number of records in bucket
  int size() => jniAccessors
      .callMethodWithArgs(reference, _id_size, jni.JniType.intType, []).integer;

  static final _id_iterator = jniAccessors.getMethodIDOf(
      _classRef, "iterator", "()Ljava/util/Iterator;");

  /// from: public java.util.Iterator<android.icu.text.AlphabeticIndex.Record<V>> iterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Iterator over the records in the bucket
  jni.JniObject iterator() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_iterator, jni.JniType.objectType, []).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard toString()
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.icu.text.AlphabeticIndex$Bucket$LabelType
///
/// Type of the label
class AlphabeticIndex_Bucket_LabelType extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/icu/text/AlphabeticIndex\$Bucket\$LabelType");
  AlphabeticIndex_Bucket_LabelType.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(_classRef,
      "values", "()[Landroid/icu/text/AlphabeticIndex\$Bucket\$LabelType;");

  /// from: static public android.icu.text.AlphabeticIndex.Bucket.LabelType[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/icu/text/AlphabeticIndex\$Bucket\$LabelType;");

  /// from: static public android.icu.text.AlphabeticIndex.Bucket.LabelType valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static AlphabeticIndex_Bucket_LabelType valueOf(jni.JniString name) =>
      AlphabeticIndex_Bucket_LabelType.fromRef(jniAccessors
          .callStaticMethodWithArgs(_classRef, _id_valueOf,
              jni.JniType.objectType, [name.reference]).object);
}
