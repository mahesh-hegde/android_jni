// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.text.IDNA
///
/// Abstract base class for IDNA processing.
/// See http://www.unicode.org/reports/tr46/
/// and http://www.ietf.org/rfc/rfc3490.txt
///
/// The IDNA class is not intended for public subclassing.
///
/// The non-static methods implement UTS \#46 and IDNA2008.
/// IDNA2008 is implemented according to UTS \#46, see getUTS46Instance().
///
/// IDNA2003 is obsolete. The static methods implement IDNA2003. They are all deprecated.
///
/// IDNA2003 API Overview:
///
/// The static IDNA API methods implement the IDNA protocol as defined in the
/// <a href="http://www.ietf.org/rfc/rfc3490.txt">IDNA RFC</a>.
/// The draft defines 2 operations: ToASCII and ToUnicode. Domain labels
/// containing non-ASCII code points are required to be processed by
/// ToASCII operation before passing it to resolver libraries. Domain names
/// that are obtained from resolver libraries are required to be processed by
/// ToUnicode operation before displaying the domain name to the user.
/// IDNA requires that implementations process input strings with
/// <a href="http://www.ietf.org/rfc/rfc3491.txt">Nameprep</a>,
/// which is a profile of <a href="http://www.ietf.org/rfc/rfc3454.txt">Stringprep</a> ,
/// and then with <a href="http://www.ietf.org/rfc/rfc3492.txt">Punycode</a>.
/// Implementations of IDNA MUST fully implement Nameprep and Punycode;
/// neither Nameprep nor Punycode are optional.
/// The input and output of ToASCII and ToUnicode operations are Unicode
/// and are designed to be chainable, i.e., applying ToASCII or ToUnicode operations
/// multiple times to an input string will yield the same result as applying the operation
/// once.
/// ToUnicode(ToUnicode(ToUnicode...(ToUnicode(string)))) == ToUnicode(string)
/// ToASCII(ToASCII(ToASCII...(ToASCII(string))) == ToASCII(string).
///@author Ram Viswanadha, Markus Scherer
class IDNA extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/icu/text/IDNA");
  IDNA.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CHECK_BIDI
  ///
  /// IDNA option to check for whether the input conforms to the BiDi rules.
  /// For use in static worker and factory methods.
  /// This option is ignored by the IDNA2003 implementation.
  /// (IDNA2003 always performs a BiDi check.)
  static const CHECK_BIDI = 4;

  /// from: static public final int CHECK_CONTEXTJ
  ///
  /// IDNA option to check for whether the input conforms to the CONTEXTJ rules.
  /// For use in static worker and factory methods.
  /// This option is ignored by the IDNA2003 implementation.
  /// (The CONTEXTJ check is new in IDNA2008.)
  static const CHECK_CONTEXTJ = 8;

  /// from: static public final int CHECK_CONTEXTO
  ///
  /// IDNA option to check for whether the input conforms to the CONTEXTO rules.
  /// For use in static worker and factory methods.
  /// This option is ignored by the IDNA2003 implementation.
  /// (The CONTEXTO check is new in IDNA2008.)
  /// This is for use by registries for IDNA2008 conformance.
  /// UTS \#46 does not require the CONTEXTO check.
  static const CHECK_CONTEXTO = 64;

  /// from: static public final int DEFAULT
  ///
  /// Default options value: None of the other options are set.
  /// For use in static worker and factory methods.
  static const DEFAULT = 0;

  /// from: static public final int NONTRANSITIONAL_TO_ASCII
  ///
  /// IDNA option for nontransitional processing in ToASCII().
  /// For use in static worker and factory methods.
  /// By default, ToASCII() uses transitional processing.
  /// This option is ignored by the IDNA2003 implementation.
  /// (This is only relevant for compatibility of newer IDNA implementations with IDNA2003.)
  static const NONTRANSITIONAL_TO_ASCII = 16;

  /// from: static public final int NONTRANSITIONAL_TO_UNICODE
  ///
  /// IDNA option for nontransitional processing in ToUnicode().
  /// For use in static worker and factory methods.
  /// By default, ToUnicode() uses transitional processing.
  /// This option is ignored by the IDNA2003 implementation.
  /// (This is only relevant for compatibility of newer IDNA implementations with IDNA2003.)
  static const NONTRANSITIONAL_TO_UNICODE = 32;

  /// from: static public final int USE_STD3_RULES
  ///
  /// Option to check whether the input conforms to the STD3 ASCII rules,
  /// for example the restriction of labels to LDH characters
  /// (ASCII Letters, Digits and Hyphen-Minus).
  /// For use in static worker and factory methods.
  static const USE_STD3_RULES = 2;

  static final _id_getUTS46Instance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getUTS46Instance", "(I)Landroid/icu/text/IDNA;");

  /// from: static public android.icu.text.IDNA getUTS46Instance(int options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an IDNA instance which implements UTS \#46.
  /// Returns an unmodifiable instance, owned by the caller.
  /// Cache it for multiple operations, and delete it when done.
  /// The instance is thread-safe, that is, it can be used concurrently.
  ///
  /// UTS \#46 defines Unicode IDNA Compatibility Processing,
  /// updated to the latest version of Unicode and compatible with both
  /// IDNA2003 and IDNA2008.
  ///
  /// The worker functions use transitional processing, including deviation mappings,
  /// unless NONTRANSITIONAL_TO_ASCII or NONTRANSITIONAL_TO_UNICODE
  /// is used in which case the deviation characters are passed through without change.
  ///
  /// Disallowed characters are mapped to U+FFFD.
  ///
  /// Operations with the UTS \#46 instance do not support the
  /// ALLOW_UNASSIGNED option.
  ///
  /// By default, the UTS \#46 implementation allows all ASCII characters (as valid or mapped).
  /// When the USE_STD3_RULES option is used, ASCII characters other than
  /// letters, digits, hyphen (LDH) and dot/full stop are disallowed and mapped to U+FFFD.
  ///@param options Bit set to modify the processing and error checking.
  ///@return the UTS \#46 IDNA instance, if successful
  static IDNA getUTS46Instance(int options) =>
      IDNA.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getUTS46Instance, jni.JniType.objectType, [options]).object);

  static final _id_labelToASCII = jniAccessors.getMethodIDOf(
      _classRef,
      "labelToASCII",
      "(Ljava/lang/CharSequence;Ljava/lang/StringBuilder;Landroid/icu/text/IDNA\$Info;)Ljava/lang/StringBuilder;");

  /// from: public abstract java.lang.StringBuilder labelToASCII(java.lang.CharSequence label, java.lang.StringBuilder dest, android.icu.text.IDNA.Info info)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Converts a single domain name label into its ASCII form for DNS lookup.
  /// If any processing step fails, then info.hasErrors() will be true and
  /// the result might not be an ASCII string.
  /// The label might be modified according to the types of errors.
  /// Labels with severe errors will be left in (or turned into) their Unicode form.
  ///@param label Input domain name label
  ///@param dest Destination string object
  ///@param info Output container of IDNA processing details.
  ///@return dest
  jni.JniObject labelToASCII(
          jni.JniObject label, jni.JniObject dest, IDNA_Info info) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_labelToASCII,
          jni.JniType.objectType,
          [label.reference, dest.reference, info.reference]).object);

  static final _id_labelToUnicode = jniAccessors.getMethodIDOf(
      _classRef,
      "labelToUnicode",
      "(Ljava/lang/CharSequence;Ljava/lang/StringBuilder;Landroid/icu/text/IDNA\$Info;)Ljava/lang/StringBuilder;");

  /// from: public abstract java.lang.StringBuilder labelToUnicode(java.lang.CharSequence label, java.lang.StringBuilder dest, android.icu.text.IDNA.Info info)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Converts a single domain name label into its Unicode form for human-readable display.
  /// If any processing step fails, then info.hasErrors() will be true.
  /// The label might be modified according to the types of errors.
  ///@param label Input domain name label
  ///@param dest Destination string object
  ///@param info Output container of IDNA processing details.
  ///@return dest
  jni.JniObject labelToUnicode(
          jni.JniObject label, jni.JniObject dest, IDNA_Info info) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_labelToUnicode,
          jni.JniType.objectType,
          [label.reference, dest.reference, info.reference]).object);

  static final _id_nameToASCII = jniAccessors.getMethodIDOf(
      _classRef,
      "nameToASCII",
      "(Ljava/lang/CharSequence;Ljava/lang/StringBuilder;Landroid/icu/text/IDNA\$Info;)Ljava/lang/StringBuilder;");

  /// from: public abstract java.lang.StringBuilder nameToASCII(java.lang.CharSequence name, java.lang.StringBuilder dest, android.icu.text.IDNA.Info info)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Converts a whole domain name into its ASCII form for DNS lookup.
  /// If any processing step fails, then info.hasErrors() will be true and
  /// the result might not be an ASCII string.
  /// The domain name might be modified according to the types of errors.
  /// Labels with severe errors will be left in (or turned into) their Unicode form.
  ///@param name Input domain name
  ///@param dest Destination string object
  ///@param info Output container of IDNA processing details.
  ///@return dest
  jni.JniObject nameToASCII(
          jni.JniObject name, jni.JniObject dest, IDNA_Info info) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_nameToASCII,
          jni.JniType.objectType,
          [name.reference, dest.reference, info.reference]).object);

  static final _id_nameToUnicode = jniAccessors.getMethodIDOf(
      _classRef,
      "nameToUnicode",
      "(Ljava/lang/CharSequence;Ljava/lang/StringBuilder;Landroid/icu/text/IDNA\$Info;)Ljava/lang/StringBuilder;");

  /// from: public abstract java.lang.StringBuilder nameToUnicode(java.lang.CharSequence name, java.lang.StringBuilder dest, android.icu.text.IDNA.Info info)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Converts a whole domain name into its Unicode form for human-readable display.
  /// If any processing step fails, then info.hasErrors() will be true.
  /// The domain name might be modified according to the types of errors.
  ///@param name Input domain name
  ///@param dest Destination string object
  ///@param info Output container of IDNA processing details.
  ///@return dest
  jni.JniObject nameToUnicode(
          jni.JniObject name, jni.JniObject dest, IDNA_Info info) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_nameToUnicode,
          jni.JniType.objectType,
          [name.reference, dest.reference, info.reference]).object);
}

/// from: android.icu.text.IDNA$Info
///
/// Output container for IDNA processing errors.
/// The Info class is not suitable for subclassing.
class IDNA_Info extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/IDNA\$Info");
  IDNA_Info.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor.
  IDNA_Info()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_hasErrors =
      jniAccessors.getMethodIDOf(_classRef, "hasErrors", "()Z");

  /// from: public boolean hasErrors()
  ///
  /// Were there IDNA processing errors?
  ///@return true if there were processing errors
  bool hasErrors() => jniAccessors.callMethodWithArgs(
      reference, _id_hasErrors, jni.JniType.booleanType, []).boolean;

  static final _id_getErrors =
      jniAccessors.getMethodIDOf(_classRef, "getErrors", "()Ljava/util/Set;");

  /// from: public java.util.Set<android.icu.text.IDNA.Error> getErrors()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a set indicating IDNA processing errors.
  ///@return set of processing errors (modifiable, and not null)
  jni.JniObject getErrors() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getErrors, jni.JniType.objectType, []).object);

  static final _id_isTransitionalDifferent =
      jniAccessors.getMethodIDOf(_classRef, "isTransitionalDifferent", "()Z");

  /// from: public boolean isTransitionalDifferent()
  ///
  /// Returns true if transitional and nontransitional processing produce different results.
  /// This is the case when the input label or domain name contains
  /// one or more deviation characters outside a Punycode label (see UTS \#46).
  /// <ul>
  /// <li>With nontransitional processing, such characters are
  /// copied to the destination string.
  /// <li>With transitional processing, such characters are
  /// mapped (sharp s/sigma) or removed (joiner/nonjoiner).
  /// </ul>
  ///@return true if transitional and nontransitional processing produce different results
  bool isTransitionalDifferent() => jniAccessors.callMethodWithArgs(reference,
      _id_isTransitionalDifferent, jni.JniType.booleanType, []).boolean;
}

/// from: android.icu.text.IDNA$Error
///
/// IDNA error bit set values.
/// When a domain name or label fails a processing step or does not meet the
/// validity criteria, then one or more of these error bits are set.
class IDNA_Error extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/IDNA\$Error");
  IDNA_Error.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/icu/text/IDNA\$Error;");

  /// from: static public android.icu.text.IDNA.Error[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/icu/text/IDNA\$Error;");

  /// from: static public android.icu.text.IDNA.Error valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static IDNA_Error valueOf(jni.JniString name) =>
      IDNA_Error.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);
}
