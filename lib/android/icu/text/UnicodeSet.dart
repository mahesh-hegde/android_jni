// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "UnicodeFilter.dart" as unicodefilter_;

import "SymbolTable.dart" as symboltable_;

import "Replaceable.dart" as replaceable_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.text.UnicodeSet
///
/// A mutable set of Unicode characters and multicharacter strings.
/// Objects of this class represent _character classes_ used
/// in regular expressions. A character specifies a subset of Unicode
/// code points.  Legal code points are U+0000 to U+10FFFF, inclusive.
///
/// Note: method freeze() will not only make the set immutable, but
/// also makes important methods much higher performance:
/// contains(c), containsNone(...), span(...), spanBack(...) etc.
/// After the object is frozen, any subsequent call that wants to change
/// the object will throw UnsupportedOperationException.
///
/// The UnicodeSet class is not designed to be subclassed.
///
/// <code>UnicodeSet</code> supports two APIs. The first is the
/// _operand_ API that allows the caller to modify the value of
/// a <code>UnicodeSet</code> object. It conforms to Java 2's
/// <code>java.util.Set</code> interface, although
/// <code>UnicodeSet</code> does not actually implement that
/// interface. All methods of <code>Set</code> are supported, with the
/// modification that they take a character range or single character
/// instead of an <code>Object</code>, and they take a
/// <code>UnicodeSet</code> instead of a <code>Collection</code>.  The
/// operand API may be thought of in terms of boolean logic: a boolean
/// OR is implemented by <code>add</code>, a boolean AND is implemented
/// by <code>retain</code>, a boolean XOR is implemented by
/// <code>complement</code> taking an argument, and a boolean NOT is
/// implemented by <code>complement</code> with no argument.  In terms
/// of traditional set theory function names, <code>add</code> is a
/// union, <code>retain</code> is an intersection, <code>remove</code>
/// is an asymmetric difference, and <code>complement</code> with no
/// argument is a set complement with respect to the superset range
/// <code>MIN_VALUE-MAX_VALUE</code>
///
/// The second API is the
/// <code>applyPattern()</code>/<code>toPattern()</code> API from the
/// <code>java.text.Format</code>-derived classes.  Unlike the
/// methods that add characters, add categories, and control the logic
/// of the set, the method <code>applyPattern()</code> sets all
/// attributes of a <code>UnicodeSet</code> at once, based on a
/// string pattern.
///
/// __Pattern syntax__
///
///
/// Patterns are accepted by the constructors and the
/// <code>applyPattern()</code> methods and returned by the
/// <code>toPattern()</code> method.  These patterns follow a syntax
/// similar to that employed by version 8 regular expression character
/// classes.  Here are some simple examples:
///
/// <blockquote>
///   <table>
///     <tr style="vertical-align: top">
///       <td style="white-space: nowrap; vertical-align: top; horizontal-align: left;"><code>[]</code></td>
///       <td style="vertical-align: top;">No characters</td>
///     </tr><tr style="vertical-align: top">
///       <td style="white-space: nowrap; vertical-align: top; horizontal-align: left;"><code>[a]</code></td>
///       <td style="vertical-align: top;">The character 'a'</td>
///     </tr><tr style="vertical-align: top">
///       <td style="white-space: nowrap; vertical-align: top; horizontal-align: left;"><code>[ae]</code></td>
///       <td style="vertical-align: top;">The characters 'a' and 'e'</td>
///     </tr>
///     <tr>
///       <td style="white-space: nowrap; vertical-align: top; horizontal-align: left;"><code>[a-e]</code></td>
///       <td style="vertical-align: top;">The characters 'a' through 'e' inclusive, in Unicode code
///       point order</td>
///     </tr>
///     <tr>
///       <td style="white-space: nowrap; vertical-align: top; horizontal-align: left;"><code>[\\u4E01]</code></td>
///       <td style="vertical-align: top;">The character U+4E01</td>
///     </tr>
///     <tr>
///       <td style="white-space: nowrap; vertical-align: top; horizontal-align: left;"><code>[a{ab}{ac}]</code></td>
///       <td style="vertical-align: top;">The character 'a' and the multicharacter strings &quot;ab&quot; and
///       &quot;ac&quot;</td>
///     </tr>
///     <tr>
///       <td style="white-space: nowrap; vertical-align: top; horizontal-align: left;"><code>[\p{Lu}]</code></td>
///       <td style="vertical-align: top;">All characters in the general category Uppercase Letter</td>
///     </tr>
///   </table>
/// </blockquote>
///
/// Any character may be preceded by a backslash in order to remove any special
/// meaning.  White space characters, as defined by the Unicode Pattern_White_Space property, are
/// ignored, unless they are escaped.
///
/// Property patterns specify a set of characters having a certain
/// property as defined by the Unicode standard.  Both the POSIX-like
/// "[:Lu:]" and the Perl-like syntax "\p{Lu}" are recognized.  For a
/// complete list of supported property patterns, see the User's Guide
/// for UnicodeSet at
/// <a href="http://www.icu-project.org/userguide/unicodeSet.html">
/// http://www.icu-project.org/userguide/unicodeSet.html</a>.
/// Actual determination of property data is defined by the underlying
/// Unicode database as implemented by UCharacter.
///
/// Patterns specify individual characters, ranges of characters, and
/// Unicode property sets.  When elements are concatenated, they
/// specify their union.  To complement a set, place a '^' immediately
/// after the opening '['.  Property patterns are inverted by modifying
/// their delimiters; "[:^foo]" and "\P{foo}".  In any other location,
/// '^' has no special meaning.
///
/// Ranges are indicated by placing two a '-' between two
/// characters, as in "a-z".  This specifies the range of all
/// characters from the left to the right, in Unicode order.  If the
/// left character is greater than or equal to the
/// right character it is a syntax error.  If a '-' occurs as the first
/// character after the opening '[' or '[^', or if it occurs as the
/// last character before the closing ']', then it is taken as a
/// literal.  Thus "[a\\-b]", "[-ab]", and "[ab-]" all indicate the same
/// set of three characters, 'a', 'b', and '-'.
///
/// Sets may be intersected using the '&amp;' operator or the asymmetric
/// set difference may be taken using the '-' operator, for example,
/// "[[:L:]&amp;[\\u0000-\\u0FFF]]" indicates the set of all Unicode letters
/// with values less than 4096.  Operators ('&amp;' and '|') have equal
/// precedence and bind left-to-right.  Thus
/// "[[:L:]-[a-z]-[\\u0100-\\u01FF]]" is equivalent to
/// "[[[:L:]-[a-z]]-[\\u0100-\\u01FF]]".  This only really matters for
/// difference; intersection is commutative.
///
/// <table>
/// <tr style="vertical-align: top;"><td style="white-space: nowrap;"><code>[a]</code><td>The set containing 'a'
/// <tr style="vertical-align: top;"><td style="white-space: nowrap;"><code>[a-z]</code><td>The set containing 'a'
/// through 'z' and all letters in between, in Unicode order
/// <tr style="vertical-align: top;"><td style="white-space: nowrap;"><code>[^a-z]</code><td>The set containing
/// all characters but 'a' through 'z',
/// that is, U+0000 through 'a'-1 and 'z'+1 through U+10FFFF
/// <tr style="vertical-align: top;"><td style="white-space: nowrap;"><code>[[_pat1_][_pat2_]]</code>
/// <td>The union of sets specified by _pat1_ and _pat2_
/// <tr style="vertical-align: top;"><td style="white-space: nowrap;"><code>[[_pat1_]&amp;[_pat2_]]</code>
/// <td>The intersection of sets specified by _pat1_ and _pat2_
/// <tr style="vertical-align: top;"><td style="white-space: nowrap;"><code>[[_pat1_]-[_pat2_]]</code>
/// <td>The asymmetric difference of sets specified by _pat1_ and
/// _pat2_
/// <tr style="vertical-align: top;"><td style="white-space: nowrap;"><code>[:Lu:] or \p{Lu}</code>
/// <td>The set of characters having the specified
/// Unicode property; in
/// this case, Unicode uppercase letters
/// <tr style="vertical-align: top;"><td style="white-space: nowrap;"><code>[:^Lu:] or \P{Lu}</code>
/// <td>The set of characters _not_ having the given
/// Unicode property
/// </table>
///
/// __Warning__: you cannot add an empty string ("") to a UnicodeSet.
///
///
/// __Formal syntax__
///
///
/// <blockquote>
///   <table>
///     <tr style="vertical-align: top">
///       <td style="white-space: nowrap; vertical-align: top;"align="right"><code>pattern :=&nbsp; </code></td>
///       <td style="vertical-align: top;"><code>('[' '^'? item* ']') |
///       property</code></td>
///     </tr>
///     <tr style="vertical-align: top">
///       <td style="white-space: nowrap; vertical-align: top;"align="right"><code>item :=&nbsp; </code></td>
///       <td style="vertical-align: top;"><code>char | (char '-' char) | pattern-expr<br>
///       </code></td>
///     </tr>
///     <tr style="vertical-align: top">
///       <td style="white-space: nowrap; vertical-align: top;"align="right"><code>pattern-expr :=&nbsp; </code></td>
///       <td style="vertical-align: top;"><code>pattern | pattern-expr pattern |
///       pattern-expr op pattern<br>
///       </code></td>
///     </tr>
///     <tr style="vertical-align: top">
///       <td style="white-space: nowrap; vertical-align: top;"align="right"><code>op :=&nbsp; </code></td>
///       <td style="vertical-align: top;"><code>'&amp;' | '-'<br>
///       </code></td>
///     </tr>
///     <tr style="vertical-align: top">
///       <td style="white-space: nowrap; vertical-align: top;"align="right"><code>special :=&nbsp; </code></td>
///       <td style="vertical-align: top;"><code>'[' | ']' | '-'<br>
///       </code></td>
///     </tr>
///     <tr style="vertical-align: top">
///       <td style="white-space: nowrap; vertical-align: top;"align="right"><code>char :=&nbsp; </code></td>
///       <td style="vertical-align: top;">_any character that is not_<code> special<br>
///       | ('\\' </code>_any character_<code>)<br>
///       | ('&\#92;u' hex hex hex hex)<br>
///       </code></td>
///     </tr>
///     <tr style="vertical-align: top">
///       <td style="white-space: nowrap; vertical-align: top;"align="right"><code>hex :=&nbsp; </code></td>
///       <td style="vertical-align: top;">_any character for which
///       _<code>Character.digit(c, 16)</code>_
///       returns a non-negative result_</td>
///     </tr>
///     <tr>
///       <td style="white-space: nowrap; vertical-align: top;"align="right"><code>property :=&nbsp; </code></td>
///       <td style="vertical-align: top;">_a Unicode property set pattern_</td>
///     </tr>
///   </table>
///   <br>
///   <table border="1">
///     <tr>
///       <td>Legend: <table>
///         <tr>
///           <td style="white-space: nowrap; vertical-align: top;"><code>a := b</code></td>
///           <td style="width: 20; vertical-align: top;">&nbsp; </td>
///           <td style="vertical-align: top;"><code>a</code> may be replaced by <code>b</code> </td>
///         </tr>
///         <tr>
///           <td style="white-space: nowrap; vertical-align: top;"><code>a?</code></td>
///           <td style="vertical-align: top;"></td>
///           <td style="vertical-align: top;">zero or one instance of <code>a</code><br>
///           </td>
///         </tr>
///         <tr>
///           <td style="white-space: nowrap; vertical-align: top;"><code>a*</code></td>
///           <td style="vertical-align: top;"></td>
///           <td style="vertical-align: top;">one or more instances of <code>a</code><br>
///           </td>
///         </tr>
///         <tr>
///           <td style="white-space: nowrap; vertical-align: top;"><code>a | b</code></td>
///           <td style="vertical-align: top;"></td>
///           <td style="vertical-align: top;">either <code>a</code> or <code>b</code><br>
///           </td>
///         </tr>
///         <tr>
///           <td style="white-space: nowrap; vertical-align: top;"><code>'a'</code></td>
///           <td style="vertical-align: top;"></td>
///           <td style="vertical-align: top;">the literal string between the quotes </td>
///         </tr>
///       </table>
///       </td>
///     </tr>
///   </table>
/// </blockquote>
/// To iterate over contents of UnicodeSet, the following are available:
/// <ul><li>\#ranges() to iterate through the ranges</li>
/// <li>\#strings() to iterate through the strings</li>
/// <li>\#iterator() to iterate through the entire contents in a single loop.
/// That method is, however, not particularly efficient, since it "boxes" each code point into a String.
/// </ul>
/// All of the above can be used in __for__ loops.
/// The android.icu.text.UnicodeSetIterator UnicodeSetIterator can also be used, but not in __for__ loops.
/// To replace, count elements, or delete spans, see android.icu.text.UnicodeSetSpanner UnicodeSetSpanner.
///@author Alan Liu
///@see UnicodeSetIterator
///@see UnicodeSetSpanner
class UnicodeSet extends unicodefilter_.UnicodeFilter {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/UnicodeSet");
  UnicodeSet.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ADD_CASE_MAPPINGS
  ///
  /// Bitmask for constructor, applyPattern(), and closeOver()
  /// indicating letter case.  This may be ORed together with other
  /// selectors.
  ///
  /// Enable case insensitive matching.  E.g., "[ab]" with this flag
  /// will match 'a', 'A', 'b', and 'B'.  "[^ab]" with this flag will
  /// match all except 'a', 'A', 'b', and 'B'. This adds the lower-,
  /// title-, and uppercase mappings as well as the case folding
  /// of each existing element in the set.
  static const ADD_CASE_MAPPINGS = 4;

  static final _id_ALL_CODE_POINTS = jniAccessors.getStaticFieldIDOf(
      _classRef, "ALL_CODE_POINTS", "Landroid/icu/text/UnicodeSet;");

  /// from: static public final android.icu.text.UnicodeSet ALL_CODE_POINTS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constant for the set of all code points. (Since UnicodeSets can include strings, does not include everything that a UnicodeSet can.)
  static UnicodeSet get ALL_CODE_POINTS => UnicodeSet.fromRef(jniAccessors
      .getStaticField(_classRef, _id_ALL_CODE_POINTS, jni.JniType.objectType)
      .object);

  /// from: static public final int CASE
  ///
  /// Bitmask for constructor, applyPattern(), and closeOver()
  /// indicating letter case.  This may be ORed together with other
  /// selectors.
  ///
  /// Enable case insensitive matching.  E.g., "[ab]" with this flag
  /// will match 'a', 'A', 'b', and 'B'.  "[^ab]" with this flag will
  /// match all except 'a', 'A', 'b', and 'B'. This performs a full
  /// closure over case mappings, e.g. U+017F for s.
  ///
  /// The resulting set is a superset of the input for the code points but
  /// not for the strings.
  /// It performs a case mapping closure of the code points and adds
  /// full case folding strings for the code points, and reduces strings of
  /// the original set to their full case folding equivalents.
  ///
  /// This is designed for case-insensitive matches, for example
  /// in regular expressions. The full code point case closure allows checking of
  /// an input character directly against the closure set.
  /// Strings are matched by comparing the case-folded form from the closure
  /// set with an incremental case folding of the string in question.
  ///
  /// The closure set will also contain single code points if the original
  /// set contained case-equivalent strings (like U+00DF for "ss" or "Ss" etc.).
  /// This is not necessary (that is, redundant) for the above matching method
  /// but results in the same closure sets regardless of whether the original
  /// set contained the code point or a string.
  static const CASE = 2;

  /// from: static public final int CASE_INSENSITIVE
  ///
  /// Alias for UnicodeSet.CASE, for ease of porting from C++ where ICU4C
  /// also has both USET_CASE and USET_CASE_INSENSITIVE (see uset.h).
  ///@see \#CASE
  static const CASE_INSENSITIVE = 2;

  static final _id_EMPTY = jniAccessors.getStaticFieldIDOf(
      _classRef, "EMPTY", "Landroid/icu/text/UnicodeSet;");

  /// from: static public final android.icu.text.UnicodeSet EMPTY
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constant for the empty set.
  static UnicodeSet get EMPTY => UnicodeSet.fromRef(jniAccessors
      .getStaticField(_classRef, _id_EMPTY, jni.JniType.objectType)
      .object);

  /// from: static public final int IGNORE_SPACE
  ///
  /// Bitmask for constructor and applyPattern() indicating that
  /// white space should be ignored.  If set, ignore Unicode Pattern_White_Space characters,
  /// unless they are quoted or escaped.  This may be ORed together
  /// with other selectors.
  static const IGNORE_SPACE = 1;

  /// from: static public final int MAX_VALUE
  ///
  /// Maximum value that can be stored in a UnicodeSet.
  static const MAX_VALUE = 1114111;

  /// from: static public final int MIN_VALUE
  ///
  /// Minimum value that can be stored in a UnicodeSet.
  static const MIN_VALUE = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs an empty set.
  UnicodeSet()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/icu/text/UnicodeSet;)V");

  /// from: public void <init>(android.icu.text.UnicodeSet other)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a copy of an existing set.
  UnicodeSet.ctor1(UnicodeSet other)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [other.reference]).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(II)V");

  /// from: public void <init>(int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a set containing the given range. If <code>end &gt;
  /// start</code> then an empty set is created.
  ///@param start first character, inclusive, of range
  ///@param end last character, inclusive, of range
  UnicodeSet.ctor2(int start, int end)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [start, end]).object);

  static final _id_ctor3 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "([I)V");

  /// from: public void <init>(int[] pairs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Quickly constructs a set from a set of ranges &lt;s0, e0, s1, e1, s2, e2, ..., sn, en&gt;.
  /// There must be an even number of integers, and they must be all greater than zero,
  /// all less than or equal to Character.MAX_CODE_POINT.
  /// In each pair (..., si, ei, ...) it must be true that si &lt;= ei
  /// Between adjacent pairs (...ei, sj...), it must be true that ei+1 &lt; sj
  ///@param pairs pairs of character representing ranges
  UnicodeSet.ctor3(jni.JniObject pairs)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor3, [pairs.reference]).object);

  static final _id_ctor4 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String pattern)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a set from the given pattern.  See the class description
  /// for the syntax of the pattern language.  Whitespace is ignored.
  ///@param pattern a string specifying what characters are in the set
  ///@exception java.lang.IllegalArgumentException if the pattern contains
  /// a syntax error.
  UnicodeSet.ctor4(jni.JniString pattern)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor4, [pattern.reference]).object);

  static final _id_ctor5 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;Z)V");

  /// from: public void <init>(java.lang.String pattern, boolean ignoreWhitespace)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a set from the given pattern.  See the class description
  /// for the syntax of the pattern language.
  ///@param pattern a string specifying what characters are in the set
  ///@param ignoreWhitespace if true, ignore Unicode Pattern_White_Space characters
  ///@exception java.lang.IllegalArgumentException if the pattern contains
  /// a syntax error.
  UnicodeSet.ctor5(jni.JniString pattern, bool ignoreWhitespace)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor5,
            [pattern.reference, ignoreWhitespace]).object);

  static final _id_ctor6 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;I)V");

  /// from: public void <init>(java.lang.String pattern, int options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a set from the given pattern.  See the class description
  /// for the syntax of the pattern language.
  ///@param pattern a string specifying what characters are in the set
  ///@param options a bitmask indicating which options to apply.
  /// Valid options are IGNORE_SPACE and CASE.
  ///@exception java.lang.IllegalArgumentException if the pattern contains
  /// a syntax error.
  UnicodeSet.ctor6(jni.JniString pattern, int options)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor6, [pattern.reference, options]).object);

  static final _id_ctor7 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;Ljava/text/ParsePosition;Landroid/icu/text/SymbolTable;)V");

  /// from: public void <init>(java.lang.String pattern, java.text.ParsePosition pos, android.icu.text.SymbolTable symbols)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a set from the given pattern.  See the class description
  /// for the syntax of the pattern language.
  ///@param pattern a string specifying what characters are in the set
  ///@param pos on input, the position in pattern at which to start parsing.
  /// On output, the position after the last character parsed.
  ///@param symbols a symbol table mapping variables to char[] arrays
  /// and chars to UnicodeSets
  ///@exception java.lang.IllegalArgumentException if the pattern
  /// contains a syntax error.
  UnicodeSet.ctor7(jni.JniString pattern, jni.JniObject pos,
      symboltable_.SymbolTable symbols)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor7,
            [pattern.reference, pos.reference, symbols.reference]).object);

  static final _id_ctor8 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;Ljava/text/ParsePosition;Landroid/icu/text/SymbolTable;I)V");

  /// from: public void <init>(java.lang.String pattern, java.text.ParsePosition pos, android.icu.text.SymbolTable symbols, int options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a set from the given pattern.  See the class description
  /// for the syntax of the pattern language.
  ///@param pattern a string specifying what characters are in the set
  ///@param pos on input, the position in pattern at which to start parsing.
  /// On output, the position after the last character parsed.
  ///@param symbols a symbol table mapping variables to char[] arrays
  /// and chars to UnicodeSets
  ///@param options a bitmask indicating which options to apply.
  /// Valid options are IGNORE_SPACE and CASE.
  ///@exception java.lang.IllegalArgumentException if the pattern
  /// contains a syntax error.
  UnicodeSet.ctor8(jni.JniString pattern, jni.JniObject pos,
      symboltable_.SymbolTable symbols, int options)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor8, [
          pattern.reference,
          pos.reference,
          symbols.reference,
          options
        ]).object);

  static final _id_clone =
      jniAccessors.getMethodIDOf(_classRef, "clone", "()Ljava/lang/Object;");

  /// from: public java.lang.Object clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new set that is equivalent to this one.
  jni.JniObject clone() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_set0 = jniAccessors.getMethodIDOf(
      _classRef, "set", "(II)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet set(int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Make this object represent the range <code>start - end</code>.
  /// If <code>end &gt; start</code> then this object is set to an
  /// an empty range.
  ///@param start first character in the set, inclusive
  ///@param end last character in the set, inclusive
  UnicodeSet set0(int start, int end) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_set0, jni.JniType.objectType, [start, end]).object);

  static final _id_set1 = jniAccessors.getMethodIDOf(_classRef, "set",
      "(Landroid/icu/text/UnicodeSet;)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet set(android.icu.text.UnicodeSet other)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Make this object represent the same set as <code>other</code>.
  ///@param other a <code>UnicodeSet</code> whose value will be
  /// copied to this object
  UnicodeSet set1(UnicodeSet other) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference, _id_set1,
          jni.JniType.objectType, [other.reference]).object);

  static final _id_applyPattern = jniAccessors.getMethodIDOf(_classRef,
      "applyPattern", "(Ljava/lang/String;)Landroid/icu/text/UnicodeSet;");

  /// from: public final android.icu.text.UnicodeSet applyPattern(java.lang.String pattern)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Modifies this set to represent the set specified by the given pattern.
  /// See the class description for the syntax of the pattern language.
  /// Whitespace is ignored.
  ///@param pattern a string specifying what characters are in the set
  ///@exception java.lang.IllegalArgumentException if the pattern
  /// contains a syntax error.
  UnicodeSet applyPattern(jni.JniString pattern) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_applyPattern,
          jni.JniType.objectType,
          [pattern.reference]).object);

  static final _id_applyPattern1 = jniAccessors.getMethodIDOf(_classRef,
      "applyPattern", "(Ljava/lang/String;Z)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet applyPattern(java.lang.String pattern, boolean ignoreWhitespace)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Modifies this set to represent the set specified by the given pattern,
  /// optionally ignoring whitespace.
  /// See the class description for the syntax of the pattern language.
  ///@param pattern a string specifying what characters are in the set
  ///@param ignoreWhitespace if true then Unicode Pattern_White_Space characters are ignored
  ///@exception java.lang.IllegalArgumentException if the pattern
  /// contains a syntax error.
  UnicodeSet applyPattern1(jni.JniString pattern, bool ignoreWhitespace) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_applyPattern1,
          jni.JniType.objectType,
          [pattern.reference, ignoreWhitespace]).object);

  static final _id_applyPattern2 = jniAccessors.getMethodIDOf(_classRef,
      "applyPattern", "(Ljava/lang/String;I)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet applyPattern(java.lang.String pattern, int options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Modifies this set to represent the set specified by the given pattern,
  /// optionally ignoring whitespace.
  /// See the class description for the syntax of the pattern language.
  ///@param pattern a string specifying what characters are in the set
  ///@param options a bitmask indicating which options to apply.
  /// Valid options are IGNORE_SPACE and CASE.
  ///@exception java.lang.IllegalArgumentException if the pattern
  /// contains a syntax error.
  UnicodeSet applyPattern2(jni.JniString pattern, int options) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_applyPattern2,
          jni.JniType.objectType,
          [pattern.reference, options]).object);

  static final _id_toPattern = jniAccessors.getMethodIDOf(
      _classRef, "toPattern", "(Z)Ljava/lang/String;");

  /// from: public java.lang.String toPattern(boolean escapeUnprintable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a string representation of this set.  If the result of
  /// calling this function is passed to a UnicodeSet constructor, it
  /// will produce another set that is equal to this one.
  jni.JniString toPattern(bool escapeUnprintable) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_toPattern, jni.JniType.objectType, [escapeUnprintable]).object);

  static final _id_size = jniAccessors.getMethodIDOf(_classRef, "size", "()I");

  /// from: public int size()
  ///
  /// Returns the number of elements in this set (its cardinality)
  /// Note than the elements of a set may include both individual
  /// codepoints and strings.
  ///@return the number of elements in this set (its cardinality).
  int size() => jniAccessors
      .callMethodWithArgs(reference, _id_size, jni.JniType.intType, []).integer;

  static final _id_isEmpty =
      jniAccessors.getMethodIDOf(_classRef, "isEmpty", "()Z");

  /// from: public boolean isEmpty()
  ///
  /// Returns <tt>true</tt> if this set contains no elements.
  ///@return <tt>true</tt> if this set contains no elements.
  bool isEmpty() => jniAccessors.callMethodWithArgs(
      reference, _id_isEmpty, jni.JniType.booleanType, []).boolean;

  static final _id_matchesIndexValue =
      jniAccessors.getMethodIDOf(_classRef, "matchesIndexValue", "(I)Z");

  /// from: public boolean matchesIndexValue(int v)
  ///
  /// Implementation of UnicodeMatcher API.  Returns <tt>true</tt> if
  /// this set contains any character whose low byte is the given
  /// value.  This is used by <tt>RuleBasedTransliterator</tt> for
  /// indexing.
  bool matchesIndexValue(int v) => jniAccessors.callMethodWithArgs(
      reference, _id_matchesIndexValue, jni.JniType.booleanType, [v]).boolean;

  static final _id_matches = jniAccessors.getMethodIDOf(
      _classRef, "matches", "(Landroid/icu/text/Replaceable;[IIZ)I");

  /// from: public int matches(android.icu.text.Replaceable text, int[] offset, int limit, boolean incremental)
  ///
  /// Implementation of UnicodeMatcher.matches().  Always matches the
  /// longest possible multichar string.
  int matches(replaceable_.Replaceable text, jni.JniObject offset, int limit,
          bool incremental) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_matches,
          jni.JniType.intType,
          [text.reference, offset.reference, limit, incremental]).integer;

  static final _id_addMatchSetTo = jniAccessors.getMethodIDOf(
      _classRef, "addMatchSetTo", "(Landroid/icu/text/UnicodeSet;)V");

  /// from: public void addMatchSetTo(android.icu.text.UnicodeSet toUnionTo)
  ///
  /// Implementation of UnicodeMatcher API.  Union the set of all
  /// characters that may be matched by this object into the given
  /// set.
  ///@param toUnionTo the set into which to union the source characters
  void addMatchSetTo(UnicodeSet toUnionTo) => jniAccessors.callMethodWithArgs(
      reference,
      _id_addMatchSetTo,
      jni.JniType.voidType,
      [toUnionTo.reference]).check();

  static final _id_indexOf =
      jniAccessors.getMethodIDOf(_classRef, "indexOf", "(I)I");

  /// from: public int indexOf(int c)
  ///
  /// Returns the index of the given character within this set, where
  /// the set is ordered by ascending code point.  If the character
  /// is not in this set, return -1.  The inverse of this method is
  /// <code>charAt()</code>.
  ///@return an index from 0..size()-1, or -1
  int indexOf(int c) => jniAccessors.callMethodWithArgs(
      reference, _id_indexOf, jni.JniType.intType, [c]).integer;

  static final _id_charAt =
      jniAccessors.getMethodIDOf(_classRef, "charAt", "(I)I");

  /// from: public int charAt(int index)
  ///
  /// Returns the character at the given index within this set, where
  /// the set is ordered by ascending code point.  If the index is
  /// out of range, return -1.  The inverse of this method is
  /// <code>indexOf()</code>.
  ///@param index an index from 0..size()-1
  ///@return the character at the given index, or -1.
  int charAt(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_charAt, jni.JniType.intType, [index]).integer;

  static final _id_add = jniAccessors.getMethodIDOf(
      _classRef, "add", "(II)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet add(int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds the specified range to this set if it is not already
  /// present.  If this set already contains the specified range,
  /// the call leaves this set unchanged.  If <code>end &gt; start</code>
  /// then an empty range is added, leaving the set unchanged.
  ///@param start first character, inclusive, of range to be added
  /// to this set.
  ///@param end last character, inclusive, of range to be added
  /// to this set.
  UnicodeSet add(int start, int end) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_add, jni.JniType.objectType, [start, end]).object);

  static final _id_addAll = jniAccessors.getMethodIDOf(
      _classRef, "addAll", "(II)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet addAll(int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds all characters in range (uses preferred naming convention).
  ///@param start The index of where to start on adding all characters.
  ///@param end The index of where to end on adding all characters.
  ///@return a reference to this object
  UnicodeSet addAll(int start, int end) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_addAll, jni.JniType.objectType, [start, end]).object);

  static final _id_add1 = jniAccessors.getMethodIDOf(
      _classRef, "add", "(I)Landroid/icu/text/UnicodeSet;");

  /// from: public final android.icu.text.UnicodeSet add(int c)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds the specified character to this set if it is not already
  /// present.  If this set already contains the specified character,
  /// the call leaves this set unchanged.
  UnicodeSet add1(int c) => UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_add1, jni.JniType.objectType, [c]).object);

  static final _id_add2 = jniAccessors.getMethodIDOf(_classRef, "add",
      "(Ljava/lang/CharSequence;)Landroid/icu/text/UnicodeSet;");

  /// from: public final android.icu.text.UnicodeSet add(java.lang.CharSequence s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds the specified multicharacter to this set if it is not already
  /// present.  If this set already contains the multicharacter,
  /// the call leaves this set unchanged.
  /// Thus "ch" =&gt; {"ch"}
  /// <br>__Warning: you cannot add an empty string ("") to a UnicodeSet.__
  ///@param s the source string
  ///@return this object, for chaining
  UnicodeSet add2(jni.JniObject s) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_add2, jni.JniType.objectType, [s.reference]).object);

  static final _id_addAll1 = jniAccessors.getMethodIDOf(_classRef, "addAll",
      "(Ljava/lang/CharSequence;)Landroid/icu/text/UnicodeSet;");

  /// from: public final android.icu.text.UnicodeSet addAll(java.lang.CharSequence s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
  /// If this set already any particular character, it has no effect on that character.
  ///@param s the source string
  ///@return this object, for chaining
  UnicodeSet addAll1(jni.JniObject s) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference, _id_addAll1,
          jni.JniType.objectType, [s.reference]).object);

  static final _id_retainAll = jniAccessors.getMethodIDOf(_classRef,
      "retainAll", "(Ljava/lang/CharSequence;)Landroid/icu/text/UnicodeSet;");

  /// from: public final android.icu.text.UnicodeSet retainAll(java.lang.CharSequence s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
  /// If this set already any particular character, it has no effect on that character.
  ///@param s the source string
  ///@return this object, for chaining
  UnicodeSet retainAll(jni.JniObject s) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_retainAll, jni.JniType.objectType, [s.reference]).object);

  static final _id_complementAll = jniAccessors.getMethodIDOf(
      _classRef,
      "complementAll",
      "(Ljava/lang/CharSequence;)Landroid/icu/text/UnicodeSet;");

  /// from: public final android.icu.text.UnicodeSet complementAll(java.lang.CharSequence s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
  /// If this set already any particular character, it has no effect on that character.
  ///@param s the source string
  ///@return this object, for chaining
  UnicodeSet complementAll(jni.JniObject s) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_complementAll, jni.JniType.objectType, [s.reference]).object);

  static final _id_removeAll = jniAccessors.getMethodIDOf(_classRef,
      "removeAll", "(Ljava/lang/CharSequence;)Landroid/icu/text/UnicodeSet;");

  /// from: public final android.icu.text.UnicodeSet removeAll(java.lang.CharSequence s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
  /// If this set already any particular character, it has no effect on that character.
  ///@param s the source string
  ///@return this object, for chaining
  UnicodeSet removeAll(jni.JniObject s) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_removeAll, jni.JniType.objectType, [s.reference]).object);

  static final _id_removeAllStrings = jniAccessors.getMethodIDOf(
      _classRef, "removeAllStrings", "()Landroid/icu/text/UnicodeSet;");

  /// from: public final android.icu.text.UnicodeSet removeAllStrings()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Remove all strings from this UnicodeSet
  ///@return this object, for chaining
  UnicodeSet removeAllStrings() =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_removeAllStrings, jni.JniType.objectType, []).object);

  static final _id_from = jniAccessors.getStaticMethodIDOf(_classRef, "from",
      "(Ljava/lang/CharSequence;)Landroid/icu/text/UnicodeSet;");

  /// from: static public android.icu.text.UnicodeSet from(java.lang.CharSequence s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Makes a set from a multicharacter string. Thus "ch" =&gt; {"ch"}
  /// <br>__Warning: you cannot add an empty string ("") to a UnicodeSet.__
  ///@param s the source string
  ///@return a newly created set containing the given string
  static UnicodeSet from(jni.JniObject s) =>
      UnicodeSet.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_from, jni.JniType.objectType, [s.reference]).object);

  static final _id_fromAll = jniAccessors.getStaticMethodIDOf(_classRef,
      "fromAll", "(Ljava/lang/CharSequence;)Landroid/icu/text/UnicodeSet;");

  /// from: static public android.icu.text.UnicodeSet fromAll(java.lang.CharSequence s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Makes a set from each of the characters in the string. Thus "ch" =&gt; {"c", "h"}
  ///@param s the source string
  ///@return a newly created set containing the given characters
  static UnicodeSet fromAll(jni.JniObject s) =>
      UnicodeSet.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_fromAll, jni.JniType.objectType, [s.reference]).object);

  static final _id_retain = jniAccessors.getMethodIDOf(
      _classRef, "retain", "(II)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet retain(int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retain only the elements in this set that are contained in the
  /// specified range.  If <code>end &gt; start</code> then an empty range is
  /// retained, leaving the set empty.
  ///@param start first character, inclusive, of range to be retained
  /// to this set.
  ///@param end last character, inclusive, of range to be retained
  /// to this set.
  UnicodeSet retain(int start, int end) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_retain, jni.JniType.objectType, [start, end]).object);

  static final _id_retain1 = jniAccessors.getMethodIDOf(
      _classRef, "retain", "(I)Landroid/icu/text/UnicodeSet;");

  /// from: public final android.icu.text.UnicodeSet retain(int c)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retain the specified character from this set if it is present.
  /// Upon return this set will be empty if it did not contain c, or
  /// will only contain c if it did contain c.
  ///@param c the character to be retained
  ///@return this object, for chaining
  UnicodeSet retain1(int c) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_retain1, jni.JniType.objectType, [c]).object);

  static final _id_retain2 = jniAccessors.getMethodIDOf(_classRef, "retain",
      "(Ljava/lang/CharSequence;)Landroid/icu/text/UnicodeSet;");

  /// from: public final android.icu.text.UnicodeSet retain(java.lang.CharSequence cs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retain the specified string in this set if it is present.
  /// Upon return this set will be empty if it did not contain s, or
  /// will only contain s if it did contain s.
  ///@param cs the string to be retained
  ///@return this object, for chaining
  UnicodeSet retain2(jni.JniObject cs) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference, _id_retain2,
          jni.JniType.objectType, [cs.reference]).object);

  static final _id_remove = jniAccessors.getMethodIDOf(
      _classRef, "remove", "(II)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet remove(int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes the specified range from this set if it is present.
  /// The set will not contain the specified range once the call
  /// returns.  If <code>end &gt; start</code> then an empty range is
  /// removed, leaving the set unchanged.
  ///@param start first character, inclusive, of range to be removed
  /// from this set.
  ///@param end last character, inclusive, of range to be removed
  /// from this set.
  UnicodeSet remove(int start, int end) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_remove, jni.JniType.objectType, [start, end]).object);

  static final _id_remove1 = jniAccessors.getMethodIDOf(
      _classRef, "remove", "(I)Landroid/icu/text/UnicodeSet;");

  /// from: public final android.icu.text.UnicodeSet remove(int c)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes the specified character from this set if it is present.
  /// The set will not contain the specified character once the call
  /// returns.
  ///@param c the character to be removed
  ///@return this object, for chaining
  UnicodeSet remove1(int c) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_remove1, jni.JniType.objectType, [c]).object);

  static final _id_remove2 = jniAccessors.getMethodIDOf(_classRef, "remove",
      "(Ljava/lang/CharSequence;)Landroid/icu/text/UnicodeSet;");

  /// from: public final android.icu.text.UnicodeSet remove(java.lang.CharSequence s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes the specified string from this set if it is present.
  /// The set will not contain the specified string once the call
  /// returns.
  ///@param s the string to be removed
  ///@return this object, for chaining
  UnicodeSet remove2(jni.JniObject s) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference, _id_remove2,
          jni.JniType.objectType, [s.reference]).object);

  static final _id_complement = jniAccessors.getMethodIDOf(
      _classRef, "complement", "(II)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet complement(int start, int end)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Complements the specified range in this set.  Any character in
  /// the range will be removed if it is in this set, or will be
  /// added if it is not in this set.  If <code>end &gt; start</code>
  /// then an empty range is complemented, leaving the set unchanged.
  ///@param start first character, inclusive, of range to be removed
  /// from this set.
  ///@param end last character, inclusive, of range to be removed
  /// from this set.
  UnicodeSet complement(int start, int end) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_complement, jni.JniType.objectType, [start, end]).object);

  static final _id_complement1 = jniAccessors.getMethodIDOf(
      _classRef, "complement", "(I)Landroid/icu/text/UnicodeSet;");

  /// from: public final android.icu.text.UnicodeSet complement(int c)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Complements the specified character in this set.  The character
  /// will be removed if it is in this set, or will be added if it is
  /// not in this set.
  UnicodeSet complement1(int c) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_complement1, jni.JniType.objectType, [c]).object);

  static final _id_complement2 = jniAccessors.getMethodIDOf(
      _classRef, "complement", "()Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet complement()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This is equivalent to
  /// <code>complement(MIN_VALUE, MAX_VALUE)</code>.
  UnicodeSet complement2() =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_complement2, jni.JniType.objectType, []).object);

  static final _id_complement3 = jniAccessors.getMethodIDOf(_classRef,
      "complement", "(Ljava/lang/CharSequence;)Landroid/icu/text/UnicodeSet;");

  /// from: public final android.icu.text.UnicodeSet complement(java.lang.CharSequence s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Complement the specified string in this set.
  /// The set will not contain the specified string once the call
  /// returns.
  /// <br>__Warning: you cannot add an empty string ("") to a UnicodeSet.__
  ///@param s the string to complement
  ///@return this object, for chaining
  UnicodeSet complement3(jni.JniObject s) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_complement3, jni.JniType.objectType, [s.reference]).object);

  static final _id_contains =
      jniAccessors.getMethodIDOf(_classRef, "contains", "(I)Z");

  /// from: public boolean contains(int c)
  ///
  /// Returns true if this set contains the given character.
  ///@param c character to be checked for containment
  ///@return true if the test condition is met
  bool contains(int c) => jniAccessors.callMethodWithArgs(
      reference, _id_contains, jni.JniType.booleanType, [c]).boolean;

  static final _id_contains1 =
      jniAccessors.getMethodIDOf(_classRef, "contains", "(II)Z");

  /// from: public boolean contains(int start, int end)
  ///
  /// Returns true if this set contains every character
  /// of the given range.
  ///@param start first character, inclusive, of the range
  ///@param end last character, inclusive, of the range
  ///@return true if the test condition is met
  bool contains1(int start, int end) => jniAccessors.callMethodWithArgs(
      reference, _id_contains1, jni.JniType.booleanType, [start, end]).boolean;

  static final _id_contains2 = jniAccessors.getMethodIDOf(
      _classRef, "contains", "(Ljava/lang/CharSequence;)Z");

  /// from: public final boolean contains(java.lang.CharSequence s)
  ///
  /// Returns <tt>true</tt> if this set contains the given
  /// multicharacter string.
  ///@param s string to be checked for containment
  ///@return <tt>true</tt> if this set contains the specified string
  bool contains2(jni.JniObject s) => jniAccessors.callMethodWithArgs(
      reference, _id_contains2, jni.JniType.booleanType, [s.reference]).boolean;

  static final _id_containsAll = jniAccessors.getMethodIDOf(
      _classRef, "containsAll", "(Landroid/icu/text/UnicodeSet;)Z");

  /// from: public boolean containsAll(android.icu.text.UnicodeSet b)
  ///
  /// Returns true if this set contains all the characters and strings
  /// of the given set.
  ///@param b set to be checked for containment
  ///@return true if the test condition is met
  bool containsAll(UnicodeSet b) => jniAccessors.callMethodWithArgs(reference,
      _id_containsAll, jni.JniType.booleanType, [b.reference]).boolean;

  static final _id_containsAll1 = jniAccessors.getMethodIDOf(
      _classRef, "containsAll", "(Ljava/lang/String;)Z");

  /// from: public boolean containsAll(java.lang.String s)
  ///
  /// Returns true if there is a partition of the string such that this set contains each of the partitioned strings.
  /// For example, for the Unicode set [a{bc}{cd}]<br>
  /// containsAll is true for each of: "a", "bc", ""cdbca"<br>
  /// containsAll is false for each of: "acb", "bcda", "bcx"<br>
  ///@param s string containing characters to be checked for containment
  ///@return true if the test condition is met
  bool containsAll1(jni.JniString s) => jniAccessors.callMethodWithArgs(
      reference,
      _id_containsAll1,
      jni.JniType.booleanType,
      [s.reference]).boolean;

  static final _id_containsNone =
      jniAccessors.getMethodIDOf(_classRef, "containsNone", "(II)Z");

  /// from: public boolean containsNone(int start, int end)
  ///
  /// Returns true if this set contains none of the characters
  /// of the given range.
  ///@param start first character, inclusive, of the range
  ///@param end last character, inclusive, of the range
  ///@return true if the test condition is met
  bool containsNone(int start, int end) => jniAccessors.callMethodWithArgs(
      reference,
      _id_containsNone,
      jni.JniType.booleanType,
      [start, end]).boolean;

  static final _id_containsNone1 = jniAccessors.getMethodIDOf(
      _classRef, "containsNone", "(Landroid/icu/text/UnicodeSet;)Z");

  /// from: public boolean containsNone(android.icu.text.UnicodeSet b)
  ///
  /// Returns true if none of the characters or strings in this UnicodeSet appears in the string.
  /// For example, for the Unicode set [a{bc}{cd}]<br>
  /// containsNone is true for: "xy", "cb"<br>
  /// containsNone is false for: "a", "bc", "bcd"<br>
  ///@param b set to be checked for containment
  ///@return true if the test condition is met
  bool containsNone1(UnicodeSet b) => jniAccessors.callMethodWithArgs(reference,
      _id_containsNone1, jni.JniType.booleanType, [b.reference]).boolean;

  static final _id_containsNone2 = jniAccessors.getMethodIDOf(
      _classRef, "containsNone", "(Ljava/lang/CharSequence;)Z");

  /// from: public boolean containsNone(java.lang.CharSequence s)
  ///
  /// Returns true if this set contains none of the characters
  /// of the given string.
  ///@param s string containing characters to be checked for containment
  ///@return true if the test condition is met
  bool containsNone2(jni.JniObject s) => jniAccessors.callMethodWithArgs(
      reference,
      _id_containsNone2,
      jni.JniType.booleanType,
      [s.reference]).boolean;

  static final _id_containsSome =
      jniAccessors.getMethodIDOf(_classRef, "containsSome", "(II)Z");

  /// from: public final boolean containsSome(int start, int end)
  ///
  /// Returns true if this set contains one or more of the characters
  /// in the given range.
  ///@param start first character, inclusive, of the range
  ///@param end last character, inclusive, of the range
  ///@return true if the condition is met
  bool containsSome(int start, int end) => jniAccessors.callMethodWithArgs(
      reference,
      _id_containsSome,
      jni.JniType.booleanType,
      [start, end]).boolean;

  static final _id_containsSome1 = jniAccessors.getMethodIDOf(
      _classRef, "containsSome", "(Landroid/icu/text/UnicodeSet;)Z");

  /// from: public final boolean containsSome(android.icu.text.UnicodeSet s)
  ///
  /// Returns true if this set contains one or more of the characters
  /// and strings of the given set.
  ///@param s set to be checked for containment
  ///@return true if the condition is met
  bool containsSome1(UnicodeSet s) => jniAccessors.callMethodWithArgs(reference,
      _id_containsSome1, jni.JniType.booleanType, [s.reference]).boolean;

  static final _id_containsSome2 = jniAccessors.getMethodIDOf(
      _classRef, "containsSome", "(Ljava/lang/CharSequence;)Z");

  /// from: public final boolean containsSome(java.lang.CharSequence s)
  ///
  /// Returns true if this set contains one or more of the characters
  /// of the given string.
  ///@param s string containing characters to be checked for containment
  ///@return true if the condition is met
  bool containsSome2(jni.JniObject s) => jniAccessors.callMethodWithArgs(
      reference,
      _id_containsSome2,
      jni.JniType.booleanType,
      [s.reference]).boolean;

  static final _id_addAll2 = jniAccessors.getMethodIDOf(_classRef, "addAll",
      "(Landroid/icu/text/UnicodeSet;)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet addAll(android.icu.text.UnicodeSet c)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds all of the elements in the specified set to this set if
  /// they're not already present.  This operation effectively
  /// modifies this set so that its value is the <i>union</i> of the two
  /// sets.  The behavior of this operation is unspecified if the specified
  /// collection is modified while the operation is in progress.
  ///@param c set whose elements are to be added to this set.
  UnicodeSet addAll2(UnicodeSet c) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference, _id_addAll2,
          jni.JniType.objectType, [c.reference]).object);

  static final _id_retainAll1 = jniAccessors.getMethodIDOf(
      _classRef,
      "retainAll",
      "(Landroid/icu/text/UnicodeSet;)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet retainAll(android.icu.text.UnicodeSet c)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retains only the elements in this set that are contained in the
  /// specified set.  In other words, removes from this set all of
  /// its elements that are not contained in the specified set.  This
  /// operation effectively modifies this set so that its value is
  /// the <i>intersection</i> of the two sets.
  ///@param c set that defines which elements this set will retain.
  UnicodeSet retainAll1(UnicodeSet c) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_retainAll1, jni.JniType.objectType, [c.reference]).object);

  static final _id_removeAll1 = jniAccessors.getMethodIDOf(
      _classRef,
      "removeAll",
      "(Landroid/icu/text/UnicodeSet;)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet removeAll(android.icu.text.UnicodeSet c)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes from this set all of its elements that are contained in the
  /// specified set.  This operation effectively modifies this
  /// set so that its value is the <i>asymmetric set difference</i> of
  /// the two sets.
  ///@param c set that defines which elements will be removed from
  ///          this set.
  UnicodeSet removeAll1(UnicodeSet c) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_removeAll1, jni.JniType.objectType, [c.reference]).object);

  static final _id_complementAll1 = jniAccessors.getMethodIDOf(
      _classRef,
      "complementAll",
      "(Landroid/icu/text/UnicodeSet;)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet complementAll(android.icu.text.UnicodeSet c)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Complements in this set all elements contained in the specified
  /// set.  Any character in the other set will be removed if it is
  /// in this set, or will be added if it is not in this set.
  ///@param c set that defines which elements will be complemented from
  ///          this set.
  UnicodeSet complementAll1(UnicodeSet c) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_complementAll1, jni.JniType.objectType, [c.reference]).object);

  static final _id_clear = jniAccessors.getMethodIDOf(
      _classRef, "clear", "()Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet clear()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes all of the elements from this set.  This set will be
  /// empty after this call returns.
  UnicodeSet clear() => UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniType.objectType, []).object);

  static final _id_getRangeCount =
      jniAccessors.getMethodIDOf(_classRef, "getRangeCount", "()I");

  /// from: public int getRangeCount()
  ///
  /// Iteration method that returns the number of ranges contained in
  /// this set.
  ///@see \#getRangeStart
  ///@see \#getRangeEnd
  int getRangeCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getRangeCount, jni.JniType.intType, []).integer;

  static final _id_getRangeStart =
      jniAccessors.getMethodIDOf(_classRef, "getRangeStart", "(I)I");

  /// from: public int getRangeStart(int index)
  ///
  /// Iteration method that returns the first character in the
  /// specified range of this set.
  ///@exception ArrayIndexOutOfBoundsException if index is outside
  /// the range <code>0..getRangeCount()-1</code>
  ///@see \#getRangeCount
  ///@see \#getRangeEnd
  int getRangeStart(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_getRangeStart, jni.JniType.intType, [index]).integer;

  static final _id_getRangeEnd =
      jniAccessors.getMethodIDOf(_classRef, "getRangeEnd", "(I)I");

  /// from: public int getRangeEnd(int index)
  ///
  /// Iteration method that returns the last character in the
  /// specified range of this set.
  ///@exception ArrayIndexOutOfBoundsException if index is outside
  /// the range <code>0..getRangeCount()-1</code>
  ///@see \#getRangeStart
  ///@see \#getRangeEnd
  int getRangeEnd(int index) => jniAccessors.callMethodWithArgs(
      reference, _id_getRangeEnd, jni.JniType.intType, [index]).integer;

  static final _id_compact = jniAccessors.getMethodIDOf(
      _classRef, "compact", "()Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet compact()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Reallocate this objects internal structures to take up the least
  /// possible space, without changing this object's value.
  UnicodeSet compact() => UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_compact, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  ///
  /// Compares the specified object with this set for equality.  Returns
  /// <tt>true</tt> if the specified object is also a set, the two sets
  /// have the same size, and every member of the specified set is
  /// contained in this set (or equivalently, every member of this set is
  /// contained in the specified set).
  ///@param o Object to be compared for equality with this set.
  ///@return <tt>true</tt> if the specified Object is equal to this set.
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// Returns the hash code value for this set.
  ///@return the hash code value for this set.
  ///@see java.lang.Object\#hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a programmer-readable string representation of this object.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_add3 = jniAccessors.getMethodIDOf(
      _classRef, "add", "(Ljava/lang/Iterable;)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet add(java.lang.Iterable<?> source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add the contents of the collection (as strings) into this UnicodeSet.
  /// The collection must not contain null.
  ///@param source the collection to add
  ///@return a reference to this object
  UnicodeSet add3(jni.JniObject source) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference, _id_add3,
          jni.JniType.objectType, [source.reference]).object);

  static final _id_addAll3 = jniAccessors.getMethodIDOf(_classRef, "addAll",
      "(Ljava/lang/Iterable;)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet addAll(java.lang.Iterable<?> source)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a collection (as strings) into this UnicodeSet.
  /// Uses standard naming convention.
  ///@param source collection to add into
  ///@return a reference to this object
  UnicodeSet addAll3(jni.JniObject source) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference, _id_addAll3,
          jni.JniType.objectType, [source.reference]).object);

  static final _id_applyIntPropertyValue = jniAccessors.getMethodIDOf(
      _classRef, "applyIntPropertyValue", "(II)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet applyIntPropertyValue(int prop, int value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Modifies this set to contain those code points which have the
  /// given value for the given binary or enumerated property, as
  /// returned by UCharacter.getIntPropertyValue.  Prior contents of
  /// this set are lost.
  ///@param prop a property in the range
  /// UProperty.BIN_START..UProperty.BIN_LIMIT-1 or
  /// UProperty.INT_START..UProperty.INT_LIMIT-1 or.
  /// UProperty.MASK_START..UProperty.MASK_LIMIT-1.
  ///@param value a value in the range
  /// UCharacter.getIntPropertyMinValue(prop)..
  /// UCharacter.getIntPropertyMaxValue(prop), with one exception.
  /// If prop is UProperty.GENERAL_CATEGORY_MASK, then value should not be
  /// a UCharacter.getType() result, but rather a mask value produced
  /// by logically ORing (1 &lt;&lt; UCharacter.getType()) values together.
  /// This allows grouped categories such as [:L:] to be represented.
  ///@return a reference to this set
  UnicodeSet applyIntPropertyValue(int prop, int value) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_applyIntPropertyValue,
          jni.JniType.objectType,
          [prop, value]).object);

  static final _id_applyPropertyAlias = jniAccessors.getMethodIDOf(
      _classRef,
      "applyPropertyAlias",
      "(Ljava/lang/String;Ljava/lang/String;)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet applyPropertyAlias(java.lang.String propertyAlias, java.lang.String valueAlias)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Modifies this set to contain those code points which have the
  /// given value for the given property.  Prior contents of this
  /// set are lost.
  ///@param propertyAlias a property alias, either short or long.
  /// The name is matched loosely.  See PropertyAliases.txt for names
  /// and a description of loose matching.  If the value string is
  /// empty, then this string is interpreted as either a
  /// General_Category value alias, a Script value alias, a binary
  /// property alias, or a special ID.  Special IDs are matched
  /// loosely and correspond to the following sets:
  ///
  /// "ANY" = [\\u0000-\\U0010FFFF],
  /// "ASCII" = [\\u0000-\\u007F].
  ///@param valueAlias a value alias, either short or long.  The
  /// name is matched loosely.  See PropertyValueAliases.txt for
  /// names and a description of loose matching.  In addition to
  /// aliases listed, numeric values and canonical combining classes
  /// may be expressed numerically, e.g., ("nv", "0.5") or ("ccc",
  /// "220").  The value string may also be empty.
  ///@return a reference to this set
  UnicodeSet applyPropertyAlias(
          jni.JniString propertyAlias, jni.JniString valueAlias) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_applyPropertyAlias,
          jni.JniType.objectType,
          [propertyAlias.reference, valueAlias.reference]).object);

  static final _id_applyPropertyAlias1 = jniAccessors.getMethodIDOf(
      _classRef,
      "applyPropertyAlias",
      "(Ljava/lang/String;Ljava/lang/String;Landroid/icu/text/SymbolTable;)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet applyPropertyAlias(java.lang.String propertyAlias, java.lang.String valueAlias, android.icu.text.SymbolTable symbols)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Modifies this set to contain those code points which have the
  /// given value for the given property.  Prior contents of this
  /// set are lost.
  ///@param propertyAlias A string of the property alias.
  ///@param valueAlias A string of the value alias.
  ///@param symbols if not null, then symbols are first called to see if a property
  /// is available. If true, then everything else is skipped.
  ///@return this set
  UnicodeSet applyPropertyAlias1(jni.JniString propertyAlias,
          jni.JniString valueAlias, symboltable_.SymbolTable symbols) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_applyPropertyAlias1, jni.JniType.objectType, [
        propertyAlias.reference,
        valueAlias.reference,
        symbols.reference
      ]).object);

  static final _id_closeOver = jniAccessors.getMethodIDOf(
      _classRef, "closeOver", "(I)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet closeOver(int attribute)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Close this set over the given attribute.  For the attribute
  /// CASE, the result is to modify this set so that:
  ///
  /// 1. For each character or string 'a' in this set, all strings
  /// 'b' such that foldCase(a) == foldCase(b) are added to this set.
  /// (For most 'a' that are single characters, 'b' will have
  /// b.length() == 1.)
  ///
  /// 2. For each string 'e' in the resulting set, if e !=
  /// foldCase(e), 'e' will be removed.
  ///
  /// Example: [aqß{Bc}{bC}{Fi}] =&gt; [aAqQß\ufb01{ss}{bc}{fi}]
  ///
  /// (Here foldCase(x) refers to the operation
  /// UCharacter.foldCase(x, true), and a == b actually denotes
  /// a.equals(b), not pointer comparison.)
  ///@param attribute bitmask for attributes to close over.
  /// Currently only the CASE bit is supported.  Any undefined bits
  /// are ignored.
  ///@return a reference to this set.
  UnicodeSet closeOver(int attribute) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_closeOver, jni.JniType.objectType, [attribute]).object);

  static final _id_isFrozen =
      jniAccessors.getMethodIDOf(_classRef, "isFrozen", "()Z");

  /// from: public boolean isFrozen()
  ///
  /// Is this frozen, according to the Freezable interface?
  ///@return value
  bool isFrozen() => jniAccessors.callMethodWithArgs(
      reference, _id_isFrozen, jni.JniType.booleanType, []).boolean;

  static final _id_freeze = jniAccessors.getMethodIDOf(
      _classRef, "freeze", "()Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet freeze()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Freeze this class, according to the Freezable interface.
  ///@return this
  UnicodeSet freeze() => UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_freeze, jni.JniType.objectType, []).object);

  static final _id_span = jniAccessors.getMethodIDOf(_classRef, "span",
      "(Ljava/lang/CharSequence;Landroid/icu/text/UnicodeSet\$SpanCondition;)I");

  /// from: public int span(java.lang.CharSequence s, android.icu.text.UnicodeSet.SpanCondition spanCondition)
  ///
  /// Span a string using this UnicodeSet.
  /// To replace, count elements, or delete spans, see android.icu.text.UnicodeSetSpanner UnicodeSetSpanner.
  ///@param s The string to be spanned
  ///@param spanCondition The span condition
  ///@return the length of the span
  int span(jni.JniObject s, UnicodeSet_SpanCondition spanCondition) =>
      jniAccessors.callMethodWithArgs(reference, _id_span, jni.JniType.intType,
          [s.reference, spanCondition.reference]).integer;

  static final _id_span1 = jniAccessors.getMethodIDOf(_classRef, "span",
      "(Ljava/lang/CharSequence;ILandroid/icu/text/UnicodeSet\$SpanCondition;)I");

  /// from: public int span(java.lang.CharSequence s, int start, android.icu.text.UnicodeSet.SpanCondition spanCondition)
  ///
  /// Span a string using this UnicodeSet.
  ///   If the start index is less than 0, span will start from 0.
  ///   If the start index is greater than the string length, span returns the string length.
  /// To replace, count elements, or delete spans, see android.icu.text.UnicodeSetSpanner UnicodeSetSpanner.
  ///@param s The string to be spanned
  ///@param start The start index that the span begins
  ///@param spanCondition The span condition
  ///@return the string index which ends the span (i.e. exclusive)
  int span1(
          jni.JniObject s, int start, UnicodeSet_SpanCondition spanCondition) =>
      jniAccessors.callMethodWithArgs(reference, _id_span1, jni.JniType.intType,
          [s.reference, start, spanCondition.reference]).integer;

  static final _id_spanBack = jniAccessors.getMethodIDOf(_classRef, "spanBack",
      "(Ljava/lang/CharSequence;Landroid/icu/text/UnicodeSet\$SpanCondition;)I");

  /// from: public int spanBack(java.lang.CharSequence s, android.icu.text.UnicodeSet.SpanCondition spanCondition)
  ///
  /// Span a string backwards (from the end) using this UnicodeSet.
  /// To replace, count elements, or delete spans, see android.icu.text.UnicodeSetSpanner UnicodeSetSpanner.
  ///@param s The string to be spanned
  ///@param spanCondition The span condition
  ///@return The string index which starts the span (i.e. inclusive).
  int spanBack(jni.JniObject s, UnicodeSet_SpanCondition spanCondition) =>
      jniAccessors.callMethodWithArgs(reference, _id_spanBack,
          jni.JniType.intType, [s.reference, spanCondition.reference]).integer;

  static final _id_spanBack1 = jniAccessors.getMethodIDOf(_classRef, "spanBack",
      "(Ljava/lang/CharSequence;ILandroid/icu/text/UnicodeSet\$SpanCondition;)I");

  /// from: public int spanBack(java.lang.CharSequence s, int fromIndex, android.icu.text.UnicodeSet.SpanCondition spanCondition)
  ///
  /// Span a string backwards (from the fromIndex) using this UnicodeSet.
  /// If the fromIndex is less than 0, spanBack will return 0.
  /// If fromIndex is greater than the string length, spanBack will start from the string length.
  /// To replace, count elements, or delete spans, see android.icu.text.UnicodeSetSpanner UnicodeSetSpanner.
  ///@param s The string to be spanned
  ///@param fromIndex The index of the char (exclusive) that the string should be spanned backwards
  ///@param spanCondition The span condition
  ///@return The string index which starts the span (i.e. inclusive).
  int spanBack1(jni.JniObject s, int fromIndex,
          UnicodeSet_SpanCondition spanCondition) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_spanBack1,
          jni.JniType.intType,
          [s.reference, fromIndex, spanCondition.reference]).integer;

  static final _id_cloneAsThawed = jniAccessors.getMethodIDOf(
      _classRef, "cloneAsThawed", "()Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet cloneAsThawed()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Clone a thawed version of this class, according to the Freezable interface.
  ///@return the clone, not frozen
  UnicodeSet cloneAsThawed() =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_cloneAsThawed, jni.JniType.objectType, []).object);

  static final _id_ranges =
      jniAccessors.getMethodIDOf(_classRef, "ranges", "()Ljava/lang/Iterable;");

  /// from: public java.lang.Iterable<android.icu.text.UnicodeSet.EntryRange> ranges()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provide for faster iteration than by String. Returns an Iterable/Iterator over ranges of code points.
  /// The UnicodeSet must not be altered during the iteration.
  /// The EntryRange instance is the same each time; the contents are just reset.
  ///
  /// __Warning: __To iterate over the full contents, you have to also iterate over the strings.
  ///
  /// __Warning: __For speed, UnicodeSet iteration does not check for concurrent modification.
  /// Do not alter the UnicodeSet while iterating.
  ///
  /// <pre>
  /// // Sample code
  /// for (EntryRange range : us1.ranges()) {
  ///     // do something with code points between range.codepoint and range.codepointEnd;
  /// }
  /// for (String s : us1.strings()) {
  ///     // do something with each string;
  /// }
  /// </pre>
  jni.JniObject ranges() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_ranges, jni.JniType.objectType, []).object);

  static final _id_iterator = jniAccessors.getMethodIDOf(
      _classRef, "iterator", "()Ljava/util/Iterator;");

  /// from: public java.util.Iterator<java.lang.String> iterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a string iterator. Uses the same order of iteration as UnicodeSetIterator.
  /// __Warning: __For speed, UnicodeSet iteration does not check for concurrent modification.
  /// Do not alter the UnicodeSet while iterating.
  ///@see java.util.Set\#iterator()
  jni.JniObject iterator() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_iterator, jni.JniType.objectType, []).object);

  static final _id_containsAll2 = jniAccessors.getMethodIDOf(
      _classRef, "containsAll", "(Ljava/lang/Iterable;)Z");

  /// from: public boolean containsAll(java.lang.Iterable<T> collection)
  ///
  /// @see \#containsAll(android.icu.text.UnicodeSet)
  bool containsAll2(jni.JniObject collection) =>
      jniAccessors.callMethodWithArgs(reference, _id_containsAll2,
          jni.JniType.booleanType, [collection.reference]).boolean;

  static final _id_containsNone3 = jniAccessors.getMethodIDOf(
      _classRef, "containsNone", "(Ljava/lang/Iterable;)Z");

  /// from: public boolean containsNone(java.lang.Iterable<T> collection)
  ///
  /// @see \#containsNone(android.icu.text.UnicodeSet)
  bool containsNone3(jni.JniObject collection) =>
      jniAccessors.callMethodWithArgs(reference, _id_containsNone3,
          jni.JniType.booleanType, [collection.reference]).boolean;

  static final _id_containsSome3 = jniAccessors.getMethodIDOf(
      _classRef, "containsSome", "(Ljava/lang/Iterable;)Z");

  /// from: public final boolean containsSome(java.lang.Iterable<T> collection)
  ///
  /// @see \#containsAll(android.icu.text.UnicodeSet)
  bool containsSome3(jni.JniObject collection) =>
      jniAccessors.callMethodWithArgs(reference, _id_containsSome3,
          jni.JniType.booleanType, [collection.reference]).boolean;

  static final _id_addAll4 = jniAccessors.getMethodIDOf(_classRef, "addAll",
      "([Ljava/lang/Object;)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet addAll(T[] collection)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see \#addAll(android.icu.text.UnicodeSet)
  UnicodeSet addAll4(jni.JniObject collection) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(reference, _id_addAll4,
          jni.JniType.objectType, [collection.reference]).object);

  static final _id_removeAll2 = jniAccessors.getMethodIDOf(_classRef,
      "removeAll", "(Ljava/lang/Iterable;)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet removeAll(java.lang.Iterable<T> collection)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see \#removeAll(android.icu.text.UnicodeSet)
  UnicodeSet removeAll2(jni.JniObject collection) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_removeAll2,
          jni.JniType.objectType,
          [collection.reference]).object);

  static final _id_retainAll2 = jniAccessors.getMethodIDOf(_classRef,
      "retainAll", "(Ljava/lang/Iterable;)Landroid/icu/text/UnicodeSet;");

  /// from: public android.icu.text.UnicodeSet retainAll(java.lang.Iterable<T> collection)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see \#retainAll(android.icu.text.UnicodeSet)
  UnicodeSet retainAll2(jni.JniObject collection) =>
      UnicodeSet.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_retainAll2,
          jni.JniType.objectType,
          [collection.reference]).object);

  static final _id_compareTo = jniAccessors.getMethodIDOf(
      _classRef, "compareTo", "(Landroid/icu/text/UnicodeSet;)I");

  /// from: public int compareTo(android.icu.text.UnicodeSet o)
  ///
  /// Compares UnicodeSets, where shorter come first, and otherwise lexigraphically
  /// (according to the comparison of the first characters that differ).
  ///@see java.lang.Comparable\#compareTo(java.lang.Object)
  int compareTo(UnicodeSet o) => jniAccessors.callMethodWithArgs(
      reference, _id_compareTo, jni.JniType.intType, [o.reference]).integer;

  static final _id_compareTo1 = jniAccessors.getMethodIDOf(
      _classRef,
      "compareTo",
      "(Landroid/icu/text/UnicodeSet;Landroid/icu/text/UnicodeSet\$ComparisonStyle;)I");

  /// from: public int compareTo(android.icu.text.UnicodeSet o, android.icu.text.UnicodeSet.ComparisonStyle style)
  ///
  /// Compares UnicodeSets, in three different ways.
  ///@see java.lang.Comparable\#compareTo(java.lang.Object)
  int compareTo1(UnicodeSet o, UnicodeSet_ComparisonStyle style) =>
      jniAccessors.callMethodWithArgs(reference, _id_compareTo1,
          jni.JniType.intType, [o.reference, style.reference]).integer;

  static final _id_compareTo2 = jniAccessors.getMethodIDOf(
      _classRef, "compareTo", "(Ljava/lang/Iterable;)I");

  /// from: public int compareTo(java.lang.Iterable<java.lang.String> other)
  ///
  ///
  int compareTo2(jni.JniObject other) => jniAccessors.callMethodWithArgs(
      reference,
      _id_compareTo2,
      jni.JniType.intType,
      [other.reference]).integer;

  static final _id_strings = jniAccessors.getMethodIDOf(
      _classRef, "strings", "()Ljava/util/Collection;");

  /// from: public java.util.Collection<java.lang.String> strings()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// For iterating through the strings in the set. Example:
  /// <pre>
  /// for (String key : myUnicodeSet.strings()) {
  ///   doSomethingWith(key);
  /// }
  /// </pre>
  jni.JniObject strings() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_strings, jni.JniType.objectType, []).object);
}

/// from: android.icu.text.UnicodeSet$SpanCondition
///
/// Argument values for whether span() and similar functions continue while the current character is contained vs.
/// not contained in the set.
///
/// The functionality is straightforward for sets with only single code points, without strings (which is the common
/// case):
/// <ul>
/// <li>CONTAINED and SIMPLE work the same.
/// <li>CONTAINED and SIMPLE are inverses of NOT_CONTAINED.
/// <li>span() and spanBack() partition any string the
/// same way when alternating between span(NOT_CONTAINED) and span(either "contained" condition).
/// <li>Using a
/// complemented (inverted) set and the opposite span conditions yields the same results.
/// </ul>
/// When a set contains multi-code point strings, then these statements may not be true, depending on the strings in
/// the set (for example, whether they overlap with each other) and the string that is processed. For a set with
/// strings:
/// <ul>
/// <li>The complement of the set contains the opposite set of code points, but the same set of strings.
/// Therefore, complementing both the set and the span conditions may yield different results.
/// <li>When starting spans
/// at different positions in a string (span(s, ...) vs. span(s+1, ...)) the ends of the spans may be different
/// because a set string may start before the later position.
/// <li>span(SIMPLE) may be shorter than
/// span(CONTAINED) because it will not recursively try all possible paths. For example, with a set which
/// contains the three strings "xy", "xya" and "ax", span("xyax", CONTAINED) will return 4 but span("xyax",
/// SIMPLE) will return 3. span(SIMPLE) will never be longer than span(CONTAINED).
/// <li>With either "contained" condition, span() and spanBack() may partition a string in different ways. For example,
/// with a set which contains the two strings "ab" and "ba", and when processing the string "aba", span() will yield
/// contained/not-contained boundaries of { 0, 2, 3 } while spanBack() will yield boundaries of { 0, 1, 3 }.
/// </ul>
/// Note: If it is important to get the same boundaries whether iterating forward or backward through a string, then
/// either only span() should be used and the boundaries cached for backward operation, or an ICU BreakIterator could
/// be used.
///
/// Note: Unpaired surrogates are treated like surrogate code points. Similarly, set strings match only on code point
/// boundaries, never in the middle of a surrogate pair.
class UnicodeSet_SpanCondition extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/UnicodeSet\$SpanCondition");
  UnicodeSet_SpanCondition.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/icu/text/UnicodeSet\$SpanCondition;");

  /// from: static public android.icu.text.UnicodeSet.SpanCondition[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/icu/text/UnicodeSet\$SpanCondition;");

  /// from: static public android.icu.text.UnicodeSet.SpanCondition valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static UnicodeSet_SpanCondition valueOf(jni.JniString name) =>
      UnicodeSet_SpanCondition.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);
}

/// from: android.icu.text.UnicodeSet$EntryRange
///
/// A struct-like class used for iteration through ranges, for faster iteration than by String.
/// Read about the restrictions on usage in UnicodeSet\#ranges().
class UnicodeSet_EntryRange extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/UnicodeSet\$EntryRange");
  UnicodeSet_EntryRange.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_codepoint =
      jniAccessors.getFieldIDOf(_classRef, "codepoint", "I");

  /// from: public int codepoint
  ///
  /// The starting code point of the range.
  int get codepoint => jniAccessors
      .getField(reference, _id_codepoint, jni.JniType.intType)
      .integer;

  /// from: public int codepoint
  ///
  /// The starting code point of the range.
  set codepoint(int value) =>
      jniEnv.SetIntField(reference, _id_codepoint, value);

  static final _id_codepointEnd =
      jniAccessors.getFieldIDOf(_classRef, "codepointEnd", "I");

  /// from: public int codepointEnd
  ///
  /// The ending code point of the range
  int get codepointEnd => jniAccessors
      .getField(reference, _id_codepointEnd, jni.JniType.intType)
      .integer;

  /// from: public int codepointEnd
  ///
  /// The ending code point of the range
  set codepointEnd(int value) =>
      jniEnv.SetIntField(reference, _id_codepointEnd, value);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.icu.text.UnicodeSet$ComparisonStyle
///
/// Comparison style enums used by UnicodeSet\#compareTo(UnicodeSet, ComparisonStyle).
class UnicodeSet_ComparisonStyle extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/UnicodeSet\$ComparisonStyle");
  UnicodeSet_ComparisonStyle.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/icu/text/UnicodeSet\$ComparisonStyle;");

  /// from: static public android.icu.text.UnicodeSet.ComparisonStyle[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/icu/text/UnicodeSet\$ComparisonStyle;");

  /// from: static public android.icu.text.UnicodeSet.ComparisonStyle valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static UnicodeSet_ComparisonStyle valueOf(jni.JniString name) =>
      UnicodeSet_ComparisonStyle.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);
}
