// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "SearchIterator.dart" as searchiterator_;

import "RuleBasedCollator.dart" as rulebasedcollator_;

import "BreakIterator.dart" as breakiterator_;

import "../util/ULocale.dart" as ulocale_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.text.StringSearch
///
/// <tt>StringSearch</tt> is a SearchIterator that provides
/// language-sensitive text searching based on the comparison rules defined
/// in a RuleBasedCollator object.
/// StringSearch ensures that language eccentricity can be
/// handled, e.g. for the German collator, characters &szlig; and SS will be matched
/// if case is chosen to be ignored.
/// See the <a href="http://source.icu-project.org/repos/icu/icuhtml/trunk/design/collation/ICU_collation_design.htm">
/// "ICU Collation Design Document"</a> for more information.
///
/// There are 2 match options for selection:<br>
/// Let S' be the sub-string of a text string S between the offsets start and
/// end [start, end].
/// <br>
/// A pattern string P matches a text string S at the offsets [start, end]
/// if
/// <pre>
/// option 1. Some canonical equivalent of P matches some canonical equivalent
///           of S'
/// option 2. P matches S' and if P starts or ends with a combining mark,
///           there exists no non-ignorable combining mark before or after S?
///           in S respectively.
/// </pre>
/// Option 2. is the default.
///
/// This search has APIs similar to that of other text iteration mechanisms
/// such as the break iterators in BreakIterator. Using these
/// APIs, it is easy to scan through text looking for all occurrences of
/// a given pattern. This search iterator allows changing of direction by
/// calling a \#reset followed by a \#next or \#previous.
/// Though a direction change can occur without calling \#reset first,
/// this operation comes with some speed penalty.
/// Match results in the forward direction will match the result matches in
/// the backwards direction in the reverse order
///
/// SearchIterator provides APIs to specify the starting position
/// within the text string to be searched, e.g. SearchIterator\#setIndex setIndex,
/// SearchIterator\#preceding preceding and SearchIterator\#following following.
/// Since the starting position will be set as it is specified, please take note that
/// there are some danger points at which the search may render incorrect
/// results:
/// <ul>
/// <li> In the midst of a substring that requires normalization.
/// <li> If the following match is to be found, the position should not be the
///      second character which requires swapping with the preceding
///      character. Vice versa, if the preceding match is to be found, the
///      position to search from should not be the first character which
///      requires swapping with the next character. E.g certain Thai and
///      Lao characters require swapping.
/// <li> If a following pattern match is to be found, any position within a
///      contracting sequence except the first will fail. Vice versa if a
///      preceding pattern match is to be found, an invalid starting point
///      would be any character within a contracting sequence except the last.
/// </ul>
///
/// A BreakIterator can be used if only matches at logical breaks are desired.
/// Using a BreakIterator will only give you results that exactly matches the
/// boundaries given by the BreakIterator. For instance the pattern "e" will
/// not be found in the string "Ã©" if a character break iterator is used.
///
/// Options are provided to handle overlapping matches.
/// E.g. In English, overlapping matches produces the result 0 and 2
/// for the pattern "abab" in the text "ababab", where mutually
/// exclusive matches only produces the result of 0.
///
/// Options are also provided to implement "asymmetric search" as described in
/// <a href="http://www.unicode.org/reports/tr10/\#Asymmetric_Search">
/// UTS \#10 Unicode Collation Algorithm</a>, specifically the ElementComparisonType
/// values.
///
/// Though collator attributes will be taken into consideration while
/// performing matches, there are no APIs here for setting and getting the
/// attributes. These attributes can be set by getting the collator
/// from \#getCollator and using the APIs in RuleBasedCollator.
/// Lastly to update <tt>StringSearch</tt> to the new collator attributes,
/// \#reset has to be called.
///
/// Restriction: <br>
/// Currently there are no composite characters that consists of a
/// character with combining class &gt; 0 before a character with combining
/// class == 0. However, if such a character exists in the future,
/// <tt>StringSearch</tt> does not guarantee the results for option 1.
///
/// Consult the SearchIterator documentation for information on
/// and examples of how to use instances of this class to implement text
/// searching.
///
/// Note, <tt>StringSearch</tt> is not to be subclassed.
///
///
///@see SearchIterator
///@see RuleBasedCollator
///@author Laura Werner, synwee
class StringSearch extends searchiterator_.SearchIterator {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/StringSearch");
  StringSearch.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;Ljava/text/CharacterIterator;Landroid/icu/text/RuleBasedCollator;Landroid/icu/text/BreakIterator;)V");

  /// from: public void <init>(java.lang.String pattern, java.text.CharacterIterator target, android.icu.text.RuleBasedCollator collator, android.icu.text.BreakIterator breakiter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Initializes the iterator to use the language-specific rules defined in
  /// the argument collator to search for argument pattern in the argument
  /// target text. The argument <code>breakiter</code> is used to define logical matches.
  /// See super class documentation for more details on the use of the target
  /// text and BreakIterator.
  ///@param pattern text to look for.
  ///@param target target text to search for pattern.
  ///@param collator RuleBasedCollator that defines the language rules
  ///@param breakiter A BreakIterator that is used to determine the
  ///                boundaries of a logical match. This argument can be null.
  ///@throws IllegalArgumentException thrown when argument target is null,
  ///            or of length 0
  ///@see BreakIterator
  ///@see RuleBasedCollator
  StringSearch.ctor1(
      jni.JniString pattern,
      jni.JniObject target,
      rulebasedcollator_.RuleBasedCollator collator,
      breakiterator_.BreakIterator breakiter)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1, [
          pattern.reference,
          target.reference,
          collator.reference,
          breakiter.reference
        ]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;Ljava/text/CharacterIterator;Landroid/icu/text/RuleBasedCollator;)V");

  /// from: public void <init>(java.lang.String pattern, java.text.CharacterIterator target, android.icu.text.RuleBasedCollator collator)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Initializes the iterator to use the language-specific rules defined in
  /// the argument collator to search for argument pattern in the argument
  /// target text. No BreakIterators are set to test for logical matches.
  ///@param pattern text to look for.
  ///@param target target text to search for pattern.
  ///@param collator RuleBasedCollator that defines the language rules
  ///@throws IllegalArgumentException thrown when argument target is null,
  ///            or of length 0
  ///@see RuleBasedCollator
  StringSearch.ctor2(jni.JniString pattern, jni.JniObject target,
      rulebasedcollator_.RuleBasedCollator collator)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [pattern.reference, target.reference, collator.reference]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;Ljava/text/CharacterIterator;Ljava/util/Locale;)V");

  /// from: public void <init>(java.lang.String pattern, java.text.CharacterIterator target, java.util.Locale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Initializes the iterator to use the language-specific rules and
  /// break iterator rules defined in the argument locale to search for
  /// argument pattern in the argument target text.
  ///@param pattern text to look for.
  ///@param target target text to search for pattern.
  ///@param locale locale to use for language and break iterator rules
  ///@throws IllegalArgumentException thrown when argument target is null,
  ///            or of length 0. ClassCastException thrown if the collator for
  ///            the specified locale is not a RuleBasedCollator.
  StringSearch.ctor3(
      jni.JniString pattern, jni.JniObject target, jni.JniObject locale)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3,
            [pattern.reference, target.reference, locale.reference]).object);

  static final _id_ctor4 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;Ljava/text/CharacterIterator;Landroid/icu/util/ULocale;)V");

  /// from: public void <init>(java.lang.String pattern, java.text.CharacterIterator target, android.icu.util.ULocale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Initializes the iterator to use the language-specific rules and
  /// break iterator rules defined in the argument locale to search for
  /// argument pattern in the argument target text.
  /// See super class documentation for more details on the use of the target
  /// text and BreakIterator.
  ///@param pattern text to look for.
  ///@param target target text to search for pattern.
  ///@param locale locale to use for language and break iterator rules
  ///@throws IllegalArgumentException thrown when argument target is null,
  ///            or of length 0. ClassCastException thrown if the collator for
  ///            the specified locale is not a RuleBasedCollator.
  ///@see BreakIterator
  ///@see RuleBasedCollator
  ///@see SearchIterator
  StringSearch.ctor4(
      jni.JniString pattern, jni.JniObject target, ulocale_.ULocale locale)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor4,
            [pattern.reference, target.reference, locale.reference]).object);

  static final _id_ctor5 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String pattern, java.lang.String target)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Initializes the iterator to use the language-specific rules and
  /// break iterator rules defined in the default locale to search for
  /// argument pattern in the argument target text.
  ///@param pattern text to look for.
  ///@param target target text to search for pattern.
  ///@throws IllegalArgumentException thrown when argument target is null,
  ///            or of length 0. ClassCastException thrown if the collator for
  ///            the default locale is not a RuleBasedCollator.
  StringSearch.ctor5(jni.JniString pattern, jni.JniString target)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor5,
            [pattern.reference, target.reference]).object);

  static final _id_getCollator = jniAccessors.getMethodIDOf(
      _classRef, "getCollator", "()Landroid/icu/text/RuleBasedCollator;");

  /// from: public android.icu.text.RuleBasedCollator getCollator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the RuleBasedCollator used for the language rules.
  ///
  /// Since <tt>StringSearch</tt> depends on the returned RuleBasedCollator, any
  /// changes to the RuleBasedCollator result should follow with a call to
  /// either \#reset() or \#setCollator(RuleBasedCollator) to ensure the correct
  /// search behavior.
  ///
  ///
  ///@return RuleBasedCollator used by this <tt>StringSearch</tt>
  ///@see RuleBasedCollator
  ///@see \#setCollator
  rulebasedcollator_.RuleBasedCollator getCollator() =>
      rulebasedcollator_.RuleBasedCollator.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getCollator, jni.JniType.objectType, []).object);

  static final _id_setCollator = jniAccessors.getMethodIDOf(
      _classRef, "setCollator", "(Landroid/icu/text/RuleBasedCollator;)V");

  /// from: public void setCollator(android.icu.text.RuleBasedCollator collator)
  ///
  /// Sets the RuleBasedCollator to be used for language-specific searching.
  ///
  /// The iterator's position will not be changed by this method.
  ///@param collator to use for this <tt>StringSearch</tt>
  ///@throws IllegalArgumentException thrown when collator is null
  ///@see \#getCollator
  void setCollator(rulebasedcollator_.RuleBasedCollator collator) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCollator,
          jni.JniType.voidType, [collator.reference]).check();

  static final _id_getPattern = jniAccessors.getMethodIDOf(
      _classRef, "getPattern", "()Ljava/lang/String;");

  /// from: public java.lang.String getPattern()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the pattern for which <tt>StringSearch</tt> is searching for.
  ///@return the pattern searched for
  jni.JniString getPattern() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPattern, jni.JniType.objectType, []).object);

  static final _id_setPattern = jniAccessors.getMethodIDOf(
      _classRef, "setPattern", "(Ljava/lang/String;)V");

  /// from: public void setPattern(java.lang.String pattern)
  ///
  /// Set the pattern to search for.
  /// The iterator's position will not be changed by this method.
  ///@param pattern for searching
  ///@see \#getPattern
  ///@exception IllegalArgumentException thrown if pattern is null or of
  ///               length 0
  void setPattern(jni.JniString pattern) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setPattern,
      jni.JniType.voidType,
      [pattern.reference]).check();

  static final _id_isCanonical =
      jniAccessors.getMethodIDOf(_classRef, "isCanonical", "()Z");

  /// from: public boolean isCanonical()
  ///
  /// Determines whether canonical matches (option 1, as described in the
  /// class documentation) is set.
  /// See setCanonical(boolean) for more information.
  ///@see \#setCanonical
  ///@return true if canonical matches is set, false otherwise
  bool isCanonical() => jniAccessors.callMethodWithArgs(
      reference, _id_isCanonical, jni.JniType.booleanType, []).boolean;

  static final _id_setCanonical =
      jniAccessors.getMethodIDOf(_classRef, "setCanonical", "(Z)V");

  /// from: public void setCanonical(boolean allowCanonical)
  ///
  /// Set the canonical match mode. See class documentation for details.
  /// The default setting for this property is false.
  ///@param allowCanonical flag indicator if canonical matches are allowed
  ///@see \#isCanonical
  void setCanonical(bool allowCanonical) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setCanonical,
      jni.JniType.voidType,
      [allowCanonical]).check();

  static final _id_setTarget = jniAccessors.getMethodIDOf(
      _classRef, "setTarget", "(Ljava/text/CharacterIterator;)V");

  /// from: public void setTarget(java.text.CharacterIterator text)
  ///
  /// {@inheritDoc}
  void setTarget(jni.JniObject text) => jniAccessors.callMethodWithArgs(
      reference, _id_setTarget, jni.JniType.voidType, [text.reference]).check();

  static final _id_getIndex =
      jniAccessors.getMethodIDOf(_classRef, "getIndex", "()I");

  /// from: public int getIndex()
  ///
  /// {@inheritDoc}
  int getIndex() => jniAccessors.callMethodWithArgs(
      reference, _id_getIndex, jni.JniType.intType, []).integer;

  static final _id_setIndex =
      jniAccessors.getMethodIDOf(_classRef, "setIndex", "(I)V");

  /// from: public void setIndex(int position)
  ///
  /// {@inheritDoc}
  void setIndex(int position) => jniAccessors.callMethodWithArgs(
      reference, _id_setIndex, jni.JniType.voidType, [position]).check();

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, "reset", "()V");

  /// from: public void reset()
  ///
  /// {@inheritDoc}
  void reset() => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniType.voidType, []).check();

  static final _id_handleNext =
      jniAccessors.getMethodIDOf(_classRef, "handleNext", "(I)I");

  /// from: protected int handleNext(int position)
  ///
  /// {@inheritDoc}
  int handleNext(int position) => jniAccessors.callMethodWithArgs(
      reference, _id_handleNext, jni.JniType.intType, [position]).integer;

  static final _id_handlePrevious =
      jniAccessors.getMethodIDOf(_classRef, "handlePrevious", "(I)I");

  /// from: protected int handlePrevious(int position)
  ///
  /// {@inheritDoc}
  int handlePrevious(int position) => jniAccessors.callMethodWithArgs(
      reference, _id_handlePrevious, jni.JniType.intType, [position]).integer;
}
