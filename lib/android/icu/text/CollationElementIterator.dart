// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "RuleBasedCollator.dart" as rulebasedcollator_;

import "UCharacterIterator.dart" as ucharacteriterator_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.text.CollationElementIterator
///
/// <code>CollationElementIterator</code> is an iterator created by
/// a RuleBasedCollator to walk through a string. The return result of
/// each iteration is a 32-bit collation element (CE) that defines the
/// ordering priority of the next character or sequence of characters
/// in the source string.
///
/// For illustration, consider the following in Slovak and in traditional Spanish collation:
/// <blockquote>
/// <pre>
/// "ca" -&gt; the first collation element is CE('c') and the second
///         collation element is CE('a').
/// "cha" -&gt; the first collation element is CE('ch') and the second
///          collation element is CE('a').
/// </pre>
/// </blockquote>
/// And in German phonebook collation,
/// <blockquote>
/// <pre>
/// Since the character '&\#230;' is a composed character of 'a' and 'e', the
/// iterator returns two collation elements for the single character '&\#230;'
///
/// "&\#230;b" -&gt; the first collation element is collation_element('a'), the
///              second collation element is collation_element('e'), and the
///              third collation element is collation_element('b').
/// </pre>
/// </blockquote>
///
/// For collation ordering comparison, the collation element results
/// can not be compared simply by using basic arithmetic operators,
/// e.g. &lt;, == or &gt;, further processing has to be done. Details
/// can be found in the ICU
/// <a href="http://userguide.icu-project.org/collation/architecture">
/// User Guide</a>. An example of using the CollationElementIterator
/// for collation ordering comparison is the class
/// android.icu.text.StringSearch.
///
/// To construct a CollationElementIterator object, users
/// call the method getCollationElementIterator() on a
/// RuleBasedCollator that defines the desired sorting order.
///
///  Example:
/// <blockquote>
/// <pre>
///  String testString = "This is a test";
///  RuleBasedCollator rbc = new RuleBasedCollator("&amp;a&lt;b");
///  CollationElementIterator iterator = rbc.getCollationElementIterator(testString);
///  int primaryOrder = iterator.IGNORABLE;
///  while (primaryOrder != iterator.NULLORDER) {
///      int order = iterator.next();
///      if (order != iterator.IGNORABLE &amp;&amp;
///          order != iterator.NULLORDER) {
///          // order is valid, not ignorable and we have not passed the end
///          // of the iteration, we do something
///          primaryOrder = CollationElementIterator.primaryOrder(order);
///          System.out.println("Next primary order 0x" +
///                             Integer.toHexString(primaryOrder));
///      }
///  }
/// </pre>
/// </blockquote>
///
/// The method next() returns the collation order of the next character based on
/// the comparison level of the collator. The method previous() returns the
/// collation order of the previous character based on the comparison level of
/// the collator. The Collation Element Iterator moves only in one direction
/// between calls to reset(), setOffset(), or setText(). That is, next() and
/// previous() can not be inter-used. Whenever previous() is to be called after
/// next() or vice versa, reset(), setOffset() or setText() has to be called first
/// to reset the status, shifting current position to either the end or the start of
/// the string (reset() or setText()), or the specified position (setOffset()).
/// Hence at the next call of next() or previous(), the first or last collation order,
/// or collation order at the specified position will be returned. If a change of
/// direction is done without one of these calls, the result is undefined.
///
/// This class is not subclassable.
///@see Collator
///@see RuleBasedCollator
///@see StringSearch
///@author Syn Wee Quek
class CollationElementIterator extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/CollationElementIterator");
  CollationElementIterator.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int IGNORABLE
  ///
  /// This constant is returned by the iterator in the methods
  /// next() and previous() when a collation element result is to be
  /// ignored.
  ///
  /// See class documentation for an example of use.
  ///@see \#next
  ///@see \#previous
  static const IGNORABLE = 0;

  /// from: static public final int NULLORDER
  ///
  /// This constant is returned by the iterator in the methods
  /// next() and previous() when the end or the beginning of the
  /// source string has been reached, and there are no more valid
  /// collation elements to return.
  ///
  /// See class documentation for an example of use.
  ///@see \#next
  ///@see \#previous
  static const NULLORDER = -1;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/icu/text/RuleBasedCollator;)V");

  /// from: void <init>(android.icu.text.RuleBasedCollator collator)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CollationElementIterator(rulebasedcollator_.RuleBasedCollator collator)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [collator.reference]).object);

  static final _id_primaryOrder =
      jniAccessors.getStaticMethodIDOf(_classRef, "primaryOrder", "(I)I");

  /// from: static public int primaryOrder(int ce)
  ///
  /// Return the primary order of the specified collation element,
  /// i.e. the first 16 bits.  This value is unsigned.
  ///@param ce the collation element
  ///@return the element's 16 bits primary order.
  static int primaryOrder(int ce) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_primaryOrder, jni.JniType.intType, [ce]).integer;

  static final _id_secondaryOrder =
      jniAccessors.getStaticMethodIDOf(_classRef, "secondaryOrder", "(I)I");

  /// from: static public int secondaryOrder(int ce)
  ///
  /// Return the secondary order of the specified collation element,
  /// i.e. the 16th to 23th bits, inclusive.  This value is unsigned.
  ///@param ce the collation element
  ///@return the element's 8 bits secondary order
  static int secondaryOrder(int ce) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_secondaryOrder, jni.JniType.intType, [ce]).integer;

  static final _id_tertiaryOrder =
      jniAccessors.getStaticMethodIDOf(_classRef, "tertiaryOrder", "(I)I");

  /// from: static public int tertiaryOrder(int ce)
  ///
  /// Return the tertiary order of the specified collation element, i.e. the last
  /// 8 bits.  This value is unsigned.
  ///@param ce the collation element
  ///@return the element's 8 bits tertiary order
  static int tertiaryOrder(int ce) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_tertiaryOrder, jni.JniType.intType, [ce]).integer;

  static final _id_getOffset =
      jniAccessors.getMethodIDOf(_classRef, "getOffset", "()I");

  /// from: public int getOffset()
  ///
  /// Returns the character offset in the source string
  /// corresponding to the next collation element. I.e., getOffset()
  /// returns the position in the source string corresponding to the
  /// collation element that will be returned by the next call to
  /// next() or previous(). This value could be any of:
  /// <ul>
  /// <li> The index of the __first__ character corresponding to
  /// the next collation element. (This means that if
  /// <code>setOffset(offset)</code> sets the index in the middle of
  /// a contraction, <code>getOffset()</code> returns the index of
  /// the first character in the contraction, which may not be equal
  /// to the original offset that was set. Hence calling getOffset()
  /// immediately after setOffset(offset) does not guarantee that the
  /// original offset set will be returned.)
  /// <li> If normalization is on, the index of the __immediate__
  /// subsequent character, or composite character with the first
  /// character, having a combining class of 0.
  /// <li> The length of the source string, if iteration has reached
  /// the end.
  ///</ul>
  ///@return The character offset in the source string corresponding to the
  ///         collation element that will be returned by the next call to
  ///         next() or previous().
  int getOffset() => jniAccessors.callMethodWithArgs(
      reference, _id_getOffset, jni.JniType.intType, []).integer;

  static final _id_next = jniAccessors.getMethodIDOf(_classRef, "next", "()I");

  /// from: public int next()
  ///
  /// Get the next collation element in the source string.
  ///
  /// This iterator iterates over a sequence of collation elements
  /// that were built from the string. Because there isn't
  /// necessarily a one-to-one mapping from characters to collation
  /// elements, this doesn't mean the same thing as "return the
  /// collation element [or ordering priority] of the next character
  /// in the string".
  ///
  /// This function returns the collation element that the
  /// iterator is currently pointing to, and then updates the
  /// internal pointer to point to the next element.
  ///@return the next collation element or NULLORDER if the end of the
  ///         iteration has been reached.
  int next() => jniAccessors
      .callMethodWithArgs(reference, _id_next, jni.JniType.intType, []).integer;

  static final _id_previous =
      jniAccessors.getMethodIDOf(_classRef, "previous", "()I");

  /// from: public int previous()
  ///
  /// Get the previous collation element in the source string.
  ///
  /// This iterator iterates over a sequence of collation elements
  /// that were built from the string. Because there isn't
  /// necessarily a one-to-one mapping from characters to collation
  /// elements, this doesn't mean the same thing as "return the
  /// collation element [or ordering priority] of the previous
  /// character in the string".
  ///
  /// This function updates the iterator's internal pointer to
  /// point to the collation element preceding the one it's currently
  /// pointing to and then returns that element, while next() returns
  /// the current element and then updates the pointer.
  ///@return the previous collation element, or NULLORDER when the start of
  ///             the iteration has been reached.
  int previous() => jniAccessors.callMethodWithArgs(
      reference, _id_previous, jni.JniType.intType, []).integer;

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, "reset", "()V");

  /// from: public void reset()
  ///
  /// Resets the cursor to the beginning of the string. The next
  /// call to next() or previous() will return the first and last
  /// collation element in the string, respectively.
  ///
  /// If the RuleBasedCollator used by this iterator has had its
  /// attributes changed, calling reset() will reinitialize the
  /// iterator to use the new attributes.
  void reset() => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniType.voidType, []).check();

  static final _id_setOffset =
      jniAccessors.getMethodIDOf(_classRef, "setOffset", "(I)V");

  /// from: public void setOffset(int newOffset)
  ///
  /// Sets the iterator to point to the collation element
  /// corresponding to the character at the specified offset. The
  /// value returned by the next call to next() will be the collation
  /// element corresponding to the characters at offset.
  ///
  /// If offset is in the middle of a contracting character
  /// sequence, the iterator is adjusted to the start of the
  /// contracting sequence. This means that getOffset() is not
  /// guaranteed to return the same value set by this method.
  ///
  /// If the decomposition mode is on, and offset is in the middle
  /// of a decomposible range of source text, the iterator may not
  /// return a correct result for the next forwards or backwards
  /// iteration.  The user must ensure that the offset is not in the
  /// middle of a decomposible range.
  ///@param newOffset the character offset into the original source string to
  ///        set. Note that this is not an offset into the corresponding
  ///        sequence of collation elements.
  void setOffset(int newOffset) => jniAccessors.callMethodWithArgs(
      reference, _id_setOffset, jni.JniType.voidType, [newOffset]).check();

  static final _id_setText =
      jniAccessors.getMethodIDOf(_classRef, "setText", "(Ljava/lang/String;)V");

  /// from: public void setText(java.lang.String source)
  ///
  /// Set a new source string for iteration, and reset the offset
  /// to the beginning of the text.
  ///@param source the new source string for iteration.
  void setText(jni.JniString source) => jniAccessors.callMethodWithArgs(
      reference, _id_setText, jni.JniType.voidType, [source.reference]).check();

  static final _id_setText1 = jniAccessors.getMethodIDOf(
      _classRef, "setText", "(Landroid/icu/text/UCharacterIterator;)V");

  /// from: public void setText(android.icu.text.UCharacterIterator source)
  ///
  /// Set a new source string iterator for iteration, and reset the
  /// offset to the beginning of the text.
  ///
  /// The source iterator's integrity will be preserved since a new copy
  /// will be created for use.
  ///@param source the new source string iterator for iteration.
  void setText1(ucharacteriterator_.UCharacterIterator source) =>
      jniAccessors.callMethodWithArgs(reference, _id_setText1,
          jni.JniType.voidType, [source.reference]).check();

  static final _id_setText2 = jniAccessors.getMethodIDOf(
      _classRef, "setText", "(Ljava/text/CharacterIterator;)V");

  /// from: public void setText(java.text.CharacterIterator source)
  ///
  /// Set a new source string iterator for iteration, and reset the
  /// offset to the beginning of the text.
  ///@param source the new source string iterator for iteration.
  void setText2(jni.JniObject source) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setText2,
      jni.JniType.voidType,
      [source.reference]).check();

  static final _id_getMaxExpansion =
      jniAccessors.getMethodIDOf(_classRef, "getMaxExpansion", "(I)I");

  /// from: public int getMaxExpansion(int ce)
  ///
  /// Returns the maximum length of any expansion sequence that ends with
  /// the specified collation element. If there is no expansion with this
  /// collation element as the last element, returns 1.
  ///@param ce a collation element returned by previous() or next().
  ///@return the maximum length of any expansion sequence ending
  ///         with the specified collation element.
  int getMaxExpansion(int ce) => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxExpansion, jni.JniType.intType, [ce]).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object that)
  ///
  /// Tests that argument object is equals to this CollationElementIterator.
  /// Iterators are equal if the objects uses the same RuleBasedCollator,
  /// the same source text and have the same current position in iteration.
  ///@param that object to test if it is equals to this
  ///             CollationElementIterator
  bool equals1(jni.JniObject that) => jniAccessors.callMethodWithArgs(reference,
      _id_equals1, jni.JniType.booleanType, [that.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// Mock implementation of hashCode(). This implementation always returns a constant
  /// value. When Java assertion is enabled, this method triggers an assertion failure.
  ///@deprecated This API is ICU internal only.
  ///@hide original deprecated declaration
  ///@hide draft / provisional / internal are hidden on Android
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}
