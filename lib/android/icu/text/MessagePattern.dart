// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.text.MessagePattern
///
/// Parses and represents ICU MessageFormat patterns.
/// Also handles patterns for ChoiceFormat, PluralFormat and SelectFormat.
/// Used in the implementations of those classes as well as in tools
/// for message validation, translation and format conversion.
///
/// The parser handles all syntax relevant for identifying message arguments.
/// This includes "complex" arguments whose style strings contain
/// nested MessageFormat pattern substrings.
/// For "simple" arguments (with no nested MessageFormat pattern substrings),
/// the argument style is not parsed any further.
///
/// The parser handles named and numbered message arguments and allows both in one message.
///
/// Once a pattern has been parsed successfully, iterate through the parsed data
/// with countParts(), getPart() and related methods.
///
/// The data logically represents a parse tree, but is stored and accessed
/// as a list of "parts" for fast and simple parsing and to minimize object allocations.
/// Arguments and nested messages are best handled via recursion.
/// For every _START "part", \#getLimitPartIndex(int) efficiently returns
/// the index of the corresponding _LIMIT "part".
///
/// List of "parts":
/// <pre>
/// message = MSG_START (SKIP_SYNTAX | INSERT_CHAR | REPLACE_NUMBER | argument)* MSG_LIMIT
/// argument = noneArg | simpleArg | complexArg
/// complexArg = choiceArg | pluralArg | selectArg
///
/// noneArg = ARG_START.NONE (ARG_NAME | ARG_NUMBER) ARG_LIMIT.NONE
/// simpleArg = ARG_START.SIMPLE (ARG_NAME | ARG_NUMBER) ARG_TYPE [ARG_STYLE] ARG_LIMIT.SIMPLE
/// choiceArg = ARG_START.CHOICE (ARG_NAME | ARG_NUMBER) choiceStyle ARG_LIMIT.CHOICE
/// pluralArg = ARG_START.PLURAL (ARG_NAME | ARG_NUMBER) pluralStyle ARG_LIMIT.PLURAL
/// selectArg = ARG_START.SELECT (ARG_NAME | ARG_NUMBER) selectStyle ARG_LIMIT.SELECT
///
/// choiceStyle = ((ARG_INT | ARG_DOUBLE) ARG_SELECTOR message)+
/// pluralStyle = [ARG_INT | ARG_DOUBLE] (ARG_SELECTOR [ARG_INT | ARG_DOUBLE] message)+
/// selectStyle = (ARG_SELECTOR message)+
/// </pre>
/// <ul>
///   <li>Literal output text is not represented directly by "parts" but accessed
///       between parts of a message, from one part's getLimit() to the next part's getIndex().
///   <li><code>ARG_START.CHOICE</code> stands for an ARG_START Part with ArgType CHOICE.
///   <li>In the choiceStyle, the ARG_SELECTOR has the '&lt;', the '\#' or
///       the less-than-or-equal-to sign (U+2264).
///   <li>In the pluralStyle, the first, optional numeric Part has the "offset:" value.
///       The optional numeric Part between each (ARG_SELECTOR, message) pair
///       is the value of an explicit-number selector like "=2",
///       otherwise the selector is a non-numeric identifier.
///   <li>The REPLACE_NUMBER Part can occur only in an immediate sub-message of the pluralStyle.
/// </ul>
///
/// This class is not intended for public subclassing.
///@author Markus Scherer
class MessagePattern extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/MessagePattern");
  MessagePattern.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ARG_NAME_NOT_NUMBER
  ///
  /// Return value from \#validateArgumentName(String) for when
  /// the string is a valid "pattern identifier" but not a number.
  static const ARG_NAME_NOT_NUMBER = -1;

  /// from: static public final int ARG_NAME_NOT_VALID
  ///
  /// Return value from \#validateArgumentName(String) for when
  /// the string is invalid.
  /// It might not be a valid "pattern identifier",
  /// or it have only ASCII digits but there is a leading zero or the number is too large.
  static const ARG_NAME_NOT_VALID = -2;

  /// from: static public final double NO_NUMERIC_VALUE
  ///
  /// Special value that is returned by getNumericValue(Part) when no
  /// numeric value is defined for a part.
  ///@see \#getNumericValue
  static const NO_NUMERIC_VALUE = -123456789.0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs an empty MessagePattern with default ApostropheMode.
  MessagePattern()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/icu/text/MessagePattern\$ApostropheMode;)V");

  /// from: public void <init>(android.icu.text.MessagePattern.ApostropheMode mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs an empty MessagePattern.
  ///@param mode Explicit ApostropheMode.
  MessagePattern.ctor1(MessagePattern_ApostropheMode mode)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [mode.reference]).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String pattern)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a MessagePattern with default ApostropheMode and
  /// parses the MessageFormat pattern string.
  ///@param pattern a MessageFormat pattern string
  ///@throws IllegalArgumentException for syntax errors in the pattern string
  ///@throws IndexOutOfBoundsException if certain limits are exceeded
  ///         (e.g., argument number too high, argument name too long, etc.)
  ///@throws NumberFormatException if a number could not be parsed
  MessagePattern.ctor2(jni.JniString pattern)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [pattern.reference]).object);

  static final _id_parse = jniAccessors.getMethodIDOf(_classRef, "parse",
      "(Ljava/lang/String;)Landroid/icu/text/MessagePattern;");

  /// from: public android.icu.text.MessagePattern parse(java.lang.String pattern)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a MessageFormat pattern string.
  ///@param pattern a MessageFormat pattern string
  ///@return this
  ///@throws IllegalArgumentException for syntax errors in the pattern string
  ///@throws IndexOutOfBoundsException if certain limits are exceeded
  ///         (e.g., argument number too high, argument name too long, etc.)
  ///@throws NumberFormatException if a number could not be parsed
  MessagePattern parse(jni.JniString pattern) =>
      MessagePattern.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_parse, jni.JniType.objectType, [pattern.reference]).object);

  static final _id_parseChoiceStyle = jniAccessors.getMethodIDOf(
      _classRef,
      "parseChoiceStyle",
      "(Ljava/lang/String;)Landroid/icu/text/MessagePattern;");

  /// from: public android.icu.text.MessagePattern parseChoiceStyle(java.lang.String pattern)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a ChoiceFormat pattern string.
  ///@param pattern a ChoiceFormat pattern string
  ///@return this
  ///@throws IllegalArgumentException for syntax errors in the pattern string
  ///@throws IndexOutOfBoundsException if certain limits are exceeded
  ///         (e.g., argument number too high, argument name too long, etc.)
  ///@throws NumberFormatException if a number could not be parsed
  MessagePattern parseChoiceStyle(jni.JniString pattern) =>
      MessagePattern.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_parseChoiceStyle,
          jni.JniType.objectType,
          [pattern.reference]).object);

  static final _id_parsePluralStyle = jniAccessors.getMethodIDOf(
      _classRef,
      "parsePluralStyle",
      "(Ljava/lang/String;)Landroid/icu/text/MessagePattern;");

  /// from: public android.icu.text.MessagePattern parsePluralStyle(java.lang.String pattern)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PluralFormat pattern string.
  ///@param pattern a PluralFormat pattern string
  ///@return this
  ///@throws IllegalArgumentException for syntax errors in the pattern string
  ///@throws IndexOutOfBoundsException if certain limits are exceeded
  ///         (e.g., argument number too high, argument name too long, etc.)
  ///@throws NumberFormatException if a number could not be parsed
  MessagePattern parsePluralStyle(jni.JniString pattern) =>
      MessagePattern.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_parsePluralStyle,
          jni.JniType.objectType,
          [pattern.reference]).object);

  static final _id_parseSelectStyle = jniAccessors.getMethodIDOf(
      _classRef,
      "parseSelectStyle",
      "(Ljava/lang/String;)Landroid/icu/text/MessagePattern;");

  /// from: public android.icu.text.MessagePattern parseSelectStyle(java.lang.String pattern)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a SelectFormat pattern string.
  ///@param pattern a SelectFormat pattern string
  ///@return this
  ///@throws IllegalArgumentException for syntax errors in the pattern string
  ///@throws IndexOutOfBoundsException if certain limits are exceeded
  ///         (e.g., argument number too high, argument name too long, etc.)
  ///@throws NumberFormatException if a number could not be parsed
  MessagePattern parseSelectStyle(jni.JniString pattern) =>
      MessagePattern.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_parseSelectStyle,
          jni.JniType.objectType,
          [pattern.reference]).object);

  static final _id_clear =
      jniAccessors.getMethodIDOf(_classRef, "clear", "()V");

  /// from: public void clear()
  ///
  /// Clears this MessagePattern.
  /// countParts() will return 0.
  void clear() => jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniType.voidType, []).check();

  static final _id_clearPatternAndSetApostropheMode =
      jniAccessors.getMethodIDOf(_classRef, "clearPatternAndSetApostropheMode",
          "(Landroid/icu/text/MessagePattern\$ApostropheMode;)V");

  /// from: public void clearPatternAndSetApostropheMode(android.icu.text.MessagePattern.ApostropheMode mode)
  ///
  /// Clears this MessagePattern and sets the ApostropheMode.
  /// countParts() will return 0.
  ///@param mode The new ApostropheMode.
  void clearPatternAndSetApostropheMode(MessagePattern_ApostropheMode mode) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_clearPatternAndSetApostropheMode,
          jni.JniType.voidType,
          [mode.reference]).check();

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object other)
  ///
  /// @param other another object to compare with.
  ///@return true if this object is equivalent to the other one.
  bool equals1(jni.JniObject other) => jniAccessors.callMethodWithArgs(
      reference,
      _id_equals1,
      jni.JniType.booleanType,
      [other.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// {@inheritDoc}
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_getApostropheMode = jniAccessors.getMethodIDOf(
      _classRef,
      "getApostropheMode",
      "()Landroid/icu/text/MessagePattern\$ApostropheMode;");

  /// from: public android.icu.text.MessagePattern.ApostropheMode getApostropheMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return this instance's ApostropheMode.
  MessagePattern_ApostropheMode getApostropheMode() =>
      MessagePattern_ApostropheMode.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getApostropheMode, jni.JniType.objectType, []).object);

  static final _id_getPatternString = jniAccessors.getMethodIDOf(
      _classRef, "getPatternString", "()Ljava/lang/String;");

  /// from: public java.lang.String getPatternString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the parsed pattern string (null if none was parsed).
  jni.JniString getPatternString() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPatternString, jni.JniType.objectType, []).object);

  static final _id_hasNamedArguments =
      jniAccessors.getMethodIDOf(_classRef, "hasNamedArguments", "()Z");

  /// from: public boolean hasNamedArguments()
  ///
  /// Does the parsed pattern have named arguments like {first_name}?
  ///@return true if the parsed pattern has at least one named argument.
  bool hasNamedArguments() => jniAccessors.callMethodWithArgs(
      reference, _id_hasNamedArguments, jni.JniType.booleanType, []).boolean;

  static final _id_hasNumberedArguments =
      jniAccessors.getMethodIDOf(_classRef, "hasNumberedArguments", "()Z");

  /// from: public boolean hasNumberedArguments()
  ///
  /// Does the parsed pattern have numbered arguments like {2}?
  ///@return true if the parsed pattern has at least one numbered argument.
  bool hasNumberedArguments() => jniAccessors.callMethodWithArgs(
      reference, _id_hasNumberedArguments, jni.JniType.booleanType, []).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_validateArgumentName = jniAccessors.getStaticMethodIDOf(
      _classRef, "validateArgumentName", "(Ljava/lang/String;)I");

  /// from: static public int validateArgumentName(java.lang.String name)
  ///
  /// Validates and parses an argument name or argument number string.
  /// An argument name must be a "pattern identifier", that is, it must contain
  /// no Unicode Pattern_Syntax or Pattern_White_Space characters.
  /// If it only contains ASCII digits, then it must be a small integer with no leading zero.
  ///@param name Input string.
  ///@return &gt;=0 if the name is a valid number,
  ///         ARG_NAME_NOT_NUMBER (-1) if it is a "pattern identifier" but not all ASCII digits,
  ///         ARG_NAME_NOT_VALID (-2) if it is neither.
  static int validateArgumentName(jni.JniString name) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_validateArgumentName,
          jni.JniType.intType, [name.reference]).integer;

  static final _id_autoQuoteApostropheDeep = jniAccessors.getMethodIDOf(
      _classRef, "autoQuoteApostropheDeep", "()Ljava/lang/String;");

  /// from: public java.lang.String autoQuoteApostropheDeep()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a version of the parsed pattern string where each ASCII apostrophe
  /// is doubled (escaped) if it is not already, and if it is not interpreted as quoting syntax.
  ///
  /// For example, this turns "I don't '{know}' {gender,select,female{h''er}other{h'im}}."
  /// into "I don''t '{know}' {gender,select,female{h''er}other{h''im}}."
  ///@return the deep-auto-quoted version of the parsed pattern string.
  ///@see MessageFormat\#autoQuoteApostrophe(String)
  jni.JniString autoQuoteApostropheDeep() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_autoQuoteApostropheDeep, jni.JniType.objectType, []).object);

  static final _id_countParts =
      jniAccessors.getMethodIDOf(_classRef, "countParts", "()I");

  /// from: public int countParts()
  ///
  /// Returns the number of "parts" created by parsing the pattern string.
  /// Returns 0 if no pattern has been parsed or clear() was called.
  ///@return the number of pattern parts.
  int countParts() => jniAccessors.callMethodWithArgs(
      reference, _id_countParts, jni.JniType.intType, []).integer;

  static final _id_getPart = jniAccessors.getMethodIDOf(
      _classRef, "getPart", "(I)Landroid/icu/text/MessagePattern\$Part;");

  /// from: public android.icu.text.MessagePattern.Part getPart(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the i-th pattern "part".
  ///@param i The index of the Part data. (0..countParts()-1)
  ///@return the i-th pattern "part".
  ///@throws IndexOutOfBoundsException if i is outside the (0..countParts()-1) range
  MessagePattern_Part getPart(int i) =>
      MessagePattern_Part.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPart, jni.JniType.objectType, [i]).object);

  static final _id_getPartType = jniAccessors.getMethodIDOf(_classRef,
      "getPartType", "(I)Landroid/icu/text/MessagePattern\$Part\$Type;");

  /// from: public android.icu.text.MessagePattern.Part.Type getPartType(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Part.Type of the i-th pattern "part".
  /// Convenience method for getPart(i).getType().
  ///@param i The index of the Part data. (0..countParts()-1)
  ///@return The Part.Type of the i-th Part.
  ///@throws IndexOutOfBoundsException if i is outside the (0..countParts()-1) range
  MessagePattern_Part_Type getPartType(int i) =>
      MessagePattern_Part_Type.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPartType, jni.JniType.objectType, [i]).object);

  static final _id_getPatternIndex =
      jniAccessors.getMethodIDOf(_classRef, "getPatternIndex", "(I)I");

  /// from: public int getPatternIndex(int partIndex)
  ///
  /// Returns the pattern index of the specified pattern "part".
  /// Convenience method for getPart(partIndex).getIndex().
  ///@param partIndex The index of the Part data. (0..countParts()-1)
  ///@return The pattern index of this Part.
  ///@throws IndexOutOfBoundsException if partIndex is outside the (0..countParts()-1) range
  int getPatternIndex(int partIndex) => jniAccessors.callMethodWithArgs(
      reference, _id_getPatternIndex, jni.JniType.intType, [partIndex]).integer;

  static final _id_getSubstring = jniAccessors.getMethodIDOf(
      _classRef,
      "getSubstring",
      "(Landroid/icu/text/MessagePattern\$Part;)Ljava/lang/String;");

  /// from: public java.lang.String getSubstring(android.icu.text.MessagePattern.Part part)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the substring of the pattern string indicated by the Part.
  /// Convenience method for getPatternString().substring(part.getIndex(), part.getLimit()).
  ///@param part a part of this MessagePattern.
  ///@return the substring associated with part.
  jni.JniString getSubstring(MessagePattern_Part part0) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSubstring, jni.JniType.objectType, [part0.reference]).object);

  static final _id_partSubstringMatches = jniAccessors.getMethodIDOf(
      _classRef,
      "partSubstringMatches",
      "(Landroid/icu/text/MessagePattern\$Part;Ljava/lang/String;)Z");

  /// from: public boolean partSubstringMatches(android.icu.text.MessagePattern.Part part, java.lang.String s)
  ///
  /// Compares the part's substring with the input string s.
  ///@param part a part of this MessagePattern.
  ///@param s a string.
  ///@return true if getSubstring(part).equals(s).
  bool partSubstringMatches(MessagePattern_Part part0, jni.JniString s) =>
      jniAccessors.callMethodWithArgs(reference, _id_partSubstringMatches,
          jni.JniType.booleanType, [part0.reference, s.reference]).boolean;

  static final _id_getNumericValue = jniAccessors.getMethodIDOf(_classRef,
      "getNumericValue", "(Landroid/icu/text/MessagePattern\$Part;)D");

  /// from: public double getNumericValue(android.icu.text.MessagePattern.Part part)
  ///
  /// Returns the numeric value associated with an ARG_INT or ARG_DOUBLE.
  ///@param part a part of this MessagePattern.
  ///@return the part's numeric value, or NO_NUMERIC_VALUE if this is not a numeric part.
  double getNumericValue(MessagePattern_Part part0) =>
      jniAccessors.callMethodWithArgs(reference, _id_getNumericValue,
          jni.JniType.doubleType, [part0.reference]).doubleFloat;

  static final _id_getPluralOffset =
      jniAccessors.getMethodIDOf(_classRef, "getPluralOffset", "(I)D");

  /// from: public double getPluralOffset(int pluralStart)
  ///
  /// Returns the "offset:" value of a PluralFormat argument, or 0 if none is specified.
  ///@param pluralStart the index of the first PluralFormat argument style part. (0..countParts()-1)
  ///@return the "offset:" value.
  ///@throws IndexOutOfBoundsException if pluralStart is outside the (0..countParts()-1) range
  double getPluralOffset(int pluralStart) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getPluralOffset,
      jni.JniType.doubleType,
      [pluralStart]).doubleFloat;

  static final _id_getLimitPartIndex =
      jniAccessors.getMethodIDOf(_classRef, "getLimitPartIndex", "(I)I");

  /// from: public int getLimitPartIndex(int start)
  ///
  /// Returns the index of the ARG|MSG_LIMIT part corresponding to the ARG|MSG_START at start.
  ///@param start The index of some Part data (0..countParts()-1);
  ///        this Part should be of Type ARG_START or MSG_START.
  ///@return The first i&gt;start where getPart(i).getType()==ARG|MSG_LIMIT at the same nesting level,
  ///         or start itself if getPartType(msgStart)!=ARG|MSG_START.
  ///@throws IndexOutOfBoundsException if start is outside the (0..countParts()-1) range
  int getLimitPartIndex(int start) => jniAccessors.callMethodWithArgs(
      reference, _id_getLimitPartIndex, jni.JniType.intType, [start]).integer;

  static final _id_clone =
      jniAccessors.getMethodIDOf(_classRef, "clone", "()Ljava/lang/Object;");

  /// from: public java.lang.Object clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates and returns a copy of this object.
  ///@return a copy of this object (or itself if frozen).
  jni.JniObject clone() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_cloneAsThawed = jniAccessors.getMethodIDOf(
      _classRef, "cloneAsThawed", "()Landroid/icu/text/MessagePattern;");

  /// from: public android.icu.text.MessagePattern cloneAsThawed()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates and returns an unfrozen copy of this object.
  ///@return a copy of this object.
  MessagePattern cloneAsThawed() =>
      MessagePattern.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_cloneAsThawed, jni.JniType.objectType, []).object);

  static final _id_freeze = jniAccessors.getMethodIDOf(
      _classRef, "freeze", "()Landroid/icu/text/MessagePattern;");

  /// from: public android.icu.text.MessagePattern freeze()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Freezes this object, making it immutable and thread-safe.
  ///@return this
  MessagePattern freeze() =>
      MessagePattern.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_freeze, jni.JniType.objectType, []).object);

  static final _id_isFrozen =
      jniAccessors.getMethodIDOf(_classRef, "isFrozen", "()Z");

  /// from: public boolean isFrozen()
  ///
  /// Determines whether this object is frozen (immutable) or not.
  ///@return true if this object is frozen.
  bool isFrozen() => jniAccessors.callMethodWithArgs(
      reference, _id_isFrozen, jni.JniType.booleanType, []).boolean;
}

/// from: android.icu.text.MessagePattern$Part
///
/// A message pattern "part", representing a pattern parsing event.
/// There is a part for the start and end of a message or argument,
/// for quoting and escaping of and with ASCII apostrophes,
/// and for syntax elements of "complex" arguments.
class MessagePattern_Part extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/MessagePattern\$Part");
  MessagePattern_Part.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getType = jniAccessors.getMethodIDOf(
      _classRef, "getType", "()Landroid/icu/text/MessagePattern\$Part\$Type;");

  /// from: public android.icu.text.MessagePattern.Part.Type getType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the type of this part.
  ///@return the part type.
  MessagePattern_Part_Type getType() =>
      MessagePattern_Part_Type.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getType, jni.JniType.objectType, []).object);

  static final _id_getIndex =
      jniAccessors.getMethodIDOf(_classRef, "getIndex", "()I");

  /// from: public int getIndex()
  ///
  /// Returns the pattern string index associated with this Part.
  ///@return this part's pattern string index.
  int getIndex() => jniAccessors.callMethodWithArgs(
      reference, _id_getIndex, jni.JniType.intType, []).integer;

  static final _id_getLength =
      jniAccessors.getMethodIDOf(_classRef, "getLength", "()I");

  /// from: public int getLength()
  ///
  /// Returns the length of the pattern substring associated with this Part.
  /// This is 0 for some parts.
  ///@return this part's pattern substring length.
  int getLength() => jniAccessors.callMethodWithArgs(
      reference, _id_getLength, jni.JniType.intType, []).integer;

  static final _id_getLimit =
      jniAccessors.getMethodIDOf(_classRef, "getLimit", "()I");

  /// from: public int getLimit()
  ///
  /// Returns the pattern string limit (exclusive-end) index associated with this Part.
  /// Convenience method for getIndex()+getLength().
  ///@return this part's pattern string limit index, same as getIndex()+getLength().
  int getLimit() => jniAccessors.callMethodWithArgs(
      reference, _id_getLimit, jni.JniType.intType, []).integer;

  static final _id_getValue =
      jniAccessors.getMethodIDOf(_classRef, "getValue", "()I");

  /// from: public int getValue()
  ///
  /// Returns a value associated with this part.
  /// See the documentation of each part type for details.
  ///@return the part value.
  int getValue() => jniAccessors.callMethodWithArgs(
      reference, _id_getValue, jni.JniType.intType, []).integer;

  static final _id_getArgType = jniAccessors.getMethodIDOf(
      _classRef, "getArgType", "()Landroid/icu/text/MessagePattern\$ArgType;");

  /// from: public android.icu.text.MessagePattern.ArgType getArgType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the argument type if this part is of type ARG_START or ARG_LIMIT,
  /// otherwise ArgType.NONE.
  ///@return the argument type for this part.
  MessagePattern_ArgType getArgType() =>
      MessagePattern_ArgType.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getArgType, jni.JniType.objectType, []).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return a string representation of this part.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object other)
  ///
  /// @param other another object to compare with.
  ///@return true if this object is equivalent to the other one.
  bool equals1(jni.JniObject other) => jniAccessors.callMethodWithArgs(
      reference,
      _id_equals1,
      jni.JniType.booleanType,
      [other.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// {@inheritDoc}
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}

/// from: android.icu.text.MessagePattern$Part$Type
///
/// Part type constants.
class MessagePattern_Part_Type extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/MessagePattern\$Part\$Type");
  MessagePattern_Part_Type.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/icu/text/MessagePattern\$Part\$Type;");

  /// from: static public android.icu.text.MessagePattern.Part.Type[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/icu/text/MessagePattern\$Part\$Type;");

  /// from: static public android.icu.text.MessagePattern.Part.Type valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static MessagePattern_Part_Type valueOf(jni.JniString name) =>
      MessagePattern_Part_Type.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_hasNumericValue =
      jniAccessors.getMethodIDOf(_classRef, "hasNumericValue", "()Z");

  /// from: public boolean hasNumericValue()
  ///
  /// Indicates whether this part has a numeric value.
  /// If so, then that numeric value can be retrieved via MessagePattern\#getNumericValue(Part).
  ///@return true if this part has a numeric value.
  bool hasNumericValue() => jniAccessors.callMethodWithArgs(
      reference, _id_hasNumericValue, jni.JniType.booleanType, []).boolean;
}

/// from: android.icu.text.MessagePattern$ArgType
///
/// Argument type constants.
/// Returned by Part.getArgType() for ARG_START and ARG_LIMIT parts.
///
/// Messages nested inside an argument are each delimited by MSG_START and MSG_LIMIT,
/// with a nesting level one greater than the surrounding message.
class MessagePattern_ArgType extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/MessagePattern\$ArgType");
  MessagePattern_ArgType.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/icu/text/MessagePattern\$ArgType;");

  /// from: static public android.icu.text.MessagePattern.ArgType[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/icu/text/MessagePattern\$ArgType;");

  /// from: static public android.icu.text.MessagePattern.ArgType valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static MessagePattern_ArgType valueOf(jni.JniString name) =>
      MessagePattern_ArgType.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_hasPluralStyle =
      jniAccessors.getMethodIDOf(_classRef, "hasPluralStyle", "()Z");

  /// from: public boolean hasPluralStyle()
  ///
  /// @return true if the argument type has a plural style part sequence and semantics,
  /// for example ArgType\#PLURAL and ArgType\#SELECTORDINAL.
  bool hasPluralStyle() => jniAccessors.callMethodWithArgs(
      reference, _id_hasPluralStyle, jni.JniType.booleanType, []).boolean;
}

/// from: android.icu.text.MessagePattern$ApostropheMode
///
/// Mode for when an apostrophe starts quoted literal text for MessageFormat output.
/// The default is DOUBLE_OPTIONAL unless overridden via ICUConfig
/// (/com/ibm/icu/ICUConfig.properties).
///
/// A pair of adjacent apostrophes always results in a single apostrophe in the output,
/// even when the pair is between two single, text-quoting apostrophes.
///
/// The following table shows examples of desired MessageFormat.format() output
/// with the pattern strings that yield that output.
///
/// <table>
///   <tr>
///     <th>Desired output</th>
///     <th>DOUBLE_OPTIONAL</th>
///     <th>DOUBLE_REQUIRED</th>
///   </tr>
///   <tr>
///     <td>I see {many}</td>
///     <td>I see '{many}'</td>
///     <td>(same)</td>
///   </tr>
///   <tr>
///     <td>I said {'Wow!'}</td>
///     <td>I said '{''Wow!''}'</td>
///     <td>(same)</td>
///   </tr>
///   <tr>
///     <td>I don't know</td>
///     <td>I don't know OR<br> I don''t know</td>
///     <td>I don''t know</td>
///   </tr>
/// </table>
class MessagePattern_ApostropheMode extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/icu/text/MessagePattern\$ApostropheMode");
  MessagePattern_ApostropheMode.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(_classRef,
      "values", "()[Landroid/icu/text/MessagePattern\$ApostropheMode;");

  /// from: static public android.icu.text.MessagePattern.ApostropheMode[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/icu/text/MessagePattern\$ApostropheMode;");

  /// from: static public android.icu.text.MessagePattern.ApostropheMode valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static MessagePattern_ApostropheMode valueOf(jni.JniString name) =>
      MessagePattern_ApostropheMode.fromRef(jniAccessors
          .callStaticMethodWithArgs(_classRef, _id_valueOf,
              jni.JniType.objectType, [name.reference]).object);
}
