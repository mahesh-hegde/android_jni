// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "NumberFormat.dart" as numberformat_;

import "DecimalFormatSymbols.dart" as decimalformatsymbols_;

import "CurrencyPluralInfo.dart" as currencypluralinfo_;

import "../math/BigDecimal.dart" as bigdecimal_;

import "../util/CurrencyAmount.dart" as currencyamount_;

import "../math/MathContext.dart" as mathcontext_;

import "../util/Currency.dart" as currency_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.text.DecimalFormat
///
/// <strong>[icu enhancement]</strong> ICU's replacement for java.text.DecimalFormat.&nbsp;Methods, fields, and other functionality specific to ICU are labeled '<strong>[icu]</strong>'. <code>DecimalFormat</code> is the primary
/// concrete subclass of NumberFormat. It has a variety of features designed to make it
/// possible to parse and format numbers in any locale, including support for Western, Arabic, or
/// Indic digits. It supports different flavors of numbers, including integers ("123"), fixed-point
/// numbers ("123.4"), scientific notation ("1.23E4"), percentages ("12%"), and currency amounts
/// ("$123.00", "USD123.00", "123.00 US dollars"). All of these flavors can be easily localized.
///
/// To obtain a number formatter for a specific locale (including the default locale), call one of
/// NumberFormat's factory methods such as NumberFormat\#getInstance. Do not call
/// DecimalFormat constructors directly unless you know what you are doing.
///
/// DecimalFormat aims to comply with the specification <a href="http://unicode.org/reports/tr35/tr35-numbers.html\#Number_Format_Patterns">UTS \#35</a>. Read
/// the specification for more information on how all the properties in DecimalFormat fit together.
///
/// <strong>NOTE:</strong> Starting in ICU 60, there is a new set of APIs for localized number
/// formatting that are designed to be an improvement over DecimalFormat.  New users are discouraged
/// from using DecimalFormat.  For more information, see the package android.icu.number.
///
/// <h3>Example Usage</h3>
///
/// Customize settings on a DecimalFormat instance from the NumberFormat factory:
///
/// <blockquote>
///
/// <pre>
/// NumberFormat f = NumberFormat.getInstance(loc);
/// if (f instanceof DecimalFormat) {
///     ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);
///     ((DecimalFormat) f).setMinimumGroupingDigits(2);
/// }
/// </pre>
///
/// </blockquote>
///
/// Quick and dirty print out a number using the localized number, currency, and percent format
/// for each locale:
///
/// <blockquote>
///
/// <pre>
/// for (ULocale uloc : ULocale.getAvailableLocales()) {
///     System.out.print(uloc + ":\t");
///     System.out.print(NumberFormat.getInstance(uloc).format(1.23));
///     System.out.print("\t");
///     System.out.print(NumberFormat.getCurrencyInstance(uloc).format(1.23));
///     System.out.print("\t");
///     System.out.print(NumberFormat.getPercentInstance(uloc).format(1.23));
///     System.out.println();
/// }
/// </pre>
///
/// </blockquote>
///
/// <h3>Properties and Symbols</h3>
///
/// A DecimalFormat object encapsulates a set of _properties_ and a set of
/// _symbols_. Grouping size, rounding mode, and affixes are examples of properties. Locale
/// digits and the characters used for grouping and decimal separators are examples of symbols.
///
/// To set a custom set of symbols, use \#setDecimalFormatSymbols. Use the various other
/// setters in this class to set custom values for the properties.
///
/// <h3>Rounding</h3>
///
/// DecimalFormat provides three main strategies to specify the position at which numbers should
/// be rounded:
///
/// <ol>
///   <li><strong>Magnitude:</strong> Display a fixed number of fraction digits; this is the most
///       common form.
///   <li><strong>Increment:</strong> Round numbers to the closest multiple of a certain increment,
///       such as 0.05. This is common in currencies.
///   <li><strong>Significant Digits:</strong> Round numbers such that a fixed number of nonzero
///       digits are shown. This is most common in scientific notation.
/// </ol>
///
/// It is not possible to specify more than one rounding strategy. For example, setting a rounding
/// increment in conjunction with significant digits results in undefined behavior.
///
/// It is also possible to specify the _rounding mode_ to use. The default rounding mode is
/// "half even", which rounds numbers to their closest increment, with ties broken in favor of
/// trailing numbers being even. For more information, see \#setRoundingMode and <a href="http://userguide.icu-project.org/formatparse/numbers/rounding-modes">the ICU User
/// Guide</a>.
///
/// <h3>Pattern Strings</h3>
///
/// A _pattern string_ is a way to serialize some of the available properties for decimal
/// formatting. However, not all properties are capable of being serialized into a pattern string;
/// see \#applyPattern for more information.
///
/// Most users should not need to interface with pattern strings directly.
///
/// ICU DecimalFormat aims to follow the specification for pattern strings in <a href="http://unicode.org/reports/tr35/tr35-numbers.html\#Number_Format_Patterns">UTS \#35</a>.
/// Refer to that specification for more information on pattern string syntax.
///
/// <h4>Pattern String BNF</h4>
///
/// The following BNF is used when parsing the pattern string into property values:
///
/// <pre>
/// pattern    := subpattern (';' subpattern)?
/// subpattern := prefix? number exponent? suffix?
/// number     := (integer ('.' fraction)?) | sigDigits
/// prefix     := '&\#92;u0000'..'&\#92;uFFFD' - specialCharacters
/// suffix     := '&\#92;u0000'..'&\#92;uFFFD' - specialCharacters
/// integer    := '\#'* '0'* '0'
/// fraction   := '0'* '\#'*
/// sigDigits  := '\#'* '@' '@'* '\#'*
/// exponent   := 'E' '+'? '0'* '0'
/// padSpec    := '*' padChar
/// padChar    := '&\#92;u0000'..'&\#92;uFFFD' - quote
/// &\#32;
/// Notation:
///   X*       0 or more instances of X
///   X?       0 or 1 instances of X
///   X|Y      either X or Y
///   C..D     any character from C up to D, inclusive
///   S-T      characters in S, except those in T
/// </pre>
///
/// The first subpattern is for positive numbers. The second (optional) subpattern is for negative
/// numbers.
///
/// Not indicated in the BNF syntax above:
///
/// <ul>
///   <li>The grouping separator ',' can occur inside the integer and sigDigits elements, between any
///       two pattern characters of that element, as long as the integer or sigDigits element is not
///       followed by the exponent element.
///   <li>Two grouping intervals are recognized: That between the decimal point and the first
///       grouping symbol, and that between the first and second grouping symbols. These intervals
///       are identical in most locales, but in some locales they differ. For example, the pattern
///       &quot;\#,\#\#,\#\#\#&quot; formats the number 123456789 as &quot;12,34,56,789&quot;.
///   <li>The pad specifier <code>padSpec</code> may appear before the prefix, after the prefix,
///       before the suffix, after the suffix, or not at all.
///   <li>In place of '0', the digits '1' through '9' may be used to indicate a rounding increment.
/// </ul>
///
/// <h3>Parsing</h3>
///
/// DecimalFormat aims to be able to parse anything that it can output as a formatted string.
///
/// There are two primary parse modes: _lenient_ and _strict_. Lenient mode should
/// be used if the goal is to parse user input to a number; strict mode should be used if the goal is
/// validation. The default is lenient mode. For more information, see \#setParseStrict.
///
/// <code>DecimalFormat</code> parses all Unicode characters that represent decimal digits, as
/// defined by UCharacter\#digit. In addition, <code>DecimalFormat</code> also recognizes as
/// digits the ten consecutive characters starting with the localized zero digit defined in the
/// DecimalFormatSymbols object. During formatting, the DecimalFormatSymbols-based
/// digits are output.
///
/// Grouping separators are ignored in lenient mode (default). In strict mode, grouping separators
/// must match the locale-specified grouping sizes.
///
/// When using \#parseCurrency, all currencies are accepted, not just the currency
/// currently set in the formatter. In addition, the formatter is able to parse every currency style
/// format for a particular locale no matter which style the formatter is constructed with. For
/// example, a formatter instance gotten from NumberFormat.getInstance(ULocale,
/// NumberFormat.CURRENCYSTYLE) can parse both "USD1.00" and "3.00 US dollars".
///
/// Whitespace characters (lenient mode) and bidi control characters (lenient and strict mode),
/// collectively called "ignorables", do not need to match in identity or quantity between the
/// pattern string and the input string. For example, the pattern "\# %" matches "35 %" (with a single
/// space), "35%" (with no space), "35&nbsp;%" (with a non-breaking space), and "35&nbsp; %" (with
/// multiple spaces). Arbitrary ignorables are also allowed at boundaries between the parts of the
/// number: prefix, number, exponent separator, and suffix. Ignorable whitespace characters are those
/// having the Unicode "blank" property for regular expressions, defined in UTS \#18 Annex C, which is
/// "horizontal" whitespace, like spaces and tabs, but not "vertical" whitespace, like line breaks.
///
/// If \#parse(String, ParsePosition) fails to parse a string, it returns <code>null</code>
/// and leaves the parse position unchanged. The convenience method \#parse(String) indicates
/// parse failure by throwing a java.text.ParseException.
///
/// Under the hood, a state table parsing engine is used. To debug a parsing failure during
/// development, use the following pattern to print details about the state table transitions:
///
/// <pre>
/// android.icu.impl.number.Parse.DEBUGGING = true;
/// df.parse("123.45", ppos);
/// android.icu.impl.number.Parse.DEBUGGING = false;
/// </pre>
///
/// <h3>Thread Safety and Best Practices</h3>
///
/// Starting with ICU 59, instances of DecimalFormat are thread-safe.
///
/// Under the hood, DecimalFormat maintains an immutable formatter object that is rebuilt whenever
/// any of the property setters are called. It is therefore best practice to call property setters
/// only during construction and not when formatting numbers online.
///@see java.text.Format
///@see NumberFormat
class DecimalFormat extends numberformat_.NumberFormat {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/DecimalFormat");
  DecimalFormat.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int PAD_AFTER_PREFIX
  ///
  /// <strong>[icu]</strong> Constant for \#getPadPosition() and \#setPadPosition(int) to specify pad
  /// characters inserted after the prefix.
  ///@see \#setPadPosition
  ///@see \#getPadPosition
  ///@see \#PAD_BEFORE_PREFIX
  ///@see \#PAD_BEFORE_SUFFIX
  ///@see \#PAD_AFTER_SUFFIX
  static const PAD_AFTER_PREFIX = 1;

  /// from: static public final int PAD_AFTER_SUFFIX
  ///
  /// <strong>[icu]</strong> Constant for \#getPadPosition() and \#setPadPosition(int) to specify pad
  /// characters inserted after the suffix.
  ///@see \#setPadPosition
  ///@see \#getPadPosition
  ///@see \#PAD_BEFORE_PREFIX
  ///@see \#PAD_AFTER_PREFIX
  ///@see \#PAD_BEFORE_SUFFIX
  static const PAD_AFTER_SUFFIX = 3;

  /// from: static public final int PAD_BEFORE_PREFIX
  ///
  /// <strong>[icu]</strong> Constant for \#getPadPosition() and \#setPadPosition(int) to specify pad
  /// characters inserted before the prefix.
  ///@see \#setPadPosition
  ///@see \#getPadPosition
  ///@see \#PAD_AFTER_PREFIX
  ///@see \#PAD_BEFORE_SUFFIX
  ///@see \#PAD_AFTER_SUFFIX
  static const PAD_BEFORE_PREFIX = 0;

  /// from: static public final int PAD_BEFORE_SUFFIX
  ///
  /// <strong>[icu]</strong> Constant for \#getPadPosition() and \#setPadPosition(int) to specify pad
  /// characters inserted before the suffix.
  ///@see \#setPadPosition
  ///@see \#getPadPosition
  ///@see \#PAD_BEFORE_PREFIX
  ///@see \#PAD_AFTER_PREFIX
  ///@see \#PAD_AFTER_SUFFIX
  static const PAD_BEFORE_SUFFIX = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a DecimalFormat based on the number pattern and symbols for the default locale. This is
  /// a convenient way to obtain a DecimalFormat instance when internationalization is not the main
  /// concern.
  ///
  /// Most users should call the factory methods on NumberFormat, such as NumberFormat\#getNumberInstance, which return localized formatter objects, instead of the
  /// DecimalFormat constructors.
  ///@see NumberFormat\#getInstance
  ///@see NumberFormat\#getNumberInstance
  ///@see NumberFormat\#getCurrencyInstance
  ///@see NumberFormat\#getPercentInstance
  ///@see Category\#FORMAT
  DecimalFormat()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String pattern)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a DecimalFormat based on the given pattern, using symbols for the default locale. This
  /// is a convenient way to obtain a DecimalFormat instance when internationalization is not the
  /// main concern.
  ///
  /// Most users should call the factory methods on NumberFormat, such as NumberFormat\#getNumberInstance, which return localized formatter objects, instead of the
  /// DecimalFormat constructors.
  ///@param pattern A pattern string such as "\#,\#\#0.00" conforming to <a href="http://unicode.org/reports/tr35/tr35-numbers.html\#Number_Format_Patterns">UTS
  ///     \#35</a>.
  ///@throws IllegalArgumentException if the given pattern is invalid.
  ///@see NumberFormat\#getInstance
  ///@see NumberFormat\#getNumberInstance
  ///@see NumberFormat\#getCurrencyInstance
  ///@see NumberFormat\#getPercentInstance
  ///@see Category\#FORMAT
  DecimalFormat.ctor1(jni.JniString pattern)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [pattern.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;Landroid/icu/text/DecimalFormatSymbols;)V");

  /// from: public void <init>(java.lang.String pattern, android.icu.text.DecimalFormatSymbols symbols)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a DecimalFormat based on the given pattern and symbols. Use this constructor if you
  /// want complete control over the behavior of the formatter.
  ///
  /// Most users should call the factory methods on NumberFormat, such as NumberFormat\#getNumberInstance, which return localized formatter objects, instead of the
  /// DecimalFormat constructors.
  ///@param pattern A pattern string such as "\#,\#\#0.00" conforming to <a href="http://unicode.org/reports/tr35/tr35-numbers.html\#Number_Format_Patterns">UTS
  ///     \#35</a>.
  ///@param symbols The set of symbols to be used.
  ///@exception IllegalArgumentException if the given pattern is invalid
  ///@see NumberFormat\#getInstance
  ///@see NumberFormat\#getNumberInstance
  ///@see NumberFormat\#getCurrencyInstance
  ///@see NumberFormat\#getPercentInstance
  ///@see DecimalFormatSymbols
  DecimalFormat.ctor2(
      jni.JniString pattern, decimalformatsymbols_.DecimalFormatSymbols symbols)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [pattern.reference, symbols.reference]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Ljava/lang/String;Landroid/icu/text/DecimalFormatSymbols;Landroid/icu/text/CurrencyPluralInfo;I)V");

  /// from: public void <init>(java.lang.String pattern, android.icu.text.DecimalFormatSymbols symbols, android.icu.text.CurrencyPluralInfo infoInput, int style)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a DecimalFormat based on the given pattern and symbols, with additional control over
  /// the behavior of currency. The style argument determines whether currency rounding rules should
  /// override the pattern, and the CurrencyPluralInfo object is used for customizing the
  /// plural forms used for currency long names.
  ///
  /// Most users should call the factory methods on NumberFormat, such as NumberFormat\#getNumberInstance, which return localized formatter objects, instead of the
  /// DecimalFormat constructors.
  ///@param pattern a non-localized pattern string
  ///@param symbols the set of symbols to be used
  ///@param infoInput the information used for currency plural format, including currency plural
  ///     patterns and plural rules.
  ///@param style the decimal formatting style, it is one of the following values:
  ///     NumberFormat.NUMBERSTYLE; NumberFormat.CURRENCYSTYLE; NumberFormat.PERCENTSTYLE;
  ///     NumberFormat.SCIENTIFICSTYLE; NumberFormat.INTEGERSTYLE; NumberFormat.ISOCURRENCYSTYLE;
  ///     NumberFormat.PLURALCURRENCYSTYLE;
  DecimalFormat.ctor3(
      jni.JniString pattern,
      decimalformatsymbols_.DecimalFormatSymbols symbols,
      currencypluralinfo_.CurrencyPluralInfo infoInput,
      int style)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          pattern.reference,
          symbols.reference,
          infoInput.reference,
          style
        ]).object);

  static final _id_applyPattern = jniAccessors.getMethodIDOf(
      _classRef, "applyPattern", "(Ljava/lang/String;)V");

  /// from: synchronized public void applyPattern(java.lang.String pattern)
  ///
  /// Parses the given pattern string and overwrites the settings specified in the pattern string.
  /// The properties corresponding to the following setters are overwritten, either with their
  /// default values or with the value specified in the pattern string:
  ///
  /// <ol>
  ///   <li>\#setDecimalSeparatorAlwaysShown
  ///   <li>\#setExponentSignAlwaysShown
  ///   <li>\#setFormatWidth
  ///   <li>\#setGroupingSize
  ///   <li>\#setMultiplier (percent/permille)
  ///   <li>\#setMaximumFractionDigits
  ///   <li>\#setMaximumIntegerDigits
  ///   <li>\#setMaximumSignificantDigits
  ///   <li>\#setMinimumExponentDigits
  ///   <li>\#setMinimumFractionDigits
  ///   <li>\#setMinimumIntegerDigits
  ///   <li>\#setMinimumSignificantDigits
  ///   <li>\#setPadPosition
  ///   <li>\#setPadCharacter
  ///   <li>\#setRoundingIncrement
  ///   <li>\#setSecondaryGroupingSize
  /// </ol>
  ///
  /// All other settings remain untouched.
  ///
  /// For more information on pattern strings, see <a href="http://unicode.org/reports/tr35/tr35-numbers.html\#Number_Format_Patterns">UTS \#35</a>.
  void applyPattern(jni.JniString pattern) => jniAccessors.callMethodWithArgs(
      reference,
      _id_applyPattern,
      jni.JniType.voidType,
      [pattern.reference]).check();

  static final _id_applyLocalizedPattern = jniAccessors.getMethodIDOf(
      _classRef, "applyLocalizedPattern", "(Ljava/lang/String;)V");

  /// from: synchronized public void applyLocalizedPattern(java.lang.String localizedPattern)
  ///
  /// Converts the given string to standard notation and then parses it using \#applyPattern.
  /// This method is provided for backwards compatibility and should not be used in new projects.
  ///
  /// Localized notation means that instead of using generic placeholders in the pattern, you use
  /// the corresponding locale-specific characters instead. For example, in locale _fr-FR_,
  /// the period in the pattern "0.000" means "decimal" in standard notation (as it does in every
  /// other locale), but it means "grouping" in localized notation.
  ///@param localizedPattern The pattern string in localized notation.
  void applyLocalizedPattern(jni.JniString localizedPattern) =>
      jniAccessors.callMethodWithArgs(reference, _id_applyLocalizedPattern,
          jni.JniType.voidType, [localizedPattern.reference]).check();

  static final _id_clone =
      jniAccessors.getMethodIDOf(_classRef, "clone", "()Ljava/lang/Object;");

  /// from: public java.lang.Object clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  jni.JniObject clone() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_format7 = jniAccessors.getMethodIDOf(_classRef, "format",
      "(DLjava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;");

  /// from: public java.lang.StringBuffer format(double number, java.lang.StringBuffer result, java.text.FieldPosition fieldPosition)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniObject format7(
          double number, jni.JniObject result, jni.JniObject fieldPosition) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_format7,
          jni.JniType.objectType,
          [number, result.reference, fieldPosition.reference]).object);

  static final _id_format8 = jniAccessors.getMethodIDOf(_classRef, "format",
      "(JLjava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;");

  /// from: public java.lang.StringBuffer format(long number, java.lang.StringBuffer result, java.text.FieldPosition fieldPosition)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniObject format8(
          int number, jni.JniObject result, jni.JniObject fieldPosition) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_format8,
          jni.JniType.objectType,
          [number, result.reference, fieldPosition.reference]).object);

  static final _id_format9 = jniAccessors.getMethodIDOf(_classRef, "format",
      "(Ljava/math/BigInteger;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;");

  /// from: public java.lang.StringBuffer format(java.math.BigInteger number, java.lang.StringBuffer result, java.text.FieldPosition fieldPosition)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniObject format9(jni.JniObject number, jni.JniObject result,
          jni.JniObject fieldPosition) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_format9, jni.JniType.objectType, [
        number.reference,
        result.reference,
        fieldPosition.reference
      ]).object);

  static final _id_format10 = jniAccessors.getMethodIDOf(_classRef, "format",
      "(Ljava/math/BigDecimal;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;");

  /// from: public java.lang.StringBuffer format(java.math.BigDecimal number, java.lang.StringBuffer result, java.text.FieldPosition fieldPosition)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniObject format10(jni.JniObject number, jni.JniObject result,
          jni.JniObject fieldPosition) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_format10, jni.JniType.objectType, [
        number.reference,
        result.reference,
        fieldPosition.reference
      ]).object);

  static final _id_format11 = jniAccessors.getMethodIDOf(_classRef, "format",
      "(Landroid/icu/math/BigDecimal;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;");

  /// from: public java.lang.StringBuffer format(android.icu.math.BigDecimal number, java.lang.StringBuffer result, java.text.FieldPosition fieldPosition)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniObject format11(bigdecimal_.BigDecimal number, jni.JniObject result,
          jni.JniObject fieldPosition) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_format11, jni.JniType.objectType, [
        number.reference,
        result.reference,
        fieldPosition.reference
      ]).object);

  static final _id_formatToCharacterIterator = jniAccessors.getMethodIDOf(
      _classRef,
      "formatToCharacterIterator",
      "(Ljava/lang/Object;)Ljava/text/AttributedCharacterIterator;");

  /// from: public java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object obj)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniObject formatToCharacterIterator(jni.JniObject obj) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_formatToCharacterIterator,
          jni.JniType.objectType,
          [obj.reference]).object);

  static final _id_format12 = jniAccessors.getMethodIDOf(_classRef, "format",
      "(Landroid/icu/util/CurrencyAmount;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;");

  /// from: public java.lang.StringBuffer format(android.icu.util.CurrencyAmount currAmt, java.lang.StringBuffer toAppendTo, java.text.FieldPosition pos)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniObject format12(currencyamount_.CurrencyAmount currAmt,
          jni.JniObject toAppendTo, jni.JniObject pos) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_format12,
          jni.JniType.objectType,
          [currAmt.reference, toAppendTo.reference, pos.reference]).object);

  static final _id_parse = jniAccessors.getMethodIDOf(_classRef, "parse",
      "(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/lang/Number;");

  /// from: public java.lang.Number parse(java.lang.String text, java.text.ParsePosition parsePosition)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniObject parse(jni.JniString text, jni.JniObject parsePosition) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_parse,
          jni.JniType.objectType,
          [text.reference, parsePosition.reference]).object);

  static final _id_parseCurrency = jniAccessors.getMethodIDOf(
      _classRef,
      "parseCurrency",
      "(Ljava/lang/CharSequence;Ljava/text/ParsePosition;)Landroid/icu/util/CurrencyAmount;");

  /// from: public android.icu.util.CurrencyAmount parseCurrency(java.lang.CharSequence text, java.text.ParsePosition parsePosition)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  currencyamount_.CurrencyAmount parseCurrency(
          jni.JniObject text, jni.JniObject parsePosition) =>
      currencyamount_.CurrencyAmount.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_parseCurrency,
          jni.JniType.objectType,
          [text.reference, parsePosition.reference]).object);

  static final _id_getDecimalFormatSymbols = jniAccessors.getMethodIDOf(
      _classRef,
      "getDecimalFormatSymbols",
      "()Landroid/icu/text/DecimalFormatSymbols;");

  /// from: synchronized public android.icu.text.DecimalFormatSymbols getDecimalFormatSymbols()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a copy of the decimal format symbols used by this formatter.
  ///@return desired DecimalFormatSymbols
  ///@see DecimalFormatSymbols
  decimalformatsymbols_.DecimalFormatSymbols getDecimalFormatSymbols() =>
      decimalformatsymbols_.DecimalFormatSymbols.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getDecimalFormatSymbols,
              jni.JniType.objectType, []).object);

  static final _id_setDecimalFormatSymbols = jniAccessors.getMethodIDOf(
      _classRef,
      "setDecimalFormatSymbols",
      "(Landroid/icu/text/DecimalFormatSymbols;)V");

  /// from: synchronized public void setDecimalFormatSymbols(android.icu.text.DecimalFormatSymbols newSymbols)
  ///
  /// Sets the decimal format symbols used by this formatter. The formatter uses a copy of the
  /// provided symbols.
  ///@param newSymbols desired DecimalFormatSymbols
  ///@see DecimalFormatSymbols
  void setDecimalFormatSymbols(
          decimalformatsymbols_.DecimalFormatSymbols newSymbols) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDecimalFormatSymbols,
          jni.JniType.voidType, [newSymbols.reference]).check();

  static final _id_getPositivePrefix = jniAccessors.getMethodIDOf(
      _classRef, "getPositivePrefix", "()Ljava/lang/String;");

  /// from: synchronized public java.lang.String getPositivePrefix()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>Affixes:</strong> Gets the positive prefix string currently being used to format
  /// numbers.
  ///
  /// If the affix was specified via the pattern, the string returned by this method will have
  /// locale symbols substituted in place of special characters according to the LDML specification.
  /// If the affix was specified via \#setPositivePrefix, the string will be returned
  /// literally.
  ///@return The string being prepended to positive numbers.
  jni.JniString getPositivePrefix() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPositivePrefix, jni.JniType.objectType, []).object);

  static final _id_setPositivePrefix = jniAccessors.getMethodIDOf(
      _classRef, "setPositivePrefix", "(Ljava/lang/String;)V");

  /// from: synchronized public void setPositivePrefix(java.lang.String prefix)
  ///
  /// <strong>Affixes:</strong> Sets the string to prepend to positive numbers. For example, if you
  /// set the value "\#", then the number 123 will be formatted as "\#123" in the locale
  /// _en-US_.
  ///
  /// Using this method overrides the affix specified via the pattern, and unlike the pattern, the
  /// string given to this method will be interpreted literally WITHOUT locale symbol substitutions.
  ///@param prefix The literal string to prepend to positive numbers.
  void setPositivePrefix(jni.JniString prefix) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPositivePrefix,
          jni.JniType.voidType, [prefix.reference]).check();

  static final _id_getNegativePrefix = jniAccessors.getMethodIDOf(
      _classRef, "getNegativePrefix", "()Ljava/lang/String;");

  /// from: synchronized public java.lang.String getNegativePrefix()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>Affixes:</strong> Gets the negative prefix string currently being used to format
  /// numbers.
  ///
  /// If the affix was specified via the pattern, the string returned by this method will have
  /// locale symbols substituted in place of special characters according to the LDML specification.
  /// If the affix was specified via \#setNegativePrefix, the string will be returned
  /// literally.
  ///@return The string being prepended to negative numbers.
  jni.JniString getNegativePrefix() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getNegativePrefix, jni.JniType.objectType, []).object);

  static final _id_setNegativePrefix = jniAccessors.getMethodIDOf(
      _classRef, "setNegativePrefix", "(Ljava/lang/String;)V");

  /// from: synchronized public void setNegativePrefix(java.lang.String prefix)
  ///
  /// <strong>Affixes:</strong> Sets the string to prepend to negative numbers. For example, if you
  /// set the value "\#", then the number -123 will be formatted as "\#123" in the locale
  /// _en-US_ (overriding the implicit default '-' in the pattern).
  ///
  /// Using this method overrides the affix specified via the pattern, and unlike the pattern, the
  /// string given to this method will be interpreted literally WITHOUT locale symbol substitutions.
  ///@param prefix The literal string to prepend to negative numbers.
  void setNegativePrefix(jni.JniString prefix) =>
      jniAccessors.callMethodWithArgs(reference, _id_setNegativePrefix,
          jni.JniType.voidType, [prefix.reference]).check();

  static final _id_getPositiveSuffix = jniAccessors.getMethodIDOf(
      _classRef, "getPositiveSuffix", "()Ljava/lang/String;");

  /// from: synchronized public java.lang.String getPositiveSuffix()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>Affixes:</strong> Gets the positive suffix string currently being used to format
  /// numbers.
  ///
  /// If the affix was specified via the pattern, the string returned by this method will have
  /// locale symbols substituted in place of special characters according to the LDML specification.
  /// If the affix was specified via \#setPositiveSuffix, the string will be returned
  /// literally.
  ///@return The string being appended to positive numbers.
  jni.JniString getPositiveSuffix() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPositiveSuffix, jni.JniType.objectType, []).object);

  static final _id_setPositiveSuffix = jniAccessors.getMethodIDOf(
      _classRef, "setPositiveSuffix", "(Ljava/lang/String;)V");

  /// from: synchronized public void setPositiveSuffix(java.lang.String suffix)
  ///
  /// <strong>Affixes:</strong> Sets the string to append to positive numbers. For example, if you
  /// set the value "\#", then the number 123 will be formatted as "123\#" in the locale
  /// _en-US_.
  ///
  /// Using this method overrides the affix specified via the pattern, and unlike the pattern, the
  /// string given to this method will be interpreted literally WITHOUT locale symbol substitutions.
  ///@param suffix The literal string to append to positive numbers.
  void setPositiveSuffix(jni.JniString suffix) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPositiveSuffix,
          jni.JniType.voidType, [suffix.reference]).check();

  static final _id_getNegativeSuffix = jniAccessors.getMethodIDOf(
      _classRef, "getNegativeSuffix", "()Ljava/lang/String;");

  /// from: synchronized public java.lang.String getNegativeSuffix()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>Affixes:</strong> Gets the negative suffix string currently being used to format
  /// numbers.
  ///
  /// If the affix was specified via the pattern, the string returned by this method will have
  /// locale symbols substituted in place of special characters according to the LDML specification.
  /// If the affix was specified via \#setNegativeSuffix, the string will be returned
  /// literally.
  ///@return The string being appended to negative numbers.
  jni.JniString getNegativeSuffix() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getNegativeSuffix, jni.JniType.objectType, []).object);

  static final _id_setNegativeSuffix = jniAccessors.getMethodIDOf(
      _classRef, "setNegativeSuffix", "(Ljava/lang/String;)V");

  /// from: synchronized public void setNegativeSuffix(java.lang.String suffix)
  ///
  /// <strong>Affixes:</strong> Sets the string to append to negative numbers. For example, if you
  /// set the value "\#", then the number 123 will be formatted as "123\#" in the locale
  /// _en-US_.
  ///
  /// Using this method overrides the affix specified via the pattern, and unlike the pattern, the
  /// string given to this method will be interpreted literally WITHOUT locale symbol substitutions.
  ///@param suffix The literal string to append to negative numbers.
  void setNegativeSuffix(jni.JniString suffix) =>
      jniAccessors.callMethodWithArgs(reference, _id_setNegativeSuffix,
          jni.JniType.voidType, [suffix.reference]).check();

  static final _id_getMultiplier =
      jniAccessors.getMethodIDOf(_classRef, "getMultiplier", "()I");

  /// from: synchronized public int getMultiplier()
  ///
  /// Returns the multiplier being applied to numbers before they are formatted.
  ///@see \#setMultiplier
  int getMultiplier() => jniAccessors.callMethodWithArgs(
      reference, _id_getMultiplier, jni.JniType.intType, []).integer;

  static final _id_setMultiplier =
      jniAccessors.getMethodIDOf(_classRef, "setMultiplier", "(I)V");

  /// from: synchronized public void setMultiplier(int multiplier)
  ///
  /// Sets a number that will be used to multiply all numbers prior to formatting. For example, when
  /// formatting percents, a multiplier of 100 can be used.
  ///
  /// If a percent or permille sign is specified in the pattern, the multiplier is automatically
  /// set to 100 or 1000, respectively.
  ///
  /// If the number specified here is a power of 10, a more efficient code path will be used.
  ///@param multiplier The number by which all numbers passed to \#format will be multiplied.
  ///@throws IllegalArgumentException If the given multiplier is zero.
  void setMultiplier(int multiplier) => jniAccessors.callMethodWithArgs(
      reference, _id_setMultiplier, jni.JniType.voidType, [multiplier]).check();

  static final _id_getRoundingIncrement = jniAccessors.getMethodIDOf(
      _classRef, "getRoundingIncrement", "()Ljava/math/BigDecimal;");

  /// from: synchronized public java.math.BigDecimal getRoundingIncrement()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the increment to which numbers are being rounded.
  ///@see \#setRoundingIncrement
  jni.JniObject getRoundingIncrement() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getRoundingIncrement, jni.JniType.objectType, []).object);

  static final _id_setRoundingIncrement = jniAccessors.getMethodIDOf(
      _classRef, "setRoundingIncrement", "(Ljava/math/BigDecimal;)V");

  /// from: synchronized public void setRoundingIncrement(java.math.BigDecimal increment)
  ///
  /// <strong>[icu]</strong> <strong>Rounding and Digit Limits:</strong> Sets an increment, or interval, to which
  /// numbers are rounded. For example, a rounding increment of 0.05 will cause the number 1.23 to be
  /// rounded to 1.25 in the default rounding mode.
  ///
  /// The rounding increment can be specified via the pattern string: for example, the pattern
  /// "\#,\#\#0.05" encodes a rounding increment of 0.05.
  ///
  /// The rounding increment is applied _after_ any multipliers might take effect; for
  /// example, in scientific notation or when \#setMultiplier is used.
  ///
  /// See \#setMaximumFractionDigits and \#setMaximumSignificantDigits for two other
  /// ways of specifying rounding strategies.
  ///@param increment The increment to which numbers are to be rounded.
  ///@see \#setRoundingMode
  ///@see \#setMaximumFractionDigits
  ///@see \#setMaximumSignificantDigits
  void setRoundingIncrement(jni.JniObject increment) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRoundingIncrement,
          jni.JniType.voidType, [increment.reference]).check();

  static final _id_setRoundingIncrement1 = jniAccessors.getMethodIDOf(
      _classRef, "setRoundingIncrement", "(Landroid/icu/math/BigDecimal;)V");

  /// from: synchronized public void setRoundingIncrement(android.icu.math.BigDecimal increment)
  ///
  /// <strong>[icu]</strong> <strong>Rounding and Digit Limits:</strong> Overload of \#setRoundingIncrement(java.math.BigDecimal).
  ///@param increment The increment to which numbers are to be rounded.
  ///@see \#setRoundingIncrement
  void setRoundingIncrement1(bigdecimal_.BigDecimal increment) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRoundingIncrement1,
          jni.JniType.voidType, [increment.reference]).check();

  static final _id_setRoundingIncrement2 =
      jniAccessors.getMethodIDOf(_classRef, "setRoundingIncrement", "(D)V");

  /// from: synchronized public void setRoundingIncrement(double increment)
  ///
  /// <strong>[icu]</strong> <strong>Rounding and Digit Limits:</strong> Overload of \#setRoundingIncrement(java.math.BigDecimal).
  ///@param increment The increment to which numbers are to be rounded.
  ///@see \#setRoundingIncrement
  void setRoundingIncrement2(double increment) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRoundingIncrement2,
          jni.JniType.voidType, [increment]).check();

  static final _id_getRoundingMode =
      jniAccessors.getMethodIDOf(_classRef, "getRoundingMode", "()I");

  /// from: synchronized public int getRoundingMode()
  ///
  /// Returns the rounding mode being used to round numbers.
  ///@see \#setRoundingMode
  int getRoundingMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getRoundingMode, jni.JniType.intType, []).integer;

  static final _id_setRoundingMode =
      jniAccessors.getMethodIDOf(_classRef, "setRoundingMode", "(I)V");

  /// from: synchronized public void setRoundingMode(int roundingMode)
  ///
  /// <strong>Rounding and Digit Limits:</strong> Sets the RoundingMode used to round
  /// numbers. The default rounding mode is HALF_EVEN, which rounds decimals to their closest whole
  /// number, and rounds to the closest even number if at the midpoint.
  ///
  /// For more detail on rounding modes, see <a href="http://userguide.icu-project.org/formatparse/numbers/rounding-modes">the ICU User
  /// Guide</a>.
  ///
  /// For backwards compatibility, the rounding mode is specified as an int argument, which can be
  /// from either the constants in BigDecimal or the ordinal value of RoundingMode.
  /// The following two calls are functionally equivalent.
  ///
  /// <pre>
  /// df.setRoundingMode(BigDecimal.ROUND_CEILING);
  /// df.setRoundingMode(RoundingMode.CEILING.ordinal());
  /// </pre>
  ///@param roundingMode The integer constant rounding mode to use when formatting numbers.
  void setRoundingMode(int roundingMode) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setRoundingMode,
      jni.JniType.voidType,
      [roundingMode]).check();

  static final _id_getMathContext = jniAccessors.getMethodIDOf(
      _classRef, "getMathContext", "()Ljava/math/MathContext;");

  /// from: synchronized public java.math.MathContext getMathContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the java.math.MathContext being used to round numbers.
  ///@see \#setMathContext
  jni.JniObject getMathContext() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMathContext, jni.JniType.objectType, []).object);

  static final _id_setMathContext = jniAccessors.getMethodIDOf(
      _classRef, "setMathContext", "(Ljava/math/MathContext;)V");

  /// from: synchronized public void setMathContext(java.math.MathContext mathContext)
  ///
  /// <strong>[icu]</strong> <strong>Rounding and Digit Limits:</strong> Sets the java.math.MathContext used
  /// to round numbers. A "math context" encodes both a rounding mode and a number of significant
  /// digits. Most users should call \#setRoundingMode and/or \#setMaximumSignificantDigits instead of this method.
  ///
  /// When formatting, since no division is ever performed, the default MathContext is unlimited
  /// significant digits. However, when division occurs during parsing to correct for percentages and
  /// multipliers, a MathContext of 34 digits, the IEEE 754R Decimal128 standard, is used by default.
  /// If you require more than 34 digits when parsing, you can set a custom MathContext using this
  /// method.
  ///@param mathContext The MathContext to use when rounding numbers.
  ///@see java.math.MathContext
  void setMathContext(jni.JniObject mathContext) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMathContext,
          jni.JniType.voidType, [mathContext.reference]).check();

  static final _id_getMathContextICU = jniAccessors.getMethodIDOf(
      _classRef, "getMathContextICU", "()Landroid/icu/math/MathContext;");

  /// from: synchronized public android.icu.math.MathContext getMathContextICU()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the android.icu.math.MathContext being used to round numbers.
  ///@see \#setMathContext
  mathcontext_.MathContext getMathContextICU() =>
      mathcontext_.MathContext.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMathContextICU, jni.JniType.objectType, []).object);

  static final _id_setMathContextICU = jniAccessors.getMethodIDOf(
      _classRef, "setMathContextICU", "(Landroid/icu/math/MathContext;)V");

  /// from: synchronized public void setMathContextICU(android.icu.math.MathContext mathContextICU)
  ///
  /// <strong>[icu]</strong> <strong>Rounding and Digit Limits:</strong> Overload of \#setMathContext for
  /// android.icu.math.MathContext.
  ///@param mathContextICU The MathContext to use when rounding numbers.
  ///@see \#setMathContext(java.math.MathContext)
  void setMathContextICU(mathcontext_.MathContext mathContextICU) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMathContextICU,
          jni.JniType.voidType, [mathContextICU.reference]).check();

  static final _id_getMinimumIntegerDigits =
      jniAccessors.getMethodIDOf(_classRef, "getMinimumIntegerDigits", "()I");

  /// from: synchronized public int getMinimumIntegerDigits()
  ///
  /// Returns the effective minimum number of digits before the decimal separator.
  ///@see \#setMinimumIntegerDigits
  int getMinimumIntegerDigits() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinimumIntegerDigits, jni.JniType.intType, []).integer;

  static final _id_setMinimumIntegerDigits =
      jniAccessors.getMethodIDOf(_classRef, "setMinimumIntegerDigits", "(I)V");

  /// from: synchronized public void setMinimumIntegerDigits(int value)
  ///
  /// <strong>Rounding and Digit Limits:</strong> Sets the minimum number of digits to display before
  /// the decimal separator. If the number has fewer than this many digits, the number is padded with
  /// zeros.
  ///
  /// For example, if minimum integer digits is 3, the number 12.3 will be printed as "001.23".
  ///
  /// Minimum integer and minimum and maximum fraction digits can be specified via the pattern
  /// string. For example, "\#,\#00.00\#" has 2 minimum integer digits, 2 minimum fraction digits, and 3
  /// maximum fraction digits. Note that it is not possible to specify maximium integer digits in the
  /// pattern except in scientific notation.
  ///
  /// If minimum and maximum integer, fraction, or significant digits conflict with each other,
  /// the most recently specified value is used. For example, if there is a formatter with minInt=5,
  /// and then you set maxInt=3, then minInt will be changed to 3.
  ///@param value The minimum number of digits before the decimal separator.
  void setMinimumIntegerDigits(int value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMinimumIntegerDigits,
      jni.JniType.voidType,
      [value]).check();

  static final _id_getMaximumIntegerDigits =
      jniAccessors.getMethodIDOf(_classRef, "getMaximumIntegerDigits", "()I");

  /// from: synchronized public int getMaximumIntegerDigits()
  ///
  /// Returns the effective maximum number of digits before the decimal separator.
  ///@see \#setMaximumIntegerDigits
  int getMaximumIntegerDigits() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaximumIntegerDigits, jni.JniType.intType, []).integer;

  static final _id_setMaximumIntegerDigits =
      jniAccessors.getMethodIDOf(_classRef, "setMaximumIntegerDigits", "(I)V");

  /// from: synchronized public void setMaximumIntegerDigits(int value)
  ///
  /// <strong>Rounding and Digit Limits:</strong> Sets the maximum number of digits to display before
  /// the decimal separator. If the number has more than this many digits, the number is truncated.
  ///
  /// For example, if maximum integer digits is 3, the number 12345 will be printed as "345".
  ///
  /// Minimum integer and minimum and maximum fraction digits can be specified via the pattern
  /// string. For example, "\#,\#00.00\#" has 2 minimum integer digits, 2 minimum fraction digits, and 3
  /// maximum fraction digits. Note that it is not possible to specify maximium integer digits in the
  /// pattern except in scientific notation.
  ///
  /// If minimum and maximum integer, fraction, or significant digits conflict with each other,
  /// the most recently specified value is used. For example, if there is a formatter with minInt=5,
  /// and then you set maxInt=3, then minInt will be changed to 3.
  ///@param value The maximum number of digits before the decimal separator.
  void setMaximumIntegerDigits(int value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMaximumIntegerDigits,
      jni.JniType.voidType,
      [value]).check();

  static final _id_getMinimumFractionDigits =
      jniAccessors.getMethodIDOf(_classRef, "getMinimumFractionDigits", "()I");

  /// from: synchronized public int getMinimumFractionDigits()
  ///
  /// Returns the effective minimum number of integer digits after the decimal separator.
  ///@see \#setMaximumIntegerDigits
  int getMinimumFractionDigits() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinimumFractionDigits, jni.JniType.intType, []).integer;

  static final _id_setMinimumFractionDigits =
      jniAccessors.getMethodIDOf(_classRef, "setMinimumFractionDigits", "(I)V");

  /// from: synchronized public void setMinimumFractionDigits(int value)
  ///
  /// <strong>Rounding and Digit Limits:</strong> Sets the minimum number of digits to display after
  /// the decimal separator. If the number has fewer than this many digits, the number is padded with
  /// zeros.
  ///
  /// For example, if minimum fraction digits is 2, the number 123.4 will be printed as "123.40".
  ///
  /// Minimum integer and minimum and maximum fraction digits can be specified via the pattern
  /// string. For example, "\#,\#00.00\#" has 2 minimum integer digits, 2 minimum fraction digits, and 3
  /// maximum fraction digits. Note that it is not possible to specify maximium integer digits in the
  /// pattern except in scientific notation.
  ///
  /// If minimum and maximum integer, fraction, or significant digits conflict with each other,
  /// the most recently specified value is used. For example, if there is a formatter with minInt=5,
  /// and then you set maxInt=3, then minInt will be changed to 3.
  ///
  /// See \#setRoundingIncrement and \#setMaximumSignificantDigits for two other
  /// ways of specifying rounding strategies.
  ///@param value The minimum number of integer digits after the decimal separator.
  ///@see \#setRoundingMode
  ///@see \#setRoundingIncrement
  ///@see \#setMaximumSignificantDigits
  void setMinimumFractionDigits(int value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMinimumFractionDigits,
      jni.JniType.voidType,
      [value]).check();

  static final _id_getMaximumFractionDigits =
      jniAccessors.getMethodIDOf(_classRef, "getMaximumFractionDigits", "()I");

  /// from: synchronized public int getMaximumFractionDigits()
  ///
  /// Returns the effective maximum number of integer digits after the decimal separator.
  ///@see \#setMaximumIntegerDigits
  int getMaximumFractionDigits() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaximumFractionDigits, jni.JniType.intType, []).integer;

  static final _id_setMaximumFractionDigits =
      jniAccessors.getMethodIDOf(_classRef, "setMaximumFractionDigits", "(I)V");

  /// from: synchronized public void setMaximumFractionDigits(int value)
  ///
  /// <strong>Rounding and Digit Limits:</strong> Sets the maximum number of digits to display after
  /// the decimal separator. If the number has more than this many digits, the number is rounded
  /// according to the rounding mode.
  ///
  /// For example, if maximum fraction digits is 2, the number 123.456 will be printed as
  /// "123.46".
  ///
  /// Minimum integer and minimum and maximum fraction digits can be specified via the pattern
  /// string. For example, "\#,\#00.00\#" has 2 minimum integer digits, 2 minimum fraction digits, and 3
  /// maximum fraction digits. Note that it is not possible to specify maximium integer digits in the
  /// pattern except in scientific notation.
  ///
  /// If minimum and maximum integer, fraction, or significant digits conflict with each other,
  /// the most recently specified value is used. For example, if there is a formatter with minInt=5,
  /// and then you set maxInt=3, then minInt will be changed to 3.
  ///@param value The maximum number of integer digits after the decimal separator.
  ///@see \#setRoundingMode
  void setMaximumFractionDigits(int value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMaximumFractionDigits,
      jni.JniType.voidType,
      [value]).check();

  static final _id_areSignificantDigitsUsed =
      jniAccessors.getMethodIDOf(_classRef, "areSignificantDigitsUsed", "()Z");

  /// from: synchronized public boolean areSignificantDigitsUsed()
  ///
  /// <strong>[icu]</strong> Returns whether significant digits are being used in rounding.
  ///@see \#setSignificantDigitsUsed
  bool areSignificantDigitsUsed() => jniAccessors.callMethodWithArgs(reference,
      _id_areSignificantDigitsUsed, jni.JniType.booleanType, []).boolean;

  static final _id_setSignificantDigitsUsed =
      jniAccessors.getMethodIDOf(_classRef, "setSignificantDigitsUsed", "(Z)V");

  /// from: synchronized public void setSignificantDigitsUsed(boolean useSignificantDigits)
  ///
  /// <strong>[icu]</strong> <strong>Rounding and Digit Limits:</strong> Sets whether significant digits are to be
  /// used in rounding.
  ///
  /// Calling <code>df.setSignificantDigitsUsed(true)</code> is functionally equivalent to:
  ///
  /// <pre>
  /// df.setMinimumSignificantDigits(1);
  /// df.setMaximumSignificantDigits(6);
  /// </pre>
  ///@param useSignificantDigits true to enable significant digit rounding; false to disable it.
  void setSignificantDigitsUsed(bool useSignificantDigits) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSignificantDigitsUsed,
          jni.JniType.voidType, [useSignificantDigits]).check();

  static final _id_getMinimumSignificantDigits = jniAccessors.getMethodIDOf(
      _classRef, "getMinimumSignificantDigits", "()I");

  /// from: synchronized public int getMinimumSignificantDigits()
  ///
  /// <strong>[icu]</strong> Returns the effective minimum number of significant digits displayed.
  ///@see \#setMinimumSignificantDigits
  int getMinimumSignificantDigits() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getMinimumSignificantDigits,
      jni.JniType.intType, []).integer;

  static final _id_setMinimumSignificantDigits = jniAccessors.getMethodIDOf(
      _classRef, "setMinimumSignificantDigits", "(I)V");

  /// from: synchronized public void setMinimumSignificantDigits(int value)
  ///
  /// <strong>[icu]</strong> <strong>Rounding and Digit Limits:</strong> Sets the minimum number of significant
  /// digits to be displayed. If the number of significant digits is less than this value, the number
  /// will be padded with zeros as necessary.
  ///
  /// For example, if minimum significant digits is 3 and the number is 1.2, the number will be
  /// printed as "1.20".
  ///
  /// If minimum and maximum integer, fraction, or significant digits conflict with each other,
  /// the most recently specified value is used. For example, if there is a formatter with minInt=5,
  /// and then you set maxInt=3, then minInt will be changed to 3.
  ///@param value The minimum number of significant digits to display.
  void setMinimumSignificantDigits(int value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setMinimumSignificantDigits,
          jni.JniType.voidType,
          [value]).check();

  static final _id_getMaximumSignificantDigits = jniAccessors.getMethodIDOf(
      _classRef, "getMaximumSignificantDigits", "()I");

  /// from: synchronized public int getMaximumSignificantDigits()
  ///
  /// <strong>[icu]</strong> Returns the effective maximum number of significant digits displayed.
  ///@see \#setMaximumSignificantDigits
  int getMaximumSignificantDigits() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getMaximumSignificantDigits,
      jni.JniType.intType, []).integer;

  static final _id_setMaximumSignificantDigits = jniAccessors.getMethodIDOf(
      _classRef, "setMaximumSignificantDigits", "(I)V");

  /// from: synchronized public void setMaximumSignificantDigits(int value)
  ///
  /// <strong>[icu]</strong> <strong>Rounding and Digit Limits:</strong> Sets the maximum number of significant
  /// digits to be displayed. If the number of significant digits in the number exceeds this value,
  /// the number will be rounded according to the current rounding mode.
  ///
  /// For example, if maximum significant digits is 3 and the number is 12345, the number will be
  /// printed as "12300".
  ///
  /// If minimum and maximum integer, fraction, or significant digits conflict with each other,
  /// the most recently specified value is used. For example, if there is a formatter with minInt=5,
  /// and then you set maxInt=3, then minInt will be changed to 3.
  ///
  /// See \#setRoundingIncrement and \#setMaximumFractionDigits for two other ways
  /// of specifying rounding strategies.
  ///@param value The maximum number of significant digits to display.
  ///@see \#setRoundingMode
  ///@see \#setRoundingIncrement
  ///@see \#setMaximumFractionDigits
  void setMaximumSignificantDigits(int value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setMaximumSignificantDigits,
          jni.JniType.voidType,
          [value]).check();

  static final _id_getFormatWidth =
      jniAccessors.getMethodIDOf(_classRef, "getFormatWidth", "()I");

  /// from: synchronized public int getFormatWidth()
  ///
  /// Returns the minimum number of characters in formatted output.
  ///@see \#setFormatWidth
  int getFormatWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getFormatWidth, jni.JniType.intType, []).integer;

  static final _id_setFormatWidth =
      jniAccessors.getMethodIDOf(_classRef, "setFormatWidth", "(I)V");

  /// from: synchronized public void setFormatWidth(int width)
  ///
  /// <strong>Padding:</strong> Sets the minimum width of the string output by the formatting
  /// pipeline. For example, if padding is enabled and paddingWidth is set to 6, formatting the
  /// number "3.14159" with the pattern "0.00" will result in "3.14" if '' is your padding string.
  ///
  /// If the number is longer than your padding width, the number will display as if no padding
  /// width had been specified, which may result in strings longer than the padding width.
  ///
  /// Padding can be specified in the pattern string using the '*' symbol. For example, the format
  /// "*x\#\#\#\#\#\#0" has a format width of 7 and a pad character of 'x'.
  ///
  /// Padding is currently counted in UTF-16 code units; see <a href="http://bugs.icu-project.org/trac/ticket/13034">ticket \#13034</a> for more information.
  ///@param width The minimum number of characters in the output.
  ///@see \#setPadCharacter
  ///@see \#setPadPosition
  void setFormatWidth(int width) => jniAccessors.callMethodWithArgs(
      reference, _id_setFormatWidth, jni.JniType.voidType, [width]).check();

  static final _id_getPadCharacter =
      jniAccessors.getMethodIDOf(_classRef, "getPadCharacter", "()C");

  /// from: synchronized public char getPadCharacter()
  ///
  /// <strong>[icu]</strong> Returns the character used for padding.
  ///@see \#setPadCharacter
  int getPadCharacter() => jniAccessors.callMethodWithArgs(
      reference, _id_getPadCharacter, jni.JniType.charType, []).char;

  static final _id_setPadCharacter =
      jniAccessors.getMethodIDOf(_classRef, "setPadCharacter", "(C)V");

  /// from: synchronized public void setPadCharacter(char padChar)
  ///
  /// <strong>[icu]</strong> <strong>Padding:</strong> Sets the character used to pad numbers that are narrower than
  /// the width specified in \#setFormatWidth.
  ///
  /// In the pattern string, the padding character is the token that follows '*' before or after
  /// the prefix or suffix.
  ///@param padChar The character used for padding.
  ///@see \#setFormatWidth
  void setPadCharacter(int padChar) => jniAccessors.callMethodWithArgs(
      reference, _id_setPadCharacter, jni.JniType.voidType, [padChar]).check();

  static final _id_getPadPosition =
      jniAccessors.getMethodIDOf(_classRef, "getPadPosition", "()I");

  /// from: synchronized public int getPadPosition()
  ///
  /// <strong>[icu]</strong> Returns the position used for padding.
  ///@see \#setPadPosition
  int getPadPosition() => jniAccessors.callMethodWithArgs(
      reference, _id_getPadPosition, jni.JniType.intType, []).integer;

  static final _id_setPadPosition =
      jniAccessors.getMethodIDOf(_classRef, "setPadPosition", "(I)V");

  /// from: synchronized public void setPadPosition(int padPos)
  ///
  /// <strong>[icu]</strong> <strong>Padding:</strong> Sets the position where to insert the pad character when
  /// narrower than the width specified in \#setFormatWidth. For example, consider the pattern
  /// "P123S" with padding width 8 and padding char "*". The four positions are:
  ///
  /// <ul>
  ///   <li>DecimalFormat\#PAD_BEFORE_PREFIX \u21d2 "***P123S"
  ///   <li>DecimalFormat\#PAD_AFTER_PREFIX \u21d2 "P***123S"
  ///   <li>DecimalFormat\#PAD_BEFORE_SUFFIX \u21d2 "P123***S"
  ///   <li>DecimalFormat\#PAD_AFTER_SUFFIX \u21d2 "P123S***"
  /// </ul>
  ///@param padPos The position used for padding.
  ///@see \#setFormatWidth
  void setPadPosition(int padPos) => jniAccessors.callMethodWithArgs(
      reference, _id_setPadPosition, jni.JniType.voidType, [padPos]).check();

  static final _id_isScientificNotation =
      jniAccessors.getMethodIDOf(_classRef, "isScientificNotation", "()Z");

  /// from: synchronized public boolean isScientificNotation()
  ///
  /// <strong>[icu]</strong> Returns whether scientific (exponential) notation is enabled on this formatter.
  ///@see \#setScientificNotation
  bool isScientificNotation() => jniAccessors.callMethodWithArgs(
      reference, _id_isScientificNotation, jni.JniType.booleanType, []).boolean;

  static final _id_setScientificNotation =
      jniAccessors.getMethodIDOf(_classRef, "setScientificNotation", "(Z)V");

  /// from: synchronized public void setScientificNotation(boolean useScientific)
  ///
  /// <strong>[icu]</strong> <strong>Scientific Notation:</strong> Sets whether this formatter should print in
  /// scientific (exponential) notation. For example, if scientific notation is enabled, the number
  /// 123000 will be printed as "1.23E5" in locale _en-US_. A locale-specific symbol is used
  /// as the exponent separator.
  ///
  /// Calling <code>df.setScientificNotation(true)</code> is functionally equivalent to calling
  /// <code>df.setMinimumExponentDigits(1)</code>.
  ///@param useScientific true to enable scientific notation; false to disable it.
  ///@see \#setMinimumExponentDigits
  void setScientificNotation(bool useScientific) =>
      jniAccessors.callMethodWithArgs(reference, _id_setScientificNotation,
          jni.JniType.voidType, [useScientific]).check();

  static final _id_getMinimumExponentDigits =
      jniAccessors.getMethodIDOf(_classRef, "getMinimumExponentDigits", "()B");

  /// from: synchronized public byte getMinimumExponentDigits()
  ///
  /// <strong>[icu]</strong> Returns the minimum number of digits printed in the exponent in scientific notation.
  ///@see \#setMinimumExponentDigits
  int getMinimumExponentDigits() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinimumExponentDigits, jni.JniType.byteType, []).byte;

  static final _id_setMinimumExponentDigits =
      jniAccessors.getMethodIDOf(_classRef, "setMinimumExponentDigits", "(B)V");

  /// from: synchronized public void setMinimumExponentDigits(byte minExpDig)
  ///
  /// <strong>[icu]</strong> <strong>Scientific Notation:</strong> Sets the minimum number of digits to be printed in
  /// the exponent. For example, if minimum exponent digits is 3, the number 123000 will be printed
  /// as "1.23E005".
  ///
  /// This setting corresponds to the number of zeros after the 'E' in a pattern string such as
  /// "0.00E000".
  ///@param minExpDig The minimum number of digits in the exponent.
  void setMinimumExponentDigits(int minExpDig) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMinimumExponentDigits,
          jni.JniType.voidType, [minExpDig]).check();

  static final _id_isExponentSignAlwaysShown =
      jniAccessors.getMethodIDOf(_classRef, "isExponentSignAlwaysShown", "()Z");

  /// from: synchronized public boolean isExponentSignAlwaysShown()
  ///
  /// <strong>[icu]</strong> Returns whether the sign (plus or minus) is always printed in scientific notation.
  ///@see \#setExponentSignAlwaysShown
  bool isExponentSignAlwaysShown() => jniAccessors.callMethodWithArgs(reference,
      _id_isExponentSignAlwaysShown, jni.JniType.booleanType, []).boolean;

  static final _id_setExponentSignAlwaysShown = jniAccessors.getMethodIDOf(
      _classRef, "setExponentSignAlwaysShown", "(Z)V");

  /// from: synchronized public void setExponentSignAlwaysShown(boolean expSignAlways)
  ///
  /// <strong>[icu]</strong> <strong>Scientific Notation:</strong> Sets whether the sign (plus or minus) is always to
  /// be shown in the exponent in scientific notation. For example, if this setting is enabled, the
  /// number 123000 will be printed as "1.23E+5" in locale _en-US_. The number 0.0000123 will
  /// always be printed as "1.23E-5" in locale _en-US_ whether or not this setting is enabled.
  ///
  /// This setting corresponds to the '+' in a pattern such as "0.00E+0".
  ///@param expSignAlways true to always shown the sign in the exponent; false to show it for
  ///     negatives but not positives.
  void setExponentSignAlwaysShown(bool expSignAlways) =>
      jniAccessors.callMethodWithArgs(reference, _id_setExponentSignAlwaysShown,
          jni.JniType.voidType, [expSignAlways]).check();

  static final _id_isGroupingUsed =
      jniAccessors.getMethodIDOf(_classRef, "isGroupingUsed", "()Z");

  /// from: synchronized public boolean isGroupingUsed()
  ///
  /// Returns whether or not grouping separators are being printed in the output.
  ///@see \#setGroupingUsed
  bool isGroupingUsed() => jniAccessors.callMethodWithArgs(
      reference, _id_isGroupingUsed, jni.JniType.booleanType, []).boolean;

  static final _id_setGroupingUsed =
      jniAccessors.getMethodIDOf(_classRef, "setGroupingUsed", "(Z)V");

  /// from: synchronized public void setGroupingUsed(boolean enabled)
  ///
  /// <strong>Grouping:</strong> Sets whether grouping is to be used when formatting numbers.
  /// Grouping means whether the thousands, millions, billions, and larger powers of ten should be
  /// separated by a grouping separator (a comma in _en-US_).
  ///
  /// For example, if grouping is enabled, 12345 will be printed as "12,345" in _en-US_. If
  /// grouping were disabled, it would instead be printed as simply "12345".
  ///
  /// Calling <code>df.setGroupingUsed(true)</code> is functionally equivalent to setting grouping
  /// size to 3, as in <code>df.setGroupingSize(3)</code>.
  ///@param enabled true to enable grouping separators; false to disable them.
  ///@see \#setGroupingSize
  ///@see \#setSecondaryGroupingSize
  void setGroupingUsed(bool enabled) => jniAccessors.callMethodWithArgs(
      reference, _id_setGroupingUsed, jni.JniType.voidType, [enabled]).check();

  static final _id_getGroupingSize =
      jniAccessors.getMethodIDOf(_classRef, "getGroupingSize", "()I");

  /// from: synchronized public int getGroupingSize()
  ///
  /// Returns the primary grouping size in use.
  ///@see \#setGroupingSize
  int getGroupingSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getGroupingSize, jni.JniType.intType, []).integer;

  static final _id_setGroupingSize =
      jniAccessors.getMethodIDOf(_classRef, "setGroupingSize", "(I)V");

  /// from: synchronized public void setGroupingSize(int width)
  ///
  /// <strong>Grouping:</strong> Sets the primary grouping size (distance between grouping
  /// separators) used when formatting large numbers. For most locales, this defaults to 3: the
  /// number of digits between the ones and thousands place, between thousands and millions, and so
  /// forth.
  ///
  /// For example, with a grouping size of 3, the number 1234567 will be formatted as "1,234,567".
  ///
  /// Grouping size can also be specified in the pattern: for example, "\#,\#\#0" corresponds to a
  /// grouping size of 3.
  ///@param width The grouping size to use.
  ///@see \#setSecondaryGroupingSize
  void setGroupingSize(int width) => jniAccessors.callMethodWithArgs(
      reference, _id_setGroupingSize, jni.JniType.voidType, [width]).check();

  static final _id_getSecondaryGroupingSize =
      jniAccessors.getMethodIDOf(_classRef, "getSecondaryGroupingSize", "()I");

  /// from: synchronized public int getSecondaryGroupingSize()
  ///
  /// <strong>[icu]</strong> Returns the secondary grouping size in use.
  ///@see \#setSecondaryGroupingSize
  int getSecondaryGroupingSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getSecondaryGroupingSize, jni.JniType.intType, []).integer;

  static final _id_setSecondaryGroupingSize =
      jniAccessors.getMethodIDOf(_classRef, "setSecondaryGroupingSize", "(I)V");

  /// from: synchronized public void setSecondaryGroupingSize(int width)
  ///
  /// <strong>[icu]</strong> <strong>Grouping:</strong> Sets the secondary grouping size (distance between grouping
  /// separators after the first separator) used when formatting large numbers. In many south Asian
  /// locales, this is set to 2.
  ///
  /// For example, with primary grouping size 3 and secondary grouping size 2, the number 1234567
  /// will be formatted as "12,34,567".
  ///
  /// Grouping size can also be specified in the pattern: for example, "\#,\#\#,\#\#0" corresponds to a
  /// primary grouping size of 3 and a secondary grouping size of 2.
  ///@param width The secondary grouping size to use.
  ///@see \#setGroupingSize
  void setSecondaryGroupingSize(int width) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSecondaryGroupingSize,
      jni.JniType.voidType,
      [width]).check();

  static final _id_isDecimalSeparatorAlwaysShown = jniAccessors.getMethodIDOf(
      _classRef, "isDecimalSeparatorAlwaysShown", "()Z");

  /// from: synchronized public boolean isDecimalSeparatorAlwaysShown()
  ///
  /// Returns whether the decimal separator is shown on integers.
  ///@see \#setDecimalSeparatorAlwaysShown
  bool isDecimalSeparatorAlwaysShown() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isDecimalSeparatorAlwaysShown,
      jni.JniType.booleanType, []).boolean;

  static final _id_setDecimalSeparatorAlwaysShown = jniAccessors.getMethodIDOf(
      _classRef, "setDecimalSeparatorAlwaysShown", "(Z)V");

  /// from: synchronized public void setDecimalSeparatorAlwaysShown(boolean value)
  ///
  /// <strong>Separators:</strong> Sets whether the decimal separator (a period in _en-US_) is
  /// shown on integers. For example, if this setting is turned on, formatting 123 will result in
  /// "123." with the decimal separator.
  ///
  /// This setting can be specified in the pattern for integer formats: "\#,\#\#0." is an example.
  ///@param value true to always show the decimal separator; false to show it only when there is a
  ///     fraction part of the number.
  void setDecimalSeparatorAlwaysShown(bool value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setDecimalSeparatorAlwaysShown,
          jni.JniType.voidType,
          [value]).check();

  static final _id_getCurrency = jniAccessors.getMethodIDOf(
      _classRef, "getCurrency", "()Landroid/icu/util/Currency;");

  /// from: synchronized public android.icu.util.Currency getCurrency()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the user-specified currency. May be null.
  ///@see \#setCurrency
  ///@see DecimalFormatSymbols\#getCurrency
  currency_.Currency getCurrency() =>
      currency_.Currency.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCurrency, jni.JniType.objectType, []).object);

  static final _id_setCurrency = jniAccessors.getMethodIDOf(
      _classRef, "setCurrency", "(Landroid/icu/util/Currency;)V");

  /// from: synchronized public void setCurrency(android.icu.util.Currency currency)
  ///
  /// Sets the currency to be used when formatting numbers. The effect is twofold:
  ///
  /// <ol>
  ///   <li>Substitutions for currency symbols in the pattern string will use this currency
  ///   <li>The rounding mode will obey the rules for this currency (see \#setCurrencyUsage)
  /// </ol>
  ///
  /// <strong>Important:</strong> Displaying the currency in the output requires that the patter
  /// associated with this formatter contains a currency symbol ''. This will be the case if the
  /// instance was created via \#getCurrencyInstance or one of its friends.
  ///@param currency The currency to use.
  void setCurrency(currency_.Currency currency) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCurrency,
          jni.JniType.voidType, [currency.reference]).check();

  static final _id_getCurrencyUsage = jniAccessors.getMethodIDOf(_classRef,
      "getCurrencyUsage", "()Landroid/icu/util/Currency\$CurrencyUsage;");

  /// from: synchronized public android.icu.util.Currency.CurrencyUsage getCurrencyUsage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the strategy for rounding currency amounts.
  ///@see \#setCurrencyUsage
  currency_.Currency_CurrencyUsage getCurrencyUsage() =>
      currency_.Currency_CurrencyUsage.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCurrencyUsage, jni.JniType.objectType, []).object);

  static final _id_setCurrencyUsage = jniAccessors.getMethodIDOf(_classRef,
      "setCurrencyUsage", "(Landroid/icu/util/Currency\$CurrencyUsage;)V");

  /// from: synchronized public void setCurrencyUsage(android.icu.util.Currency.CurrencyUsage usage)
  ///
  /// <strong>[icu]</strong> Sets the currency-dependent strategy to use when rounding numbers. There are two
  /// strategies:
  ///
  /// <ul>
  ///   <li>STANDARD: When the amount displayed is intended for banking statements or electronic
  ///       transfer.
  ///   <li>CASH: When the amount displayed is intended to be representable in physical currency,
  ///       like at a cash register.
  /// </ul>
  ///
  /// CASH mode is relevant in currencies that do not have tender down to the penny. For more
  /// information on the two rounding strategies, see <a href="http://unicode.org/reports/tr35/tr35-numbers.html\#Supplemental_Currency_Data">UTS
  /// \#35</a>. If omitted, the strategy defaults to STANDARD. To override currency rounding
  /// altogether, use \#setMinimumFractionDigits and \#setMaximumFractionDigits or
  /// \#setRoundingIncrement.
  ///@param usage The strategy to use when rounding in the current currency.
  void setCurrencyUsage(currency_.Currency_CurrencyUsage usage) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCurrencyUsage,
          jni.JniType.voidType, [usage.reference]).check();

  static final _id_getCurrencyPluralInfo = jniAccessors.getMethodIDOf(_classRef,
      "getCurrencyPluralInfo", "()Landroid/icu/text/CurrencyPluralInfo;");

  /// from: synchronized public android.icu.text.CurrencyPluralInfo getCurrencyPluralInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the current instance of CurrencyPluralInfo.
  ///@see \#setCurrencyPluralInfo
  currencypluralinfo_.CurrencyPluralInfo getCurrencyPluralInfo() =>
      currencypluralinfo_.CurrencyPluralInfo.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getCurrencyPluralInfo,
              jni.JniType.objectType, []).object);

  static final _id_setCurrencyPluralInfo = jniAccessors.getMethodIDOf(_classRef,
      "setCurrencyPluralInfo", "(Landroid/icu/text/CurrencyPluralInfo;)V");

  /// from: synchronized public void setCurrencyPluralInfo(android.icu.text.CurrencyPluralInfo newInfo)
  ///
  /// <strong>[icu]</strong> Sets a custom instance of CurrencyPluralInfo. CurrencyPluralInfo generates pattern
  /// strings for printing currency long names.
  ///
  /// <strong>Most users should not call this method directly.</strong> You should instead create
  /// your formatter via <code>NumberFormat.getInstance(NumberFormat.PLURALCURRENCYSTYLE)</code>.
  ///@param newInfo The CurrencyPluralInfo to use when printing currency long names.
  void setCurrencyPluralInfo(currencypluralinfo_.CurrencyPluralInfo newInfo) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCurrencyPluralInfo,
          jni.JniType.voidType, [newInfo.reference]).check();

  static final _id_isParseBigDecimal =
      jniAccessors.getMethodIDOf(_classRef, "isParseBigDecimal", "()Z");

  /// from: synchronized public boolean isParseBigDecimal()
  ///
  /// Returns whether \#parse will always return a BigDecimal.
  ///@see \#setParseBigDecimal
  bool isParseBigDecimal() => jniAccessors.callMethodWithArgs(
      reference, _id_isParseBigDecimal, jni.JniType.booleanType, []).boolean;

  static final _id_setParseBigDecimal =
      jniAccessors.getMethodIDOf(_classRef, "setParseBigDecimal", "(Z)V");

  /// from: synchronized public void setParseBigDecimal(boolean value)
  ///
  /// Whether to make \#parse prefer returning a android.icu.math.BigDecimal when
  /// possible. For strings corresponding to return values of Infinity, -Infinity, NaN, and -0.0, a
  /// Double will be returned even if ParseBigDecimal is enabled.
  ///@param value true to cause \#parse to prefer BigDecimal; false to let \#parse
  ///     return additional data types like Long or BigInteger.
  void setParseBigDecimal(bool value) => jniAccessors.callMethodWithArgs(
      reference, _id_setParseBigDecimal, jni.JniType.voidType, [value]).check();

  static final _id_getParseMaxDigits =
      jniAccessors.getMethodIDOf(_classRef, "getParseMaxDigits", "()I");

  /// from: public int getParseMaxDigits()
  ///
  /// Always returns 1000, the default prior to ICU 59.
  ///@deprecated Setting max parse digits has no effect since ICU4J 59.
  int getParseMaxDigits() => jniAccessors.callMethodWithArgs(
      reference, _id_getParseMaxDigits, jni.JniType.intType, []).integer;

  static final _id_setParseMaxDigits =
      jniAccessors.getMethodIDOf(_classRef, "setParseMaxDigits", "(I)V");

  /// from: public void setParseMaxDigits(int maxDigits)
  ///
  /// @param maxDigits Prior to ICU 59, the maximum number of digits in the output number after
  ///     exponential notation is applied.
  ///@deprecated Setting max parse digits has no effect since ICU4J 59.
  void setParseMaxDigits(int maxDigits) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setParseMaxDigits,
      jni.JniType.voidType,
      [maxDigits]).check();

  static final _id_isParseStrict =
      jniAccessors.getMethodIDOf(_classRef, "isParseStrict", "()Z");

  /// from: synchronized public boolean isParseStrict()
  ///
  /// {@inheritDoc}
  bool isParseStrict() => jniAccessors.callMethodWithArgs(
      reference, _id_isParseStrict, jni.JniType.booleanType, []).boolean;

  static final _id_setParseStrict =
      jniAccessors.getMethodIDOf(_classRef, "setParseStrict", "(Z)V");

  /// from: synchronized public void setParseStrict(boolean parseStrict)
  ///
  /// {@inheritDoc}
  void setParseStrict(bool parseStrict) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setParseStrict,
      jni.JniType.voidType,
      [parseStrict]).check();

  static final _id_isParseIntegerOnly =
      jniAccessors.getMethodIDOf(_classRef, "isParseIntegerOnly", "()Z");

  /// from: synchronized public boolean isParseIntegerOnly()
  ///
  /// {@inheritDoc}
  ///@see \#setParseIntegerOnly
  bool isParseIntegerOnly() => jniAccessors.callMethodWithArgs(
      reference, _id_isParseIntegerOnly, jni.JniType.booleanType, []).boolean;

  static final _id_setParseIntegerOnly =
      jniAccessors.getMethodIDOf(_classRef, "setParseIntegerOnly", "(Z)V");

  /// from: synchronized public void setParseIntegerOnly(boolean parseIntegerOnly)
  ///
  /// <strong>Parsing:</strong> {@inheritDoc}
  ///
  /// This is functionally equivalent to calling \#setDecimalPatternMatchRequired and a
  /// pattern without a decimal point.
  ///@param parseIntegerOnly true to ignore fractional parts of numbers when parsing; false to
  ///     consume fractional parts.
  void setParseIntegerOnly(bool parseIntegerOnly) =>
      jniAccessors.callMethodWithArgs(reference, _id_setParseIntegerOnly,
          jni.JniType.voidType, [parseIntegerOnly]).check();

  static final _id_isDecimalPatternMatchRequired = jniAccessors.getMethodIDOf(
      _classRef, "isDecimalPatternMatchRequired", "()Z");

  /// from: synchronized public boolean isDecimalPatternMatchRequired()
  ///
  /// <strong>[icu]</strong> Returns whether the presence of a decimal point must match the pattern.
  ///@see \#setDecimalPatternMatchRequired
  bool isDecimalPatternMatchRequired() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isDecimalPatternMatchRequired,
      jni.JniType.booleanType, []).boolean;

  static final _id_setDecimalPatternMatchRequired = jniAccessors.getMethodIDOf(
      _classRef, "setDecimalPatternMatchRequired", "(Z)V");

  /// from: synchronized public void setDecimalPatternMatchRequired(boolean value)
  ///
  /// <strong>[icu]</strong> <strong>Parsing:</strong> This method is used to either _require_ or
  /// _forbid_ the presence of a decimal point in the string being parsed (disabled by
  /// default). This feature was designed to be an extra layer of strictness on top of strict
  /// parsing, although it can be used in either lenient mode or strict mode.
  ///
  /// To _require_ a decimal point, call this method in combination with either a pattern
  /// containing a decimal point or with \#setDecimalSeparatorAlwaysShown.
  ///
  /// <pre>
  /// // Require a decimal point in the string being parsed:
  /// df.applyPattern("\#.");
  /// df.setDecimalPatternMatchRequired(true);
  ///
  /// // Alternatively:
  /// df.setDecimalSeparatorAlwaysShown(true);
  /// df.setDecimalPatternMatchRequired(true);
  /// </pre>
  ///
  /// To _forbid_ a decimal point, call this method in combination with a pattern containing
  /// no decimal point. Alternatively, use \#setParseIntegerOnly for the same behavior without
  /// depending on the contents of the pattern string.
  ///
  /// <pre>
  /// // Forbid a decimal point in the string being parsed:
  /// df.applyPattern("\#");
  /// df.setDecimalPatternMatchRequired(true);
  /// </pre>
  ///@param value true to either require or forbid the decimal point according to the pattern; false
  ///     to disable this feature.
  ///@see \#setParseIntegerOnly
  void setDecimalPatternMatchRequired(bool value) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setDecimalPatternMatchRequired,
          jni.JniType.voidType,
          [value]).check();

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: synchronized public boolean equals(java.lang.Object obj)
  ///
  /// Tests for equality between this formatter and another formatter.
  ///
  /// If two DecimalFormat instances are equal, then they will always produce the same output.
  /// However, the reverse is not necessarily true: if two DecimalFormat instances always produce the
  /// same output, they are not necessarily equal.
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: synchronized public int hashCode()
  ///
  /// {@inheritDoc}
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the default value of toString() with extra DecimalFormat-specific information appended
  /// to the end of the string. This extra information is intended for debugging purposes, and the
  /// format is not guaranteed to be stable.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_toPattern = jniAccessors.getMethodIDOf(
      _classRef, "toPattern", "()Ljava/lang/String;");

  /// from: synchronized public java.lang.String toPattern()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Serializes this formatter object to a decimal format pattern string. The result of this method
  /// is guaranteed to be _functionally_ equivalent to the pattern string used to create this
  /// instance after incorporating values from the setter methods.
  ///
  /// For more information on decimal format pattern strings, see <a href="http://unicode.org/reports/tr35/tr35-numbers.html\#Number_Format_Patterns">UTS \#35</a>.
  ///
  /// <strong>Important:</strong> Not all properties are capable of being encoded in a pattern
  /// string. See a list of properties in \#applyPattern.
  ///@return A decimal format pattern string.
  jni.JniString toPattern() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toPattern, jni.JniType.objectType, []).object);

  static final _id_toLocalizedPattern = jniAccessors.getMethodIDOf(
      _classRef, "toLocalizedPattern", "()Ljava/lang/String;");

  /// from: synchronized public java.lang.String toLocalizedPattern()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Calls \#toPattern and converts the string to localized notation. For more information on
  /// localized notation, see \#applyLocalizedPattern. This method is provided for backwards
  /// compatibility and should not be used in new projects.
  ///@return A decimal format pattern string in localized notation.
  jni.JniString toLocalizedPattern() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_toLocalizedPattern, jni.JniType.objectType, []).object);
}
