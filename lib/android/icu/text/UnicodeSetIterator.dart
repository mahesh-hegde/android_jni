// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "UnicodeSet.dart" as unicodeset_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.text.UnicodeSetIterator
///
/// UnicodeSetIterator iterates over the contents of a UnicodeSet.  It
/// iterates over either code points or code point ranges.  After all
/// code points or ranges have been returned, it returns the
/// multicharacter strings of the UnicodSet, if any.
///
/// To iterate over code points and multicharacter strings,
/// use a loop like this:
/// <pre>
/// for (UnicodeSetIterator it = new UnicodeSetIterator(set); it.next();) {
///   processString(it.getString());
/// }
/// </pre>
///
/// To iterate over code point ranges, use a loop like this:
/// <pre>
/// for (UnicodeSetIterator it = new UnicodeSetIterator(set); it.nextRange();) {
///   if (it.codepoint != UnicodeSetIterator.IS_STRING) {
///     processCodepointRange(it.codepoint, it.codepointEnd);
///   } else {
///     processString(it.getString());
///   }
/// }
/// </pre>
/// __Warning: __For speed, UnicodeSet iteration does not check for concurrent modification.
/// Do not alter the UnicodeSet while iterating.
///@author M. Davis
class UnicodeSetIterator extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/UnicodeSetIterator");
  UnicodeSetIterator.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_IS_STRING =
      jniAccessors.getStaticFieldIDOf(_classRef, "IS_STRING", "I");

  /// from: static public int IS_STRING
  ///
  /// Value of <tt>codepoint</tt> if the iterator points to a string.
  /// If <tt>codepoint == IS_STRING</tt>, then examine
  /// <tt>string</tt> for the current iteration result.
  static int get IS_STRING => jniAccessors
      .getStaticField(_classRef, _id_IS_STRING, jni.JniType.intType)
      .integer;

  /// from: static public int IS_STRING
  ///
  /// Value of <tt>codepoint</tt> if the iterator points to a string.
  /// If <tt>codepoint == IS_STRING</tt>, then examine
  /// <tt>string</tt> for the current iteration result.
  static set IS_STRING(int value) =>
      jniEnv.SetStaticIntField(_classRef, _id_IS_STRING, value);

  static final _id_codepoint =
      jniAccessors.getFieldIDOf(_classRef, "codepoint", "I");

  /// from: public int codepoint
  ///
  /// Current code point, or the special value <tt>IS_STRING</tt>, if
  /// the iterator points to a string.
  int get codepoint => jniAccessors
      .getField(reference, _id_codepoint, jni.JniType.intType)
      .integer;

  /// from: public int codepoint
  ///
  /// Current code point, or the special value <tt>IS_STRING</tt>, if
  /// the iterator points to a string.
  set codepoint(int value) =>
      jniEnv.SetIntField(reference, _id_codepoint, value);

  static final _id_codepointEnd =
      jniAccessors.getFieldIDOf(_classRef, "codepointEnd", "I");

  /// from: public int codepointEnd
  ///
  /// When iterating over ranges using <tt>nextRange()</tt>,
  /// <tt>codepointEnd</tt> contains the inclusive end of the
  /// iteration range, if <tt>codepoint != IS_STRING</tt>.  If
  /// iterating over code points using <tt>next()</tt>, or if
  /// <tt>codepoint == IS_STRING</tt>, then the value of
  /// <tt>codepointEnd</tt> is undefined.
  int get codepointEnd => jniAccessors
      .getField(reference, _id_codepointEnd, jni.JniType.intType)
      .integer;

  /// from: public int codepointEnd
  ///
  /// When iterating over ranges using <tt>nextRange()</tt>,
  /// <tt>codepointEnd</tt> contains the inclusive end of the
  /// iteration range, if <tt>codepoint != IS_STRING</tt>.  If
  /// iterating over code points using <tt>next()</tt>, or if
  /// <tt>codepoint == IS_STRING</tt>, then the value of
  /// <tt>codepointEnd</tt> is undefined.
  set codepointEnd(int value) =>
      jniEnv.SetIntField(reference, _id_codepointEnd, value);

  static final _id_string =
      jniAccessors.getFieldIDOf(_classRef, "string", "Ljava/lang/String;");

  /// from: public java.lang.String string
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If <tt>codepoint == IS_STRING</tt>, then <tt>string</tt> points
  /// to the current string.  If <tt>codepoint != IS_STRING</tt>, the
  /// value of <tt>string</tt> is undefined.
  jni.JniString get string => jni.JniString.fromRef(jniAccessors
      .getField(reference, _id_string, jni.JniType.objectType)
      .object);

  /// from: public java.lang.String string
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If <tt>codepoint == IS_STRING</tt>, then <tt>string</tt> points
  /// to the current string.  If <tt>codepoint != IS_STRING</tt>, the
  /// value of <tt>string</tt> is undefined.
  set string(jni.JniString value) =>
      jniEnv.SetObjectField(reference, _id_string, value.reference);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/icu/text/UnicodeSet;)V");

  /// from: public void <init>(android.icu.text.UnicodeSet set)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an iterator over the given set.
  ///@param set set to iterate over
  UnicodeSetIterator(unicodeset_.UnicodeSet set0)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [set0.reference]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an iterator over nothing.  <tt>next()</tt> and
  /// <tt>nextRange()</tt> return false. This is a convenience
  /// constructor allowing the target to be set later.
  UnicodeSetIterator.ctor1()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor1, []).object);

  static final _id_next = jniAccessors.getMethodIDOf(_classRef, "next", "()Z");

  /// from: public boolean next()
  ///
  /// Returns the next element in the set, either a single code point
  /// or a string.  If there are no more elements in the set, return
  /// false.  If <tt>codepoint == IS_STRING</tt>, the value is a
  /// string in the <tt>string</tt> field.  Otherwise the value is a
  /// single code point in the <tt>codepoint</tt> field.
  ///
  /// The order of iteration is all code points in sorted order,
  /// followed by all strings sorted order.  <tt>codepointEnd</tt> is
  /// undefined after calling this method.  <tt>string</tt> is
  /// undefined unless <tt>codepoint == IS_STRING</tt>.  Do not mix
  /// calls to <tt>next()</tt> and <tt>nextRange()</tt> without
  /// calling <tt>reset()</tt> between them.  The results of doing so
  /// are undefined.
  /// __Warning: __For speed, UnicodeSet iteration does not check for concurrent modification.
  /// Do not alter the UnicodeSet while iterating.
  ///@return true if there was another element in the set and this
  /// object contains the element.
  bool next() => jniAccessors.callMethodWithArgs(
      reference, _id_next, jni.JniType.booleanType, []).boolean;

  static final _id_nextRange =
      jniAccessors.getMethodIDOf(_classRef, "nextRange", "()Z");

  /// from: public boolean nextRange()
  ///
  /// Returns the next element in the set, either a code point range
  /// or a string.  If there are no more elements in the set, return
  /// false.  If <tt>codepoint == IS_STRING</tt>, the value is a
  /// string in the <tt>string</tt> field.  Otherwise the value is a
  /// range of one or more code points from <tt>codepoint</tt> to
  /// <tt>codepointeEnd</tt> inclusive.
  ///
  /// The order of iteration is all code points ranges in sorted
  /// order, followed by all strings sorted order.  Ranges are
  /// disjoint and non-contiguous.  <tt>string</tt> is undefined
  /// unless <tt>codepoint == IS_STRING</tt>.  Do not mix calls to
  /// <tt>next()</tt> and <tt>nextRange()</tt> without calling
  /// <tt>reset()</tt> between them.  The results of doing so are
  /// undefined.
  ///@return true if there was another element in the set and this
  /// object contains the element.
  bool nextRange() => jniAccessors.callMethodWithArgs(
      reference, _id_nextRange, jni.JniType.booleanType, []).boolean;

  static final _id_reset = jniAccessors.getMethodIDOf(
      _classRef, "reset", "(Landroid/icu/text/UnicodeSet;)V");

  /// from: public void reset(android.icu.text.UnicodeSet uset)
  ///
  /// Sets this iterator to visit the elements of the given set and
  /// resets it to the start of that set.  The iterator is valid only
  /// so long as <tt>set</tt> is valid.
  ///@param uset the set to iterate over.
  void reset(unicodeset_.UnicodeSet uset) => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniType.voidType, [uset.reference]).check();

  static final _id_reset1 =
      jniAccessors.getMethodIDOf(_classRef, "reset", "()V");

  /// from: public void reset()
  ///
  /// Resets this iterator to the start of the set.
  void reset1() => jniAccessors.callMethodWithArgs(
      reference, _id_reset1, jni.JniType.voidType, []).check();

  static final _id_getString = jniAccessors.getMethodIDOf(
      _classRef, "getString", "()Ljava/lang/String;");

  /// from: public java.lang.String getString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current string from the iterator. Only use after calling next(), not nextRange().
  jni.JniString getString() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getString, jni.JniType.objectType, []).object);
}
