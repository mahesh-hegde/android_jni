// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../util/ULocale.dart" as ulocale_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.text.PluralRules
///
///
/// Defines rules for mapping non-negative numeric values onto a small set of keywords.
///
///
///
/// Rules are constructed from a text description, consisting of a series of keywords and conditions. The \#select
/// method examines each condition in order and returns the keyword for the first condition that matches the number. If
/// none match, \#KEYWORD_OTHER is returned.
///
///
///
/// A PluralRules object is immutable. It contains caches for sample values, but those are synchronized.
///
/// PluralRules is Serializable so that it can be used in formatters, which are serializable.
///
///
///
/// For more information, details, and tips for writing rules, see the <a href="http://www.unicode.org/draft/reports/tr35/tr35.html\#Language_Plural_Rules">LDML spec, C.11 Language Plural
/// Rules</a>
///
///
///
/// Examples:
///
///
///
/// <pre>
/// &quot;one: n is 1; few: n in 2..4&quot;
/// </pre>
///
/// This defines two rules, for 'one' and 'few'. The condition for 'one' is "n is 1" which means that the number must be
/// equal to 1 for this condition to pass. The condition for 'few' is "n in 2..4" which means that the number must be
/// between 2 and 4 inclusive - and be an integer - for this condition to pass. All other numbers are assigned the
/// keyword "other" by the default rule.
///
///
///
/// <pre>
/// &quot;zero: n is 0; one: n is 1; zero: n mod 100 in 1..19&quot;
/// </pre>
///
/// This illustrates that the same keyword can be defined multiple times. Each rule is examined in order, and the first
/// keyword whose condition passes is the one returned. Also notes that a modulus is applied to n in the last rule. Thus
/// its condition holds for 119, 219, 319...
///
///
///
/// <pre>
/// &quot;one: n is 1; few: n mod 10 in 2..4 and n mod 100 not in 12..14&quot;
/// </pre>
///
/// This illustrates conjunction and negation. The condition for 'few' has two parts, both of which must be met:
/// "n mod 10 in 2..4" and "n mod 100 not in 12..14". The first part applies a modulus to n before the test as in the
/// previous example. The second part applies a different modulus and also uses negation, thus it matches all numbers
/// _not_ in 12, 13, 14, 112, 113, 114, 212, 213, 214...
///
///
///
/// Syntax:
///
///
/// <pre>
/// rules         = rule (';' rule)*
/// rule          = keyword ':' condition
/// keyword       = &lt;identifier&gt;
/// condition     = and_condition ('or' and_condition)*
/// and_condition = relation ('and' relation)*
/// relation      = not? expr not? rel not? range_list
/// expr          = ('n' | 'i' | 'f' | 'v' | 't') (mod value)?
/// not           = 'not' | '!'
/// rel           = 'in' | 'is' | '=' | '\u2260' | 'within'
/// mod           = 'mod' | '%'
/// range_list    = (range | value) (',' range_list)*
/// value         = digit+
/// digit         = 0|1|2|3|4|5|6|7|8|9
/// range         = value'..'value
/// </pre>
/// Each __not__ term inverts the meaning; however, there should not be more than one of them.
///
///
/// The i, f, t, and v values are defined as follows:
///
///
/// <ul>
/// <li>i to be the integer digits.</li>
/// <li>f to be the visible decimal digits, as an integer.</li>
/// <li>t to be the visible decimal digits\u2014without trailing zeros\u2014as an integer.</li>
/// <li>v to be the number of visible fraction digits.</li>
/// <li>j is defined to only match integers. That is j is 3 fails if v != 0 (eg for 3.1 or 3.0).</li>
/// </ul>
///
/// Examples are in the following table:
///
///
/// <table border='1'style="border-collapse:collapse">
/// <tbody>
/// <tr>
/// <th>n</th>
/// <th>i</th>
/// <th>f</th>
/// <th>v</th>
/// </tr>
/// <tr>
/// <td>1.0</td>
/// <td>1</td>
/// <td align="right">0</td>
/// <td>1</td>
/// </tr>
/// <tr>
/// <td>1.00</td>
/// <td>1</td>
/// <td align="right">0</td>
/// <td>2</td>
/// </tr>
/// <tr>
/// <td>1.3</td>
/// <td>1</td>
/// <td align="right">3</td>
/// <td>1</td>
/// </tr>
/// <tr>
/// <td>1.03</td>
/// <td>1</td>
/// <td align="right">3</td>
/// <td>2</td>
/// </tr>
/// <tr>
/// <td>1.23</td>
/// <td>1</td>
/// <td align="right">23</td>
/// <td>2</td>
/// </tr>
/// </tbody>
/// </table>
///
/// An "identifier" is a sequence of characters that do not have the Unicode Pattern_Syntax or Pattern_White_Space
/// properties.
///
/// The difference between 'in' and 'within' is that 'in' only includes integers in the specified range, while 'within'
/// includes all values. Using 'within' with a range_list consisting entirely of values is the same as using 'in' (it's
/// not an error).
///
///
class PluralRules extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/PluralRules");
  PluralRules.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_DEFAULT = jniAccessors.getStaticFieldIDOf(
      _classRef, "DEFAULT", "Landroid/icu/text/PluralRules;");

  /// from: static public final android.icu.text.PluralRules DEFAULT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The default rules that accept any number and return
  /// \#KEYWORD_OTHER.
  static PluralRules get DEFAULT => PluralRules.fromRef(jniAccessors
      .getStaticField(_classRef, _id_DEFAULT, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String KEYWORD_FEW
  ///
  /// Common name for the 'paucal' or other special plural form.
  static const KEYWORD_FEW = "few";

  /// from: static public final java.lang.String KEYWORD_MANY
  ///
  /// Common name for the arabic (11 to 99) plural form.
  static const KEYWORD_MANY = "many";

  /// from: static public final java.lang.String KEYWORD_ONE
  ///
  /// Common name for the 'singular' plural form.
  static const KEYWORD_ONE = "one";

  /// from: static public final java.lang.String KEYWORD_OTHER
  ///
  /// Common name for the default plural form.  This name is returned
  /// for values to which no other form in the rule applies.  It
  /// can additionally be assigned rules of its own.
  static const KEYWORD_OTHER = "other";

  /// from: static public final java.lang.String KEYWORD_TWO
  ///
  /// Common name for the 'dual' plural form.
  static const KEYWORD_TWO = "two";

  /// from: static public final java.lang.String KEYWORD_ZERO
  ///
  /// Common name for the 'zero' plural form.
  static const KEYWORD_ZERO = "zero";

  /// from: static public final double NO_UNIQUE_VALUE
  ///
  /// Value returned by \#getUniqueKeywordValue when there is no
  /// unique value to return.
  static const NO_UNIQUE_VALUE = -0.00123456777;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  PluralRules()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_parseDescription = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "parseDescription",
      "(Ljava/lang/String;)Landroid/icu/text/PluralRules;");

  /// from: static public android.icu.text.PluralRules parseDescription(java.lang.String description)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a plural rules description and returns a PluralRules.
  ///@param description the rule description.
  ///@throws ParseException if the description cannot be parsed.
  ///    The exception index is typically not set, it will be -1.
  static PluralRules parseDescription(jni.JniString description) =>
      PluralRules.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_parseDescription,
          jni.JniType.objectType,
          [description.reference]).object);

  static final _id_createRules = jniAccessors.getStaticMethodIDOf(_classRef,
      "createRules", "(Ljava/lang/String;)Landroid/icu/text/PluralRules;");

  /// from: static public android.icu.text.PluralRules createRules(java.lang.String description)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a PluralRules from a description if it is parsable,
  /// otherwise returns null.
  ///@param description the rule description.
  ///@return the PluralRules
  static PluralRules createRules(jni.JniString description) =>
      PluralRules.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createRules,
          jni.JniType.objectType,
          [description.reference]).object);

  static final _id_forLocale = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "forLocale",
      "(Landroid/icu/util/ULocale;)Landroid/icu/text/PluralRules;");

  /// from: static public android.icu.text.PluralRules forLocale(android.icu.util.ULocale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provides access to the predefined cardinal-number <code>PluralRules</code> for a given
  /// locale.
  /// Same as forLocale(locale, PluralType.CARDINAL).
  ///
  /// ICU defines plural rules for many locales based on CLDR <i>Language Plural Rules</i>.
  /// For these predefined rules, see CLDR page at
  /// http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
  ///@param locale The locale for which a <code>PluralRules</code> object is
  ///   returned.
  ///@return The predefined <code>PluralRules</code> object for this locale.
  ///   If there's no predefined rules for this locale, the rules
  ///   for the closest parent in the locale hierarchy that has one will
  ///   be returned.  The final fallback always returns the default
  ///   rules.
  static PluralRules forLocale(ulocale_.ULocale locale) =>
      PluralRules.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_forLocale, jni.JniType.objectType, [locale.reference]).object);

  static final _id_forLocale1 = jniAccessors.getStaticMethodIDOf(_classRef,
      "forLocale", "(Ljava/util/Locale;)Landroid/icu/text/PluralRules;");

  /// from: static public android.icu.text.PluralRules forLocale(java.util.Locale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provides access to the predefined cardinal-number <code>PluralRules</code> for a given
  /// java.util.Locale.
  /// Same as forLocale(locale, PluralType.CARDINAL).
  ///
  /// ICU defines plural rules for many locales based on CLDR <i>Language Plural Rules</i>.
  /// For these predefined rules, see CLDR page at
  /// http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
  ///@param locale The locale for which a <code>PluralRules</code> object is
  ///   returned.
  ///@return The predefined <code>PluralRules</code> object for this locale.
  ///   If there's no predefined rules for this locale, the rules
  ///   for the closest parent in the locale hierarchy that has one will
  ///   be returned.  The final fallback always returns the default
  ///   rules.
  static PluralRules forLocale1(jni.JniObject locale) =>
      PluralRules.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_forLocale1, jni.JniType.objectType, [locale.reference]).object);

  static final _id_forLocale2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "forLocale",
      "(Landroid/icu/util/ULocale;Landroid/icu/text/PluralRules\$PluralType;)Landroid/icu/text/PluralRules;");

  /// from: static public android.icu.text.PluralRules forLocale(android.icu.util.ULocale locale, android.icu.text.PluralRules.PluralType type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provides access to the predefined <code>PluralRules</code> for a given
  /// locale and the plural type.
  ///
  /// ICU defines plural rules for many locales based on CLDR <i>Language Plural Rules</i>.
  /// For these predefined rules, see CLDR page at
  /// http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
  ///@param locale The locale for which a <code>PluralRules</code> object is
  ///   returned.
  ///@param type The plural type (e.g., cardinal or ordinal).
  ///@return The predefined <code>PluralRules</code> object for this locale.
  ///   If there's no predefined rules for this locale, the rules
  ///   for the closest parent in the locale hierarchy that has one will
  ///   be returned.  The final fallback always returns the default
  ///   rules.
  static PluralRules forLocale2(
          ulocale_.ULocale locale, PluralRules_PluralType type) =>
      PluralRules.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_forLocale2,
          jni.JniType.objectType,
          [locale.reference, type.reference]).object);

  static final _id_forLocale3 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "forLocale",
      "(Ljava/util/Locale;Landroid/icu/text/PluralRules\$PluralType;)Landroid/icu/text/PluralRules;");

  /// from: static public android.icu.text.PluralRules forLocale(java.util.Locale locale, android.icu.text.PluralRules.PluralType type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provides access to the predefined <code>PluralRules</code> for a given
  /// java.util.Locale and the plural type.
  ///
  /// ICU defines plural rules for many locales based on CLDR <i>Language Plural Rules</i>.
  /// For these predefined rules, see CLDR page at
  /// http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
  ///@param locale The locale for which a <code>PluralRules</code> object is
  ///   returned.
  ///@param type The plural type (e.g., cardinal or ordinal).
  ///@return The predefined <code>PluralRules</code> object for this locale.
  ///   If there's no predefined rules for this locale, the rules
  ///   for the closest parent in the locale hierarchy that has one will
  ///   be returned.  The final fallback always returns the default
  ///   rules.
  static PluralRules forLocale3(
          jni.JniObject locale, PluralRules_PluralType type) =>
      PluralRules.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_forLocale3,
          jni.JniType.objectType,
          [locale.reference, type.reference]).object);

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// @deprecated This API is ICU internal only.
  ///@hide original deprecated declaration
  ///@hide draft / provisional / internal are hidden on Android
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_select =
      jniAccessors.getMethodIDOf(_classRef, "select", "(D)Ljava/lang/String;");

  /// from: public java.lang.String select(double number)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Given a number, returns the keyword of the first rule that applies to
  /// the number.
  ///@param number The number for which the rule has to be determined.
  ///@return The keyword of the selected rule.
  jni.JniString select(double number) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_select, jni.JniType.objectType, [number]).object);

  static final _id_getKeywords =
      jniAccessors.getMethodIDOf(_classRef, "getKeywords", "()Ljava/util/Set;");

  /// from: public java.util.Set<java.lang.String> getKeywords()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a set of all rule keywords used in this <code>PluralRules</code>
  /// object.  The rule "other" is always present by default.
  ///@return The set of keywords.
  jni.JniObject getKeywords() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getKeywords, jni.JniType.objectType, []).object);

  static final _id_getUniqueKeywordValue = jniAccessors.getMethodIDOf(
      _classRef, "getUniqueKeywordValue", "(Ljava/lang/String;)D");

  /// from: public double getUniqueKeywordValue(java.lang.String keyword)
  ///
  /// Returns the unique value that this keyword matches, or \#NO_UNIQUE_VALUE
  /// if the keyword matches multiple values or is not defined for this PluralRules.
  ///@param keyword the keyword to check for a unique value
  ///@return The unique value for the keyword, or NO_UNIQUE_VALUE.
  double getUniqueKeywordValue(jni.JniString keyword) =>
      jniAccessors.callMethodWithArgs(reference, _id_getUniqueKeywordValue,
          jni.JniType.doubleType, [keyword.reference]).doubleFloat;

  static final _id_getAllKeywordValues = jniAccessors.getMethodIDOf(_classRef,
      "getAllKeywordValues", "(Ljava/lang/String;)Ljava/util/Collection;");

  /// from: public java.util.Collection<java.lang.Double> getAllKeywordValues(java.lang.String keyword)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns all the values that trigger this keyword, or null if the number of such
  /// values is unlimited.
  ///@param keyword the keyword
  ///@return the values that trigger this keyword, or null.  The returned collection
  /// is immutable. It will be empty if the keyword is not defined.
  jni.JniObject getAllKeywordValues(jni.JniString keyword) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAllKeywordValues,
          jni.JniType.objectType,
          [keyword.reference]).object);

  static final _id_getSamples = jniAccessors.getMethodIDOf(
      _classRef, "getSamples", "(Ljava/lang/String;)Ljava/util/Collection;");

  /// from: public java.util.Collection<java.lang.Double> getSamples(java.lang.String keyword)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of integer values for which select() would return that keyword,
  /// or null if the keyword is not defined. The returned collection is unmodifiable.
  /// The returned list is not complete, and there might be additional values that
  /// would return the keyword.
  ///@param keyword the keyword to test
  ///@return a list of values matching the keyword.
  jni.JniObject getSamples(jni.JniString keyword) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSamples, jni.JniType.objectType, [keyword.reference]).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object rhs)
  ///
  /// {@inheritDoc}
  bool equals1(jni.JniObject rhs) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [rhs.reference]).boolean;

  static final _id_equals2 = jniAccessors.getMethodIDOf(
      _classRef, "equals", "(Landroid/icu/text/PluralRules;)Z");

  /// from: public boolean equals(android.icu.text.PluralRules rhs)
  ///
  /// Returns true if rhs is equal to this.
  ///@param rhs the PluralRules to compare to.
  ///@return true if this and rhs are equal.
  bool equals2(PluralRules rhs) => jniAccessors.callMethodWithArgs(
      reference, _id_equals2, jni.JniType.booleanType, [rhs.reference]).boolean;
}

/// from: android.icu.text.PluralRules$PluralType
///
/// Type of plurals and PluralRules.
class PluralRules_PluralType extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/text/PluralRules\$PluralType");
  PluralRules_PluralType.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/icu/text/PluralRules\$PluralType;");

  /// from: static public android.icu.text.PluralRules.PluralType[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/icu/text/PluralRules\$PluralType;");

  /// from: static public android.icu.text.PluralRules.PluralType valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static PluralRules_PluralType valueOf(jni.JniString name) =>
      PluralRules_PluralType.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  PluralRules_PluralType()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
