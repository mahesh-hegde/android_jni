// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../math/BigDecimal.dart" as bigdecimal_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.util.UniversalTimeScale
///
/// There are quite a few different conventions for binary datetime, depending on different
/// platforms and protocols. Some of these have severe drawbacks. For example, people using
/// Unix time (seconds since Jan 1, 1970, usually in a 32-bit integer)
/// think that they are safe until near the year 2038.
/// But cases can and do arise where arithmetic manipulations causes serious problems. Consider
/// the computation of the average of two datetimes, for example: if one calculates them with
/// <code>averageTime = (time1 + time2)/2</code>, there will be overflow even with dates
/// beginning in 2004. Moreover, even if these problems don't occur, there is the issue of
/// conversion back and forth between different systems.
///
/// Binary datetimes differ in a number of ways: the datatype, the unit,
/// and the epoch (origin). We refer to these as time scales.
///
/// ICU implements a universal time scale that is similar to the
/// .NET framework's System.DateTime. The universal time scale is a
/// 64-bit integer that holds ticks since midnight, January 1st, 0001.
/// (One tick is 100 nanoseconds.)
/// Negative values are supported. This has enough range to guarantee that
/// calculations involving dates around the present are safe.
///
/// The universal time scale always measures time according to the
/// proleptic Gregorian calendar. That is, the Gregorian calendar's
/// leap year rules are used for all times, even before 1582 when it was
/// introduced. (This is different from the default ICU calendar which
/// switches from the Julian to the Gregorian calendar in 1582.
/// See GregorianCalendar.setGregorianChange() and ucal_setGregorianChange().)
///
/// ICU provides conversion functions to and from all other major time
/// scales, allowing datetimes in any time scale to be converted to the
/// universal time scale, safely manipulated, and converted back to any other
/// datetime time scale.
///
/// For more details and background, see the
/// <a href="http://www.icu-project.org/userguide/universalTimeScale.html">Universal Time Scale</a>
/// chapter in the ICU User Guide.
class UniversalTimeScale extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/util/UniversalTimeScale");
  UniversalTimeScale.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DB2_TIME
  ///
  /// Used in DB2. Data is a <code>?unknown?</code>. Value
  /// is days since December 31, 1899.
  static const DB2_TIME = 8;

  /// from: static public final int DOTNET_DATE_TIME
  ///
  /// Used in the .NET framework's <code>System.DateTime</code> structure.
  /// Data is a <code>long</code>. Value is ticks (1 tick == 100 nanoseconds) since January 1, 0001.
  static const DOTNET_DATE_TIME = 4;

  /// from: static public final int EPOCH_OFFSET_PLUS_1_VALUE
  ///
  /// The constant used to select the epoch plus one value
  /// for a time scale.
  ///
  /// NOTE: This is an internal value. DO NOT USE IT. May not
  /// actually be equal to the epoch offset value plus one.
  ///@see \#getTimeScaleValue
  static const EPOCH_OFFSET_PLUS_1_VALUE = 6;

  /// from: static public final int EPOCH_OFFSET_VALUE
  ///
  /// The constant used to select the epoch offset value
  /// for a time scale.
  ///@see \#getTimeScaleValue
  static const EPOCH_OFFSET_VALUE = 1;

  /// from: static public final int EXCEL_TIME
  ///
  /// Used in Excel. Data is a <code>?unknown?</code>. Value
  /// is days since December 31, 1899.
  static const EXCEL_TIME = 7;

  /// from: static public final int FROM_MAX_VALUE
  ///
  /// The constant used to select the maximum from value
  /// for a time scale.
  ///@see \#getTimeScaleValue
  static const FROM_MAX_VALUE = 3;

  /// from: static public final int FROM_MIN_VALUE
  ///
  /// The constant used to select the minimum from value
  /// for a time scale.
  ///@see \#getTimeScaleValue
  static const FROM_MIN_VALUE = 2;

  /// from: static public final int ICU4C_TIME
  ///
  /// Used in the ICU4C. Data is a <code>double</code>. Value
  /// is milliseconds since January 1, 1970.
  static const ICU4C_TIME = 2;

  /// from: static public final int JAVA_TIME
  ///
  /// Used in the JDK. Data is a <code>long</code>. Value
  /// is milliseconds since January 1, 1970.
  static const JAVA_TIME = 0;

  /// from: static public final int MAC_OLD_TIME
  ///
  /// Used in older Macintosh systems. Data is an <code>int</code>. Value
  /// is seconds since January 1, 1904.
  static const MAC_OLD_TIME = 5;

  /// from: static public final int MAC_TIME
  ///
  /// Used in the JDK. Data is a <code>double</code>. Value
  /// is milliseconds since January 1, 2001.
  static const MAC_TIME = 6;

  /// from: static public final int MAX_SCALE
  ///
  /// This is the first unused time scale value.
  ///@deprecated ICU 59
  static const MAX_SCALE = 10;

  /// from: static public final int TO_MAX_VALUE
  ///
  /// The constant used to select the maximum to value
  /// for a time scale.
  ///@see \#getTimeScaleValue
  static const TO_MAX_VALUE = 5;

  /// from: static public final int TO_MIN_VALUE
  ///
  /// The constant used to select the minimum to value
  /// for a time scale.
  ///@see \#getTimeScaleValue
  static const TO_MIN_VALUE = 4;

  /// from: static public final int UNITS_VALUE
  ///
  /// The constant used to select the units value
  /// for a time scale.
  static const UNITS_VALUE = 0;

  /// from: static public final int UNIX_MICROSECONDS_TIME
  ///
  /// Data is a <code>long</code>. Value is microseconds since January 1, 1970.
  /// Similar to Unix time (linear value from 1970) and struct timeval
  /// (microseconds resolution).
  static const UNIX_MICROSECONDS_TIME = 9;

  /// from: static public final int UNIX_TIME
  ///
  /// Used in Unix systems. Data is an <code>int</code> or a <code>long</code>. Value
  /// is seconds since January 1, 1970.
  static const UNIX_TIME = 1;

  /// from: static public final int WINDOWS_FILE_TIME
  ///
  /// Used in Windows for file times. Data is a <code>long</code>. Value
  /// is ticks (1 tick == 100 nanoseconds) since January 1, 1601.
  static const WINDOWS_FILE_TIME = 3;

  static final _id_from =
      jniAccessors.getStaticMethodIDOf(_classRef, "from", "(JI)J");

  /// from: static public long from(long otherTime, int timeScale)
  ///
  /// Convert a <code>long</code> datetime from the given time scale to the universal time scale.
  ///@param otherTime The <code>long</code> datetime
  ///@param timeScale The time scale to convert from
  ///@return The datetime converted to the universal time scale
  static int from(int otherTime, int timeScale) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_from,
          jni.JniType.longType, [otherTime, timeScale]).long;

  static final _id_bigDecimalFrom = jniAccessors.getStaticMethodIDOf(
      _classRef, "bigDecimalFrom", "(DI)Landroid/icu/math/BigDecimal;");

  /// from: static public android.icu.math.BigDecimal bigDecimalFrom(double otherTime, int timeScale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convert a <code>double</code> datetime from the given time scale to the universal time scale.
  /// All calculations are done using <code>BigDecimal</code> to guarantee that the value
  /// does not go out of range.
  ///@param otherTime The <code>double</code> datetime
  ///@param timeScale The time scale to convert from
  ///@return The datetime converted to the universal time scale
  static bigdecimal_.BigDecimal bigDecimalFrom(
          double otherTime, int timeScale) =>
      bigdecimal_.BigDecimal.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_bigDecimalFrom,
          jni.JniType.objectType,
          [otherTime, timeScale]).object);

  static final _id_bigDecimalFrom1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "bigDecimalFrom", "(JI)Landroid/icu/math/BigDecimal;");

  /// from: static public android.icu.math.BigDecimal bigDecimalFrom(long otherTime, int timeScale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convert a <code>long</code> datetime from the given time scale to the universal time scale.
  /// All calculations are done using <code>BigDecimal</code> to guarantee that the value
  /// does not go out of range.
  ///@param otherTime The <code>long</code> datetime
  ///@param timeScale The time scale to convert from
  ///@return The datetime converted to the universal time scale
  static bigdecimal_.BigDecimal bigDecimalFrom1(int otherTime, int timeScale) =>
      bigdecimal_.BigDecimal.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_bigDecimalFrom1,
          jni.JniType.objectType,
          [otherTime, timeScale]).object);

  static final _id_bigDecimalFrom2 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "bigDecimalFrom",
      "(Landroid/icu/math/BigDecimal;I)Landroid/icu/math/BigDecimal;");

  /// from: static public android.icu.math.BigDecimal bigDecimalFrom(android.icu.math.BigDecimal otherTime, int timeScale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convert a <code>BigDecimal</code> datetime from the given time scale to the universal time scale.
  /// All calculations are done using <code>BigDecimal</code> to guarantee that the value
  /// does not go out of range.
  ///@param otherTime The <code>BigDecimal</code> datetime
  ///@param timeScale The time scale to convert from
  ///@return The datetime converted to the universal time scale
  static bigdecimal_.BigDecimal bigDecimalFrom2(
          bigdecimal_.BigDecimal otherTime, int timeScale) =>
      bigdecimal_.BigDecimal.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_bigDecimalFrom2,
          jni.JniType.objectType,
          [otherTime.reference, timeScale]).object);

  static final _id_toLong =
      jniAccessors.getStaticMethodIDOf(_classRef, "toLong", "(JI)J");

  /// from: static public long toLong(long universalTime, int timeScale)
  ///
  /// Convert a datetime from the universal time scale stored as a <code>BigDecimal</code> to a
  /// <code>long</code> in the given time scale.
  ///
  /// Since this calculation requires a divide, we must round. The straight forward
  /// way to round by adding half of the divisor will push the sum out of range for values
  /// within have the divisor of the limits of the precision of a <code>long</code>. To get around this, we do
  /// the rounding like this:
  ///
  /// <code>
  /// (universalTime - units + units/2) / units + 1
  /// </code>
  ///
  ///
  /// (i.e. we subtract units first to guarantee that we'll still be in range when we
  /// add <code>units/2</code>. We then need to add one to the quotent to make up for the extra subtraction.
  /// This simplifies to:
  ///
  /// <code>
  /// (universalTime - units/2) / units - 1
  /// </code>
  ///
  ///
  /// For negative values to round away from zero, we need to flip the signs:
  ///
  /// <code>
  /// (universalTime + units/2) / units + 1
  /// </code>
  ///
  ///
  /// Since we also need to subtract the epochOffset, we fold the <code>+/- 1</code>
  /// into the offset value. (i.e. <code>epochOffsetP1</code>, <code>epochOffsetM1</code>.)
  ///@param universalTime The datetime in the universal time scale
  ///@param timeScale The time scale to convert to
  ///@return The datetime converted to the given time scale
  static int toLong(int universalTime, int timeScale) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_toLong,
          jni.JniType.longType, [universalTime, timeScale]).long;

  static final _id_toBigDecimal = jniAccessors.getStaticMethodIDOf(
      _classRef, "toBigDecimal", "(JI)Landroid/icu/math/BigDecimal;");

  /// from: static public android.icu.math.BigDecimal toBigDecimal(long universalTime, int timeScale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convert a datetime from the universal time scale to a <code>BigDecimal</code> in the given time scale.
  ///@param universalTime The datetime in the universal time scale
  ///@param timeScale The time scale to convert to
  ///@return The datetime converted to the given time scale
  static bigdecimal_.BigDecimal toBigDecimal(
          int universalTime, int timeScale) =>
      bigdecimal_.BigDecimal.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_toBigDecimal,
          jni.JniType.objectType,
          [universalTime, timeScale]).object);

  static final _id_toBigDecimal1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "toBigDecimal",
      "(Landroid/icu/math/BigDecimal;I)Landroid/icu/math/BigDecimal;");

  /// from: static public android.icu.math.BigDecimal toBigDecimal(android.icu.math.BigDecimal universalTime, int timeScale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convert a datetime from the universal time scale to a <code>BigDecimal</code> in the given time scale.
  ///@param universalTime The datetime in the universal time scale
  ///@param timeScale The time scale to convert to
  ///@return The datetime converted to the given time scale
  static bigdecimal_.BigDecimal toBigDecimal1(
          bigdecimal_.BigDecimal universalTime, int timeScale) =>
      bigdecimal_.BigDecimal.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_toBigDecimal1,
          jni.JniType.objectType,
          [universalTime.reference, timeScale]).object);

  static final _id_getTimeScaleValue =
      jniAccessors.getStaticMethodIDOf(_classRef, "getTimeScaleValue", "(II)J");

  /// from: static public long getTimeScaleValue(int scale, int value)
  ///
  /// Get a value associated with a particular time scale.
  ///@param scale - the time scale
  ///@param value - a constant representing the value to get
  ///@return - the value.
  static int getTimeScaleValue(int scale, int value) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getTimeScaleValue,
          jni.JniType.longType, [scale, value]).long;
}
