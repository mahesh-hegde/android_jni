// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Calendar.dart" as calendar_;

import "TimeZone.dart" as timezone_;

import "ULocale.dart" as ulocale_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.util.GregorianCalendar
///
/// <strong>[icu enhancement]</strong> ICU's replacement for java.util.GregorianCalendar.&nbsp;Methods, fields, and other functionality specific to ICU are labeled '<strong>[icu]</strong>'.
///
/// <code>GregorianCalendar</code> is a concrete subclass of
/// Calendar
/// and provides the standard calendar used by most of the world.
///
/// The standard (Gregorian) calendar has 2 eras, BC and AD.
///
/// This implementation handles a single discontinuity, which corresponds by
/// default to the date the Gregorian calendar was instituted (October 15, 1582
/// in some countries, later in others).  The cutover date may be changed by the
/// caller by calling <code>setGregorianChange()</code>.
///
/// Historically, in those countries which adopted the Gregorian calendar first,
/// October 4, 1582 was thus followed by October 15, 1582. This calendar models
/// this correctly.  Before the Gregorian cutover, <code>GregorianCalendar</code>
/// implements the Julian calendar.  The only difference between the Gregorian
/// and the Julian calendar is the leap year rule. The Julian calendar specifies
/// leap years every four years, whereas the Gregorian calendar omits century
/// years which are not divisible by 400.
///
/// <code>GregorianCalendar</code> implements _proleptic_ Gregorian and
/// Julian calendars. That is, dates are computed by extrapolating the current
/// rules indefinitely far backward and forward in time. As a result,
/// <code>GregorianCalendar</code> may be used for all years to generate
/// meaningful and consistent results. However, dates obtained using
/// <code>GregorianCalendar</code> are historically accurate only from March 1, 4
/// AD onward, when modern Julian calendar rules were adopted.  Before this date,
/// leap year rules were applied irregularly, and before 45 BC the Julian
/// calendar did not even exist.
///
/// Prior to the institution of the Gregorian calendar, New Year's Day was
/// March 25. To avoid confusion, this calendar always uses January 1. A manual
/// adjustment may be made if desired for dates that are prior to the Gregorian
/// changeover and which fall between January 1 and March 24.
///
/// Values calculated for the <code>WEEK_OF_YEAR</code> field range from 1 to
/// 53.  Week 1 for a year is the earliest seven day period starting on
/// <code>getFirstDayOfWeek()</code> that contains at least
/// <code>getMinimalDaysInFirstWeek()</code> days from that year.  It thus
/// depends on the values of <code>getMinimalDaysInFirstWeek()</code>,
/// <code>getFirstDayOfWeek()</code>, and the day of the week of January 1.
/// Weeks between week 1 of one year and week 1 of the following year are
/// numbered sequentially from 2 to 52 or 53 (as needed).
///
/// For example, January 1, 1998 was a Thursday.  If
/// <code>getFirstDayOfWeek()</code> is <code>MONDAY</code> and
/// <code>getMinimalDaysInFirstWeek()</code> is 4 (these are the values
/// reflecting ISO 8601 and many national standards), then week 1 of 1998 starts
/// on December 29, 1997, and ends on January 4, 1998.  If, however,
/// <code>getFirstDayOfWeek()</code> is <code>SUNDAY</code>, then week 1 of 1998
/// starts on January 4, 1998, and ends on January 10, 1998; the first three days
/// of 1998 then are part of week 53 of 1997.
///
/// Values calculated for the <code>WEEK_OF_MONTH</code> field range from 0 or
/// 1 to 4 or 5.  Week 1 of a month (the days with <code>WEEK_OF_MONTH =
/// 1</code>) is the earliest set of at least
/// <code>getMinimalDaysInFirstWeek()</code> contiguous days in that month,
/// ending on the day before <code>getFirstDayOfWeek()</code>.  Unlike
/// week 1 of a year, week 1 of a month may be shorter than 7 days, need
/// not start on <code>getFirstDayOfWeek()</code>, and will not include days of
/// the previous month.  Days of a month before week 1 have a
/// <code>WEEK_OF_MONTH</code> of 0.
///
/// For example, if <code>getFirstDayOfWeek()</code> is <code>SUNDAY</code>
/// and <code>getMinimalDaysInFirstWeek()</code> is 4, then the first week of
/// January 1998 is Sunday, January 4 through Saturday, January 10.  These days
/// have a <code>WEEK_OF_MONTH</code> of 1.  Thursday, January 1 through
/// Saturday, January 3 have a <code>WEEK_OF_MONTH</code> of 0.  If
/// <code>getMinimalDaysInFirstWeek()</code> is changed to 3, then January 1
/// through January 3 have a <code>WEEK_OF_MONTH</code> of 1.
///
///
/// <strong>Example:</strong>
/// <blockquote>
/// <pre>
/// // get the supported ids for GMT-08:00 (Pacific Standard Time)
/// String[] ids = TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000);
/// // if no ids were returned, something is wrong. get out.
/// if (ids.length == 0)
///     System.exit(0);
///
///  // begin output
/// System.out.println("Current Time");
///
/// // create a Pacific Standard Time time zone
/// SimpleTimeZone pdt = new SimpleTimeZone(-8 * 60 * 60 * 1000, ids[0]);
///
/// // set up rules for daylight savings time
/// pdt.setStartRule(Calendar.MARCH, 2, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
/// pdt.setEndRule(Calendar.NOVEMBER, 1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
///
/// // create a GregorianCalendar with the Pacific Daylight time zone
/// // and the current date and time
/// Calendar calendar = new GregorianCalendar(pdt);
/// Date trialTime = new Date();
/// calendar.setTime(trialTime);
///
/// // print out a bunch of interesting things
/// System.out.println("ERA: " + calendar.get(Calendar.ERA));
/// System.out.println("YEAR: " + calendar.get(Calendar.YEAR));
/// System.out.println("MONTH: " + calendar.get(Calendar.MONTH));
/// System.out.println("WEEK_OF_YEAR: " + calendar.get(Calendar.WEEK_OF_YEAR));
/// System.out.println("WEEK_OF_MONTH: " + calendar.get(Calendar.WEEK_OF_MONTH));
/// System.out.println("DATE: " + calendar.get(Calendar.DATE));
/// System.out.println("DAY_OF_MONTH: " + calendar.get(Calendar.DAY_OF_MONTH));
/// System.out.println("DAY_OF_YEAR: " + calendar.get(Calendar.DAY_OF_YEAR));
/// System.out.println("DAY_OF_WEEK: " + calendar.get(Calendar.DAY_OF_WEEK));
/// System.out.println("DAY_OF_WEEK_IN_MONTH: "
///                    + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
/// System.out.println("AM_PM: " + calendar.get(Calendar.AM_PM));
/// System.out.println("HOUR: " + calendar.get(Calendar.HOUR));
/// System.out.println("HOUR_OF_DAY: " + calendar.get(Calendar.HOUR_OF_DAY));
/// System.out.println("MINUTE: " + calendar.get(Calendar.MINUTE));
/// System.out.println("SECOND: " + calendar.get(Calendar.SECOND));
/// System.out.println("MILLISECOND: " + calendar.get(Calendar.MILLISECOND));
/// System.out.println("ZONE_OFFSET: "
///                    + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000)));
/// System.out.println("DST_OFFSET: "
///                    + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000)));
///
/// System.out.println("Current Time, with hour reset to 3");
/// calendar.clear(Calendar.HOUR_OF_DAY); // so doesn't override
/// calendar.set(Calendar.HOUR, 3);
/// System.out.println("ERA: " + calendar.get(Calendar.ERA));
/// System.out.println("YEAR: " + calendar.get(Calendar.YEAR));
/// System.out.println("MONTH: " + calendar.get(Calendar.MONTH));
/// System.out.println("WEEK_OF_YEAR: " + calendar.get(Calendar.WEEK_OF_YEAR));
/// System.out.println("WEEK_OF_MONTH: " + calendar.get(Calendar.WEEK_OF_MONTH));
/// System.out.println("DATE: " + calendar.get(Calendar.DATE));
/// System.out.println("DAY_OF_MONTH: " + calendar.get(Calendar.DAY_OF_MONTH));
/// System.out.println("DAY_OF_YEAR: " + calendar.get(Calendar.DAY_OF_YEAR));
/// System.out.println("DAY_OF_WEEK: " + calendar.get(Calendar.DAY_OF_WEEK));
/// System.out.println("DAY_OF_WEEK_IN_MONTH: "
///                    + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
/// System.out.println("AM_PM: " + calendar.get(Calendar.AM_PM));
/// System.out.println("HOUR: " + calendar.get(Calendar.HOUR));
/// System.out.println("HOUR_OF_DAY: " + calendar.get(Calendar.HOUR_OF_DAY));
/// System.out.println("MINUTE: " + calendar.get(Calendar.MINUTE));
/// System.out.println("SECOND: " + calendar.get(Calendar.SECOND));
/// System.out.println("MILLISECOND: " + calendar.get(Calendar.MILLISECOND));
/// System.out.println("ZONE_OFFSET: "
///        + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000))); // in hours
/// System.out.println("DST_OFFSET: "
///        + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); // in hours</pre>
/// </blockquote>
///
/// GregorianCalendar usually should be instantiated using
/// android.icu.util.Calendar\#getInstance(ULocale) passing in a <code>ULocale</code>
/// with the tag <code>"@calendar=gregorian"</code>.
///
///@see Calendar
///@see TimeZone
///@author Deborah Goldsmith, Mark Davis, Chen-Lieh Huang, Alan Liu
class GregorianCalendar extends calendar_.Calendar {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/util/GregorianCalendar");
  GregorianCalendar.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int AD
  ///
  /// Value of the <code>ERA</code> field indicating
  /// the common era (Anno Domini), also known as CE.
  /// The sequence of years at the transition from <code>BC</code> to <code>AD</code> is
  /// ..., 2 BC, 1 BC, 1 AD, 2 AD,...
  ///@see Calendar\#ERA
  static const AD = 1;

  /// from: static public final int BC
  ///
  /// Value of the <code>ERA</code> field indicating
  /// the period before the common era (before Christ), also known as BCE.
  /// The sequence of years at the transition from <code>BC</code> to <code>AD</code> is
  /// ..., 2 BC, 1 BC, 1 AD, 2 AD,...
  ///@see Calendar\#ERA
  static const BC = 0;

  static final _id_invertGregorian =
      jniAccessors.getFieldIDOf(_classRef, "invertGregorian", "Z");

  /// from: protected transient boolean invertGregorian
  ///
  /// Used by handleComputeJulianDay() and handleComputeMonthStart().
  bool get invertGregorian => jniAccessors
      .getField(reference, _id_invertGregorian, jni.JniType.booleanType)
      .boolean;

  /// from: protected transient boolean invertGregorian
  ///
  /// Used by handleComputeJulianDay() and handleComputeMonthStart().
  set invertGregorian(bool value) =>
      jniEnv.SetBooleanField(reference, _id_invertGregorian, value ? 1 : 0);

  static final _id_isGregorian =
      jniAccessors.getFieldIDOf(_classRef, "isGregorian", "Z");

  /// from: protected transient boolean isGregorian
  ///
  /// Used by handleComputeJulianDay() and handleComputeMonthStart().
  bool get isGregorian => jniAccessors
      .getField(reference, _id_isGregorian, jni.JniType.booleanType)
      .boolean;

  /// from: protected transient boolean isGregorian
  ///
  /// Used by handleComputeJulianDay() and handleComputeMonthStart().
  set isGregorian(bool value) =>
      jniEnv.SetBooleanField(reference, _id_isGregorian, value ? 1 : 0);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a default GregorianCalendar using the current time
  /// in the default time zone with the default <code>FORMAT</code> locale.
  ///@see Category\#FORMAT
  GregorianCalendar()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/icu/util/TimeZone;)V");

  /// from: public void <init>(android.icu.util.TimeZone zone)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a GregorianCalendar based on the current time
  /// in the given time zone with the default <code>FORMAT</code> locale.
  ///@param zone the given time zone.
  ///@see Category\#FORMAT
  GregorianCalendar.ctor3(timezone_.TimeZone zone)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor3, [zone.reference]).object);

  static final _id_ctor4 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/util/Locale;)V");

  /// from: public void <init>(java.util.Locale aLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a GregorianCalendar based on the current time
  /// in the default time zone with the given locale.
  ///@param aLocale the given locale.
  GregorianCalendar.ctor4(jni.JniObject aLocale)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor4, [aLocale.reference]).object);

  static final _id_ctor5 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/icu/util/ULocale;)V");

  /// from: public void <init>(android.icu.util.ULocale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Constructs a GregorianCalendar based on the current time
  /// in the default time zone with the given locale.
  ///@param locale the given ulocale.
  GregorianCalendar.ctor5(ulocale_.ULocale locale)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor5, [locale.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/icu/util/TimeZone;Ljava/util/Locale;)V");

  /// from: public void <init>(android.icu.util.TimeZone zone, java.util.Locale aLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Constructs a GregorianCalendar based on the current time
  /// in the given time zone with the given locale.
  ///@param zone the given time zone.
  ///@param aLocale the given locale.
  GregorianCalendar.ctor1(timezone_.TimeZone zone, jni.JniObject aLocale)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [zone.reference, aLocale.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/icu/util/TimeZone;Landroid/icu/util/ULocale;)V");

  /// from: public void <init>(android.icu.util.TimeZone zone, android.icu.util.ULocale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a GregorianCalendar based on the current time
  /// in the given time zone with the given locale.
  ///@param zone the given time zone.
  ///@param locale the given ulocale.
  GregorianCalendar.ctor2(timezone_.TimeZone zone, ulocale_.ULocale locale)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [zone.reference, locale.reference]).object);

  static final _id_ctor6 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(III)V");

  /// from: public void <init>(int year, int month, int date)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a GregorianCalendar with the given date set
  /// in the default time zone with the default <code>FORMAT</code> locale.
  ///@param year the value used to set the YEAR time field in the calendar.
  ///@param month the value used to set the MONTH time field in the calendar.
  /// Month value is 0-based. e.g., 0 for January.
  ///@param date the value used to set the DATE time field in the calendar.
  ///@see Category\#FORMAT
  GregorianCalendar.ctor6(int year, int month, int date)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor6, [year, month, date]).object);

  static final _id_ctor7 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(IIIII)V");

  /// from: public void <init>(int year, int month, int date, int hour, int minute)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a GregorianCalendar with the given date
  /// and time set for the default time zone with the default <code>FORMAT</code> locale.
  ///@param year the value used to set the YEAR time field in the calendar.
  ///@param month the value used to set the MONTH time field in the calendar.
  /// Month value is 0-based. e.g., 0 for January.
  ///@param date the value used to set the DATE time field in the calendar.
  ///@param hour the value used to set the HOUR_OF_DAY time field
  /// in the calendar.
  ///@param minute the value used to set the MINUTE time field
  /// in the calendar.
  ///@see Category\#FORMAT
  GregorianCalendar.ctor7(int year, int month, int date, int hour, int minute)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor7, [year, month, date, hour, minute]).object);

  static final _id_ctor8 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(IIIIII)V");

  /// from: public void <init>(int year, int month, int date, int hour, int minute, int second)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a GregorianCalendar with the given date
  /// and time set for the default time zone with the default <code>FORMAT</code> locale.
  ///@param year the value used to set the YEAR time field in the calendar.
  ///@param month the value used to set the MONTH time field in the calendar.
  /// Month value is 0-based. e.g., 0 for January.
  ///@param date the value used to set the DATE time field in the calendar.
  ///@param hour the value used to set the HOUR_OF_DAY time field
  /// in the calendar.
  ///@param minute the value used to set the MINUTE time field
  /// in the calendar.
  ///@param second the value used to set the SECOND time field
  /// in the calendar.
  ///@see Category\#FORMAT
  GregorianCalendar.ctor8(
      int year, int month, int date, int hour, int minute, int second)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor8,
            [year, month, date, hour, minute, second]).object);

  static final _id_handleGetLimit =
      jniAccessors.getMethodIDOf(_classRef, "handleGetLimit", "(II)I");

  /// from: protected int handleGetLimit(int field, int limitType)
  ///
  ///
  int handleGetLimit(int field, int limitType) =>
      jniAccessors.callMethodWithArgs(reference, _id_handleGetLimit,
          jni.JniType.intType, [field, limitType]).integer;

  static final _id_setGregorianChange = jniAccessors.getMethodIDOf(
      _classRef, "setGregorianChange", "(Ljava/util/Date;)V");

  /// from: public void setGregorianChange(java.util.Date date)
  ///
  /// Sets the GregorianCalendar change date. This is the point when the switch
  /// from Julian dates to Gregorian dates occurred. Default is October 15,
  /// 1582. Previous to this, dates will be in the Julian calendar.
  ///
  /// To obtain a pure Julian calendar, set the change date to
  /// <code>Date(Long.MAX_VALUE)</code>.  To obtain a pure Gregorian calendar,
  /// set the change date to <code>Date(Long.MIN_VALUE)</code>.
  ///@param date the given Gregorian cutover date.
  void setGregorianChange(jni.JniObject date) =>
      jniAccessors.callMethodWithArgs(reference, _id_setGregorianChange,
          jni.JniType.voidType, [date.reference]).check();

  static final _id_getGregorianChange = jniAccessors.getMethodIDOf(
      _classRef, "getGregorianChange", "()Ljava/util/Date;");

  /// from: public final java.util.Date getGregorianChange()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the Gregorian Calendar change date.  This is the point when the
  /// switch from Julian dates to Gregorian dates occurred. Default is
  /// October 15, 1582. Previous to this, dates will be in the Julian
  /// calendar.
  ///@return the Gregorian cutover date for this calendar.
  jni.JniObject getGregorianChange() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getGregorianChange, jni.JniType.objectType, []).object);

  static final _id_isLeapYear =
      jniAccessors.getMethodIDOf(_classRef, "isLeapYear", "(I)Z");

  /// from: public boolean isLeapYear(int year)
  ///
  /// Determines if the given year is a leap year. Returns true if the
  /// given year is a leap year.
  ///@param year the given year.
  ///@return true if the given year is a leap year; false otherwise.
  bool isLeapYear(int year) => jniAccessors.callMethodWithArgs(
      reference, _id_isLeapYear, jni.JniType.booleanType, [year]).boolean;

  static final _id_isEquivalentTo = jniAccessors.getMethodIDOf(
      _classRef, "isEquivalentTo", "(Landroid/icu/util/Calendar;)Z");

  /// from: public boolean isEquivalentTo(android.icu.util.Calendar other)
  ///
  /// Returns true if the given Calendar object is equivalent to this
  /// one.  Calendar override.
  ///@param other the Calendar to be compared with this Calendar
  bool isEquivalentTo(calendar_.Calendar other) =>
      jniAccessors.callMethodWithArgs(reference, _id_isEquivalentTo,
          jni.JniType.booleanType, [other.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// Override hashCode.
  /// Generates the hash code for the GregorianCalendar object
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_roll1 =
      jniAccessors.getMethodIDOf(_classRef, "roll", "(II)V");

  /// from: public void roll(int field, int amount)
  ///
  /// Roll a field by a signed amount.
  void roll1(int field, int amount) => jniAccessors.callMethodWithArgs(
      reference, _id_roll1, jni.JniType.voidType, [field, amount]).check();

  static final _id_getActualMinimum =
      jniAccessors.getMethodIDOf(_classRef, "getActualMinimum", "(I)I");

  /// from: public int getActualMinimum(int field)
  ///
  /// Return the minimum value that this field could have, given the current date.
  /// For the Gregorian calendar, this is the same as getMinimum() and getGreatestMinimum().
  int getActualMinimum(int field) => jniAccessors.callMethodWithArgs(
      reference, _id_getActualMinimum, jni.JniType.intType, [field]).integer;

  static final _id_getActualMaximum =
      jniAccessors.getMethodIDOf(_classRef, "getActualMaximum", "(I)I");

  /// from: public int getActualMaximum(int field)
  ///
  /// Return the maximum value that this field could have, given the current date.
  /// For example, with the date "Feb 3, 1997" and the DAY_OF_MONTH field, the actual
  /// maximum would be 28; for "Feb 3, 1996" it s 29.  Similarly for a Hebrew calendar,
  /// for some years the actual maximum for MONTH is 12, and for others 13.
  int getActualMaximum(int field) => jniAccessors.callMethodWithArgs(
      reference, _id_getActualMaximum, jni.JniType.intType, [field]).integer;

  static final _id_handleGetMonthLength =
      jniAccessors.getMethodIDOf(_classRef, "handleGetMonthLength", "(II)I");

  /// from: protected int handleGetMonthLength(int extendedYear, int month)
  ///
  ///
  int handleGetMonthLength(int extendedYear, int month) =>
      jniAccessors.callMethodWithArgs(reference, _id_handleGetMonthLength,
          jni.JniType.intType, [extendedYear, month]).integer;

  static final _id_handleGetYearLength =
      jniAccessors.getMethodIDOf(_classRef, "handleGetYearLength", "(I)I");

  /// from: protected int handleGetYearLength(int eyear)
  ///
  ///
  int handleGetYearLength(int eyear) => jniAccessors.callMethodWithArgs(
      reference, _id_handleGetYearLength, jni.JniType.intType, [eyear]).integer;

  static final _id_handleComputeFields =
      jniAccessors.getMethodIDOf(_classRef, "handleComputeFields", "(I)V");

  /// from: protected void handleComputeFields(int julianDay)
  ///
  /// Override Calendar to compute several fields specific to the hybrid
  /// Gregorian-Julian calendar system.  These are:
  ///
  /// <ul><li>ERA
  /// <li>YEAR
  /// <li>MONTH
  /// <li>DAY_OF_MONTH
  /// <li>DAY_OF_YEAR
  /// <li>EXTENDED_YEAR</ul>
  void handleComputeFields(int julianDay) => jniAccessors.callMethodWithArgs(
      reference,
      _id_handleComputeFields,
      jni.JniType.voidType,
      [julianDay]).check();

  static final _id_handleGetExtendedYear =
      jniAccessors.getMethodIDOf(_classRef, "handleGetExtendedYear", "()I");

  /// from: protected int handleGetExtendedYear()
  ///
  ///
  int handleGetExtendedYear() => jniAccessors.callMethodWithArgs(
      reference, _id_handleGetExtendedYear, jni.JniType.intType, []).integer;

  static final _id_handleComputeJulianDay =
      jniAccessors.getMethodIDOf(_classRef, "handleComputeJulianDay", "(I)I");

  /// from: protected int handleComputeJulianDay(int bestField)
  ///
  ///
  int handleComputeJulianDay(int bestField) => jniAccessors.callMethodWithArgs(
      reference,
      _id_handleComputeJulianDay,
      jni.JniType.intType,
      [bestField]).integer;

  static final _id_handleComputeMonthStart = jniAccessors.getMethodIDOf(
      _classRef, "handleComputeMonthStart", "(IIZ)I");

  /// from: protected int handleComputeMonthStart(int eyear, int month, boolean useMonth)
  ///
  /// Return JD of start of given month/year
  int handleComputeMonthStart(int eyear, int month, bool useMonth) =>
      jniAccessors.callMethodWithArgs(reference, _id_handleComputeMonthStart,
          jni.JniType.intType, [eyear, month, useMonth]).integer;

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "()Ljava/lang/String;");

  /// from: public java.lang.String getType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniString getType() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getType, jni.JniType.objectType, []).object);
}
