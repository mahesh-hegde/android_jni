// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "ULocale.dart" as ulocale_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.util.TimeZone
///
/// <strong>[icu enhancement]</strong> ICU's replacement for java.util.TimeZone.&nbsp;Methods, fields, and other functionality specific to ICU are labeled '<strong>[icu]</strong>'.
///
/// <code>TimeZone</code> represents a time zone offset, and also computes daylight
/// savings.
///
/// Typically, you get a <code>TimeZone</code> using \#getDefault()
/// which creates a <code>TimeZone</code> based on the time zone where the program
/// is running. For example, for a program running in Japan, <code>getDefault</code>
/// creates a <code>TimeZone</code> object based on Japanese Standard Time.
///
/// You can also get a <code>TimeZone</code> using \#getTimeZone(String)
/// along with a time zone ID. For instance, the time zone ID for the
/// U.S. Pacific Time zone is "America/Los_Angeles". So, you can get a
/// U.S. Pacific Time <code>TimeZone</code> object with:
///
/// <blockquote>
/// <pre>
/// TimeZone tz = TimeZone.getTimeZone("America/Los_Angeles");
/// </pre>
/// </blockquote>
/// You can use the \#getAvailableIDs() method to iterate through
/// all the supported time zone IDs, or getCanonicalID method to check
/// if a time zone ID is supported or not. You can then choose a
/// supported ID to get a <code>TimeZone</code>.
/// If the time zone you want is not represented by one of the
/// supported IDs, then you can create a custom time zone ID with
/// the following syntax:
///
/// <blockquote>
/// <pre>
/// GMT[+|-]hh[[:]mm]
/// </pre>
/// </blockquote>
///
/// For example, you might specify GMT+14:00 as a custom
/// time zone ID.  The <code>TimeZone</code> that is returned
/// when you specify a custom time zone ID uses the specified
/// offset from GMT(=UTC) and does not observe daylight saving
/// time. For example, you might specify GMT+14:00 as a custom
/// time zone ID to create a TimeZone representing 14 hours ahead
/// of GMT (with no daylight saving time). In addition,
/// <code>getCanonicalID</code> can also be used to
/// normalize a custom time zone ID.
///
/// For compatibility with JDK 1.1.x, some other three-letter time zone IDs
/// (such as "PST", "CTT", "AST") are also supported. However, <strong>their
/// use is deprecated</strong> because the same abbreviation is often used
/// for multiple time zones (for example, "CST" could be U.S. "Central Standard
/// Time" and "China Standard Time"), and the Java platform can then only
/// recognize one of them.
///@see Calendar
///@see GregorianCalendar
///@see SimpleTimeZone
///@author Mark Davis, Deborah Goldsmith, Chen-Lieh Huang, Alan Liu
class TimeZone extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/icu/util/TimeZone");
  TimeZone.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int GENERIC_LOCATION
  ///
  /// <strong>[icu]</strong> A style specifier for <code>getDisplayName()</code> indicating
  /// a long name derived from the timezone's fallback name, such as
  /// "United States (Los Angeles)."
  static const GENERIC_LOCATION = 7;

  static final _id_GMT_ZONE = jniAccessors.getStaticFieldIDOf(
      _classRef, "GMT_ZONE", "Landroid/icu/util/TimeZone;");

  /// from: static public final android.icu.util.TimeZone GMT_ZONE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> The immutable GMT (=UTC) time zone. Its ID is "Etc/GMT".
  static TimeZone get GMT_ZONE => TimeZone.fromRef(jniAccessors
      .getStaticField(_classRef, _id_GMT_ZONE, jni.JniType.objectType)
      .object);

  /// from: static public final int LONG
  ///
  /// A style specifier for <code>getDisplayName()</code> indicating
  /// a long name, such as "Pacific Standard Time."
  ///@see \#SHORT
  static const LONG = 1;

  /// from: static public final int LONG_GENERIC
  ///
  /// <strong>[icu]</strong> A style specifier for <code>getDisplayName()</code> indicating
  /// a long generic name, such as "Pacific Time."
  ///@see \#SHORT_GENERIC
  static const LONG_GENERIC = 3;

  /// from: static public final int LONG_GMT
  ///
  /// <strong>[icu]</strong> A style specifier for <code>getDisplayName()</code> indicating
  /// a long name derived from the timezone's offset, such as "GMT-08:00."
  ///@see \#SHORT_GMT
  static const LONG_GMT = 5;

  /// from: static public final int SHORT
  ///
  /// A style specifier for <code>getDisplayName()</code> indicating
  /// a short name, such as "PST."
  ///@see \#LONG
  static const SHORT = 0;

  /// from: static public final int SHORT_COMMONLY_USED
  ///
  /// <strong>[icu]</strong> A style specifier for <code>getDisplayName()</code> indicating
  /// a short name derived from the timezone's short standard or daylight
  /// timezone name ignoring commonlyUsed, such as "PDT."
  static const SHORT_COMMONLY_USED = 6;

  /// from: static public final int SHORT_GENERIC
  ///
  /// <strong>[icu]</strong> A style specifier for <code>getDisplayName()</code> indicating
  /// a short generic name, such as "PT."
  ///@see \#LONG_GENERIC
  static const SHORT_GENERIC = 2;

  /// from: static public final int SHORT_GMT
  ///
  /// <strong>[icu]</strong> A style specifier for <code>getDisplayName()</code> indicating
  /// a short name derived from the timezone's offset, such as "-0800."
  ///@see \#LONG_GMT
  static const SHORT_GMT = 4;

  /// from: static public final int TIMEZONE_ICU
  ///
  /// <strong>[icu]</strong> A time zone implementation type indicating ICU's own TimeZone used by
  /// <code>getTimeZone</code>.
  static const TIMEZONE_ICU = 0;

  /// from: static public final int TIMEZONE_JDK
  ///
  /// <strong>[icu]</strong> A time zone implementation type indicating the java.util.TimeZone
  /// used by <code>getTimeZone</code>.
  static const TIMEZONE_JDK = 1;

  static final _id_UNKNOWN_ZONE = jniAccessors.getStaticFieldIDOf(
      _classRef, "UNKNOWN_ZONE", "Landroid/icu/util/TimeZone;");

  /// from: static public final android.icu.util.TimeZone UNKNOWN_ZONE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> The immutable (frozen) "unknown" time zone.
  /// It behaves like the GMT/UTC time zone but has the UNKNOWN_ZONE_ID = "Etc/Unknown".
  /// TimeZone\#getTimeZone(String) returns a mutable clone of this
  /// time zone if the input ID is not recognized.
  ///@see \#UNKNOWN_ZONE_ID
  ///@see \#getTimeZone(String)
  static TimeZone get UNKNOWN_ZONE => TimeZone.fromRef(jniAccessors
      .getStaticField(_classRef, _id_UNKNOWN_ZONE, jni.JniType.objectType)
      .object);

  /// from: static public final java.lang.String UNKNOWN_ZONE_ID
  ///
  /// <strong>[icu]</strong> The time zone ID reserved for unknown time zone.
  ///@see \#getTimeZone(String)
  static const UNKNOWN_ZONE_ID = "Etc/Unknown";

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Default constructor.  (For invocation by subclass constructors,
  /// typically implicit.)
  TimeZone()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getOffset =
      jniAccessors.getMethodIDOf(_classRef, "getOffset", "(IIIIII)I");

  /// from: public abstract int getOffset(int era, int year, int month, int day, int dayOfWeek, int milliseconds)
  ///
  /// Gets the time zone offset, for current date, modified in case of
  /// daylight savings. This is the offset to add *to* UTC to get local time.
  ///@param era the era of the given date.
  ///@param year the year in the given date.
  ///@param month the month in the given date.
  /// Month is 0-based. e.g., 0 for January.
  ///@param day the day-in-month of the given date.
  ///@param dayOfWeek the day-of-week of the given date.
  ///@param milliseconds the millis in day in _standard_ local time.
  ///@return the offset to add *to* GMT to get local time.
  int getOffset(int era, int year, int month, int day, int dayOfWeek,
          int milliseconds) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getOffset,
          jni.JniType.intType,
          [era, year, month, day, dayOfWeek, milliseconds]).integer;

  static final _id_getOffset1 =
      jniAccessors.getMethodIDOf(_classRef, "getOffset", "(J)I");

  /// from: public int getOffset(long date)
  ///
  /// Returns the offset of this time zone from UTC at the specified
  /// date. If Daylight Saving Time is in effect at the specified
  /// date, the offset value is adjusted with the amount of daylight
  /// saving.
  ///@param date the date represented in milliseconds since January 1, 1970 00:00:00 GMT
  ///@return the amount of time in milliseconds to add to UTC to get local time.
  ///@see Calendar\#ZONE_OFFSET
  ///@see Calendar\#DST_OFFSET
  ///@see \#getOffset(long, boolean, int[])
  int getOffset1(int date) => jniAccessors.callMethodWithArgs(
      reference, _id_getOffset1, jni.JniType.intType, [date]).integer;

  static final _id_getOffset2 =
      jniAccessors.getMethodIDOf(_classRef, "getOffset", "(JZ[I)V");

  /// from: public void getOffset(long date, boolean local, int[] offsets)
  ///
  /// Returns the time zone raw and GMT offset for the given moment
  /// in time.  Upon return, local-millis = GMT-millis + rawOffset +
  /// dstOffset.  All computations are performed in the proleptic
  /// Gregorian calendar.  The default implementation in the TimeZone
  /// class delegates to the 8-argument getOffset().
  ///@param date moment in time for which to return offsets, in
  /// units of milliseconds from January 1, 1970 0:00 GMT, either GMT
  /// time or local wall time, depending on `local'.
  ///@param local if true, `date' is local wall time; otherwise it
  /// is in GMT time.
  ///@param offsets output parameter to receive the raw offset, that
  /// is, the offset not including DST adjustments, in offsets[0],
  /// and the DST offset, that is, the offset to be added to
  /// `rawOffset' to obtain the total offset between local and GMT
  /// time, in offsets[1]. If DST is not in effect, the DST offset is
  /// zero; otherwise it is a positive value, typically one hour.
  void getOffset2(int date, bool local, jni.JniObject offsets) =>
      jniAccessors.callMethodWithArgs(reference, _id_getOffset2,
          jni.JniType.voidType, [date, local, offsets.reference]).check();

  static final _id_setRawOffset =
      jniAccessors.getMethodIDOf(_classRef, "setRawOffset", "(I)V");

  /// from: public abstract void setRawOffset(int offsetMillis)
  ///
  /// Sets the base time zone offset to GMT.
  /// This is the offset to add *to* UTC to get local time.
  ///@param offsetMillis the given base time zone offset to GMT.
  void setRawOffset(int offsetMillis) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setRawOffset,
      jni.JniType.voidType,
      [offsetMillis]).check();

  static final _id_getRawOffset =
      jniAccessors.getMethodIDOf(_classRef, "getRawOffset", "()I");

  /// from: public abstract int getRawOffset()
  ///
  /// Gets unmodified offset, NOT modified in case of daylight savings.
  /// This is the offset to add *to* UTC to get local time.
  ///@return the unmodified offset to add *to* UTC to get local time.
  int getRawOffset() => jniAccessors.callMethodWithArgs(
      reference, _id_getRawOffset, jni.JniType.intType, []).integer;

  static final _id_getID =
      jniAccessors.getMethodIDOf(_classRef, "getID", "()Ljava/lang/String;");

  /// from: public java.lang.String getID()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the ID of this time zone.
  ///@return the ID of this time zone.
  jni.JniString getID() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getID, jni.JniType.objectType, []).object);

  static final _id_setID =
      jniAccessors.getMethodIDOf(_classRef, "setID", "(Ljava/lang/String;)V");

  /// from: public void setID(java.lang.String ID)
  ///
  /// Sets the time zone ID. This does not change any other data in
  /// the time zone object.
  ///@param ID the new time zone ID.
  void setID(jni.JniString ID) => jniAccessors.callMethodWithArgs(
      reference, _id_setID, jni.JniType.voidType, [ID.reference]).check();

  static final _id_getDisplayName = jniAccessors.getMethodIDOf(
      _classRef, "getDisplayName", "()Ljava/lang/String;");

  /// from: public final java.lang.String getDisplayName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a name of this time zone suitable for presentation to the user
  /// in the default <code>DISPLAY</code> locale.
  /// This method returns the long generic name.
  /// If the display name is not available for the locale,
  /// a fallback based on the country, city, or time zone id will be used.
  ///@return the human-readable name of this time zone in the default locale.
  ///@see Category\#DISPLAY
  jni.JniString getDisplayName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDisplayName, jni.JniType.objectType, []).object);

  static final _id_getDisplayName1 = jniAccessors.getMethodIDOf(
      _classRef, "getDisplayName", "(Ljava/util/Locale;)Ljava/lang/String;");

  /// from: public final java.lang.String getDisplayName(java.util.Locale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a name of this time zone suitable for presentation to the user
  /// in the specified locale.
  /// This method returns the long generic name.
  /// If the display name is not available for the locale,
  /// a fallback based on the country, city, or time zone id will be used.
  ///@param locale the locale in which to supply the display name.
  ///@return the human-readable name of this time zone in the given locale
  /// or in the default locale if the given locale is not recognized.
  jni.JniString getDisplayName1(jni.JniObject locale) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDisplayName1,
          jni.JniType.objectType,
          [locale.reference]).object);

  static final _id_getDisplayName2 = jniAccessors.getMethodIDOf(_classRef,
      "getDisplayName", "(Landroid/icu/util/ULocale;)Ljava/lang/String;");

  /// from: public final java.lang.String getDisplayName(android.icu.util.ULocale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a name of this time zone suitable for presentation to the user
  /// in the specified locale.
  /// This method returns the long name, not including daylight savings.
  /// If the display name is not available for the locale,
  /// a fallback based on the country, city, or time zone id will be used.
  ///@param locale the ulocale in which to supply the display name.
  ///@return the human-readable name of this time zone in the given locale
  /// or in the default ulocale if the given ulocale is not recognized.
  jni.JniString getDisplayName2(ulocale_.ULocale locale) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDisplayName2,
          jni.JniType.objectType,
          [locale.reference]).object);

  static final _id_getDisplayName3 = jniAccessors.getMethodIDOf(
      _classRef, "getDisplayName", "(ZI)Ljava/lang/String;");

  /// from: public final java.lang.String getDisplayName(boolean daylight, int style)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a name of this time zone suitable for presentation to the user
  /// in the default <code>DISPLAY</code> locale.
  /// If the display name is not available for the locale,
  /// then this method returns a string in the localized GMT offset format
  /// such as <code>GMT[+-]HH:mm</code>.
  ///@param daylight if true, return the daylight savings name.
  ///@param style the output style of the display name.  Valid styles are
  /// <code>SHORT</code>, <code>LONG</code>, <code>SHORT_GENERIC</code>,
  /// <code>LONG_GENERIC</code>, <code>SHORT_GMT</code>, <code>LONG_GMT</code>,
  /// <code>SHORT_COMMONLY_USED</code> or <code>GENERIC_LOCATION</code>.
  ///@return the human-readable name of this time zone in the default locale.
  ///@see Category\#DISPLAY
  jni.JniString getDisplayName3(bool daylight, int style) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDisplayName3,
          jni.JniType.objectType,
          [daylight, style]).object);

  static final _id_getDisplayName4 = jniAccessors.getMethodIDOf(
      _classRef, "getDisplayName", "(ZILjava/util/Locale;)Ljava/lang/String;");

  /// from: public java.lang.String getDisplayName(boolean daylight, int style, java.util.Locale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a name of this time zone suitable for presentation to the user
  /// in the specified locale.
  /// If the display name is not available for the locale,
  /// then this method returns a string in the localized GMT offset format
  /// such as <code>GMT[+-]HH:mm</code>.
  ///@param daylight if true, return the daylight savings name.
  ///@param style the output style of the display name.  Valid styles are
  /// <code>SHORT</code>, <code>LONG</code>, <code>SHORT_GENERIC</code>,
  /// <code>LONG_GENERIC</code>, <code>SHORT_GMT</code>, <code>LONG_GMT</code>,
  /// <code>SHORT_COMMONLY_USED</code> or <code>GENERIC_LOCATION</code>.
  ///@param locale the locale in which to supply the display name.
  ///@return the human-readable name of this time zone in the given locale
  /// or in the default locale if the given locale is not recognized.
  ///@exception IllegalArgumentException style is invalid.
  jni.JniString getDisplayName4(
          bool daylight, int style, jni.JniObject locale) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDisplayName4,
          jni.JniType.objectType,
          [daylight, style, locale.reference]).object);

  static final _id_getDisplayName5 = jniAccessors.getMethodIDOf(_classRef,
      "getDisplayName", "(ZILandroid/icu/util/ULocale;)Ljava/lang/String;");

  /// from: public java.lang.String getDisplayName(boolean daylight, int style, android.icu.util.ULocale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a name of this time zone suitable for presentation to the user
  /// in the specified locale.
  /// If the display name is not available for the locale,
  /// then this method returns a string in the localized GMT offset format
  /// such as <code>GMT[+-]HH:mm</code>.
  ///@param daylight if true, return the daylight savings name.
  ///@param style the output style of the display name.  Valid styles are
  /// <code>SHORT</code>, <code>LONG</code>, <code>SHORT_GENERIC</code>,
  /// <code>LONG_GENERIC</code>, <code>SHORT_GMT</code>, <code>LONG_GMT</code>,
  /// <code>SHORT_COMMONLY_USED</code> or <code>GENERIC_LOCATION</code>.
  ///@param locale the locale in which to supply the display name.
  ///@return the human-readable name of this time zone in the given locale
  /// or in the default locale if the given locale is not recognized.
  ///@exception IllegalArgumentException style is invalid.
  jni.JniString getDisplayName5(
          bool daylight, int style, ulocale_.ULocale locale) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDisplayName5,
          jni.JniType.objectType,
          [daylight, style, locale.reference]).object);

  static final _id_getDSTSavings =
      jniAccessors.getMethodIDOf(_classRef, "getDSTSavings", "()I");

  /// from: public int getDSTSavings()
  ///
  /// Returns the amount of time to be added to local standard time
  /// to get local wall clock time.
  ///
  /// The default implementation always returns 3600000 milliseconds
  /// (i.e., one hour) if this time zone observes Daylight Saving
  /// Time. Otherwise, 0 (zero) is returned.
  ///
  /// If an underlying TimeZone implementation subclass supports
  /// historical Daylight Saving Time changes, this method returns
  /// the known latest daylight saving value.
  ///@return the amount of saving time in milliseconds
  int getDSTSavings() => jniAccessors.callMethodWithArgs(
      reference, _id_getDSTSavings, jni.JniType.intType, []).integer;

  static final _id_useDaylightTime =
      jniAccessors.getMethodIDOf(_classRef, "useDaylightTime", "()Z");

  /// from: public abstract boolean useDaylightTime()
  ///
  /// Queries if this time zone uses daylight savings time.
  ///@return true if this time zone uses daylight savings time,
  /// false, otherwise.
  /// <strong>Note:</strong>The default implementation of
  /// ICU TimeZone uses the tz database, which supports historic
  /// rule changes, for system time zones. With the implementation,
  /// there are time zones that used daylight savings time in the
  /// past, but no longer used currently. For example, Asia/Tokyo has
  /// never used daylight savings time since 1951. Most clients would
  /// expect that this method to return <code>false</code> for such case.
  /// The default implementation of this method returns <code>true</code>
  /// when the time zone uses daylight savings time in the current
  /// (Gregorian) calendar year.
  bool useDaylightTime() => jniAccessors.callMethodWithArgs(
      reference, _id_useDaylightTime, jni.JniType.booleanType, []).boolean;

  static final _id_observesDaylightTime =
      jniAccessors.getMethodIDOf(_classRef, "observesDaylightTime", "()Z");

  /// from: public boolean observesDaylightTime()
  ///
  /// Queries if this time zone is in daylight saving time or will observe
  /// daylight saving time at any future time.
  /// The default implementation in this class returns <code>true</code> if \#useDaylightTime()
  /// or \#inDaylightTime(Date) inDaylightTime(new Date()) returns <code>true</code>.
  ///
  /// <strong>Note:</strong> This method was added for java.util.TimeZone compatibility
  /// support. The java.util.TimeZone\#useDaylightTime() method only checks the last known
  /// rule(s), therefore it may return false even the zone observes daylight saving time currently.
  /// java.util.TimeZone added <code>observesDaylightTime()</code> to resolve the issue.
  /// In ICU, \#useDaylightTime() works differently. The ICU implementation checks if the
  /// zone uses daylight saving time in the current calendar year. Therefore, it will never return
  /// <code>false</code> if daylight saving time is currently used.
  ///
  /// ICU's TimeZone subclass implementations override this method to support the same behavior
  /// with java.util.TimeZone\#observesDaylightTime(). Unlike \#useDaylightTime(),
  /// the implementation does not take past daylight saving time into account, so
  /// that this method may return <code>false</code> even when \#useDaylightTime() returns
  /// <code>true</code>.
  ///@return <code>true</code> if this time zone is in daylight saving time or will observe
  /// daylight saving time at any future time.
  ///@see \#useDaylightTime
  bool observesDaylightTime() => jniAccessors.callMethodWithArgs(
      reference, _id_observesDaylightTime, jni.JniType.booleanType, []).boolean;

  static final _id_inDaylightTime = jniAccessors.getMethodIDOf(
      _classRef, "inDaylightTime", "(Ljava/util/Date;)Z");

  /// from: public abstract boolean inDaylightTime(java.util.Date date)
  ///
  /// Queries if the given date is in daylight savings time in
  /// this time zone.
  ///@param date the given Date.
  ///@return true if the given date is in daylight savings time,
  /// false, otherwise.
  bool inDaylightTime(jni.JniObject date) => jniAccessors.callMethodWithArgs(
      reference,
      _id_inDaylightTime,
      jni.JniType.booleanType,
      [date.reference]).boolean;

  static final _id_getTimeZone = jniAccessors.getStaticMethodIDOf(_classRef,
      "getTimeZone", "(Ljava/lang/String;)Landroid/icu/util/TimeZone;");

  /// from: static public android.icu.util.TimeZone getTimeZone(java.lang.String ID)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the <code>TimeZone</code> for the given ID.
  ///@param ID the ID for a <code>TimeZone</code>, such as "America/Los_Angeles",
  /// or a custom ID such as "GMT-8:00". Note that the support of abbreviations,
  /// such as "PST", is for JDK 1.1.x compatibility only and full names should be used.
  ///@return the specified <code>TimeZone</code>, or a mutable clone of the UNKNOWN_ZONE
  /// if the given ID cannot be understood or if the given ID is "Etc/Unknown".
  ///@see \#UNKNOWN_ZONE
  static TimeZone getTimeZone(jni.JniString ID) =>
      TimeZone.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getTimeZone, jni.JniType.objectType, [ID.reference]).object);

  static final _id_getFrozenTimeZone = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getFrozenTimeZone",
      "(Ljava/lang/String;)Landroid/icu/util/TimeZone;");

  /// from: static public android.icu.util.TimeZone getFrozenTimeZone(java.lang.String ID)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the <code>TimeZone</code> for the given ID. The instance of <code>TimeZone</code>
  /// returned by this method is immutable. Any methods mutate the instance(\#setID(String),
  /// \#setRawOffset(int)) will throw <code>UnsupportedOperationException</code> upon its
  /// invocation.
  ///@param ID the ID for a <code>TimeZone</code>, such as "America/Los_Angeles",
  /// or a custom ID such as "GMT-8:00". Note that the support of abbreviations,
  /// such as "PST", is for JDK 1.1.x compatibility only and full names should be used.
  ///@return the specified <code>TimeZone</code>, or the UNKNOWN_ZONE
  /// if the given ID cannot be understood.
  ///@see \#UNKNOWN_ZONE
  static TimeZone getFrozenTimeZone(jni.JniString ID) =>
      TimeZone.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getFrozenTimeZone,
          jni.JniType.objectType,
          [ID.reference]).object);

  static final _id_getTimeZone1 = jniAccessors.getStaticMethodIDOf(_classRef,
      "getTimeZone", "(Ljava/lang/String;I)Landroid/icu/util/TimeZone;");

  /// from: static public android.icu.util.TimeZone getTimeZone(java.lang.String ID, int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the <code>TimeZone</code> for the given ID and the timezone type.
  ///@param ID the ID for a <code>TimeZone</code>, such as "America/Los_Angeles", or a
  /// custom ID such as "GMT-8:00". Note that the support of abbreviations, such as
  /// "PST", is for JDK 1.1.x compatibility only and full names should be used.
  ///@param type Time zone type, either <code>TIMEZONE_ICU</code> or
  /// <code>TIMEZONE_JDK</code>.
  ///@return the specified <code>TimeZone</code>, or a mutable clone of the UNKNOWN_ZONE if the given ID
  /// cannot be understood or if the given ID is "Etc/Unknown".
  ///@see \#UNKNOWN_ZONE
  static TimeZone getTimeZone1(jni.JniString ID, int type) =>
      TimeZone.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getTimeZone1,
          jni.JniType.objectType,
          [ID.reference, type]).object);

  static final _id_getAvailableIDs = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getAvailableIDs",
      "(Landroid/icu/util/TimeZone\$SystemTimeZoneType;Ljava/lang/String;Ljava/lang/Integer;)Ljava/util/Set;");

  /// from: static public java.util.Set<java.lang.String> getAvailableIDs(android.icu.util.TimeZone.SystemTimeZoneType zoneType, java.lang.String region, java.lang.Integer rawOffset)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns a set of time zone ID strings with the given filter conditions.
  /// __Note:__A <code>Set</code> returned by this method is
  /// immutable.
  ///@param zoneType The system time zone type.
  ///@param region The ISO 3166 two-letter country code or UN M.49 three-digit area code.
  ///                      When null, no filtering done by region.
  ///@param rawOffset An offset from GMT in milliseconds, ignoring the effect of daylight savings
  ///                      time, if any. When null, no filtering done by zone offset.
  ///@return an immutable set of system time zone IDs.
  ///@see SystemTimeZoneType
  static jni.JniObject getAvailableIDs(TimeZone_SystemTimeZoneType zoneType,
          jni.JniString region, jni.JniObject rawOffset) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getAvailableIDs,
          jni.JniType.objectType,
          [zoneType.reference, region.reference, rawOffset.reference]).object);

  static final _id_getAvailableIDs1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "getAvailableIDs", "(I)[Ljava/lang/String;");

  /// from: static public java.lang.String[] getAvailableIDs(int rawOffset)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new String array containing all system TimeZone IDs
  /// with the given raw offset from GMT.  These IDs may be passed to
  /// <code>get()</code> to construct the corresponding TimeZone
  /// object.
  ///@param rawOffset the offset in milliseconds from GMT
  ///@return an array of IDs for system TimeZones with the given
  /// raw offset.  If there are none, return a zero-length array.
  ///@see \#getAvailableIDs(SystemTimeZoneType, String, Integer)
  static jni.JniObject getAvailableIDs1(int rawOffset) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getAvailableIDs1, jni.JniType.objectType, [rawOffset]).object);

  static final _id_getAvailableIDs2 = jniAccessors.getStaticMethodIDOf(
      _classRef, "getAvailableIDs", "(Ljava/lang/String;)[Ljava/lang/String;");

  /// from: static public java.lang.String[] getAvailableIDs(java.lang.String country)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new String array containing all system TimeZone IDs
  /// associated with the given country.  These IDs may be passed to
  /// <code>get()</code> to construct the corresponding TimeZone
  /// object.
  ///@param country a two-letter ISO 3166 country code, or <code>null</code>
  /// to return zones not associated with any country
  ///@return an array of IDs for system TimeZones in the given
  /// country.  If there are none, return a zero-length array.
  ///@see \#getAvailableIDs(SystemTimeZoneType, String, Integer)
  static jni.JniObject getAvailableIDs2(jni.JniString country) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getAvailableIDs2,
          jni.JniType.objectType,
          [country.reference]).object);

  static final _id_getAvailableIDs3 = jniAccessors.getStaticMethodIDOf(
      _classRef, "getAvailableIDs", "()[Ljava/lang/String;");

  /// from: static public java.lang.String[] getAvailableIDs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new String array containing all system TimeZone IDs.
  /// These IDs (and only these IDs) may be passed to
  /// <code>get()</code> to construct the corresponding TimeZone
  /// object.
  ///@return an array of all system TimeZone IDs
  ///@see \#getAvailableIDs(SystemTimeZoneType, String, Integer)
  static jni.JniObject getAvailableIDs3() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getAvailableIDs3, jni.JniType.objectType, []).object);

  static final _id_countEquivalentIDs = jniAccessors.getStaticMethodIDOf(
      _classRef, "countEquivalentIDs", "(Ljava/lang/String;)I");

  /// from: static public int countEquivalentIDs(java.lang.String id)
  ///
  /// <strong>[icu]</strong> Returns the number of IDs in the equivalency group that
  /// includes the given ID.  An equivalency group contains zones
  /// that have the same GMT offset and rules.
  ///
  /// The returned count includes the given ID; it is always &gt;= 1
  /// for valid IDs.  The given ID must be a system time zone.  If it
  /// is not, returns zero.
  ///@param id a system time zone ID
  ///@return the number of zones in the equivalency group containing
  /// 'id', or zero if 'id' is not a valid system ID
  ///@see \#getEquivalentID
  static int countEquivalentIDs(jni.JniString id) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_countEquivalentIDs,
          jni.JniType.intType, [id.reference]).integer;

  static final _id_getEquivalentID = jniAccessors.getStaticMethodIDOf(
      _classRef, "getEquivalentID", "(Ljava/lang/String;I)Ljava/lang/String;");

  /// from: static public java.lang.String getEquivalentID(java.lang.String id, int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an ID in the equivalency group that
  /// includes the given ID.  An equivalency group contains zones
  /// that have the same GMT offset and rules.
  ///
  /// The given index must be in the range 0..n-1, where n is the
  /// value returned by <code>countEquivalentIDs(id)</code>.  For
  /// some value of 'index', the returned value will be equal to the
  /// given id.  If the given id is not a valid system time zone, or
  /// if 'index' is out of range, then returns an empty string.
  ///@param id a system time zone ID
  ///@param index a value from 0 to n-1, where n is the value
  /// returned by <code>countEquivalentIDs(id)</code>
  ///@return the ID of the index-th zone in the equivalency group
  /// containing 'id', or an empty string if 'id' is not a valid
  /// system ID or 'index' is out of range
  ///@see \#countEquivalentIDs
  static jni.JniString getEquivalentID(jni.JniString id, int index) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getEquivalentID,
          jni.JniType.objectType,
          [id.reference, index]).object);

  static final _id_getDefault = jniAccessors.getStaticMethodIDOf(
      _classRef, "getDefault", "()Landroid/icu/util/TimeZone;");

  /// from: static public android.icu.util.TimeZone getDefault()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the default <code>TimeZone</code> for this host.
  /// The source of the default <code>TimeZone</code>
  /// may vary with implementation.
  ///@return a default <code>TimeZone</code>.
  static TimeZone getDefault() =>
      TimeZone.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getDefault, jni.JniType.objectType, []).object);

  static final _id_hasSameRules = jniAccessors.getMethodIDOf(
      _classRef, "hasSameRules", "(Landroid/icu/util/TimeZone;)Z");

  /// from: public boolean hasSameRules(android.icu.util.TimeZone other)
  ///
  /// Returns true if this zone has the same rule and offset as another zone.
  /// That is, if this zone differs only in ID, if at all.  Returns false
  /// if the other zone is null.
  ///@param other the <code>TimeZone</code> object to be compared with
  ///@return true if the other zone is not null and is the same as this one,
  /// with the possible exception of the ID
  bool hasSameRules(TimeZone other) => jniAccessors.callMethodWithArgs(
      reference,
      _id_hasSameRules,
      jni.JniType.booleanType,
      [other.reference]).boolean;

  static final _id_clone =
      jniAccessors.getMethodIDOf(_classRef, "clone", "()Ljava/lang/Object;");

  /// from: public java.lang.Object clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Overrides clone.
  jni.JniObject clone() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// Overrides equals.
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// Overrides hashCode.
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_getTZDataVersion = jniAccessors.getStaticMethodIDOf(
      _classRef, "getTZDataVersion", "()Ljava/lang/String;");

  /// from: static public java.lang.String getTZDataVersion()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the time zone data version currently used by ICU.
  ///@return the version string, such as "2007f"
  ///@throws MissingResourceException if ICU time zone resource bundle
  /// is missing or the version information is not available.
  static jni.JniString getTZDataVersion() =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getTZDataVersion, jni.JniType.objectType, []).object);

  static final _id_getCanonicalID = jniAccessors.getStaticMethodIDOf(
      _classRef, "getCanonicalID", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String getCanonicalID(java.lang.String id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the canonical system time zone ID or the normalized
  /// custom time zone ID for the given time zone ID.
  ///@param id The input time zone ID to be canonicalized.
  ///@return The canonical system time zone ID or the custom time zone ID
  /// in normalized format for the given time zone ID.  When the given time zone ID
  /// is neither a known system time zone ID nor a valid custom time zone ID,
  /// null is returned.
  static jni.JniString getCanonicalID(jni.JniString id) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getCanonicalID, jni.JniType.objectType, [id.reference]).object);

  static final _id_getCanonicalID1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "getCanonicalID", "(Ljava/lang/String;[Z)Ljava/lang/String;");

  /// from: static public java.lang.String getCanonicalID(java.lang.String id, boolean[] isSystemID)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the canonical system time zone ID or the normalized
  /// custom time zone ID for the given time zone ID.
  ///@param id The input time zone ID to be canonicalized.
  ///@param isSystemID When non-null boolean array is specified and
  /// the given ID is a known system time zone ID, true is set to <code>isSystemID[0]</code>
  ///@return The canonical system time zone ID or the custom time zone ID
  /// in normalized format for the given time zone ID.  When the given time zone ID
  /// is neither a known system time zone ID nor a valid custom time zone ID,
  /// null is returned.
  static jni.JniString getCanonicalID1(
          jni.JniString id, jni.JniObject isSystemID) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getCanonicalID1,
          jni.JniType.objectType,
          [id.reference, isSystemID.reference]).object);

  static final _id_getRegion = jniAccessors.getStaticMethodIDOf(
      _classRef, "getRegion", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String getRegion(java.lang.String id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the region code associated with the given
  /// system time zone ID. The region code is either ISO 3166
  /// 2-letter country code or UN M.49 3-digit area code.
  /// When the time zone is not associated with a specific location,
  /// for example - "Etc/UTC", "EST5EDT", then this method returns
  /// "001" (UN M.49 area code for World).
  ///@param id the system time zone ID.
  ///@return the region code associated with the given
  /// system time zone ID.
  ///@throws IllegalArgumentException if <code>id</code> is not a known system ID.
  ///@see \#getAvailableIDs(String)
  static jni.JniString getRegion(jni.JniString id) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getRegion, jni.JniType.objectType, [id.reference]).object);

  static final _id_getWindowsID = jniAccessors.getStaticMethodIDOf(
      _classRef, "getWindowsID", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String getWindowsID(java.lang.String id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Converts a system time zone ID to an equivalent Windows time zone ID. For example,
  /// Windows time zone ID "Pacific Standard Time" is returned for input "America/Los_Angeles".
  ///
  /// There are system time zones that cannot be mapped to Windows zones. When the input
  /// system time zone ID is unknown or unmappable to a Windows time zone, then this
  /// method returns <code>null</code>.
  ///
  /// This implementation utilizes <a href="http://unicode.org/cldr/charts/supplemental/zone_tzid.html">
  /// Zone-Tzid mapping data</a>. The mapping data is updated time to time. To get the latest changes,
  /// please read the ICU user guide section <a href="http://userguide.icu-project.org/datetime/timezone\#TOC-Updating-the-Time-Zone-Data">
  /// Updating the Time Zone Data</a>.
  ///@param id A system time zone ID
  ///@return A Windows time zone ID mapped from the input system time zone ID,
  /// or <code>null</code> when the input ID is unknown or unmappable.
  ///@see \#getIDForWindowsID(String, String)
  static jni.JniString getWindowsID(jni.JniString id) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getWindowsID, jni.JniType.objectType, [id.reference]).object);

  static final _id_getIDForWindowsID = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getIDForWindowsID",
      "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String getIDForWindowsID(java.lang.String winid, java.lang.String region)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Converts a Windows time zone ID to an equivalent system time zone ID
  /// for a region. For example, system time zone ID "America/Los_Angeles" is returned
  /// for input Windows ID "Pacific Standard Time" and region "US" (or <code>null</code>),
  /// "America/Vancouver" is returned for the same Windows ID "Pacific Standard Time" and
  /// region "CA".
  ///
  /// Not all Windows time zones can be mapped to system time zones. When the input
  /// Windows time zone ID is unknown or unmappable to a system time zone, then this
  /// method returns <code>null</code>.
  ///
  /// This implementation utilizes <a href="http://unicode.org/cldr/charts/supplemental/zone_tzid.html">
  /// Zone-Tzid mapping data</a>. The mapping data is updated time to time. To get the latest changes,
  /// please read the ICU user guide section <a href="http://userguide.icu-project.org/datetime/timezone\#TOC-Updating-the-Time-Zone-Data">
  /// Updating the Time Zone Data</a>.
  ///@param winid A Windows time zone ID
  ///@param region A region code, or <code>null</code> if no regional preference.
  ///@return A system time zone ID mapped from the input Windows time zone ID,
  /// or <code>null</code> when the input ID is unknown or unmappable.
  ///@see \#getWindowsID(String)
  static jni.JniString getIDForWindowsID(
          jni.JniString winid, jni.JniString region) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getIDForWindowsID,
          jni.JniType.objectType,
          [winid.reference, region.reference]).object);

  static final _id_isFrozen =
      jniAccessors.getMethodIDOf(_classRef, "isFrozen", "()Z");

  /// from: public boolean isFrozen()
  ///
  /// {@inheritDoc}
  bool isFrozen() => jniAccessors.callMethodWithArgs(
      reference, _id_isFrozen, jni.JniType.booleanType, []).boolean;

  static final _id_freeze = jniAccessors.getMethodIDOf(
      _classRef, "freeze", "()Landroid/icu/util/TimeZone;");

  /// from: public android.icu.util.TimeZone freeze()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  TimeZone freeze() => TimeZone.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_freeze, jni.JniType.objectType, []).object);

  static final _id_cloneAsThawed = jniAccessors.getMethodIDOf(
      _classRef, "cloneAsThawed", "()Landroid/icu/util/TimeZone;");

  /// from: public android.icu.util.TimeZone cloneAsThawed()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  TimeZone cloneAsThawed() => TimeZone.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_cloneAsThawed, jni.JniType.objectType, []).object);
}

/// from: android.icu.util.TimeZone$SystemTimeZoneType
///
/// <strong>[icu]</strong> System time zone type constants used by filtering zones in
/// TimeZone\#getAvailableIDs(SystemTimeZoneType, String, Integer)
class TimeZone_SystemTimeZoneType extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/util/TimeZone\$SystemTimeZoneType");
  TimeZone_SystemTimeZoneType.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(_classRef,
      "values", "()[Landroid/icu/util/TimeZone\$SystemTimeZoneType;");

  /// from: static public android.icu.util.TimeZone.SystemTimeZoneType[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/icu/util/TimeZone\$SystemTimeZoneType;");

  /// from: static public android.icu.util.TimeZone.SystemTimeZoneType valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static TimeZone_SystemTimeZoneType valueOf(jni.JniString name) =>
      TimeZone_SystemTimeZoneType.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  TimeZone_SystemTimeZoneType()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
