// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.util.RangeValueIterator
///
/// Interface for enabling iteration over sets of &lt;int index, int value&gt;,
/// where index is the sorted integer index in ascending order and value, its
/// associated integer value.
/// The result for each iteration is the consecutive range of
/// &lt;int index, int value&gt; with the same value. Result is represented by
/// &lt;start, limit, value&gt; where
/// <ul>
/// <li> start is the starting integer of the result range
/// <li> limit is 1 after the maximum integer that follows start, such that
///      all integers between start and (limit - 1), inclusive, have the same
///      associated integer value.
/// <li> value is the integer value that all integers from start to (limit - 1)
///      share in common.
/// </ul>
///
/// Hence value(start) = value(start + 1) = .... = value(start + n) = .... =
/// value(limit - 1). However value(start -1) != value(start) and
/// value(limit) != value(start).
///
/// Most implementations will be created by factory methods, such as the
/// character type iterator in UCharacter.getTypeIterator. See example below.
///
/// Example of use:<br>
/// <pre>
/// RangeValueIterator iterator = UCharacter.getTypeIterator();
/// RangeValueIterator.Element result = new RangeValueIterator.Element();
/// while (iterator.next(result)) {
///     System.out.println("Codepoint \\u" +
///                        Integer.toHexString(result.start) +
///                        " to codepoint \\u" +
///                        Integer.toHexString(result.limit - 1) +
///                        " has the character type " + result.value);
/// }
/// </pre>
///@author synwee
class RangeValueIterator extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/util/RangeValueIterator");
  RangeValueIterator.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_next = jniAccessors.getMethodIDOf(
      _classRef, "next", "(Landroid/icu/util/RangeValueIterator\$Element;)Z");

  /// from: public abstract boolean next(android.icu.util.RangeValueIterator.Element element)
  ///
  /// Returns the next maximal result range with a common value and returns
  /// true if we are not at the end of the iteration, false otherwise.
  /// If this returns a false, the contents of elements will not
  /// be updated.
  ///@param element for storing the result range and value
  ///@return true if we are not at the end of the iteration, false otherwise.
  ///@see Element
  bool next(RangeValueIterator_Element element) =>
      jniAccessors.callMethodWithArgs(reference, _id_next,
          jni.JniType.booleanType, [element.reference]).boolean;

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, "reset", "()V");

  /// from: public abstract void reset()
  ///
  /// Resets the iterator to the beginning of the iteration.
  void reset() => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniType.voidType, []).check();
}

/// from: android.icu.util.RangeValueIterator$Element
///
/// Return result wrapper for android.icu.util.RangeValueIterator.
/// Stores the start and limit of the continous result range and the
/// common value all integers between [start, limit - 1] has.
class RangeValueIterator_Element extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/util/RangeValueIterator\$Element");
  RangeValueIterator_Element.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_limit = jniAccessors.getFieldIDOf(_classRef, "limit", "I");

  /// from: public int limit
  ///
  /// (End + 1) integer of continuous result range that has the same
  /// value
  int get limit =>
      jniAccessors.getField(reference, _id_limit, jni.JniType.intType).integer;

  /// from: public int limit
  ///
  /// (End + 1) integer of continuous result range that has the same
  /// value
  set limit(int value) => jniEnv.SetIntField(reference, _id_limit, value);

  static final _id_start = jniAccessors.getFieldIDOf(_classRef, "start", "I");

  /// from: public int start
  ///
  /// Starting integer of the continuous result range that has the same
  /// value
  int get start =>
      jniAccessors.getField(reference, _id_start, jni.JniType.intType).integer;

  /// from: public int start
  ///
  /// Starting integer of the continuous result range that has the same
  /// value
  set start(int value) => jniEnv.SetIntField(reference, _id_start, value);

  static final _id_value = jniAccessors.getFieldIDOf(_classRef, "value", "I");

  /// from: public int value
  ///
  /// Gets the common value of the continous result range
  int get value =>
      jniAccessors.getField(reference, _id_value, jni.JniType.intType).integer;

  /// from: public int value
  ///
  /// Gets the common value of the continous result range
  set value(int value) => jniEnv.SetIntField(reference, _id_value, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Empty default constructor to make javadoc happy
  RangeValueIterator_Element()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
