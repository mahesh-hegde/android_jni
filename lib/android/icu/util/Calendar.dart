// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "TimeZone.dart" as timezone_;

import "ULocale.dart" as ulocale_;

import "../text/DateFormat.dart" as dateformat_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.icu.util.Calendar
///
/// <strong>[icu enhancement]</strong> ICU's replacement for java.util.Calendar.&nbsp;Methods, fields, and other functionality specific to ICU are labeled '<strong>[icu]</strong>'.
///
/// <code>Calendar</code> is an abstract base class for converting between
/// a <code>Date</code> object and a set of integer fields such as
/// <code>YEAR</code>, <code>MONTH</code>, <code>DAY</code>, <code>HOUR</code>,
/// and so on. (A <code>Date</code> object represents a specific instant in
/// time with millisecond precision. See
/// Date
/// for information about the <code>Date</code> class.)
///
/// Subclasses of <code>Calendar</code> interpret a <code>Date</code>
/// according to the rules of a specific calendar system.  ICU4J contains
/// several subclasses implementing different international calendar systems.
///
///
/// Like other locale-sensitive classes, <code>Calendar</code> provides a
/// class method, <code>getInstance</code>, for getting a generally useful
/// object of this type. <code>Calendar</code>'s <code>getInstance</code> method
/// returns a calendar of a type appropriate to the locale, whose
/// time fields have been initialized with the current date and time:
/// <blockquote>
/// <pre>Calendar rightNow = Calendar.getInstance()</pre>
/// </blockquote>
///
/// When a <code>ULocale</code> is used by <code>getInstance</code>, its
/// '<code>calendar</code>' tag and value are retrieved if present.  If a recognized
/// value is supplied, a calendar is provided and configured as appropriate.
/// Currently recognized tags are "buddhist", "chinese", "coptic", "ethiopic",
/// "gregorian", "hebrew", "islamic", "islamic-civil", "japanese", and "roc".  For
/// example: <blockquote>
/// <pre>Calendar cal = Calendar.getInstance(new ULocale("en_US@calendar=japanese"));</pre>
/// </blockquote> will return an instance of JapaneseCalendar (using en_US conventions for
/// minimum days in first week, start day of week, et cetera).
///
/// A <code>Calendar</code> object can produce all the time field values
/// needed to implement the date-time formatting for a particular language and
/// calendar style (for example, Japanese-Gregorian, Japanese-Traditional).
/// <code>Calendar</code> defines the range of values returned by certain fields,
/// as well as their meaning.  For example, the first month of the year has value
/// <code>MONTH</code> == <code>JANUARY</code> for all calendars.  Other values
/// are defined by the concrete subclass, such as <code>ERA</code> and
/// <code>YEAR</code>.  See individual field documentation and subclass
/// documentation for details.
///
/// When a <code>Calendar</code> is _lenient_, it accepts a wider range
/// of field values than it produces.  For example, a lenient
/// <code>GregorianCalendar</code> interprets <code>MONTH</code> ==
/// <code>JANUARY</code>, <code>DAY_OF_MONTH</code> == 32 as February 1.  A
/// non-lenient <code>GregorianCalendar</code> throws an exception when given
/// out-of-range field settings.  When calendars recompute field values for
/// return by <code>get()</code>, they normalize them.  For example, a
/// <code>GregorianCalendar</code> always produces <code>DAY_OF_MONTH</code>
/// values between 1 and the length of the month.
///
/// <code>Calendar</code> defines a locale-specific seven day week using two
/// parameters: the first day of the week and the minimal days in first week
/// (from 1 to 7).  These numbers are taken from the locale resource data when a
/// <code>Calendar</code> is constructed.  They may also be specified explicitly
/// through the API.
///
/// When setting or getting the <code>WEEK_OF_MONTH</code> or
/// <code>WEEK_OF_YEAR</code> fields, <code>Calendar</code> must determine the
/// first week of the month or year as a reference point.  The first week of a
/// month or year is defined as the earliest seven day period beginning on
/// <code>getFirstDayOfWeek()</code> and containing at least
/// <code>getMinimalDaysInFirstWeek()</code> days of that month or year.  Weeks
/// numbered ..., -1, 0 precede the first week; weeks numbered 2, 3,... follow
/// it.  Note that the normalized numbering returned by <code>get()</code> may be
/// different.  For example, a specific <code>Calendar</code> subclass may
/// designate the week before week 1 of a year as week _n_ of the previous
/// year.
///
///  When computing a <code>Date</code> from time fields, some special
/// circumstances may arise: there may be insufficient information to compute the
/// <code>Date</code> (such as only year and month but no day in the month),
/// there may be inconsistent information (such as "Tuesday, July 15, 1996" --
/// July 15, 1996 is actually a Monday), or the input time might be ambiguous
/// because of time zone transition.
///
/// <strong>Insufficient information.</strong> The calendar will use default
/// information to specify the missing fields. This may vary by calendar; for
/// the Gregorian calendar, the default for a field is the same as that of the
/// start of the epoch: i.e., YEAR = 1970, MONTH = JANUARY, DATE = 1, etc.
///
/// <strong>Inconsistent information.</strong> If fields conflict, the calendar
/// will give preference to fields set more recently. For example, when
/// determining the day, the calendar will look for one of the following
/// combinations of fields.  The most recent combination, as determined by the
/// most recently set single field, will be used.
///
/// <blockquote>
/// <pre>
/// MONTH + DAY_OF_MONTH
/// MONTH + WEEK_OF_MONTH + DAY_OF_WEEK
/// MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK
/// DAY_OF_YEAR
/// DAY_OF_WEEK + WEEK_OF_YEAR</pre>
/// </blockquote>
///
/// For the time of day:
///
/// <blockquote>
/// <pre>
/// HOUR_OF_DAY
/// AM_PM + HOUR</pre>
/// </blockquote>
///
/// <strong>Ambiguous Wall Clock Time.</strong> When time offset from UTC has
/// changed, it produces an ambiguous time slot around the transition. For example,
/// many US locations observe daylight saving time. On the date switching to daylight
/// saving time in US, wall clock time jumps from 12:59 AM (standard) to 2:00 AM
/// (daylight). Therefore, wall clock time from 1:00 AM to 1:59 AM do not exist on
/// the date. When the input wall time fall into this missing time slot, the ICU
/// Calendar resolves the time using the UTC offset before the transition by default.
/// In this example, 1:30 AM is interpreted as 1:30 AM standard time (non-exist),
/// so the final result will be 2:30 AM daylight time.
///
/// On the date switching back to standard time, wall clock time is moved back one
/// hour at 2:00 AM. So wall clock time from 1:00 AM to 1:59 AM occur twice. In this
/// case, the ICU Calendar resolves the time using the UTC offset after the transition
/// by default. For example, 1:30 AM on the date is resolved as 1:30 AM standard time.
///
/// Ambiguous wall clock time resolution behaviors can be customized by Calendar APIs
/// \#setRepeatedWallTimeOption(int) and \#setSkippedWallTimeOption(int).
/// These methods are available in ICU 49 or later versions.
///
/// <strong>Note:</strong> for some non-Gregorian calendars, different
/// fields may be necessary for complete disambiguation. For example, a full
/// specification of the historial Arabic astronomical calendar requires year,
/// month, day-of-month _and_ day-of-week in some cases.
///
/// <strong>Note:</strong> There are certain possible ambiguities in
/// interpretation of certain singular times, which are resolved in the
/// following ways:
/// <ol>
///     <li> 24:00:00 "belongs" to the following day. That is,
///          23:59 on Dec 31, 1969 &lt; 24:00 on Jan 1, 1970 &lt; 24:01:00 on Jan 1, 1970
///
///     <li> Although historically not precise, midnight also belongs to "am",
///          and noon belongs to "pm", so on the same day,
///          12:00 am (midnight) &lt; 12:01 am, and 12:00 pm (noon) &lt; 12:01 pm
/// </ol>
///
/// The date or time format strings are not part of the definition of a
/// calendar, as those must be modifiable or overridable by the user at
/// runtime. Use DateFormat
/// to format dates.
///
/// <strong>Field manipulation methods</strong>
///
///
/// <code>Calendar</code> fields can be changed using three methods:
/// <code>set()</code>, <code>add()</code>, and <code>roll()</code>.
///
///
/// <strong><code>set(f, value)</code></strong> changes field
/// <code>f</code> to <code>value</code>.  In addition, it sets an
/// internal member variable to indicate that field <code>f</code> has
/// been changed. Although field <code>f</code> is changed immediately,
/// the calendar's milliseconds is not recomputed until the next call to
/// <code>get()</code>, <code>getTime()</code>, or
/// <code>getTimeInMillis()</code> is made. Thus, multiple calls to
/// <code>set()</code> do not trigger multiple, unnecessary
/// computations. As a result of changing a field using
/// <code>set()</code>, other fields may also change, depending on the
/// field, the field value, and the calendar system. In addition,
/// <code>get(f)</code> will not necessarily return <code>value</code>
/// after the fields have been recomputed. The specifics are determined by
/// the concrete calendar class.
///
///
/// _Example_: Consider a <code>GregorianCalendar</code>
/// originally set to August 31, 1999. Calling <code>set(Calendar.MONTH,
/// Calendar.SEPTEMBER)</code> sets the calendar to September 31,
/// 1999. This is a temporary internal representation that resolves to
/// October 1, 1999 if <code>getTime()</code>is then called. However, a
/// call to <code>set(Calendar.DAY_OF_MONTH, 30)</code> before the call to
/// <code>getTime()</code> sets the calendar to September 30, 1999, since
/// no recomputation occurs after <code>set()</code> itself.
///
///
/// <strong><code>add(f, delta)</code></strong> adds <code>delta</code>
/// to field <code>f</code>.  This is equivalent to calling <code>set(f,
/// get(f) + delta)</code> with two adjustments:
///
///
/// <blockquote>
///   <strong>Add rule 1</strong>. The value of field <code>f</code>
///   after the call minus the value of field <code>f</code> before the
///   call is <code>delta</code>, modulo any overflow that has occurred in
///   field <code>f</code>. Overflow occurs when a field value exceeds its
///   range and, as a result, the next larger field is incremented or
///   decremented and the field value is adjusted back into its range.
///
///
///   <strong>Add rule 2</strong>. If a smaller field is expected to be
///   invariant, but &nbsp; it is impossible for it to be equal to its
///   prior value because of changes in its minimum or maximum after field
///   <code>f</code> is changed, then its value is adjusted to be as close
///   as possible to its expected value. A smaller field represents a
///   smaller unit of time. <code>HOUR</code> is a smaller field than
///   <code>DAY_OF_MONTH</code>. No adjustment is made to smaller fields
///   that are not expected to be invariant. The calendar system
///   determines what fields are expected to be invariant.
///
/// </blockquote>
///
/// In addition, unlike <code>set()</code>, <code>add()</code> forces
/// an immediate recomputation of the calendar's milliseconds and all
/// fields.
///
///
/// _Example_: Consider a <code>GregorianCalendar</code>
/// originally set to August 31, 1999. Calling <code>add(Calendar.MONTH,
/// 13)</code> sets the calendar to September 30, 2000. <strong>Add rule
/// 1</strong> sets the <code>MONTH</code> field to September, since
/// adding 13 months to August gives September of the next year. Since
/// <code>DAY_OF_MONTH</code> cannot be 31 in September in a
/// <code>GregorianCalendar</code>, <strong>add rule 2</strong> sets the
/// <code>DAY_OF_MONTH</code> to 30, the closest possible value. Although
/// it is a smaller field, <code>DAY_OF_WEEK</code> is not adjusted by
/// rule 2, since it is expected to change when the month changes in a
/// <code>GregorianCalendar</code>.
///
///
/// <strong><code>roll(f, delta)</code></strong> adds
/// <code>delta</code> to field <code>f</code> without changing larger
/// fields. This is equivalent to calling <code>add(f, delta)</code> with
/// the following adjustment:
///
///
/// <blockquote>
///   <strong>Roll rule</strong>. Larger fields are unchanged after the
///   call. A larger field represents a larger unit of
///   time. <code>DAY_OF_MONTH</code> is a larger field than
///   <code>HOUR</code>.
///
/// </blockquote>
///
/// _Example_: Consider a <code>GregorianCalendar</code>
/// originally set to August 31, 1999. Calling <code>roll(Calendar.MONTH,
/// 8)</code> sets the calendar to April 30, <strong>1999</strong>.  Add
/// rule 1 sets the <code>MONTH</code> field to April. Using a
/// <code>GregorianCalendar</code>, the <code>DAY_OF_MONTH</code> cannot
/// be 31 in the month April. Add rule 2 sets it to the closest possible
/// value, 30. Finally, the <strong>roll rule</strong> maintains the
/// <code>YEAR</code> field value of 1999.
///
///
/// _Example_: Consider a <code>GregorianCalendar</code>
/// originally set to Sunday June 6, 1999. Calling
/// <code>roll(Calendar.WEEK_OF_MONTH, -1)</code> sets the calendar to
/// Tuesday June 1, 1999, whereas calling
/// <code>add(Calendar.WEEK_OF_MONTH, -1)</code> sets the calendar to
/// Sunday May 30, 1999. This is because the roll rule imposes an
/// additional constraint: The <code>MONTH</code> must not change when the
/// <code>WEEK_OF_MONTH</code> is rolled. Taken together with add rule 1,
/// the resultant date must be between Tuesday June 1 and Saturday June
/// 5. According to add rule 2, the <code>DAY_OF_WEEK</code>, an invariant
/// when changing the <code>WEEK_OF_MONTH</code>, is set to Tuesday, the
/// closest possible value to Sunday (where Sunday is the first day of the
/// week).
///
///
/// <strong>Usage model</strong>. To motivate the behavior of
/// <code>add()</code> and <code>roll()</code>, consider a user interface
/// component with increment and decrement buttons for the month, day, and
/// year, and an underlying <code>GregorianCalendar</code>. If the
/// interface reads January 31, 1999 and the user presses the month
/// increment button, what should it read? If the underlying
/// implementation uses <code>set()</code>, it might read March 3, 1999. A
/// better result would be February 28, 1999. Furthermore, if the user
/// presses the month increment button again, it should read March 31,
/// 1999, not March 28, 1999. By saving the original date and using either
/// <code>add()</code> or <code>roll()</code>, depending on whether larger
/// fields should be affected, the user interface can behave as most users
/// will intuitively expect.
///
///
/// __Note:__ You should always use \#roll roll and \#add add rather
/// than attempting to perform arithmetic operations directly on the fields
/// of a <tt>Calendar</tt>.  It is quite possible for <tt>Calendar</tt> subclasses
/// to have fields with non-linear behavior, for example missing months
/// or days during non-leap years.  The subclasses' <tt>add</tt> and <tt>roll</tt>
/// methods will take this into account, while simple arithmetic manipulations
/// may give invalid results.
///
/// <big><big>__Calendar Architecture in ICU4J__</big></big>
///
///
/// Recently the implementation of <code>Calendar</code> has changed
/// significantly in order to better support subclassing. The original
/// <code>Calendar</code> class was designed to support subclassing, but
/// it had only one implemented subclass, <code>GregorianCalendar</code>.
/// With the implementation of several new calendar subclasses, including
/// the <code>BuddhistCalendar</code>, <code>ChineseCalendar</code>,
/// <code>HebrewCalendar</code>, <code>IslamicCalendar</code>, and
/// <code>JapaneseCalendar</code>, the subclassing API has been reworked
/// thoroughly. This section details the new subclassing API and other
/// ways in which <code>android.icu.util.Calendar</code> differs from
/// <code>java.util.Calendar</code>.
///
///
///
/// <big>__Changes__</big>
///
///
/// Overview of changes between the classic <code>Calendar</code>
/// architecture and the new architecture.
///
/// <ul>
///
///   <li>The <code>fields[]</code> array is <code>private</code> now
///     instead of <code>protected</code>.  Subclasses must access it
///     using the methods \#internalSet and
///     \#internalGet.  __Motivation:__ Subclasses should
///     not directly access data members.</li>
///
///   <li>The <code>time</code> long word is <code>private</code> now
///     instead of <code>protected</code>.  Subclasses may access it using
///     the method \#internalGetTimeInMillis, which does not
///     provoke an update. __Motivation:__ Subclasses should not
///     directly access data members.</li>
///
///   <li>The scope of responsibility of subclasses has been drastically
///     reduced. As much functionality as possible is implemented in the
///     <code>Calendar</code> base class. As a result, it is much easier
///     to subclass <code>Calendar</code>. __Motivation:__ Subclasses
///     should not have to reimplement common code. Certain behaviors are
///     common across calendar systems: The definition and behavior of
///     week-related fields and time fields, the arithmetic
///     (\#add(int, int) add and \#roll(int, int) roll) behavior of many
///     fields, and the field validation system.</li>
///
///   <li>The subclassing API has been completely redesigned.</li>
///
///   <li>The <code>Calendar</code> base class contains some Gregorian
///     calendar algorithmic support that subclasses can use (specifically
///     in \#handleComputeFields).  Subclasses can use the
///     methods <code>getGregorianXxx()</code> to obtain precomputed
///     values. __Motivation:__ This is required by all
///     <code>Calendar</code> subclasses in order to implement consistent
///     time zone behavior, and Gregorian-derived systems can use the
///     already computed data.</li>
///
///   <li>The <code>FIELD_COUNT</code> constant has been removed. Use
///     \#getFieldCount.  In addition, framework API has been
///     added to allow subclasses to define additional fields.
///     __Motivation: __The number of fields is not constant across
///     calendar systems.</li>
///
///   <li>The range of handled dates has been narrowed from +/-
///     ~300,000,000 years to +/- ~5,000,000 years. In practical terms
///     this should not affect clients. However, it does mean that client
///     code cannot be guaranteed well-behaved results with dates such as
///     <code>Date(Long.MIN_VALUE)</code> or
///     <code>Date(Long.MAX_VALUE)</code>. Instead, the
///     <code>Calendar</code> protected constants should be used.
///     __Motivation:__ With
///     the addition of the \#JULIAN_DAY field, Julian day
///     numbers must be restricted to a 32-bit <code>int</code>.  This
///     restricts the overall supported range. Furthermore, restricting
///     the supported range simplifies the computations by removing
///     special case code that was used to accomodate arithmetic overflow
///     at millis near <code>Long.MIN_VALUE</code> and
///     <code>Long.MAX_VALUE</code>.</li>
///
///   <li>New fields are implemented: \#JULIAN_DAY defines
///     single-field specification of the
///     date. \#MILLISECONDS_IN_DAY defines a single-field
///     specification of the wall time. \#DOW_LOCAL and
///     \#YEAR_WOY implement localized day-of-week and
///     week-of-year behavior.</li>
///
///   <li>Subclasses can access protected millisecond constants
///   defined in <code>Calendar</code>.</li>
///
///   <li>New API has been added to support calendar-specific subclasses
///     of <code>DateFormat</code>.</li>
///
///   <li>Several subclasses have been implemented, representing
///     various international calendar systems.</li>
///
/// </ul>
///
/// <big>__Subclass API__</big>
///
///
/// The original <code>Calendar</code> API was based on the experience
/// of implementing a only a single subclass,
/// <code>GregorianCalendar</code>. As a result, all of the subclassing
/// kinks had not been worked out. The new subclassing API has been
/// refined based on several implemented subclasses. This includes methods
/// that must be overridden and methods for subclasses to call. Subclasses
/// no longer have direct access to <code>fields</code> and
/// <code>stamp</code>. Instead, they have new API to access
/// these. Subclasses are able to allocate the <code>fields</code> array
/// through a protected framework method; this allows subclasses to
/// specify additional fields.
///
///
/// More functionality has been moved into the base class. The base
/// class now contains much of the computational machinery to support the
/// Gregorian calendar. This is based on two things: (1) Many calendars
/// are based on the Gregorian calendar (such as the Buddhist and Japanese
/// imperial calendars). (2) _All_ calendars require basic
/// Gregorian support in order to handle timezone computations.
///
///
/// Common computations have been moved into
/// <code>Calendar</code>. Subclasses no longer compute the week related
/// fields and the time related fields. These are commonly handled for all
/// calendars by the base class.
///
///
/// __Subclass computation of time <tt>=&gt;</tt> fields__
///
/// The \#ERA, \#YEAR,
/// \#EXTENDED_YEAR, \#MONTH,
/// \#DAY_OF_MONTH, and \#DAY_OF_YEAR fields are
/// computed by the subclass, based on the Julian day. All other fields
/// are computed by <code>Calendar</code>.
///
/// <ul>
///
///   <li>Subclasses should implement \#handleComputeFields
///     to compute the \#ERA, \#YEAR,
///     \#EXTENDED_YEAR, \#MONTH,
///     \#DAY_OF_MONTH, and \#DAY_OF_YEAR fields,
///     based on the value of the \#JULIAN_DAY field. If there
///     are calendar-specific fields not defined by <code>Calendar</code>,
///     they must also be computed. These are the only fields that the
///     subclass should compute. All other fields are computed by the base
///     class, so time and week fields behave in a consistent way across
///     all calendars. The default version of this method in
///     <code>Calendar</code> implements a proleptic Gregorian
///     calendar. Within this method, subclasses may call
///     <code>getGregorianXxx()</code> to obtain the Gregorian calendar
///     month, day of month, and extended year for the given date.</li>
///
/// </ul>
///
/// __Subclass computation of fields <tt>=&gt;</tt> time__
///
/// The interpretation of most field values is handled entirely by
/// <code>Calendar</code>. <code>Calendar</code> determines which fields
/// are set, which are not, which are set more recently, and so on. In
/// addition, <code>Calendar</code> handles the computation of the time
/// from the time fields and handles the week-related fields. The only
/// thing the subclass must do is determine the extended year, based on
/// the year fields, and then, given an extended year and a month, it must
/// return a Julian day number.
///
/// <ul>
///
///   <li>Subclasses should implement \#handleGetExtendedYear
///     to return the extended year for this calendar system, based on the
///     \#YEAR, \#EXTENDED_YEAR, and any fields that
///     the calendar system uses that are larger than a year, such as
///     \#ERA.</li>
///
///   <li>Subclasses should implement \#handleComputeMonthStart
///     to return the Julian day number
///     associated with a month and extended year. This is the Julian day
///     number of the day before the first day of the month. The month
///     number is zero-based. This computation should not depend on any
///     field values.</li>
///
/// </ul>
///
/// __Other methods__
///
/// <ul>
///
///   <li>Subclasses should implement \#handleGetMonthLength
///     to return the number of days in a
///     given month of a given extended year. The month number, as always,
///     is zero-based.</li>
///
///   <li>Subclasses should implement \#handleGetYearLength
///     to return the number of days in the given
///     extended year. This method is used by
///     <tt>computeWeekFields</tt> to compute the
///     \#WEEK_OF_YEAR and \#YEAR_WOY fields.</li>
///
///   <li>Subclasses should implement \#handleGetLimit
///     to return the protected values of a field, depending on the value of
///     <code>limitType</code>. This method only needs to handle the
///     fields \#ERA, \#YEAR, \#MONTH,
///     \#WEEK_OF_YEAR, \#WEEK_OF_MONTH,
///     \#DAY_OF_MONTH, \#DAY_OF_YEAR,
///     \#DAY_OF_WEEK_IN_MONTH, \#YEAR_WOY, and
///     \#EXTENDED_YEAR.  Other fields are invariant (with
///     respect to calendar system) and are handled by the base
///     class.</li>
///
///   <li>Optionally, subclasses may override \#validateField
///     to check any subclass-specific fields. If the
///     field's value is out of range, the method should throw an
///     <code>IllegalArgumentException</code>. The method may call
///     <code>super.validateField(field)</code> to handle fields in a
///     generic way, that is, to compare them to the range
///     <code>getMinimum(field)</code>..<code>getMaximum(field)</code>.</li>
///
///   <li>Optionally, subclasses may override
///     \#handleCreateFields to create an <code>int[]</code>
///     array large enough to hold the calendar's fields. This is only
///     necessary if the calendar defines additional fields beyond those
///     defined by <code>Calendar</code>. The length of the result must be
///     be between the base and maximum field counts.</li>
///
///   <li>Optionally, subclasses may override
///     \#handleGetDateFormat to create a
///     <code>DateFormat</code> appropriate to this calendar. This is only
///     required if a calendar subclass redefines the use of a field (for
///     example, changes the \#ERA field from a symbolic field
///     to a numeric one) or defines an additional field.</li>
///
///   <li>Optionally, subclasses may override \#roll roll and
///     \#add add to handle fields that are discontinuous. For
///     example, in the Hebrew calendar the month &quot;Adar I&quot; only
///     occurs in leap years; in other years the calendar jumps from
///     Shevat (month \#4) to Adar (month \#6). The HebrewCalendar\#add HebrewCalendar.add and HebrewCalendar\#roll HebrewCalendar.roll methods take this into
///     account, so that adding 1 month to Shevat gives the proper result
///     (Adar) in a non-leap year. The protected utility method \#pinField pinField is often useful when implementing these two
///     methods. </li>
///
/// </ul>
///
/// <big>__Normalized behavior__</big>
///
/// The behavior of certain fields has been made consistent across all
/// calendar systems and implemented in <code>Calendar</code>.
///
/// <ul>
///
///   <li>Time is normalized. Even though some calendar systems transition
///     between days at sunset or at other times, all ICU4J calendars
///     transition between days at _local zone midnight_.  This
///     allows ICU4J to centralize the time computations in
///     <code>Calendar</code> and to maintain basic correpsondences
///     between calendar systems. Affected fields: \#AM_PM,
///     \#HOUR, \#HOUR_OF_DAY, \#MINUTE,
///     \#SECOND, \#MILLISECOND,
///     \#ZONE_OFFSET, and \#DST_OFFSET.</li>
///
///   <li>DST behavior is normalized. Daylight savings time behavior is
///     computed the same for all calendar systems, and depends on the
///     value of several <code>GregorianCalendar</code> fields: the
///     \#YEAR, \#MONTH, and
///     \#DAY_OF_MONTH. As a result, <code>Calendar</code>
///     always computes these fields, even for non-Gregorian calendar
///     systems. These fields are available to subclasses.</li>
///
///   <li>Weeks are normalized. Although locales define the week
///     differently, in terms of the day on which it starts, and the
///     designation of week number one of a month or year, they all use a
///     common mechanism. Furthermore, the day of the week has a simple
///     and consistent definition throughout history. For example,
///     although the Gregorian calendar introduced a discontinuity when
///     first instituted, the day of week was not disrupted. For this
///     reason, the fields \#DAY_OF_WEEK, <code>WEEK_OF_YEAR,
///     WEEK_OF_MONTH</code>, \#DAY_OF_WEEK_IN_MONTH,
///     \#DOW_LOCAL, \#YEAR_WOY are all computed in
///     a consistent way in the base class, based on the
///     \#EXTENDED_YEAR, \#DAY_OF_YEAR,
///     \#MONTH, and \#DAY_OF_MONTH, which are
///     computed by the subclass.</li>
///
/// </ul>
///
/// <big>__Supported range__</big>
///
/// The allowable range of <code>Calendar</code> has been
/// narrowed. <code>GregorianCalendar</code> used to attempt to support
/// the range of dates with millisecond values from
/// <code>Long.MIN_VALUE</code> to <code>Long.MAX_VALUE</code>. This
/// introduced awkward constructions (hacks) which slowed down
/// performance. It also introduced non-uniform behavior at the
/// boundaries. The new <code>Calendar</code> protocol specifies the
/// maximum range of supportable dates as those having Julian day numbers
/// of <code>-0x7F000000</code> to <code>+0x7F000000</code>. This
/// corresponds to years from ~5,800,000 BCE to ~5,800,000 CE. Programmers
/// should use the protected constants in <code>Calendar</code> to
/// specify an extremely early or extremely late date.
///
///
/// <big>__General notes__</big>
///
/// <ul>
///
///   <li>Calendars implementations are _proleptic_. For example,
///     even though the Gregorian calendar was not instituted until the
///     16th century, the <code>GregorianCalendar</code> class supports
///     dates before the historical onset of the calendar by extending the
///     calendar system backward in time. Similarly, the
///     <code>HebrewCalendar</code> extends backward before the start of
///     its epoch into zero and negative years. Subclasses do not throw
///     exceptions because a date precedes the historical start of a
///     calendar system. Instead, they implement
///     \#handleGetLimit to return appropriate limits on
///     \#YEAR, \#ERA, etc. fields. Then, if the
///     calendar is set to not be lenient, out-of-range field values will
///     trigger an exception.</li>
///
///   <li>Calendar system subclasses compute a _extended
///     year_. This differs from the \#YEAR field in that
///     it ranges over all integer values, including zero and negative
///     values, and it encapsulates the information of the
///     \#YEAR field and all larger fields.  Thus, for the
///     Gregorian calendar, the \#EXTENDED_YEAR is computed as
///     <code>ERA==AD ? YEAR : 1-YEAR</code>. Another example is the Mayan
///     long count, which has years (<code>KUN</code>) and nested cycles
///     of years (<code>KATUN</code> and <code>BAKTUN</code>). The Mayan
///     \#EXTENDED_YEAR is computed as <code>TUN + 20 * (KATUN
///     + 20 * BAKTUN)</code>. The <code>Calendar</code> base class uses
///     the \#EXTENDED_YEAR field to compute the week-related
///     fields.</li>
///
/// </ul>
///@see Date
///@see GregorianCalendar
///@see TimeZone
///@see DateFormat
///@author Mark Davis, Deborah Goldsmith, Chen-Lieh Huang, Alan Liu, Laura Werner
class Calendar extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/icu/util/Calendar");
  Calendar.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int AM
  ///
  /// Value of the <code>AM_PM</code> field indicating the
  /// period of the day from midnight to just before noon.
  static const AM = 0;

  /// from: static public final int AM_PM
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating
  /// whether the <code>HOUR</code> is before or after noon.
  /// E.g., at 10:04:15.250 PM the <code>AM_PM</code> is <code>PM</code>.
  ///@see \#AM
  ///@see \#PM
  ///@see \#HOUR
  static const AM_PM = 9;

  /// from: static public final int APRIL
  ///
  /// Value of the <code>MONTH</code> field indicating the
  /// fourth month of the year.
  static const APRIL = 3;

  /// from: static public final int AUGUST
  ///
  /// Value of the <code>MONTH</code> field indicating the
  /// eighth month of the year.
  static const AUGUST = 7;

  /// from: static protected final int BASE_FIELD_COUNT
  ///
  /// The number of fields defined by this class.  Subclasses may define
  /// addition fields starting with this number.
  ///@deprecated ICU 58 The numeric value may change over time, see ICU ticket \#12420.
  static const BASE_FIELD_COUNT = 23;

  /// from: static public final int DATE
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the
  /// day of the month. This is a synonym for \#DAY_OF_MONTH.
  /// The first day of the month has value 1.
  ///@see \#DAY_OF_MONTH
  static const DATE = 5;

  /// from: static public final int DAY_OF_MONTH
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the
  /// day of the month. This is a synonym for \#DATE.
  /// The first day of the month has value 1.
  ///@see \#DATE
  static const DAY_OF_MONTH = 5;

  /// from: static public final int DAY_OF_WEEK
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the day
  /// of the week.  This field takes values \#SUNDAY,
  /// \#MONDAY, \#TUESDAY, \#WEDNESDAY,
  /// \#THURSDAY, \#FRIDAY, and \#SATURDAY.
  ///@see \#SUNDAY
  ///@see \#MONDAY
  ///@see \#TUESDAY
  ///@see \#WEDNESDAY
  ///@see \#THURSDAY
  ///@see \#FRIDAY
  ///@see \#SATURDAY
  static const DAY_OF_WEEK = 7;

  /// from: static public final int DAY_OF_WEEK_IN_MONTH
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the
  /// ordinal number of the day of the week within the current month. Together
  /// with the \#DAY_OF_WEEK field, this uniquely specifies a day
  /// within a month.  Unlike \#WEEK_OF_MONTH and
  /// \#WEEK_OF_YEAR, this field's value does _not_ depend on
  /// \#getFirstDayOfWeek() or
  /// \#getMinimalDaysInFirstWeek().  <code>DAY_OF_MONTH 1</code>
  /// through <code>7</code> always correspond to <code>DAY_OF_WEEK_IN_MONTH
  /// 1</code>; <code>8</code> through <code>15</code> correspond to
  /// <code>DAY_OF_WEEK_IN_MONTH 2</code>, and so on.
  /// <code>DAY_OF_WEEK_IN_MONTH 0</code> indicates the week before
  /// <code>DAY_OF_WEEK_IN_MONTH 1</code>.  Negative values count back from the
  /// end of the month, so the last Sunday of a month is specified as
  /// <code>DAY_OF_WEEK = SUNDAY, DAY_OF_WEEK_IN_MONTH = -1</code>.  Because
  /// negative values count backward they will usually be aligned differently
  /// within the month than positive values.  For example, if a month has 31
  /// days, <code>DAY_OF_WEEK_IN_MONTH -1</code> will overlap
  /// <code>DAY_OF_WEEK_IN_MONTH 5</code> and the end of <code>4</code>.
  ///@see \#DAY_OF_WEEK
  ///@see \#WEEK_OF_MONTH
  static const DAY_OF_WEEK_IN_MONTH = 8;

  /// from: static public final int DAY_OF_YEAR
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the day
  /// number within the current year.  The first day of the year has value 1.
  static const DAY_OF_YEAR = 6;

  /// from: static public final int DECEMBER
  ///
  /// Value of the <code>MONTH</code> field indicating the
  /// twelfth month of the year.
  static const DECEMBER = 11;

  /// from: static public final int DOW_LOCAL
  ///
  /// <strong>[icu]</strong> Field number for <code>get()</code> and <code>set()</code>
  /// indicating the localized day of week.  This will be a value from 1
  /// to 7 inclusive, with 1 being the localized first day of the week.
  static const DOW_LOCAL = 18;

  /// from: static public final int DST_OFFSET
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the
  /// daylight savings offset in milliseconds.
  static const DST_OFFSET = 16;

  /// from: static protected final int EPOCH_JULIAN_DAY
  ///
  /// The Julian day of the epoch, that is, January 1, 1970 on the
  /// Gregorian calendar.
  static const EPOCH_JULIAN_DAY = 2440588;

  /// from: static public final int ERA
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the
  /// era, e.g., AD or BC in the Julian calendar. This is a calendar-specific
  /// value; see subclass documentation.
  ///@see GregorianCalendar\#AD
  ///@see GregorianCalendar\#BC
  static const ERA = 0;

  /// from: static public final int EXTENDED_YEAR
  ///
  /// <strong>[icu]</strong> Field number for <code>get()</code> and <code>set()</code>
  /// indicating the extended year.  This is a single number designating
  /// the year of this calendar system, encompassing all supra-year
  /// fields.  For example, for the Julian calendar system, year numbers
  /// are positive, with an era of BCE or CE.  An extended year value for
  /// the Julian calendar system assigns positive values to CE years and
  /// negative values to BCE years, with 1 BCE being year 0.
  static const EXTENDED_YEAR = 19;

  /// from: static public final int FEBRUARY
  ///
  /// Value of the <code>MONTH</code> field indicating the
  /// second month of the year.
  static const FEBRUARY = 1;

  /// from: static public final int FRIDAY
  ///
  /// Value of the <code>DAY_OF_WEEK</code> field indicating
  /// Friday.
  static const FRIDAY = 6;

  /// from: static protected final int GREATEST_MINIMUM
  ///
  /// Limit type for <code>getLimit()</code> and <code>handleGetLimit()</code>
  /// indicating the greatest minimum value that a field can take.
  ///@see \#getLimit
  ///@see \#handleGetLimit
  static const GREATEST_MINIMUM = 1;

  /// from: static public final int HOUR
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the
  /// hour of the morning or afternoon. <code>HOUR</code> is used for the 12-hour
  /// clock.
  /// E.g., at 10:04:15.250 PM the <code>HOUR</code> is 10.
  ///@see \#AM_PM
  ///@see \#HOUR_OF_DAY
  static const HOUR = 10;

  /// from: static public final int HOUR_OF_DAY
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the
  /// hour of the day. <code>HOUR_OF_DAY</code> is used for the 24-hour clock.
  /// E.g., at 10:04:15.250 PM the <code>HOUR_OF_DAY</code> is 22.
  ///@see \#HOUR
  static const HOUR_OF_DAY = 11;

  /// from: static protected final int INTERNALLY_SET
  ///
  /// Value of the time stamp <code>stamp[]</code> indicating that a field
  /// has been set via computations from the time or from other fields.
  ///@see \#UNSET
  ///@see \#MINIMUM_USER_STAMP
  static const INTERNALLY_SET = 1;

  /// from: static public final int IS_LEAP_MONTH
  ///
  /// <strong>[icu]</strong> Field indicating whether or not the current month is a leap month.
  /// Should have a value of 0 for non-leap months, and 1 for leap months.
  static const IS_LEAP_MONTH = 22;

  /// from: static public final int JANUARY
  ///
  /// Value of the <code>MONTH</code> field indicating the
  /// first month of the year.
  static const JANUARY = 0;

  /// from: static protected final int JAN_1_1_JULIAN_DAY
  ///
  /// The Julian day of the Gregorian epoch, that is, January 1, 1 on the
  /// Gregorian calendar.
  static const JAN_1_1_JULIAN_DAY = 1721426;

  /// from: static public final int JULIAN_DAY
  ///
  /// <strong>[icu]</strong> Field number for <code>get()</code> and <code>set()</code>
  /// indicating the modified Julian day number.  This is different from
  /// the conventional Julian day number in two regards.  First, it
  /// demarcates days at local zone midnight, rather than noon GMT.
  /// Second, it is a local number; that is, it depends on the local time
  /// zone.  It can be thought of as a single number that encompasses all
  /// the date-related fields.
  static const JULIAN_DAY = 20;

  /// from: static public final int JULY
  ///
  /// Value of the <code>MONTH</code> field indicating the
  /// seventh month of the year.
  static const JULY = 6;

  /// from: static public final int JUNE
  ///
  /// Value of the <code>MONTH</code> field indicating the
  /// sixth month of the year.
  static const JUNE = 5;

  /// from: static protected final int LEAST_MAXIMUM
  ///
  /// Limit type for <code>getLimit()</code> and <code>handleGetLimit()</code>
  /// indicating the least maximum value that a field can take.
  ///@see \#getLimit
  ///@see \#handleGetLimit
  static const LEAST_MAXIMUM = 2;

  /// from: static public final int MARCH
  ///
  /// Value of the <code>MONTH</code> field indicating the
  /// third month of the year.
  static const MARCH = 2;

  /// from: static protected final int MAXIMUM
  ///
  /// Limit type for <code>getLimit()</code> and <code>handleGetLimit()</code>
  /// indicating the maximum value that a field can take (greatest maximum).
  ///@see \#getLimit
  ///@see \#handleGetLimit
  static const MAXIMUM = 3;

  static final _id_MAX_DATE = jniAccessors.getStaticFieldIDOf(
      _classRef, "MAX_DATE", "Ljava/util/Date;");

  /// from: static protected final java.util.Date MAX_DATE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The maximum supported <code>Date</code>.  This value is equivalent
  /// to \#MAX_JULIAN and \#MAX_MILLIS.
  static jni.JniObject get MAX_DATE => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_MAX_DATE, jni.JniType.objectType)
      .object);

  /// from: static protected final int MAX_FIELD_COUNT
  ///
  /// The maximum number of fields possible.  Subclasses must not define
  /// more total fields than this number.
  ///@deprecated ICU 58 The numeric value may change over time, see ICU ticket \#12420.
  static const MAX_FIELD_COUNT = 32;

  /// from: static protected final int MAX_JULIAN
  ///
  /// The maximum supported Julian day.  This value is equivalent to
  /// \#MAX_MILLIS and \#MAX_DATE.
  ///@see \#JULIAN_DAY
  static const MAX_JULIAN = 2130706432;

  /// from: static protected final long MAX_MILLIS
  ///
  /// The maximum supported epoch milliseconds.  This value is equivalent
  /// to \#MAX_JULIAN and \#MAX_DATE.
  static const MAX_MILLIS = 183882168921600000;

  /// from: static public final int MAY
  ///
  /// Value of the <code>MONTH</code> field indicating the
  /// fifth month of the year.
  static const MAY = 4;

  /// from: static public final int MILLISECOND
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the
  /// millisecond within the second.
  /// E.g., at 10:04:15.250 PM the <code>MILLISECOND</code> is 250.
  static const MILLISECOND = 14;

  /// from: static public final int MILLISECONDS_IN_DAY
  ///
  /// <strong>[icu]</strong> Field number for <code>get()</code> and <code>set()</code>
  /// indicating the milliseconds in the day.  This ranges from 0 to
  /// 23:59:59.999 (regardless of DST).  This field behaves
  /// _exactly_ like a composite of all time-related fields, not
  /// including the zone fields.  As such, it also reflects
  /// discontinuities of those fields on DST transition days.  On a day of
  /// DST onset, it will jump forward.  On a day of DST cessation, it will
  /// jump backward.  This reflects the fact that is must be combined with
  /// the DST_OFFSET field to obtain a unique local time value.
  static const MILLISECONDS_IN_DAY = 21;

  /// from: static protected final int MINIMUM
  ///
  /// Limit type for <code>getLimit()</code> and <code>handleGetLimit()</code>
  /// indicating the minimum value that a field can take (least minimum).
  ///@see \#getLimit
  ///@see \#handleGetLimit
  static const MINIMUM = 0;

  /// from: static protected final int MINIMUM_USER_STAMP
  ///
  /// If the time stamp <code>stamp[]</code> has a value greater than or
  /// equal to <code>MINIMUM_USER_SET</code> then it has been set by the
  /// user via a call to <code>set()</code>.
  ///@see \#UNSET
  ///@see \#INTERNALLY_SET
  static const MINIMUM_USER_STAMP = 2;

  /// from: static public final int MINUTE
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the
  /// minute within the hour.
  /// E.g., at 10:04:15.250 PM the <code>MINUTE</code> is 4.
  static const MINUTE = 12;

  static final _id_MIN_DATE = jniAccessors.getStaticFieldIDOf(
      _classRef, "MIN_DATE", "Ljava/util/Date;");

  /// from: static protected final java.util.Date MIN_DATE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The minimum supported <code>Date</code>.  This value is equivalent
  /// to \#MIN_JULIAN and \#MIN_MILLIS.
  static jni.JniObject get MIN_DATE => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_MIN_DATE, jni.JniType.objectType)
      .object);

  /// from: static protected final int MIN_JULIAN
  ///
  /// The minimum supported Julian day.  This value is equivalent to
  /// \#MIN_MILLIS and \#MIN_DATE.
  ///@see \#JULIAN_DAY
  static const MIN_JULIAN = -2130706432;

  /// from: static protected final long MIN_MILLIS
  ///
  /// The minimum supported epoch milliseconds.  This value is equivalent
  /// to \#MIN_JULIAN and \#MIN_DATE.
  static const MIN_MILLIS = -184303902528000000;

  /// from: static public final int MONDAY
  ///
  /// Value of the <code>DAY_OF_WEEK</code> field indicating
  /// Monday.
  static const MONDAY = 2;

  /// from: static public final int MONTH
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the
  /// month. This is a calendar-specific value. The first month of the year is
  /// <code>JANUARY</code>; the last depends on the number of months in a year.
  ///@see \#JANUARY
  ///@see \#FEBRUARY
  ///@see \#MARCH
  ///@see \#APRIL
  ///@see \#MAY
  ///@see \#JUNE
  ///@see \#JULY
  ///@see \#AUGUST
  ///@see \#SEPTEMBER
  ///@see \#OCTOBER
  ///@see \#NOVEMBER
  ///@see \#DECEMBER
  ///@see \#UNDECIMBER
  static const MONTH = 2;

  /// from: static public final int NOVEMBER
  ///
  /// Value of the <code>MONTH</code> field indicating the
  /// eleventh month of the year.
  static const NOVEMBER = 10;

  /// from: static public final int OCTOBER
  ///
  /// Value of the <code>MONTH</code> field indicating the
  /// tenth month of the year.
  static const OCTOBER = 9;

  /// from: static protected final long ONE_DAY
  ///
  /// The number of milliseconds in one day.  Although ONE_DAY and
  /// ONE_WEEK can fit into ints, they must be longs in order to prevent
  /// arithmetic overflow when performing (bug 4173516).
  static const ONE_DAY = 86400000;

  /// from: static protected final int ONE_HOUR
  ///
  /// The number of milliseconds in one hour.
  static const ONE_HOUR = 3600000;

  /// from: static protected final int ONE_MINUTE
  ///
  /// The number of milliseconds in one minute.
  static const ONE_MINUTE = 60000;

  /// from: static protected final int ONE_SECOND
  ///
  /// The number of milliseconds in one second.
  static const ONE_SECOND = 1000;

  /// from: static protected final long ONE_WEEK
  ///
  /// The number of milliseconds in one week.  Although ONE_DAY and
  /// ONE_WEEK can fit into ints, they must be longs in order to prevent
  /// arithmetic overflow when performing (bug 4173516).
  static const ONE_WEEK = 604800000;

  /// from: static public final int PM
  ///
  /// Value of the <code>AM_PM</code> field indicating the
  /// period of the day from noon to just before midnight.
  static const PM = 1;

  /// from: static protected final int RESOLVE_REMAP
  ///
  /// Value to OR against resolve table field values for remapping.
  ///@see \#resolveFields
  static const RESOLVE_REMAP = 32;

  /// from: static public final int SATURDAY
  ///
  /// Value of the <code>DAY_OF_WEEK</code> field indicating
  /// Saturday.
  static const SATURDAY = 7;

  /// from: static public final int SECOND
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the
  /// second within the minute.
  /// E.g., at 10:04:15.250 PM the <code>SECOND</code> is 15.
  static const SECOND = 13;

  /// from: static public final int SEPTEMBER
  ///
  /// Value of the <code>MONTH</code> field indicating the
  /// ninth month of the year.
  static const SEPTEMBER = 8;

  /// from: static public final int SUNDAY
  ///
  /// Value of the <code>DAY_OF_WEEK</code> field indicating
  /// Sunday.
  static const SUNDAY = 1;

  /// from: static public final int THURSDAY
  ///
  /// Value of the <code>DAY_OF_WEEK</code> field indicating
  /// Thursday.
  static const THURSDAY = 5;

  /// from: static public final int TUESDAY
  ///
  /// Value of the <code>DAY_OF_WEEK</code> field indicating
  /// Tuesday.
  static const TUESDAY = 3;

  /// from: static public final int UNDECIMBER
  ///
  /// Value of the <code>MONTH</code> field indicating the
  /// thirteenth month of the year. Although GregorianCalendar
  /// does not use this value, lunar calendars do.
  static const UNDECIMBER = 12;

  /// from: static protected final int UNSET
  ///
  /// Value of the time stamp <code>stamp[]</code> indicating that
  /// a field has not been set since the last call to <code>clear()</code>.
  ///@see \#INTERNALLY_SET
  ///@see \#MINIMUM_USER_STAMP
  static const UNSET = 0;

  /// from: static public final int WALLTIME_FIRST
  ///
  /// <strong>[icu]</strong>Option used by \#setRepeatedWallTimeOption(int) and
  /// \#setSkippedWallTimeOption(int) specifying an ambiguous wall time
  /// to be interpreted as the earliest.
  ///@see \#setRepeatedWallTimeOption(int)
  ///@see \#getRepeatedWallTimeOption()
  ///@see \#setSkippedWallTimeOption(int)
  ///@see \#getSkippedWallTimeOption()
  static const WALLTIME_FIRST = 1;

  /// from: static public final int WALLTIME_LAST
  ///
  /// <strong>[icu]</strong>Option used by \#setRepeatedWallTimeOption(int) and
  /// \#setSkippedWallTimeOption(int) specifying an ambiguous wall time
  /// to be interpreted as the latest.
  ///@see \#setRepeatedWallTimeOption(int)
  ///@see \#getRepeatedWallTimeOption()
  ///@see \#setSkippedWallTimeOption(int)
  ///@see \#getSkippedWallTimeOption()
  static const WALLTIME_LAST = 0;

  /// from: static public final int WALLTIME_NEXT_VALID
  ///
  /// <strong>[icu]</strong>Option used by \#setSkippedWallTimeOption(int) specifying an
  /// ambiguous wall time to be interpreted as the next valid wall time.
  ///@see \#setSkippedWallTimeOption(int)
  ///@see \#getSkippedWallTimeOption()
  static const WALLTIME_NEXT_VALID = 2;

  /// from: static public final int WEDNESDAY
  ///
  /// Value of the <code>DAY_OF_WEEK</code> field indicating
  /// Wednesday.
  static const WEDNESDAY = 4;

  /// from: static public final int WEEK_OF_MONTH
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the
  /// week number within the current month.  The first week of the month, as
  /// defined by \#getFirstDayOfWeek() and
  /// \#getMinimalDaysInFirstWeek(), has value 1.  Subclasses define
  /// the value of \#WEEK_OF_MONTH for days before the first week of
  /// the month.
  ///@see \#getFirstDayOfWeek
  ///@see \#getMinimalDaysInFirstWeek
  static const WEEK_OF_MONTH = 4;

  /// from: static public final int WEEK_OF_YEAR
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the
  /// week number within the current year.  The first week of the year, as
  /// defined by \#getFirstDayOfWeek() and
  /// \#getMinimalDaysInFirstWeek(), has value 1.  Subclasses define
  /// the value of \#WEEK_OF_YEAR for days before the first week of
  /// the year.
  ///@see \#getFirstDayOfWeek
  ///@see \#getMinimalDaysInFirstWeek
  static const WEEK_OF_YEAR = 3;

  /// from: static public final int YEAR
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the
  /// year. This is a calendar-specific value; see subclass documentation.
  static const YEAR = 1;

  /// from: static public final int YEAR_WOY
  ///
  /// <strong>[icu]</strong> Field number for <code>get()</code> and <code>set()</code>
  /// indicating the extended year corresponding to the
  /// \#WEEK_OF_YEAR field.  This may be one greater or less
  /// than the value of \#EXTENDED_YEAR.
  static const YEAR_WOY = 17;

  /// from: static public final int ZONE_OFFSET
  ///
  /// Field number for <code>get</code> and <code>set</code> indicating the
  /// raw offset from GMT in milliseconds.
  static const ZONE_OFFSET = 15;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: protected void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a Calendar with the default time zone
  /// and the default <code>FORMAT</code> locale.
  ///@see TimeZone\#getDefault
  ///@see Category\#FORMAT
  Calendar()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/icu/util/TimeZone;Ljava/util/Locale;)V");

  /// from: protected void <init>(android.icu.util.TimeZone zone, java.util.Locale aLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a calendar with the specified time zone and locale.
  ///@param zone the time zone to use
  ///@param aLocale the locale for the week data
  Calendar.ctor1(timezone_.TimeZone zone, jni.JniObject aLocale)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [zone.reference, aLocale.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/icu/util/TimeZone;Landroid/icu/util/ULocale;)V");

  /// from: protected void <init>(android.icu.util.TimeZone zone, android.icu.util.ULocale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a calendar with the specified time zone and locale.
  ///@param zone the time zone to use
  ///@param locale the ulocale for the week data
  Calendar.ctor2(timezone_.TimeZone zone, ulocale_.ULocale locale)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [zone.reference, locale.reference]).object);

  static final _id_getInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getInstance", "()Landroid/icu/util/Calendar;");

  /// from: static public android.icu.util.Calendar getInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a calendar using the default time zone and locale.
  ///@return a Calendar.
  static Calendar getInstance() =>
      Calendar.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getInstance, jni.JniType.objectType, []).object);

  static final _id_getInstance1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getInstance",
      "(Landroid/icu/util/TimeZone;)Landroid/icu/util/Calendar;");

  /// from: static public android.icu.util.Calendar getInstance(android.icu.util.TimeZone zone)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a calendar using the specified time zone and default locale.
  ///@param zone the time zone to use
  ///@return a Calendar.
  static Calendar getInstance1(timezone_.TimeZone zone) =>
      Calendar.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getInstance1, jni.JniType.objectType, [zone.reference]).object);

  static final _id_getInstance2 = jniAccessors.getStaticMethodIDOf(_classRef,
      "getInstance", "(Ljava/util/Locale;)Landroid/icu/util/Calendar;");

  /// from: static public android.icu.util.Calendar getInstance(java.util.Locale aLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a calendar using the default time zone and specified locale.
  ///@param aLocale the locale for the week data
  ///@return a Calendar.
  static Calendar getInstance2(jni.JniObject aLocale) =>
      Calendar.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getInstance2,
          jni.JniType.objectType,
          [aLocale.reference]).object);

  static final _id_getInstance3 = jniAccessors.getStaticMethodIDOf(_classRef,
      "getInstance", "(Landroid/icu/util/ULocale;)Landroid/icu/util/Calendar;");

  /// from: static public android.icu.util.Calendar getInstance(android.icu.util.ULocale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a calendar using the default time zone and specified locale.
  ///@param locale the ulocale for the week data
  ///@return a Calendar.
  static Calendar getInstance3(ulocale_.ULocale locale) =>
      Calendar.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getInstance3, jni.JniType.objectType, [locale.reference]).object);

  static final _id_getInstance4 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getInstance",
      "(Landroid/icu/util/TimeZone;Ljava/util/Locale;)Landroid/icu/util/Calendar;");

  /// from: static public android.icu.util.Calendar getInstance(android.icu.util.TimeZone zone, java.util.Locale aLocale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a calendar with the specified time zone and locale.
  ///@param zone the time zone to use
  ///@param aLocale the locale for the week data
  ///@return a Calendar.
  static Calendar getInstance4(
          timezone_.TimeZone zone, jni.JniObject aLocale) =>
      Calendar.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getInstance4,
          jni.JniType.objectType,
          [zone.reference, aLocale.reference]).object);

  static final _id_getInstance5 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getInstance",
      "(Landroid/icu/util/TimeZone;Landroid/icu/util/ULocale;)Landroid/icu/util/Calendar;");

  /// from: static public android.icu.util.Calendar getInstance(android.icu.util.TimeZone zone, android.icu.util.ULocale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a calendar with the specified time zone and locale.
  ///@param zone the time zone to use
  ///@param locale the ulocale for the week data
  ///@return a Calendar.
  static Calendar getInstance5(
          timezone_.TimeZone zone, ulocale_.ULocale locale) =>
      Calendar.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getInstance5,
          jni.JniType.objectType,
          [zone.reference, locale.reference]).object);

  static final _id_getAvailableLocales = jniAccessors.getStaticMethodIDOf(
      _classRef, "getAvailableLocales", "()[Ljava/util/Locale;");

  /// from: static public java.util.Locale[] getAvailableLocales()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of locales for which Calendars are installed.
  ///@return the list of locales for which Calendars are installed.
  static jni.JniObject getAvailableLocales() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getAvailableLocales, jni.JniType.objectType, []).object);

  static final _id_getKeywordValuesForLocale = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getKeywordValuesForLocale",
      "(Ljava/lang/String;Landroid/icu/util/ULocale;Z)[Ljava/lang/String;");

  /// from: static public final java.lang.String[] getKeywordValuesForLocale(java.lang.String key, android.icu.util.ULocale locale, boolean commonlyUsed)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Given a key and a locale, returns an array of string values in a preferred
  /// order that would make a difference. These are all and only those values where
  /// the open (creation) of the service with the locale formed from the input locale
  /// plus input keyword and that value has different behavior than creation with the
  /// input locale alone.
  ///@param key one of the keys supported by this service.  For now, only
  ///                      "calendar" is supported.
  ///@param locale the locale
  ///@param commonlyUsed if set to true it will return only commonly used values
  ///                      with the given locale in preferred order.  Otherwise,
  ///                      it will return all the available values for the locale.
  ///@return an array of string values for the given key and the locale.
  static jni.JniObject getKeywordValuesForLocale(
          jni.JniString key, ulocale_.ULocale locale, bool commonlyUsed) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getKeywordValuesForLocale,
          jni.JniType.objectType,
          [key.reference, locale.reference, commonlyUsed]).object);

  static final _id_getTime =
      jniAccessors.getMethodIDOf(_classRef, "getTime", "()Ljava/util/Date;");

  /// from: public final java.util.Date getTime()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns this Calendar's current time.
  ///@return the current time.
  jni.JniObject getTime() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTime, jni.JniType.objectType, []).object);

  static final _id_setTime =
      jniAccessors.getMethodIDOf(_classRef, "setTime", "(Ljava/util/Date;)V");

  /// from: public final void setTime(java.util.Date date)
  ///
  /// Sets this Calendar's current time with the given Date.
  ///
  /// Note: Calling <code>setTime</code> with
  /// <code>Date(Long.MAX_VALUE)</code> or <code>Date(Long.MIN_VALUE)</code>
  /// may yield incorrect field values from \#get(int).
  ///@param date the given Date.
  void setTime(jni.JniObject date) => jniAccessors.callMethodWithArgs(
      reference, _id_setTime, jni.JniType.voidType, [date.reference]).check();

  static final _id_getTimeInMillis =
      jniAccessors.getMethodIDOf(_classRef, "getTimeInMillis", "()J");

  /// from: public long getTimeInMillis()
  ///
  /// Returns this Calendar's current time as a long.
  ///@return the current time as UTC milliseconds from the epoch.
  int getTimeInMillis() => jniAccessors.callMethodWithArgs(
      reference, _id_getTimeInMillis, jni.JniType.longType, []).long;

  static final _id_setTimeInMillis =
      jniAccessors.getMethodIDOf(_classRef, "setTimeInMillis", "(J)V");

  /// from: public void setTimeInMillis(long millis)
  ///
  /// Sets this Calendar's current time from the given long value.
  /// An IllegalIcuArgumentException is thrown when millis is outside the range permitted
  /// by a Calendar object when in strict mode.
  /// When in lenient mode the out of range values are pinned to their respective min/max.
  ///@param millis the new time in UTC milliseconds from the epoch.
  void setTimeInMillis(int millis) => jniAccessors.callMethodWithArgs(
      reference, _id_setTimeInMillis, jni.JniType.voidType, [millis]).check();

  static final _id_get0 = jniAccessors.getMethodIDOf(_classRef, "get", "(I)I");

  /// from: public final int get(int field)
  ///
  /// Returns the value for a given time field.
  ///@param field the given time field.
  ///@return the value for the given time field.
  int get0(int field) => jniAccessors.callMethodWithArgs(
      reference, _id_get0, jni.JniType.intType, [field]).integer;

  static final _id_internalGet =
      jniAccessors.getMethodIDOf(_classRef, "internalGet", "(I)I");

  /// from: protected final int internalGet(int field)
  ///
  /// Returns the value for a given time field.  This is an internal method
  /// for subclasses that does _not_ trigger any calculations.
  ///@param field the given time field.
  ///@return the value for the given time field.
  int internalGet(int field) => jniAccessors.callMethodWithArgs(
      reference, _id_internalGet, jni.JniType.intType, [field]).integer;

  static final _id_internalGet1 =
      jniAccessors.getMethodIDOf(_classRef, "internalGet", "(II)I");

  /// from: protected final int internalGet(int field, int defaultValue)
  ///
  /// Returns the value for a given time field, or return the given default
  /// value if the field is not set.  This is an internal method for
  /// subclasses that does _not_ trigger any calculations.
  ///@param field the given time field.
  ///@param defaultValue value to return if field is not set
  ///@return the value for the given time field of defaultValue if the
  /// field is unset
  int internalGet1(int field, int defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_internalGet1,
          jni.JniType.intType, [field, defaultValue]).integer;

  static final _id_set0 = jniAccessors.getMethodIDOf(_classRef, "set", "(II)V");

  /// from: public final void set(int field, int value)
  ///
  /// Sets the time field with the given value.
  ///@param field the given time field.
  ///@param value the value to be set for the given time field.
  void set0(int field, int value) => jniAccessors.callMethodWithArgs(
      reference, _id_set0, jni.JniType.voidType, [field, value]).check();

  static final _id_set1 =
      jniAccessors.getMethodIDOf(_classRef, "set", "(III)V");

  /// from: public final void set(int year, int month, int date)
  ///
  /// Sets the values for the fields year, month, and date.
  /// Previous values of other fields are retained.  If this is not desired,
  /// call \#clear() first.
  ///@param year the value used to set the YEAR time field.
  ///@param month the value used to set the MONTH time field.
  /// Month value is 0-based. e.g., 0 for January.
  ///@param date the value used to set the DATE time field.
  void set1(int year, int month, int date) => jniAccessors.callMethodWithArgs(
      reference, _id_set1, jni.JniType.voidType, [year, month, date]).check();

  static final _id_set2 =
      jniAccessors.getMethodIDOf(_classRef, "set", "(IIIII)V");

  /// from: public final void set(int year, int month, int date, int hour, int minute)
  ///
  /// Sets the values for the fields year, month, date, hour, and minute.
  /// Previous values of other fields are retained.  If this is not desired,
  /// call \#clear() first.
  ///@param year the value used to set the YEAR time field.
  ///@param month the value used to set the MONTH time field.
  /// Month value is 0-based. e.g., 0 for January.
  ///@param date the value used to set the DATE time field.
  ///@param hour the value used to set the HOUR_OF_DAY time field.
  ///@param minute the value used to set the MINUTE time field.
  void set2(int year, int month, int date, int hour, int minute) =>
      jniAccessors.callMethodWithArgs(reference, _id_set2, jni.JniType.voidType,
          [year, month, date, hour, minute]).check();

  static final _id_set3 =
      jniAccessors.getMethodIDOf(_classRef, "set", "(IIIIII)V");

  /// from: public final void set(int year, int month, int date, int hour, int minute, int second)
  ///
  /// Sets the values for the fields year, month, date, hour, minute, and second.
  /// Previous values of other fields are retained.  If this is not desired,
  /// call \#clear first.
  ///@param year the value used to set the YEAR time field.
  ///@param month the value used to set the MONTH time field.
  /// Month value is 0-based. e.g., 0 for January.
  ///@param date the value used to set the DATE time field.
  ///@param hour the value used to set the HOUR_OF_DAY time field.
  ///@param minute the value used to set the MINUTE time field.
  ///@param second the value used to set the SECOND time field.
  void set3(int year, int month, int date, int hour, int minute, int second) =>
      jniAccessors.callMethodWithArgs(reference, _id_set3, jni.JniType.voidType,
          [year, month, date, hour, minute, second]).check();

  static final _id_clear =
      jniAccessors.getMethodIDOf(_classRef, "clear", "()V");

  /// from: public final void clear()
  ///
  /// Clears the values of all the time fields.
  void clear() => jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniType.voidType, []).check();

  static final _id_clear1 =
      jniAccessors.getMethodIDOf(_classRef, "clear", "(I)V");

  /// from: public final void clear(int field)
  ///
  /// Clears the value in the given time field.
  ///@param field the time field to be cleared.
  void clear1(int field) => jniAccessors.callMethodWithArgs(
      reference, _id_clear1, jni.JniType.voidType, [field]).check();

  static final _id_isSet =
      jniAccessors.getMethodIDOf(_classRef, "isSet", "(I)Z");

  /// from: public final boolean isSet(int field)
  ///
  /// Determines if the given time field has a value set.
  ///@return true if the given time field has a value set; false otherwise.
  bool isSet(int field) => jniAccessors.callMethodWithArgs(
      reference, _id_isSet, jni.JniType.booleanType, [field]).boolean;

  static final _id_complete =
      jniAccessors.getMethodIDOf(_classRef, "complete", "()V");

  /// from: protected void complete()
  ///
  /// Fills in any unset fields in the time field list.
  void complete() => jniAccessors.callMethodWithArgs(
      reference, _id_complete, jni.JniType.voidType, []).check();

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// Compares this calendar to the specified object.
  /// The result is <code>true</code> if and only if the argument is
  /// not <code>null</code> and is a <code>Calendar</code> object that
  /// represents the same calendar as this object.
  ///@param obj the object to compare with.
  ///@return <code>true</code> if the objects are the same;
  /// <code>false</code> otherwise.
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_isEquivalentTo = jniAccessors.getMethodIDOf(
      _classRef, "isEquivalentTo", "(Landroid/icu/util/Calendar;)Z");

  /// from: public boolean isEquivalentTo(android.icu.util.Calendar other)
  ///
  /// <strong>[icu]</strong> Returns true if the given Calendar object is equivalent to this
  /// one.  An equivalent Calendar will behave exactly as this one
  /// does, but it may be set to a different time.  By contrast, for
  /// the equals() method to return true, the other Calendar must
  /// be set to the same time.
  ///@param other the Calendar to be compared with this Calendar
  bool isEquivalentTo(Calendar other) => jniAccessors.callMethodWithArgs(
      reference,
      _id_isEquivalentTo,
      jni.JniType.booleanType,
      [other.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// Returns a hash code for this calendar.
  ///@return a hash code value for this object.
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_before =
      jniAccessors.getMethodIDOf(_classRef, "before", "(Ljava/lang/Object;)Z");

  /// from: public boolean before(java.lang.Object when)
  ///
  /// Compares the time field records.
  /// Equivalent to comparing result of conversion to UTC.
  ///@param when the Calendar to be compared with this Calendar.
  ///@return true if the current time of this Calendar is before
  /// the time of Calendar when; false otherwise.
  bool before(jni.JniObject when) => jniAccessors.callMethodWithArgs(
      reference, _id_before, jni.JniType.booleanType, [when.reference]).boolean;

  static final _id_after =
      jniAccessors.getMethodIDOf(_classRef, "after", "(Ljava/lang/Object;)Z");

  /// from: public boolean after(java.lang.Object when)
  ///
  /// Compares the time field records.
  /// Equivalent to comparing result of conversion to UTC.
  ///@param when the Calendar to be compared with this Calendar.
  ///@return true if the current time of this Calendar is after
  /// the time of Calendar when; false otherwise.
  bool after(jni.JniObject when) => jniAccessors.callMethodWithArgs(
      reference, _id_after, jni.JniType.booleanType, [when.reference]).boolean;

  static final _id_getActualMaximum =
      jniAccessors.getMethodIDOf(_classRef, "getActualMaximum", "(I)I");

  /// from: public int getActualMaximum(int field)
  ///
  /// Returns the maximum value that this field could have, given the
  /// current date.  For example, with the Gregorian date February 3, 1997
  /// and the \#DAY_OF_MONTH DAY_OF_MONTH field, the actual maximum
  /// is 28; for February 3, 1996 it is 29.
  ///
  /// The actual maximum computation ignores smaller fields and the
  /// current value of like-sized fields.  For example, the actual maximum
  /// of the DAY_OF_YEAR or MONTH depends only on the year and supra-year
  /// fields.  The actual maximum of the DAY_OF_MONTH depends, in
  /// addition, on the MONTH field and any other fields at that
  /// granularity (such as IS_LEAP_MONTH).  The
  /// DAY_OF_WEEK_IN_MONTH field does not depend on the current
  /// DAY_OF_WEEK; it returns the maximum for any day of week in the
  /// current month.  Likewise for the WEEK_OF_MONTH and WEEK_OF_YEAR
  /// fields.
  ///@param field the field whose maximum is desired
  ///@return the maximum of the given field for the current date of this calendar
  ///@see \#getMaximum
  ///@see \#getLeastMaximum
  int getActualMaximum(int field) => jniAccessors.callMethodWithArgs(
      reference, _id_getActualMaximum, jni.JniType.intType, [field]).integer;

  static final _id_getActualMinimum =
      jniAccessors.getMethodIDOf(_classRef, "getActualMinimum", "(I)I");

  /// from: public int getActualMinimum(int field)
  ///
  /// Returns the minimum value that this field could have, given the current date.
  /// For most fields, this is the same as \#getMinimum getMinimum
  /// and \#getGreatestMinimum getGreatestMinimum.  However, some fields,
  /// especially those related to week number, are more complicated.
  ///
  /// For example, assume \#getMinimalDaysInFirstWeek getMinimalDaysInFirstWeek
  /// returns 4 and \#getFirstDayOfWeek getFirstDayOfWeek returns SUNDAY.
  /// If the first day of the month is Sunday, Monday, Tuesday, or Wednesday
  /// there will be four or more days in the first week, so it will be week number 1,
  /// and <code>getActualMinimum(WEEK_OF_MONTH)</code> will return 1.  However,
  /// if the first of the month is a Thursday, Friday, or Saturday, there are
  /// _not_ four days in that week, so it is week number 0, and
  /// <code>getActualMinimum(WEEK_OF_MONTH)</code> will return 0.
  ///
  ///@param field the field whose actual minimum value is desired.
  ///@return the minimum of the given field for the current date of this calendar
  ///@see \#getMinimum
  ///@see \#getGreatestMinimum
  int getActualMinimum(int field) => jniAccessors.callMethodWithArgs(
      reference, _id_getActualMinimum, jni.JniType.intType, [field]).integer;

  static final _id_prepareGetActual =
      jniAccessors.getMethodIDOf(_classRef, "prepareGetActual", "(IZ)V");

  /// from: protected void prepareGetActual(int field, boolean isMinimum)
  ///
  /// Prepare this calendar for computing the actual minimum or maximum.
  /// This method modifies this calendar's fields; it is called on a
  /// temporary calendar.
  ///
  /// Rationale: The semantics of getActualXxx() is to return the
  /// maximum or minimum value that the given field can take, taking into
  /// account other relevant fields.  In general these other fields are
  /// larger fields.  For example, when computing the actual maximum
  /// DAY_OF_MONTH, the current value of DAY_OF_MONTH itself is ignored,
  /// as is the value of any field smaller.
  ///
  /// The time fields all have fixed minima and maxima, so we don't
  /// need to worry about them.  This also lets us set the
  /// MILLISECONDS_IN_DAY to zero to erase any effects the time fields
  /// might have when computing date fields.
  ///
  /// DAY_OF_WEEK is adjusted specially for the WEEK_OF_MONTH and
  /// WEEK_OF_YEAR fields to ensure that they are computed correctly.
  void prepareGetActual(int field, bool isMinimum) =>
      jniAccessors.callMethodWithArgs(reference, _id_prepareGetActual,
          jni.JniType.voidType, [field, isMinimum]).check();

  static final _id_roll =
      jniAccessors.getMethodIDOf(_classRef, "roll", "(IZ)V");

  /// from: public final void roll(int field, boolean up)
  ///
  /// Rolls (up/down) a single unit of time on the given field.  If the
  /// field is rolled past its maximum allowable value, it will "wrap" back
  /// to its minimum and continue rolling. For
  /// example, to roll the current date up by one day, you can call:
  ///
  /// <code>roll(\#DATE, true)</code>
  ///
  /// When rolling on the \#YEAR field, it will roll the year
  /// value in the range between 1 and the value returned by calling
  /// \#getMaximum getMaximum(\#YEAR).
  ///
  /// When rolling on certain fields, the values of other fields may conflict and
  /// need to be changed.  For example, when rolling the <code>MONTH</code> field
  /// for the Gregorian date 1/31/96 upward, the <code>DAY_OF_MONTH</code> field
  /// must be adjusted so that the result is 2/29/96 rather than the invalid
  /// 2/31/96.
  ///
  /// Rolling up always means rolling forward in time (unless
  /// the limit of the field is reached, in which case it may pin or wrap), so for the
  /// Gregorian calendar, starting with 100 BC and rolling the year up results in 99 BC.
  /// When eras have a definite beginning and end (as in the Chinese calendar, or as in
  /// most eras in the Japanese calendar) then rolling the year past either limit of the
  /// era will cause the year to wrap around. When eras only have a limit at one end,
  /// then attempting to roll the year past that limit will result in pinning the year
  /// at that limit. Note that for most calendars in which era 0 years move forward in
  /// time (such as Buddhist, Hebrew, or Islamic), it is possible for add or roll to
  /// result in negative years for era 0 (that is the only way to represent years before
  /// the calendar epoch in such calendars).
  ///
  /// __Note:__ Calling <tt>roll(field, true)</tt> N times is _not_
  /// necessarily equivalent to calling <tt>roll(field, N)</tt>.  For example,
  /// imagine that you start with the date Gregorian date January 31, 1995.  If you call
  /// <tt>roll(Calendar.MONTH, 2)</tt>, the result will be March 31, 1995.
  /// But if you call <tt>roll(Calendar.MONTH, true)</tt>, the result will be
  /// February 28, 1995.  Calling it one more time will give March 28, 1995, which
  /// is usually not the desired result.
  ///
  /// __Note:__ You should always use <tt>roll</tt> and <tt>add</tt> rather
  /// than attempting to perform arithmetic operations directly on the fields
  /// of a <tt>Calendar</tt>.  It is quite possible for <tt>Calendar</tt> subclasses
  /// to have fields with non-linear behavior, for example missing months
  /// or days during non-leap years.  The subclasses' <tt>add</tt> and <tt>roll</tt>
  /// methods will take this into account, while simple arithmetic manipulations
  /// may give invalid results.
  ///
  ///@param field the calendar field to roll.
  ///@param up indicates if the value of the specified time field is to be
  ///              rolled up or rolled down. Use <code>true</code> if rolling up,
  ///              <code>false</code> otherwise.
  ///@exception IllegalArgumentException if the field is invalid or refers
  ///              to a field that cannot be handled by this method.
  ///@see \#roll(int, int)
  ///@see \#add
  void roll(int field, bool up) => jniAccessors.callMethodWithArgs(
      reference, _id_roll, jni.JniType.voidType, [field, up]).check();

  static final _id_roll1 =
      jniAccessors.getMethodIDOf(_classRef, "roll", "(II)V");

  /// from: public void roll(int field, int amount)
  ///
  /// Rolls (up/down) a specified amount time on the given field.  For
  /// example, to roll the current date up by three days, you can call
  /// <code>roll(Calendar.DATE, 3)</code>.  If the
  /// field is rolled past its maximum allowable value, it will "wrap" back
  /// to its minimum and continue rolling.
  /// For example, calling <code>roll(Calendar.DATE, 10)</code>
  /// on a Gregorian calendar set to 4/25/96 will result in the date 4/5/96.
  ///
  /// When rolling on certain fields, the values of other fields may conflict and
  /// need to be changed.  For example, when rolling the \#MONTH MONTH field
  /// for the Gregorian date 1/31/96 by +1, the \#DAY_OF_MONTH DAY_OF_MONTH field
  /// must be adjusted so that the result is 2/29/96 rather than the invalid
  /// 2/31/96.
  ///
  /// Rolling by a positive value always means rolling forward in time (unless
  /// the limit of the field is reached, in which case it may pin or wrap), so for the
  /// Gregorian calendar, starting with 100 BC and rolling the year by + 1 results in 99 BC.
  /// When eras have a definite beginning and end (as in the Chinese calendar, or as in
  /// most eras in the Japanese calendar) then rolling the year past either limit of the
  /// era will cause the year to wrap around. When eras only have a limit at one end,
  /// then attempting to roll the year past that limit will result in pinning the year
  /// at that limit. Note that for most calendars in which era 0 years move forward in
  /// time (such as Buddhist, Hebrew, or Islamic), it is possible for add or roll to
  /// result in negative years for era 0 (that is the only way to represent years before
  /// the calendar epoch in such calendars).
  ///
  /// <strong>[icu] Note:</strong> the ICU implementation of this method is able to roll
  /// all fields except for \#ERA ERA, \#DST_OFFSET DST_OFFSET,
  /// and \#ZONE_OFFSET ZONE_OFFSET.  Subclasses may, of course, add support for
  /// additional fields in their overrides of <code>roll</code>.
  ///
  /// __Note:__ You should always use <tt>roll</tt> and <tt>add</tt> rather
  /// than attempting to perform arithmetic operations directly on the fields
  /// of a <tt>Calendar</tt>.  It is quite possible for <tt>Calendar</tt> subclasses
  /// to have fields with non-linear behavior, for example missing months
  /// or days during non-leap years.  The subclasses' <tt>add</tt> and <tt>roll</tt>
  /// methods will take this into account, while simple arithmetic manipulations
  /// may give invalid results.
  ///
  /// __Subclassing:__<br>
  /// This implementation of <code>roll</code> assumes that the behavior of the
  /// field is continuous between its minimum and maximum, which are found by
  /// calling \#getActualMinimum getActualMinimum and \#getActualMaximum getActualMaximum.
  /// For most such fields, simple addition, subtraction, and modulus operations
  /// are sufficient to perform the roll.  For week-related fields,
  /// the results of \#getFirstDayOfWeek getFirstDayOfWeek and
  /// \#getMinimalDaysInFirstWeek getMinimalDaysInFirstWeek are also necessary.
  /// Subclasses can override these two methods if their values differ from the defaults.
  ///
  /// Subclasses that have fields for which the assumption of continuity breaks
  /// down must overide <code>roll</code> to handle those fields specially.
  /// For example, in the Hebrew calendar the month "Adar I"
  /// only occurs in leap years; in other years the calendar jumps from
  /// Shevat (month \#4) to Adar (month \#6).  The
  /// HebrewCalendar\#roll HebrewCalendar.roll method takes this into account,
  /// so that rolling the month of Shevat by one gives the proper result (Adar) in a
  /// non-leap year.
  ///
  ///@param field the calendar field to roll.
  ///@param amount the amount by which the field should be rolled.
  ///@exception IllegalArgumentException if the field is invalid or refers
  ///              to a field that cannot be handled by this method.
  ///@see \#roll(int, boolean)
  ///@see \#add
  void roll1(int field, int amount) => jniAccessors.callMethodWithArgs(
      reference, _id_roll1, jni.JniType.voidType, [field, amount]).check();

  static final _id_add = jniAccessors.getMethodIDOf(_classRef, "add", "(II)V");

  /// from: public void add(int field, int amount)
  ///
  /// Add a signed amount to a specified field, using this calendar's rules.
  /// For example, to add three days to the current date, you can call
  /// <code>add(Calendar.DATE, 3)</code>.
  ///
  /// When adding to certain fields, the values of other fields may conflict and
  /// need to be changed.  For example, when adding one to the \#MONTH MONTH field
  /// for the Gregorian date 1/31/96, the \#DAY_OF_MONTH DAY_OF_MONTH field
  /// must be adjusted so that the result is 2/29/96 rather than the invalid
  /// 2/31/96.
  ///
  /// Adding a positive value always means moving forward in time, so for the Gregorian
  /// calendar, starting with 100 BC and adding +1 to year results in 99 BC (even though
  /// this actually reduces the numeric value of the field itself).
  ///
  /// <strong>[icu] Note:</strong> The ICU implementation of this method is able to add to
  /// all fields except for \#ERA ERA, \#DST_OFFSET DST_OFFSET,
  /// and \#ZONE_OFFSET ZONE_OFFSET.  Subclasses may, of course, add support for
  /// additional fields in their overrides of <code>add</code>.
  ///
  /// __Note:__ You should always use <tt>roll</tt> and <tt>add</tt> rather
  /// than attempting to perform arithmetic operations directly on the fields
  /// of a <tt>Calendar</tt>.  It is quite possible for <tt>Calendar</tt> subclasses
  /// to have fields with non-linear behavior, for example missing months
  /// or days during non-leap years.  The subclasses' <tt>add</tt> and <tt>roll</tt>
  /// methods will take this into account, while simple arithmetic manipulations
  /// may give invalid results.
  ///
  /// __Subclassing:__<br>
  /// This implementation of <code>add</code> assumes that the behavior of the
  /// field is continuous between its minimum and maximum, which are found by
  /// calling \#getActualMinimum getActualMinimum and
  /// \#getActualMaximum getActualMaximum.
  /// For such fields, simple arithmetic operations are sufficient to
  /// perform the add.
  ///
  /// Subclasses that have fields for which this assumption of continuity breaks
  /// down must overide <code>add</code> to handle those fields specially.
  /// For example, in the Hebrew calendar the month "Adar I"
  /// only occurs in leap years; in other years the calendar jumps from
  /// Shevat (month \#4) to Adar (month \#6).  The
  /// HebrewCalendar\#add HebrewCalendar.add method takes this into account,
  /// so that adding one month
  /// to a date in Shevat gives the proper result (Adar) in a non-leap year.
  ///
  ///@param field the time field.
  ///@param amount the amount to add to the field.
  ///@exception IllegalArgumentException if the field is invalid or refers
  ///              to a field that cannot be handled by this method.
  ///@see \#roll(int, int)
  void add(int field, int amount) => jniAccessors.callMethodWithArgs(
      reference, _id_add, jni.JniType.voidType, [field, amount]).check();

  static final _id_getDisplayName = jniAccessors.getMethodIDOf(
      _classRef, "getDisplayName", "(Ljava/util/Locale;)Ljava/lang/String;");

  /// from: public java.lang.String getDisplayName(java.util.Locale loc)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name of this calendar in the language of the given locale.
  jni.JniString getDisplayName(jni.JniObject loc) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDisplayName, jni.JniType.objectType, [loc.reference]).object);

  static final _id_getDisplayName1 = jniAccessors.getMethodIDOf(_classRef,
      "getDisplayName", "(Landroid/icu/util/ULocale;)Ljava/lang/String;");

  /// from: public java.lang.String getDisplayName(android.icu.util.ULocale loc)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name of this calendar in the language of the given locale.
  jni.JniString getDisplayName1(ulocale_.ULocale loc) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDisplayName1, jni.JniType.objectType, [loc.reference]).object);

  static final _id_compareTo = jniAccessors.getMethodIDOf(
      _classRef, "compareTo", "(Landroid/icu/util/Calendar;)I");

  /// from: public int compareTo(android.icu.util.Calendar that)
  ///
  /// Compares the times (in millis) represented by two
  /// <code>Calendar</code> objects.
  ///@param that the <code>Calendar</code> to compare to this.
  ///@return <code>0</code> if the time represented by
  /// this <code>Calendar</code> is equal to the time represented
  /// by that <code>Calendar</code>, a value less than
  /// <code>0</code> if the time represented by this is before
  /// the time represented by that, and a value greater than
  /// <code>0</code> if the time represented by this
  /// is after the time represented by that.
  ///@throws NullPointerException if that
  /// <code>Calendar</code> is null.
  ///@throws IllegalArgumentException if the time of that
  /// <code>Calendar</code> can't be obtained because of invalid
  /// calendar values.
  int compareTo(Calendar that) => jniAccessors.callMethodWithArgs(
      reference, _id_compareTo, jni.JniType.intType, [that.reference]).integer;

  static final _id_getDateTimeFormat = jniAccessors.getMethodIDOf(
      _classRef,
      "getDateTimeFormat",
      "(IILjava/util/Locale;)Landroid/icu/text/DateFormat;");

  /// from: public android.icu.text.DateFormat getDateTimeFormat(int dateStyle, int timeStyle, java.util.Locale loc)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns a <code>DateFormat</code> appropriate to this calendar.
  /// Subclasses wishing to specialize this behavior should override
  /// \#handleGetDateFormat.
  dateformat_.DateFormat getDateTimeFormat(
          int dateStyle, int timeStyle, jni.JniObject loc) =>
      dateformat_.DateFormat.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDateTimeFormat,
          jni.JniType.objectType,
          [dateStyle, timeStyle, loc.reference]).object);

  static final _id_getDateTimeFormat1 = jniAccessors.getMethodIDOf(
      _classRef,
      "getDateTimeFormat",
      "(IILandroid/icu/util/ULocale;)Landroid/icu/text/DateFormat;");

  /// from: public android.icu.text.DateFormat getDateTimeFormat(int dateStyle, int timeStyle, android.icu.util.ULocale loc)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns a <code>DateFormat</code> appropriate to this calendar.
  /// Subclasses wishing to specialize this behavior should override
  /// \#handleGetDateFormat.
  dateformat_.DateFormat getDateTimeFormat1(
          int dateStyle, int timeStyle, ulocale_.ULocale loc) =>
      dateformat_.DateFormat.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDateTimeFormat1,
          jni.JniType.objectType,
          [dateStyle, timeStyle, loc.reference]).object);

  static final _id_handleGetDateFormat = jniAccessors.getMethodIDOf(
      _classRef,
      "handleGetDateFormat",
      "(Ljava/lang/String;Ljava/util/Locale;)Landroid/icu/text/DateFormat;");

  /// from: protected android.icu.text.DateFormat handleGetDateFormat(java.lang.String pattern, java.util.Locale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a <code>DateFormat</code> appropriate to this calendar.
  /// This is a framework method for subclasses to override.  This method
  /// is responsible for creating the calendar-specific DateFormat and
  /// DateFormatSymbols objects as needed.
  ///@param pattern the pattern, specific to the <code>DateFormat</code>
  /// subclass
  ///@param locale the locale for which the symbols should be drawn
  ///@return a <code>DateFormat</code> appropriate to this calendar
  dateformat_.DateFormat handleGetDateFormat(
          jni.JniString pattern, jni.JniObject locale) =>
      dateformat_.DateFormat.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_handleGetDateFormat,
          jni.JniType.objectType,
          [pattern.reference, locale.reference]).object);

  static final _id_handleGetDateFormat1 = jniAccessors.getMethodIDOf(
      _classRef,
      "handleGetDateFormat",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/util/Locale;)Landroid/icu/text/DateFormat;");

  /// from: protected android.icu.text.DateFormat handleGetDateFormat(java.lang.String pattern, java.lang.String override, java.util.Locale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a <code>DateFormat</code> appropriate to this calendar.
  /// This is a framework method for subclasses to override.  This method
  /// is responsible for creating the calendar-specific DateFormat and
  /// DateFormatSymbols objects as needed.
  ///@param pattern the pattern, specific to the <code>DateFormat</code>
  /// subclass
  ///@param override The override string.  A numbering system override string can take one of the following forms:
  ///     1). If just a numbering system name is specified, it applies to all numeric fields in the date format pattern.
  ///     2). To specify an alternate numbering system on a field by field basis, use the field letters from the pattern
  ///         followed by an = sign, followed by the numbering system name.  For example, to specify that just the year
  ///         be formatted using Hebrew digits, use the override "y=hebr".  Multiple overrides can be specified in a single
  ///         string by separating them with a semi-colon. For example, the override string "m=thai;y=deva" would format using
  ///         Thai digits for the month and Devanagari digits for the year.
  ///@param locale the locale for which the symbols should be drawn
  ///@return a <code>DateFormat</code> appropriate to this calendar
  dateformat_.DateFormat handleGetDateFormat1(jni.JniString pattern,
          jni.JniString override, jni.JniObject locale) =>
      dateformat_.DateFormat.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_handleGetDateFormat1,
          jni.JniType.objectType,
          [pattern.reference, override.reference, locale.reference]).object);

  static final _id_handleGetDateFormat2 = jniAccessors.getMethodIDOf(
      _classRef,
      "handleGetDateFormat",
      "(Ljava/lang/String;Landroid/icu/util/ULocale;)Landroid/icu/text/DateFormat;");

  /// from: protected android.icu.text.DateFormat handleGetDateFormat(java.lang.String pattern, android.icu.util.ULocale locale)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a <code>DateFormat</code> appropriate to this calendar.
  /// This is a framework method for subclasses to override.  This method
  /// is responsible for creating the calendar-specific DateFormat and
  /// DateFormatSymbols objects as needed.
  ///@param pattern the pattern, specific to the <code>DateFormat</code>
  /// subclass
  ///@param locale the locale for which the symbols should be drawn
  ///@return a <code>DateFormat</code> appropriate to this calendar
  dateformat_.DateFormat handleGetDateFormat2(
          jni.JniString pattern, ulocale_.ULocale locale) =>
      dateformat_.DateFormat.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_handleGetDateFormat2,
          jni.JniType.objectType,
          [pattern.reference, locale.reference]).object);

  static final _id_pinField =
      jniAccessors.getMethodIDOf(_classRef, "pinField", "(I)V");

  /// from: protected void pinField(int field)
  ///
  /// Adjust the specified field so that it is within
  /// the allowable range for the date to which this calendar is set.
  /// For example, in a Gregorian calendar pinning the \#DAY_OF_MONTH DAY_OF_MONTH
  /// field for a calendar set to April 31 would cause it to be set
  /// to April 30.
  ///
  /// __Subclassing:__
  /// <br>
  /// This utility method is intended for use by subclasses that need to implement
  /// their own overrides of \#roll roll and \#add add.
  ///
  /// __Note:__
  /// <code>pinField</code> is implemented in terms of
  /// \#getActualMinimum getActualMinimum
  /// and \#getActualMaximum getActualMaximum.  If either of those methods uses
  /// a slow, iterative algorithm for a particular field, it would be
  /// unwise to attempt to call <code>pinField</code> for that field.  If you
  /// really do need to do so, you should override this method to do
  /// something more efficient for that field.
  ///
  ///@param field The calendar field whose value should be pinned.
  ///@see \#getActualMinimum
  ///@see \#getActualMaximum
  void pinField(int field) => jniAccessors.callMethodWithArgs(
      reference, _id_pinField, jni.JniType.voidType, [field]).check();

  static final _id_weekNumber =
      jniAccessors.getMethodIDOf(_classRef, "weekNumber", "(III)I");

  /// from: protected int weekNumber(int desiredDay, int dayOfPeriod, int dayOfWeek)
  ///
  /// Returns the week number of a day, within a period. This may be the week number in
  /// a year or the week number in a month. Usually this will be a value &gt;= 1, but if
  /// some initial days of the period are excluded from week 1, because
  /// \#getMinimalDaysInFirstWeek getMinimalDaysInFirstWeek is &gt; 1, then
  /// the week number will be zero for those
  /// initial days. This method requires the day number and day of week for some
  /// known date in the period in order to determine the day of week
  /// on the desired day.
  ///
  /// __Subclassing:__
  /// <br>
  /// This method is intended for use by subclasses in implementing their
  /// \#computeTime computeTime and/or \#computeFields computeFields methods.
  /// It is often useful in \#getActualMinimum getActualMinimum and
  /// \#getActualMaximum getActualMaximum as well.
  ///
  /// This variant is handy for computing the week number of some other
  /// day of a period (often the first or last day of the period) when its day
  /// of the week is not known but the day number and day of week for some other
  /// day in the period (e.g. the current date) _is_ known.
  ///
  ///@param desiredDay The \#DAY_OF_YEAR DAY_OF_YEAR or
  ///              \#DAY_OF_MONTH DAY_OF_MONTH whose week number is desired.
  ///              Should be 1 for the first day of the period.
  ///@param dayOfPeriod The \#DAY_OF_YEAR DAY_OF_YEAR
  ///              or \#DAY_OF_MONTH DAY_OF_MONTH for a day in the period whose
  ///              \#DAY_OF_WEEK DAY_OF_WEEK is specified by the
  ///              <code>dayOfWeek</code> parameter.
  ///              Should be 1 for first day of period.
  ///@param dayOfWeek The \#DAY_OF_WEEK DAY_OF_WEEK for the day
  ///              corresponding to the <code>dayOfPeriod</code> parameter.
  ///              1-based with 1=Sunday.
  ///@return The week number (one-based), or zero if the day falls before
  ///              the first week because
  ///              \#getMinimalDaysInFirstWeek getMinimalDaysInFirstWeek
  ///              is more than one.
  int weekNumber(int desiredDay, int dayOfPeriod, int dayOfWeek) =>
      jniAccessors.callMethodWithArgs(reference, _id_weekNumber,
          jni.JniType.intType, [desiredDay, dayOfPeriod, dayOfWeek]).integer;

  static final _id_weekNumber1 =
      jniAccessors.getMethodIDOf(_classRef, "weekNumber", "(II)I");

  /// from: protected final int weekNumber(int dayOfPeriod, int dayOfWeek)
  ///
  /// Returns the week number of a day, within a period. This may be the week number in
  /// a year, or the week number in a month. Usually this will be a value &gt;= 1, but if
  /// some initial days of the period are excluded from week 1, because
  /// \#getMinimalDaysInFirstWeek getMinimalDaysInFirstWeek is &gt; 1,
  /// then the week number will be zero for those
  /// initial days. This method requires the day of week for the given date in order to
  /// determine the result.
  ///
  /// __Subclassing:__
  /// <br>
  /// This method is intended for use by subclasses in implementing their
  /// \#computeTime computeTime and/or \#computeFields computeFields methods.
  /// It is often useful in \#getActualMinimum getActualMinimum and
  /// \#getActualMaximum getActualMaximum as well.
  ///
  ///@param dayOfPeriod The \#DAY_OF_YEAR DAY_OF_YEAR or
  ///                      \#DAY_OF_MONTH DAY_OF_MONTH whose week number is desired.
  ///                      Should be 1 for the first day of the period.
  ///@param dayOfWeek The \#DAY_OF_WEEK DAY_OF_WEEK for the day
  ///                      corresponding to the <code>dayOfPeriod</code> parameter.
  ///                      1-based with 1=Sunday.
  ///@return The week number (one-based), or zero if the day falls before
  ///              the first week because
  ///              \#getMinimalDaysInFirstWeek getMinimalDaysInFirstWeek
  ///              is more than one.
  int weekNumber1(int dayOfPeriod, int dayOfWeek) =>
      jniAccessors.callMethodWithArgs(reference, _id_weekNumber1,
          jni.JniType.intType, [dayOfPeriod, dayOfWeek]).integer;

  static final _id_fieldDifference = jniAccessors.getMethodIDOf(
      _classRef, "fieldDifference", "(Ljava/util/Date;I)I");

  /// from: public int fieldDifference(java.util.Date when, int field)
  ///
  /// <strong>[icu]</strong> Returns the difference between the given time and the time this
  /// calendar object is set to.  If this calendar is set
  /// _before_ the given time, the returned value will be
  /// positive.  If this calendar is set _after_ the given
  /// time, the returned value will be negative.  The
  /// <code>field</code> parameter specifies the units of the return
  /// value.  For example, if <code>fieldDifference(when,
  /// Calendar.MONTH)</code> returns 3, then this calendar is set to
  /// 3 months before <code>when</code>, and possibly some additional
  /// time less than one month.
  ///
  /// As a side effect of this call, this calendar is advanced
  /// toward <code>when</code> by the given amount.  That is, calling
  /// this method has the side effect of calling <code>add(field,
  /// n)</code>, where <code>n</code> is the return value.
  ///
  /// Usage: To use this method, call it first with the largest
  /// field of interest, then with progressively smaller fields.  For
  /// example:
  ///
  /// <pre>
  /// int y = cal.fieldDifference(when, Calendar.YEAR);
  /// int m = cal.fieldDifference(when, Calendar.MONTH);
  /// int d = cal.fieldDifference(when, Calendar.DATE);</pre>
  ///
  /// computes the difference between <code>cal</code> and
  /// <code>when</code> in years, months, and days.
  ///
  /// Note: <code>fieldDifference()</code> is
  /// _asymmetrical_.  That is, in the following code:
  ///
  /// <pre>
  /// cal.setTime(date1);
  /// int m1 = cal.fieldDifference(date2, Calendar.MONTH);
  /// int d1 = cal.fieldDifference(date2, Calendar.DATE);
  /// cal.setTime(date2);
  /// int m2 = cal.fieldDifference(date1, Calendar.MONTH);
  /// int d2 = cal.fieldDifference(date1, Calendar.DATE);</pre>
  ///
  /// one might expect that <code>m1 == -m2 &amp;&amp; d1 == -d2</code>.
  /// However, this is not generally the case, because of
  /// irregularities in the underlying calendar system (e.g., the
  /// Gregorian calendar has a varying number of days per month).
  ///@param when the date to compare this calendar's time to
  ///@param field the field in which to compute the result
  ///@return the difference, either positive or negative, between
  /// this calendar's time and <code>when</code>, in terms of
  /// <code>field</code>.
  int fieldDifference(jni.JniObject when, int field) =>
      jniAccessors.callMethodWithArgs(reference, _id_fieldDifference,
          jni.JniType.intType, [when.reference, field]).integer;

  static final _id_setTimeZone = jniAccessors.getMethodIDOf(
      _classRef, "setTimeZone", "(Landroid/icu/util/TimeZone;)V");

  /// from: public void setTimeZone(android.icu.util.TimeZone value)
  ///
  /// Sets the time zone with the given time zone value.
  ///@param value the given time zone.
  void setTimeZone(timezone_.TimeZone value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTimeZone,
      jni.JniType.voidType,
      [value.reference]).check();

  static final _id_getTimeZone = jniAccessors.getMethodIDOf(
      _classRef, "getTimeZone", "()Landroid/icu/util/TimeZone;");

  /// from: public android.icu.util.TimeZone getTimeZone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the time zone.
  ///@return the time zone object associated with this calendar.
  timezone_.TimeZone getTimeZone() =>
      timezone_.TimeZone.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTimeZone, jni.JniType.objectType, []).object);

  static final _id_setLenient =
      jniAccessors.getMethodIDOf(_classRef, "setLenient", "(Z)V");

  /// from: public void setLenient(boolean lenient)
  ///
  /// Specify whether or not date/time interpretation is to be lenient.  With
  /// lenient interpretation, a date such as "February 942, 1996" will be
  /// treated as being equivalent to the 941st day after February 1, 1996.
  /// With strict interpretation, such dates will cause an exception to be
  /// thrown.
  ///@see DateFormat\#setLenient
  void setLenient(bool lenient) => jniAccessors.callMethodWithArgs(
      reference, _id_setLenient, jni.JniType.voidType, [lenient]).check();

  static final _id_isLenient =
      jniAccessors.getMethodIDOf(_classRef, "isLenient", "()Z");

  /// from: public boolean isLenient()
  ///
  /// Tell whether date/time interpretation is to be lenient.
  bool isLenient() => jniAccessors.callMethodWithArgs(
      reference, _id_isLenient, jni.JniType.booleanType, []).boolean;

  static final _id_setRepeatedWallTimeOption = jniAccessors.getMethodIDOf(
      _classRef, "setRepeatedWallTimeOption", "(I)V");

  /// from: public void setRepeatedWallTimeOption(int option)
  ///
  /// <strong>[icu]</strong>Sets the behavior for handling wall time repeating multiple times
  /// at negative time zone offset transitions. For example, 1:30 AM on
  /// November 6, 2011 in US Eastern time (Ameirca/New_York) occurs twice;
  /// 1:30 AM EDT, then 1:30 AM EST one hour later. When <code>WALLTIME_FIRST</code>
  /// is used, the wall time 1:30AM in this example will be interpreted as 1:30 AM EDT
  /// (first occurrence). When <code>WALLTIME_LAST</code> is used, it will be
  /// interpreted as 1:30 AM EST (last occurrence). The default value is
  /// <code>WALLTIME_LAST</code>.
  ///@param option the behavior for handling repeating wall time, either
  /// <code>WALLTIME_FIRST</code> or <code>WALLTIME_LAST</code>.
  ///@throws IllegalArgumentException when <code>option</code> is neither
  /// <code>WALLTIME_FIRST</code> nor <code>WALLTIME_LAST</code>.
  ///@see \#getRepeatedWallTimeOption()
  ///@see \#WALLTIME_FIRST
  ///@see \#WALLTIME_LAST
  void setRepeatedWallTimeOption(int option) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setRepeatedWallTimeOption,
      jni.JniType.voidType,
      [option]).check();

  static final _id_getRepeatedWallTimeOption =
      jniAccessors.getMethodIDOf(_classRef, "getRepeatedWallTimeOption", "()I");

  /// from: public int getRepeatedWallTimeOption()
  ///
  /// <strong>[icu]</strong>Gets the behavior for handling wall time repeating multiple times
  /// at negative time zone offset transitions.
  ///@return the behavior for handling repeating wall time, either
  /// <code>WALLTIME_FIRST</code> or <code>WALLTIME_LAST</code>.
  ///@see \#setRepeatedWallTimeOption(int)
  ///@see \#WALLTIME_FIRST
  ///@see \#WALLTIME_LAST
  int getRepeatedWallTimeOption() => jniAccessors.callMethodWithArgs(reference,
      _id_getRepeatedWallTimeOption, jni.JniType.intType, []).integer;

  static final _id_setSkippedWallTimeOption =
      jniAccessors.getMethodIDOf(_classRef, "setSkippedWallTimeOption", "(I)V");

  /// from: public void setSkippedWallTimeOption(int option)
  ///
  /// <strong>[icu]</strong>Sets the behavior for handling skipped wall time at positive time zone offset
  /// transitions. For example, 2:30 AM on March 13, 2011 in US Eastern time (America/New_York)
  /// does not exist because the wall time jump from 1:59 AM EST to 3:00 AM EDT. When
  /// <code>WALLTIME_FIRST</code> is used, 2:30 AM is interpreted as 30 minutes before 3:00 AM
  /// EDT, therefore, it will be resolved as 1:30 AM EST. When <code>WALLTIME_LAST</code>
  /// is used, 2:30 AM is interpreted as 31 minutes after 1:59 AM EST, therefore, it will be
  /// resolved as 3:30 AM EDT. When <code>WALLTIME_NEXT_VALID</code> is used, 2:30 AM will
  /// be resolved as next valid wall time, that is 3:00 AM EDT. The default value is
  /// <code>WALLTIME_LAST</code>.
  ///
  /// __Note:__This option is effective only when this calendar is \#isLenient() lenient.
  /// When the calendar is strict, such non-existing wall time will cause an exception.
  ///@param option the behavior for handling skipped wall time at positive time zone
  /// offset transitions, one of <code>WALLTIME_FIRST</code>, <code>WALLTIME_LAST</code> and
  /// <code>WALLTIME_NEXT_VALID</code>.
  ///@throws IllegalArgumentException when <code>option</code> is not any of
  /// <code>WALLTIME_FIRST</code>, <code>WALLTIME_LAST</code> and <code>WALLTIME_NEXT_VALID</code>.
  ///@see \#getSkippedWallTimeOption()
  ///@see \#WALLTIME_FIRST
  ///@see \#WALLTIME_LAST
  ///@see \#WALLTIME_NEXT_VALID
  void setSkippedWallTimeOption(int option) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSkippedWallTimeOption,
      jni.JniType.voidType,
      [option]).check();

  static final _id_getSkippedWallTimeOption =
      jniAccessors.getMethodIDOf(_classRef, "getSkippedWallTimeOption", "()I");

  /// from: public int getSkippedWallTimeOption()
  ///
  /// <strong>[icu]</strong>Gets the behavior for handling skipped wall time at positive time zone offset
  /// transitions.
  ///@return the behavior for handling skipped wall time, one of
  /// <code>WALLTIME_FIRST</code>, <code>WALLTIME_LAST</code> and <code>WALLTIME_NEXT_VALID</code>.
  ///@see \#setSkippedWallTimeOption(int)
  ///@see \#WALLTIME_FIRST
  ///@see \#WALLTIME_LAST
  ///@see \#WALLTIME_NEXT_VALID
  int getSkippedWallTimeOption() => jniAccessors.callMethodWithArgs(
      reference, _id_getSkippedWallTimeOption, jni.JniType.intType, []).integer;

  static final _id_setFirstDayOfWeek =
      jniAccessors.getMethodIDOf(_classRef, "setFirstDayOfWeek", "(I)V");

  /// from: public void setFirstDayOfWeek(int value)
  ///
  /// Sets what the first day of the week is,
  /// where 1 = \#SUNDAY and 7 = \#SATURDAY.
  ///@param value the given first day of the week, where 1 = \#SUNDAY and 7 = \#SATURDAY.
  void setFirstDayOfWeek(int value) => jniAccessors.callMethodWithArgs(
      reference, _id_setFirstDayOfWeek, jni.JniType.voidType, [value]).check();

  static final _id_getFirstDayOfWeek =
      jniAccessors.getMethodIDOf(_classRef, "getFirstDayOfWeek", "()I");

  /// from: public int getFirstDayOfWeek()
  ///
  /// Returns what the first day of the week is,
  /// where 1 = \#SUNDAY and 7 = \#SATURDAY.
  /// e.g., Sunday in US, Monday in France
  ///@return the first day of the week, where 1 = \#SUNDAY and 7 = \#SATURDAY.
  int getFirstDayOfWeek() => jniAccessors.callMethodWithArgs(
      reference, _id_getFirstDayOfWeek, jni.JniType.intType, []).integer;

  static final _id_setMinimalDaysInFirstWeek = jniAccessors.getMethodIDOf(
      _classRef, "setMinimalDaysInFirstWeek", "(I)V");

  /// from: public void setMinimalDaysInFirstWeek(int value)
  ///
  /// Sets what the minimal days required in the first week of the year are.
  /// For example, if the first week is defined as one that contains the first
  /// day of the first month of a year, call the method with value 1. If it
  /// must be a full week, use value 7.
  ///@param value the given minimal days required in the first week
  /// of the year.
  void setMinimalDaysInFirstWeek(int value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMinimalDaysInFirstWeek,
      jni.JniType.voidType,
      [value]).check();

  static final _id_getMinimalDaysInFirstWeek =
      jniAccessors.getMethodIDOf(_classRef, "getMinimalDaysInFirstWeek", "()I");

  /// from: public int getMinimalDaysInFirstWeek()
  ///
  /// Returns what the minimal days required in the first week of the year are.
  /// That is, if the first week is defined as one that contains the first day
  /// of the first month of a year, getMinimalDaysInFirstWeek returns 1. If
  /// the minimal days required must be a full week, getMinimalDaysInFirstWeek
  /// returns 7.
  ///@return the minimal days required in the first week of the year.
  int getMinimalDaysInFirstWeek() => jniAccessors.callMethodWithArgs(reference,
      _id_getMinimalDaysInFirstWeek, jni.JniType.intType, []).integer;

  static final _id_handleGetLimit =
      jniAccessors.getMethodIDOf(_classRef, "handleGetLimit", "(II)I");

  /// from: protected abstract int handleGetLimit(int field, int limitType)
  ///
  /// Subclass API for defining limits of different types.
  /// Subclasses must implement this method to return limits for the
  /// following fields:
  ///
  /// <pre>ERA
  /// YEAR
  /// MONTH
  /// WEEK_OF_YEAR
  /// WEEK_OF_MONTH
  /// DAY_OF_MONTH
  /// DAY_OF_YEAR
  /// DAY_OF_WEEK_IN_MONTH
  /// YEAR_WOY
  /// EXTENDED_YEAR</pre>
  ///@param field one of the above field numbers
  ///@param limitType one of <code>MINIMUM</code>, <code>GREATEST_MINIMUM</code>,
  /// <code>LEAST_MAXIMUM</code>, or <code>MAXIMUM</code>
  int handleGetLimit(int field, int limitType) =>
      jniAccessors.callMethodWithArgs(reference, _id_handleGetLimit,
          jni.JniType.intType, [field, limitType]).integer;

  static final _id_getLimit =
      jniAccessors.getMethodIDOf(_classRef, "getLimit", "(II)I");

  /// from: protected int getLimit(int field, int limitType)
  ///
  /// Returns a limit for a field.
  ///@param field the field, from 0..<code>getFieldCount()-1</code>
  ///@param limitType the type specifier for the limit
  ///@see \#MINIMUM
  ///@see \#GREATEST_MINIMUM
  ///@see \#LEAST_MAXIMUM
  ///@see \#MAXIMUM
  int getLimit(int field, int limitType) => jniAccessors.callMethodWithArgs(
      reference, _id_getLimit, jni.JniType.intType, [field, limitType]).integer;

  static final _id_getMinimum =
      jniAccessors.getMethodIDOf(_classRef, "getMinimum", "(I)I");

  /// from: public final int getMinimum(int field)
  ///
  /// Returns the minimum value for the given time field.
  /// e.g., for Gregorian DAY_OF_MONTH, 1.
  ///@param field the given time field.
  ///@return the minimum value for the given time field.
  int getMinimum(int field) => jniAccessors.callMethodWithArgs(
      reference, _id_getMinimum, jni.JniType.intType, [field]).integer;

  static final _id_getMaximum =
      jniAccessors.getMethodIDOf(_classRef, "getMaximum", "(I)I");

  /// from: public final int getMaximum(int field)
  ///
  /// Returns the maximum value for the given time field.
  /// e.g. for Gregorian DAY_OF_MONTH, 31.
  ///@param field the given time field.
  ///@return the maximum value for the given time field.
  int getMaximum(int field) => jniAccessors.callMethodWithArgs(
      reference, _id_getMaximum, jni.JniType.intType, [field]).integer;

  static final _id_getGreatestMinimum =
      jniAccessors.getMethodIDOf(_classRef, "getGreatestMinimum", "(I)I");

  /// from: public final int getGreatestMinimum(int field)
  ///
  /// Returns the highest minimum value for the given field if varies.
  /// Otherwise same as getMinimum(). For Gregorian, no difference.
  ///@param field the given time field.
  ///@return the highest minimum value for the given time field.
  int getGreatestMinimum(int field) => jniAccessors.callMethodWithArgs(
      reference, _id_getGreatestMinimum, jni.JniType.intType, [field]).integer;

  static final _id_getLeastMaximum =
      jniAccessors.getMethodIDOf(_classRef, "getLeastMaximum", "(I)I");

  /// from: public final int getLeastMaximum(int field)
  ///
  /// Returns the lowest maximum value for the given field if varies.
  /// Otherwise same as getMaximum(). e.g., for Gregorian DAY_OF_MONTH, 28.
  ///@param field the given time field.
  ///@return the lowest maximum value for the given time field.
  int getLeastMaximum(int field) => jniAccessors.callMethodWithArgs(
      reference, _id_getLeastMaximum, jni.JniType.intType, [field]).integer;

  static final _id_isWeekend =
      jniAccessors.getMethodIDOf(_classRef, "isWeekend", "(Ljava/util/Date;)Z");

  /// from: public boolean isWeekend(java.util.Date date)
  ///
  /// <strong>[icu]</strong> Returns true if the given date and time is in the weekend in this calendar
  /// system.  Equivalent to calling setTime() followed by isWeekend().  Note: This
  /// method changes the time this calendar is set to.
  ///@param date the date and time
  ///@return true if the given date and time is part of the
  /// weekend
  ///@see \#getDayOfWeekType
  ///@see \#getWeekendTransition
  ///@see \#isWeekend()
  bool isWeekend(jni.JniObject date) => jniAccessors.callMethodWithArgs(
      reference,
      _id_isWeekend,
      jni.JniType.booleanType,
      [date.reference]).boolean;

  static final _id_isWeekend1 =
      jniAccessors.getMethodIDOf(_classRef, "isWeekend", "()Z");

  /// from: public boolean isWeekend()
  ///
  /// <strong>[icu]</strong> Returns true if this Calendar's current date and time is in the weekend in
  /// this calendar system.
  ///@return true if the given date and time is part of the
  /// weekend
  ///@see \#getDayOfWeekType
  ///@see \#getWeekendTransition
  ///@see \#isWeekend(Date)
  bool isWeekend1() => jniAccessors.callMethodWithArgs(
      reference, _id_isWeekend1, jni.JniType.booleanType, []).boolean;

  static final _id_clone =
      jniAccessors.getMethodIDOf(_classRef, "clone", "()Ljava/lang/Object;");

  /// from: public java.lang.Object clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Overrides Cloneable
  jni.JniObject clone() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a string representation of this calendar. This method
  /// is intended to be used only for debugging purposes, and the
  /// format of the returned string may vary between implementations.
  /// The returned string may be empty but may not be <code>null</code>.
  ///@return a string representation of this calendar.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_getWeekDataForRegion = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getWeekDataForRegion",
      "(Ljava/lang/String;)Landroid/icu/util/Calendar\$WeekData;");

  /// from: static public android.icu.util.Calendar.WeekData getWeekDataForRegion(java.lang.String region)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Return simple, immutable struct-like class for access to the CLDR weekend data.
  ///@param region The input region. The results are undefined if the region code is not valid.
  ///@return the WeekData for the input region. It is never null.
  static Calendar_WeekData getWeekDataForRegion(jni.JniString region) =>
      Calendar_WeekData.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getWeekDataForRegion,
          jni.JniType.objectType,
          [region.reference]).object);

  static final _id_getWeekData = jniAccessors.getMethodIDOf(
      _classRef, "getWeekData", "()Landroid/icu/util/Calendar\$WeekData;");

  /// from: public android.icu.util.Calendar.WeekData getWeekData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Return simple, immutable struct-like class for access to the weekend data in this calendar.
  ///@return the WeekData for this calendar.
  Calendar_WeekData getWeekData() =>
      Calendar_WeekData.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWeekData, jni.JniType.objectType, []).object);

  static final _id_setWeekData = jniAccessors.getMethodIDOf(
      _classRef,
      "setWeekData",
      "(Landroid/icu/util/Calendar\$WeekData;)Landroid/icu/util/Calendar;");

  /// from: public android.icu.util.Calendar setWeekData(android.icu.util.Calendar.WeekData wdata)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Set data in this calendar based on the WeekData input.
  ///@param wdata The week data to use
  ///@return this, for chaining
  Calendar setWeekData(Calendar_WeekData wdata) =>
      Calendar.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setWeekData, jni.JniType.objectType, [wdata.reference]).object);

  static final _id_computeFields =
      jniAccessors.getMethodIDOf(_classRef, "computeFields", "()V");

  /// from: protected void computeFields()
  ///
  /// Converts the current millisecond time value <code>time</code> to
  /// field values in <code>fields[]</code>.  This synchronizes the time
  /// field values with a new time that is set for the calendar.  The time
  /// is _not_ recomputed first; to recompute the time, then the
  /// fields, call the <code>complete</code> method.
  ///@see \#complete
  void computeFields() => jniAccessors.callMethodWithArgs(
      reference, _id_computeFields, jni.JniType.voidType, []).check();

  static final _id_computeGregorianFields =
      jniAccessors.getMethodIDOf(_classRef, "computeGregorianFields", "(I)V");

  /// from: protected final void computeGregorianFields(int julianDay)
  ///
  /// Compute the Gregorian calendar year, month, and day of month from the
  /// Julian day.  These values are not stored in fields, but in member
  /// variables gregorianXxx.  They are used for time zone computations and by
  /// subclasses that are Gregorian derivatives.  Subclasses may call this
  /// method to perform a Gregorian calendar millis-&gt;fields computation.
  /// To perform a Gregorian calendar fields-&gt;millis computation, call
  /// computeGregorianMonthStart().
  ///@see \#computeGregorianMonthStart
  void computeGregorianFields(int julianDay) => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeGregorianFields,
      jni.JniType.voidType,
      [julianDay]).check();

  static final _id_resolveFields =
      jniAccessors.getMethodIDOf(_classRef, "resolveFields", "([[[I)I");

  /// from: protected int resolveFields(int[][][] precedenceTable)
  ///
  /// Given a precedence table, return the newest field combination in
  /// the table, or -1 if none is found.
  ///
  /// The precedence table is a 3-dimensional array of integers.  It
  /// may be thought of as an array of groups.  Each group is an array of
  /// lines.  Each line is an array of field numbers.  Within a line, if
  /// all fields are set, then the time stamp of the line is taken to be
  /// the stamp of the most recently set field.  If any field of a line is
  /// unset, then the line fails to match.  Within a group, the line with
  /// the newest time stamp is selected.  The first field of the line is
  /// returned to indicate which line matched.
  ///
  /// In some cases, it may be desirable to map a line to field that
  /// whose stamp is NOT examined.  For example, if the best field is
  /// DAY_OF_WEEK then the DAY_OF_WEEK_IN_MONTH algorithm may be used.  In
  /// order to do this, insert the value <code>REMAP_RESOLVE | F</code> at
  /// the start of the line, where <code>F</code> is the desired return
  /// field value.  This field will NOT be examined; it only determines
  /// the return value if the other fields in the line are the newest.
  ///
  /// If all lines of a group contain at least one unset field, then no
  /// line will match, and the group as a whole will fail to match.  In
  /// that case, the next group will be processed.  If all groups fail to
  /// match, then -1 is returned.
  int resolveFields(jni.JniObject precedenceTable) =>
      jniAccessors.callMethodWithArgs(reference, _id_resolveFields,
          jni.JniType.intType, [precedenceTable.reference]).integer;

  static final _id_newestStamp =
      jniAccessors.getMethodIDOf(_classRef, "newestStamp", "(III)I");

  /// from: protected int newestStamp(int first, int last, int bestStampSoFar)
  ///
  /// Returns the newest stamp of a given range of fields.
  int newestStamp(int first, int last, int bestStampSoFar) =>
      jniAccessors.callMethodWithArgs(reference, _id_newestStamp,
          jni.JniType.intType, [first, last, bestStampSoFar]).integer;

  static final _id_getStamp =
      jniAccessors.getMethodIDOf(_classRef, "getStamp", "(I)I");

  /// from: protected final int getStamp(int field)
  ///
  /// Returns the timestamp of a field.
  int getStamp(int field) => jniAccessors.callMethodWithArgs(
      reference, _id_getStamp, jni.JniType.intType, [field]).integer;

  static final _id_newerField =
      jniAccessors.getMethodIDOf(_classRef, "newerField", "(II)I");

  /// from: protected int newerField(int defaultField, int alternateField)
  ///
  /// Returns the field that is newer, either defaultField, or
  /// alternateField.  If neither is newer or neither is set, return defaultField.
  int newerField(int defaultField, int alternateField) =>
      jniAccessors.callMethodWithArgs(reference, _id_newerField,
          jni.JniType.intType, [defaultField, alternateField]).integer;

  static final _id_validateFields =
      jniAccessors.getMethodIDOf(_classRef, "validateFields", "()V");

  /// from: protected void validateFields()
  ///
  /// Ensure that each field is within its valid range by calling \#validateField(int) on each field that has been set.  This method
  /// should only be called if this calendar is not lenient.
  ///@see \#isLenient
  ///@see \#validateField(int)
  void validateFields() => jniAccessors.callMethodWithArgs(
      reference, _id_validateFields, jni.JniType.voidType, []).check();

  static final _id_validateField =
      jniAccessors.getMethodIDOf(_classRef, "validateField", "(I)V");

  /// from: protected void validateField(int field)
  ///
  /// Validate a single field of this calendar.  Subclasses should
  /// override this method to validate any calendar-specific fields.
  /// Generic fields can be handled by
  /// <code>Calendar.validateField()</code>.
  ///@see \#validateField(int, int, int)
  void validateField(int field) => jniAccessors.callMethodWithArgs(
      reference, _id_validateField, jni.JniType.voidType, [field]).check();

  static final _id_validateField1 =
      jniAccessors.getMethodIDOf(_classRef, "validateField", "(III)V");

  /// from: protected final void validateField(int field, int min, int max)
  ///
  /// Validate a single field of this calendar given its minimum and
  /// maximum allowed value.  If the field is out of range, throw a
  /// descriptive <code>IllegalArgumentException</code>.  Subclasses may
  /// use this method in their implementation of \#validateField(int).
  void validateField1(int field, int min, int max) =>
      jniAccessors.callMethodWithArgs(reference, _id_validateField1,
          jni.JniType.voidType, [field, min, max]).check();

  static final _id_computeTime =
      jniAccessors.getMethodIDOf(_classRef, "computeTime", "()V");

  /// from: protected void computeTime()
  ///
  /// Converts the current field values in <code>fields[]</code> to the
  /// millisecond time value <code>time</code>.
  void computeTime() => jniAccessors.callMethodWithArgs(
      reference, _id_computeTime, jni.JniType.voidType, []).check();

  static final _id_computeMillisInDay =
      jniAccessors.getMethodIDOf(_classRef, "computeMillisInDay", "()I");

  /// from: protected int computeMillisInDay()
  ///
  /// Compute the milliseconds in the day from the fields.  This is a
  /// value from 0 to 23:59:59.999 inclusive, unless fields are out of
  /// range, in which case it can be an arbitrary value.  This value
  /// reflects local zone wall time.
  ///@deprecated ICU 60
  int computeMillisInDay() => jniAccessors.callMethodWithArgs(
      reference, _id_computeMillisInDay, jni.JniType.intType, []).integer;

  static final _id_computeZoneOffset =
      jniAccessors.getMethodIDOf(_classRef, "computeZoneOffset", "(JI)I");

  /// from: protected int computeZoneOffset(long millis, int millisInDay)
  ///
  /// This method can assume EXTENDED_YEAR has been set.
  ///@param millis milliseconds of the date fields (local midnight millis)
  ///@param millisInDay milliseconds of the time fields; may be out
  /// or range.
  ///@return total zone offset (raw + DST) for the given moment
  ///@deprecated ICU 60
  int computeZoneOffset(int millis, int millisInDay) =>
      jniAccessors.callMethodWithArgs(reference, _id_computeZoneOffset,
          jni.JniType.intType, [millis, millisInDay]).integer;

  static final _id_computeJulianDay =
      jniAccessors.getMethodIDOf(_classRef, "computeJulianDay", "()I");

  /// from: protected int computeJulianDay()
  ///
  /// Compute the Julian day number as specified by this calendar's fields.
  int computeJulianDay() => jniAccessors.callMethodWithArgs(
      reference, _id_computeJulianDay, jni.JniType.intType, []).integer;

  static final _id_getFieldResolutionTable = jniAccessors.getMethodIDOf(
      _classRef, "getFieldResolutionTable", "()[[[I");

  /// from: protected int[][][] getFieldResolutionTable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the field resolution array for this calendar.  Calendars that
  /// define additional fields or change the semantics of existing fields
  /// should override this method to adjust the field resolution semantics
  /// accordingly.  Other subclasses should not override this method.
  ///@see \#resolveFields
  jni.JniObject getFieldResolutionTable() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getFieldResolutionTable, jni.JniType.objectType, []).object);

  static final _id_handleComputeMonthStart = jniAccessors.getMethodIDOf(
      _classRef, "handleComputeMonthStart", "(IIZ)I");

  /// from: protected abstract int handleComputeMonthStart(int eyear, int month, boolean useMonth)
  ///
  /// Returns the Julian day number of day before the first day of the
  /// given month in the given extended year.  Subclasses should override
  /// this method to implement their calendar system.
  ///@param eyear the extended year
  ///@param month the zero-based month, or 0 if useMonth is false
  ///@param useMonth if false, compute the day before the first day of
  /// the given year, otherwise, compute the day before the first day of
  /// the given month
  ///@return the Julian day number of the day before the first
  /// day of the given month and year
  int handleComputeMonthStart(int eyear, int month, bool useMonth) =>
      jniAccessors.callMethodWithArgs(reference, _id_handleComputeMonthStart,
          jni.JniType.intType, [eyear, month, useMonth]).integer;

  static final _id_handleGetExtendedYear =
      jniAccessors.getMethodIDOf(_classRef, "handleGetExtendedYear", "()I");

  /// from: protected abstract int handleGetExtendedYear()
  ///
  /// Returns the extended year defined by the current fields.  This will
  /// use the EXTENDED_YEAR field or the YEAR and supra-year fields (such
  /// as ERA) specific to the calendar system, depending on which set of
  /// fields is newer.
  ///@return the extended year
  int handleGetExtendedYear() => jniAccessors.callMethodWithArgs(
      reference, _id_handleGetExtendedYear, jni.JniType.intType, []).integer;

  static final _id_handleGetMonthLength =
      jniAccessors.getMethodIDOf(_classRef, "handleGetMonthLength", "(II)I");

  /// from: protected int handleGetMonthLength(int extendedYear, int month)
  ///
  /// Returns the number of days in the given month of the given extended
  /// year of this calendar system.  Subclasses should override this
  /// method if they can provide a more correct or more efficient
  /// implementation than the default implementation in Calendar.
  int handleGetMonthLength(int extendedYear, int month) =>
      jniAccessors.callMethodWithArgs(reference, _id_handleGetMonthLength,
          jni.JniType.intType, [extendedYear, month]).integer;

  static final _id_handleGetYearLength =
      jniAccessors.getMethodIDOf(_classRef, "handleGetYearLength", "(I)I");

  /// from: protected int handleGetYearLength(int eyear)
  ///
  /// Returns the number of days in the given extended year of this
  /// calendar system.  Subclasses should override this method if they can
  /// provide a more correct or more efficient implementation than the
  /// default implementation in Calendar.
  int handleGetYearLength(int eyear) => jniAccessors.callMethodWithArgs(
      reference, _id_handleGetYearLength, jni.JniType.intType, [eyear]).integer;

  static final _id_handleCreateFields =
      jniAccessors.getMethodIDOf(_classRef, "handleCreateFields", "()[I");

  /// from: protected int[] handleCreateFields()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Subclasses that use additional fields beyond those defined in
  /// <code>Calendar</code> should override this method to return an
  /// <code>int[]</code> array of the appropriate length.  The length
  /// must be at least <code>BASE_FIELD_COUNT</code> and no more than
  /// <code>MAX_FIELD_COUNT</code>.
  jni.JniObject handleCreateFields() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_handleCreateFields, jni.JniType.objectType, []).object);

  static final _id_handleComputeJulianDay =
      jniAccessors.getMethodIDOf(_classRef, "handleComputeJulianDay", "(I)I");

  /// from: protected int handleComputeJulianDay(int bestField)
  ///
  /// Subclasses may override this.  This method calls
  /// handleGetMonthLength() to obtain the calendar-specific month
  /// length.
  int handleComputeJulianDay(int bestField) => jniAccessors.callMethodWithArgs(
      reference,
      _id_handleComputeJulianDay,
      jni.JniType.intType,
      [bestField]).integer;

  static final _id_computeGregorianMonthStart = jniAccessors.getMethodIDOf(
      _classRef, "computeGregorianMonthStart", "(II)I");

  /// from: protected int computeGregorianMonthStart(int year, int month)
  ///
  /// Compute the Julian day of a month of the Gregorian calendar.
  /// Subclasses may call this method to perform a Gregorian calendar
  /// fields-&gt;millis computation.  To perform a Gregorian calendar
  /// millis-&gt;fields computation, call computeGregorianFields().
  ///@param year extended Gregorian year
  ///@param month zero-based Gregorian month
  ///@return the Julian day number of the day before the first
  /// day of the given month in the given extended year
  ///@see \#computeGregorianFields
  int computeGregorianMonthStart(int year, int month) =>
      jniAccessors.callMethodWithArgs(reference, _id_computeGregorianMonthStart,
          jni.JniType.intType, [year, month]).integer;

  static final _id_handleComputeFields =
      jniAccessors.getMethodIDOf(_classRef, "handleComputeFields", "(I)V");

  /// from: protected void handleComputeFields(int julianDay)
  ///
  /// Subclasses may override this method to compute several fields
  /// specific to each calendar system.  These are:
  ///
  /// <ul><li>ERA
  /// <li>YEAR
  /// <li>MONTH
  /// <li>DAY_OF_MONTH
  /// <li>DAY_OF_YEAR
  /// <li>EXTENDED_YEAR</ul>
  ///
  /// Subclasses can refer to the DAY_OF_WEEK and DOW_LOCAL fields, which
  /// will be set when this method is called.  Subclasses can also call
  /// the getGregorianXxx() methods to obtain Gregorian calendar
  /// equivalents for the given Julian day.
  ///
  /// In addition, subclasses should compute any subclass-specific
  /// fields, that is, fields from BASE_FIELD_COUNT to
  /// getFieldCount() - 1.
  ///
  /// The default implementation in <code>Calendar</code> implements
  /// a pure proleptic Gregorian calendar.
  void handleComputeFields(int julianDay) => jniAccessors.callMethodWithArgs(
      reference,
      _id_handleComputeFields,
      jni.JniType.voidType,
      [julianDay]).check();

  static final _id_getGregorianYear =
      jniAccessors.getMethodIDOf(_classRef, "getGregorianYear", "()I");

  /// from: protected final int getGregorianYear()
  ///
  /// Returns the extended year on the Gregorian calendar as computed by
  /// <code>computeGregorianFields()</code>.
  ///@see \#computeGregorianFields
  int getGregorianYear() => jniAccessors.callMethodWithArgs(
      reference, _id_getGregorianYear, jni.JniType.intType, []).integer;

  static final _id_getGregorianMonth =
      jniAccessors.getMethodIDOf(_classRef, "getGregorianMonth", "()I");

  /// from: protected final int getGregorianMonth()
  ///
  /// Returns the month (0-based) on the Gregorian calendar as computed by
  /// <code>computeGregorianFields()</code>.
  ///@see \#computeGregorianFields
  int getGregorianMonth() => jniAccessors.callMethodWithArgs(
      reference, _id_getGregorianMonth, jni.JniType.intType, []).integer;

  static final _id_getGregorianDayOfYear =
      jniAccessors.getMethodIDOf(_classRef, "getGregorianDayOfYear", "()I");

  /// from: protected final int getGregorianDayOfYear()
  ///
  /// Returns the day of year (1-based) on the Gregorian calendar as
  /// computed by <code>computeGregorianFields()</code>.
  ///@see \#computeGregorianFields
  int getGregorianDayOfYear() => jniAccessors.callMethodWithArgs(
      reference, _id_getGregorianDayOfYear, jni.JniType.intType, []).integer;

  static final _id_getGregorianDayOfMonth =
      jniAccessors.getMethodIDOf(_classRef, "getGregorianDayOfMonth", "()I");

  /// from: protected final int getGregorianDayOfMonth()
  ///
  /// Returns the day of month (1-based) on the Gregorian calendar as
  /// computed by <code>computeGregorianFields()</code>.
  ///@see \#computeGregorianFields
  int getGregorianDayOfMonth() => jniAccessors.callMethodWithArgs(
      reference, _id_getGregorianDayOfMonth, jni.JniType.intType, []).integer;

  static final _id_getFieldCount =
      jniAccessors.getMethodIDOf(_classRef, "getFieldCount", "()I");

  /// from: public final int getFieldCount()
  ///
  /// <strong>[icu]</strong> Returns the number of fields defined by this calendar.  Valid field
  /// arguments to <code>set()</code> and <code>get()</code> are
  /// <code>0..getFieldCount()-1</code>.
  int getFieldCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getFieldCount, jni.JniType.intType, []).integer;

  static final _id_internalSet =
      jniAccessors.getMethodIDOf(_classRef, "internalSet", "(II)V");

  /// from: protected final void internalSet(int field, int value)
  ///
  /// Set a field to a value.  Subclasses should use this method when
  /// computing fields.  It sets the time stamp in the
  /// <code>stamp[]</code> array to <code>INTERNALLY_SET</code>.  If a
  /// field that may not be set by subclasses is passed in, an
  /// <code>IllegalArgumentException</code> is thrown.  This prevents
  /// subclasses from modifying fields that are intended to be
  /// calendar-system invariant.
  void internalSet(int field, int value) => jniAccessors.callMethodWithArgs(
      reference, _id_internalSet, jni.JniType.voidType, [field, value]).check();

  static final _id_isGregorianLeapYear = jniAccessors.getStaticMethodIDOf(
      _classRef, "isGregorianLeapYear", "(I)Z");

  /// from: static protected final boolean isGregorianLeapYear(int year)
  ///
  /// Determines if the given year is a leap year. Returns true if the
  /// given year is a leap year.
  ///@param year the given year.
  ///@return true if the given year is a leap year; false otherwise.
  static bool isGregorianLeapYear(int year) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_isGregorianLeapYear,
          jni.JniType.booleanType, [year]).boolean;

  static final _id_gregorianMonthLength = jniAccessors.getStaticMethodIDOf(
      _classRef, "gregorianMonthLength", "(II)I");

  /// from: static protected final int gregorianMonthLength(int y, int m)
  ///
  /// Returns the length of a month of the Gregorian calendar.
  ///@param y the extended year
  ///@param m the 0-based month number
  ///@return the number of days in the given month
  static int gregorianMonthLength(int y, int m) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_gregorianMonthLength,
          jni.JniType.intType, [y, m]).integer;

  static final _id_gregorianPreviousMonthLength = jniAccessors
      .getStaticMethodIDOf(_classRef, "gregorianPreviousMonthLength", "(II)I");

  /// from: static protected final int gregorianPreviousMonthLength(int y, int m)
  ///
  /// Returns the length of a previous month of the Gregorian calendar.
  ///@param y the extended year
  ///@param m the 0-based month number
  ///@return the number of days in the month previous to the given month
  static int gregorianPreviousMonthLength(int y, int m) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_gregorianPreviousMonthLength,
          jni.JniType.intType,
          [y, m]).integer;

  static final _id_floorDivide =
      jniAccessors.getStaticMethodIDOf(_classRef, "floorDivide", "(JJ)J");

  /// from: static protected final long floorDivide(long numerator, long denominator)
  ///
  /// Divide two long integers, returning the floor of the quotient.
  ///
  /// Unlike the built-in division, this is mathematically well-behaved.
  /// E.g., <code>-1/4</code> =&gt; 0
  /// but <code>floorDivide(-1,4)</code> =&gt; -1.
  ///@param numerator the numerator
  ///@param denominator a divisor which must be &gt; 0
  ///@return the floor of the quotient.
  static int floorDivide(int numerator, int denominator) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_floorDivide,
          jni.JniType.longType, [numerator, denominator]).long;

  static final _id_floorDivide1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "floorDivide", "(II)I");

  /// from: static protected final int floorDivide(int numerator, int denominator)
  ///
  /// Divide two integers, returning the floor of the quotient.
  ///
  /// Unlike the built-in division, this is mathematically well-behaved.
  /// E.g., <code>-1/4</code> =&gt; 0
  /// but <code>floorDivide(-1,4)</code> =&gt; -1.
  ///@param numerator the numerator
  ///@param denominator a divisor which must be &gt; 0
  ///@return the floor of the quotient.
  static int floorDivide1(int numerator, int denominator) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_floorDivide1,
          jni.JniType.intType, [numerator, denominator]).integer;

  static final _id_floorDivide2 =
      jniAccessors.getStaticMethodIDOf(_classRef, "floorDivide", "(II[I)I");

  /// from: static protected final int floorDivide(int numerator, int denominator, int[] remainder)
  ///
  /// Divide two integers, returning the floor of the quotient, and
  /// the modulus remainder.
  ///
  /// Unlike the built-in division, this is mathematically well-behaved.
  /// E.g., <code>-1/4</code> =&gt; 0 and <code>-1%4</code> =&gt; -1,
  /// but <code>floorDivide(-1,4)</code> =&gt; -1 with <code>remainder[0]</code> =&gt; 3.
  ///@param numerator the numerator
  ///@param denominator a divisor which must be &gt; 0
  ///@param remainder an array of at least one element in which the value
  /// <code>numerator mod denominator</code> is returned. Unlike <code>numerator
  /// % denominator</code>, this will always be non-negative.
  ///@return the floor of the quotient.
  static int floorDivide2(
          int numerator, int denominator, jni.JniObject remainder) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_floorDivide2,
          jni.JniType.intType,
          [numerator, denominator, remainder.reference]).integer;

  static final _id_floorDivide3 =
      jniAccessors.getStaticMethodIDOf(_classRef, "floorDivide", "(JI[I)I");

  /// from: static protected final int floorDivide(long numerator, int denominator, int[] remainder)
  ///
  /// Divide two integers, returning the floor of the quotient, and
  /// the modulus remainder.
  ///
  /// Unlike the built-in division, this is mathematically well-behaved.
  /// E.g., <code>-1/4</code> =&gt; 0 and <code>-1%4</code> =&gt; -1,
  /// but <code>floorDivide(-1,4)</code> =&gt; -1 with <code>remainder[0]</code> =&gt; 3.
  ///@param numerator the numerator
  ///@param denominator a divisor which must be &gt; 0
  ///@param remainder an array of at least one element in which the value
  /// <code>numerator mod denominator</code> is returned. Unlike <code>numerator
  /// % denominator</code>, this will always be non-negative.
  ///@return the floor of the quotient.
  static int floorDivide3(
          int numerator, int denominator, jni.JniObject remainder) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_floorDivide3,
          jni.JniType.intType,
          [numerator, denominator, remainder.reference]).integer;

  static final _id_fieldName = jniAccessors.getMethodIDOf(
      _classRef, "fieldName", "(I)Ljava/lang/String;");

  /// from: protected java.lang.String fieldName(int field)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a string name for a field, for debugging and exceptions.
  jni.JniString fieldName(int field) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_fieldName, jni.JniType.objectType, [field]).object);

  static final _id_millisToJulianDay =
      jniAccessors.getStaticMethodIDOf(_classRef, "millisToJulianDay", "(J)I");

  /// from: static protected final int millisToJulianDay(long millis)
  ///
  /// Converts time as milliseconds to Julian day.
  ///@param millis the given milliseconds.
  ///@return the Julian day number.
  static int millisToJulianDay(int millis) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_millisToJulianDay,
          jni.JniType.intType, [millis]).integer;

  static final _id_julianDayToMillis =
      jniAccessors.getStaticMethodIDOf(_classRef, "julianDayToMillis", "(I)J");

  /// from: static protected final long julianDayToMillis(int julian)
  ///
  /// Converts Julian day to time as milliseconds.
  ///@param julian the given Julian day number.
  ///@return time as milliseconds.
  static int julianDayToMillis(int julian) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_julianDayToMillis,
          jni.JniType.longType, [julian]).long;

  static final _id_julianDayToDayOfWeek = jniAccessors.getStaticMethodIDOf(
      _classRef, "julianDayToDayOfWeek", "(I)I");

  /// from: static protected final int julianDayToDayOfWeek(int julian)
  ///
  /// Returns the day of week, from SUNDAY to SATURDAY, given a Julian day.
  static int julianDayToDayOfWeek(int julian) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_julianDayToDayOfWeek,
          jni.JniType.intType, [julian]).integer;

  static final _id_internalGetTimeInMillis =
      jniAccessors.getMethodIDOf(_classRef, "internalGetTimeInMillis", "()J");

  /// from: protected final long internalGetTimeInMillis()
  ///
  /// Returns the current milliseconds without recomputing.
  int internalGetTimeInMillis() => jniAccessors.callMethodWithArgs(
      reference, _id_internalGetTimeInMillis, jni.JniType.longType, []).long;

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "()Ljava/lang/String;");

  /// from: public java.lang.String getType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// <strong>[icu]</strong> Returns the calendar type name string for this Calendar object.
  /// The returned string is the legacy ICU calendar attribute value,
  /// for example, "gregorian" or "japanese".
  ///
  /// See type="old type name" for the calendar attribute of locale IDs
  /// at http://www.unicode.org/reports/tr35/\#Key_Type_Definitions
  ///@return legacy calendar type name string
  jni.JniString getType() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getType, jni.JniType.objectType, []).object);
}

/// from: android.icu.util.Calendar$WeekData
///
/// Simple, immutable struct-like class for access to the CLDR weekend data.
class Calendar_WeekData extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/icu/util/Calendar\$WeekData");
  Calendar_WeekData.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_firstDayOfWeek =
      jniAccessors.getFieldIDOf(_classRef, "firstDayOfWeek", "I");

  /// from: public final int firstDayOfWeek
  ///
  /// the first day of the week, where 1 = \#SUNDAY and 7 = \#SATURDAY
  int get firstDayOfWeek => jniAccessors
      .getField(reference, _id_firstDayOfWeek, jni.JniType.intType)
      .integer;

  static final _id_minimalDaysInFirstWeek =
      jniAccessors.getFieldIDOf(_classRef, "minimalDaysInFirstWeek", "I");

  /// from: public final int minimalDaysInFirstWeek
  ///
  /// the minimal number of days in the first week
  int get minimalDaysInFirstWeek => jniAccessors
      .getField(reference, _id_minimalDaysInFirstWeek, jni.JniType.intType)
      .integer;

  static final _id_weekendCease =
      jniAccessors.getFieldIDOf(_classRef, "weekendCease", "I");

  /// from: public final int weekendCease
  ///
  /// the cease day, where 1 = \#SUNDAY and 7 = \#SATURDAY
  int get weekendCease => jniAccessors
      .getField(reference, _id_weekendCease, jni.JniType.intType)
      .integer;

  static final _id_weekendCeaseMillis =
      jniAccessors.getFieldIDOf(_classRef, "weekendCeaseMillis", "I");

  /// from: public final int weekendCeaseMillis
  ///
  /// the cease time in millis during the cease day. Exclusive, so the max is 24:00:00.000.
  /// Note that this will format as 00:00 the next day.
  int get weekendCeaseMillis => jniAccessors
      .getField(reference, _id_weekendCeaseMillis, jni.JniType.intType)
      .integer;

  static final _id_weekendOnset =
      jniAccessors.getFieldIDOf(_classRef, "weekendOnset", "I");

  /// from: public final int weekendOnset
  ///
  /// the onset day, where 1 = \#SUNDAY and 7 = \#SATURDAY
  int get weekendOnset => jniAccessors
      .getField(reference, _id_weekendOnset, jni.JniType.intType)
      .integer;

  static final _id_weekendOnsetMillis =
      jniAccessors.getFieldIDOf(_classRef, "weekendOnsetMillis", "I");

  /// from: public final int weekendOnsetMillis
  ///
  /// the onset time in millis during the onset day
  int get weekendOnsetMillis => jniAccessors
      .getField(reference, _id_weekendOnsetMillis, jni.JniType.intType)
      .integer;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(IIIIII)V");

  /// from: public void <init>(int fdow, int mdifw, int weekendOnset, int weekendOnsetMillis, int weekendCease, int weekendCeaseMillis)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor
  ///@param fdow the first day of the week, where 1 = \#SUNDAY and 7 = \#SATURDAY
  ///@param mdifw the minimal number of days in the first week
  ///@param weekendOnset the onset day, where 1 = Sunday and 7 = Saturday
  ///@param weekendOnsetMillis the onset time in millis during the onset day
  ///@param weekendCease the cease day, where 1 = Sunday and 7 = Saturday
  ///@param weekendCeaseMillis the cease time in millis during the cease day.
  Calendar_WeekData(int fdow, int mdifw, int weekendOnset,
      int weekendOnsetMillis, int weekendCease, int weekendCeaseMillis)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [
          fdow,
          mdifw,
          weekendOnset,
          weekendOnsetMillis,
          weekendCease,
          weekendCeaseMillis
        ]).object);

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// {@inheritDoc}
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object other)
  ///
  /// {@inheritDoc}
  bool equals1(jni.JniObject other) => jniAccessors.callMethodWithArgs(
      reference,
      _id_equals1,
      jni.JniType.booleanType,
      [other.reference]).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
