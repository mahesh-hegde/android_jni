// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "PersistableBundle.dart" as persistablebundle_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.BaseBundle
///
/// A mapping from String keys to values of various types. In most cases, you
/// should work directly with either the Bundle or
/// PersistableBundle subclass.
class BaseBundle extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/BaseBundle");
  BaseBundle.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new, empty Bundle.
  BaseBundle()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_size = jniAccessors.getMethodIDOf(_classRef, "size", "()I");

  /// from: public int size()
  ///
  /// Returns the number of mappings contained in this Bundle.
  ///@return the number of mappings as an int.
  int size() => jniAccessors
      .callMethodWithArgs(reference, _id_size, jni.JniType.intType, []).integer;

  static final _id_isEmpty =
      jniAccessors.getMethodIDOf(_classRef, "isEmpty", "()Z");

  /// from: public boolean isEmpty()
  ///
  /// Returns true if the mapping of this Bundle is empty, false otherwise.
  bool isEmpty() => jniAccessors.callMethodWithArgs(
      reference, _id_isEmpty, jni.JniType.booleanType, []).boolean;

  static final _id_clear =
      jniAccessors.getMethodIDOf(_classRef, "clear", "()V");

  /// from: public void clear()
  ///
  /// Removes all elements from the mapping of this Bundle.
  void clear() => jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniType.voidType, []).check();

  static final _id_containsKey = jniAccessors.getMethodIDOf(
      _classRef, "containsKey", "(Ljava/lang/String;)Z");

  /// from: public boolean containsKey(java.lang.String key)
  ///
  /// Returns true if the given key is contained in the mapping
  /// of this Bundle.
  ///@param key a String key
  ///@return true if the key is part of the mapping, false otherwise
  bool containsKey(jni.JniString key) => jniAccessors.callMethodWithArgs(
      reference,
      _id_containsKey,
      jni.JniType.booleanType,
      [key.reference]).boolean;

  static final _id_get0 = jniAccessors.getMethodIDOf(
      _classRef, "get", "(Ljava/lang/String;)Ljava/lang/Object;");

  /// from: public java.lang.Object get(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the entry with the given key as an object.
  ///@param key a String key
  ///@return an Object, or null
  jni.JniObject get0(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_get0, jni.JniType.objectType, [key.reference]).object);

  static final _id_remove =
      jniAccessors.getMethodIDOf(_classRef, "remove", "(Ljava/lang/String;)V");

  /// from: public void remove(java.lang.String key)
  ///
  /// Removes any entry with the given key from the mapping of this Bundle.
  ///@param key a String key
  void remove(jni.JniString key) => jniAccessors.callMethodWithArgs(
      reference, _id_remove, jni.JniType.voidType, [key.reference]).check();

  static final _id_putAll = jniAccessors.getMethodIDOf(
      _classRef, "putAll", "(Landroid/os/PersistableBundle;)V");

  /// from: public void putAll(android.os.PersistableBundle bundle)
  ///
  /// Inserts all mappings from the given PersistableBundle into this BaseBundle.
  ///@param bundle a PersistableBundle
  void putAll(persistablebundle_.PersistableBundle bundle) =>
      jniAccessors.callMethodWithArgs(reference, _id_putAll,
          jni.JniType.voidType, [bundle.reference]).check();

  static final _id_keySet =
      jniAccessors.getMethodIDOf(_classRef, "keySet", "()Ljava/util/Set;");

  /// from: public java.util.Set<java.lang.String> keySet()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Set containing the Strings used as keys in this Bundle.
  ///@return a Set of String keys
  jni.JniObject keySet() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_keySet, jni.JniType.objectType, []).object);

  static final _id_putBoolean = jniAccessors.getMethodIDOf(
      _classRef, "putBoolean", "(Ljava/lang/String;Z)V");

  /// from: public void putBoolean(java.lang.String key, boolean value)
  ///
  /// Inserts a Boolean value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a boolean
  void putBoolean(jni.JniString key, bool value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putBoolean,
          jni.JniType.voidType, [key.reference, value]).check();

  static final _id_putInt =
      jniAccessors.getMethodIDOf(_classRef, "putInt", "(Ljava/lang/String;I)V");

  /// from: public void putInt(java.lang.String key, int value)
  ///
  /// Inserts an int value into the mapping of this Bundle, replacing
  /// any existing value for the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value an int
  void putInt(jni.JniString key, int value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_putInt,
      jni.JniType.voidType,
      [key.reference, value]).check();

  static final _id_putLong = jniAccessors.getMethodIDOf(
      _classRef, "putLong", "(Ljava/lang/String;J)V");

  /// from: public void putLong(java.lang.String key, long value)
  ///
  /// Inserts a long value into the mapping of this Bundle, replacing
  /// any existing value for the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a long
  void putLong(jni.JniString key, int value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_putLong,
      jni.JniType.voidType,
      [key.reference, value]).check();

  static final _id_putDouble = jniAccessors.getMethodIDOf(
      _classRef, "putDouble", "(Ljava/lang/String;D)V");

  /// from: public void putDouble(java.lang.String key, double value)
  ///
  /// Inserts a double value into the mapping of this Bundle, replacing
  /// any existing value for the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a double
  void putDouble(jni.JniString key, double value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putDouble,
          jni.JniType.voidType, [key.reference, value]).check();

  static final _id_putString = jniAccessors.getMethodIDOf(
      _classRef, "putString", "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void putString(java.lang.String key, java.lang.String value)
  ///
  /// Inserts a String value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a String, or null
  ///
  /// This value may be {@code null}.
  void putString(jni.JniString key, jni.JniString value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putString,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putBooleanArray = jniAccessors.getMethodIDOf(
      _classRef, "putBooleanArray", "(Ljava/lang/String;[Z)V");

  /// from: public void putBooleanArray(java.lang.String key, boolean[] value)
  ///
  /// Inserts a boolean array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a boolean array object, or null
  ///
  /// This value may be {@code null}.
  void putBooleanArray(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putBooleanArray,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putIntArray = jniAccessors.getMethodIDOf(
      _classRef, "putIntArray", "(Ljava/lang/String;[I)V");

  /// from: public void putIntArray(java.lang.String key, int[] value)
  ///
  /// Inserts an int array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value an int array object, or null
  ///
  /// This value may be {@code null}.
  void putIntArray(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putIntArray,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putLongArray = jniAccessors.getMethodIDOf(
      _classRef, "putLongArray", "(Ljava/lang/String;[J)V");

  /// from: public void putLongArray(java.lang.String key, long[] value)
  ///
  /// Inserts a long array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a long array object, or null
  ///
  /// This value may be {@code null}.
  void putLongArray(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putLongArray,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putDoubleArray = jniAccessors.getMethodIDOf(
      _classRef, "putDoubleArray", "(Ljava/lang/String;[D)V");

  /// from: public void putDoubleArray(java.lang.String key, double[] value)
  ///
  /// Inserts a double array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a double array object, or null
  ///
  /// This value may be {@code null}.
  void putDoubleArray(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putDoubleArray,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putStringArray = jniAccessors.getMethodIDOf(
      _classRef, "putStringArray", "(Ljava/lang/String;[Ljava/lang/String;)V");

  /// from: public void putStringArray(java.lang.String key, java.lang.String[] value)
  ///
  /// Inserts a String array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a String array object, or null
  ///
  /// This value may be {@code null}.
  void putStringArray(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putStringArray,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_getBoolean = jniAccessors.getMethodIDOf(
      _classRef, "getBoolean", "(Ljava/lang/String;)Z");

  /// from: public boolean getBoolean(java.lang.String key)
  ///
  /// Returns the value associated with the given key, or false if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@return a boolean value
  bool getBoolean(jni.JniString key) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getBoolean,
      jni.JniType.booleanType,
      [key.reference]).boolean;

  static final _id_getBoolean1 = jniAccessors.getMethodIDOf(
      _classRef, "getBoolean", "(Ljava/lang/String;Z)Z");

  /// from: public boolean getBoolean(java.lang.String key, boolean defaultValue)
  ///
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@param defaultValue Value to return if key does not exist
  ///@return a boolean value
  bool getBoolean1(jni.JniString key, bool defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getBoolean1,
          jni.JniType.booleanType, [key.reference, defaultValue]).boolean;

  static final _id_getInt =
      jniAccessors.getMethodIDOf(_classRef, "getInt", "(Ljava/lang/String;)I");

  /// from: public int getInt(java.lang.String key)
  ///
  /// Returns the value associated with the given key, or 0 if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@return an int value
  int getInt(jni.JniString key) => jniAccessors.callMethodWithArgs(
      reference, _id_getInt, jni.JniType.intType, [key.reference]).integer;

  static final _id_getInt1 =
      jniAccessors.getMethodIDOf(_classRef, "getInt", "(Ljava/lang/String;I)I");

  /// from: public int getInt(java.lang.String key, int defaultValue)
  ///
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@param defaultValue Value to return if key does not exist
  ///@return an int value
  int getInt1(jni.JniString key, int defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getInt1,
          jni.JniType.intType, [key.reference, defaultValue]).integer;

  static final _id_getLong =
      jniAccessors.getMethodIDOf(_classRef, "getLong", "(Ljava/lang/String;)J");

  /// from: public long getLong(java.lang.String key)
  ///
  /// Returns the value associated with the given key, or 0L if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@return a long value
  int getLong(jni.JniString key) => jniAccessors.callMethodWithArgs(
      reference, _id_getLong, jni.JniType.longType, [key.reference]).long;

  static final _id_getLong1 = jniAccessors.getMethodIDOf(
      _classRef, "getLong", "(Ljava/lang/String;J)J");

  /// from: public long getLong(java.lang.String key, long defaultValue)
  ///
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@param defaultValue Value to return if key does not exist
  ///@return a long value
  int getLong1(jni.JniString key, int defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getLong1,
          jni.JniType.longType, [key.reference, defaultValue]).long;

  static final _id_getDouble = jniAccessors.getMethodIDOf(
      _classRef, "getDouble", "(Ljava/lang/String;)D");

  /// from: public double getDouble(java.lang.String key)
  ///
  /// Returns the value associated with the given key, or 0.0 if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@return a double value
  double getDouble(jni.JniString key) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getDouble,
      jni.JniType.doubleType,
      [key.reference]).doubleFloat;

  static final _id_getDouble1 = jniAccessors.getMethodIDOf(
      _classRef, "getDouble", "(Ljava/lang/String;D)D");

  /// from: public double getDouble(java.lang.String key, double defaultValue)
  ///
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@param defaultValue Value to return if key does not exist
  ///@return a double value
  double getDouble1(jni.JniString key, double defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getDouble1,
          jni.JniType.doubleType, [key.reference, defaultValue]).doubleFloat;

  static final _id_getString = jniAccessors.getMethodIDOf(
      _classRef, "getString", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String getString(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a String value, or null
  jni.JniString getString(jni.JniString key) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getString, jni.JniType.objectType, [key.reference]).object);

  static final _id_getString1 = jniAccessors.getMethodIDOf(_classRef,
      "getString", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String getString(java.lang.String key, java.lang.String defaultValue)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key or if a null
  /// value is explicitly associated with the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param defaultValue Value to return if key does not exist or if a null
  ///     value is associated with the given key.
  ///@return the String value associated with the given key, or defaultValue
  ///     if no valid String object is currently mapped to that key.
  jni.JniString getString1(jni.JniString key, jni.JniString defaultValue) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getString1,
          jni.JniType.objectType,
          [key.reference, defaultValue.reference]).object);

  static final _id_getBooleanArray = jniAccessors.getMethodIDOf(
      _classRef, "getBooleanArray", "(Ljava/lang/String;)[Z");

  /// from: public boolean[] getBooleanArray(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a boolean[] value, or null
  jni.JniObject getBooleanArray(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getBooleanArray, jni.JniType.objectType, [key.reference]).object);

  static final _id_getIntArray = jniAccessors.getMethodIDOf(
      _classRef, "getIntArray", "(Ljava/lang/String;)[I");

  /// from: public int[] getIntArray(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return an int[] value, or null
  jni.JniObject getIntArray(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getIntArray, jni.JniType.objectType, [key.reference]).object);

  static final _id_getLongArray = jniAccessors.getMethodIDOf(
      _classRef, "getLongArray", "(Ljava/lang/String;)[J");

  /// from: public long[] getLongArray(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a long[] value, or null
  jni.JniObject getLongArray(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getLongArray, jni.JniType.objectType, [key.reference]).object);

  static final _id_getDoubleArray = jniAccessors.getMethodIDOf(
      _classRef, "getDoubleArray", "(Ljava/lang/String;)[D");

  /// from: public double[] getDoubleArray(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a double[] value, or null
  jni.JniObject getDoubleArray(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDoubleArray, jni.JniType.objectType, [key.reference]).object);

  static final _id_getStringArray = jniAccessors.getMethodIDOf(
      _classRef, "getStringArray", "(Ljava/lang/String;)[Ljava/lang/String;");

  /// from: public java.lang.String[] getStringArray(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a String[] value, or null
  jni.JniObject getStringArray(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getStringArray, jni.JniType.objectType, [key.reference]).object);
}
