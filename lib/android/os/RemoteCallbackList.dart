// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.RemoteCallbackList
///
/// Takes care of the grunt work of maintaining a list of remote interfaces,
/// typically for the use of performing callbacks from a
/// android.app.Service to its clients.  In particular, this:
///
/// <ul>
/// <li> Keeps track of a set of registered IInterface callbacks,
/// taking care to identify them through their underlying unique IBinder
/// (by calling IInterface\#asBinder IInterface.asBinder().
/// <li> Attaches a IBinder.DeathRecipient IBinder.DeathRecipient to
/// each registered interface, so that it can be cleaned out of the list if its
/// process goes away.
/// <li> Performs locking of the underlying list of interfaces to deal with
/// multithreaded incoming calls, and a thread-safe way to iterate over a
/// snapshot of the list without holding its lock.
/// </ul>
///
/// To use this class, simply create a single instance along with your
/// service, and call its \#register and \#unregister methods
/// as client register and unregister with your service.  To call back on to
/// the registered clients, use \#beginBroadcast,
/// \#getBroadcastItem, and \#finishBroadcast.
///
/// If a registered callback's process goes away, this class will take
/// care of automatically removing it from the list.  If you want to do
/// additional work in this situation, you can create a subclass that
/// implements the \#onCallbackDied method.
class RemoteCallbackList extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/os/RemoteCallbackList");
  RemoteCallbackList.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  RemoteCallbackList()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_kill = jniAccessors.getMethodIDOf(_classRef, "kill", "()V");

  /// from: public void kill()
  ///
  /// Disable this callback list.  All registered callbacks are unregistered,
  /// and the list is disabled so that future calls to \#register will
  /// fail.  This should be used when a Service is stopping, to prevent clients
  /// from registering callbacks after it is stopped.
  ///@see \#register
  void kill() => jniAccessors.callMethodWithArgs(
      reference, _id_kill, jni.JniType.voidType, []).check();

  static final _id_beginBroadcast =
      jniAccessors.getMethodIDOf(_classRef, "beginBroadcast", "()I");

  /// from: public int beginBroadcast()
  ///
  /// Prepare to start making calls to the currently registered callbacks.
  /// This creates a copy of the callback list, which you can retrieve items
  /// from using \#getBroadcastItem.  Note that only one broadcast can
  /// be active at a time, so you must be sure to always call this from the
  /// same thread (usually by scheduling with Handler) or
  /// do your own synchronization.  You must call \#finishBroadcast
  /// when done.
  ///
  /// A typical loop delivering a broadcast looks like this:
  ///
  /// <pre>
  /// int i = callbacks.beginBroadcast();
  /// while (i &gt; 0) {
  ///     i--;
  ///     try {
  ///         callbacks.getBroadcastItem(i).somethingHappened();
  ///     } catch (RemoteException e) {
  ///         // The RemoteCallbackList will take care of removing
  ///         // the dead object for us.
  ///     }
  /// }
  /// callbacks.finishBroadcast();</pre>
  ///@return Returns the number of callbacks in the broadcast, to be used
  /// with \#getBroadcastItem to determine the range of indices you
  /// can supply.
  ///@see \#getBroadcastItem
  ///@see \#finishBroadcast
  int beginBroadcast() => jniAccessors.callMethodWithArgs(
      reference, _id_beginBroadcast, jni.JniType.intType, []).integer;

  static final _id_getBroadcastCookie = jniAccessors.getMethodIDOf(
      _classRef, "getBroadcastCookie", "(I)Ljava/lang/Object;");

  /// from: public java.lang.Object getBroadcastCookie(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the cookie associated with the item
  /// returned by \#getBroadcastItem(int).
  ///@see \#getBroadcastItem
  jni.JniObject getBroadcastCookie(int index) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getBroadcastCookie, jni.JniType.objectType, [index]).object);

  static final _id_finishBroadcast =
      jniAccessors.getMethodIDOf(_classRef, "finishBroadcast", "()V");

  /// from: public void finishBroadcast()
  ///
  /// Clean up the state of a broadcast previously initiated by calling
  /// \#beginBroadcast.  This must always be called when you are done
  /// with a broadcast.
  ///@see \#beginBroadcast
  void finishBroadcast() => jniAccessors.callMethodWithArgs(
      reference, _id_finishBroadcast, jni.JniType.voidType, []).check();

  static final _id_getRegisteredCallbackCount = jniAccessors.getMethodIDOf(
      _classRef, "getRegisteredCallbackCount", "()I");

  /// from: public int getRegisteredCallbackCount()
  ///
  /// Returns the number of registered callbacks. Note that the number of registered
  /// callbacks may differ from the value returned by \#beginBroadcast() since
  /// the former returns the number of callbacks registered at the time of the call
  /// and the second the number of callback to which the broadcast will be delivered.
  ///
  /// This function is useful to decide whether to schedule a broadcast if this
  /// requires doing some work which otherwise would not be performed.
  ///
  ///
  ///@return The size.
  int getRegisteredCallbackCount() => jniAccessors.callMethodWithArgs(reference,
      _id_getRegisteredCallbackCount, jni.JniType.intType, []).integer;

  static final _id_getRegisteredCallbackCookie = jniAccessors.getMethodIDOf(
      _classRef, "getRegisteredCallbackCookie", "(I)Ljava/lang/Object;");

  /// from: public java.lang.Object getRegisteredCallbackCookie(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return any cookie associated with a currently registered callback.  Note that this is
  /// _not_ the same as \#getBroadcastCookie and should not be used
  /// interchangeably with it.  This method returns the current cookie registered at the given
  /// index, not the current broadcast state.  This means that it is not itself thread-safe:
  /// any call to \#register or \#unregister will change these indices, so you
  /// must do your own thread safety between these to protect from such changes.
  ///@param index Index of which registration cookie to return, from 0 to
  /// \#getRegisteredCallbackCount() - 1.
  ///@return Returns whatever cookie object is associated with this index, or null if
  /// \#kill() has been called.
  jni.JniObject getRegisteredCallbackCookie(int index) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getRegisteredCallbackCookie,
          jni.JniType.objectType,
          [index]).object);
}
