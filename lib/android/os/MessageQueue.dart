// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.MessageQueue
///
/// Low-level class holding the list of messages to be dispatched by a
/// Looper.  Messages are not added directly to a MessageQueue,
/// but rather through Handler objects associated with the Looper.
///
/// You can retrieve the MessageQueue for the current thread with
/// Looper\#myQueue() Looper.myQueue().
class MessageQueue extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/MessageQueue");
  MessageQueue.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_isIdle =
      jniAccessors.getMethodIDOf(_classRef, "isIdle", "()Z");

  /// from: public boolean isIdle()
  ///
  /// Returns true if the looper has no pending messages which are due to be processed.
  ///
  /// This method is safe to call from any thread.
  ///@return True if the looper is idle.
  bool isIdle() => jniAccessors.callMethodWithArgs(
      reference, _id_isIdle, jni.JniType.booleanType, []).boolean;

  static final _id_addIdleHandler = jniAccessors.getMethodIDOf(
      _classRef, "addIdleHandler", "(Landroid/os/MessageQueue\$IdleHandler;)V");

  /// from: public void addIdleHandler(android.os.MessageQueue.IdleHandler handler)
  ///
  /// Add a new IdleHandler to this message queue.  This may be
  /// removed automatically for you by returning false from
  /// IdleHandler\#queueIdle IdleHandler.queueIdle() when it is
  /// invoked, or explicitly removing it with \#removeIdleHandler.
  ///
  /// This method is safe to call from any thread.
  ///@param handler The IdleHandler to be added.
  ///
  /// This value must never be {@code null}.
  void addIdleHandler(MessageQueue_IdleHandler handler) =>
      jniAccessors.callMethodWithArgs(reference, _id_addIdleHandler,
          jni.JniType.voidType, [handler.reference]).check();

  static final _id_removeIdleHandler = jniAccessors.getMethodIDOf(_classRef,
      "removeIdleHandler", "(Landroid/os/MessageQueue\$IdleHandler;)V");

  /// from: public void removeIdleHandler(android.os.MessageQueue.IdleHandler handler)
  ///
  /// Remove an IdleHandler from the queue that was previously added
  /// with \#addIdleHandler.  If the given object is not currently
  /// in the idle list, nothing is done.
  ///
  /// This method is safe to call from any thread.
  ///@param handler The IdleHandler to be removed.
  ///
  /// This value must never be {@code null}.
  void removeIdleHandler(MessageQueue_IdleHandler handler) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeIdleHandler,
          jni.JniType.voidType, [handler.reference]).check();

  static final _id_addOnFileDescriptorEventListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addOnFileDescriptorEventListener",
      "(Ljava/io/FileDescriptor;ILandroid/os/MessageQueue\$OnFileDescriptorEventListener;)V");

  /// from: public void addOnFileDescriptorEventListener(java.io.FileDescriptor fd, int events, android.os.MessageQueue.OnFileDescriptorEventListener listener)
  ///
  /// Adds a file descriptor listener to receive notification when file descriptor
  /// related events occur.
  ///
  /// If the file descriptor has already been registered, the specified events
  /// and listener will replace any that were previously associated with it.
  /// It is not possible to set more than one listener per file descriptor.
  ///
  ///
  /// It is important to always unregister the listener when the file descriptor
  /// is no longer of use.
  ///
  ///
  ///@param fd The file descriptor for which a listener will be registered.
  /// This value must never be {@code null}.
  ///@param events The set of events to receive: a combination of the
  /// OnFileDescriptorEventListener\#EVENT_INPUT,
  /// OnFileDescriptorEventListener\#EVENT_OUTPUT, and
  /// OnFileDescriptorEventListener\#EVENT_ERROR event masks.  If the requested
  /// set of events is zero, then the listener is unregistered.
  /// Value is either <code>0</code> or a combination of android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_INPUT, android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_OUTPUT, and android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_ERROR
  ///@param listener The listener to invoke when file descriptor events occur.
  ///
  /// This value must never be {@code null}.
  ///@see OnFileDescriptorEventListener
  ///@see \#removeOnFileDescriptorEventListener
  void addOnFileDescriptorEventListener(jni.JniObject fd, int events,
          MessageQueue_OnFileDescriptorEventListener listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_addOnFileDescriptorEventListener,
          jni.JniType.voidType,
          [fd.reference, events, listener.reference]).check();

  static final _id_removeOnFileDescriptorEventListener =
      jniAccessors.getMethodIDOf(_classRef,
          "removeOnFileDescriptorEventListener", "(Ljava/io/FileDescriptor;)V");

  /// from: public void removeOnFileDescriptorEventListener(java.io.FileDescriptor fd)
  ///
  /// Removes a file descriptor listener.
  ///
  /// This method does nothing if no listener has been registered for the
  /// specified file descriptor.
  ///
  ///
  ///@param fd The file descriptor whose listener will be unregistered.
  ///
  /// This value must never be {@code null}.
  ///@see OnFileDescriptorEventListener
  ///@see \#addOnFileDescriptorEventListener
  void removeOnFileDescriptorEventListener(jni.JniObject fd) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removeOnFileDescriptorEventListener,
          jni.JniType.voidType,
          [fd.reference]).check();
}

/// from: android.os.MessageQueue$OnFileDescriptorEventListener
///
/// A listener which is invoked when file descriptor related events occur.
class MessageQueue_OnFileDescriptorEventListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/os/MessageQueue\$OnFileDescriptorEventListener");
  MessageQueue_OnFileDescriptorEventListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final int EVENT_ERROR
  ///
  /// File descriptor event: Indicates that the file descriptor encountered a
  /// fatal error.
  ///
  /// File descriptor errors can occur for various reasons.  One common error
  /// is when the remote peer of a socket or pipe closes its end of the connection.
  ///
  ///
  /// This event may be generated at any time regardless of whether the
  /// \#EVENT_ERROR event mask was specified when the listener was added.
  ///
  ///
  static const EVENT_ERROR = 4;

  /// from: static public final int EVENT_INPUT
  ///
  /// File descriptor event: Indicates that the file descriptor is ready for input
  /// operations, such as reading.
  ///
  /// The listener should read all available data from the file descriptor
  /// then return <code>true</code> to keep the listener active or <code>false</code>
  /// to remove the listener.
  ///
  ///
  /// In the case of a socket, this event may be generated to indicate
  /// that there is at least one incoming connection that the listener
  /// should accept.
  ///
  ///
  /// This event will only be generated if the \#EVENT_INPUT event mask was
  /// specified when the listener was added.
  ///
  ///
  static const EVENT_INPUT = 1;

  /// from: static public final int EVENT_OUTPUT
  ///
  /// File descriptor event: Indicates that the file descriptor is ready for output
  /// operations, such as writing.
  ///
  /// The listener should write as much data as it needs.  If it could not
  /// write everything at once, then it should return <code>true</code> to
  /// keep the listener active.  Otherwise, it should return <code>false</code>
  /// to remove the listener then re-register it later when it needs to write
  /// something else.
  ///
  ///
  /// This event will only be generated if the \#EVENT_OUTPUT event mask was
  /// specified when the listener was added.
  ///
  ///
  static const EVENT_OUTPUT = 2;

  static final _id_onFileDescriptorEvents = jniAccessors.getMethodIDOf(
      _classRef, "onFileDescriptorEvents", "(Ljava/io/FileDescriptor;I)I");

  /// from: public abstract int onFileDescriptorEvents(java.io.FileDescriptor fd, int events)
  ///
  /// Called when a file descriptor receives events.
  ///@param fd The file descriptor.
  /// This value must never be {@code null}.
  ///@param events The set of events that occurred: a combination of the
  /// \#EVENT_INPUT, \#EVENT_OUTPUT, and \#EVENT_ERROR event masks.
  /// Value is either <code>0</code> or a combination of android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_INPUT, android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_OUTPUT, and android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_ERROR
  ///@return The new set of events to watch, or 0 to unregister the listener.
  ///
  /// Value is either <code>0</code> or a combination of android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_INPUT, android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_OUTPUT, and android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_ERROR
  ///@see \#EVENT_INPUT
  ///@see \#EVENT_OUTPUT
  ///@see \#EVENT_ERROR
  int onFileDescriptorEvents(jni.JniObject fd, int events) =>
      jniAccessors.callMethodWithArgs(reference, _id_onFileDescriptorEvents,
          jni.JniType.intType, [fd.reference, events]).integer;
}

/// from: android.os.MessageQueue$IdleHandler
///
/// Callback interface for discovering when a thread is going to block
/// waiting for more messages.
class MessageQueue_IdleHandler extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/os/MessageQueue\$IdleHandler");
  MessageQueue_IdleHandler.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_queueIdle =
      jniAccessors.getMethodIDOf(_classRef, "queueIdle", "()Z");

  /// from: public abstract boolean queueIdle()
  ///
  /// Called when the message queue has run out of messages and will now
  /// wait for more.  Return true to keep your idle handler active, false
  /// to have it removed.  This may be called if there are still messages
  /// pending in the queue, but they are all scheduled to be dispatched
  /// after the current time.
  bool queueIdle() => jniAccessors.callMethodWithArgs(
      reference, _id_queueIdle, jni.JniType.booleanType, []).boolean;
}
