// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.FileObserver
///
/// Monitors files (using <a href="http://en.wikipedia.org/wiki/Inotify">inotify</a>)
/// to fire an event after files are accessed or changed by by any process on
/// the device (including this one).  FileObserver is an abstract class;
/// subclasses must implement the event handler \#onEvent(int, String).
///
/// Each FileObserver instance monitors a single file or directory.
/// If a directory is monitored, events will be triggered for all files and
/// subdirectories inside the monitored directory.
///
///
/// An event mask is used to specify which changes or actions to report.
/// Event type constants are used to describe the possible changes in the
/// event mask as well as what actually happened in event callbacks.
///
///
/// <p class="caution">__Warning__: If a FileObserver is garbage collected, it
/// will stop sending events.  To ensure you keep receiving events, you must
/// keep a reference to the FileObserver instance from some other live object.
///
class FileObserver extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/FileObserver");
  FileObserver.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ACCESS
  ///
  /// Event type: Data was read from a file
  static const ACCESS = 1;

  /// from: static public final int ALL_EVENTS
  ///
  /// Event mask: All valid event types, combined
  static const ALL_EVENTS = 4095;

  /// from: static public final int ATTRIB
  ///
  /// Event type: Metadata (permissions, owner, timestamp) was changed explicitly
  static const ATTRIB = 4;

  /// from: static public final int CLOSE_NOWRITE
  ///
  /// Event type: Someone had a file or directory open read-only, and closed it
  static const CLOSE_NOWRITE = 16;

  /// from: static public final int CLOSE_WRITE
  ///
  /// Event type: Someone had a file or directory open for writing, and closed it
  static const CLOSE_WRITE = 8;

  /// from: static public final int CREATE
  ///
  /// Event type: A new file or subdirectory was created under the monitored directory
  static const CREATE = 256;

  /// from: static public final int DELETE
  ///
  /// Event type: A file was deleted from the monitored directory
  static const DELETE = 512;

  /// from: static public final int DELETE_SELF
  ///
  /// Event type: The monitored file or directory was deleted; monitoring effectively stops
  static const DELETE_SELF = 1024;

  /// from: static public final int MODIFY
  ///
  /// Event type: Data was written to a file
  static const MODIFY = 2;

  /// from: static public final int MOVED_FROM
  ///
  /// Event type: A file or subdirectory was moved from the monitored directory
  static const MOVED_FROM = 64;

  /// from: static public final int MOVED_TO
  ///
  /// Event type: A file or subdirectory was moved to the monitored directory
  static const MOVED_TO = 128;

  /// from: static public final int MOVE_SELF
  ///
  /// Event type: The monitored file or directory was moved; monitoring continues
  static const MOVE_SELF = 2048;

  /// from: static public final int OPEN
  ///
  /// Event type: A file or directory was opened
  static const OPEN = 32;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String path)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Equivalent to FileObserver(path, FileObserver.ALL_EVENTS).
  FileObserver(jni.JniString path)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [path.reference]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;I)V");

  /// from: public void <init>(java.lang.String path, int mask)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new file observer for a certain file or directory.
  /// Monitoring does not start on creation!  You must call
  /// \#startWatching() before you will receive events.
  ///@param path The file or directory to monitor
  ///@param mask The event or events (added together) to watch for
  FileObserver.ctor1(jni.JniString path, int mask)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [path.reference, mask]).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_startWatching =
      jniAccessors.getMethodIDOf(_classRef, "startWatching", "()V");

  /// from: public void startWatching()
  ///
  /// Start watching for events.  The monitored file or directory must exist at
  /// this time, or else no events will be reported (even if it appears later).
  /// If monitoring is already started, this call has no effect.
  void startWatching() => jniAccessors.callMethodWithArgs(
      reference, _id_startWatching, jni.JniType.voidType, []).check();

  static final _id_stopWatching =
      jniAccessors.getMethodIDOf(_classRef, "stopWatching", "()V");

  /// from: public void stopWatching()
  ///
  /// Stop watching for events.  Some events may be in process, so events
  /// may continue to be reported even after this method completes.  If
  /// monitoring is already stopped, this call has no effect.
  void stopWatching() => jniAccessors.callMethodWithArgs(
      reference, _id_stopWatching, jni.JniType.voidType, []).check();

  static final _id_onEvent = jniAccessors.getMethodIDOf(
      _classRef, "onEvent", "(ILjava/lang/String;)V");

  /// from: public abstract void onEvent(int event, java.lang.String path)
  ///
  /// The event handler, which must be implemented by subclasses.
  ///
  /// <p class="note">This method is invoked on a special FileObserver thread.
  /// It runs independently of any threads, so take care to use appropriate
  /// synchronization!  Consider using Handler\#post(Runnable) to shift
  /// event handling work to the main thread to avoid concurrency problems.
  ///
  ///
  /// Event handlers must not throw exceptions.
  ///
  ///@param event The type of event which happened
  ///@param path The path, relative to the main monitored file or directory,
  ///     of the file or directory which triggered the event.  This value can
  ///     be {@code null} for certain events, such as \#MOVE_SELF.
  ///
  /// This value may be {@code null}.
  void onEvent(int event, jni.JniString path) =>
      jniAccessors.callMethodWithArgs(reference, _id_onEvent,
          jni.JniType.voidType, [event, path.reference]).check();
}
