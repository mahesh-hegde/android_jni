// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "BaseBundle.dart" as basebundle_;

import "Parcelable.dart" as parcelable_;

import "PersistableBundle.dart" as persistablebundle_;

import "../util/Size.dart" as size_;

import "../util/SizeF.dart" as sizef_;

import "../util/SparseArray.dart" as sparsearray_;

import "IBinder.dart" as ibinder_;

import "Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.Bundle
///
/// A mapping from String keys to various Parcelable values.
///@see PersistableBundle
class Bundle extends basebundle_.BaseBundle {
  static final _classRef = jniAccessors.getClassOf("android/os/Bundle");
  Bundle.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.os.Bundle> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_EMPTY = jniAccessors.getStaticFieldIDOf(
      _classRef, "EMPTY", "Landroid/os/Bundle;");

  /// from: static public final android.os.Bundle EMPTY
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Bundle get EMPTY => Bundle.fromRef(jniAccessors
      .getStaticField(_classRef, _id_EMPTY, jni.JniType.objectType)
      .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new, empty Bundle.
  Bundle()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/ClassLoader;)V");

  /// from: public void <init>(java.lang.ClassLoader loader)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new, empty Bundle that uses a specific ClassLoader for
  /// instantiating Parcelable and Serializable objects.
  ///@param loader An explicit ClassLoader to use when instantiating objects
  /// inside of the Bundle.
  Bundle.ctor1(jni.JniObject loader)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [loader.reference]).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int capacity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new, empty Bundle sized to hold the given number of
  /// elements. The Bundle will grow as needed.
  ///@param capacity the initial capacity of the Bundle
  Bundle.ctor2(int capacity)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [capacity]).object);

  static final _id_ctor3 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Bundle;)V");

  /// from: public void <init>(android.os.Bundle b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a Bundle containing a copy of the mappings from the given
  /// Bundle.  Does only a shallow copy of the original Bundle -- see
  /// \#deepCopy() if that is not what you want.
  ///@param b a Bundle to be copied.
  ///@see \#deepCopy()
  Bundle.ctor3(Bundle b)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor3, [b.reference]).object);

  static final _id_ctor4 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/os/PersistableBundle;)V");

  /// from: public void <init>(android.os.PersistableBundle b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a Bundle containing a copy of the mappings from the given
  /// PersistableBundle.  Does only a shallow copy of the PersistableBundle -- see
  /// PersistableBundle\#deepCopy() if you don't want that.
  ///@param b a PersistableBundle to be copied.
  Bundle.ctor4(persistablebundle_.PersistableBundle b)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor4, [b.reference]).object);

  static final _id_setClassLoader = jniAccessors.getMethodIDOf(
      _classRef, "setClassLoader", "(Ljava/lang/ClassLoader;)V");

  /// from: public void setClassLoader(java.lang.ClassLoader loader)
  ///
  /// Changes the ClassLoader this Bundle uses when instantiating objects.
  ///@param loader An explicit ClassLoader to use when instantiating objects
  /// inside of the Bundle.
  void setClassLoader(jni.JniObject loader) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setClassLoader,
      jni.JniType.voidType,
      [loader.reference]).check();

  static final _id_getClassLoader = jniAccessors.getMethodIDOf(
      _classRef, "getClassLoader", "()Ljava/lang/ClassLoader;");

  /// from: public java.lang.ClassLoader getClassLoader()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the ClassLoader currently associated with this Bundle.
  jni.JniObject getClassLoader() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getClassLoader, jni.JniType.objectType, []).object);

  static final _id_clone =
      jniAccessors.getMethodIDOf(_classRef, "clone", "()Ljava/lang/Object;");

  /// from: public java.lang.Object clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Clones the current Bundle. The internal map is cloned, but the keys and
  /// values to which it refers are copied by reference.
  jni.JniObject clone() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_deepCopy = jniAccessors.getMethodIDOf(
      _classRef, "deepCopy", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle deepCopy()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Make a deep copy of the given bundle.  Traverses into inner containers and copies
  /// them as well, so they are not shared across bundles.  Will traverse in to
  /// Bundle, PersistableBundle, ArrayList, and all types of
  /// primitive arrays.  Other types of objects (such as Parcelable or Serializable)
  /// are referenced as-is and not copied in any way.
  Bundle deepCopy() => Bundle.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_deepCopy, jni.JniType.objectType, []).object);

  static final _id_clear =
      jniAccessors.getMethodIDOf(_classRef, "clear", "()V");

  /// from: public void clear()
  ///
  /// Removes all elements from the mapping of this Bundle.
  void clear() => jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniType.voidType, []).check();

  static final _id_remove =
      jniAccessors.getMethodIDOf(_classRef, "remove", "(Ljava/lang/String;)V");

  /// from: public void remove(java.lang.String key)
  ///
  /// Removes any entry with the given key from the mapping of this Bundle.
  ///@param key a String key
  void remove(jni.JniString key) => jniAccessors.callMethodWithArgs(
      reference, _id_remove, jni.JniType.voidType, [key.reference]).check();

  static final _id_putAll1 =
      jniAccessors.getMethodIDOf(_classRef, "putAll", "(Landroid/os/Bundle;)V");

  /// from: public void putAll(android.os.Bundle bundle)
  ///
  /// Inserts all mappings from the given Bundle into this Bundle.
  ///@param bundle a Bundle
  void putAll1(Bundle bundle) => jniAccessors.callMethodWithArgs(
      reference, _id_putAll1, jni.JniType.voidType, [bundle.reference]).check();

  static final _id_hasFileDescriptors =
      jniAccessors.getMethodIDOf(_classRef, "hasFileDescriptors", "()Z");

  /// from: public boolean hasFileDescriptors()
  ///
  /// Reports whether the bundle contains any parcelled file descriptors.
  bool hasFileDescriptors() => jniAccessors.callMethodWithArgs(
      reference, _id_hasFileDescriptors, jni.JniType.booleanType, []).boolean;

  static final _id_putByte = jniAccessors.getMethodIDOf(
      _classRef, "putByte", "(Ljava/lang/String;B)V");

  /// from: public void putByte(java.lang.String key, byte value)
  ///
  /// Inserts a byte value into the mapping of this Bundle, replacing
  /// any existing value for the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a byte
  void putByte(jni.JniString key, int value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_putByte,
      jni.JniType.voidType,
      [key.reference, value]).check();

  static final _id_putChar = jniAccessors.getMethodIDOf(
      _classRef, "putChar", "(Ljava/lang/String;C)V");

  /// from: public void putChar(java.lang.String key, char value)
  ///
  /// Inserts a char value into the mapping of this Bundle, replacing
  /// any existing value for the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a char
  void putChar(jni.JniString key, int value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_putChar,
      jni.JniType.voidType,
      [key.reference, value]).check();

  static final _id_putShort = jniAccessors.getMethodIDOf(
      _classRef, "putShort", "(Ljava/lang/String;S)V");

  /// from: public void putShort(java.lang.String key, short value)
  ///
  /// Inserts a short value into the mapping of this Bundle, replacing
  /// any existing value for the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a short
  void putShort(jni.JniString key, int value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putShort,
          jni.JniType.voidType, [key.reference, value]).check();

  static final _id_putFloat = jniAccessors.getMethodIDOf(
      _classRef, "putFloat", "(Ljava/lang/String;F)V");

  /// from: public void putFloat(java.lang.String key, float value)
  ///
  /// Inserts a float value into the mapping of this Bundle, replacing
  /// any existing value for the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a float
  void putFloat(jni.JniString key, double value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putFloat,
          jni.JniType.voidType, [key.reference, value]).check();

  static final _id_putCharSequence = jniAccessors.getMethodIDOf(_classRef,
      "putCharSequence", "(Ljava/lang/String;Ljava/lang/CharSequence;)V");

  /// from: public void putCharSequence(java.lang.String key, java.lang.CharSequence value)
  ///
  /// Inserts a CharSequence value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a CharSequence, or null
  ///
  /// This value may be {@code null}.
  void putCharSequence(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putCharSequence,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putParcelable = jniAccessors.getMethodIDOf(_classRef,
      "putParcelable", "(Ljava/lang/String;Landroid/os/Parcelable;)V");

  /// from: public void putParcelable(java.lang.String key, android.os.Parcelable value)
  ///
  /// Inserts a Parcelable value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a Parcelable object, or null
  ///
  /// This value may be {@code null}.
  void putParcelable(jni.JniString key, parcelable_.Parcelable value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putParcelable,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putSize = jniAccessors.getMethodIDOf(
      _classRef, "putSize", "(Ljava/lang/String;Landroid/util/Size;)V");

  /// from: public void putSize(java.lang.String key, android.util.Size value)
  ///
  /// Inserts a Size value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a Size object, or null
  ///
  /// This value may be {@code null}.
  void putSize(jni.JniString key, size_.Size value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putSize,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putSizeF = jniAccessors.getMethodIDOf(
      _classRef, "putSizeF", "(Ljava/lang/String;Landroid/util/SizeF;)V");

  /// from: public void putSizeF(java.lang.String key, android.util.SizeF value)
  ///
  /// Inserts a SizeF value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a SizeF object, or null
  ///
  /// This value may be {@code null}.
  void putSizeF(jni.JniString key, sizef_.SizeF value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putSizeF,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putParcelableArray = jniAccessors.getMethodIDOf(_classRef,
      "putParcelableArray", "(Ljava/lang/String;[Landroid/os/Parcelable;)V");

  /// from: public void putParcelableArray(java.lang.String key, android.os.Parcelable[] value)
  ///
  /// Inserts an array of Parcelable values into the mapping of this Bundle,
  /// replacing any existing value for the given key.  Either key or value may
  /// be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value an array of Parcelable objects, or null
  ///
  /// This value may be {@code null}.
  void putParcelableArray(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putParcelableArray,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putParcelableArrayList = jniAccessors.getMethodIDOf(
      _classRef,
      "putParcelableArrayList",
      "(Ljava/lang/String;Ljava/util/ArrayList;)V");

  /// from: public void putParcelableArrayList(java.lang.String key, java.util.ArrayList<? extends android.os.Parcelable> value)
  ///
  /// Inserts a List of Parcelable values into the mapping of this Bundle,
  /// replacing any existing value for the given key.  Either key or value may
  /// be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value an ArrayList of Parcelable objects, or null
  ///
  /// This value may be {@code null}.
  void putParcelableArrayList(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putParcelableArrayList,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putSparseParcelableArray = jniAccessors.getMethodIDOf(
      _classRef,
      "putSparseParcelableArray",
      "(Ljava/lang/String;Landroid/util/SparseArray;)V");

  /// from: public void putSparseParcelableArray(java.lang.String key, android.util.SparseArray<? extends android.os.Parcelable> value)
  ///
  /// Inserts a SparceArray of Parcelable values into the mapping of this
  /// Bundle, replacing any existing value for the given key.  Either key
  /// or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a SparseArray of Parcelable objects, or null
  ///
  /// This value may be {@code null}.
  void putSparseParcelableArray(
          jni.JniString key, sparsearray_.SparseArray value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putSparseParcelableArray,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putIntegerArrayList = jniAccessors.getMethodIDOf(_classRef,
      "putIntegerArrayList", "(Ljava/lang/String;Ljava/util/ArrayList;)V");

  /// from: public void putIntegerArrayList(java.lang.String key, java.util.ArrayList<java.lang.Integer> value)
  ///
  /// Inserts an ArrayList<Integer> value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value an ArrayList<Integer> object, or null
  ///
  /// This value may be {@code null}.
  void putIntegerArrayList(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putIntegerArrayList,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putStringArrayList = jniAccessors.getMethodIDOf(_classRef,
      "putStringArrayList", "(Ljava/lang/String;Ljava/util/ArrayList;)V");

  /// from: public void putStringArrayList(java.lang.String key, java.util.ArrayList<java.lang.String> value)
  ///
  /// Inserts an ArrayList<String> value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value an ArrayList<String> object, or null
  ///
  /// This value may be {@code null}.
  void putStringArrayList(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putStringArrayList,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putCharSequenceArrayList = jniAccessors.getMethodIDOf(
      _classRef,
      "putCharSequenceArrayList",
      "(Ljava/lang/String;Ljava/util/ArrayList;)V");

  /// from: public void putCharSequenceArrayList(java.lang.String key, java.util.ArrayList<java.lang.CharSequence> value)
  ///
  /// Inserts an ArrayList<CharSequence> value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value an ArrayList<CharSequence> object, or null
  ///
  /// This value may be {@code null}.
  void putCharSequenceArrayList(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putCharSequenceArrayList,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putSerializable = jniAccessors.getMethodIDOf(_classRef,
      "putSerializable", "(Ljava/lang/String;Ljava/io/Serializable;)V");

  /// from: public void putSerializable(java.lang.String key, java.io.Serializable value)
  ///
  /// Inserts a Serializable value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a Serializable object, or null
  ///
  /// This value may be {@code null}.
  void putSerializable(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putSerializable,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putByteArray = jniAccessors.getMethodIDOf(
      _classRef, "putByteArray", "(Ljava/lang/String;[B)V");

  /// from: public void putByteArray(java.lang.String key, byte[] value)
  ///
  /// Inserts a byte array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a byte array object, or null
  ///
  /// This value may be {@code null}.
  void putByteArray(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putByteArray,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putShortArray = jniAccessors.getMethodIDOf(
      _classRef, "putShortArray", "(Ljava/lang/String;[S)V");

  /// from: public void putShortArray(java.lang.String key, short[] value)
  ///
  /// Inserts a short array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a short array object, or null
  ///
  /// This value may be {@code null}.
  void putShortArray(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putShortArray,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putCharArray = jniAccessors.getMethodIDOf(
      _classRef, "putCharArray", "(Ljava/lang/String;[C)V");

  /// from: public void putCharArray(java.lang.String key, char[] value)
  ///
  /// Inserts a char array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a char array object, or null
  ///
  /// This value may be {@code null}.
  void putCharArray(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putCharArray,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putFloatArray = jniAccessors.getMethodIDOf(
      _classRef, "putFloatArray", "(Ljava/lang/String;[F)V");

  /// from: public void putFloatArray(java.lang.String key, float[] value)
  ///
  /// Inserts a float array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a float array object, or null
  ///
  /// This value may be {@code null}.
  void putFloatArray(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putFloatArray,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putCharSequenceArray = jniAccessors.getMethodIDOf(_classRef,
      "putCharSequenceArray", "(Ljava/lang/String;[Ljava/lang/CharSequence;)V");

  /// from: public void putCharSequenceArray(java.lang.String key, java.lang.CharSequence[] value)
  ///
  /// Inserts a CharSequence array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a CharSequence array object, or null
  ///
  /// This value may be {@code null}.
  void putCharSequenceArray(jni.JniString key, jni.JniObject value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putCharSequenceArray,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putBundle = jniAccessors.getMethodIDOf(
      _classRef, "putBundle", "(Ljava/lang/String;Landroid/os/Bundle;)V");

  /// from: public void putBundle(java.lang.String key, android.os.Bundle value)
  ///
  /// Inserts a Bundle value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a Bundle object, or null
  ///
  /// This value may be {@code null}.
  void putBundle(jni.JniString key, Bundle value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putBundle,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_putBinder = jniAccessors.getMethodIDOf(
      _classRef, "putBinder", "(Ljava/lang/String;Landroid/os/IBinder;)V");

  /// from: public void putBinder(java.lang.String key, android.os.IBinder value)
  ///
  /// Inserts an IBinder value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///
  /// <p class="note">You should be very careful when using this function.  In many
  /// places where Bundles are used (such as inside of Intent objects), the Bundle
  /// can live longer inside of another process than the process that had originally
  /// created it.  In that case, the IBinder you supply here will become invalid
  /// when your process goes away, and no longer usable, even if a new process is
  /// created for you later on.
  ///
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value an IBinder object, or null
  ///
  /// This value may be {@code null}.
  void putBinder(jni.JniString key, ibinder_.IBinder value) =>
      jniAccessors.callMethodWithArgs(reference, _id_putBinder,
          jni.JniType.voidType, [key.reference, value.reference]).check();

  static final _id_getByte =
      jniAccessors.getMethodIDOf(_classRef, "getByte", "(Ljava/lang/String;)B");

  /// from: public byte getByte(java.lang.String key)
  ///
  /// Returns the value associated with the given key, or (byte) 0 if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@return a byte value
  int getByte(jni.JniString key) => jniAccessors.callMethodWithArgs(
      reference, _id_getByte, jni.JniType.byteType, [key.reference]).byte;

  static final _id_getByte1 = jniAccessors.getMethodIDOf(
      _classRef, "getByte", "(Ljava/lang/String;B)Ljava/lang/Byte;");

  /// from: public java.lang.Byte getByte(java.lang.String key, byte defaultValue)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@param defaultValue Value to return if key does not exist
  ///@return a byte value
  jni.JniObject getByte1(jni.JniString key, int defaultValue) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getByte1,
          jni.JniType.objectType,
          [key.reference, defaultValue]).object);

  static final _id_getChar =
      jniAccessors.getMethodIDOf(_classRef, "getChar", "(Ljava/lang/String;)C");

  /// from: public char getChar(java.lang.String key)
  ///
  /// Returns the value associated with the given key, or (char) 0 if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@return a char value
  int getChar(jni.JniString key) => jniAccessors.callMethodWithArgs(
      reference, _id_getChar, jni.JniType.charType, [key.reference]).char;

  static final _id_getChar1 = jniAccessors.getMethodIDOf(
      _classRef, "getChar", "(Ljava/lang/String;C)C");

  /// from: public char getChar(java.lang.String key, char defaultValue)
  ///
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@param defaultValue Value to return if key does not exist
  ///@return a char value
  int getChar1(jni.JniString key, int defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getChar1,
          jni.JniType.charType, [key.reference, defaultValue]).char;

  static final _id_getShort = jniAccessors.getMethodIDOf(
      _classRef, "getShort", "(Ljava/lang/String;)S");

  /// from: public short getShort(java.lang.String key)
  ///
  /// Returns the value associated with the given key, or (short) 0 if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@return a short value
  int getShort(jni.JniString key) => jniAccessors.callMethodWithArgs(
      reference, _id_getShort, jni.JniType.shortType, [key.reference]).short;

  static final _id_getShort1 = jniAccessors.getMethodIDOf(
      _classRef, "getShort", "(Ljava/lang/String;S)S");

  /// from: public short getShort(java.lang.String key, short defaultValue)
  ///
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@param defaultValue Value to return if key does not exist
  ///@return a short value
  int getShort1(jni.JniString key, int defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getShort1,
          jni.JniType.shortType, [key.reference, defaultValue]).short;

  static final _id_getFloat = jniAccessors.getMethodIDOf(
      _classRef, "getFloat", "(Ljava/lang/String;)F");

  /// from: public float getFloat(java.lang.String key)
  ///
  /// Returns the value associated with the given key, or 0.0f if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@return a float value
  double getFloat(jni.JniString key) => jniAccessors.callMethodWithArgs(
      reference, _id_getFloat, jni.JniType.floatType, [key.reference]).float;

  static final _id_getFloat1 = jniAccessors.getMethodIDOf(
      _classRef, "getFloat", "(Ljava/lang/String;F)F");

  /// from: public float getFloat(java.lang.String key, float defaultValue)
  ///
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@param defaultValue Value to return if key does not exist
  ///@return a float value
  double getFloat1(jni.JniString key, double defaultValue) =>
      jniAccessors.callMethodWithArgs(reference, _id_getFloat1,
          jni.JniType.floatType, [key.reference, defaultValue]).float;

  static final _id_getCharSequence = jniAccessors.getMethodIDOf(_classRef,
      "getCharSequence", "(Ljava/lang/String;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getCharSequence(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a CharSequence value, or null
  jni.JniObject getCharSequence(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCharSequence, jni.JniType.objectType, [key.reference]).object);

  static final _id_getCharSequence1 = jniAccessors.getMethodIDOf(
      _classRef,
      "getCharSequence",
      "(Ljava/lang/String;Ljava/lang/CharSequence;)Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getCharSequence(java.lang.String key, java.lang.CharSequence defaultValue)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key or if a null
  /// value is explicitly associatd with the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param defaultValue Value to return if key does not exist or if a null
  ///     value is associated with the given key.
  ///@return the CharSequence value associated with the given key, or defaultValue
  ///     if no valid CharSequence object is currently mapped to that key.
  jni.JniObject getCharSequence1(
          jni.JniString key, jni.JniObject defaultValue) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCharSequence1,
          jni.JniType.objectType,
          [key.reference, defaultValue.reference]).object);

  static final _id_getSize = jniAccessors.getMethodIDOf(
      _classRef, "getSize", "(Ljava/lang/String;)Landroid/util/Size;");

  /// from: public android.util.Size getSize(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a Size value, or null
  size_.Size getSize(jni.JniString key) =>
      size_.Size.fromRef(jniAccessors.callMethodWithArgs(reference, _id_getSize,
          jni.JniType.objectType, [key.reference]).object);

  static final _id_getSizeF = jniAccessors.getMethodIDOf(
      _classRef, "getSizeF", "(Ljava/lang/String;)Landroid/util/SizeF;");

  /// from: public android.util.SizeF getSizeF(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a Size value, or null
  sizef_.SizeF getSizeF(jni.JniString key) =>
      sizef_.SizeF.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSizeF, jni.JniType.objectType, [key.reference]).object);

  static final _id_getBundle = jniAccessors.getMethodIDOf(
      _classRef, "getBundle", "(Ljava/lang/String;)Landroid/os/Bundle;");

  /// from: public android.os.Bundle getBundle(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a Bundle value, or null
  Bundle getBundle(jni.JniString key) =>
      Bundle.fromRef(jniAccessors.callMethodWithArgs(reference, _id_getBundle,
          jni.JniType.objectType, [key.reference]).object);

  static final _id_getParcelableArray = jniAccessors.getMethodIDOf(_classRef,
      "getParcelableArray", "(Ljava/lang/String;)[Landroid/os/Parcelable;");

  /// from: public android.os.Parcelable[] getParcelableArray(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a Parcelable[] value, or null
  jni.JniObject getParcelableArray(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getParcelableArray,
          jni.JniType.objectType,
          [key.reference]).object);

  static final _id_getParcelableArrayList = jniAccessors.getMethodIDOf(
      _classRef,
      "getParcelableArrayList",
      "(Ljava/lang/String;)Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList<T> getParcelableArrayList(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return an ArrayList<T> value, or null
  jni.JniObject getParcelableArrayList(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getParcelableArrayList,
          jni.JniType.objectType,
          [key.reference]).object);

  static final _id_getSparseParcelableArray = jniAccessors.getMethodIDOf(
      _classRef,
      "getSparseParcelableArray",
      "(Ljava/lang/String;)Landroid/util/SparseArray;");

  /// from: public android.util.SparseArray<T> getSparseParcelableArray(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  ///
  /// This value may be {@code null}.
  ///@return a SparseArray of T values, or null
  sparsearray_.SparseArray getSparseParcelableArray(jni.JniString key) =>
      sparsearray_.SparseArray.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSparseParcelableArray,
          jni.JniType.objectType,
          [key.reference]).object);

  static final _id_getSerializable = jniAccessors.getMethodIDOf(_classRef,
      "getSerializable", "(Ljava/lang/String;)Ljava/io/Serializable;");

  /// from: public java.io.Serializable getSerializable(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a Serializable value, or null
  jni.JniObject getSerializable(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSerializable, jni.JniType.objectType, [key.reference]).object);

  static final _id_getIntegerArrayList = jniAccessors.getMethodIDOf(_classRef,
      "getIntegerArrayList", "(Ljava/lang/String;)Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList<java.lang.Integer> getIntegerArrayList(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return an ArrayList<String> value, or null
  jni.JniObject getIntegerArrayList(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getIntegerArrayList,
          jni.JniType.objectType,
          [key.reference]).object);

  static final _id_getStringArrayList = jniAccessors.getMethodIDOf(_classRef,
      "getStringArrayList", "(Ljava/lang/String;)Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList<java.lang.String> getStringArrayList(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return an ArrayList<String> value, or null
  jni.JniObject getStringArrayList(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getStringArrayList,
          jni.JniType.objectType,
          [key.reference]).object);

  static final _id_getCharSequenceArrayList = jniAccessors.getMethodIDOf(
      _classRef,
      "getCharSequenceArrayList",
      "(Ljava/lang/String;)Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList<java.lang.CharSequence> getCharSequenceArrayList(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return an ArrayList<CharSequence> value, or null
  jni.JniObject getCharSequenceArrayList(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCharSequenceArrayList,
          jni.JniType.objectType,
          [key.reference]).object);

  static final _id_getByteArray = jniAccessors.getMethodIDOf(
      _classRef, "getByteArray", "(Ljava/lang/String;)[B");

  /// from: public byte[] getByteArray(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a byte[] value, or null
  jni.JniObject getByteArray(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getByteArray, jni.JniType.objectType, [key.reference]).object);

  static final _id_getShortArray = jniAccessors.getMethodIDOf(
      _classRef, "getShortArray", "(Ljava/lang/String;)[S");

  /// from: public short[] getShortArray(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a short[] value, or null
  jni.JniObject getShortArray(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getShortArray, jni.JniType.objectType, [key.reference]).object);

  static final _id_getCharArray = jniAccessors.getMethodIDOf(
      _classRef, "getCharArray", "(Ljava/lang/String;)[C");

  /// from: public char[] getCharArray(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a char[] value, or null
  jni.JniObject getCharArray(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCharArray, jni.JniType.objectType, [key.reference]).object);

  static final _id_getFloatArray = jniAccessors.getMethodIDOf(
      _classRef, "getFloatArray", "(Ljava/lang/String;)[F");

  /// from: public float[] getFloatArray(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a float[] value, or null
  jni.JniObject getFloatArray(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getFloatArray, jni.JniType.objectType, [key.reference]).object);

  static final _id_getCharSequenceArray = jniAccessors.getMethodIDOf(_classRef,
      "getCharSequenceArray", "(Ljava/lang/String;)[Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence[] getCharSequenceArray(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a CharSequence[] value, or null
  jni.JniObject getCharSequenceArray(jni.JniString key) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getCharSequenceArray,
          jni.JniType.objectType,
          [key.reference]).object);

  static final _id_getBinder = jniAccessors.getMethodIDOf(
      _classRef, "getBinder", "(Ljava/lang/String;)Landroid/os/IBinder;");

  /// from: public android.os.IBinder getBinder(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return an IBinder value, or null
  ibinder_.IBinder getBinder(jni.JniString key) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getBinder, jni.JniType.objectType, [key.reference]).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  ///
  /// Report the nature of this Parcelable's contents
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  ///
  /// Writes the Bundle contents to a Parcel, typically in order for
  /// it to be passed through an IBinder connection.
  ///@param parcel The parcel to copy this bundle to.
  void writeToParcel(parcel_.Parcel parcel, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [parcel.reference, flags]).check();

  static final _id_readFromParcel = jniAccessors.getMethodIDOf(
      _classRef, "readFromParcel", "(Landroid/os/Parcel;)V");

  /// from: public void readFromParcel(android.os.Parcel parcel)
  ///
  /// Reads the Parcel contents into this Bundle, typically in order for
  /// it to be passed through an IBinder connection.
  ///@param parcel The parcel to overwrite this bundle from.
  void readFromParcel(parcel_.Parcel parcel) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readFromParcel,
      jni.JniType.voidType,
      [parcel.reference]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: synchronized public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
