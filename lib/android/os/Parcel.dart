// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Parcelable.dart" as parcelable_;

import "IBinder.dart" as ibinder_;

import "IInterface.dart" as iinterface_;

import "Bundle.dart" as bundle_;

import "PersistableBundle.dart" as persistablebundle_;

import "../util/Size.dart" as size_;

import "../util/SizeF.dart" as sizef_;

import "../util/SparseArray.dart" as sparsearray_;

import "../util/SparseBooleanArray.dart" as sparsebooleanarray_;

import "ParcelFileDescriptor.dart" as parcelfiledescriptor_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.Parcel
///
/// Container for a message (data and object references) that can
/// be sent through an IBinder.  A Parcel can contain both flattened data
/// that will be unflattened on the other side of the IPC (using the various
/// methods here for writing specific types, or the general
/// Parcelable interface), and references to live IBinder
/// objects that will result in the other side receiving a proxy IBinder
/// connected with the original IBinder in the Parcel.
///
/// <p class="note">Parcel is <strong>not</strong> a general-purpose
/// serialization mechanism.  This class (and the corresponding
/// Parcelable API for placing arbitrary objects into a Parcel) is
/// designed as a high-performance IPC transport.  As such, it is not
/// appropriate to place any Parcel data in to persistent storage: changes
/// in the underlying implementation of any of the data in the Parcel can
/// render older data unreadable.
///
///
/// The bulk of the Parcel API revolves around reading and writing data
/// of various types.  There are six major classes of such functions available.
///
///
/// <h3>Primitives</h3>
///
/// The most basic data functions are for writing and reading primitive
/// data types: \#writeByte, \#readByte, \#writeDouble,
/// \#readDouble, \#writeFloat, \#readFloat, \#writeInt,
/// \#readInt, \#writeLong, \#readLong,
/// \#writeString, \#readString.  Most other
/// data operations are built on top of these.  The given data is written and
/// read using the endianess of the host CPU.
///
///
/// <h3>Primitive Arrays</h3>
///
/// There are a variety of methods for reading and writing raw arrays
/// of primitive objects, which generally result in writing a 4-byte length
/// followed by the primitive data items.  The methods for reading can either
/// read the data into an existing array, or create and return a new array.
/// These available types are:
///
///
/// <ul>
/// <li> \#writeBooleanArray(boolean[]),
/// \#readBooleanArray(boolean[]), \#createBooleanArray()
/// <li> \#writeByteArray(byte[]),
/// \#writeByteArray(byte[], int, int), \#readByteArray(byte[]),
/// \#createByteArray()
/// <li> \#writeCharArray(char[]), \#readCharArray(char[]),
/// \#createCharArray()
/// <li> \#writeDoubleArray(double[]), \#readDoubleArray(double[]),
/// \#createDoubleArray()
/// <li> \#writeFloatArray(float[]), \#readFloatArray(float[]),
/// \#createFloatArray()
/// <li> \#writeIntArray(int[]), \#readIntArray(int[]),
/// \#createIntArray()
/// <li> \#writeLongArray(long[]), \#readLongArray(long[]),
/// \#createLongArray()
/// <li> \#writeStringArray(String[]), \#readStringArray(String[]),
/// \#createStringArray().
/// <li> \#writeSparseBooleanArray(SparseBooleanArray),
/// \#readSparseBooleanArray().
/// </ul>
///
/// <h3>Parcelables</h3>
///
/// The Parcelable protocol provides an extremely efficient (but
/// low-level) protocol for objects to write and read themselves from Parcels.
/// You can use the direct methods \#writeParcelable(Parcelable, int)
/// and \#readParcelable(ClassLoader) or
/// \#writeParcelableArray and
/// \#readParcelableArray(ClassLoader) to write or read.  These
/// methods write both the class type and its data to the Parcel, allowing
/// that class to be reconstructed from the appropriate class loader when
/// later reading.
///
///
/// There are also some methods that provide a more efficient way to work
/// with Parcelables: \#writeTypedObject, \#writeTypedArray,
/// \#writeTypedList, \#readTypedObject,
/// \#createTypedArray and \#createTypedArrayList.  These methods
/// do not write the class information of the original object: instead, the
/// caller of the read function must know what type to expect and pass in the
/// appropriate Parcelable.Creator Parcelable.Creator instead to
/// properly construct the new object and read its data.  (To more efficient
/// write and read a single Parcelable object that is not null, you can directly
/// call Parcelable\#writeToParcel Parcelable.writeToParcel and
/// Parcelable.Creator\#createFromParcel Parcelable.Creator.createFromParcel
/// yourself.)
///
///
/// <h3>Bundles</h3>
///
/// A special type-safe container, called Bundle, is available
/// for key/value maps of heterogeneous values.  This has many optimizations
/// for improved performance when reading and writing data, and its type-safe
/// API avoids difficult to debug type errors when finally marshalling the
/// data contents into a Parcel.  The methods to use are
/// \#writeBundle(Bundle), \#readBundle(), and
/// \#readBundle(ClassLoader).
///
/// <h3>Active Objects</h3>
///
/// An unusual feature of Parcel is the ability to read and write active
/// objects.  For these objects the actual contents of the object is not
/// written, rather a special token referencing the object is written.  When
/// reading the object back from the Parcel, you do not get a new instance of
/// the object, but rather a handle that operates on the exact same object that
/// was originally written.  There are two forms of active objects available.
///
///
/// Binder objects are a core facility of Android's general cross-process
/// communication system.  The IBinder interface describes an abstract
/// protocol with a Binder object.  Any such interface can be written in to
/// a Parcel, and upon reading you will receive either the original object
/// implementing that interface or a special proxy implementation
/// that communicates calls back to the original object.  The methods to use are
/// \#writeStrongBinder(IBinder),
/// \#writeStrongInterface(IInterface), \#readStrongBinder(),
/// \#writeBinderArray(IBinder[]), \#readBinderArray(IBinder[]),
/// \#createBinderArray(),
/// \#writeBinderList(List), \#readBinderList(List),
/// \#createBinderArrayList().
///
///
/// FileDescriptor objects, representing raw Linux file descriptor identifiers,
/// can be written and ParcelFileDescriptor objects returned to operate
/// on the original file descriptor.  The returned file descriptor is a dup
/// of the original file descriptor: the object and fd is different, but
/// operating on the same underlying file stream, with the same position, etc.
/// The methods to use are \#writeFileDescriptor(FileDescriptor),
/// \#readFileDescriptor().
///
/// <h3>Untyped Containers</h3>
///
/// A final class of methods are for writing and reading standard Java
/// containers of arbitrary types.  These all revolve around the
/// \#writeValue(Object) and \#readValue(ClassLoader) methods
/// which define the types of objects allowed.  The container methods are
/// \#writeArray(Object[]), \#readArray(ClassLoader),
/// \#writeList(List), \#readList(List, ClassLoader),
/// \#readArrayList(ClassLoader),
/// \#writeMap(Map), \#readMap(Map, ClassLoader),
/// \#writeSparseArray(SparseArray),
/// \#readSparseArray(ClassLoader).
class Parcel extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/Parcel");
  Parcel.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_STRING_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "STRING_CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<java.lang.String> STRING_CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get STRING_CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_STRING_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_obtain = jniAccessors.getStaticMethodIDOf(
      _classRef, "obtain", "()Landroid/os/Parcel;");

  /// from: static public android.os.Parcel obtain()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a new Parcel object from the pool.
  static Parcel obtain() =>
      Parcel.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_obtain, jni.JniType.objectType, []).object);

  static final _id_recycle =
      jniAccessors.getMethodIDOf(_classRef, "recycle", "()V");

  /// from: public void recycle()
  ///
  /// Put a Parcel object back into the pool.  You must not touch
  /// the object after this call.
  void recycle() => jniAccessors.callMethodWithArgs(
      reference, _id_recycle, jni.JniType.voidType, []).check();

  static final _id_dataSize =
      jniAccessors.getMethodIDOf(_classRef, "dataSize", "()I");

  /// from: public int dataSize()
  ///
  /// Returns the total amount of data contained in the parcel.
  int dataSize() => jniAccessors.callMethodWithArgs(
      reference, _id_dataSize, jni.JniType.intType, []).integer;

  static final _id_dataAvail =
      jniAccessors.getMethodIDOf(_classRef, "dataAvail", "()I");

  /// from: public int dataAvail()
  ///
  /// Returns the amount of data remaining to be read from the
  /// parcel.  That is, \#dataSize-\#dataPosition.
  int dataAvail() => jniAccessors.callMethodWithArgs(
      reference, _id_dataAvail, jni.JniType.intType, []).integer;

  static final _id_dataPosition =
      jniAccessors.getMethodIDOf(_classRef, "dataPosition", "()I");

  /// from: public int dataPosition()
  ///
  /// Returns the current position in the parcel data.  Never
  /// more than \#dataSize.
  int dataPosition() => jniAccessors.callMethodWithArgs(
      reference, _id_dataPosition, jni.JniType.intType, []).integer;

  static final _id_dataCapacity =
      jniAccessors.getMethodIDOf(_classRef, "dataCapacity", "()I");

  /// from: public int dataCapacity()
  ///
  /// Returns the total amount of space in the parcel.  This is always
  /// >= \#dataSize.  The difference between it and dataSize() is the
  /// amount of room left until the parcel needs to re-allocate its
  /// data buffer.
  int dataCapacity() => jniAccessors.callMethodWithArgs(
      reference, _id_dataCapacity, jni.JniType.intType, []).integer;

  static final _id_setDataSize =
      jniAccessors.getMethodIDOf(_classRef, "setDataSize", "(I)V");

  /// from: public void setDataSize(int size)
  ///
  /// Change the amount of data in the parcel.  Can be either smaller or
  /// larger than the current size.  If larger than the current capacity,
  /// more memory will be allocated.
  ///@param size The new number of bytes in the Parcel.
  void setDataSize(int size) => jniAccessors.callMethodWithArgs(
      reference, _id_setDataSize, jni.JniType.voidType, [size]).check();

  static final _id_setDataPosition =
      jniAccessors.getMethodIDOf(_classRef, "setDataPosition", "(I)V");

  /// from: public void setDataPosition(int pos)
  ///
  /// Move the current read/write position in the parcel.
  ///@param pos New offset in the parcel; must be between 0 and
  /// \#dataSize.
  void setDataPosition(int pos) => jniAccessors.callMethodWithArgs(
      reference, _id_setDataPosition, jni.JniType.voidType, [pos]).check();

  static final _id_setDataCapacity =
      jniAccessors.getMethodIDOf(_classRef, "setDataCapacity", "(I)V");

  /// from: public void setDataCapacity(int size)
  ///
  /// Change the capacity (current available space) of the parcel.
  ///@param size The new capacity of the parcel, in bytes.  Can not be
  /// less than \#dataSize -- that is, you can not drop existing data
  /// with this method.
  void setDataCapacity(int size) => jniAccessors.callMethodWithArgs(
      reference, _id_setDataCapacity, jni.JniType.voidType, [size]).check();

  static final _id_marshall =
      jniAccessors.getMethodIDOf(_classRef, "marshall", "()[B");

  /// from: public byte[] marshall()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the raw bytes of the parcel.
  ///
  /// <p class="note">The data you retrieve here <strong>must not</strong>
  /// be placed in any kind of persistent storage (on local disk, across
  /// a network, etc).  For that, you should use standard serialization
  /// or another kind of general serialization mechanism.  The Parcel
  /// marshalled representation is highly optimized for local IPC, and as
  /// such does not attempt to maintain compatibility with data created
  /// in different versions of the platform.
  jni.JniObject marshall() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_marshall, jni.JniType.objectType, []).object);

  static final _id_unmarshall =
      jniAccessors.getMethodIDOf(_classRef, "unmarshall", "([BII)V");

  /// from: public void unmarshall(byte[] data, int offset, int length)
  ///
  /// Set the bytes in data to be the raw bytes of this Parcel.
  void unmarshall(jni.JniObject data, int offset, int length) =>
      jniAccessors.callMethodWithArgs(reference, _id_unmarshall,
          jni.JniType.voidType, [data.reference, offset, length]).check();

  static final _id_appendFrom = jniAccessors.getMethodIDOf(
      _classRef, "appendFrom", "(Landroid/os/Parcel;II)V");

  /// from: public void appendFrom(android.os.Parcel parcel, int offset, int length)
  void appendFrom(Parcel parcel, int offset, int length) =>
      jniAccessors.callMethodWithArgs(reference, _id_appendFrom,
          jni.JniType.voidType, [parcel.reference, offset, length]).check();

  static final _id_hasFileDescriptors =
      jniAccessors.getMethodIDOf(_classRef, "hasFileDescriptors", "()Z");

  /// from: public boolean hasFileDescriptors()
  ///
  /// Report whether the parcel contains any marshalled file descriptors.
  bool hasFileDescriptors() => jniAccessors.callMethodWithArgs(
      reference, _id_hasFileDescriptors, jni.JniType.booleanType, []).boolean;

  static final _id_writeInterfaceToken = jniAccessors.getMethodIDOf(
      _classRef, "writeInterfaceToken", "(Ljava/lang/String;)V");

  /// from: public void writeInterfaceToken(java.lang.String interfaceName)
  ///
  /// Store or read an IBinder interface token in the parcel at the current
  /// \#dataPosition.  This is used to validate that the marshalled
  /// transaction is intended for the target interface.
  void writeInterfaceToken(jni.JniString interfaceName) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeInterfaceToken,
          jni.JniType.voidType, [interfaceName.reference]).check();

  static final _id_enforceInterface = jniAccessors.getMethodIDOf(
      _classRef, "enforceInterface", "(Ljava/lang/String;)V");

  /// from: public void enforceInterface(java.lang.String interfaceName)
  void enforceInterface(jni.JniString interfaceName) =>
      jniAccessors.callMethodWithArgs(reference, _id_enforceInterface,
          jni.JniType.voidType, [interfaceName.reference]).check();

  static final _id_writeByteArray =
      jniAccessors.getMethodIDOf(_classRef, "writeByteArray", "([B)V");

  /// from: public void writeByteArray(byte[] b)
  ///
  /// Write a byte array into the parcel at the current \#dataPosition,
  /// growing \#dataCapacity if needed.
  ///@param b Bytes to place into the parcel.
  void writeByteArray(jni.JniObject b) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeByteArray,
      jni.JniType.voidType,
      [b.reference]).check();

  static final _id_writeByteArray1 =
      jniAccessors.getMethodIDOf(_classRef, "writeByteArray", "([BII)V");

  /// from: public void writeByteArray(byte[] b, int offset, int len)
  ///
  /// Write a byte array into the parcel at the current \#dataPosition,
  /// growing \#dataCapacity if needed.
  ///@param b Bytes to place into the parcel.
  ///@param offset Index of first byte to be written.
  ///@param len Number of bytes to write.
  void writeByteArray1(jni.JniObject b, int offset, int len) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeByteArray1,
          jni.JniType.voidType, [b.reference, offset, len]).check();

  static final _id_writeInt =
      jniAccessors.getMethodIDOf(_classRef, "writeInt", "(I)V");

  /// from: public void writeInt(int val)
  ///
  /// Write an integer value into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeInt(int val) => jniAccessors.callMethodWithArgs(
      reference, _id_writeInt, jni.JniType.voidType, [val]).check();

  static final _id_writeLong =
      jniAccessors.getMethodIDOf(_classRef, "writeLong", "(J)V");

  /// from: public void writeLong(long val)
  ///
  /// Write a long integer value into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeLong(int val) => jniAccessors.callMethodWithArgs(
      reference, _id_writeLong, jni.JniType.voidType, [val]).check();

  static final _id_writeFloat =
      jniAccessors.getMethodIDOf(_classRef, "writeFloat", "(F)V");

  /// from: public void writeFloat(float val)
  ///
  /// Write a floating point value into the parcel at the current
  /// dataPosition(), growing dataCapacity() if needed.
  void writeFloat(double val) => jniAccessors.callMethodWithArgs(
      reference, _id_writeFloat, jni.JniType.voidType, [val]).check();

  static final _id_writeDouble =
      jniAccessors.getMethodIDOf(_classRef, "writeDouble", "(D)V");

  /// from: public void writeDouble(double val)
  ///
  /// Write a double precision floating point value into the parcel at the
  /// current dataPosition(), growing dataCapacity() if needed.
  void writeDouble(double val) => jniAccessors.callMethodWithArgs(
      reference, _id_writeDouble, jni.JniType.voidType, [val]).check();

  static final _id_writeString = jniAccessors.getMethodIDOf(
      _classRef, "writeString", "(Ljava/lang/String;)V");

  /// from: public void writeString(java.lang.String val)
  ///
  /// Write a string value into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeString(jni.JniString val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeString,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_writeStrongBinder = jniAccessors.getMethodIDOf(
      _classRef, "writeStrongBinder", "(Landroid/os/IBinder;)V");

  /// from: public void writeStrongBinder(android.os.IBinder val)
  ///
  /// Write an object into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeStrongBinder(ibinder_.IBinder val) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeStrongBinder,
          jni.JniType.voidType, [val.reference]).check();

  static final _id_writeStrongInterface = jniAccessors.getMethodIDOf(
      _classRef, "writeStrongInterface", "(Landroid/os/IInterface;)V");

  /// from: public void writeStrongInterface(android.os.IInterface val)
  ///
  /// Write an object into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeStrongInterface(iinterface_.IInterface val) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeStrongInterface,
          jni.JniType.voidType, [val.reference]).check();

  static final _id_writeFileDescriptor = jniAccessors.getMethodIDOf(
      _classRef, "writeFileDescriptor", "(Ljava/io/FileDescriptor;)V");

  /// from: public void writeFileDescriptor(java.io.FileDescriptor val)
  ///
  /// Write a FileDescriptor into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  ///
  /// <p class="caution">The file descriptor will not be closed, which may
  /// result in file descriptor leaks when objects are returned from Binder
  /// calls.  Use ParcelFileDescriptor\#writeToParcel instead, which
  /// accepts contextual flags and will close the original file descriptor
  /// if Parcelable\#PARCELABLE_WRITE_RETURN_VALUE is set.
  ///
  void writeFileDescriptor(jni.JniObject val) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeFileDescriptor,
          jni.JniType.voidType, [val.reference]).check();

  static final _id_writeByte =
      jniAccessors.getMethodIDOf(_classRef, "writeByte", "(B)V");

  /// from: public void writeByte(byte val)
  ///
  /// Write a byte value into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeByte(int val) => jniAccessors.callMethodWithArgs(
      reference, _id_writeByte, jni.JniType.voidType, [val]).check();

  static final _id_writeMap =
      jniAccessors.getMethodIDOf(_classRef, "writeMap", "(Ljava/util/Map;)V");

  /// from: public void writeMap(java.util.Map val)
  ///
  /// Please use \#writeBundle instead.  Flattens a Map into the parcel
  /// at the current dataPosition(),
  /// growing dataCapacity() if needed.  The Map keys must be String objects.
  /// The Map values are written using \#writeValue and must follow
  /// the specification there.
  ///
  /// It is strongly recommended to use \#writeBundle instead of
  /// this method, since the Bundle class provides a type-safe API that
  /// allows you to avoid mysterious type errors at the point of marshalling.
  void writeMap(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference, _id_writeMap, jni.JniType.voidType, [val.reference]).check();

  static final _id_writeBundle = jniAccessors.getMethodIDOf(
      _classRef, "writeBundle", "(Landroid/os/Bundle;)V");

  /// from: public void writeBundle(android.os.Bundle val)
  ///
  /// Flatten a Bundle into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeBundle(bundle_.Bundle val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeBundle,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_writePersistableBundle = jniAccessors.getMethodIDOf(
      _classRef, "writePersistableBundle", "(Landroid/os/PersistableBundle;)V");

  /// from: public void writePersistableBundle(android.os.PersistableBundle val)
  ///
  /// Flatten a PersistableBundle into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writePersistableBundle(persistablebundle_.PersistableBundle val) =>
      jniAccessors.callMethodWithArgs(reference, _id_writePersistableBundle,
          jni.JniType.voidType, [val.reference]).check();

  static final _id_writeSize = jniAccessors.getMethodIDOf(
      _classRef, "writeSize", "(Landroid/util/Size;)V");

  /// from: public void writeSize(android.util.Size val)
  ///
  /// Flatten a Size into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeSize(size_.Size val) => jniAccessors.callMethodWithArgs(
      reference, _id_writeSize, jni.JniType.voidType, [val.reference]).check();

  static final _id_writeSizeF = jniAccessors.getMethodIDOf(
      _classRef, "writeSizeF", "(Landroid/util/SizeF;)V");

  /// from: public void writeSizeF(android.util.SizeF val)
  ///
  /// Flatten a SizeF into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeSizeF(sizef_.SizeF val) => jniAccessors.callMethodWithArgs(
      reference, _id_writeSizeF, jni.JniType.voidType, [val.reference]).check();

  static final _id_writeList =
      jniAccessors.getMethodIDOf(_classRef, "writeList", "(Ljava/util/List;)V");

  /// from: public void writeList(java.util.List val)
  ///
  /// Flatten a List into the parcel at the current dataPosition(), growing
  /// dataCapacity() if needed.  The List values are written using
  /// \#writeValue and must follow the specification there.
  void writeList(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference, _id_writeList, jni.JniType.voidType, [val.reference]).check();

  static final _id_writeArray = jniAccessors.getMethodIDOf(
      _classRef, "writeArray", "([Ljava/lang/Object;)V");

  /// from: public void writeArray(java.lang.Object[] val)
  ///
  /// Flatten an Object array into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.  The array values are written using
  /// \#writeValue and must follow the specification there.
  void writeArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference, _id_writeArray, jni.JniType.voidType, [val.reference]).check();

  static final _id_writeSparseArray = jniAccessors.getMethodIDOf(
      _classRef, "writeSparseArray", "(Landroid/util/SparseArray;)V");

  /// from: public void writeSparseArray(android.util.SparseArray<java.lang.Object> val)
  ///
  /// Flatten a generic SparseArray into the parcel at the current
  /// dataPosition(), growing dataCapacity() if needed.  The SparseArray
  /// values are written using \#writeValue and must follow the
  /// specification there.
  void writeSparseArray(sparsearray_.SparseArray val) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeSparseArray,
          jni.JniType.voidType, [val.reference]).check();

  static final _id_writeSparseBooleanArray = jniAccessors.getMethodIDOf(
      _classRef,
      "writeSparseBooleanArray",
      "(Landroid/util/SparseBooleanArray;)V");

  /// from: public void writeSparseBooleanArray(android.util.SparseBooleanArray val)
  void writeSparseBooleanArray(sparsebooleanarray_.SparseBooleanArray val) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeSparseBooleanArray,
          jni.JniType.voidType, [val.reference]).check();

  static final _id_writeBooleanArray =
      jniAccessors.getMethodIDOf(_classRef, "writeBooleanArray", "([Z)V");

  /// from: public void writeBooleanArray(boolean[] val)
  void writeBooleanArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeBooleanArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_createBooleanArray =
      jniAccessors.getMethodIDOf(_classRef, "createBooleanArray", "()[Z");

  /// from: public boolean[] createBooleanArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject createBooleanArray() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_createBooleanArray, jni.JniType.objectType, []).object);

  static final _id_readBooleanArray =
      jniAccessors.getMethodIDOf(_classRef, "readBooleanArray", "([Z)V");

  /// from: public void readBooleanArray(boolean[] val)
  void readBooleanArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readBooleanArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_writeCharArray =
      jniAccessors.getMethodIDOf(_classRef, "writeCharArray", "([C)V");

  /// from: public void writeCharArray(char[] val)
  void writeCharArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeCharArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_createCharArray =
      jniAccessors.getMethodIDOf(_classRef, "createCharArray", "()[C");

  /// from: public char[] createCharArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject createCharArray() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createCharArray, jni.JniType.objectType, []).object);

  static final _id_readCharArray =
      jniAccessors.getMethodIDOf(_classRef, "readCharArray", "([C)V");

  /// from: public void readCharArray(char[] val)
  void readCharArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readCharArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_writeIntArray =
      jniAccessors.getMethodIDOf(_classRef, "writeIntArray", "([I)V");

  /// from: public void writeIntArray(int[] val)
  void writeIntArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeIntArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_createIntArray =
      jniAccessors.getMethodIDOf(_classRef, "createIntArray", "()[I");

  /// from: public int[] createIntArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject createIntArray() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createIntArray, jni.JniType.objectType, []).object);

  static final _id_readIntArray =
      jniAccessors.getMethodIDOf(_classRef, "readIntArray", "([I)V");

  /// from: public void readIntArray(int[] val)
  void readIntArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readIntArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_writeLongArray =
      jniAccessors.getMethodIDOf(_classRef, "writeLongArray", "([J)V");

  /// from: public void writeLongArray(long[] val)
  void writeLongArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeLongArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_createLongArray =
      jniAccessors.getMethodIDOf(_classRef, "createLongArray", "()[J");

  /// from: public long[] createLongArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject createLongArray() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createLongArray, jni.JniType.objectType, []).object);

  static final _id_readLongArray =
      jniAccessors.getMethodIDOf(_classRef, "readLongArray", "([J)V");

  /// from: public void readLongArray(long[] val)
  void readLongArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readLongArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_writeFloatArray =
      jniAccessors.getMethodIDOf(_classRef, "writeFloatArray", "([F)V");

  /// from: public void writeFloatArray(float[] val)
  void writeFloatArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeFloatArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_createFloatArray =
      jniAccessors.getMethodIDOf(_classRef, "createFloatArray", "()[F");

  /// from: public float[] createFloatArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject createFloatArray() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createFloatArray, jni.JniType.objectType, []).object);

  static final _id_readFloatArray =
      jniAccessors.getMethodIDOf(_classRef, "readFloatArray", "([F)V");

  /// from: public void readFloatArray(float[] val)
  void readFloatArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readFloatArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_writeDoubleArray =
      jniAccessors.getMethodIDOf(_classRef, "writeDoubleArray", "([D)V");

  /// from: public void writeDoubleArray(double[] val)
  void writeDoubleArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeDoubleArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_createDoubleArray =
      jniAccessors.getMethodIDOf(_classRef, "createDoubleArray", "()[D");

  /// from: public double[] createDoubleArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject createDoubleArray() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createDoubleArray, jni.JniType.objectType, []).object);

  static final _id_readDoubleArray =
      jniAccessors.getMethodIDOf(_classRef, "readDoubleArray", "([D)V");

  /// from: public void readDoubleArray(double[] val)
  void readDoubleArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readDoubleArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_writeStringArray = jniAccessors.getMethodIDOf(
      _classRef, "writeStringArray", "([Ljava/lang/String;)V");

  /// from: public void writeStringArray(java.lang.String[] val)
  void writeStringArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeStringArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_createStringArray = jniAccessors.getMethodIDOf(
      _classRef, "createStringArray", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] createStringArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject createStringArray() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createStringArray, jni.JniType.objectType, []).object);

  static final _id_readStringArray = jniAccessors.getMethodIDOf(
      _classRef, "readStringArray", "([Ljava/lang/String;)V");

  /// from: public void readStringArray(java.lang.String[] val)
  void readStringArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readStringArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_writeBinderArray = jniAccessors.getMethodIDOf(
      _classRef, "writeBinderArray", "([Landroid/os/IBinder;)V");

  /// from: public void writeBinderArray(android.os.IBinder[] val)
  void writeBinderArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeBinderArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_createBinderArray = jniAccessors.getMethodIDOf(
      _classRef, "createBinderArray", "()[Landroid/os/IBinder;");

  /// from: public android.os.IBinder[] createBinderArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject createBinderArray() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createBinderArray, jni.JniType.objectType, []).object);

  static final _id_readBinderArray = jniAccessors.getMethodIDOf(
      _classRef, "readBinderArray", "([Landroid/os/IBinder;)V");

  /// from: public void readBinderArray(android.os.IBinder[] val)
  void readBinderArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readBinderArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_writeTypedList = jniAccessors.getMethodIDOf(
      _classRef, "writeTypedList", "(Ljava/util/List;)V");

  /// from: public void writeTypedList(java.util.List<T> val)
  ///
  /// Flatten a List containing a particular object type into the parcel, at
  /// the current dataPosition() and growing dataCapacity() if needed.  The
  /// type of the objects in the list must be one that implements Parcelable.
  /// Unlike the generic writeList() method, however, only the raw data of the
  /// objects is written and not their type, so you must use the corresponding
  /// readTypedList() to unmarshall them.
  ///@param val The list of objects to be written.
  ///@see \#createTypedArrayList
  ///@see \#readTypedList
  ///@see Parcelable
  void writeTypedList(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeTypedList,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_writeStringList = jniAccessors.getMethodIDOf(
      _classRef, "writeStringList", "(Ljava/util/List;)V");

  /// from: public void writeStringList(java.util.List<java.lang.String> val)
  ///
  /// Flatten a List containing String objects into the parcel, at
  /// the current dataPosition() and growing dataCapacity() if needed.  They
  /// can later be retrieved with \#createStringArrayList or
  /// \#readStringList.
  ///@param val The list of strings to be written.
  ///@see \#createStringArrayList
  ///@see \#readStringList
  void writeStringList(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeStringList,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_writeBinderList = jniAccessors.getMethodIDOf(
      _classRef, "writeBinderList", "(Ljava/util/List;)V");

  /// from: public void writeBinderList(java.util.List<android.os.IBinder> val)
  ///
  /// Flatten a List containing IBinder objects into the parcel, at
  /// the current dataPosition() and growing dataCapacity() if needed.  They
  /// can later be retrieved with \#createBinderArrayList or
  /// \#readBinderList.
  ///@param val The list of strings to be written.
  ///@see \#createBinderArrayList
  ///@see \#readBinderList
  void writeBinderList(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeBinderList,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_writeTypedArray = jniAccessors.getMethodIDOf(
      _classRef, "writeTypedArray", "([Ljava/lang/Object;I)V");

  /// from: public void writeTypedArray(T[] val, int parcelableFlags)
  ///
  /// Flatten a homogeneous array containing a particular object type into
  /// the parcel, at
  /// the current dataPosition() and growing dataCapacity() if needed.  The
  /// type of the objects in the array must be one that implements Parcelable.
  /// Unlike the \#writeParcelableArray method, however, only the
  /// raw data of the objects is written and not their type, so you must use
  /// \#readTypedArray with the correct corresponding
  /// Parcelable.Creator implementation to unmarshall them.
  ///@param val The array of objects to be written.
  ///@param parcelableFlags Contextual flags as per
  /// Parcelable\#writeToParcel(Parcel, int) Parcelable.writeToParcel().
  ///@see \#readTypedArray
  ///@see \#writeParcelableArray
  ///@see Parcelable.Creator
  void writeTypedArray(jni.JniObject val, int parcelableFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeTypedArray,
          jni.JniType.voidType, [val.reference, parcelableFlags]).check();

  static final _id_writeValue = jniAccessors.getMethodIDOf(
      _classRef, "writeValue", "(Ljava/lang/Object;)V");

  /// from: public void writeValue(java.lang.Object v)
  ///
  /// Flatten a generic object in to a parcel.  The given Object value may
  /// currently be one of the following types:
  ///
  /// <ul>
  /// <li> null
  /// <li> String
  /// <li> Byte
  /// <li> Short
  /// <li> Integer
  /// <li> Long
  /// <li> Float
  /// <li> Double
  /// <li> Boolean
  /// <li> String[]
  /// <li> boolean[]
  /// <li> byte[]
  /// <li> int[]
  /// <li> long[]
  /// <li> Object[] (supporting objects of the same type defined here).
  /// <li> Bundle
  /// <li> Map (as supported by \#writeMap).
  /// <li> Any object that implements the Parcelable protocol.
  /// <li> Parcelable[]
  /// <li> CharSequence (as supported by TextUtils\#writeToParcel).
  /// <li> List (as supported by \#writeList).
  /// <li> SparseArray (as supported by \#writeSparseArray(SparseArray)).
  /// <li> IBinder
  /// <li> Any object that implements Serializable (but see
  ///      \#writeSerializable for caveats).  Note that all of the
  ///      previous types have relatively efficient implementations for
  ///      writing to a Parcel; having to rely on the generic serialization
  ///      approach is much less efficient and should be avoided whenever
  ///      possible.
  /// </ul>
  ///
  /// <p class="caution">Parcelable objects are written with
  /// Parcelable\#writeToParcel using contextual flags of 0.  When
  /// serializing objects containing ParcelFileDescriptors,
  /// this may result in file descriptor leaks when they are returned from
  /// Binder calls (where Parcelable\#PARCELABLE_WRITE_RETURN_VALUE
  /// should be used).
  ///
  void writeValue(jni.JniObject v) => jniAccessors.callMethodWithArgs(
      reference, _id_writeValue, jni.JniType.voidType, [v.reference]).check();

  static final _id_writeParcelable = jniAccessors.getMethodIDOf(
      _classRef, "writeParcelable", "(Landroid/os/Parcelable;I)V");

  /// from: public void writeParcelable(android.os.Parcelable p, int parcelableFlags)
  ///
  /// Flatten the name of the class of the Parcelable and its contents
  /// into the parcel.
  ///@param p The Parcelable object to be written.
  ///@param parcelableFlags Contextual flags as per
  /// Parcelable\#writeToParcel(Parcel, int) Parcelable.writeToParcel().
  void writeParcelable(parcelable_.Parcelable p, int parcelableFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeParcelable,
          jni.JniType.voidType, [p.reference, parcelableFlags]).check();

  static final _id_writeSerializable = jniAccessors.getMethodIDOf(
      _classRef, "writeSerializable", "(Ljava/io/Serializable;)V");

  /// from: public void writeSerializable(java.io.Serializable s)
  ///
  /// Write a generic serializable object in to a Parcel.  It is strongly
  /// recommended that this method be avoided, since the serialization
  /// overhead is extremely large, and this approach will be much slower than
  /// using the other approaches to writing data in to a Parcel.
  void writeSerializable(jni.JniObject s) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeSerializable,
      jni.JniType.voidType,
      [s.reference]).check();

  static final _id_writeException = jniAccessors.getMethodIDOf(
      _classRef, "writeException", "(Ljava/lang/Exception;)V");

  /// from: public void writeException(java.lang.Exception e)
  ///
  /// Special function for writing an exception result at the header of
  /// a parcel, to be used when returning an exception from a transaction.
  /// Note that this currently only supports a few exception types; any other
  /// exception will be re-thrown by this function as a RuntimeException
  /// (to be caught by the system's last-resort exception handling when
  /// dispatching a transaction).
  ///
  /// The supported exception types are:
  /// <ul>
  /// <li>BadParcelableException
  /// <li>IllegalArgumentException
  /// <li>IllegalStateException
  /// <li>NullPointerException
  /// <li>SecurityException
  /// <li>UnsupportedOperationException
  /// <li>NetworkOnMainThreadException
  /// </ul>
  ///@param e The Exception to be written.
  ///@see \#writeNoException
  ///@see \#readException
  void writeException(jni.JniObject e) => jniAccessors.callMethodWithArgs(
      reference,
      _id_writeException,
      jni.JniType.voidType,
      [e.reference]).check();

  static final _id_writeNoException =
      jniAccessors.getMethodIDOf(_classRef, "writeNoException", "()V");

  /// from: public void writeNoException()
  ///
  /// Special function for writing information at the front of the Parcel
  /// indicating that no exception occurred.
  ///@see \#writeException
  ///@see \#readException
  void writeNoException() => jniAccessors.callMethodWithArgs(
      reference, _id_writeNoException, jni.JniType.voidType, []).check();

  static final _id_readException =
      jniAccessors.getMethodIDOf(_classRef, "readException", "()V");

  /// from: public void readException()
  ///
  /// Special function for reading an exception result from the header of
  /// a parcel, to be used after receiving the result of a transaction.  This
  /// will throw the exception for you if it had been written to the Parcel,
  /// otherwise return and let you read the normal result data from the Parcel.
  ///@see \#writeException
  ///@see \#writeNoException
  void readException() => jniAccessors.callMethodWithArgs(
      reference, _id_readException, jni.JniType.voidType, []).check();

  static final _id_readException1 = jniAccessors.getMethodIDOf(
      _classRef, "readException", "(ILjava/lang/String;)V");

  /// from: public void readException(int code, java.lang.String msg)
  ///
  /// Throw an exception with the given message. Not intended for use
  /// outside the Parcel class.
  ///@param code Used to determine which exception class to throw.
  ///@param msg The exception message.
  void readException1(int code, jni.JniString msg) =>
      jniAccessors.callMethodWithArgs(reference, _id_readException1,
          jni.JniType.voidType, [code, msg.reference]).check();

  static final _id_readInt =
      jniAccessors.getMethodIDOf(_classRef, "readInt", "()I");

  /// from: public int readInt()
  ///
  /// Read an integer value from the parcel at the current dataPosition().
  int readInt() => jniAccessors.callMethodWithArgs(
      reference, _id_readInt, jni.JniType.intType, []).integer;

  static final _id_readLong =
      jniAccessors.getMethodIDOf(_classRef, "readLong", "()J");

  /// from: public long readLong()
  ///
  /// Read a long integer value from the parcel at the current dataPosition().
  int readLong() => jniAccessors.callMethodWithArgs(
      reference, _id_readLong, jni.JniType.longType, []).long;

  static final _id_readFloat =
      jniAccessors.getMethodIDOf(_classRef, "readFloat", "()F");

  /// from: public float readFloat()
  ///
  /// Read a floating point value from the parcel at the current
  /// dataPosition().
  double readFloat() => jniAccessors.callMethodWithArgs(
      reference, _id_readFloat, jni.JniType.floatType, []).float;

  static final _id_readDouble =
      jniAccessors.getMethodIDOf(_classRef, "readDouble", "()D");

  /// from: public double readDouble()
  ///
  /// Read a double precision floating point value from the parcel at the
  /// current dataPosition().
  double readDouble() => jniAccessors.callMethodWithArgs(
      reference, _id_readDouble, jni.JniType.doubleType, []).doubleFloat;

  static final _id_readString = jniAccessors.getMethodIDOf(
      _classRef, "readString", "()Ljava/lang/String;");

  /// from: public java.lang.String readString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read a string value from the parcel at the current dataPosition().
  jni.JniString readString() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_readString, jni.JniType.objectType, []).object);

  static final _id_readStrongBinder = jniAccessors.getMethodIDOf(
      _classRef, "readStrongBinder", "()Landroid/os/IBinder;");

  /// from: public android.os.IBinder readStrongBinder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read an object from the parcel at the current dataPosition().
  ibinder_.IBinder readStrongBinder() =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_readStrongBinder, jni.JniType.objectType, []).object);

  static final _id_readFileDescriptor = jniAccessors.getMethodIDOf(
      _classRef, "readFileDescriptor", "()Landroid/os/ParcelFileDescriptor;");

  /// from: public android.os.ParcelFileDescriptor readFileDescriptor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read a FileDescriptor from the parcel at the current dataPosition().
  parcelfiledescriptor_.ParcelFileDescriptor readFileDescriptor() =>
      parcelfiledescriptor_.ParcelFileDescriptor.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_readFileDescriptor,
              jni.JniType.objectType, []).object);

  static final _id_readByte =
      jniAccessors.getMethodIDOf(_classRef, "readByte", "()B");

  /// from: public byte readByte()
  ///
  /// Read a byte value from the parcel at the current dataPosition().
  int readByte() => jniAccessors.callMethodWithArgs(
      reference, _id_readByte, jni.JniType.byteType, []).byte;

  static final _id_readMap = jniAccessors.getMethodIDOf(
      _classRef, "readMap", "(Ljava/util/Map;Ljava/lang/ClassLoader;)V");

  /// from: public void readMap(java.util.Map outVal, java.lang.ClassLoader loader)
  ///
  /// Please use \#readBundle(ClassLoader) instead (whose data must have
  /// been written with \#writeBundle.  Read into an existing Map object
  /// from the parcel at the current dataPosition().
  void readMap(jni.JniObject outVal, jni.JniObject loader) =>
      jniAccessors.callMethodWithArgs(reference, _id_readMap,
          jni.JniType.voidType, [outVal.reference, loader.reference]).check();

  static final _id_readList = jniAccessors.getMethodIDOf(
      _classRef, "readList", "(Ljava/util/List;Ljava/lang/ClassLoader;)V");

  /// from: public void readList(java.util.List outVal, java.lang.ClassLoader loader)
  ///
  /// Read into an existing List object from the parcel at the current
  /// dataPosition(), using the given class loader to load any enclosed
  /// Parcelables.  If it is null, the default class loader is used.
  void readList(jni.JniObject outVal, jni.JniObject loader) =>
      jniAccessors.callMethodWithArgs(reference, _id_readList,
          jni.JniType.voidType, [outVal.reference, loader.reference]).check();

  static final _id_readHashMap = jniAccessors.getMethodIDOf(
      _classRef, "readHashMap", "(Ljava/lang/ClassLoader;)Ljava/util/HashMap;");

  /// from: public java.util.HashMap readHashMap(java.lang.ClassLoader loader)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Please use \#readBundle(ClassLoader) instead (whose data must have
  /// been written with \#writeBundle.  Read and return a new HashMap
  /// object from the parcel at the current dataPosition(), using the given
  /// class loader to load any enclosed Parcelables.  Returns null if
  /// the previously written map object was null.
  jni.JniObject readHashMap(jni.JniObject loader) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_readHashMap, jni.JniType.objectType, [loader.reference]).object);

  static final _id_readBundle = jniAccessors.getMethodIDOf(
      _classRef, "readBundle", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle readBundle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read and return a new Bundle object from the parcel at the current
  /// dataPosition().  Returns null if the previously written Bundle object was
  /// null.
  bundle_.Bundle readBundle() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_readBundle, jni.JniType.objectType, []).object);

  static final _id_readBundle1 = jniAccessors.getMethodIDOf(
      _classRef, "readBundle", "(Ljava/lang/ClassLoader;)Landroid/os/Bundle;");

  /// from: public android.os.Bundle readBundle(java.lang.ClassLoader loader)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read and return a new Bundle object from the parcel at the current
  /// dataPosition(), using the given class loader to initialize the class
  /// loader of the Bundle for later retrieval of Parcelable objects.
  /// Returns null if the previously written Bundle object was null.
  bundle_.Bundle readBundle1(jni.JniObject loader) =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_readBundle1, jni.JniType.objectType, [loader.reference]).object);

  static final _id_readPersistableBundle = jniAccessors.getMethodIDOf(
      _classRef, "readPersistableBundle", "()Landroid/os/PersistableBundle;");

  /// from: public android.os.PersistableBundle readPersistableBundle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read and return a new Bundle object from the parcel at the current
  /// dataPosition().  Returns null if the previously written Bundle object was
  /// null.
  persistablebundle_.PersistableBundle readPersistableBundle() =>
      persistablebundle_.PersistableBundle.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_readPersistableBundle,
              jni.JniType.objectType, []).object);

  static final _id_readPersistableBundle1 = jniAccessors.getMethodIDOf(
      _classRef,
      "readPersistableBundle",
      "(Ljava/lang/ClassLoader;)Landroid/os/PersistableBundle;");

  /// from: public android.os.PersistableBundle readPersistableBundle(java.lang.ClassLoader loader)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read and return a new Bundle object from the parcel at the current
  /// dataPosition(), using the given class loader to initialize the class
  /// loader of the Bundle for later retrieval of Parcelable objects.
  /// Returns null if the previously written Bundle object was null.
  persistablebundle_.PersistableBundle readPersistableBundle1(
          jni.JniObject loader) =>
      persistablebundle_.PersistableBundle.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_readPersistableBundle1,
              jni.JniType.objectType, [loader.reference]).object);

  static final _id_readSize = jniAccessors.getMethodIDOf(
      _classRef, "readSize", "()Landroid/util/Size;");

  /// from: public android.util.Size readSize()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read a Size from the parcel at the current dataPosition().
  size_.Size readSize() => size_.Size.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_readSize, jni.JniType.objectType, []).object);

  static final _id_readSizeF = jniAccessors.getMethodIDOf(
      _classRef, "readSizeF", "()Landroid/util/SizeF;");

  /// from: public android.util.SizeF readSizeF()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read a SizeF from the parcel at the current dataPosition().
  sizef_.SizeF readSizeF() =>
      sizef_.SizeF.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_readSizeF, jni.JniType.objectType, []).object);

  static final _id_createByteArray =
      jniAccessors.getMethodIDOf(_classRef, "createByteArray", "()[B");

  /// from: public byte[] createByteArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read and return a byte[] object from the parcel.
  jni.JniObject createByteArray() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createByteArray, jni.JniType.objectType, []).object);

  static final _id_readByteArray =
      jniAccessors.getMethodIDOf(_classRef, "readByteArray", "([B)V");

  /// from: public void readByteArray(byte[] val)
  ///
  /// Read a byte[] object from the parcel and copy it into the
  /// given byte array.
  void readByteArray(jni.JniObject val) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readByteArray,
      jni.JniType.voidType,
      [val.reference]).check();

  static final _id_readArrayList = jniAccessors.getMethodIDOf(_classRef,
      "readArrayList", "(Ljava/lang/ClassLoader;)Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList readArrayList(java.lang.ClassLoader loader)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read and return a new ArrayList object from the parcel at the current
  /// dataPosition().  Returns null if the previously written list object was
  /// null.  The given class loader will be used to load any enclosed
  /// Parcelables.
  jni.JniObject readArrayList(jni.JniObject loader) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_readArrayList,
          jni.JniType.objectType,
          [loader.reference]).object);

  static final _id_readArray = jniAccessors.getMethodIDOf(
      _classRef, "readArray", "(Ljava/lang/ClassLoader;)[Ljava/lang/Object;");

  /// from: public java.lang.Object[] readArray(java.lang.ClassLoader loader)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read and return a new Object array from the parcel at the current
  /// dataPosition().  Returns null if the previously written array was
  /// null.  The given class loader will be used to load any enclosed
  /// Parcelables.
  jni.JniObject readArray(jni.JniObject loader) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_readArray, jni.JniType.objectType, [loader.reference]).object);

  static final _id_readSparseArray = jniAccessors.getMethodIDOf(_classRef,
      "readSparseArray", "(Ljava/lang/ClassLoader;)Landroid/util/SparseArray;");

  /// from: public android.util.SparseArray readSparseArray(java.lang.ClassLoader loader)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read and return a new SparseArray object from the parcel at the current
  /// dataPosition().  Returns null if the previously written list object was
  /// null.  The given class loader will be used to load any enclosed
  /// Parcelables.
  sparsearray_.SparseArray readSparseArray(jni.JniObject loader) =>
      sparsearray_.SparseArray.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_readSparseArray,
          jni.JniType.objectType,
          [loader.reference]).object);

  static final _id_readSparseBooleanArray = jniAccessors.getMethodIDOf(
      _classRef,
      "readSparseBooleanArray",
      "()Landroid/util/SparseBooleanArray;");

  /// from: public android.util.SparseBooleanArray readSparseBooleanArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read and return a new SparseBooleanArray object from the parcel at the current
  /// dataPosition().  Returns null if the previously written list object was
  /// null.
  sparsebooleanarray_.SparseBooleanArray readSparseBooleanArray() =>
      sparsebooleanarray_.SparseBooleanArray.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_readSparseBooleanArray,
              jni.JniType.objectType, []).object);

  static final _id_createTypedArrayList = jniAccessors.getMethodIDOf(
      _classRef,
      "createTypedArrayList",
      "(Landroid/os/Parcelable\$Creator;)Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList<T> createTypedArrayList(android.os.Parcelable.Creator<T> c)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read and return a new ArrayList containing a particular object type from
  /// the parcel that was written with \#writeTypedList at the
  /// current dataPosition().  Returns null if the
  /// previously written list object was null.  The list _must_ have
  /// previously been written via \#writeTypedList with the same object
  /// type.
  ///@return A newly created ArrayList containing objects with the same data
  ///         as those that were previously written.
  ///@see \#writeTypedList
  jni.JniObject createTypedArrayList(parcelable_.Parcelable_Creator c) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_createTypedArrayList,
          jni.JniType.objectType,
          [c.reference]).object);

  static final _id_readTypedList = jniAccessors.getMethodIDOf(_classRef,
      "readTypedList", "(Ljava/util/List;Landroid/os/Parcelable\$Creator;)V");

  /// from: public void readTypedList(java.util.List<T> list, android.os.Parcelable.Creator<T> c)
  ///
  /// Read into the given List items containing a particular object type
  /// that were written with \#writeTypedList at the
  /// current dataPosition().  The list _must_ have
  /// previously been written via \#writeTypedList with the same object
  /// type.
  ///@return A newly created ArrayList containing objects with the same data
  ///         as those that were previously written.
  ///@see \#writeTypedList
  void readTypedList(jni.JniObject list, parcelable_.Parcelable_Creator c) =>
      jniAccessors.callMethodWithArgs(reference, _id_readTypedList,
          jni.JniType.voidType, [list.reference, c.reference]).check();

  static final _id_createStringArrayList = jniAccessors.getMethodIDOf(
      _classRef, "createStringArrayList", "()Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList<java.lang.String> createStringArrayList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read and return a new ArrayList containing String objects from
  /// the parcel that was written with \#writeStringList at the
  /// current dataPosition().  Returns null if the
  /// previously written list object was null.
  ///@return A newly created ArrayList containing strings with the same data
  ///         as those that were previously written.
  ///@see \#writeStringList
  jni.JniObject createStringArrayList() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_createStringArrayList, jni.JniType.objectType, []).object);

  static final _id_createBinderArrayList = jniAccessors.getMethodIDOf(
      _classRef, "createBinderArrayList", "()Ljava/util/ArrayList;");

  /// from: public java.util.ArrayList<android.os.IBinder> createBinderArrayList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read and return a new ArrayList containing IBinder objects from
  /// the parcel that was written with \#writeBinderList at the
  /// current dataPosition().  Returns null if the
  /// previously written list object was null.
  ///@return A newly created ArrayList containing strings with the same data
  ///         as those that were previously written.
  ///@see \#writeBinderList
  jni.JniObject createBinderArrayList() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_createBinderArrayList, jni.JniType.objectType, []).object);

  static final _id_readStringList = jniAccessors.getMethodIDOf(
      _classRef, "readStringList", "(Ljava/util/List;)V");

  /// from: public void readStringList(java.util.List<java.lang.String> list)
  ///
  /// Read into the given List items String objects that were written with
  /// \#writeStringList at the current dataPosition().
  ///@see \#writeStringList
  void readStringList(jni.JniObject list) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readStringList,
      jni.JniType.voidType,
      [list.reference]).check();

  static final _id_readBinderList = jniAccessors.getMethodIDOf(
      _classRef, "readBinderList", "(Ljava/util/List;)V");

  /// from: public void readBinderList(java.util.List<android.os.IBinder> list)
  ///
  /// Read into the given List items IBinder objects that were written with
  /// \#writeBinderList at the current dataPosition().
  ///@see \#writeBinderList
  void readBinderList(jni.JniObject list) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readBinderList,
      jni.JniType.voidType,
      [list.reference]).check();

  static final _id_createTypedArray = jniAccessors.getMethodIDOf(
      _classRef,
      "createTypedArray",
      "(Landroid/os/Parcelable\$Creator;)[Ljava/lang/Object;");

  /// from: public T[] createTypedArray(android.os.Parcelable.Creator<T> c)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read and return a new array containing a particular object type from
  /// the parcel at the current dataPosition().  Returns null if the
  /// previously written array was null.  The array _must_ have
  /// previously been written via \#writeTypedArray with the same
  /// object type.
  ///@return A newly created array containing objects with the same data
  ///         as those that were previously written.
  ///@see \#writeTypedArray
  jni.JniObject createTypedArray(parcelable_.Parcelable_Creator c) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_createTypedArray, jni.JniType.objectType, [c.reference]).object);

  static final _id_readTypedArray = jniAccessors.getMethodIDOf(
      _classRef,
      "readTypedArray",
      "([Ljava/lang/Object;Landroid/os/Parcelable\$Creator;)V");

  /// from: public void readTypedArray(T[] val, android.os.Parcelable.Creator<T> c)
  void readTypedArray(jni.JniObject val, parcelable_.Parcelable_Creator c) =>
      jniAccessors.callMethodWithArgs(reference, _id_readTypedArray,
          jni.JniType.voidType, [val.reference, c.reference]).check();

  static final _id_writeParcelableArray = jniAccessors.getMethodIDOf(
      _classRef, "writeParcelableArray", "([Ljava/lang/Object;I)V");

  /// from: public void writeParcelableArray(T[] value, int parcelableFlags)
  ///
  /// Write a heterogeneous array of Parcelable objects into the Parcel.
  /// Each object in the array is written along with its class name, so
  /// that the correct class can later be instantiated.  As a result, this
  /// has significantly more overhead than \#writeTypedArray, but will
  /// correctly handle an array containing more than one type of object.
  ///@param value The array of objects to be written.
  ///@param parcelableFlags Contextual flags as per
  /// Parcelable\#writeToParcel(Parcel, int) Parcelable.writeToParcel().
  ///@see \#writeTypedArray
  void writeParcelableArray(jni.JniObject value, int parcelableFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeParcelableArray,
          jni.JniType.voidType, [value.reference, parcelableFlags]).check();

  static final _id_readValue = jniAccessors.getMethodIDOf(
      _classRef, "readValue", "(Ljava/lang/ClassLoader;)Ljava/lang/Object;");

  /// from: public java.lang.Object readValue(java.lang.ClassLoader loader)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read a typed object from a parcel.  The given class loader will be
  /// used to load any enclosed Parcelables.  If it is null, the default class
  /// loader will be used.
  jni.JniObject readValue(jni.JniObject loader) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_readValue, jni.JniType.objectType, [loader.reference]).object);

  static final _id_readParcelableArray = jniAccessors.getMethodIDOf(
      _classRef,
      "readParcelableArray",
      "(Ljava/lang/ClassLoader;)[Landroid/os/Parcelable;");

  /// from: public android.os.Parcelable[] readParcelableArray(java.lang.ClassLoader loader)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read and return a new Parcelable array from the parcel.
  /// The given class loader will be used to load any enclosed
  /// Parcelables.
  ///@return the Parcelable array, or null if the array is null
  jni.JniObject readParcelableArray(jni.JniObject loader) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_readParcelableArray,
          jni.JniType.objectType,
          [loader.reference]).object);

  static final _id_readSerializable = jniAccessors.getMethodIDOf(
      _classRef, "readSerializable", "()Ljava/io/Serializable;");

  /// from: public java.io.Serializable readSerializable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read and return a new Serializable object from the parcel.
  ///@return the Serializable object, or null if the Serializable name
  /// wasn't found in the parcel.
  jni.JniObject readSerializable() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_readSerializable, jni.JniType.objectType, []).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}
