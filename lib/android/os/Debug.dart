// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Parcelable.dart" as parcelable_;

import "Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.Debug
///
/// Provides various debugging methods for Android applications, including
/// tracing and allocation counts.
/// <strong>Logging Trace Files</strong>
///
/// Debug can create log files that give details about an application, such as
/// a call stack and start/stop times for any running methods. See <a href="{@docRoot}studio/profile/traceview.html">Inspect Trace Logs with
/// Traceview</a> for information about reading trace files. To start logging
/// trace files, call one of the startMethodTracing() methods. To stop tracing,
/// call \#stopMethodTracing().
class Debug extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/Debug");
  Debug.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int SHOW_CLASSLOADER
  static const SHOW_CLASSLOADER = 2;

  /// from: static public final int SHOW_FULL_DETAIL
  ///
  /// Flags for printLoadedClasses().  Default behavior is to only show
  /// the class name.
  static const SHOW_FULL_DETAIL = 1;

  /// from: static public final int SHOW_INITIALIZED
  static const SHOW_INITIALIZED = 4;

  /// from: static public final int TRACE_COUNT_ALLOCS
  ///
  /// Flags for startMethodTracing().  These can be ORed together.
  ///
  /// TRACE_COUNT_ALLOCS adds the results from startAllocCounting to the
  /// trace key file.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static const TRACE_COUNT_ALLOCS = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Debug()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_waitForDebugger =
      jniAccessors.getStaticMethodIDOf(_classRef, "waitForDebugger", "()V");

  /// from: static public void waitForDebugger()
  ///
  /// Wait until a debugger attaches.  As soon as the debugger attaches,
  /// this returns, so you will need to place a breakpoint after the
  /// waitForDebugger() call if you want to start tracing immediately.
  static void waitForDebugger() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_waitForDebugger, jni.JniType.voidType, []).check();

  static final _id_waitingForDebugger =
      jniAccessors.getStaticMethodIDOf(_classRef, "waitingForDebugger", "()Z");

  /// from: static public boolean waitingForDebugger()
  ///
  /// Returns "true" if one or more threads is waiting for a debugger
  /// to attach.
  static bool waitingForDebugger() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_waitingForDebugger, jni.JniType.booleanType, []).boolean;

  static final _id_isDebuggerConnected =
      jniAccessors.getStaticMethodIDOf(_classRef, "isDebuggerConnected", "()Z");

  /// from: static public boolean isDebuggerConnected()
  ///
  /// Determine if a debugger is currently attached.
  static bool isDebuggerConnected() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_isDebuggerConnected, jni.JniType.booleanType, []).boolean;

  static final _id_changeDebugPort =
      jniAccessors.getStaticMethodIDOf(_classRef, "changeDebugPort", "(I)V");

  /// from: static public void changeDebugPort(int port)
  ///
  /// Change the JDWP port.
  ///@deprecated no longer needed or useful
  static void changeDebugPort(int port) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_changeDebugPort, jni.JniType.voidType, [port]).check();

  static final _id_startNativeTracing =
      jniAccessors.getStaticMethodIDOf(_classRef, "startNativeTracing", "()V");

  /// from: static public void startNativeTracing()
  ///
  /// Enable qemu tracing. For this to work requires running everything inside
  /// the qemu emulator; otherwise, this method will have no effect. The trace
  /// file is specified on the command line when the emulator is started. For
  /// example, the following command line <br/>
  /// <code>emulator -trace foo</code><br/>
  /// will start running the emulator and create a trace file named "foo". This
  /// method simply enables writing the trace records to the trace file.
  ///
  ///
  /// The main differences between this and \#startMethodTracing() are
  /// that tracing in the qemu emulator traces every cpu instruction of every
  /// process, including kernel code, so we have more complete information,
  /// including all context switches. We can also get more detailed information
  /// such as cache misses. The sequence of calls is determined by
  /// post-processing the instruction trace. The qemu tracing is also done
  /// without modifying the application or perturbing the timing of calls
  /// because no instrumentation is added to the application being traced.
  ///
  ///
  ///
  ///
  /// One limitation of using this method compared to using
  /// \#startMethodTracing() on the real device is that the emulator
  /// does not model all of the real hardware effects such as memory and
  /// bus contention.  The emulator also has a simple cache model and cannot
  /// capture all the complexities of a real cache.
  ///
  ///
  static void startNativeTracing() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_startNativeTracing, jni.JniType.voidType, []).check();

  static final _id_stopNativeTracing =
      jniAccessors.getStaticMethodIDOf(_classRef, "stopNativeTracing", "()V");

  /// from: static public void stopNativeTracing()
  ///
  /// Stop qemu tracing.  See \#startNativeTracing() to start tracing.
  ///
  /// Tracing can be started and stopped as many times as desired.  When
  /// the qemu emulator itself is stopped then the buffered trace records
  /// are flushed and written to the trace file.  In fact, it is not necessary
  /// to call this method at all; simply killing qemu is sufficient.  But
  /// starting and stopping a trace is useful for examining a specific
  /// region of code.
  ///
  static void stopNativeTracing() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_stopNativeTracing, jni.JniType.voidType, []).check();

  static final _id_enableEmulatorTraceOutput = jniAccessors.getStaticMethodIDOf(
      _classRef, "enableEmulatorTraceOutput", "()V");

  /// from: static public void enableEmulatorTraceOutput()
  ///
  /// Enable "emulator traces", in which information about the current
  /// method is made available to the "emulator -trace" feature.  There
  /// is no corresponding "disable" call -- this is intended for use by
  /// the framework when tracing should be turned on and left that way, so
  /// that traces captured with F9/F10 will include the necessary data.
  ///
  /// This puts the VM into "profile" mode, which has performance
  /// consequences.
  ///
  /// To temporarily enable tracing, use \#startNativeTracing().
  static void enableEmulatorTraceOutput() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_enableEmulatorTraceOutput, jni.JniType.voidType, []).check();

  static final _id_startMethodTracing =
      jniAccessors.getStaticMethodIDOf(_classRef, "startMethodTracing", "()V");

  /// from: static public void startMethodTracing()
  ///
  /// Start method tracing with default log name and buffer size.
  ///
  /// By default, the trace file is called "dmtrace.trace" and it's placed
  /// under your package-specific directory on primary shared/external storage,
  /// as returned by Context\#getExternalFilesDir(String).
  ///
  /// See <a href="{@docRoot}studio/profile/traceview.html">Inspect Trace Logs
  /// with Traceview</a> for information about reading trace files.
  /// <p class="note">
  /// When method tracing is enabled, the VM will run more slowly than usual,
  /// so the timings from the trace files should only be considered in relative
  /// terms (e.g. was run \#1 faster than run \#2). The times for native methods
  /// will not change, so don't try to use this to compare the performance of
  /// interpreted and native implementations of the same method. As an
  /// alternative, consider using sampling-based method tracing via
  /// \#startMethodTracingSampling(String, int, int) or "native" tracing
  /// in the emulator via \#startNativeTracing().
  ///
  ///
  static void startMethodTracing() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_startMethodTracing, jni.JniType.voidType, []).check();

  static final _id_startMethodTracing1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "startMethodTracing", "(Ljava/lang/String;)V");

  /// from: static public void startMethodTracing(java.lang.String tracePath)
  ///
  /// Start method tracing, specifying the trace log file path.
  ///
  /// When a relative file path is given, the trace file will be placed under
  /// your package-specific directory on primary shared/external storage, as
  /// returned by Context\#getExternalFilesDir(String).
  ///
  /// See <a href="{@docRoot}studio/profile/traceview.html">Inspect Trace Logs
  /// with Traceview</a> for information about reading trace files.
  /// <p class="note">
  /// When method tracing is enabled, the VM will run more slowly than usual,
  /// so the timings from the trace files should only be considered in relative
  /// terms (e.g. was run \#1 faster than run \#2). The times for native methods
  /// will not change, so don't try to use this to compare the performance of
  /// interpreted and native implementations of the same method. As an
  /// alternative, consider using sampling-based method tracing via
  /// \#startMethodTracingSampling(String, int, int) or "native" tracing
  /// in the emulator via \#startNativeTracing().
  ///
  ///
  ///@param tracePath Path to the trace log file to create. If {@code null},
  ///            this will default to "dmtrace.trace". If the file already
  ///            exists, it will be truncated. If the path given does not end
  ///            in ".trace", it will be appended for you.
  static void startMethodTracing1(jni.JniString tracePath) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_startMethodTracing1,
          jni.JniType.voidType, [tracePath.reference]).check();

  static final _id_startMethodTracing2 = jniAccessors.getStaticMethodIDOf(
      _classRef, "startMethodTracing", "(Ljava/lang/String;I)V");

  /// from: static public void startMethodTracing(java.lang.String tracePath, int bufferSize)
  ///
  /// Start method tracing, specifying the trace log file name and the buffer
  /// size.
  ///
  /// When a relative file path is given, the trace file will be placed under
  /// your package-specific directory on primary shared/external storage, as
  /// returned by Context\#getExternalFilesDir(String).
  ///
  /// See <a href="{@docRoot}studio/profile/traceview.html">Inspect Trace Logs
  /// with Traceview</a> for information about reading trace files.
  /// <p class="note">
  /// When method tracing is enabled, the VM will run more slowly than usual,
  /// so the timings from the trace files should only be considered in relative
  /// terms (e.g. was run \#1 faster than run \#2). The times for native methods
  /// will not change, so don't try to use this to compare the performance of
  /// interpreted and native implementations of the same method. As an
  /// alternative, consider using sampling-based method tracing via
  /// \#startMethodTracingSampling(String, int, int) or "native" tracing
  /// in the emulator via \#startNativeTracing().
  ///
  ///
  ///@param tracePath Path to the trace log file to create. If {@code null},
  ///            this will default to "dmtrace.trace". If the file already
  ///            exists, it will be truncated. If the path given does not end
  ///            in ".trace", it will be appended for you.
  ///@param bufferSize The maximum amount of trace data we gather. If not
  ///            given, it defaults to 8MB.
  static void startMethodTracing2(jni.JniString tracePath, int bufferSize) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_startMethodTracing2,
          jni.JniType.voidType, [tracePath.reference, bufferSize]).check();

  static final _id_startMethodTracing3 = jniAccessors.getStaticMethodIDOf(
      _classRef, "startMethodTracing", "(Ljava/lang/String;II)V");

  /// from: static public void startMethodTracing(java.lang.String tracePath, int bufferSize, int flags)
  ///
  /// Start method tracing, specifying the trace log file name, the buffer
  /// size, and flags.
  ///
  /// When a relative file path is given, the trace file will be placed under
  /// your package-specific directory on primary shared/external storage, as
  /// returned by Context\#getExternalFilesDir(String).
  ///
  /// See <a href="{@docRoot}studio/profile/traceview.html">Inspect Trace Logs
  /// with Traceview</a> for information about reading trace files.
  /// <p class="note">
  /// When method tracing is enabled, the VM will run more slowly than usual,
  /// so the timings from the trace files should only be considered in relative
  /// terms (e.g. was run \#1 faster than run \#2). The times for native methods
  /// will not change, so don't try to use this to compare the performance of
  /// interpreted and native implementations of the same method. As an
  /// alternative, consider using sampling-based method tracing via
  /// \#startMethodTracingSampling(String, int, int) or "native" tracing
  /// in the emulator via \#startNativeTracing().
  ///
  ///
  ///@param tracePath Path to the trace log file to create. If {@code null},
  ///            this will default to "dmtrace.trace". If the file already
  ///            exists, it will be truncated. If the path given does not end
  ///            in ".trace", it will be appended for you.
  ///@param bufferSize The maximum amount of trace data we gather. If not
  ///            given, it defaults to 8MB.
  ///@param flags Flags to control method tracing. The only one that is
  ///            currently defined is \#TRACE_COUNT_ALLOCS.
  static void startMethodTracing3(
          jni.JniString tracePath, int bufferSize, int flags) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_startMethodTracing3,
          jni.JniType.voidType,
          [tracePath.reference, bufferSize, flags]).check();

  static final _id_startMethodTracingSampling =
      jniAccessors.getStaticMethodIDOf(
          _classRef, "startMethodTracingSampling", "(Ljava/lang/String;II)V");

  /// from: static public void startMethodTracingSampling(java.lang.String tracePath, int bufferSize, int intervalUs)
  ///
  /// Start sampling-based method tracing, specifying the trace log file name,
  /// the buffer size, and the sampling interval.
  ///
  /// When a relative file path is given, the trace file will be placed under
  /// your package-specific directory on primary shared/external storage, as
  /// returned by Context\#getExternalFilesDir(String).
  ///
  /// See <a href="{@docRoot}studio/profile/traceview.html">Inspect Trace Logs
  /// with Traceview</a> for information about reading trace files.
  ///@param tracePath Path to the trace log file to create. If {@code null},
  ///            this will default to "dmtrace.trace". If the file already
  ///            exists, it will be truncated. If the path given does not end
  ///            in ".trace", it will be appended for you.
  ///@param bufferSize The maximum amount of trace data we gather. If not
  ///            given, it defaults to 8MB.
  ///@param intervalUs The amount of time between each sample in microseconds.
  static void startMethodTracingSampling(
          jni.JniString tracePath, int bufferSize, int intervalUs) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_startMethodTracingSampling,
          jni.JniType.voidType,
          [tracePath.reference, bufferSize, intervalUs]).check();

  static final _id_stopMethodTracing =
      jniAccessors.getStaticMethodIDOf(_classRef, "stopMethodTracing", "()V");

  /// from: static public void stopMethodTracing()
  ///
  /// Stop method tracing.
  static void stopMethodTracing() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_stopMethodTracing, jni.JniType.voidType, []).check();

  static final _id_threadCpuTimeNanos =
      jniAccessors.getStaticMethodIDOf(_classRef, "threadCpuTimeNanos", "()J");

  /// from: static public long threadCpuTimeNanos()
  ///
  /// Get an indication of thread CPU usage.  The value returned
  /// indicates the amount of time that the current thread has spent
  /// executing code or waiting for certain types of I/O.
  ///
  /// The time is expressed in nanoseconds, and is only meaningful
  /// when compared to the result from an earlier call.  Note that
  /// nanosecond resolution does not imply nanosecond accuracy.
  ///
  /// On system which don't support this operation, the call returns -1.
  static int threadCpuTimeNanos() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_threadCpuTimeNanos, jni.JniType.longType, []).long;

  static final _id_startAllocCounting =
      jniAccessors.getStaticMethodIDOf(_classRef, "startAllocCounting", "()V");

  /// from: static public void startAllocCounting()
  ///
  /// Start counting the number and aggregate size of memory allocations.
  ///
  /// The \#startAllocCounting() start method resets the counts and enables counting.
  /// The \#stopAllocCounting() stop method disables the counting so that the analysis
  /// code doesn't cause additional allocations.  The various <code>get</code> methods return
  /// the specified value. And the various <code>reset</code> methods reset the specified
  /// count.
  ///
  ///
  /// Counts are kept for the system as a whole (global) and for each thread.
  /// The per-thread counts for threads other than the current thread
  /// are not cleared by the "reset" or "start" calls.
  ///
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void startAllocCounting() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_startAllocCounting, jni.JniType.voidType, []).check();

  static final _id_stopAllocCounting =
      jniAccessors.getStaticMethodIDOf(_classRef, "stopAllocCounting", "()V");

  /// from: static public void stopAllocCounting()
  ///
  /// Stop counting the number and aggregate size of memory allocations.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void stopAllocCounting() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_stopAllocCounting, jni.JniType.voidType, []).check();

  static final _id_getGlobalAllocCount =
      jniAccessors.getStaticMethodIDOf(_classRef, "getGlobalAllocCount", "()I");

  /// from: static public int getGlobalAllocCount()
  ///
  /// Returns the global count of objects allocated by the runtime between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getGlobalAllocCount() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getGlobalAllocCount, jni.JniType.intType, []).integer;

  static final _id_resetGlobalAllocCount = jniAccessors.getStaticMethodIDOf(
      _classRef, "resetGlobalAllocCount", "()V");

  /// from: static public void resetGlobalAllocCount()
  ///
  /// Clears the global count of objects allocated.
  ///@see \#getGlobalAllocCount()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetGlobalAllocCount() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_resetGlobalAllocCount, jni.JniType.voidType, []).check();

  static final _id_getGlobalAllocSize =
      jniAccessors.getStaticMethodIDOf(_classRef, "getGlobalAllocSize", "()I");

  /// from: static public int getGlobalAllocSize()
  ///
  /// Returns the global size, in bytes, of objects allocated by the runtime between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getGlobalAllocSize() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getGlobalAllocSize, jni.JniType.intType, []).integer;

  static final _id_resetGlobalAllocSize = jniAccessors.getStaticMethodIDOf(
      _classRef, "resetGlobalAllocSize", "()V");

  /// from: static public void resetGlobalAllocSize()
  ///
  /// Clears the global size of objects allocated.
  ///@see \#getGlobalAllocSize()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetGlobalAllocSize() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_resetGlobalAllocSize, jni.JniType.voidType, []).check();

  static final _id_getGlobalFreedCount =
      jniAccessors.getStaticMethodIDOf(_classRef, "getGlobalFreedCount", "()I");

  /// from: static public int getGlobalFreedCount()
  ///
  /// Returns the global count of objects freed by the runtime between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getGlobalFreedCount() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getGlobalFreedCount, jni.JniType.intType, []).integer;

  static final _id_resetGlobalFreedCount = jniAccessors.getStaticMethodIDOf(
      _classRef, "resetGlobalFreedCount", "()V");

  /// from: static public void resetGlobalFreedCount()
  ///
  /// Clears the global count of objects freed.
  ///@see \#getGlobalFreedCount()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetGlobalFreedCount() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_resetGlobalFreedCount, jni.JniType.voidType, []).check();

  static final _id_getGlobalFreedSize =
      jniAccessors.getStaticMethodIDOf(_classRef, "getGlobalFreedSize", "()I");

  /// from: static public int getGlobalFreedSize()
  ///
  /// Returns the global size, in bytes, of objects freed by the runtime between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getGlobalFreedSize() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getGlobalFreedSize, jni.JniType.intType, []).integer;

  static final _id_resetGlobalFreedSize = jniAccessors.getStaticMethodIDOf(
      _classRef, "resetGlobalFreedSize", "()V");

  /// from: static public void resetGlobalFreedSize()
  ///
  /// Clears the global size of objects freed.
  ///@see \#getGlobalFreedSize()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetGlobalFreedSize() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_resetGlobalFreedSize, jni.JniType.voidType, []).check();

  static final _id_getGlobalGcInvocationCount = jniAccessors
      .getStaticMethodIDOf(_classRef, "getGlobalGcInvocationCount", "()I");

  /// from: static public int getGlobalGcInvocationCount()
  ///
  /// Returns the number of non-concurrent GC invocations between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getGlobalGcInvocationCount() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getGlobalGcInvocationCount, jni.JniType.intType, []).integer;

  static final _id_resetGlobalGcInvocationCount = jniAccessors
      .getStaticMethodIDOf(_classRef, "resetGlobalGcInvocationCount", "()V");

  /// from: static public void resetGlobalGcInvocationCount()
  ///
  /// Clears the count of non-concurrent GC invocations.
  ///@see \#getGlobalGcInvocationCount()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetGlobalGcInvocationCount() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_resetGlobalGcInvocationCount, jni.JniType.voidType, []).check();

  static final _id_getGlobalClassInitCount = jniAccessors.getStaticMethodIDOf(
      _classRef, "getGlobalClassInitCount", "()I");

  /// from: static public int getGlobalClassInitCount()
  ///
  /// Returns the number of classes successfully initialized (ie those that executed without
  /// throwing an exception) between a \#startAllocCounting() start and
  /// \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getGlobalClassInitCount() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getGlobalClassInitCount, jni.JniType.intType, []).integer;

  static final _id_resetGlobalClassInitCount = jniAccessors.getStaticMethodIDOf(
      _classRef, "resetGlobalClassInitCount", "()V");

  /// from: static public void resetGlobalClassInitCount()
  ///
  /// Clears the count of classes initialized.
  ///@see \#getGlobalClassInitCount()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetGlobalClassInitCount() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_resetGlobalClassInitCount, jni.JniType.voidType, []).check();

  static final _id_getGlobalClassInitTime = jniAccessors.getStaticMethodIDOf(
      _classRef, "getGlobalClassInitTime", "()I");

  /// from: static public int getGlobalClassInitTime()
  ///
  /// Returns the time spent successfully initializing classes between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getGlobalClassInitTime() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getGlobalClassInitTime, jni.JniType.intType, []).integer;

  static final _id_resetGlobalClassInitTime = jniAccessors.getStaticMethodIDOf(
      _classRef, "resetGlobalClassInitTime", "()V");

  /// from: static public void resetGlobalClassInitTime()
  ///
  /// Clears the count of time spent initializing classes.
  ///@see \#getGlobalClassInitTime()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetGlobalClassInitTime() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_resetGlobalClassInitTime, jni.JniType.voidType, []).check();

  static final _id_getGlobalExternalAllocCount = jniAccessors
      .getStaticMethodIDOf(_classRef, "getGlobalExternalAllocCount", "()I");

  /// from: static public int getGlobalExternalAllocCount()
  ///
  /// This method exists for compatibility and always returns 0.
  ///@deprecated This method is now obsolete.
  static int getGlobalExternalAllocCount() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getGlobalExternalAllocCount, jni.JniType.intType, []).integer;

  static final _id_resetGlobalExternalAllocSize = jniAccessors
      .getStaticMethodIDOf(_classRef, "resetGlobalExternalAllocSize", "()V");

  /// from: static public void resetGlobalExternalAllocSize()
  ///
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static void resetGlobalExternalAllocSize() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_resetGlobalExternalAllocSize, jni.JniType.voidType, []).check();

  static final _id_resetGlobalExternalAllocCount = jniAccessors
      .getStaticMethodIDOf(_classRef, "resetGlobalExternalAllocCount", "()V");

  /// from: static public void resetGlobalExternalAllocCount()
  ///
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static void resetGlobalExternalAllocCount() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_resetGlobalExternalAllocCount, jni.JniType.voidType, []).check();

  static final _id_getGlobalExternalAllocSize = jniAccessors
      .getStaticMethodIDOf(_classRef, "getGlobalExternalAllocSize", "()I");

  /// from: static public int getGlobalExternalAllocSize()
  ///
  /// This method exists for compatibility and always returns 0.
  ///@deprecated This method is now obsolete.
  static int getGlobalExternalAllocSize() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getGlobalExternalAllocSize, jni.JniType.intType, []).integer;

  static final _id_getGlobalExternalFreedCount = jniAccessors
      .getStaticMethodIDOf(_classRef, "getGlobalExternalFreedCount", "()I");

  /// from: static public int getGlobalExternalFreedCount()
  ///
  /// This method exists for compatibility and always returns 0.
  ///@deprecated This method is now obsolete.
  static int getGlobalExternalFreedCount() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getGlobalExternalFreedCount, jni.JniType.intType, []).integer;

  static final _id_resetGlobalExternalFreedCount = jniAccessors
      .getStaticMethodIDOf(_classRef, "resetGlobalExternalFreedCount", "()V");

  /// from: static public void resetGlobalExternalFreedCount()
  ///
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static void resetGlobalExternalFreedCount() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_resetGlobalExternalFreedCount, jni.JniType.voidType, []).check();

  static final _id_getGlobalExternalFreedSize = jniAccessors
      .getStaticMethodIDOf(_classRef, "getGlobalExternalFreedSize", "()I");

  /// from: static public int getGlobalExternalFreedSize()
  ///
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static int getGlobalExternalFreedSize() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getGlobalExternalFreedSize, jni.JniType.intType, []).integer;

  static final _id_resetGlobalExternalFreedSize = jniAccessors
      .getStaticMethodIDOf(_classRef, "resetGlobalExternalFreedSize", "()V");

  /// from: static public void resetGlobalExternalFreedSize()
  ///
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static void resetGlobalExternalFreedSize() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_resetGlobalExternalFreedSize, jni.JniType.voidType, []).check();

  static final _id_getThreadAllocCount =
      jniAccessors.getStaticMethodIDOf(_classRef, "getThreadAllocCount", "()I");

  /// from: static public int getThreadAllocCount()
  ///
  /// Returns the thread-local count of objects allocated by the runtime between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getThreadAllocCount() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getThreadAllocCount, jni.JniType.intType, []).integer;

  static final _id_resetThreadAllocCount = jniAccessors.getStaticMethodIDOf(
      _classRef, "resetThreadAllocCount", "()V");

  /// from: static public void resetThreadAllocCount()
  ///
  /// Clears the thread-local count of objects allocated.
  ///@see \#getThreadAllocCount()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetThreadAllocCount() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_resetThreadAllocCount, jni.JniType.voidType, []).check();

  static final _id_getThreadAllocSize =
      jniAccessors.getStaticMethodIDOf(_classRef, "getThreadAllocSize", "()I");

  /// from: static public int getThreadAllocSize()
  ///
  /// Returns the thread-local size of objects allocated by the runtime between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@return The allocated size in bytes.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getThreadAllocSize() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getThreadAllocSize, jni.JniType.intType, []).integer;

  static final _id_resetThreadAllocSize = jniAccessors.getStaticMethodIDOf(
      _classRef, "resetThreadAllocSize", "()V");

  /// from: static public void resetThreadAllocSize()
  ///
  /// Clears the thread-local count of objects allocated.
  ///@see \#getThreadAllocSize()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetThreadAllocSize() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_resetThreadAllocSize, jni.JniType.voidType, []).check();

  static final _id_getThreadExternalAllocCount = jniAccessors
      .getStaticMethodIDOf(_classRef, "getThreadExternalAllocCount", "()I");

  /// from: static public int getThreadExternalAllocCount()
  ///
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static int getThreadExternalAllocCount() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getThreadExternalAllocCount, jni.JniType.intType, []).integer;

  static final _id_resetThreadExternalAllocCount = jniAccessors
      .getStaticMethodIDOf(_classRef, "resetThreadExternalAllocCount", "()V");

  /// from: static public void resetThreadExternalAllocCount()
  ///
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static void resetThreadExternalAllocCount() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_resetThreadExternalAllocCount, jni.JniType.voidType, []).check();

  static final _id_getThreadExternalAllocSize = jniAccessors
      .getStaticMethodIDOf(_classRef, "getThreadExternalAllocSize", "()I");

  /// from: static public int getThreadExternalAllocSize()
  ///
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static int getThreadExternalAllocSize() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getThreadExternalAllocSize, jni.JniType.intType, []).integer;

  static final _id_resetThreadExternalAllocSize = jniAccessors
      .getStaticMethodIDOf(_classRef, "resetThreadExternalAllocSize", "()V");

  /// from: static public void resetThreadExternalAllocSize()
  ///
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static void resetThreadExternalAllocSize() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_resetThreadExternalAllocSize, jni.JniType.voidType, []).check();

  static final _id_getThreadGcInvocationCount = jniAccessors
      .getStaticMethodIDOf(_classRef, "getThreadGcInvocationCount", "()I");

  /// from: static public int getThreadGcInvocationCount()
  ///
  /// Returns the number of thread-local non-concurrent GC invocations between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getThreadGcInvocationCount() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getThreadGcInvocationCount, jni.JniType.intType, []).integer;

  static final _id_resetThreadGcInvocationCount = jniAccessors
      .getStaticMethodIDOf(_classRef, "resetThreadGcInvocationCount", "()V");

  /// from: static public void resetThreadGcInvocationCount()
  ///
  /// Clears the thread-local count of non-concurrent GC invocations.
  ///@see \#getThreadGcInvocationCount()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetThreadGcInvocationCount() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_resetThreadGcInvocationCount, jni.JniType.voidType, []).check();

  static final _id_resetAllCounts =
      jniAccessors.getStaticMethodIDOf(_classRef, "resetAllCounts", "()V");

  /// from: static public void resetAllCounts()
  ///
  /// Clears all the global and thread-local memory allocation counters.
  ///@see \#startAllocCounting()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetAllCounts() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_resetAllCounts, jni.JniType.voidType, []).check();

  static final _id_getRuntimeStat = jniAccessors.getStaticMethodIDOf(
      _classRef, "getRuntimeStat", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String getRuntimeStat(java.lang.String statName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value of a particular runtime statistic or {@code null} if no
  /// such runtime statistic exists.
  ///
  /// The following table lists the runtime statistics that the runtime supports.
  /// Note runtime statistics may be added or removed in a future API level.
  ///
  ///
  /// <table>
  ///     <thead>
  ///         <tr>
  ///             <th>Runtime statistic name</th>
  ///             <th>Meaning</th>
  ///             <th>Example</th>
  ///             <th>Supported (API Levels)</th>
  ///         </tr>
  ///     </thead>
  ///     <tbody>
  ///         <tr>
  ///             <td>art.gc.gc-count</td>
  ///             <td>The number of garbage collection runs.</td>
  ///             <td>{@code 164}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>art.gc.gc-time</td>
  ///             <td>The total duration of garbage collection runs in ms.</td>
  ///             <td>{@code 62364}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>art.gc.bytes-allocated</td>
  ///             <td>The total number of bytes that the application allocated.</td>
  ///             <td>{@code 1463948408}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>art.gc.bytes-freed</td>
  ///             <td>The total number of bytes that garbage collection reclaimed.</td>
  ///             <td>{@code 1313493084}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>art.gc.blocking-gc-count</td>
  ///             <td>The number of blocking garbage collection runs.</td>
  ///             <td>{@code 2}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>art.gc.blocking-gc-time</td>
  ///             <td>The total duration of blocking garbage collection runs in ms.</td>
  ///             <td>{@code 804}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>art.gc.gc-count-rate-histogram</td>
  ///             <td>Every 10 seconds, the gc-count-rate is computed as the number of garbage
  ///                 collection runs that have occurred over the last 10
  ///                 seconds. art.gc.gc-count-rate-histogram is a histogram of the gc-count-rate
  ///                 samples taken since the process began. The histogram can be used to identify
  ///                 instances of high rates of garbage collection runs. For example, a histogram
  ///                 of "0:34503,1:45350,2:11281,3:8088,4:43,5:8" shows that most of the time
  ///                 there are between 0 and 2 garbage collection runs every 10 seconds, but there
  ///                 were 8 distinct 10-second intervals in which 5 garbage collection runs
  ///                 occurred.</td>
  ///             <td>{@code 0:34503,1:45350,2:11281,3:8088,4:43,5:8}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>art.gc.blocking-gc-count-rate-histogram</td>
  ///             <td>Every 10 seconds, the blocking-gc-count-rate is computed as the number of
  ///                 blocking garbage collection runs that have occurred over the last 10
  ///                 seconds. art.gc.blocking-gc-count-rate-histogram is a histogram of the
  ///                 blocking-gc-count-rate samples taken since the process began. The histogram
  ///                 can be used to identify instances of high rates of blocking garbage
  ///                 collection runs. For example, a histogram of "0:99269,1:1,2:1" shows that
  ///                 most of the time there are zero blocking garbage collection runs every 10
  ///                 seconds, but there was one 10-second interval in which one blocking garbage
  ///                 collection run occurred, and there was one interval in which two blocking
  ///                 garbage collection runs occurred.</td>
  ///             <td>{@code 0:99269,1:1,2:1}</td>
  ///             <td>23</td>
  ///         </tr>
  ///     </tbody>
  /// </table>
  ///@param statName the name of the runtime statistic to look up.
  ///@return the value of the specified runtime statistic or {@code null} if the
  ///         runtime statistic doesn't exist.
  static jni.JniString getRuntimeStat(jni.JniString statName) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getRuntimeStat,
          jni.JniType.objectType,
          [statName.reference]).object);

  static final _id_getRuntimeStats = jniAccessors.getStaticMethodIDOf(
      _classRef, "getRuntimeStats", "()Ljava/util/Map;");

  /// from: static public java.util.Map<java.lang.String,java.lang.String> getRuntimeStats()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a map of the names/values of the runtime statistics
  /// that \#getRuntimeStat(String) supports.
  ///@return a map of the names/values of the supported runtime statistics.
  static jni.JniObject getRuntimeStats() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getRuntimeStats, jni.JniType.objectType, []).object);

  static final _id_getNativeHeapSize =
      jniAccessors.getStaticMethodIDOf(_classRef, "getNativeHeapSize", "()J");

  /// from: static public native long getNativeHeapSize()
  ///
  /// Returns the size of the native heap.
  ///@return The size of the native heap in bytes.
  static int getNativeHeapSize() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getNativeHeapSize, jni.JniType.longType, []).long;

  static final _id_getNativeHeapAllocatedSize = jniAccessors
      .getStaticMethodIDOf(_classRef, "getNativeHeapAllocatedSize", "()J");

  /// from: static public native long getNativeHeapAllocatedSize()
  ///
  /// Returns the amount of allocated memory in the native heap.
  ///@return The allocated size in bytes.
  static int getNativeHeapAllocatedSize() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getNativeHeapAllocatedSize, jni.JniType.longType, []).long;

  static final _id_getNativeHeapFreeSize = jniAccessors.getStaticMethodIDOf(
      _classRef, "getNativeHeapFreeSize", "()J");

  /// from: static public native long getNativeHeapFreeSize()
  ///
  /// Returns the amount of free memory in the native heap.
  ///@return The freed size in bytes.
  static int getNativeHeapFreeSize() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getNativeHeapFreeSize, jni.JniType.longType, []).long;

  static final _id_getMemoryInfo = jniAccessors.getStaticMethodIDOf(
      _classRef, "getMemoryInfo", "(Landroid/os/Debug\$MemoryInfo;)V");

  /// from: static public native void getMemoryInfo(android.os.Debug.MemoryInfo memoryInfo)
  ///
  /// Retrieves information about this processes memory usages. This information is broken down by
  /// how much is in use by dalvik, the native heap, and everything else.
  ///
  /// __Note:__ this method directly retrieves memory information for the given process
  /// from low-level data available to it.  It may not be able to retrieve information about
  /// some protected allocations, such as graphics.  If you want to be sure you can see
  /// all information about allocations by the process, use
  /// android.app.ActivityManager\#getProcessMemoryInfo(int[]) instead.
  ///
  static void getMemoryInfo(Debug_MemoryInfo memoryInfo) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getMemoryInfo,
          jni.JniType.voidType, [memoryInfo.reference]).check();

  static final _id_getPss =
      jniAccessors.getStaticMethodIDOf(_classRef, "getPss", "()J");

  /// from: static public native long getPss()
  ///
  /// Retrieves the PSS memory used by the process as given by the
  /// smaps.
  static int getPss() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getPss, jni.JniType.longType, []).long;

  static final _id_setAllocationLimit =
      jniAccessors.getStaticMethodIDOf(_classRef, "setAllocationLimit", "(I)I");

  /// from: static public int setAllocationLimit(int limit)
  ///
  /// Establish an object allocation limit in the current thread.
  /// This feature was never enabled in release builds.  The
  /// allocation limits feature was removed in Honeycomb.  This
  /// method exists for compatibility and always returns -1 and has
  /// no effect.
  ///@deprecated This method is now obsolete.
  static int setAllocationLimit(int limit) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_setAllocationLimit,
          jni.JniType.intType, [limit]).integer;

  static final _id_setGlobalAllocationLimit = jniAccessors.getStaticMethodIDOf(
      _classRef, "setGlobalAllocationLimit", "(I)I");

  /// from: static public int setGlobalAllocationLimit(int limit)
  ///
  /// Establish a global object allocation limit.  This feature was
  /// never enabled in release builds.  The allocation limits feature
  /// was removed in Honeycomb.  This method exists for compatibility
  /// and always returns -1 and has no effect.
  ///@deprecated This method is now obsolete.
  static int setGlobalAllocationLimit(int limit) =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_setGlobalAllocationLimit, jni.JniType.intType, [limit]).integer;

  static final _id_printLoadedClasses =
      jniAccessors.getStaticMethodIDOf(_classRef, "printLoadedClasses", "(I)V");

  /// from: static public void printLoadedClasses(int flags)
  ///
  /// Dump a list of all currently loaded class to the log file.
  ///@param flags See constants above.
  static void printLoadedClasses(int flags) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_printLoadedClasses,
          jni.JniType.voidType, [flags]).check();

  static final _id_getLoadedClassCount =
      jniAccessors.getStaticMethodIDOf(_classRef, "getLoadedClassCount", "()I");

  /// from: static public int getLoadedClassCount()
  ///
  /// Get the number of loaded classes.
  ///@return the number of loaded classes.
  static int getLoadedClassCount() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getLoadedClassCount, jni.JniType.intType, []).integer;

  static final _id_dumpHprofData = jniAccessors.getStaticMethodIDOf(
      _classRef, "dumpHprofData", "(Ljava/lang/String;)V");

  /// from: static public void dumpHprofData(java.lang.String fileName)
  ///
  /// Dump "hprof" data to the specified file.  This may cause a GC.
  ///@param fileName Full pathname of output file (e.g. "/sdcard/dump.hprof").
  ///@throws UnsupportedOperationException if the VM was built without
  ///         HPROF support.
  ///@throws IOException if an error occurs while opening or writing files.
  static void dumpHprofData(jni.JniString fileName) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_dumpHprofData,
          jni.JniType.voidType, [fileName.reference]).check();

  static final _id_getBinderSentTransactions = jniAccessors.getStaticMethodIDOf(
      _classRef, "getBinderSentTransactions", "()I");

  /// from: static public native int getBinderSentTransactions()
  ///
  /// Returns the number of sent transactions from this process.
  ///@return The number of sent transactions or -1 if it could not read t.
  static int getBinderSentTransactions() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getBinderSentTransactions, jni.JniType.intType, []).integer;

  static final _id_getBinderReceivedTransactions = jniAccessors
      .getStaticMethodIDOf(_classRef, "getBinderReceivedTransactions", "()I");

  /// from: static public native int getBinderReceivedTransactions()
  ///
  /// Returns the number of received transactions from the binder driver.
  ///@return The number of received transactions or -1 if it could not read the stats.
  static int getBinderReceivedTransactions() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getBinderReceivedTransactions, jni.JniType.intType, []).integer;

  static final _id_getBinderLocalObjectCount = jniAccessors.getStaticMethodIDOf(
      _classRef, "getBinderLocalObjectCount", "()I");

  /// from: static public native int getBinderLocalObjectCount()
  ///
  /// Returns the number of active local Binder objects that exist in the
  /// current process.
  static int getBinderLocalObjectCount() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getBinderLocalObjectCount, jni.JniType.intType, []).integer;

  static final _id_getBinderProxyObjectCount = jniAccessors.getStaticMethodIDOf(
      _classRef, "getBinderProxyObjectCount", "()I");

  /// from: static public native int getBinderProxyObjectCount()
  ///
  /// Returns the number of references to remote proxy Binder objects that
  /// exist in the current process.
  static int getBinderProxyObjectCount() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getBinderProxyObjectCount, jni.JniType.intType, []).integer;

  static final _id_getBinderDeathObjectCount = jniAccessors.getStaticMethodIDOf(
      _classRef, "getBinderDeathObjectCount", "()I");

  /// from: static public native int getBinderDeathObjectCount()
  ///
  /// Returns the number of death notification links to Binder objects that
  /// exist in the current process.
  static int getBinderDeathObjectCount() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getBinderDeathObjectCount, jni.JniType.intType, []).integer;

  static final _id_dumpService = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "dumpService",
      "(Ljava/lang/String;Ljava/io/FileDescriptor;[Ljava/lang/String;)Z");

  /// from: static public boolean dumpService(java.lang.String name, java.io.FileDescriptor fd, java.lang.String[] args)
  ///
  /// Get a debugging dump of a system service by name.
  ///
  /// Most services require the caller to hold android.permission.DUMP.
  ///@param name of the service to dump
  ///@param fd to write dump output to (usually an output log file)
  ///@param args to pass to the service's dump method, may be null
  ///@return true if the service was dumped successfully, false if
  ///     the service could not be found or had an error while dumping
  static bool dumpService(
          jni.JniString name, jni.JniObject fd, jni.JniObject args) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_dumpService,
          jni.JniType.booleanType,
          [name.reference, fd.reference, args.reference]).boolean;

  static final _id_attachJvmtiAgent = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "attachJvmtiAgent",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/ClassLoader;)V");

  /// from: static public void attachJvmtiAgent(java.lang.String library, java.lang.String options, java.lang.ClassLoader classLoader)
  ///
  /// Attach a library as a jvmti agent to the current runtime, with the given classloader
  /// determining the library search path.
  ///
  /// Note: agents may only be attached to debuggable apps. Otherwise, this function will
  /// throw a SecurityException.
  ///@param library the library containing the agent.
  /// This value must never be {@code null}.
  ///@param options the options passed to the agent.
  /// This value may be {@code null}.
  ///@param classLoader the classloader determining the library search path.
  ///
  /// This value may be {@code null}.
  ///@throws IOException if the agent could not be attached.
  ///@throws SecurityException if the app is not debuggable.
  static void attachJvmtiAgent(jni.JniString library0, jni.JniString options,
          jni.JniObject classLoader) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_attachJvmtiAgent, jni.JniType.voidType, [
        library0.reference,
        options.reference,
        classLoader.reference
      ]).check();
}

/// from: android.os.Debug$MemoryInfo
///
/// This class is used to retrieved various statistics about the memory mappings for this
/// process. The returned info is broken down by dalvik, native, and other. All results are in kB.
class Debug_MemoryInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/os/Debug\$MemoryInfo");
  Debug_MemoryInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.os.Debug.MemoryInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_dalvikPrivateDirty =
      jniAccessors.getFieldIDOf(_classRef, "dalvikPrivateDirty", "I");

  /// from: public int dalvikPrivateDirty
  ///
  /// The private dirty pages used by dalvik heap.
  int get dalvikPrivateDirty => jniAccessors
      .getField(reference, _id_dalvikPrivateDirty, jni.JniType.intType)
      .integer;

  /// from: public int dalvikPrivateDirty
  ///
  /// The private dirty pages used by dalvik heap.
  set dalvikPrivateDirty(int value) =>
      jniEnv.SetIntField(reference, _id_dalvikPrivateDirty, value);

  static final _id_dalvikPss =
      jniAccessors.getFieldIDOf(_classRef, "dalvikPss", "I");

  /// from: public int dalvikPss
  ///
  /// The proportional set size for dalvik heap.  (Doesn't include other Dalvik overhead.)
  int get dalvikPss => jniAccessors
      .getField(reference, _id_dalvikPss, jni.JniType.intType)
      .integer;

  /// from: public int dalvikPss
  ///
  /// The proportional set size for dalvik heap.  (Doesn't include other Dalvik overhead.)
  set dalvikPss(int value) =>
      jniEnv.SetIntField(reference, _id_dalvikPss, value);

  static final _id_dalvikSharedDirty =
      jniAccessors.getFieldIDOf(_classRef, "dalvikSharedDirty", "I");

  /// from: public int dalvikSharedDirty
  ///
  /// The shared dirty pages used by dalvik heap.
  int get dalvikSharedDirty => jniAccessors
      .getField(reference, _id_dalvikSharedDirty, jni.JniType.intType)
      .integer;

  /// from: public int dalvikSharedDirty
  ///
  /// The shared dirty pages used by dalvik heap.
  set dalvikSharedDirty(int value) =>
      jniEnv.SetIntField(reference, _id_dalvikSharedDirty, value);

  static final _id_nativePrivateDirty =
      jniAccessors.getFieldIDOf(_classRef, "nativePrivateDirty", "I");

  /// from: public int nativePrivateDirty
  ///
  /// The private dirty pages used by the native heap.
  int get nativePrivateDirty => jniAccessors
      .getField(reference, _id_nativePrivateDirty, jni.JniType.intType)
      .integer;

  /// from: public int nativePrivateDirty
  ///
  /// The private dirty pages used by the native heap.
  set nativePrivateDirty(int value) =>
      jniEnv.SetIntField(reference, _id_nativePrivateDirty, value);

  static final _id_nativePss =
      jniAccessors.getFieldIDOf(_classRef, "nativePss", "I");

  /// from: public int nativePss
  ///
  /// The proportional set size for the native heap.
  int get nativePss => jniAccessors
      .getField(reference, _id_nativePss, jni.JniType.intType)
      .integer;

  /// from: public int nativePss
  ///
  /// The proportional set size for the native heap.
  set nativePss(int value) =>
      jniEnv.SetIntField(reference, _id_nativePss, value);

  static final _id_nativeSharedDirty =
      jniAccessors.getFieldIDOf(_classRef, "nativeSharedDirty", "I");

  /// from: public int nativeSharedDirty
  ///
  /// The shared dirty pages used by the native heap.
  int get nativeSharedDirty => jniAccessors
      .getField(reference, _id_nativeSharedDirty, jni.JniType.intType)
      .integer;

  /// from: public int nativeSharedDirty
  ///
  /// The shared dirty pages used by the native heap.
  set nativeSharedDirty(int value) =>
      jniEnv.SetIntField(reference, _id_nativeSharedDirty, value);

  static final _id_otherPrivateDirty =
      jniAccessors.getFieldIDOf(_classRef, "otherPrivateDirty", "I");

  /// from: public int otherPrivateDirty
  ///
  /// The private dirty pages used by everything else.
  int get otherPrivateDirty => jniAccessors
      .getField(reference, _id_otherPrivateDirty, jni.JniType.intType)
      .integer;

  /// from: public int otherPrivateDirty
  ///
  /// The private dirty pages used by everything else.
  set otherPrivateDirty(int value) =>
      jniEnv.SetIntField(reference, _id_otherPrivateDirty, value);

  static final _id_otherPss =
      jniAccessors.getFieldIDOf(_classRef, "otherPss", "I");

  /// from: public int otherPss
  ///
  /// The proportional set size for everything else.
  int get otherPss => jniAccessors
      .getField(reference, _id_otherPss, jni.JniType.intType)
      .integer;

  /// from: public int otherPss
  ///
  /// The proportional set size for everything else.
  set otherPss(int value) => jniEnv.SetIntField(reference, _id_otherPss, value);

  static final _id_otherSharedDirty =
      jniAccessors.getFieldIDOf(_classRef, "otherSharedDirty", "I");

  /// from: public int otherSharedDirty
  ///
  /// The shared dirty pages used by everything else.
  int get otherSharedDirty => jniAccessors
      .getField(reference, _id_otherSharedDirty, jni.JniType.intType)
      .integer;

  /// from: public int otherSharedDirty
  ///
  /// The shared dirty pages used by everything else.
  set otherSharedDirty(int value) =>
      jniEnv.SetIntField(reference, _id_otherSharedDirty, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Debug_MemoryInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getTotalPss =
      jniAccessors.getMethodIDOf(_classRef, "getTotalPss", "()I");

  /// from: public int getTotalPss()
  ///
  /// Return total PSS memory usage in kB.
  int getTotalPss() => jniAccessors.callMethodWithArgs(
      reference, _id_getTotalPss, jni.JniType.intType, []).integer;

  static final _id_getTotalSwappablePss =
      jniAccessors.getMethodIDOf(_classRef, "getTotalSwappablePss", "()I");

  /// from: public int getTotalSwappablePss()
  ///
  /// Return total PSS memory usage in kB mapping a file of one of the following extension:
  /// .so, .jar, .apk, .ttf, .dex, .odex, .oat, .art .
  int getTotalSwappablePss() => jniAccessors.callMethodWithArgs(
      reference, _id_getTotalSwappablePss, jni.JniType.intType, []).integer;

  static final _id_getTotalPrivateDirty =
      jniAccessors.getMethodIDOf(_classRef, "getTotalPrivateDirty", "()I");

  /// from: public int getTotalPrivateDirty()
  ///
  /// Return total private dirty memory usage in kB.
  int getTotalPrivateDirty() => jniAccessors.callMethodWithArgs(
      reference, _id_getTotalPrivateDirty, jni.JniType.intType, []).integer;

  static final _id_getTotalSharedDirty =
      jniAccessors.getMethodIDOf(_classRef, "getTotalSharedDirty", "()I");

  /// from: public int getTotalSharedDirty()
  ///
  /// Return total shared dirty memory usage in kB.
  int getTotalSharedDirty() => jniAccessors.callMethodWithArgs(
      reference, _id_getTotalSharedDirty, jni.JniType.intType, []).integer;

  static final _id_getTotalPrivateClean =
      jniAccessors.getMethodIDOf(_classRef, "getTotalPrivateClean", "()I");

  /// from: public int getTotalPrivateClean()
  ///
  /// Return total shared clean memory usage in kB.
  int getTotalPrivateClean() => jniAccessors.callMethodWithArgs(
      reference, _id_getTotalPrivateClean, jni.JniType.intType, []).integer;

  static final _id_getTotalSharedClean =
      jniAccessors.getMethodIDOf(_classRef, "getTotalSharedClean", "()I");

  /// from: public int getTotalSharedClean()
  ///
  /// Return total shared clean memory usage in kB.
  int getTotalSharedClean() => jniAccessors.callMethodWithArgs(
      reference, _id_getTotalSharedClean, jni.JniType.intType, []).integer;

  static final _id_getMemoryStat = jniAccessors.getMethodIDOf(
      _classRef, "getMemoryStat", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String getMemoryStat(java.lang.String statName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value of a particular memory statistic or {@code null} if no
  /// such memory statistic exists.
  ///
  /// The following table lists the memory statistics that are supported.
  /// Note that memory statistics may be added or removed in a future API level.
  ///
  ///
  /// <table>
  ///     <thead>
  ///         <tr>
  ///             <th>Memory statistic name</th>
  ///             <th>Meaning</th>
  ///             <th>Example</th>
  ///             <th>Supported (API Levels)</th>
  ///         </tr>
  ///     </thead>
  ///     <tbody>
  ///         <tr>
  ///             <td>summary.java-heap</td>
  ///             <td>The private Java Heap usage in kB. This corresponds to the Java Heap field
  ///                 in the App Summary section output by dumpsys meminfo.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>summary.native-heap</td>
  ///             <td>The private Native Heap usage in kB. This corresponds to the Native Heap
  ///                 field in the App Summary section output by dumpsys meminfo.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>summary.code</td>
  ///             <td>The memory usage for static code and resources in kB. This corresponds to
  ///                 the Code field in the App Summary section output by dumpsys meminfo.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>summary.stack</td>
  ///             <td>The stack usage in kB. This corresponds to the Stack field in the
  ///                 App Summary section output by dumpsys meminfo.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>summary.graphics</td>
  ///             <td>The graphics usage in kB. This corresponds to the Graphics field in the
  ///                 App Summary section output by dumpsys meminfo.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>summary.private-other</td>
  ///             <td>Other private memory usage in kB. This corresponds to the Private Other
  ///                 field output in the App Summary section by dumpsys meminfo.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>summary.system</td>
  ///             <td>Shared and system memory usage in kB. This corresponds to the System
  ///                 field output in the App Summary section by dumpsys meminfo.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>summary.total-pss</td>
  ///             <td>Total PPS memory usage in kB.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>summary.total-swap</td>
  ///             <td>Total swap usage in kB.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///     </tbody>
  /// </table>
  jni.JniString getMemoryStat(jni.JniString statName) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getMemoryStat,
          jni.JniType.objectType,
          [statName.reference]).object);

  static final _id_getMemoryStats = jniAccessors.getMethodIDOf(
      _classRef, "getMemoryStats", "()Ljava/util/Map;");

  /// from: public java.util.Map<java.lang.String,java.lang.String> getMemoryStats()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a map of the names/values of the memory statistics
  /// that \#getMemoryStat(String) supports.
  ///@return a map of the names/values of the supported memory statistics.
  jni.JniObject getMemoryStats() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMemoryStats, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_readFromParcel = jniAccessors.getMethodIDOf(
      _classRef, "readFromParcel", "(Landroid/os/Parcel;)V");

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(parcel_.Parcel source) => jniAccessors.callMethodWithArgs(
      reference,
      _id_readFromParcel,
      jni.JniType.voidType,
      [source.reference]).check();
}

/// from: android.os.Debug$InstructionCount
///
/// API for gathering and querying instruction counts.
///
/// Example usage:
/// <pre>
///   Debug.InstructionCount icount = new Debug.InstructionCount();
///   icount.resetAndStart();
///    [... do lots of stuff ...]
///   if (icount.collect()) {
///       System.out.println("Total instructions executed: "
///           + icount.globalTotal());
///       System.out.println("Method invocations: "
///           + icount.globalMethodInvocations());
///   }
/// </pre>
///@deprecated Instruction counting is no longer supported.
class Debug_InstructionCount extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/os/Debug\$InstructionCount");
  Debug_InstructionCount.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Debug_InstructionCount()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_resetAndStart =
      jniAccessors.getMethodIDOf(_classRef, "resetAndStart", "()Z");

  /// from: public boolean resetAndStart()
  ///
  /// Reset counters and ensure counts are running.  Counts may
  /// have already been running.
  ///@return true if counting was started
  bool resetAndStart() => jniAccessors.callMethodWithArgs(
      reference, _id_resetAndStart, jni.JniType.booleanType, []).boolean;

  static final _id_collect =
      jniAccessors.getMethodIDOf(_classRef, "collect", "()Z");

  /// from: public boolean collect()
  ///
  /// Collect instruction counts.  May or may not stop the
  /// counting process.
  bool collect() => jniAccessors.callMethodWithArgs(
      reference, _id_collect, jni.JniType.booleanType, []).boolean;

  static final _id_globalTotal =
      jniAccessors.getMethodIDOf(_classRef, "globalTotal", "()I");

  /// from: public int globalTotal()
  ///
  /// Return the total number of instructions executed globally (i.e. in
  /// all threads).
  int globalTotal() => jniAccessors.callMethodWithArgs(
      reference, _id_globalTotal, jni.JniType.intType, []).integer;

  static final _id_globalMethodInvocations =
      jniAccessors.getMethodIDOf(_classRef, "globalMethodInvocations", "()I");

  /// from: public int globalMethodInvocations()
  ///
  /// Return the total number of method-invocation instructions
  /// executed globally.
  int globalMethodInvocations() => jniAccessors.callMethodWithArgs(
      reference, _id_globalMethodInvocations, jni.JniType.intType, []).integer;
}
