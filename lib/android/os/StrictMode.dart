// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "strictmode/Violation.dart" as violation_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.StrictMode
///
/// StrictMode is a developer tool which detects things you might be doing by accident and brings
/// them to your attention so you can fix them.
///
/// StrictMode is most commonly used to catch accidental disk or network access on the
/// application's main thread, where UI operations are received and animations take place. Keeping
/// disk and network operations off the main thread makes for much smoother, more responsive
/// applications. By keeping your application's main thread responsive, you also prevent <a href="{@docRoot}guide/practices/design/responsiveness.html">ANR dialogs</a> from being shown to
/// users.
///
/// <p class="note">Note that even though an Android device's disk is often on flash memory, many
/// devices run a filesystem on top of that memory with very limited concurrency. It's often the case
/// that almost all disk accesses are fast, but may in individual cases be dramatically slower when
/// certain I/O is happening in the background from other processes. If possible, it's best to assume
/// that such things are not fast.
///
/// Example code to enable from early in your android.app.Application, android.app.Activity, or other application component's android.app.Application\#onCreate
/// method:
///
/// <pre>
/// public void onCreate() {
///     if (DEVELOPER_MODE) {
///         StrictMode.setThreadPolicy(new ThreadPolicy.Builder StrictMode.ThreadPolicy.Builder()
///                 .detectDiskReads()
///                 .detectDiskWrites()
///                 .detectNetwork()   // or .detectAll() for all detectable problems
///                 .penaltyLog()
///                 .build());
///         StrictMode.setVmPolicy(new VmPolicy.Builder StrictMode.VmPolicy.Builder()
///                 .detectLeakedSqlLiteObjects()
///                 .detectLeakedClosableObjects()
///                 .penaltyLog()
///                 .penaltyDeath()
///                 .build());
///     }
///     super.onCreate();
/// }
/// </pre>
///
/// You can decide what should happen when a violation is detected. For example, using ThreadPolicy.Builder\#penaltyLog you can watch the output of <code>adb logcat</code> while you
/// use your application to see the violations as they happen.
///
/// If you find violations that you feel are problematic, there are a variety of tools to help
/// solve them: threads, android.os.Handler, android.os.AsyncTask, android.app.IntentService, etc. But don't feel compelled to fix everything that StrictMode
/// finds. In particular, many cases of disk access are often necessary during the normal activity
/// lifecycle. Use StrictMode to find things you did by accident. Network requests on the UI thread
/// are almost always a problem, though.
///
/// <p class="note">StrictMode is not a security mechanism and is not guaranteed to find all disk or
/// network accesses. While it does propagate its state across process boundaries when doing android.os.Binder calls, it's still ultimately a best effort mechanism. Notably, disk or network
/// access from JNI calls won't necessarily trigger it. Future versions of Android may catch more (or
/// fewer) operations, so you should never leave StrictMode enabled in applications distributed on
/// Google Play.
class StrictMode extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/StrictMode");
  StrictMode.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_setThreadPolicy = jniAccessors.getStaticMethodIDOf(
      _classRef, "setThreadPolicy", "(Landroid/os/StrictMode\$ThreadPolicy;)V");

  /// from: static public void setThreadPolicy(android.os.StrictMode.ThreadPolicy policy)
  ///
  /// Sets the policy for what actions on the current thread should be detected, as well as the
  /// penalty if such actions occur.
  ///
  /// Internally this sets a thread-local variable which is propagated across cross-process IPC
  /// calls, meaning you can catch violations when a system service or another process accesses the
  /// disk or network on your behalf.
  ///@param policy the policy to put into place
  static void setThreadPolicy(StrictMode_ThreadPolicy policy) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_setThreadPolicy,
          jni.JniType.voidType, [policy.reference]).check();

  static final _id_getThreadPolicy = jniAccessors.getStaticMethodIDOf(
      _classRef, "getThreadPolicy", "()Landroid/os/StrictMode\$ThreadPolicy;");

  /// from: static public android.os.StrictMode.ThreadPolicy getThreadPolicy()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current thread's policy.
  static StrictMode_ThreadPolicy getThreadPolicy() =>
      StrictMode_ThreadPolicy.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getThreadPolicy, jni.JniType.objectType, []).object);

  static final _id_allowThreadDiskWrites = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "allowThreadDiskWrites",
      "()Landroid/os/StrictMode\$ThreadPolicy;");

  /// from: static public android.os.StrictMode.ThreadPolicy allowThreadDiskWrites()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A convenience wrapper that takes the current ThreadPolicy from \#getThreadPolicy, modifies it to permit both disk reads &amp; writes, and sets the new
  /// policy with \#setThreadPolicy, returning the old policy so you can restore it at the
  /// end of a block.
  ///@return the old policy, to be passed to \#setThreadPolicy to restore the policy at the
  ///     end of a block
  static StrictMode_ThreadPolicy allowThreadDiskWrites() =>
      StrictMode_ThreadPolicy.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_allowThreadDiskWrites,
          jni.JniType.objectType, []).object);

  static final _id_allowThreadDiskReads = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "allowThreadDiskReads",
      "()Landroid/os/StrictMode\$ThreadPolicy;");

  /// from: static public android.os.StrictMode.ThreadPolicy allowThreadDiskReads()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A convenience wrapper that takes the current ThreadPolicy from \#getThreadPolicy, modifies it to permit disk reads, and sets the new policy with \#setThreadPolicy, returning the old policy so you can restore it at the end of a block.
  ///@return the old policy, to be passed to setThreadPolicy to restore the policy.
  static StrictMode_ThreadPolicy allowThreadDiskReads() =>
      StrictMode_ThreadPolicy.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_allowThreadDiskReads,
          jni.JniType.objectType, []).object);

  static final _id_setVmPolicy = jniAccessors.getStaticMethodIDOf(
      _classRef, "setVmPolicy", "(Landroid/os/StrictMode\$VmPolicy;)V");

  /// from: static public void setVmPolicy(android.os.StrictMode.VmPolicy policy)
  ///
  /// Sets the policy for what actions in the VM process (on any thread) should be detected, as
  /// well as the penalty if such actions occur.
  ///@param policy the policy to put into place
  static void setVmPolicy(StrictMode_VmPolicy policy) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_setVmPolicy,
          jni.JniType.voidType, [policy.reference]).check();

  static final _id_getVmPolicy = jniAccessors.getStaticMethodIDOf(
      _classRef, "getVmPolicy", "()Landroid/os/StrictMode\$VmPolicy;");

  /// from: static public android.os.StrictMode.VmPolicy getVmPolicy()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current VM policy.
  static StrictMode_VmPolicy getVmPolicy() =>
      StrictMode_VmPolicy.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getVmPolicy, jni.JniType.objectType, []).object);

  static final _id_enableDefaults =
      jniAccessors.getStaticMethodIDOf(_classRef, "enableDefaults", "()V");

  /// from: static public void enableDefaults()
  ///
  /// Enable the recommended StrictMode defaults, with violations just being logged.
  ///
  /// This catches disk and network access on the main thread, as well as leaked SQLite cursors
  /// and unclosed resources. This is simply a wrapper around \#setVmPolicy and \#setThreadPolicy.
  static void enableDefaults() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_enableDefaults, jni.JniType.voidType, []).check();

  static final _id_noteSlowCall = jniAccessors.getStaticMethodIDOf(
      _classRef, "noteSlowCall", "(Ljava/lang/String;)V");

  /// from: static public void noteSlowCall(java.lang.String name)
  ///
  /// For code to note that it's slow. This is a no-op unless the current thread's android.os.StrictMode.ThreadPolicy has android.os.StrictMode.ThreadPolicy.Builder\#detectCustomSlowCalls enabled.
  ///@param name a short string for the exception stack trace that's built if when this fires.
  static void noteSlowCall(jni.JniString name) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_noteSlowCall,
          jni.JniType.voidType, [name.reference]).check();
}

/// from: android.os.StrictMode$VmPolicy
///
/// StrictMode policy applied to all threads in the virtual machine's process.
///
/// The policy is enabled by \#setVmPolicy.
class StrictMode_VmPolicy extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/os/StrictMode\$VmPolicy");
  StrictMode_VmPolicy.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_LAX = jniAccessors.getStaticFieldIDOf(
      _classRef, "LAX", "Landroid/os/StrictMode\$VmPolicy;");

  /// from: static public final android.os.StrictMode.VmPolicy LAX
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The default, lax policy which doesn't catch anything.
  static StrictMode_VmPolicy get LAX => StrictMode_VmPolicy.fromRef(jniAccessors
      .getStaticField(_classRef, _id_LAX, jni.JniType.objectType)
      .object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.os.StrictMode$VmPolicy$Builder
///
/// Creates VmPolicy instances. Methods whose names start with {@code detect} specify
/// what problems we should look for. Methods whose names start with {@code penalty} specify
/// what we should do when we detect a problem.
///
/// You can call as many {@code detect} and {@code penalty} methods as you like. Currently
/// order is insignificant: all penalties apply to all detected problems.
///
/// For example, detect everything and log anything that's found:
///
/// <pre>
/// StrictMode.VmPolicy policy = new StrictMode.VmPolicy.Builder()
///     .detectAll()
///     .penaltyLog()
///     .build();
/// StrictMode.setVmPolicy(policy);
/// </pre>
class StrictMode_VmPolicy_Builder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/os/StrictMode\$VmPolicy\$Builder");
  StrictMode_VmPolicy_Builder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  StrictMode_VmPolicy_Builder()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/os/StrictMode\$VmPolicy;)V");

  /// from: public void <init>(android.os.StrictMode.VmPolicy base)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Build upon an existing VmPolicy.
  StrictMode_VmPolicy_Builder.ctor1(StrictMode_VmPolicy base)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor1, [base.reference]).object);

  static final _id_setClassInstanceLimit = jniAccessors.getMethodIDOf(
      _classRef,
      "setClassInstanceLimit",
      "(Ljava/lang/Class;I)Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder setClassInstanceLimit(java.lang.Class klass, int instanceLimit)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set an upper bound on how many instances of a class can be in memory at once. Helps
  /// to prevent object leaks.
  StrictMode_VmPolicy_Builder setClassInstanceLimit(
          jni.JniObject klass, int instanceLimit) =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setClassInstanceLimit,
          jni.JniType.objectType,
          [klass.reference, instanceLimit]).object);

  static final _id_detectActivityLeaks = jniAccessors.getMethodIDOf(_classRef,
      "detectActivityLeaks", "()Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder detectActivityLeaks()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Detect leaks of android.app.Activity subclasses.
  StrictMode_VmPolicy_Builder detectActivityLeaks() =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_detectActivityLeaks,
          jni.JniType.objectType, []).object);

  static final _id_detectNonSdkApiUsage = jniAccessors.getMethodIDOf(_classRef,
      "detectNonSdkApiUsage", "()Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder detectNonSdkApiUsage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Detect reflective usage of APIs that are not part of the public Android SDK.
  ///
  /// Note that any non-SDK APIs that this processes accesses before this detection is
  /// enabled may not be detected. To ensure that all such API accesses are detected,
  /// you should apply this policy as early as possible after process creation.
  StrictMode_VmPolicy_Builder detectNonSdkApiUsage() =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_detectNonSdkApiUsage,
          jni.JniType.objectType, []).object);

  static final _id_permitNonSdkApiUsage = jniAccessors.getMethodIDOf(_classRef,
      "permitNonSdkApiUsage", "()Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder permitNonSdkApiUsage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Permit reflective usage of APIs that are not part of the public Android SDK. Note
  /// that this __only__ affects {@code StrictMode}, the underlying runtime may
  /// continue to restrict or warn on access to methods that are not part of the
  /// public SDK.
  StrictMode_VmPolicy_Builder permitNonSdkApiUsage() =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_permitNonSdkApiUsage,
          jni.JniType.objectType, []).object);

  static final _id_detectAll = jniAccessors.getMethodIDOf(
      _classRef, "detectAll", "()Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder detectAll()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Detect everything that's potentially suspect.
  ///
  /// In the Honeycomb release this includes leaks of SQLite cursors, Activities, and
  /// other closable objects but will likely expand in future releases.
  StrictMode_VmPolicy_Builder detectAll() =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_detectAll, jni.JniType.objectType, []).object);

  static final _id_detectLeakedSqlLiteObjects = jniAccessors.getMethodIDOf(
      _classRef,
      "detectLeakedSqlLiteObjects",
      "()Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder detectLeakedSqlLiteObjects()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Detect when an android.database.sqlite.SQLiteCursor or other SQLite object is
  /// finalized without having been closed.
  ///
  /// You always want to explicitly close your SQLite cursors to avoid unnecessary
  /// database contention and temporary memory leaks.
  StrictMode_VmPolicy_Builder detectLeakedSqlLiteObjects() =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_detectLeakedSqlLiteObjects,
          jni.JniType.objectType, []).object);

  static final _id_detectLeakedClosableObjects = jniAccessors.getMethodIDOf(
      _classRef,
      "detectLeakedClosableObjects",
      "()Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder detectLeakedClosableObjects()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Detect when an java.io.Closeable or other object with an explicit termination
  /// method is finalized without having been closed.
  ///
  /// You always want to explicitly close such objects to avoid unnecessary resources
  /// leaks.
  StrictMode_VmPolicy_Builder detectLeakedClosableObjects() =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_detectLeakedClosableObjects,
          jni.JniType.objectType, []).object);

  static final _id_detectLeakedRegistrationObjects = jniAccessors.getMethodIDOf(
      _classRef,
      "detectLeakedRegistrationObjects",
      "()Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder detectLeakedRegistrationObjects()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Detect when a BroadcastReceiver or ServiceConnection is leaked during
  /// Context teardown.
  StrictMode_VmPolicy_Builder detectLeakedRegistrationObjects() =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_detectLeakedRegistrationObjects,
          jni.JniType.objectType, []).object);

  static final _id_detectFileUriExposure = jniAccessors.getMethodIDOf(_classRef,
      "detectFileUriExposure", "()Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder detectFileUriExposure()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Detect when the calling application exposes a {@code file://} android.net.Uri
  /// to another app.
  ///
  /// This exposure is discouraged since the receiving app may not have access to the
  /// shared path. For example, the receiving app may not have requested the android.Manifest.permission\#READ_EXTERNAL_STORAGE runtime permission, or the
  /// platform may be sharing the android.net.Uri across user profile boundaries.
  ///
  /// Instead, apps should use {@code content://} Uris so the platform can extend
  /// temporary permission for the receiving app to access the resource.
  ///@see android.support.v4.content.FileProvider
  ///@see Intent\#FLAG_GRANT_READ_URI_PERMISSION
  StrictMode_VmPolicy_Builder detectFileUriExposure() =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_detectFileUriExposure,
          jni.JniType.objectType, []).object);

  static final _id_detectCleartextNetwork = jniAccessors.getMethodIDOf(
      _classRef,
      "detectCleartextNetwork",
      "()Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder detectCleartextNetwork()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Detect any network traffic from the calling app which is not wrapped in SSL/TLS. This
  /// can help you detect places that your app is inadvertently sending cleartext data
  /// across the network.
  ///
  /// Using \#penaltyDeath() or \#penaltyDeathOnCleartextNetwork() will
  /// block further traffic on that socket to prevent accidental data leakage, in addition
  /// to crashing your process.
  ///
  /// Using \#penaltyDropBox() will log the raw contents of the packet that
  /// triggered the violation.
  ///
  /// This inspects both IPv4/IPv6 and TCP/UDP network traffic, but it may be subject to
  /// false positives, such as when STARTTLS protocols or HTTP proxies are used.
  StrictMode_VmPolicy_Builder detectCleartextNetwork() =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_detectCleartextNetwork,
          jni.JniType.objectType, []).object);

  static final _id_detectContentUriWithoutPermission =
      jniAccessors.getMethodIDOf(_classRef, "detectContentUriWithoutPermission",
          "()Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder detectContentUriWithoutPermission()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Detect when the calling application sends a {@code content://} android.net.Uri to another app without setting Intent\#FLAG_GRANT_READ_URI_PERMISSION or Intent\#FLAG_GRANT_WRITE_URI_PERMISSION.
  ///
  /// Forgetting to include one or more of these flags when sending an intent is
  /// typically an app bug.
  ///@see Intent\#FLAG_GRANT_READ_URI_PERMISSION
  ///@see Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  StrictMode_VmPolicy_Builder detectContentUriWithoutPermission() =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_detectContentUriWithoutPermission,
          jni.JniType.objectType, []).object);

  static final _id_detectUntaggedSockets = jniAccessors.getMethodIDOf(_classRef,
      "detectUntaggedSockets", "()Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder detectUntaggedSockets()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Detect any sockets in the calling app which have not been tagged using TrafficStats. Tagging sockets can help you investigate network usage inside your
  /// app, such as a narrowing down heavy usage to a specific library or component.
  ///
  /// This currently does not detect sockets created in native code.
  ///@see TrafficStats\#setThreadStatsTag(int)
  ///@see TrafficStats\#tagSocket(java.net.Socket)
  ///@see TrafficStats\#tagDatagramSocket(java.net.DatagramSocket)
  StrictMode_VmPolicy_Builder detectUntaggedSockets() =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_detectUntaggedSockets,
          jni.JniType.objectType, []).object);

  static final _id_penaltyDeath = jniAccessors.getMethodIDOf(_classRef,
      "penaltyDeath", "()Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder penaltyDeath()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Crashes the whole process on violation. This penalty runs at the end of all enabled
  /// penalties so you'll still get your logging or other violations before the process
  /// dies.
  StrictMode_VmPolicy_Builder penaltyDeath() =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_penaltyDeath, jni.JniType.objectType, []).object);

  static final _id_penaltyDeathOnCleartextNetwork = jniAccessors.getMethodIDOf(
      _classRef,
      "penaltyDeathOnCleartextNetwork",
      "()Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder penaltyDeathOnCleartextNetwork()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Crashes the whole process when cleartext network traffic is detected.
  ///@see \#detectCleartextNetwork()
  StrictMode_VmPolicy_Builder penaltyDeathOnCleartextNetwork() =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_penaltyDeathOnCleartextNetwork,
          jni.JniType.objectType, []).object);

  static final _id_penaltyDeathOnFileUriExposure = jniAccessors.getMethodIDOf(
      _classRef,
      "penaltyDeathOnFileUriExposure",
      "()Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder penaltyDeathOnFileUriExposure()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Crashes the whole process when a {@code file://} android.net.Uri is exposed
  /// beyond this app.
  ///@see \#detectFileUriExposure()
  StrictMode_VmPolicy_Builder penaltyDeathOnFileUriExposure() =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_penaltyDeathOnFileUriExposure,
          jni.JniType.objectType, []).object);

  static final _id_penaltyLog = jniAccessors.getMethodIDOf(
      _classRef, "penaltyLog", "()Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder penaltyLog()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Log detected violations to the system log.
  StrictMode_VmPolicy_Builder penaltyLog() =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_penaltyLog, jni.JniType.objectType, []).object);

  static final _id_penaltyDropBox = jniAccessors.getMethodIDOf(_classRef,
      "penaltyDropBox", "()Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder penaltyDropBox()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Enable detected violations log a stacktrace and timing data to the android.os.DropBoxManager DropBox on policy violation. Intended mostly for platform
  /// integrators doing beta user field data collection.
  StrictMode_VmPolicy_Builder penaltyDropBox() =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_penaltyDropBox, jni.JniType.objectType, []).object);

  static final _id_penaltyListener = jniAccessors.getMethodIDOf(
      _classRef,
      "penaltyListener",
      "(Ljava/util/concurrent/Executor;Landroid/os/StrictMode\$OnVmViolationListener;)Landroid/os/StrictMode\$VmPolicy\$Builder;");

  /// from: public android.os.StrictMode.VmPolicy.Builder penaltyListener(java.util.concurrent.Executor executor, android.os.StrictMode.OnVmViolationListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call \#OnVmViolationListener\#onVmViolation(Violation) on every violation.
  ///@param executor This value must never be {@code null}.
  ///@param listener This value must never be {@code null}.
  StrictMode_VmPolicy_Builder penaltyListener(
          jni.JniObject executor, StrictMode_OnVmViolationListener listener) =>
      StrictMode_VmPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_penaltyListener,
          jni.JniType.objectType,
          [executor.reference, listener.reference]).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/os/StrictMode\$VmPolicy;");

  /// from: public android.os.StrictMode.VmPolicy build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct the VmPolicy instance.
  ///
  /// Note: if no penalties are enabled before calling <code>build</code>, \#penaltyLog is implicitly set.
  StrictMode_VmPolicy build() =>
      StrictMode_VmPolicy.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_build, jni.JniType.objectType, []).object);
}

/// from: android.os.StrictMode$ThreadPolicy
///
/// StrictMode policy applied to a certain thread.
///
/// The policy is enabled by \#setThreadPolicy. The current policy can be retrieved
/// with \#getThreadPolicy.
///
/// Note that multiple penalties may be provided and they're run in order from least to most
/// severe (logging before process death, for example). There's currently no mechanism to choose
/// different penalties for different detected actions.
class StrictMode_ThreadPolicy extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/os/StrictMode\$ThreadPolicy");
  StrictMode_ThreadPolicy.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_LAX = jniAccessors.getStaticFieldIDOf(
      _classRef, "LAX", "Landroid/os/StrictMode\$ThreadPolicy;");

  /// from: static public final android.os.StrictMode.ThreadPolicy LAX
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The default, lax policy which doesn't catch anything.
  static StrictMode_ThreadPolicy get LAX =>
      StrictMode_ThreadPolicy.fromRef(jniAccessors
          .getStaticField(_classRef, _id_LAX, jni.JniType.objectType)
          .object);

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.os.StrictMode$ThreadPolicy$Builder
///
/// Creates ThreadPolicy instances. Methods whose names start with {@code detect}
/// specify what problems we should look for. Methods whose names start with {@code penalty}
/// specify what we should do when we detect a problem.
///
/// You can call as many {@code detect} and {@code penalty} methods as you like. Currently
/// order is insignificant: all penalties apply to all detected problems.
///
/// For example, detect everything and log anything that's found:
///
/// <pre>
/// StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder()
///     .detectAll()
///     .penaltyLog()
///     .build();
/// StrictMode.setThreadPolicy(policy);
/// </pre>
class StrictMode_ThreadPolicy_Builder extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/os/StrictMode\$ThreadPolicy\$Builder");
  StrictMode_ThreadPolicy_Builder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Builder that detects nothing and has no violations. (but note that \#build will default to enabling \#penaltyLog if no other penalties are
  /// specified)
  StrictMode_ThreadPolicy_Builder()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/os/StrictMode\$ThreadPolicy;)V");

  /// from: public void <init>(android.os.StrictMode.ThreadPolicy policy)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Initialize a Builder from an existing ThreadPolicy.
  StrictMode_ThreadPolicy_Builder.ctor1(StrictMode_ThreadPolicy policy)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [policy.reference]).object);

  static final _id_detectAll = jniAccessors.getMethodIDOf(_classRef,
      "detectAll", "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder detectAll()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Detect everything that's potentially suspect.
  ///
  /// As of the Gingerbread release this includes network and disk operations but will
  /// likely expand in future releases.
  StrictMode_ThreadPolicy_Builder detectAll() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_detectAll, jni.JniType.objectType, []).object);

  static final _id_permitAll = jniAccessors.getMethodIDOf(_classRef,
      "permitAll", "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder permitAll()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Disable the detection of everything.
  StrictMode_ThreadPolicy_Builder permitAll() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_permitAll, jni.JniType.objectType, []).object);

  static final _id_detectNetwork = jniAccessors.getMethodIDOf(_classRef,
      "detectNetwork", "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder detectNetwork()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Enable detection of network operations.
  StrictMode_ThreadPolicy_Builder detectNetwork() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_detectNetwork, jni.JniType.objectType, []).object);

  static final _id_permitNetwork = jniAccessors.getMethodIDOf(_classRef,
      "permitNetwork", "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder permitNetwork()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Disable detection of network operations.
  StrictMode_ThreadPolicy_Builder permitNetwork() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_permitNetwork, jni.JniType.objectType, []).object);

  static final _id_detectDiskReads = jniAccessors.getMethodIDOf(_classRef,
      "detectDiskReads", "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder detectDiskReads()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Enable detection of disk reads.
  StrictMode_ThreadPolicy_Builder detectDiskReads() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_detectDiskReads, jni.JniType.objectType, []).object);

  static final _id_permitDiskReads = jniAccessors.getMethodIDOf(_classRef,
      "permitDiskReads", "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder permitDiskReads()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Disable detection of disk reads.
  StrictMode_ThreadPolicy_Builder permitDiskReads() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_permitDiskReads, jni.JniType.objectType, []).object);

  static final _id_detectCustomSlowCalls = jniAccessors.getMethodIDOf(
      _classRef,
      "detectCustomSlowCalls",
      "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder detectCustomSlowCalls()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Enable detection of slow calls.
  StrictMode_ThreadPolicy_Builder detectCustomSlowCalls() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_detectCustomSlowCalls,
          jni.JniType.objectType, []).object);

  static final _id_permitCustomSlowCalls = jniAccessors.getMethodIDOf(
      _classRef,
      "permitCustomSlowCalls",
      "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder permitCustomSlowCalls()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Disable detection of slow calls.
  StrictMode_ThreadPolicy_Builder permitCustomSlowCalls() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_permitCustomSlowCalls,
          jni.JniType.objectType, []).object);

  static final _id_permitResourceMismatches = jniAccessors.getMethodIDOf(
      _classRef,
      "permitResourceMismatches",
      "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder permitResourceMismatches()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Disable detection of mismatches between defined resource types and getter calls.
  StrictMode_ThreadPolicy_Builder permitResourceMismatches() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_permitResourceMismatches,
          jni.JniType.objectType, []).object);

  static final _id_detectUnbufferedIo = jniAccessors.getMethodIDOf(_classRef,
      "detectUnbufferedIo", "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder detectUnbufferedIo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Detect unbuffered input/output operations.
  StrictMode_ThreadPolicy_Builder detectUnbufferedIo() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_detectUnbufferedIo,
          jni.JniType.objectType, []).object);

  static final _id_permitUnbufferedIo = jniAccessors.getMethodIDOf(_classRef,
      "permitUnbufferedIo", "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder permitUnbufferedIo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Disable detection of unbuffered input/output operations.
  StrictMode_ThreadPolicy_Builder permitUnbufferedIo() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_permitUnbufferedIo,
          jni.JniType.objectType, []).object);

  static final _id_detectResourceMismatches = jniAccessors.getMethodIDOf(
      _classRef,
      "detectResourceMismatches",
      "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder detectResourceMismatches()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Enables detection of mismatches between defined resource types and getter calls.
  ///
  /// This helps detect accidental type mismatches and potentially expensive type
  /// conversions when obtaining typed resources.
  ///
  /// For example, a strict mode violation would be thrown when calling android.content.res.TypedArray\#getInt(int, int) on an index that contains a
  /// String-type resource. If the string value can be parsed as an integer, this method
  /// call will return a value without crashing; however, the developer should format the
  /// resource as an integer to avoid unnecessary type conversion.
  StrictMode_ThreadPolicy_Builder detectResourceMismatches() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_detectResourceMismatches,
          jni.JniType.objectType, []).object);

  static final _id_detectDiskWrites = jniAccessors.getMethodIDOf(_classRef,
      "detectDiskWrites", "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder detectDiskWrites()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Enable detection of disk writes.
  StrictMode_ThreadPolicy_Builder detectDiskWrites() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_detectDiskWrites, jni.JniType.objectType, []).object);

  static final _id_permitDiskWrites = jniAccessors.getMethodIDOf(_classRef,
      "permitDiskWrites", "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder permitDiskWrites()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Disable detection of disk writes.
  StrictMode_ThreadPolicy_Builder permitDiskWrites() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_permitDiskWrites, jni.JniType.objectType, []).object);

  static final _id_penaltyDialog = jniAccessors.getMethodIDOf(_classRef,
      "penaltyDialog", "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder penaltyDialog()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Show an annoying dialog to the developer on detected violations, rate-limited to be
  /// only a little annoying.
  StrictMode_ThreadPolicy_Builder penaltyDialog() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_penaltyDialog, jni.JniType.objectType, []).object);

  static final _id_penaltyDeath = jniAccessors.getMethodIDOf(_classRef,
      "penaltyDeath", "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder penaltyDeath()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Crash the whole process on violation. This penalty runs at the end of all enabled
  /// penalties so you'll still get see logging or other violations before the process
  /// dies.
  ///
  /// Unlike \#penaltyDeathOnNetwork, this applies to disk reads, disk writes,
  /// and network usage if their corresponding detect flags are set.
  StrictMode_ThreadPolicy_Builder penaltyDeath() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_penaltyDeath, jni.JniType.objectType, []).object);

  static final _id_penaltyDeathOnNetwork = jniAccessors.getMethodIDOf(
      _classRef,
      "penaltyDeathOnNetwork",
      "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder penaltyDeathOnNetwork()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Crash the whole process on any network usage. Unlike \#penaltyDeath, this
  /// penalty runs _before_ anything else. You must still have called \#detectNetwork to enable this.
  ///
  /// In the Honeycomb or later SDKs, this is on by default.
  StrictMode_ThreadPolicy_Builder penaltyDeathOnNetwork() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_penaltyDeathOnNetwork,
          jni.JniType.objectType, []).object);

  static final _id_penaltyFlashScreen = jniAccessors.getMethodIDOf(_classRef,
      "penaltyFlashScreen", "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder penaltyFlashScreen()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Flash the screen during a violation.
  StrictMode_ThreadPolicy_Builder penaltyFlashScreen() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_penaltyFlashScreen,
          jni.JniType.objectType, []).object);

  static final _id_penaltyLog = jniAccessors.getMethodIDOf(_classRef,
      "penaltyLog", "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder penaltyLog()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Log detected violations to the system log.
  StrictMode_ThreadPolicy_Builder penaltyLog() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_penaltyLog, jni.JniType.objectType, []).object);

  static final _id_penaltyDropBox = jniAccessors.getMethodIDOf(_classRef,
      "penaltyDropBox", "()Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder penaltyDropBox()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Enable detected violations log a stacktrace and timing data to the android.os.DropBoxManager DropBox on policy violation. Intended mostly for platform
  /// integrators doing beta user field data collection.
  StrictMode_ThreadPolicy_Builder penaltyDropBox() =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_penaltyDropBox, jni.JniType.objectType, []).object);

  static final _id_penaltyListener = jniAccessors.getMethodIDOf(
      _classRef,
      "penaltyListener",
      "(Ljava/util/concurrent/Executor;Landroid/os/StrictMode\$OnThreadViolationListener;)Landroid/os/StrictMode\$ThreadPolicy\$Builder;");

  /// from: public android.os.StrictMode.ThreadPolicy.Builder penaltyListener(java.util.concurrent.Executor executor, android.os.StrictMode.OnThreadViolationListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call \#OnThreadViolationListener\#onThreadViolation(Violation) on specified
  /// executor every violation.
  ///@param executor This value must never be {@code null}.
  ///@param listener This value must never be {@code null}.
  StrictMode_ThreadPolicy_Builder penaltyListener(jni.JniObject executor,
          StrictMode_OnThreadViolationListener listener) =>
      StrictMode_ThreadPolicy_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_penaltyListener,
          jni.JniType.objectType,
          [executor.reference, listener.reference]).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/os/StrictMode\$ThreadPolicy;");

  /// from: public android.os.StrictMode.ThreadPolicy build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct the ThreadPolicy instance.
  ///
  /// Note: if no penalties are enabled before calling <code>build</code>, \#penaltyLog is implicitly set.
  StrictMode_ThreadPolicy build() =>
      StrictMode_ThreadPolicy.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_build, jni.JniType.objectType, []).object);
}

/// from: android.os.StrictMode$OnVmViolationListener
///
/// When \#VmPolicy.Builder\#penaltyListener is enabled, the listener is called on the
/// provided executor when a VM violation occurs.
class StrictMode_OnVmViolationListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/os/StrictMode\$OnVmViolationListener");
  StrictMode_OnVmViolationListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onVmViolation = jniAccessors.getMethodIDOf(
      _classRef, "onVmViolation", "(Landroid/os/strictmode/Violation;)V");

  /// from: public abstract void onVmViolation(android.os.strictmode.Violation v)
  ///
  /// Called on a VM policy violation.
  void onVmViolation(violation_.Violation v) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onVmViolation,
      jni.JniType.voidType,
      [v.reference]).check();
}

/// from: android.os.StrictMode$OnThreadViolationListener
///
/// When \#ThreadPolicy.Builder\#penaltyListener is enabled, the listener is called on the
/// provided executor when a Thread violation occurs.
class StrictMode_OnThreadViolationListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/os/StrictMode\$OnThreadViolationListener");
  StrictMode_OnThreadViolationListener.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onThreadViolation = jniAccessors.getMethodIDOf(
      _classRef, "onThreadViolation", "(Landroid/os/strictmode/Violation;)V");

  /// from: public abstract void onThreadViolation(android.os.strictmode.Violation v)
  ///
  /// Called on a thread policy violation.
  void onThreadViolation(violation_.Violation v) =>
      jniAccessors.callMethodWithArgs(reference, _id_onThreadViolation,
          jni.JniType.voidType, [v.reference]).check();
}
