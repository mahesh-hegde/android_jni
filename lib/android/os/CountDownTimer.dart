// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.CountDownTimer
///
/// Schedule a countdown until a time in the future, with
/// regular notifications on intervals along the way.
///
/// Example of showing a 30 second countdown in a text field:
///
/// <pre class="prettyprint">
/// new CountDownTimer(30000, 1000) {
///
///     public void onTick(long millisUntilFinished) {
///         mTextField.setText("seconds remaining: " + millisUntilFinished / 1000);
///     }
///
///     public void onFinish() {
///         mTextField.setText("done!");
///     }
///  }.start();
/// </pre>
///
/// The calls to \#onTick(long) are synchronized to this object so that
/// one call to \#onTick(long) won't ever occur before the previous
/// callback is complete.  This is only relevant when the implementation of
/// \#onTick(long) takes an amount of time to execute that is significant
/// compared to the countdown interval.
class CountDownTimer extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/CountDownTimer");
  CountDownTimer.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(JJ)V");

  /// from: public void <init>(long millisInFuture, long countDownInterval)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param millisInFuture The number of millis in the future from the call
  ///   to \#start() until the countdown is done and \#onFinish()
  ///   is called.
  ///@param countDownInterval The interval along the way to receive
  ///   \#onTick(long) callbacks.
  CountDownTimer(int millisInFuture, int countDownInterval)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [millisInFuture, countDownInterval]).object);

  static final _id_cancel =
      jniAccessors.getMethodIDOf(_classRef, "cancel", "()V");

  /// from: synchronized public final void cancel()
  ///
  /// Cancel the countdown.
  void cancel() => jniAccessors.callMethodWithArgs(
      reference, _id_cancel, jni.JniType.voidType, []).check();

  static final _id_start = jniAccessors.getMethodIDOf(
      _classRef, "start", "()Landroid/os/CountDownTimer;");

  /// from: synchronized public final android.os.CountDownTimer start()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start the countdown.
  CountDownTimer start() =>
      CountDownTimer.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_start, jni.JniType.objectType, []).object);

  static final _id_onTick =
      jniAccessors.getMethodIDOf(_classRef, "onTick", "(J)V");

  /// from: public abstract void onTick(long millisUntilFinished)
  ///
  /// Callback fired on regular interval.
  ///@param millisUntilFinished The amount of time until finished.
  void onTick(int millisUntilFinished) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onTick,
      jni.JniType.voidType,
      [millisUntilFinished]).check();

  static final _id_onFinish =
      jniAccessors.getMethodIDOf(_classRef, "onFinish", "()V");

  /// from: public abstract void onFinish()
  ///
  /// Callback fired when the time is up.
  void onFinish() => jniAccessors.callMethodWithArgs(
      reference, _id_onFinish, jni.JniType.voidType, []).check();
}
