// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "WorkSource.dart" as worksource_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.PowerManager
///
/// This class gives you control of the power state of the device.
///
///
/// __Device battery life will be significantly affected by the use of this API.__
/// Do not acquire WakeLocks unless you really need them, use the minimum levels
/// possible, and be sure to release them as soon as possible.
///
///
/// The primary API you'll use is \#newWakeLock(int, String) newWakeLock().
/// This will create a PowerManager.WakeLock object.  You can then use methods
/// on the wake lock object to control the power state of the device.
///
///
/// In practice it's quite simple:
/// {@samplecode PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
/// PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK, "My Tag");
/// wl.acquire();
///   ..screen will stay on during this section..
/// wl.release();
/// }
///
///
/// The following wake lock levels are defined, with varying effects on system power.
/// <i>These levels are mutually exclusive - you may only specify one of them.</i>
///
/// <table>
///     <tr><th>Flag Value</th>
///     <th>CPU</th> <th>Screen</th> <th>Keyboard</th></tr>
///
///     <tr><td>\#PARTIAL_WAKE_LOCK</td>
///         <td>On*</td> <td>Off</td> <td>Off</td>
///     </tr>
///
///     <tr><td>\#SCREEN_DIM_WAKE_LOCK</td>
///         <td>On</td> <td>Dim</td> <td>Off</td>
///     </tr>
///
///     <tr><td>\#SCREEN_BRIGHT_WAKE_LOCK</td>
///         <td>On</td> <td>Bright</td> <td>Off</td>
///     </tr>
///
///     <tr><td>\#FULL_WAKE_LOCK</td>
///         <td>On</td> <td>Bright</td> <td>Bright</td>
///     </tr>
/// </table>
///
///
/// *<i>If you hold a partial wake lock, the CPU will continue to run, regardless of any
/// display timeouts or the state of the screen and even after the user presses the power button.
/// In all other wake locks, the CPU will run, but the user can still put the device to sleep
/// using the power button.</i>
///
///
/// In addition, you can add two more flags, which affect behavior of the screen only.
/// <i>These flags have no effect when combined with a \#PARTIAL_WAKE_LOCK.</i>
///
///
/// <table>
///     <tr><th>Flag Value</th> <th>Description</th></tr>
///
///     <tr><td>\#ACQUIRE_CAUSES_WAKEUP</td>
///         <td>Normal wake locks don't actually turn on the illumination.  Instead, they cause
///         the illumination to remain on once it turns on (e.g. from user activity).  This flag
///         will force the screen and/or keyboard to turn on immediately, when the WakeLock is
///         acquired.  A typical use would be for notifications which are important for the user to
///         see immediately.</td>
///     </tr>
///
///     <tr><td>\#ON_AFTER_RELEASE</td>
///         <td>If this flag is set, the user activity timer will be reset when the WakeLock is
///         released, causing the illumination to remain on a bit longer.  This can be used to
///         reduce flicker if you are cycling between wake lock conditions.</td>
///     </tr>
/// </table>
///
/// Any application using a WakeLock must request the {@code android.permission.WAKE_LOCK}
/// permission in an {@code <uses-permission>} element of the application's manifest.
///
///
class PowerManager extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/PowerManager");
  PowerManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ACQUIRE_CAUSES_WAKEUP
  ///
  /// Wake lock flag: Turn the screen on when the wake lock is acquired.
  ///
  /// Normally wake locks don't actually wake the device, they just cause
  /// the screen to remain on once it's already on.  Think of the video player
  /// application as the normal behavior.  Notifications that pop up and want
  /// the device to be on are the exception; use this flag to be like them.
  ///
  ///
  /// Cannot be used with \#PARTIAL_WAKE_LOCK.
  ///
  ///
  static const ACQUIRE_CAUSES_WAKEUP = 268435456;

  /// from: static public final java.lang.String ACTION_DEVICE_IDLE_MODE_CHANGED
  ///
  /// Intent that is broadcast when the state of \#isDeviceIdleMode() changes.
  /// This broadcast is only sent to registered receivers.
  static const ACTION_DEVICE_IDLE_MODE_CHANGED =
      "android.os.action.DEVICE_IDLE_MODE_CHANGED";

  /// from: static public final java.lang.String ACTION_POWER_SAVE_MODE_CHANGED
  ///
  /// Intent that is broadcast when the state of \#isPowerSaveMode() changes.
  /// This broadcast is only sent to registered receivers.
  static const ACTION_POWER_SAVE_MODE_CHANGED =
      "android.os.action.POWER_SAVE_MODE_CHANGED";

  /// from: static public final int FULL_WAKE_LOCK
  ///
  /// Wake lock level: Ensures that the screen and keyboard backlight are on at
  /// full brightness.
  ///
  /// If the user presses the power button, then the \#FULL_WAKE_LOCK will be
  /// implicitly released by the system, causing both the screen and the CPU to be turned off.
  /// Contrast with \#PARTIAL_WAKE_LOCK.
  ///
  ///
  ///@deprecated Most applications should use
  /// android.view.WindowManager.LayoutParams\#FLAG_KEEP_SCREEN_ON instead
  /// of this type of wake lock, as it will be correctly managed by the platform
  /// as the user moves between applications and doesn't require a special permission.
  static const FULL_WAKE_LOCK = 26;

  /// from: static public final int LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF
  ///
  /// All location providers should be disabled when battery saver is on and
  /// the device is non-interactive.
  static const LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF = 2;

  /// from: static public final int LOCATION_MODE_FOREGROUND_ONLY
  ///
  /// In this mode, all the location providers will be kept available, but location fixes
  /// should only be provided to foreground apps.
  static const LOCATION_MODE_FOREGROUND_ONLY = 3;

  /// from: static public final int LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF
  ///
  /// In this mode, the GPS based location provider should be disabled when battery saver is on and
  /// the device is non-interactive.
  static const LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF = 1;

  /// from: static public final int LOCATION_MODE_NO_CHANGE
  ///
  /// Either the location providers shouldn't be affected by battery saver,
  /// or battery saver is off.
  static const LOCATION_MODE_NO_CHANGE = 0;

  /// from: static public final int ON_AFTER_RELEASE
  ///
  /// Wake lock flag: When this wake lock is released, poke the user activity timer
  /// so the screen stays on for a little longer.
  ///
  /// Will not turn the screen on if it is not already on.
  /// See \#ACQUIRE_CAUSES_WAKEUP if you want that.
  ///
  ///
  /// Cannot be used with \#PARTIAL_WAKE_LOCK.
  ///
  ///
  static const ON_AFTER_RELEASE = 536870912;

  /// from: static public final int PARTIAL_WAKE_LOCK
  ///
  /// Wake lock level: Ensures that the CPU is running; the screen and keyboard
  /// backlight will be allowed to go off.
  ///
  /// If the user presses the power button, then the screen will be turned off
  /// but the CPU will be kept on until all partial wake locks have been released.
  ///
  ///
  static const PARTIAL_WAKE_LOCK = 1;

  /// from: static public final int PROXIMITY_SCREEN_OFF_WAKE_LOCK
  ///
  /// Wake lock level: Turns the screen off when the proximity sensor activates.
  ///
  /// If the proximity sensor detects that an object is nearby, the screen turns off
  /// immediately.  Shortly after the object moves away, the screen turns on again.
  ///
  ///
  /// A proximity wake lock does not prevent the device from falling asleep
  /// unlike \#FULL_WAKE_LOCK, \#SCREEN_BRIGHT_WAKE_LOCK and
  /// \#SCREEN_DIM_WAKE_LOCK.  If there is no user activity and no other
  /// wake locks are held, then the device will fall asleep (and lock) as usual.
  /// However, the device will not fall asleep while the screen has been turned off
  /// by the proximity sensor because it effectively counts as ongoing user activity.
  ///
  ///
  /// Since not all devices have proximity sensors, use \#isWakeLockLevelSupported
  /// to determine whether this wake lock level is supported.
  ///
  ///
  /// Cannot be used with \#ACQUIRE_CAUSES_WAKEUP.
  ///
  ///
  static const PROXIMITY_SCREEN_OFF_WAKE_LOCK = 32;

  /// from: static public final int RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY
  ///
  /// Flag for WakeLock\#release WakeLock.release(int): Defer releasing a
  /// \#PROXIMITY_SCREEN_OFF_WAKE_LOCK wake lock until the proximity sensor
  /// indicates that an object is not in close proximity.
  static const RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY = 1;

  /// from: static public final int SCREEN_BRIGHT_WAKE_LOCK
  ///
  /// Wake lock level: Ensures that the screen is on at full brightness;
  /// the keyboard backlight will be allowed to go off.
  ///
  /// If the user presses the power button, then the \#SCREEN_BRIGHT_WAKE_LOCK will be
  /// implicitly released by the system, causing both the screen and the CPU to be turned off.
  /// Contrast with \#PARTIAL_WAKE_LOCK.
  ///
  ///
  ///@deprecated Most applications should use
  /// android.view.WindowManager.LayoutParams\#FLAG_KEEP_SCREEN_ON instead
  /// of this type of wake lock, as it will be correctly managed by the platform
  /// as the user moves between applications and doesn't require a special permission.
  static const SCREEN_BRIGHT_WAKE_LOCK = 10;

  /// from: static public final int SCREEN_DIM_WAKE_LOCK
  ///
  /// Wake lock level: Ensures that the screen is on (but may be dimmed);
  /// the keyboard backlight will be allowed to go off.
  ///
  /// If the user presses the power button, then the \#SCREEN_DIM_WAKE_LOCK will be
  /// implicitly released by the system, causing both the screen and the CPU to be turned off.
  /// Contrast with \#PARTIAL_WAKE_LOCK.
  ///
  ///
  ///@deprecated Most applications should use
  /// android.view.WindowManager.LayoutParams\#FLAG_KEEP_SCREEN_ON instead
  /// of this type of wake lock, as it will be correctly managed by the platform
  /// as the user moves between applications and doesn't require a special permission.
  static const SCREEN_DIM_WAKE_LOCK = 6;

  static final _id_newWakeLock = jniAccessors.getMethodIDOf(
      _classRef,
      "newWakeLock",
      "(ILjava/lang/String;)Landroid/os/PowerManager\$WakeLock;");

  /// from: public android.os.PowerManager.WakeLock newWakeLock(int levelAndFlags, java.lang.String tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new wake lock with the specified level and flags.
  ///
  /// The {@code levelAndFlags} parameter specifies a wake lock level and optional flags
  /// combined using the logical OR operator.
  ///
  ///
  /// The wake lock levels are: \#PARTIAL_WAKE_LOCK,
  /// \#FULL_WAKE_LOCK, \#SCREEN_DIM_WAKE_LOCK
  /// and \#SCREEN_BRIGHT_WAKE_LOCK.  Exactly one wake lock level must be
  /// specified as part of the {@code levelAndFlags} parameter.
  ///
  ///
  /// The wake lock flags are: \#ACQUIRE_CAUSES_WAKEUP
  /// and \#ON_AFTER_RELEASE.  Multiple flags can be combined as part of the
  /// {@code levelAndFlags} parameters.
  ///
  ///
  /// Call WakeLock\#acquire() acquire() on the object to acquire the
  /// wake lock, and WakeLock\#release release() when you are done.
  ///
  ///
  /// {@samplecode PowerManager pm = (PowerManager)mContext.getSystemService(
  ///                                          Context.POWER_SERVICE);
  /// PowerManager.WakeLock wl = pm.newWakeLock(
  ///                                      PowerManager.SCREEN_DIM_WAKE_LOCK
  ///                                      | PowerManager.ON_AFTER_RELEASE,
  ///                                      TAG);
  /// wl.acquire();
  /// // ... do work...
  /// wl.release();
  /// }
  ///
  ///
  /// Although a wake lock can be created without special permissions,
  /// the android.Manifest.permission\#WAKE_LOCK permission is
  /// required to actually acquire or release the wake lock that is returned.
  ///
  ///<p class="note">
  /// If using this to keep the screen on, you should strongly consider using
  /// android.view.WindowManager.LayoutParams\#FLAG_KEEP_SCREEN_ON instead.
  /// This window flag will be correctly managed by the platform
  /// as the user moves between applications and doesn't require a special permission.
  ///
  ///
  ///
  ///
  /// Recommended naming conventions for tags to make debugging easier:
  /// <ul>
  /// <li>use a unique prefix delimited by a colon for your app/library (e.g.
  /// gmail:mytag) to make it easier to understand where the wake locks comes
  /// from. This namespace will also avoid collision for tags inside your app
  /// coming from different libraries which will make debugging easier.
  /// <li>use constants (e.g. do not include timestamps in the tag) to make it
  /// easier for tools to aggregate similar wake locks. When collecting
  /// debugging data, the platform only monitors a finite number of tags,
  /// using constants will help tools to provide better debugging data.
  /// <li>avoid using Class\#getName() or similar method since this class name
  /// can be transformed by java optimizer and obfuscator tools.
  /// <li>avoid wrapping the tag or a prefix to avoid collision with wake lock
  /// tags from the platform (e.g. *alarm*).
  /// <li>never include personnally identifiable information for privacy
  /// reasons.
  /// </ul>
  ///
  ///
  ///@param levelAndFlags Combination of wake lock level and flag values defining
  /// the requested behavior of the WakeLock.
  ///@param tag Your class name (or other tag) for debugging purposes.
  ///@see WakeLock\#acquire()
  ///@see WakeLock\#release()
  ///@see \#PARTIAL_WAKE_LOCK
  ///@see \#FULL_WAKE_LOCK
  ///@see \#SCREEN_DIM_WAKE_LOCK
  ///@see \#SCREEN_BRIGHT_WAKE_LOCK
  ///@see \#PROXIMITY_SCREEN_OFF_WAKE_LOCK
  ///@see \#ACQUIRE_CAUSES_WAKEUP
  ///@see \#ON_AFTER_RELEASE
  PowerManager_WakeLock newWakeLock(int levelAndFlags, jni.JniString tag) =>
      PowerManager_WakeLock.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_newWakeLock,
          jni.JniType.objectType,
          [levelAndFlags, tag.reference]).object);

  static final _id_isWakeLockLevelSupported =
      jniAccessors.getMethodIDOf(_classRef, "isWakeLockLevelSupported", "(I)Z");

  /// from: public boolean isWakeLockLevelSupported(int level)
  ///
  /// Returns true if the specified wake lock level is supported.
  ///@param level The wake lock level to check.
  ///@return True if the specified wake lock level is supported.
  bool isWakeLockLevelSupported(int level) => jniAccessors.callMethodWithArgs(
      reference,
      _id_isWakeLockLevelSupported,
      jni.JniType.booleanType,
      [level]).boolean;

  static final _id_isScreenOn =
      jniAccessors.getMethodIDOf(_classRef, "isScreenOn", "()Z");

  /// from: public boolean isScreenOn()
  ///
  /// Returns true if the device is in an interactive state.
  ///
  /// For historical reasons, the name of this method refers to the power state of
  /// the screen but it actually describes the overall interactive state of
  /// the device.  This method has been replaced by \#isInteractive.
  ///
  ///
  /// The value returned by this method only indicates whether the device is
  /// in an interactive state which may have nothing to do with the screen being
  /// on or off.  To determine the actual state of the screen,
  /// use android.view.Display\#getState.
  ///
  ///
  ///@return True if the device is in an interactive state.
  ///@deprecated Use \#isInteractive instead.
  bool isScreenOn() => jniAccessors.callMethodWithArgs(
      reference, _id_isScreenOn, jni.JniType.booleanType, []).boolean;

  static final _id_isInteractive =
      jniAccessors.getMethodIDOf(_classRef, "isInteractive", "()Z");

  /// from: public boolean isInteractive()
  ///
  /// Returns true if the device is in an interactive state.
  ///
  /// When this method returns true, the device is awake and ready to interact
  /// with the user (although this is not a guarantee that the user is actively
  /// interacting with the device just this moment).  The main screen is usually
  /// turned on while in this state.  Certain features, such as the proximity
  /// sensor, may temporarily turn off the screen while still leaving the device in an
  /// interactive state.  Note in particular that the device is still considered
  /// to be interactive while dreaming (since dreams can be interactive) but not
  /// when it is dozing or asleep.
  ///
  ///
  /// When this method returns false, the device is dozing or asleep and must
  /// be awoken before it will become ready to interact with the user again.  The
  /// main screen is usually turned off while in this state.  Certain features,
  /// such as "ambient mode" may cause the main screen to remain on (albeit in a
  /// low power state) to display system-provided content while the device dozes.
  ///
  ///
  /// The system will send a android.content.Intent\#ACTION_SCREEN_ON screen on
  /// or android.content.Intent\#ACTION_SCREEN_OFF screen off broadcast
  /// whenever the interactive state of the device changes.  For historical reasons,
  /// the names of these broadcasts refer to the power state of the screen
  /// but they are actually sent in response to changes in the overall interactive
  /// state of the device, as described by this method.
  ///
  ///
  /// Services may use the non-interactive state as a hint to conserve power
  /// since the user is not present.
  ///
  ///
  ///@return True if the device is in an interactive state.
  ///@see android.content.Intent\#ACTION_SCREEN_ON
  ///@see android.content.Intent\#ACTION_SCREEN_OFF
  bool isInteractive() => jniAccessors.callMethodWithArgs(
      reference, _id_isInteractive, jni.JniType.booleanType, []).boolean;

  static final _id_reboot =
      jniAccessors.getMethodIDOf(_classRef, "reboot", "(Ljava/lang/String;)V");

  /// from: public void reboot(java.lang.String reason)
  ///
  /// Reboot the device.  Will not return if the reboot is successful.
  ///
  /// Requires the android.Manifest.permission\#REBOOT permission.
  ///
  ///
  ///@param reason code to pass to the kernel (e.g., "recovery") to
  ///               request special boot modes, or null.
  void reboot(jni.JniString reason) => jniAccessors.callMethodWithArgs(
      reference, _id_reboot, jni.JniType.voidType, [reason.reference]).check();

  static final _id_isPowerSaveMode =
      jniAccessors.getMethodIDOf(_classRef, "isPowerSaveMode", "()Z");

  /// from: public boolean isPowerSaveMode()
  ///
  /// Returns true if the device is currently in power save mode.  When in this mode,
  /// applications should reduce their functionality in order to conserve battery as
  /// much as possible.  You can monitor for changes to this state with
  /// \#ACTION_POWER_SAVE_MODE_CHANGED.
  ///@return Returns true if currently in low power mode, else false.
  bool isPowerSaveMode() => jniAccessors.callMethodWithArgs(
      reference, _id_isPowerSaveMode, jni.JniType.booleanType, []).boolean;

  static final _id_getLocationPowerSaveMode =
      jniAccessors.getMethodIDOf(_classRef, "getLocationPowerSaveMode", "()I");

  /// from: public int getLocationPowerSaveMode()
  ///
  /// Returns how location features should behave when battery saver is on. When battery saver
  /// is off, this will always return \#LOCATION_MODE_NO_CHANGE.
  ///
  /// This API is normally only useful for components that provide location features.
  ///@see \#isPowerSaveMode()
  ///@see \#ACTION_POWER_SAVE_MODE_CHANGED
  ///@return Value is android.os.PowerManager\#LOCATION_MODE_NO_CHANGE, android.os.PowerManager\#LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF, android.os.PowerManager\#LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF, or android.os.PowerManager\#LOCATION_MODE_FOREGROUND_ONLY
  int getLocationPowerSaveMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getLocationPowerSaveMode, jni.JniType.intType, []).integer;

  static final _id_isDeviceIdleMode =
      jniAccessors.getMethodIDOf(_classRef, "isDeviceIdleMode", "()Z");

  /// from: public boolean isDeviceIdleMode()
  ///
  /// Returns true if the device is currently in idle mode.  This happens when a device
  /// has been sitting unused and unmoving for a sufficiently long period of time, so that
  /// it decides to go into a lower power-use state.  This may involve things like turning
  /// off network access to apps.  You can monitor for changes to this state with
  /// \#ACTION_DEVICE_IDLE_MODE_CHANGED.
  ///@return Returns true if currently in active device idle mode, else false.  This is
  /// when idle mode restrictions are being actively applied; it will return false if the
  /// device is in a long-term idle mode but currently running a maintenance window where
  /// restrictions have been lifted.
  bool isDeviceIdleMode() => jniAccessors.callMethodWithArgs(
      reference, _id_isDeviceIdleMode, jni.JniType.booleanType, []).boolean;

  static final _id_isIgnoringBatteryOptimizations = jniAccessors.getMethodIDOf(
      _classRef, "isIgnoringBatteryOptimizations", "(Ljava/lang/String;)Z");

  /// from: public boolean isIgnoringBatteryOptimizations(java.lang.String packageName)
  ///
  /// Return whether the given application package name is on the device's power whitelist.
  /// Apps can be placed on the whitelist through the settings UI invoked by
  /// android.provider.Settings\#ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS.
  bool isIgnoringBatteryOptimizations(jni.JniString packageName) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isIgnoringBatteryOptimizations,
          jni.JniType.booleanType,
          [packageName.reference]).boolean;

  static final _id_isSustainedPerformanceModeSupported = jniAccessors
      .getMethodIDOf(_classRef, "isSustainedPerformanceModeSupported", "()Z");

  /// from: public boolean isSustainedPerformanceModeSupported()
  ///
  /// This function checks if the device has implemented Sustained Performance
  /// Mode. This needs to be checked only once and is constant for a particular
  /// device/release.
  ///
  /// Sustained Performance Mode is intended to provide a consistent level of
  /// performance for prolonged amount of time.
  ///
  /// Applications should check if the device supports this mode, before using
  /// android.view.Window\#setSustainedPerformanceMode.
  ///@return Returns True if the device supports it, false otherwise.
  ///@see android.view.Window\#setSustainedPerformanceMode
  bool isSustainedPerformanceModeSupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isSustainedPerformanceModeSupported,
      jni.JniType.booleanType, []).boolean;
}

/// from: android.os.PowerManager$WakeLock
///
/// A wake lock is a mechanism to indicate that your application needs
/// to have the device stay on.
///
/// Any application using a WakeLock must request the {@code android.permission.WAKE_LOCK}
/// permission in an {@code <uses-permission>} element of the application's manifest.
/// Obtain a wake lock by calling PowerManager\#newWakeLock(int, String).
///
///
/// Call \#acquire() to acquire the wake lock and force the device to stay
/// on at the level that was requested when the wake lock was created.
///
///
/// Call \#release() when you are done and don't need the lock anymore.
/// It is very important to do this as soon as possible to avoid running down the
/// device's battery excessively.
///
///
class PowerManager_WakeLock extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/os/PowerManager\$WakeLock");
  PowerManager_WakeLock.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_setReferenceCounted =
      jniAccessors.getMethodIDOf(_classRef, "setReferenceCounted", "(Z)V");

  /// from: public void setReferenceCounted(boolean value)
  ///
  /// Sets whether this WakeLock is reference counted.
  ///
  /// Wake locks are reference counted by default.  If a wake lock is
  /// reference counted, then each call to \#acquire() must be
  /// balanced by an equal number of calls to \#release().  If a wake
  /// lock is not reference counted, then one call to \#release() is
  /// sufficient to undo the effect of all previous calls to \#acquire().
  ///
  ///
  ///@param value True to make the wake lock reference counted, false to
  /// make the wake lock non-reference counted.
  void setReferenceCounted(bool value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setReferenceCounted,
      jni.JniType.voidType,
      [value]).check();

  static final _id_acquire =
      jniAccessors.getMethodIDOf(_classRef, "acquire", "()V");

  /// from: public void acquire()
  ///
  /// Acquires the wake lock.
  ///
  /// Ensures that the device is on at the level requested when
  /// the wake lock was created.
  ///
  ///
  void acquire() => jniAccessors.callMethodWithArgs(
      reference, _id_acquire, jni.JniType.voidType, []).check();

  static final _id_acquire1 =
      jniAccessors.getMethodIDOf(_classRef, "acquire", "(J)V");

  /// from: public void acquire(long timeout)
  ///
  /// Acquires the wake lock with a timeout.
  ///
  /// Ensures that the device is on at the level requested when
  /// the wake lock was created.  The lock will be released after the given timeout
  /// expires.
  ///
  ///
  ///@param timeout The timeout after which to release the wake lock, in milliseconds.
  void acquire1(int timeout) => jniAccessors.callMethodWithArgs(
      reference, _id_acquire1, jni.JniType.voidType, [timeout]).check();

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public void release()
  ///
  /// Releases the wake lock.
  ///
  /// This method releases your claim to the CPU or screen being on.
  /// The screen may turn off shortly after you release the wake lock, or it may
  /// not if there are other wake locks still held.
  ///
  ///
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_release1 =
      jniAccessors.getMethodIDOf(_classRef, "release", "(I)V");

  /// from: public void release(int flags)
  ///
  /// Releases the wake lock with flags to modify the release behavior.
  ///
  /// This method releases your claim to the CPU or screen being on.
  /// The screen may turn off shortly after you release the wake lock, or it may
  /// not if there are other wake locks still held.
  ///
  ///
  ///@param flags Combination of flag values to modify the release behavior.
  /// Currently only \#RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY is supported.
  /// Passing 0 is equivalent to calling \#release().
  void release1(int flags) => jniAccessors.callMethodWithArgs(
      reference, _id_release1, jni.JniType.voidType, [flags]).check();

  static final _id_isHeld =
      jniAccessors.getMethodIDOf(_classRef, "isHeld", "()Z");

  /// from: public boolean isHeld()
  ///
  /// Returns true if the wake lock has been acquired but not yet released.
  ///@return True if the wake lock is held.
  bool isHeld() => jniAccessors.callMethodWithArgs(
      reference, _id_isHeld, jni.JniType.booleanType, []).boolean;

  static final _id_setWorkSource = jniAccessors.getMethodIDOf(
      _classRef, "setWorkSource", "(Landroid/os/WorkSource;)V");

  /// from: public void setWorkSource(android.os.WorkSource ws)
  ///
  /// Sets the work source associated with the wake lock.
  ///
  /// The work source is used to determine on behalf of which application
  /// the wake lock is being held.  This is useful in the case where a
  /// service is performing work on behalf of an application so that the
  /// cost of that work can be accounted to the application.
  ///
  ///
  ///
  ///
  /// Make sure to follow the tag naming convention when using WorkSource
  /// to make it easier for app developers to understand wake locks
  /// attributed to them. See PowerManager\#newWakeLock(int, String)
  /// documentation.
  ///
  ///
  ///@param ws The work source, or null if none.
  void setWorkSource(worksource_.WorkSource ws) =>
      jniAccessors.callMethodWithArgs(reference, _id_setWorkSource,
          jni.JniType.voidType, [ws.reference]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
