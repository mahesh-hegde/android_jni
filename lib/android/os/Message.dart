// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Parcelable.dart" as parcelable_;

import "Messenger.dart" as messenger_;

import "Handler.dart" as handler_;

import "Bundle.dart" as bundle_;

import "Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.Message
///
/// Defines a message containing a description and arbitrary data object that can be
/// sent to a Handler.  This object contains two extra int fields and an
/// extra object field that allow you to not do allocations in many cases.
///
/// <p class="note">While the constructor of Message is public, the best way to get
/// one of these is to call \#obtain Message.obtain() or one of the
/// Handler\#obtainMessage Handler.obtainMessage() methods, which will pull
/// them from a pool of recycled objects.
///
class Message extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/Message");
  Message.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.os.Message> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_arg1 = jniAccessors.getFieldIDOf(_classRef, "arg1", "I");

  /// from: public int arg1
  ///
  /// arg1 and arg2 are lower-cost alternatives to using
  /// \#setData(Bundle) setData() if you only need to store a
  /// few integer values.
  int get arg1 =>
      jniAccessors.getField(reference, _id_arg1, jni.JniType.intType).integer;

  /// from: public int arg1
  ///
  /// arg1 and arg2 are lower-cost alternatives to using
  /// \#setData(Bundle) setData() if you only need to store a
  /// few integer values.
  set arg1(int value) => jniEnv.SetIntField(reference, _id_arg1, value);

  static final _id_arg2 = jniAccessors.getFieldIDOf(_classRef, "arg2", "I");

  /// from: public int arg2
  ///
  /// arg1 and arg2 are lower-cost alternatives to using
  /// \#setData(Bundle) setData() if you only need to store a
  /// few integer values.
  int get arg2 =>
      jniAccessors.getField(reference, _id_arg2, jni.JniType.intType).integer;

  /// from: public int arg2
  ///
  /// arg1 and arg2 are lower-cost alternatives to using
  /// \#setData(Bundle) setData() if you only need to store a
  /// few integer values.
  set arg2(int value) => jniEnv.SetIntField(reference, _id_arg2, value);

  static final _id_obj =
      jniAccessors.getFieldIDOf(_classRef, "obj", "Ljava/lang/Object;");

  /// from: public java.lang.Object obj
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// An arbitrary object to send to the recipient.  When using
  /// Messenger to send the message across processes this can only
  /// be non-null if it contains a Parcelable of a framework class (not one
  /// implemented by the application).   For other data transfer use
  /// \#setData.
  ///
  /// Note that Parcelable objects here are not supported prior to
  /// the android.os.Build.VERSION_CODES\#FROYO release.
  jni.JniObject get obj => jni.JniObject.fromRef(
      jniAccessors.getField(reference, _id_obj, jni.JniType.objectType).object);

  /// from: public java.lang.Object obj
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// An arbitrary object to send to the recipient.  When using
  /// Messenger to send the message across processes this can only
  /// be non-null if it contains a Parcelable of a framework class (not one
  /// implemented by the application).   For other data transfer use
  /// \#setData.
  ///
  /// Note that Parcelable objects here are not supported prior to
  /// the android.os.Build.VERSION_CODES\#FROYO release.
  set obj(jni.JniObject value) =>
      jniEnv.SetObjectField(reference, _id_obj, value.reference);

  static final _id_replyTo =
      jniAccessors.getFieldIDOf(_classRef, "replyTo", "Landroid/os/Messenger;");

  /// from: public android.os.Messenger replyTo
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Optional Messenger where replies to this message can be sent.  The
  /// semantics of exactly how this is used are up to the sender and
  /// receiver.
  messenger_.Messenger get replyTo => messenger_.Messenger.fromRef(jniAccessors
      .getField(reference, _id_replyTo, jni.JniType.objectType)
      .object);

  /// from: public android.os.Messenger replyTo
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Optional Messenger where replies to this message can be sent.  The
  /// semantics of exactly how this is used are up to the sender and
  /// receiver.
  set replyTo(messenger_.Messenger value) =>
      jniEnv.SetObjectField(reference, _id_replyTo, value.reference);

  static final _id_sendingUid =
      jniAccessors.getFieldIDOf(_classRef, "sendingUid", "I");

  /// from: public int sendingUid
  ///
  /// Optional field indicating the uid that sent the message.  This is
  /// only valid for messages posted by a Messenger; otherwise,
  /// it will be -1.
  int get sendingUid => jniAccessors
      .getField(reference, _id_sendingUid, jni.JniType.intType)
      .integer;

  /// from: public int sendingUid
  ///
  /// Optional field indicating the uid that sent the message.  This is
  /// only valid for messages posted by a Messenger; otherwise,
  /// it will be -1.
  set sendingUid(int value) =>
      jniEnv.SetIntField(reference, _id_sendingUid, value);

  static final _id_what = jniAccessors.getFieldIDOf(_classRef, "what", "I");

  /// from: public int what
  ///
  /// User-defined message code so that the recipient can identify
  /// what this message is about. Each Handler has its own name-space
  /// for message codes, so you do not need to worry about yours conflicting
  /// with other handlers.
  int get what =>
      jniAccessors.getField(reference, _id_what, jni.JniType.intType).integer;

  /// from: public int what
  ///
  /// User-defined message code so that the recipient can identify
  /// what this message is about. Each Handler has its own name-space
  /// for message codes, so you do not need to worry about yours conflicting
  /// with other handlers.
  set what(int value) => jniEnv.SetIntField(reference, _id_what, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor (but the preferred way to get a Message is to call \#obtain() Message.obtain()).
  Message()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_obtain = jniAccessors.getStaticMethodIDOf(
      _classRef, "obtain", "()Landroid/os/Message;");

  /// from: static public android.os.Message obtain()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new Message instance from the global pool. Allows us to
  /// avoid allocating new objects in many cases.
  static Message obtain() =>
      Message.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_obtain, jni.JniType.objectType, []).object);

  static final _id_obtain1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "obtain", "(Landroid/os/Message;)Landroid/os/Message;");

  /// from: static public android.os.Message obtain(android.os.Message orig)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Same as \#obtain(), but copies the values of an existing
  /// message (including its target) into the new one.
  ///@param orig Original message to copy.
  ///@return A Message object from the global pool.
  static Message obtain1(Message orig) =>
      Message.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_obtain1, jni.JniType.objectType, [orig.reference]).object);

  static final _id_obtain2 = jniAccessors.getStaticMethodIDOf(
      _classRef, "obtain", "(Landroid/os/Handler;)Landroid/os/Message;");

  /// from: static public android.os.Message obtain(android.os.Handler h)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Same as \#obtain(), but sets the value for the _target_ member on the Message returned.
  ///@param h Handler to assign to the returned Message object's _target_ member.
  ///@return A Message object from the global pool.
  static Message obtain2(handler_.Handler h) =>
      Message.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_obtain2, jni.JniType.objectType, [h.reference]).object);

  static final _id_obtain3 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "obtain",
      "(Landroid/os/Handler;Ljava/lang/Runnable;)Landroid/os/Message;");

  /// from: static public android.os.Message obtain(android.os.Handler h, java.lang.Runnable callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Same as \#obtain(Handler), but assigns a callback Runnable on
  /// the Message that is returned.
  ///@param h Handler to assign to the returned Message object's _target_ member.
  ///@param callback Runnable that will execute when the message is handled.
  ///@return A Message object from the global pool.
  static Message obtain3(handler_.Handler h, jni.JniObject callback) =>
      Message.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_obtain3,
          jni.JniType.objectType,
          [h.reference, callback.reference]).object);

  static final _id_obtain4 = jniAccessors.getStaticMethodIDOf(
      _classRef, "obtain", "(Landroid/os/Handler;I)Landroid/os/Message;");

  /// from: static public android.os.Message obtain(android.os.Handler h, int what)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Same as \#obtain(), but sets the values for both _target_ and
  /// _what_ members on the Message.
  ///@param h Value to assign to the _target_ member.
  ///@param what Value to assign to the _what_ member.
  ///@return A Message object from the global pool.
  static Message obtain4(handler_.Handler h, int what) =>
      Message.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_obtain4, jni.JniType.objectType, [h.reference, what]).object);

  static final _id_obtain5 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "obtain",
      "(Landroid/os/Handler;ILjava/lang/Object;)Landroid/os/Message;");

  /// from: static public android.os.Message obtain(android.os.Handler h, int what, java.lang.Object obj)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Same as \#obtain(), but sets the values of the _target_, _what_, and _obj_
  /// members.
  ///@param h The _target_ value to set.
  ///@param what The _what_ value to set.
  ///@param obj The _object_ method to set.
  ///@return A Message object from the global pool.
  static Message obtain5(handler_.Handler h, int what, jni.JniObject obj) =>
      Message.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_obtain5,
          jni.JniType.objectType,
          [h.reference, what, obj.reference]).object);

  static final _id_obtain6 = jniAccessors.getStaticMethodIDOf(
      _classRef, "obtain", "(Landroid/os/Handler;III)Landroid/os/Message;");

  /// from: static public android.os.Message obtain(android.os.Handler h, int what, int arg1, int arg2)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Same as \#obtain(), but sets the values of the _target_, _what_,
  /// _arg1_, and _arg2_ members.
  ///@param h The _target_ value to set.
  ///@param what The _what_ value to set.
  ///@param arg1 The _arg1_ value to set.
  ///@param arg2 The _arg2_ value to set.
  ///@return A Message object from the global pool.
  static Message obtain6(handler_.Handler h, int what, int arg1, int arg2) =>
      Message.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_obtain6,
          jni.JniType.objectType,
          [h.reference, what, arg1, arg2]).object);

  static final _id_obtain7 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "obtain",
      "(Landroid/os/Handler;IIILjava/lang/Object;)Landroid/os/Message;");

  /// from: static public android.os.Message obtain(android.os.Handler h, int what, int arg1, int arg2, java.lang.Object obj)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Same as \#obtain(), but sets the values of the _target_, _what_,
  /// _arg1_, _arg2_, and _obj_ members.
  ///@param h The _target_ value to set.
  ///@param what The _what_ value to set.
  ///@param arg1 The _arg1_ value to set.
  ///@param arg2 The _arg2_ value to set.
  ///@param obj The _obj_ value to set.
  ///@return A Message object from the global pool.
  static Message obtain7(handler_.Handler h, int what, int arg1, int arg2,
          jni.JniObject obj) =>
      Message.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_obtain7,
          jni.JniType.objectType,
          [h.reference, what, arg1, arg2, obj.reference]).object);

  static final _id_recycle =
      jniAccessors.getMethodIDOf(_classRef, "recycle", "()V");

  /// from: public void recycle()
  ///
  /// Return a Message instance to the global pool.
  ///
  /// You MUST NOT touch the Message after calling this function because it has
  /// effectively been freed.  It is an error to recycle a message that is currently
  /// enqueued or that is in the process of being delivered to a Handler.
  ///
  ///
  void recycle() => jniAccessors.callMethodWithArgs(
      reference, _id_recycle, jni.JniType.voidType, []).check();

  static final _id_copyFrom = jniAccessors.getMethodIDOf(
      _classRef, "copyFrom", "(Landroid/os/Message;)V");

  /// from: public void copyFrom(android.os.Message o)
  ///
  /// Make this message like o.  Performs a shallow copy of the data field.
  /// Does not copy the linked list fields, nor the timestamp or
  /// target/callback of the original message.
  void copyFrom(Message o) => jniAccessors.callMethodWithArgs(
      reference, _id_copyFrom, jni.JniType.voidType, [o.reference]).check();

  static final _id_getWhen =
      jniAccessors.getMethodIDOf(_classRef, "getWhen", "()J");

  /// from: public long getWhen()
  ///
  /// Return the targeted delivery time of this message, in milliseconds.
  int getWhen() => jniAccessors.callMethodWithArgs(
      reference, _id_getWhen, jni.JniType.longType, []).long;

  static final _id_setTarget = jniAccessors.getMethodIDOf(
      _classRef, "setTarget", "(Landroid/os/Handler;)V");

  /// from: public void setTarget(android.os.Handler target)
  void setTarget(handler_.Handler target) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTarget,
      jni.JniType.voidType,
      [target.reference]).check();

  static final _id_getTarget = jniAccessors.getMethodIDOf(
      _classRef, "getTarget", "()Landroid/os/Handler;");

  /// from: public android.os.Handler getTarget()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the a android.os.Handler Handler implementation that
  /// will receive this message. The object must implement
  /// android.os.Handler\#handleMessage(android.os.Message) Handler.handleMessage(). Each Handler has its own name-space for
  /// message codes, so you do not need to
  /// worry about yours conflicting with other handlers.
  handler_.Handler getTarget() =>
      handler_.Handler.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTarget, jni.JniType.objectType, []).object);

  static final _id_getCallback = jniAccessors.getMethodIDOf(
      _classRef, "getCallback", "()Ljava/lang/Runnable;");

  /// from: public java.lang.Runnable getCallback()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve callback object that will execute when this message is handled.
  /// This object must implement Runnable. This is called by
  /// the _target_ Handler that is receiving this Message to
  /// dispatch it.  If
  /// not set, the message will be dispatched to the receiving Handler's
  /// Handler\#handleMessage(Message Handler.handleMessage()).
  jni.JniObject getCallback() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCallback, jni.JniType.objectType, []).object);

  static final _id_getData =
      jniAccessors.getMethodIDOf(_classRef, "getData", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains a Bundle of arbitrary data associated with this
  /// event, lazily creating it if necessary. Set this value by calling
  /// \#setData(Bundle).  Note that when transferring data across
  /// processes via Messenger, you will need to set your ClassLoader
  /// on the Bundle via Bundle\#setClassLoader(ClassLoader) Bundle.setClassLoader() so that it can instantiate your objects when
  /// you retrieve them.
  ///@see \#peekData()
  ///@see \#setData(Bundle)
  bundle_.Bundle getData() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getData, jni.JniType.objectType, []).object);

  static final _id_peekData = jniAccessors.getMethodIDOf(
      _classRef, "peekData", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle peekData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like getData(), but does not lazily create the Bundle.  A null
  /// is returned if the Bundle does not already exist.  See
  /// \#getData for further information on this.
  ///@see \#getData()
  ///@see \#setData(Bundle)
  bundle_.Bundle peekData() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_peekData, jni.JniType.objectType, []).object);

  static final _id_setData = jniAccessors.getMethodIDOf(
      _classRef, "setData", "(Landroid/os/Bundle;)V");

  /// from: public void setData(android.os.Bundle data)
  ///
  /// Sets a Bundle of arbitrary data values. Use arg1 and arg2 members
  /// as a lower cost way to send a few simple integer values, if you can.
  ///@see \#getData()
  ///@see \#peekData()
  void setData(bundle_.Bundle data) => jniAccessors.callMethodWithArgs(
      reference, _id_setData, jni.JniType.voidType, [data.reference]).check();

  static final _id_sendToTarget =
      jniAccessors.getMethodIDOf(_classRef, "sendToTarget", "()V");

  /// from: public void sendToTarget()
  ///
  /// Sends this Message to the Handler specified by \#getTarget.
  /// Throws a null pointer exception if this field has not been set.
  void sendToTarget() => jniAccessors.callMethodWithArgs(
      reference, _id_sendToTarget, jni.JniType.voidType, []).check();

  static final _id_isAsynchronous =
      jniAccessors.getMethodIDOf(_classRef, "isAsynchronous", "()Z");

  /// from: public boolean isAsynchronous()
  ///
  /// Returns true if the message is asynchronous, meaning that it is not
  /// subject to Looper synchronization barriers.
  ///@return True if the message is asynchronous.
  ///@see \#setAsynchronous(boolean)
  bool isAsynchronous() => jniAccessors.callMethodWithArgs(
      reference, _id_isAsynchronous, jni.JniType.booleanType, []).boolean;

  static final _id_setAsynchronous =
      jniAccessors.getMethodIDOf(_classRef, "setAsynchronous", "(Z)V");

  /// from: public void setAsynchronous(boolean async)
  ///
  /// Sets whether the message is asynchronous, meaning that it is not
  /// subject to Looper synchronization barriers.
  ///
  /// Certain operations, such as view invalidation, may introduce synchronization
  /// barriers into the Looper's message queue to prevent subsequent messages
  /// from being delivered until some condition is met.  In the case of view invalidation,
  /// messages which are posted after a call to android.view.View\#invalidate
  /// are suspended by means of a synchronization barrier until the next frame is
  /// ready to be drawn.  The synchronization barrier ensures that the invalidation
  /// request is completely handled before resuming.
  ///
  ///
  /// Asynchronous messages are exempt from synchronization barriers.  They typically
  /// represent interrupts, input events, and other signals that must be handled independently
  /// even while other work has been suspended.
  ///
  ///
  /// Note that asynchronous messages may be delivered out of order with respect to
  /// synchronous messages although they are always delivered in order among themselves.
  /// If the relative order of these messages matters then they probably should not be
  /// asynchronous in the first place.  Use with caution.
  ///
  ///
  ///@param async True if the message is asynchronous.
  ///@see \#isAsynchronous()
  void setAsynchronous(bool async0) => jniAccessors.callMethodWithArgs(
      reference, _id_setAsynchronous, jni.JniType.voidType, [async0]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}
