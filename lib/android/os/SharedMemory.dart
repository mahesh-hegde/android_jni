// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Parcelable.dart" as parcelable_;

import "Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.SharedMemory
///
/// SharedMemory enables the creation, mapping, and protection control over anonymous shared memory.
class SharedMemory extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/SharedMemory");
  SharedMemory.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.os.SharedMemory> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/io/FileDescriptor;)V");

  /// from: void <init>(java.io.FileDescriptor fd)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SharedMemory(jni.JniObject fd)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [fd.reference]).object);

  static final _id_create = jniAccessors.getStaticMethodIDOf(
      _classRef, "create", "(Ljava/lang/String;I)Landroid/os/SharedMemory;");

  /// from: static public android.os.SharedMemory create(java.lang.String name, int size)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an anonymous SharedMemory instance with the provided debug name and size. The name
  /// is only used for debugging purposes and can help identify what the shared memory is used
  /// for when inspecting memory maps for the processes that have mapped this SharedMemory
  /// instance.
  ///@param name The debug name to use for this SharedMemory instance. This can be null, however
  ///             a debug name is recommended to help identify memory usage when using tools
  ///             such as lsof or examining /proc/[pid]/maps
  /// This value may be {@code null}.
  ///@param size The size of the shared memory to create. Must be greater than 0.
  ///@return A SharedMemory instance of the requested size
  ///@throws ErrnoException if the requested allocation fails.
  static SharedMemory create(jni.JniString name, int size) =>
      SharedMemory.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_create, jni.JniType.objectType, [name.reference, size]).object);

  static final _id_setProtect =
      jniAccessors.getMethodIDOf(_classRef, "setProtect", "(I)Z");

  /// from: public boolean setProtect(int prot)
  ///
  /// Sets the protection on the shared memory to the combination specified in prot, which
  /// is either a bitwise-or'd combination of android.system.OsConstants\#PROT_READ,
  /// android.system.OsConstants\#PROT_WRITE, android.system.OsConstants\#PROT_EXEC
  /// from android.system.OsConstants, or android.system.OsConstants\#PROT_NONE,
  /// to remove all further access.
  ///
  /// Note that protection can only ever be removed, not added. By default shared memory
  /// is created with protection set to PROT_READ | PROT_WRITE | PROT_EXEC. The protection
  /// passed here also only applies to any mappings created after calling this method. Existing
  /// mmaps of the shared memory retain whatever protection they had when they were created.
  ///
  /// A common usage of this is to share a read-only copy of the data with something else. To do
  /// that first create the read/write mapping with PROT_READ | PROT_WRITE,
  /// then call setProtect(PROT_READ) to remove write capability, then send the SharedMemory
  /// to another process. That process will only be able to mmap with PROT_READ.
  ///@param prot Any bitwise-or'ed combination of
  ///                  android.system.OsConstants\#PROT_READ,
  ///                  android.system.OsConstants\#PROT_WRITE, and
  ///                  android.system.OsConstants\#PROT_EXEC; or
  ///                  android.system.OsConstants\#PROT_NONE
  ///@return Whether or not the requested protection was applied. Returns true on success,
  /// false if the requested protection was broader than the existing protection.
  bool setProtect(int prot) => jniAccessors.callMethodWithArgs(
      reference, _id_setProtect, jni.JniType.booleanType, [prot]).boolean;

  static final _id_getSize =
      jniAccessors.getMethodIDOf(_classRef, "getSize", "()I");

  /// from: public int getSize()
  ///
  /// @return The size of the SharedMemory region.
  int getSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getSize, jni.JniType.intType, []).integer;

  static final _id_mapReadWrite = jniAccessors.getMethodIDOf(
      _classRef, "mapReadWrite", "()Ljava/nio/ByteBuffer;");

  /// from: public java.nio.ByteBuffer mapReadWrite()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a read/write mapping of the entire shared memory region. This requires the the
  /// protection level of the shared memory is at least PROT_READ|PROT_WRITE or the map will fail.
  ///
  /// Use \#map(int, int, int) to have more control over the mapping if desired.
  /// This is equivalent to map(OsConstants.PROT_READ | OsConstants.PROT_WRITE, 0, getSize())
  ///@return A ByteBuffer mapping
  /// This value will never be {@code null}.
  ///@throws ErrnoException if the mmap call failed.
  jni.JniObject mapReadWrite() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_mapReadWrite, jni.JniType.objectType, []).object);

  static final _id_mapReadOnly = jniAccessors.getMethodIDOf(
      _classRef, "mapReadOnly", "()Ljava/nio/ByteBuffer;");

  /// from: public java.nio.ByteBuffer mapReadOnly()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a read-only mapping of the entire shared memory region. This requires the the
  /// protection level of the shared memory is at least PROT_READ or the map will fail.
  ///
  /// Use \#map(int, int, int) to have more control over the mapping if desired.
  /// This is equivalent to map(OsConstants.PROT_READ, 0, getSize())
  ///@return A ByteBuffer mapping
  /// This value will never be {@code null}.
  ///@throws ErrnoException if the mmap call failed.
  jni.JniObject mapReadOnly() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_mapReadOnly, jni.JniType.objectType, []).object);

  static final _id_map = jniAccessors.getMethodIDOf(
      _classRef, "map", "(III)Ljava/nio/ByteBuffer;");

  /// from: public java.nio.ByteBuffer map(int prot, int offset, int length)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an mmap of the SharedMemory with the specified prot, offset, and length. This will
  /// always produce a new ByteBuffer window to the backing shared memory region. Every call
  /// to map() may be paired with a call to \#unmap(ByteBuffer) when the ByteBuffer
  /// returned by map() is no longer needed.
  ///@param prot A bitwise-or'd combination of PROT_READ, PROT_WRITE, PROT_EXEC, or PROT_NONE.
  ///@param offset The offset into the shared memory to begin mapping. Must be >= 0 and less than
  ///         getSize().
  ///@param length The length of the region to map. Must be > 0 and offset + length must not
  ///         exceed getSize().
  ///@return A ByteBuffer mapping.
  /// This value will never be {@code null}.
  ///@throws ErrnoException if the mmap call failed.
  jni.JniObject map(int prot, int offset, int length) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference, _id_map,
          jni.JniType.objectType, [prot, offset, length]).object);

  static final _id_unmap = jniAccessors.getStaticMethodIDOf(
      _classRef, "unmap", "(Ljava/nio/ByteBuffer;)V");

  /// from: static public void unmap(java.nio.ByteBuffer buffer)
  ///
  /// Unmaps a buffer previously returned by \#map(int, int, int). This will immediately
  /// release the backing memory of the ByteBuffer, invalidating all references to it. Only
  /// call this method if there are no duplicates of the ByteBuffer in use and don't
  /// access the ByteBuffer after calling this method.
  ///@param buffer The buffer to unmap
  ///
  /// This value must never be {@code null}.
  static void unmap(jni.JniObject buffer) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_unmap,
          jni.JniType.voidType, [buffer.reference]).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Close the backing FileDescriptor of this SharedMemory instance. Note that all
  /// open mappings of the shared memory will remain valid and may continue to be used. The
  /// shared memory will not be freed until all file descriptor handles are closed and all
  /// memory mappings are unmapped.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  ///
  /// @param dest This value must never be {@code null}.
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}
