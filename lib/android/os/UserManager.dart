// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "UserHandle.dart" as userhandle_;

import "Bundle.dart" as bundle_;

import "../content/Intent.dart" as intent_;

import "PersistableBundle.dart" as persistablebundle_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.UserManager
///
/// Manages users and user details on a multi-user system. There are two major categories of
/// users: fully customizable users with their own login, and managed profiles that share a workspace
/// with a related user.
///
/// Users are different from accounts, which are managed by
/// AccountManager. Each user can have their own set of accounts.
///
/// See DevicePolicyManager\#ACTION_PROVISION_MANAGED_PROFILE for more on managed profiles.
class UserManager extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/UserManager");
  UserManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ALLOW_PARENT_PROFILE_APP_LINKING
  ///
  /// Allows apps in the parent profile to handle web links from the managed profile.
  ///
  /// This user restriction has an effect only in a managed profile.
  /// If set:
  /// Intent filters of activities in the parent profile with action
  /// android.content.Intent\#ACTION_VIEW,
  /// category android.content.Intent\#CATEGORY_BROWSABLE, scheme http or https, and which
  /// define a host can handle intents from the managed profile.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const ALLOW_PARENT_PROFILE_APP_LINKING =
      "allow_parent_profile_app_linking";

  /// from: static public final java.lang.String DISALLOW_ADD_MANAGED_PROFILE
  ///
  /// Specifies if a user is disallowed from adding managed profiles.
  /// The default value for an unmanaged user is <code>false</code>.
  /// For users with a device owner set, the default is <code>true</code>.
  /// This restriction has no effect on managed profiles.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_ADD_MANAGED_PROFILE = "no_add_managed_profile";

  /// from: static public final java.lang.String DISALLOW_ADD_USER
  ///
  /// Specifies if a user is disallowed from adding new users. This can only be set by device
  /// owners and profile owners on the primary user.
  /// The default value is <code>false</code>.
  /// This restriction has no effect on secondary users and managed profiles since only the
  /// primary user can add other users.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_ADD_USER = "no_add_user";

  /// from: static public final java.lang.String DISALLOW_ADJUST_VOLUME
  ///
  /// Specifies if a user is disallowed from adjusting the master volume. If set, the master volume
  /// will be muted. This can be set by device owners from API 21 and profile owners from API 24.
  /// The default value is <code>false</code>.
  ///
  /// When the restriction is set by profile owners, then it only applies to relevant
  /// profiles.
  ///
  /// This restriction has no effect on managed profiles.
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_ADJUST_VOLUME = "no_adjust_volume";

  /// from: static public final java.lang.String DISALLOW_AIRPLANE_MODE
  ///
  /// Specifies if airplane mode is disallowed on the device.
  ///
  ///  This restriction can only be set by the device owner and the profile owner on the
  /// primary user and it applies globally - i.e. it disables airplane mode on the entire device.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_AIRPLANE_MODE = "no_airplane_mode";

  /// from: static public final java.lang.String DISALLOW_AMBIENT_DISPLAY
  ///
  /// Specifies if ambient display is disallowed for the user.
  ///
  /// The default value is <code>false</code>.
  ///
  /// This user restriction has no effect on managed profiles.
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_AMBIENT_DISPLAY = "no_ambient_display";

  /// from: static public final java.lang.String DISALLOW_APPS_CONTROL
  ///
  /// Specifies if a user is disallowed from modifying
  /// applications in Settings or launchers. The following actions will not be allowed when this
  /// restriction is enabled:
  /// <li>uninstalling apps</li>
  /// <li>disabling apps</li>
  /// <li>clearing app caches</li>
  /// <li>clearing app data</li>
  /// <li>force stopping apps</li>
  /// <li>clearing app defaults</li>
  ///
  /// The default value is <code>false</code>.
  ///
  /// <strong>Note:</strong> The user will still be able to perform those actions via other
  /// means (such as adb). Third party apps will also be able to uninstall apps via the
  /// android.content.pm.PackageInstaller. \#DISALLOW_UNINSTALL_APPS or
  /// DevicePolicyManager\#setUninstallBlocked(ComponentName, String, boolean) should be
  /// used to prevent the user from uninstalling apps completely, and
  /// DevicePolicyManager\#addPersistentPreferredActivity(ComponentName, IntentFilter, ComponentName)
  /// to add a default intent handler for a given intent filter.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_APPS_CONTROL = "no_control_apps";

  /// from: static public final java.lang.String DISALLOW_AUTOFILL
  ///
  /// Specifies if a user is not allowed to use Autofill Services.
  ///
  /// Device owner and profile owner can set this restriction. When it is set by device owner,
  /// only the target user will be affected.
  ///
  /// The default value is <code>false</code>.
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_AUTOFILL = "no_autofill";

  /// from: static public final java.lang.String DISALLOW_BLUETOOTH
  ///
  /// Specifies if bluetooth is disallowed on the device.
  ///
  ///  This restriction can only be set by the device owner and the profile owner on the
  /// primary user and it applies globally - i.e. it disables bluetooth on the entire device.
  /// The default value is <code>false</code>.
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_BLUETOOTH = "no_bluetooth";

  /// from: static public final java.lang.String DISALLOW_BLUETOOTH_SHARING
  ///
  /// Specifies if outgoing bluetooth sharing is disallowed on the device. Device owner and profile
  /// owner can set this restriction. When it is set by device owner, all users on this device will
  /// be affected.
  ///
  /// Default is <code>true</code> for managed profiles and false for otherwise. When a device
  /// upgrades to android.os.Build.VERSION_CODES\#O, the system sets it for all existing
  /// managed profiles.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_BLUETOOTH_SHARING = "no_bluetooth_sharing";

  /// from: static public final java.lang.String DISALLOW_CONFIG_BLUETOOTH
  ///
  /// Specifies if a user is disallowed from configuring bluetooth.
  /// This does _not_ restrict the user from turning bluetooth on or off.
  /// The default value is <code>false</code>.
  /// This restriction doesn't prevent the user from using bluetooth. For disallowing usage of
  /// bluetooth completely on the device, use \#DISALLOW_BLUETOOTH.
  /// This restriction has no effect in a managed profile.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_BLUETOOTH = "no_config_bluetooth";

  /// from: static public final java.lang.String DISALLOW_CONFIG_BRIGHTNESS
  ///
  /// Specifies if a user is disallowed from configuring brightness. When device owner sets it,
  /// it'll only be applied on the target(system) user.
  ///
  /// The default value is <code>false</code>.
  ///
  /// This user restriction has no effect on managed profiles.
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_BRIGHTNESS = "no_config_brightness";

  /// from: static public final java.lang.String DISALLOW_CONFIG_CELL_BROADCASTS
  ///
  /// Specifies if a user is disallowed from configuring cell
  /// broadcasts. This can only be set by device owners and profile owners on the primary user.
  /// The default value is <code>false</code>.
  /// This restriction has no effect on secondary users and managed profiles since only the
  /// primary user can configure cell broadcasts.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_CELL_BROADCASTS = "no_config_cell_broadcasts";

  /// from: static public final java.lang.String DISALLOW_CONFIG_CREDENTIALS
  ///
  /// Specifies if a user is disallowed from configuring user
  /// credentials. The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_CREDENTIALS = "no_config_credentials";

  /// from: static public final java.lang.String DISALLOW_CONFIG_DATE_TIME
  ///
  /// Specifies if date, time and timezone configuring is disallowed.
  ///
  /// When restriction is set by device owners, it applies globally - i.e., it disables date,
  /// time and timezone setting on the entire device and all users will be affected. When it's set
  /// by profile owners, it's only applied to the managed user.
  /// The default value is <code>false</code>.
  ///
  /// This user restriction has no effect on managed profiles.
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_DATE_TIME = "no_config_date_time";

  /// from: static public final java.lang.String DISALLOW_CONFIG_LOCALE
  ///
  /// Specifies if a user is disallowed from changing the device
  /// language. The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_LOCALE = "no_config_locale";

  /// from: static public final java.lang.String DISALLOW_CONFIG_LOCATION
  ///
  /// Specifies if a user is disallowed from enabling or disabling location providers. As a
  /// result, user is disallowed from turning on or off location. Device owner and profile owners
  /// can set this restriction and it only applies on the managed user.
  ///
  /// In a managed profile, location sharing is forced off when it's off on primary user, so
  /// user can still turn off location sharing on managed profile when the restriction is set by
  /// profile owner on managed profile.
  ///
  /// This user restriction is different from \#DISALLOW_SHARE_LOCATION,
  /// as the device owner or profile owner can still enable or disable location mode via
  /// DevicePolicyManager\#setSecureSetting when this restriction is on.
  ///
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see android.location.LocationManager\#isProviderEnabled(String)
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_LOCATION = "no_config_location";

  /// from: static public final java.lang.String DISALLOW_CONFIG_MOBILE_NETWORKS
  ///
  /// Specifies if a user is disallowed from configuring mobile
  /// networks. This can only be set by device owners and profile owners on the primary user.
  /// The default value is <code>false</code>.
  /// This restriction has no effect on secondary users and managed profiles since only the
  /// primary user can configure mobile networks.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_MOBILE_NETWORKS = "no_config_mobile_networks";

  /// from: static public final java.lang.String DISALLOW_CONFIG_SCREEN_TIMEOUT
  ///
  /// Specifies if a user is disallowed from changing screen off timeout.
  ///
  /// The default value is <code>false</code>.
  ///
  /// This user restriction has no effect on managed profiles.
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_SCREEN_TIMEOUT = "no_config_screen_timeout";

  /// from: static public final java.lang.String DISALLOW_CONFIG_TETHERING
  ///
  /// Specifies if a user is disallowed from configuring Tethering
  /// & portable hotspots. This can only be set by device owners and profile owners on the
  /// primary user. The default value is <code>false</code>.
  /// In Android 9.0 or higher, if tethering is enabled when this restriction is set,
  /// tethering will be automatically turned off.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_TETHERING = "no_config_tethering";

  /// from: static public final java.lang.String DISALLOW_CONFIG_VPN
  ///
  /// Specifies if a user is disallowed from configuring a VPN. The default value is
  /// <code>false</code>. This restriction has an effect when set by device owners and, in Android
  /// 6.0 ({@linkplain android.os.Build.VERSION_CODES\#M API level 23}) or higher, profile owners.
  /// This restriction also prevents VPNs from starting. However, in Android 7.0
  /// ({@linkplain android.os.Build.VERSION_CODES\#N API level 24}) or higher, the system does
  /// start always-on VPNs created by the device or profile owner.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_VPN = "no_config_vpn";

  /// from: static public final java.lang.String DISALLOW_CONFIG_WIFI
  ///
  /// Specifies if a user is disallowed from changing Wi-Fi
  /// access points. The default value is <code>false</code>.
  /// This restriction has no effect in a managed profile.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_WIFI = "no_config_wifi";

  /// from: static public final java.lang.String DISALLOW_CREATE_WINDOWS
  ///
  /// Specifies that windows besides app windows should not be
  /// created. This will block the creation of the following types of windows.
  /// <li>LayoutParams\#TYPE_TOAST</li>
  /// <li>LayoutParams\#TYPE_PHONE</li>
  /// <li>LayoutParams\#TYPE_PRIORITY_PHONE</li>
  /// <li>LayoutParams\#TYPE_SYSTEM_ALERT</li>
  /// <li>LayoutParams\#TYPE_SYSTEM_ERROR</li>
  /// <li>LayoutParams\#TYPE_SYSTEM_OVERLAY</li>
  /// <li>LayoutParams\#TYPE_APPLICATION_OVERLAY</li>
  ///
  /// This can only be set by device owners and profile owners on the primary user.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CREATE_WINDOWS = "no_create_windows";

  /// from: static public final java.lang.String DISALLOW_CROSS_PROFILE_COPY_PASTE
  ///
  /// Specifies if what is copied in the clipboard of this profile can
  /// be pasted in related profiles. Does not restrict if the clipboard of related profiles can be
  /// pasted in this profile.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CROSS_PROFILE_COPY_PASTE =
      "no_cross_profile_copy_paste";

  /// from: static public final java.lang.String DISALLOW_DATA_ROAMING
  ///
  /// Specifies if a user is not allowed to use cellular data when roaming. This can only be set by
  /// device owners. The default value is <code>false</code>.
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_DATA_ROAMING = "no_data_roaming";

  /// from: static public final java.lang.String DISALLOW_DEBUGGING_FEATURES
  ///
  /// Specifies if a user is disallowed from enabling or
  /// accessing debugging features. The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_DEBUGGING_FEATURES = "no_debugging_features";

  /// from: static public final java.lang.String DISALLOW_FACTORY_RESET
  ///
  /// Specifies if a user is disallowed from factory resetting
  /// from Settings. This can only be set by device owners and profile owners on the primary user.
  /// The default value is <code>false</code>.
  /// This restriction has no effect on secondary users and managed profiles since only the
  /// primary user can factory reset the device.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_FACTORY_RESET = "no_factory_reset";

  /// from: static public final java.lang.String DISALLOW_FUN
  ///
  /// Specifies if the user is not allowed to have fun. In some cases, the
  /// device owner may wish to prevent the user from experiencing amusement or
  /// joy while using the device. The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_FUN = "no_fun";

  /// from: static public final java.lang.String DISALLOW_INSTALL_APPS
  ///
  /// Specifies if a user is disallowed from installing applications. This user restriction also
  /// prevents device owners and profile owners installing apps. The default value is
  /// {@code false}.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_INSTALL_APPS = "no_install_apps";

  /// from: static public final java.lang.String DISALLOW_INSTALL_UNKNOWN_SOURCES
  ///
  /// Specifies if a user is disallowed from enabling the
  /// "Unknown Sources" setting, that allows installation of apps from unknown sources.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_INSTALL_UNKNOWN_SOURCES = "no_install_unknown_sources";

  /// from: static public final java.lang.String DISALLOW_MODIFY_ACCOUNTS
  ///
  /// Specifies if a user is disallowed from adding and removing accounts, unless they are
  /// android.accounts.AccountManager\#addAccountExplicitly programmatically added by
  /// Authenticator.
  /// The default value is <code>false</code>.
  ///
  /// From android.os.Build.VERSION_CODES\#N a profile or device owner app can still
  /// use android.accounts.AccountManager APIs to add or remove accounts when account
  /// management is disallowed.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_MODIFY_ACCOUNTS = "no_modify_accounts";

  /// from: static public final java.lang.String DISALLOW_MOUNT_PHYSICAL_MEDIA
  ///
  /// Specifies if a user is disallowed from mounting
  /// physical external media. This can only be set by device owners and profile owners on the
  /// primary user. The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_MOUNT_PHYSICAL_MEDIA = "no_physical_media";

  /// from: static public final java.lang.String DISALLOW_NETWORK_RESET
  ///
  /// Specifies if a user is disallowed from resetting network settings
  /// from Settings. This can only be set by device owners and profile owners on the primary user.
  /// The default value is <code>false</code>.
  /// This restriction has no effect on secondary users and managed profiles since only the
  /// primary user can reset the network settings of the device.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_NETWORK_RESET = "no_network_reset";

  /// from: static public final java.lang.String DISALLOW_OUTGOING_BEAM
  ///
  /// Specifies if the user is not allowed to use NFC to beam out data from apps.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_OUTGOING_BEAM = "no_outgoing_beam";

  /// from: static public final java.lang.String DISALLOW_OUTGOING_CALLS
  ///
  /// Specifies that the user is not allowed to make outgoing
  /// phone calls. Emergency calls are still permitted.
  /// The default value is <code>false</code>.
  /// This restriction has no effect on managed profiles.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_OUTGOING_CALLS = "no_outgoing_calls";

  /// from: static public final java.lang.String DISALLOW_PRINTING
  ///
  /// Specifies whether the user is allowed to print.
  ///
  /// This restriction can be set by device or profile owner.
  ///
  /// The default value is {@code false}.
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_PRINTING = "no_printing";

  /// from: static public final java.lang.String DISALLOW_REMOVE_MANAGED_PROFILE
  ///
  /// Specifies if managed profiles of this user can be removed, other than by its profile owner.
  /// The default value is <code>false</code>.
  ///
  /// This restriction has no effect on managed profiles.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_REMOVE_MANAGED_PROFILE = "no_remove_managed_profile";

  /// from: static public final java.lang.String DISALLOW_REMOVE_USER
  ///
  /// When set on the primary user this specifies if the user can remove other users.
  /// When set on a secondary user, this specifies if the user can remove itself.
  /// This restriction has no effect on managed profiles.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_REMOVE_USER = "no_remove_user";

  /// from: static public final java.lang.String DISALLOW_SAFE_BOOT
  ///
  /// Specifies if the user is not allowed to reboot the device into safe boot mode.
  /// This can only be set by device owners and profile owners on the primary user.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_SAFE_BOOT = "no_safe_boot";

  /// from: static public final java.lang.String DISALLOW_SET_USER_ICON
  ///
  /// Specifies if a user is not allowed to change their icon. Device owner and profile owner
  /// can set this restriction. When it is set by device owner, only the target user will be
  /// affected. The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_SET_USER_ICON = "no_set_user_icon";

  /// from: static public final java.lang.String DISALLOW_SET_WALLPAPER
  ///
  /// User restriction to disallow setting a wallpaper. Profile owner and device owner
  /// are able to set wallpaper regardless of this restriction.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_SET_WALLPAPER = "no_set_wallpaper";

  /// from: static public final java.lang.String DISALLOW_SHARE_INTO_MANAGED_PROFILE
  ///
  /// Specifies whether the user can share file / picture / data from the primary user into the
  /// managed profile, either by sending them from the primary side, or by picking up data within
  /// an app in the managed profile.
  ///
  /// When a managed profile is created, the system allows the user to send data from the primary
  /// side to the profile by setting up certain default cross profile intent filters. If
  /// this is undesired, this restriction can be set to disallow it. Note that this restriction
  /// will not block any sharing allowed by explicit
  /// DevicePolicyManager\#addCrossProfileIntentFilter calls by the profile owner.
  ///
  /// This restriction is only meaningful when set by profile owner. When it is set by device
  /// owner, it does not have any effect.
  ///
  /// The default value is <code>false</code>.
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_SHARE_INTO_MANAGED_PROFILE = "no_sharing_into_profile";

  /// from: static public final java.lang.String DISALLOW_SHARE_LOCATION
  ///
  /// Specifies if a user is disallowed from turning on location sharing.
  /// The default value is <code>false</code>.
  /// In a managed profile, location sharing always reflects the primary user's setting, but
  /// can be overridden and forced off by setting this restriction to true in the managed profile.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_SHARE_LOCATION = "no_share_location";

  /// from: static public final java.lang.String DISALLOW_SMS
  ///
  /// Specifies that the user is not allowed to send or receive
  /// SMS messages. The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_SMS = "no_sms";

  /// from: static public final java.lang.String DISALLOW_SYSTEM_ERROR_DIALOGS
  ///
  /// Specifies that system error dialogs for crashed or unresponsive apps should not be shown.
  /// In this case, the system will force-stop the app as if the user chooses the "close app"
  /// option on the UI. A feedback report isn't collected as there is no way for the user to
  /// provide explicit consent. The default value is <code>false</code>.
  ///
  /// When this user restriction is set by device owners, it's applied to all users. When set by
  /// the profile owner of the primary user or a secondary user, the restriction affects only the
  /// calling user. This user restriction has no effect on managed profiles.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_SYSTEM_ERROR_DIALOGS = "no_system_error_dialogs";

  /// from: static public final java.lang.String DISALLOW_UNIFIED_PASSWORD
  ///
  /// Specifies that the managed profile is not allowed to have unified lock screen challenge with
  /// the primary user.
  ///
  /// <strong>Note:</strong> Setting this restriction alone doesn't automatically set a
  /// separate challenge. Profile owner can ask the user to set a new password using
  /// DevicePolicyManager\#ACTION_SET_NEW_PASSWORD and verify it using
  /// DevicePolicyManager\#isUsingUnifiedPassword(ComponentName).
  ///
  /// Can be set by profile owners. It only has effect on managed profiles when set by managed
  /// profile owner. Has no effect on non-managed profiles or users.
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_UNIFIED_PASSWORD = "no_unified_password";

  /// from: static public final java.lang.String DISALLOW_UNINSTALL_APPS
  ///
  /// Specifies if a user is disallowed from uninstalling applications.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_UNINSTALL_APPS = "no_uninstall_apps";

  /// from: static public final java.lang.String DISALLOW_UNMUTE_MICROPHONE
  ///
  /// Specifies if a user is disallowed from adjusting microphone volume. If set, the microphone
  /// will be muted. This can be set by device owners and profile owners. The default value is
  /// <code>false</code>.
  ///
  /// This restriction has no effect on managed profiles.
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_UNMUTE_MICROPHONE = "no_unmute_microphone";

  /// from: static public final java.lang.String DISALLOW_USB_FILE_TRANSFER
  ///
  /// Specifies if a user is disallowed from transferring files over
  /// USB. This can only be set by device owners and profile owners on the primary user.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_USB_FILE_TRANSFER = "no_usb_file_transfer";

  /// from: static public final java.lang.String DISALLOW_USER_SWITCH
  ///
  /// Specifies if user switching is blocked on the current user.
  ///
  ///  This restriction can only be set by the device owner, it will be applied to all users.
  /// Device owner can still switch user via
  /// DevicePolicyManager\#switchUser(ComponentName, UserHandle) when this restriction is
  /// set.
  ///
  /// The default value is <code>false</code>.
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_USER_SWITCH = "no_user_switch";

  /// from: static public final java.lang.String ENSURE_VERIFY_APPS
  ///
  /// Specifies if a user is disallowed from disabling application verification. The default
  /// value is <code>false</code>.
  ///
  /// In Android 8.0 ({@linkplain android.os.Build.VERSION_CODES\#O API level 26}) and higher,
  /// this is a global user restriction. If a device owner or profile owner sets this restriction,
  /// the system enforces app verification across all users on the device. Running in earlier
  /// Android versions, this restriction affects only the profile that sets it.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const ENSURE_VERIFY_APPS = "ensure_verify_apps";

  /// from: static public final java.lang.String KEY_RESTRICTIONS_PENDING
  ///
  /// Application restriction key that is used to indicate the pending arrival
  /// of real restrictions for the app.
  ///
  ///
  /// Applications that support restrictions should check for the presence of this key.
  /// A <code>true</code> value indicates that restrictions may be applied in the near
  /// future but are not available yet. It is the responsibility of any
  /// management application that sets this flag to update it when the final
  /// restrictions are enforced.
  ///
  /// Key for application restrictions.
  /// Type: Boolean
  ///@see android.app.admin.DevicePolicyManager\#setApplicationRestrictions(
  ///      android.content.ComponentName, String, Bundle)
  ///@see android.app.admin.DevicePolicyManager\#getApplicationRestrictions(
  ///      android.content.ComponentName, String)
  static const KEY_RESTRICTIONS_PENDING = "restrictions_pending";

  /// from: static public final int USER_CREATION_FAILED_NOT_PERMITTED
  ///
  /// Error result indicating that this user is not allowed to add other users on this device.
  /// This is a result code returned from the activity created by the intent
  /// \#createUserCreationIntent(String, String, String, PersistableBundle).
  static const USER_CREATION_FAILED_NOT_PERMITTED = 1;

  /// from: static public final int USER_CREATION_FAILED_NO_MORE_USERS
  ///
  /// Error result indicating that no more users can be created on this device.
  /// This is a result code returned from the activity created by the intent
  /// \#createUserCreationIntent(String, String, String, PersistableBundle).
  static const USER_CREATION_FAILED_NO_MORE_USERS = 2;

  /// from: static public final int USER_OPERATION_ERROR_CURRENT_USER
  ///
  /// Indicates user operation failed because the target user is in the foreground.
  static const USER_OPERATION_ERROR_CURRENT_USER = 4;

  /// from: static public final int USER_OPERATION_ERROR_LOW_STORAGE
  ///
  /// Indicates user operation failed because device has low data storage.
  static const USER_OPERATION_ERROR_LOW_STORAGE = 5;

  /// from: static public final int USER_OPERATION_ERROR_MANAGED_PROFILE
  ///
  /// Indicates user operation failed because target user is a managed profile.
  static const USER_OPERATION_ERROR_MANAGED_PROFILE = 2;

  /// from: static public final int USER_OPERATION_ERROR_MAX_RUNNING_USERS
  ///
  /// Indicates user operation failed because maximum running user limit has been reached.
  static const USER_OPERATION_ERROR_MAX_RUNNING_USERS = 3;

  /// from: static public final int USER_OPERATION_ERROR_MAX_USERS
  ///
  /// Indicates user operation failed because maximum user limit has been reached.
  static const USER_OPERATION_ERROR_MAX_USERS = 6;

  /// from: static public final int USER_OPERATION_ERROR_UNKNOWN
  ///
  /// Indicates user operation failed for unknown reason.
  static const USER_OPERATION_ERROR_UNKNOWN = 1;

  /// from: static public final int USER_OPERATION_SUCCESS
  ///
  /// Indicates user operation is successful.
  static const USER_OPERATION_SUCCESS = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  UserManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_supportsMultipleUsers = jniAccessors.getStaticMethodIDOf(
      _classRef, "supportsMultipleUsers", "()Z");

  /// from: static public boolean supportsMultipleUsers()
  ///
  /// Returns whether this device supports multiple users with their own login and customizable
  /// space.
  ///@return whether the device supports multiple users.
  static bool supportsMultipleUsers() => jniAccessors.callStaticMethodWithArgs(
      _classRef,
      _id_supportsMultipleUsers,
      jni.JniType.booleanType, []).boolean;

  static final _id_getUserName = jniAccessors.getMethodIDOf(
      _classRef, "getUserName", "()Ljava/lang/String;");

  /// from: public java.lang.String getUserName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the user name of the user making this call.  This call is only
  /// available to applications on the system image; it requires the
  /// MANAGE_USERS permission.
  ///@return the user name
  jni.JniString getUserName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getUserName, jni.JniType.objectType, []).object);

  static final _id_isUserAGoat =
      jniAccessors.getMethodIDOf(_classRef, "isUserAGoat", "()Z");

  /// from: public boolean isUserAGoat()
  ///
  /// Used to determine whether the user making this call is subject to
  /// teleportations.
  ///
  /// As of android.os.Build.VERSION_CODES\#LOLLIPOP, this method can
  /// now automatically identify goats using advanced goat recognition technology.
  ///
  ///@return Returns true if the user making this call is a goat.
  bool isUserAGoat() => jniAccessors.callMethodWithArgs(
      reference, _id_isUserAGoat, jni.JniType.booleanType, []).boolean;

  static final _id_isSystemUser =
      jniAccessors.getMethodIDOf(_classRef, "isSystemUser", "()Z");

  /// from: public boolean isSystemUser()
  ///
  /// Used to check if this process is running under the system user. The system user
  /// is the initial user that is implicitly created on first boot and hosts most of the
  /// system services.
  ///@return whether this process is running under the system user.
  bool isSystemUser() => jniAccessors.callMethodWithArgs(
      reference, _id_isSystemUser, jni.JniType.booleanType, []).boolean;

  static final _id_isDemoUser =
      jniAccessors.getMethodIDOf(_classRef, "isDemoUser", "()Z");

  /// from: public boolean isDemoUser()
  ///
  /// Checks if the calling app is running in a demo user. When running in a demo user,
  /// apps can be more helpful to the user, or explain their features in more detail.
  ///@return whether the caller is a demo user.
  bool isDemoUser() => jniAccessors.callMethodWithArgs(
      reference, _id_isDemoUser, jni.JniType.booleanType, []).boolean;

  static final _id_isUserRunning = jniAccessors.getMethodIDOf(
      _classRef, "isUserRunning", "(Landroid/os/UserHandle;)Z");

  /// from: public boolean isUserRunning(android.os.UserHandle user)
  ///
  /// Return whether the given user is actively running.  This means that
  /// the user is in the "started" state, not "stopped" -- it is currently
  /// allowed to run code through scheduled alarms, receiving broadcasts,
  /// etc.  A started user may be either the current foreground user or a
  /// background user; the result here does not distinguish between the two.
  ///
  /// Note prior to Android Nougat MR1 (SDK version <= 24;
  /// {@link android.os.Build.VERSION_CODES\#N), this API required a system permission
  /// in order to check other profile's status.
  /// Since Android Nougat MR1 (SDK version >= 25;
  /// {@link android.os.Build.VERSION_CODES\#N_MR1)), the restriction has been relaxed, and now
  /// it'll accept any UserHandle within the same profile group as the caller.
  ///@param user The user to retrieve the running state for.
  bool isUserRunning(userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(reference, _id_isUserRunning,
          jni.JniType.booleanType, [user.reference]).boolean;

  static final _id_isUserRunningOrStopping = jniAccessors.getMethodIDOf(
      _classRef, "isUserRunningOrStopping", "(Landroid/os/UserHandle;)Z");

  /// from: public boolean isUserRunningOrStopping(android.os.UserHandle user)
  ///
  /// Return whether the given user is actively running _or_ stopping.
  /// This is like \#isUserRunning(UserHandle), but will also return
  /// true if the user had been running but is in the process of being stopped
  /// (but is not yet fully stopped, and still running some code).
  ///
  /// Note prior to Android Nougat MR1 (SDK version <= 24;
  /// {@link android.os.Build.VERSION_CODES\#N), this API required a system permission
  /// in order to check other profile's status.
  /// Since Android Nougat MR1 (SDK version >= 25;
  /// {@link android.os.Build.VERSION_CODES\#N_MR1)), the restriction has been relaxed, and now
  /// it'll accept any UserHandle within the same profile group as the caller.
  ///@param user The user to retrieve the running state for.
  bool isUserRunningOrStopping(userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(reference, _id_isUserRunningOrStopping,
          jni.JniType.booleanType, [user.reference]).boolean;

  static final _id_isUserUnlocked =
      jniAccessors.getMethodIDOf(_classRef, "isUserUnlocked", "()Z");

  /// from: public boolean isUserUnlocked()
  ///
  /// Return whether the calling user is running in an "unlocked" state.
  ///
  /// On devices with direct boot, a user is unlocked only after they've
  /// entered their credentials (such as a lock pattern or PIN). On devices
  /// without direct boot, a user is unlocked as soon as it starts.
  ///
  /// When a user is locked, only device-protected data storage is available.
  /// When a user is unlocked, both device-protected and credential-protected
  /// private app data storage is available.
  ///@see Intent\#ACTION_USER_UNLOCKED
  ///@see Context\#createDeviceProtectedStorageContext()
  bool isUserUnlocked() => jniAccessors.callMethodWithArgs(
      reference, _id_isUserUnlocked, jni.JniType.booleanType, []).boolean;

  static final _id_isUserUnlocked1 = jniAccessors.getMethodIDOf(
      _classRef, "isUserUnlocked", "(Landroid/os/UserHandle;)Z");

  /// from: public boolean isUserUnlocked(android.os.UserHandle user)
  ///
  /// Return whether the given user is running in an "unlocked" state.
  ///
  /// On devices with direct boot, a user is unlocked only after they've
  /// entered their credentials (such as a lock pattern or PIN). On devices
  /// without direct boot, a user is unlocked as soon as it starts.
  ///
  /// When a user is locked, only device-protected data storage is available.
  /// When a user is unlocked, both device-protected and credential-protected
  /// private app data storage is available.
  /// Requires {@code android.permission.MANAGE_USERS} or
  /// {@code android.permission.INTERACT_ACROSS_USERS}, otherwise specified UserHandle user
  /// must be the calling user or a managed profile associated with it.
  ///@param user to retrieve the unlocked state for.
  ///@see Intent\#ACTION_USER_UNLOCKED
  ///@see Context\#createDeviceProtectedStorageContext()
  bool isUserUnlocked1(userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(reference, _id_isUserUnlocked1,
          jni.JniType.booleanType, [user.reference]).boolean;

  static final _id_getUserRestrictions = jniAccessors.getMethodIDOf(
      _classRef, "getUserRestrictions", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getUserRestrictions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the user-wide restrictions imposed on this user.
  ///@return a Bundle containing all the restrictions.
  bundle_.Bundle getUserRestrictions() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getUserRestrictions, jni.JniType.objectType, []).object);

  static final _id_getUserRestrictions1 = jniAccessors.getMethodIDOf(_classRef,
      "getUserRestrictions", "(Landroid/os/UserHandle;)Landroid/os/Bundle;");

  /// from: public android.os.Bundle getUserRestrictions(android.os.UserHandle userHandle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the user-wide restrictions imposed on the user specified by <code>userHandle</code>.
  ///@param userHandle the UserHandle of the user for whom to retrieve the restrictions.
  ///@return a Bundle containing all the restrictions.
  bundle_.Bundle getUserRestrictions1(userhandle_.UserHandle userHandle) =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getUserRestrictions1,
          jni.JniType.objectType,
          [userHandle.reference]).object);

  static final _id_setUserRestrictions = jniAccessors.getMethodIDOf(
      _classRef, "setUserRestrictions", "(Landroid/os/Bundle;)V");

  /// from: public void setUserRestrictions(android.os.Bundle restrictions)
  ///
  /// This will no longer work.  Device owners and profile owners should use
  /// DevicePolicyManager\#addUserRestriction(ComponentName, String) instead.
  void setUserRestrictions(bundle_.Bundle restrictions) =>
      jniAccessors.callMethodWithArgs(reference, _id_setUserRestrictions,
          jni.JniType.voidType, [restrictions.reference]).check();

  static final _id_setUserRestrictions1 = jniAccessors.getMethodIDOf(_classRef,
      "setUserRestrictions", "(Landroid/os/Bundle;Landroid/os/UserHandle;)V");

  /// from: public void setUserRestrictions(android.os.Bundle restrictions, android.os.UserHandle userHandle)
  ///
  /// This will no longer work.  Device owners and profile owners should use
  /// DevicePolicyManager\#addUserRestriction(ComponentName, String) instead.
  void setUserRestrictions1(
          bundle_.Bundle restrictions, userhandle_.UserHandle userHandle) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setUserRestrictions1,
          jni.JniType.voidType,
          [restrictions.reference, userHandle.reference]).check();

  static final _id_setUserRestriction = jniAccessors.getMethodIDOf(
      _classRef, "setUserRestriction", "(Ljava/lang/String;Z)V");

  /// from: public void setUserRestriction(java.lang.String key, boolean value)
  ///
  /// Sets the value of a specific restriction.
  /// Requires the MANAGE_USERS permission.
  ///@param key the key of the restriction
  ///@param value the value for the restriction
  ///@deprecated use android.app.admin.DevicePolicyManager\#addUserRestriction(
  /// android.content.ComponentName, String) or
  /// android.app.admin.DevicePolicyManager\#clearUserRestriction(
  /// android.content.ComponentName, String) instead.
  void setUserRestriction(jni.JniString key, bool value) =>
      jniAccessors.callMethodWithArgs(reference, _id_setUserRestriction,
          jni.JniType.voidType, [key.reference, value]).check();

  static final _id_hasUserRestriction = jniAccessors.getMethodIDOf(
      _classRef, "hasUserRestriction", "(Ljava/lang/String;)Z");

  /// from: public boolean hasUserRestriction(java.lang.String restrictionKey)
  ///
  /// Returns whether the current user has been disallowed from performing certain actions
  /// or setting certain settings.
  ///@param restrictionKey The string key representing the restriction.
  ///@return {@code true} if the current user has the given restriction, {@code false} otherwise.
  bool hasUserRestriction(jni.JniString restrictionKey) =>
      jniAccessors.callMethodWithArgs(reference, _id_hasUserRestriction,
          jni.JniType.booleanType, [restrictionKey.reference]).boolean;

  static final _id_getSerialNumberForUser = jniAccessors.getMethodIDOf(
      _classRef, "getSerialNumberForUser", "(Landroid/os/UserHandle;)J");

  /// from: public long getSerialNumberForUser(android.os.UserHandle user)
  ///
  /// Return the serial number for a user.  This is a device-unique
  /// number assigned to that user; if the user is deleted and then a new
  /// user created, the new users will not be given the same serial number.
  ///@param user The user whose serial number is to be retrieved.
  ///@return The serial number of the given user; returns -1 if the
  /// given UserHandle does not exist.
  ///@see \#getUserForSerialNumber(long)
  int getSerialNumberForUser(userhandle_.UserHandle user) =>
      jniAccessors.callMethodWithArgs(reference, _id_getSerialNumberForUser,
          jni.JniType.longType, [user.reference]).long;

  static final _id_getUserForSerialNumber = jniAccessors.getMethodIDOf(
      _classRef, "getUserForSerialNumber", "(J)Landroid/os/UserHandle;");

  /// from: public android.os.UserHandle getUserForSerialNumber(long serialNumber)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the user associated with a serial number previously
  /// returned by \#getSerialNumberForUser(UserHandle).
  ///@param serialNumber The serial number of the user that is being
  /// retrieved.
  ///@return Return the user associated with the serial number, or null
  /// if there is not one.
  ///@see \#getSerialNumberForUser(UserHandle)
  userhandle_.UserHandle getUserForSerialNumber(int serialNumber) =>
      userhandle_.UserHandle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getUserForSerialNumber,
          jni.JniType.objectType,
          [serialNumber]).object);

  static final _id_createUserCreationIntent = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createUserCreationIntent",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Landroid/os/PersistableBundle;)Landroid/content/Intent;");

  /// from: static public android.content.Intent createUserCreationIntent(java.lang.String userName, java.lang.String accountName, java.lang.String accountType, android.os.PersistableBundle accountOptions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an intent to create a user for the provided name and account name. The name
  /// and account name will be used when the setup process for the new user is started.
  ///
  /// The intent should be launched using startActivityForResult and the return result will
  /// indicate if the user consented to adding a new user and if the operation succeeded. Any
  /// errors in creating the user will be returned in the result code. If the user cancels the
  /// request, the return result will be Activity\#RESULT_CANCELED. On success, the
  /// result code will be Activity\#RESULT_OK.
  ///
  /// Use \#supportsMultipleUsers() to first check if the device supports this operation
  /// at all.
  ///
  /// The new user is created but not initialized. After switching into the user for the first
  /// time, the preferred user name and account information are used by the setup process for that
  /// user.
  ///@param userName Optional name to assign to the user.
  /// This value may be {@code null}.
  ///@param accountName Optional account name that will be used by the setup wizard to initialize
  ///                    the user.
  /// This value may be {@code null}.
  ///@param accountType Optional account type for the account to be created. This is required
  ///                    if the account name is specified.
  /// This value may be {@code null}.
  ///@param accountOptions Optional bundle of data to be passed in during account creation in the
  ///                       new user via AccountManager\#addAccount(String, String, String[],
  ///                       Bundle, android.app.Activity, android.accounts.AccountManagerCallback,
  ///                       Handler).
  /// This value may be {@code null}.
  ///@return An Intent that can be launched from an Activity.
  ///@see \#USER_CREATION_FAILED_NOT_PERMITTED
  ///@see \#USER_CREATION_FAILED_NO_MORE_USERS
  ///@see \#supportsMultipleUsers
  static intent_.Intent createUserCreationIntent(
          jni.JniString userName,
          jni.JniString accountName,
          jni.JniString accountType,
          persistablebundle_.PersistableBundle accountOptions) =>
      intent_.Intent.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_createUserCreationIntent, jni.JniType.objectType, [
        userName.reference,
        accountName.reference,
        accountType.reference,
        accountOptions.reference
      ]).object);

  static final _id_getUserCount =
      jniAccessors.getMethodIDOf(_classRef, "getUserCount", "()I");

  /// from: public int getUserCount()
  ///
  /// Return the number of users currently created on the device.
  int getUserCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getUserCount, jni.JniType.intType, []).integer;

  static final _id_getUserProfiles = jniAccessors.getMethodIDOf(
      _classRef, "getUserProfiles", "()Ljava/util/List;");

  /// from: public java.util.List<android.os.UserHandle> getUserProfiles()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of UserHandles for profiles associated with the user that the calling process
  /// is running on, including the user itself.
  ///@return A non-empty list of UserHandles associated with the calling user.
  jni.JniObject getUserProfiles() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getUserProfiles, jni.JniType.objectType, []).object);

  static final _id_requestQuietModeEnabled = jniAccessors.getMethodIDOf(
      _classRef, "requestQuietModeEnabled", "(ZLandroid/os/UserHandle;)Z");

  /// from: public boolean requestQuietModeEnabled(boolean enableQuietMode, android.os.UserHandle userHandle)
  ///
  /// Enables or disables quiet mode for a managed profile. If quiet mode is enabled, apps in a
  /// managed profile don't run, generate notifications, or consume data or battery.
  ///
  /// If a user's credential is needed to turn off quiet mode, a confirm credential screen will be
  /// shown to the user.
  ///
  /// The change may not happen instantly, however apps can listen for
  /// Intent\#ACTION_MANAGED_PROFILE_AVAILABLE and
  /// Intent\#ACTION_MANAGED_PROFILE_UNAVAILABLE broadcasts in order to be notified of
  /// the change of the quiet mode. Apps can also check the current state of quiet mode by
  /// calling \#isQuietModeEnabled(UserHandle).
  ///
  /// The caller must either be the foreground default launcher or have one of these permissions:
  /// {@code MANAGE_USERS} or {@code MODIFY_QUIET_MODE}.
  ///@param enableQuietMode whether quiet mode should be enabled or disabled
  ///@param userHandle user handle of the profile
  /// This value must never be {@code null}.
  ///@return {@code false} if user's credential is needed in order to turn off quiet mode,
  ///         {@code true} otherwise
  ///@throws SecurityException if the caller is invalid
  ///@throws IllegalArgumentException if {@code userHandle} is not a managed profile
  ///@see \#isQuietModeEnabled(UserHandle)
  bool requestQuietModeEnabled(
          bool enableQuietMode, userhandle_.UserHandle userHandle) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestQuietModeEnabled,
          jni.JniType.booleanType,
          [enableQuietMode, userHandle.reference]).boolean;

  static final _id_isQuietModeEnabled = jniAccessors.getMethodIDOf(
      _classRef, "isQuietModeEnabled", "(Landroid/os/UserHandle;)Z");

  /// from: public boolean isQuietModeEnabled(android.os.UserHandle userHandle)
  ///
  /// Returns whether the given profile is in quiet mode or not.
  /// Notes: Quiet mode is only supported for managed profiles.
  ///@param userHandle The user handle of the profile to be queried.
  ///@return true if the profile is in quiet mode, false otherwise.
  bool isQuietModeEnabled(userhandle_.UserHandle userHandle) =>
      jniAccessors.callMethodWithArgs(reference, _id_isQuietModeEnabled,
          jni.JniType.booleanType, [userHandle.reference]).boolean;

  static final _id_getApplicationRestrictions = jniAccessors.getMethodIDOf(
      _classRef,
      "getApplicationRestrictions",
      "(Ljava/lang/String;)Landroid/os/Bundle;");

  /// from: public android.os.Bundle getApplicationRestrictions(java.lang.String packageName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Bundle containing any saved application restrictions for this user, for the
  /// given package name. Only an application with this package name can call this method.
  ///
  /// The returned Bundle consists of key-value pairs, as defined by the application,
  /// where the types of values may be:
  /// <ul>
  /// <li>{@code boolean}
  /// <li>{@code int}
  /// <li>{@code String} or {@code String[]}
  /// <li>From android.os.Build.VERSION_CODES\#M, {@code Bundle} or {@code Bundle[]}
  /// </ul>
  ///
  /// NOTE: The method performs disk I/O and shouldn't be called on the main thread
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param packageName the package name of the calling application
  ///@return a Bundle with the restrictions for that package, or an empty Bundle
  /// if there are no saved restrictions.
  ///@see \#KEY_RESTRICTIONS_PENDING
  bundle_.Bundle getApplicationRestrictions(jni.JniString packageName) =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getApplicationRestrictions,
          jni.JniType.objectType,
          [packageName.reference]).object);

  static final _id_setRestrictionsChallenge = jniAccessors.getMethodIDOf(
      _classRef, "setRestrictionsChallenge", "(Ljava/lang/String;)Z");

  /// from: public boolean setRestrictionsChallenge(java.lang.String newPin)
  ///
  /// Sets a new challenge PIN for restrictions. This is only for use by pre-installed
  /// apps and requires the MANAGE_USERS permission.
  ///@param newPin the PIN to use for challenge dialogs.
  ///@return Returns true if the challenge PIN was set successfully.
  ///@deprecated The restrictions PIN functionality is no longer provided by the system.
  /// This method is preserved for backwards compatibility reasons and always returns false.
  bool setRestrictionsChallenge(jni.JniString newPin) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRestrictionsChallenge,
          jni.JniType.booleanType, [newPin.reference]).boolean;

  static final _id_getUserCreationTime = jniAccessors.getMethodIDOf(
      _classRef, "getUserCreationTime", "(Landroid/os/UserHandle;)J");

  /// from: public long getUserCreationTime(android.os.UserHandle userHandle)
  ///
  /// Returns creation time of the user or of a managed profile associated with the calling user.
  ///@param userHandle user handle of the user or a managed profile associated with the
  ///                   calling user.
  ///@return creation time in milliseconds since Epoch time.
  int getUserCreationTime(userhandle_.UserHandle userHandle) =>
      jniAccessors.callMethodWithArgs(reference, _id_getUserCreationTime,
          jni.JniType.longType, [userHandle.reference]).long;
}

/// from: android.os.UserManager$UserOperationException
///
/// Thrown to indicate user operation failed.
class UserManager_UserOperationException extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/os/UserManager\$UserOperationException");
  UserManager_UserOperationException.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/lang/String;I)V");

  /// from: void <init>(java.lang.String message, int userOperationResult)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a UserOperationException with specific result code.
  ///@param message the detail message
  ///@param userOperationResult the result code
  ///@hide
  UserManager_UserOperationException(
      jni.JniString message, int userOperationResult)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor,
            [message.reference, userOperationResult]).object);

  static final _id_getUserOperationResult =
      jniAccessors.getMethodIDOf(_classRef, "getUserOperationResult", "()I");

  /// from: public int getUserOperationResult()
  ///
  /// Returns the operation result code.
  ///@return Value is android.os.UserManager\#USER_OPERATION_SUCCESS, android.os.UserManager\#USER_OPERATION_ERROR_UNKNOWN, android.os.UserManager\#USER_OPERATION_ERROR_MANAGED_PROFILE, android.os.UserManager\#USER_OPERATION_ERROR_MAX_RUNNING_USERS, android.os.UserManager\#USER_OPERATION_ERROR_CURRENT_USER, android.os.UserManager\#USER_OPERATION_ERROR_LOW_STORAGE, or android.os.UserManager\#USER_OPERATION_ERROR_MAX_USERS
  int getUserOperationResult() => jniAccessors.callMethodWithArgs(
      reference, _id_getUserOperationResult, jni.JniType.intType, []).integer;
}
