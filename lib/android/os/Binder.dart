// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "UserHandle.dart" as userhandle_;

import "IInterface.dart" as iinterface_;

import "Parcel.dart" as parcel_;

import "IBinder.dart" as ibinder_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.Binder
///
/// Base class for a remotable object, the core part of a lightweight
/// remote procedure call mechanism defined by IBinder.
/// This class is an implementation of IBinder that provides
/// standard local implementation of such an object.
///
/// Most developers will not implement this class directly, instead using the
/// <a href="{@docRoot}guide/components/aidl.html">aidl</a> tool to describe the desired
/// interface, having it generate the appropriate Binder subclass.  You can,
/// however, derive directly from Binder to implement your own custom RPC
/// protocol or simply instantiate a raw Binder object directly to use as a
/// token that can be shared across processes.
///
/// This class is just a basic IPC primitive; it has no impact on an application's
/// lifecycle, and is valid only as long as the process that created it continues to run.
/// To use this correctly, you must be doing so within the context of a top-level
/// application component (a android.app.Service, android.app.Activity,
/// or android.content.ContentProvider) that lets the system know your process
/// should remain running.
///
///
/// You must keep in mind the situations in which your process
/// could go away, and thus require that you later re-create a new Binder and re-attach
/// it when the process starts again.  For example, if you are using this within an
/// android.app.Activity, your activity's process may be killed any time the
/// activity is not started; if the activity is later re-created you will need to
/// create a new Binder and hand it back to the correct place again; you need to be
/// aware that your process may be started for another reason (for example to receive
/// a broadcast) that will not involve re-creating the activity and thus run its code
/// to create a new Binder.
///
///@see IBinder
class Binder extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/Binder");
  Binder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Default constructor initializes the object.
  Binder()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getCallingPid =
      jniAccessors.getStaticMethodIDOf(_classRef, "getCallingPid", "()I");

  /// from: static public native final int getCallingPid()
  ///
  /// Return the ID of the process that sent you the current transaction
  /// that is being processed.  This pid can be used with higher-level
  /// system services to determine its identity and check permissions.
  /// If the current thread is not currently executing an incoming transaction,
  /// then its own pid is returned.
  static int getCallingPid() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getCallingPid, jni.JniType.intType, []).integer;

  static final _id_getCallingUid =
      jniAccessors.getStaticMethodIDOf(_classRef, "getCallingUid", "()I");

  /// from: static public native final int getCallingUid()
  ///
  /// Return the Linux uid assigned to the process that sent you the
  /// current transaction that is being processed.  This uid can be used with
  /// higher-level system services to determine its identity and check
  /// permissions.  If the current thread is not currently executing an
  /// incoming transaction, then its own uid is returned.
  static int getCallingUid() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getCallingUid, jni.JniType.intType, []).integer;

  static final _id_getCallingUserHandle = jniAccessors.getStaticMethodIDOf(
      _classRef, "getCallingUserHandle", "()Landroid/os/UserHandle;");

  /// from: static public final android.os.UserHandle getCallingUserHandle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the UserHandle assigned to the process that sent you the
  /// current transaction that is being processed.  This is the user
  /// of the caller.  It is distinct from \#getCallingUid() in that a
  /// particular user will have multiple distinct apps running under it each
  /// with their own uid.  If the current thread is not currently executing an
  /// incoming transaction, then its own UserHandle is returned.
  ///@return This value will never be {@code null}.
  static userhandle_.UserHandle getCallingUserHandle() =>
      userhandle_.UserHandle.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getCallingUserHandle,
          jni.JniType.objectType, []).object);

  static final _id_clearCallingIdentity = jniAccessors.getStaticMethodIDOf(
      _classRef, "clearCallingIdentity", "()J");

  /// from: static public native final long clearCallingIdentity()
  ///
  /// Reset the identity of the incoming IPC on the current thread.  This can
  /// be useful if, while handling an incoming call, you will be calling
  /// on interfaces of other objects that may be local to your process and
  /// need to do permission checks on the calls coming into them (so they
  /// will check the permission of your own local process, and not whatever
  /// process originally called you).
  ///@return Returns an opaque token that can be used to restore the
  /// original calling identity by passing it to
  /// \#restoreCallingIdentity(long).
  ///@see \#getCallingPid()
  ///@see \#getCallingUid()
  ///@see \#restoreCallingIdentity(long)
  static int clearCallingIdentity() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_clearCallingIdentity, jni.JniType.longType, []).long;

  static final _id_restoreCallingIdentity = jniAccessors.getStaticMethodIDOf(
      _classRef, "restoreCallingIdentity", "(J)V");

  /// from: static public native final void restoreCallingIdentity(long token)
  ///
  /// Restore the identity of the incoming IPC on the current thread
  /// back to a previously identity that was returned by \#clearCallingIdentity.
  ///@param token The opaque token that was previously returned by
  /// \#clearCallingIdentity.
  ///@see \#clearCallingIdentity
  static void restoreCallingIdentity(int token) =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_restoreCallingIdentity, jni.JniType.voidType, [token]).check();

  static final _id_flushPendingCommands = jniAccessors.getStaticMethodIDOf(
      _classRef, "flushPendingCommands", "()V");

  /// from: static public native final void flushPendingCommands()
  ///
  /// Flush any Binder commands pending in the current thread to the kernel
  /// driver.  This can be
  /// useful to call before performing an operation that may block for a long
  /// time, to ensure that any pending object references have been released
  /// in order to prevent the process from holding on to objects longer than
  /// it needs to.
  static void flushPendingCommands() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_flushPendingCommands, jni.JniType.voidType, []).check();

  static final _id_joinThreadPool =
      jniAccessors.getStaticMethodIDOf(_classRef, "joinThreadPool", "()V");

  /// from: static public final void joinThreadPool()
  ///
  /// Add the calling thread to the IPC thread pool.  This function does
  /// not return until the current process is exiting.
  static void joinThreadPool() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_joinThreadPool, jni.JniType.voidType, []).check();

  static final _id_attachInterface = jniAccessors.getMethodIDOf(_classRef,
      "attachInterface", "(Landroid/os/IInterface;Ljava/lang/String;)V");

  /// from: public void attachInterface(android.os.IInterface owner, java.lang.String descriptor)
  ///
  /// Convenience method for associating a specific interface with the Binder.
  /// After calling, queryLocalInterface() will be implemented for you
  /// to return the given owner IInterface when the corresponding
  /// descriptor is requested.
  ///@param owner This value may be {@code null}.
  ///@param descriptor This value may be {@code null}.
  void attachInterface(
          iinterface_.IInterface owner, jni.JniString descriptor) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_attachInterface,
          jni.JniType.voidType,
          [owner.reference, descriptor.reference]).check();

  static final _id_getInterfaceDescriptor = jniAccessors.getMethodIDOf(
      _classRef, "getInterfaceDescriptor", "()Ljava/lang/String;");

  /// from: public java.lang.String getInterfaceDescriptor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Default implementation returns an empty interface name.
  ///@return This value may be {@code null}.
  jni.JniString getInterfaceDescriptor() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getInterfaceDescriptor, jni.JniType.objectType, []).object);

  static final _id_pingBinder =
      jniAccessors.getMethodIDOf(_classRef, "pingBinder", "()Z");

  /// from: public boolean pingBinder()
  ///
  /// Default implementation always returns true -- if you got here,
  /// the object is alive.
  bool pingBinder() => jniAccessors.callMethodWithArgs(
      reference, _id_pingBinder, jni.JniType.booleanType, []).boolean;

  static final _id_isBinderAlive =
      jniAccessors.getMethodIDOf(_classRef, "isBinderAlive", "()Z");

  /// from: public boolean isBinderAlive()
  ///
  /// {@inheritDoc}
  ///
  /// Note that if you're calling on a local binder, this always returns true
  /// because your process is alive if you're calling it.
  bool isBinderAlive() => jniAccessors.callMethodWithArgs(
      reference, _id_isBinderAlive, jni.JniType.booleanType, []).boolean;

  static final _id_queryLocalInterface = jniAccessors.getMethodIDOf(_classRef,
      "queryLocalInterface", "(Ljava/lang/String;)Landroid/os/IInterface;");

  /// from: public android.os.IInterface queryLocalInterface(java.lang.String descriptor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Use information supplied to attachInterface() to return the
  /// associated IInterface if it matches the requested
  /// descriptor.
  ///@param descriptor This value must never be {@code null}.
  ///@return This value may be {@code null}.
  iinterface_.IInterface queryLocalInterface(jni.JniString descriptor) =>
      iinterface_.IInterface.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryLocalInterface,
          jni.JniType.objectType,
          [descriptor.reference]).object);

  static final _id_onTransact = jniAccessors.getMethodIDOf(
      _classRef, "onTransact", "(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z");

  /// from: protected boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)
  ///
  /// Default implementation is a stub that returns false.  You will want
  /// to override this to do the appropriate unmarshalling of transactions.
  ///
  /// If you want to call this, call transact().
  ///
  /// Implementations that are returning a result should generally use
  /// Parcel\#writeNoException() Parcel.writeNoException and
  /// Parcel\#writeException(Exception) Parcel.writeException to propagate
  /// exceptions back to the caller.
  ///
  ///@param code The action to perform.  This should
  /// be a number between \#FIRST_CALL_TRANSACTION and
  /// \#LAST_CALL_TRANSACTION.
  ///@param data Marshalled data being received from the caller.
  /// This value must never be {@code null}.
  ///@param reply If the caller is expecting a result back, it should be marshalled
  /// in to here.
  /// This value may be {@code null}.
  ///@param flags Additional operation flags.  Either 0 for a normal
  /// RPC, or \#FLAG_ONEWAY for a one-way RPC.
  ///@return Return true on a successful call; returning false is generally used to
  /// indicate that you did not understand the transaction code.
  bool onTransact(
          int code, parcel_.Parcel data, parcel_.Parcel reply, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onTransact,
          jni.JniType.booleanType,
          [code, data.reference, reply.reference, flags]).boolean;

  static final _id_dump = jniAccessors.getMethodIDOf(
      _classRef, "dump", "(Ljava/io/FileDescriptor;[Ljava/lang/String;)V");

  /// from: public void dump(java.io.FileDescriptor fd, java.lang.String[] args)
  ///
  /// Implemented to call the more convenient version
  /// \#dump(FileDescriptor, PrintWriter, String[]).
  ///@param fd This value must never be {@code null}.
  ///@param args This value may be {@code null}.
  void dump(jni.JniObject fd, jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(reference, _id_dump, jni.JniType.voidType,
          [fd.reference, args.reference]).check();

  static final _id_dumpAsync = jniAccessors.getMethodIDOf(
      _classRef, "dumpAsync", "(Ljava/io/FileDescriptor;[Ljava/lang/String;)V");

  /// from: public void dumpAsync(java.io.FileDescriptor fd, java.lang.String[] args)
  ///
  /// Like \#dump(FileDescriptor, String[]), but ensures the target
  /// executes asynchronously.
  ///@param fd This value must never be {@code null}.
  ///@param args This value may be {@code null}.
  void dumpAsync(jni.JniObject fd, jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(reference, _id_dumpAsync,
          jni.JniType.voidType, [fd.reference, args.reference]).check();

  static final _id_dump1 = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: protected void dump(java.io.FileDescriptor fd, java.io.PrintWriter fout, java.lang.String[] args)
  ///
  /// Print the object's state into the given stream.
  ///@param fd The raw file descriptor that the dump is being sent to.
  /// This value must never be {@code null}.
  ///@param fout The file to which you should dump your state.  This will be
  /// closed for you after you return.
  /// This value must never be {@code null}.
  ///@param args additional arguments to the dump request.
  ///
  /// This value may be {@code null}.
  void dump1(jni.JniObject fd, jni.JniObject fout, jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dump1,
          jni.JniType.voidType,
          [fd.reference, fout.reference, args.reference]).check();

  static final _id_transact = jniAccessors.getMethodIDOf(
      _classRef, "transact", "(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z");

  /// from: public final boolean transact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)
  ///
  /// Default implementation rewinds the parcels and calls onTransact.  On
  /// the remote side, transact calls into the binder to do the IPC.
  ///@param data This value must never be {@code null}.
  ///@param reply This value may be {@code null}.
  bool transact(
          int code, parcel_.Parcel data, parcel_.Parcel reply, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_transact,
          jni.JniType.booleanType,
          [code, data.reference, reply.reference, flags]).boolean;

  static final _id_linkToDeath = jniAccessors.getMethodIDOf(
      _classRef, "linkToDeath", "(Landroid/os/IBinder\$DeathRecipient;I)V");

  /// from: public void linkToDeath(android.os.IBinder.DeathRecipient recipient, int flags)
  ///
  /// Local implementation is a no-op.
  ///@param recipient This value must never be {@code null}.
  void linkToDeath(ibinder_.IBinder_DeathRecipient recipient, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_linkToDeath,
          jni.JniType.voidType, [recipient.reference, flags]).check();

  static final _id_unlinkToDeath = jniAccessors.getMethodIDOf(
      _classRef, "unlinkToDeath", "(Landroid/os/IBinder\$DeathRecipient;I)Z");

  /// from: public boolean unlinkToDeath(android.os.IBinder.DeathRecipient recipient, int flags)
  ///
  /// Local implementation is a no-op.
  ///@param recipient This value must never be {@code null}.
  bool unlinkToDeath(ibinder_.IBinder_DeathRecipient recipient, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_unlinkToDeath,
          jni.JniType.booleanType, [recipient.reference, flags]).boolean;
}
