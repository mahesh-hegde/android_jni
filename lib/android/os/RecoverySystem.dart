// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.RecoverySystem
///
/// RecoverySystem contains methods for interacting with the Android
/// recovery system (the separate partition that can be used to install
/// system updates, wipe user data, etc.)
class RecoverySystem extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/RecoverySystem");
  RecoverySystem.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @removed Was previously made visible by accident.
  RecoverySystem()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_verifyPackage = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "verifyPackage",
      "(Ljava/io/File;Landroid/os/RecoverySystem\$ProgressListener;Ljava/io/File;)V");

  /// from: static public void verifyPackage(java.io.File packageFile, android.os.RecoverySystem.ProgressListener listener, java.io.File deviceCertsZipFile)
  ///
  /// Verify the cryptographic signature of a system update package
  /// before installing it.  Note that the package is also verified
  /// separately by the installer once the device is rebooted into
  /// the recovery system.  This function will return only if the
  /// package was successfully verified; otherwise it will throw an
  /// exception.
  ///
  /// Verification of a package can take significant time, so this
  /// function should not be called from a UI thread.  Interrupting
  /// the thread while this function is in progress will result in a
  /// SecurityException being thrown (and the thread's interrupt flag
  /// will be cleared).
  ///@param packageFile the package to be verified
  ///@param listener an object to receive periodic progress
  /// updates as verification proceeds.  May be null.
  ///@param deviceCertsZipFile the zip file of certificates whose
  /// public keys we will accept.  Verification succeeds if the
  /// package is signed by the private key corresponding to any
  /// public key in this file.  May be null to use the system default
  /// file (currently "/system/etc/security/otacerts.zip").
  ///@throws IOException if there were any errors reading the
  /// package or certs files.
  ///@throws GeneralSecurityException if verification failed
  static void verifyPackage(
          jni.JniObject packageFile,
          RecoverySystem_ProgressListener listener,
          jni.JniObject deviceCertsZipFile) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_verifyPackage, jni.JniType.voidType, [
        packageFile.reference,
        listener.reference,
        deviceCertsZipFile.reference
      ]).check();

  static final _id_installPackage = jniAccessors.getStaticMethodIDOf(_classRef,
      "installPackage", "(Landroid/content/Context;Ljava/io/File;)V");

  /// from: static public void installPackage(android.content.Context context, java.io.File packageFile)
  ///
  /// Reboots the device in order to install the given update
  /// package.
  /// Requires the android.Manifest.permission\#REBOOT permission.
  ///
  /// Requires android.Manifest.permission\#RECOVERY
  ///@param context the Context to use
  ///@param packageFile the update package to install.  Must be on
  /// a partition mountable by recovery.  (The set of partitions
  /// known to recovery may vary from device to device.  Generally,
  /// /cache and /data are safe.)
  ///@throws IOException if writing the recovery command file
  /// fails, or if the reboot itself fails.
  static void installPackage(
          context_.Context context, jni.JniObject packageFile) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_installPackage,
          jni.JniType.voidType,
          [context.reference, packageFile.reference]).check();

  static final _id_rebootWipeUserData = jniAccessors.getStaticMethodIDOf(
      _classRef, "rebootWipeUserData", "(Landroid/content/Context;)V");

  /// from: static public void rebootWipeUserData(android.content.Context context)
  ///
  /// Reboots the device and wipes the user data and cache
  /// partitions.  This is sometimes called a "factory reset", which
  /// is something of a misnomer because the system partition is not
  /// restored to its factory state.  Requires the
  /// android.Manifest.permission\#REBOOT permission.
  ///@param context the Context to use
  ///@throws IOException if writing the recovery command file
  /// fails, or if the reboot itself fails.
  ///@throws SecurityException if the current user is not allowed to wipe data.
  static void rebootWipeUserData(context_.Context context) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_rebootWipeUserData,
          jni.JniType.voidType, [context.reference]).check();

  static final _id_rebootWipeCache = jniAccessors.getStaticMethodIDOf(
      _classRef, "rebootWipeCache", "(Landroid/content/Context;)V");

  /// from: static public void rebootWipeCache(android.content.Context context)
  ///
  /// Reboot into the recovery system to wipe the /cache partition.
  ///@throws IOException if something goes wrong.
  static void rebootWipeCache(context_.Context context) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_rebootWipeCache,
          jni.JniType.voidType, [context.reference]).check();
}

/// from: android.os.RecoverySystem$ProgressListener
///
/// Interface definition for a callback to be invoked regularly as
/// verification proceeds.
class RecoverySystem_ProgressListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/os/RecoverySystem\$ProgressListener");
  RecoverySystem_ProgressListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onProgress =
      jniAccessors.getMethodIDOf(_classRef, "onProgress", "(I)V");

  /// from: public abstract void onProgress(int progress)
  ///
  /// Called periodically as the verification progresses.
  ///@param progress the approximate percentage of the
  ///        verification that has been completed, ranging from 0
  ///        to 100 (inclusive).
  void onProgress(int progress) => jniAccessors.callMethodWithArgs(
      reference, _id_onProgress, jni.JniType.voidType, [progress]).check();
}
