// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "IInterface.dart" as iinterface_;

import "Parcel.dart" as parcel_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.IBinder
///
/// Base interface for a remotable object, the core part of a lightweight
/// remote procedure call mechanism designed for high performance when
/// performing in-process and cross-process calls.  This
/// interface describes the abstract protocol for interacting with a
/// remotable object.  Do not implement this interface directly, instead
/// extend from Binder.
///
/// The key IBinder API is \#transact transact() matched by
/// Binder\#onTransact Binder.onTransact().  These
/// methods allow you to send a call to an IBinder object and receive a
/// call coming in to a Binder object, respectively.  This transaction API
/// is synchronous, such that a call to \#transact transact() does not
/// return until the target has returned from
/// Binder\#onTransact Binder.onTransact(); this is the
/// expected behavior when calling an object that exists in the local
/// process, and the underlying inter-process communication (IPC) mechanism
/// ensures that these same semantics apply when going across processes.
///
/// The data sent through transact() is a Parcel, a generic buffer
/// of data that also maintains some meta-data about its contents.  The meta
/// data is used to manage IBinder object references in the buffer, so that those
/// references can be maintained as the buffer moves across processes.  This
/// mechanism ensures that when an IBinder is written into a Parcel and sent to
/// another process, if that other process sends a reference to that same IBinder
/// back to the original process, then the original process will receive the
/// same IBinder object back.  These semantics allow IBinder/Binder objects to
/// be used as a unique identity (to serve as a token or for other purposes)
/// that can be managed across processes.
///
/// The system maintains a pool of transaction threads in each process that
/// it runs in.  These threads are used to dispatch all
/// IPCs coming in from other processes.  For example, when an IPC is made from
/// process A to process B, the calling thread in A blocks in transact() as
/// it sends the transaction to process B.  The next available pool thread in
/// B receives the incoming transaction, calls Binder.onTransact() on the target
/// object, and replies with the result Parcel.  Upon receiving its result, the
/// thread in process A returns to allow its execution to continue.  In effect,
/// other processes appear to use as additional threads that you did not create
/// executing in your own process.
///
/// The Binder system also supports recursion across processes.  For example
/// if process A performs a transaction to process B, and process B while
/// handling that transaction calls transact() on an IBinder that is implemented
/// in A, then the thread in A that is currently waiting for the original
/// transaction to finish will take care of calling Binder.onTransact() on the
/// object being called by B.  This ensures that the recursion semantics when
/// calling remote binder object are the same as when calling local objects.
///
/// When working with remote objects, you often want to find out when they
/// are no longer valid.  There are three ways this can be determined:
/// <ul>
/// <li> The \#transact transact() method will throw a
/// RemoteException exception if you try to call it on an IBinder
/// whose process no longer exists.
/// <li> The \#pingBinder() method can be called, and will return false
/// if the remote process no longer exists.
/// <li> The \#linkToDeath linkToDeath() method can be used to register
/// a DeathRecipient with the IBinder, which will be called when its
/// containing process goes away.
/// </ul>
///@see Binder
class IBinder extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/IBinder");
  IBinder.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DUMP_TRANSACTION
  ///
  /// IBinder protocol transaction code: dump internal state.
  static const DUMP_TRANSACTION = 1598311760;

  /// from: static public final int FIRST_CALL_TRANSACTION
  ///
  /// The first transaction code available for user commands.
  static const FIRST_CALL_TRANSACTION = 1;

  /// from: static public final int FLAG_ONEWAY
  ///
  /// Flag to \#transact: this is a one-way call, meaning that the
  /// caller returns immediately, without waiting for a result from the
  /// callee. Applies only if the caller and callee are in different
  /// processes.
  ///
  /// The system provides special ordering semantics for multiple oneway calls
  /// being made to the same IBinder object: these calls will be dispatched in the
  /// other process one at a time, with the same order as the original calls.  These
  /// are still dispatched by the IPC thread pool, so may execute on different threads,
  /// but the next one will not be dispatched until the previous one completes.  This
  /// ordering is not guaranteed for calls on different IBinder objects or when mixing
  /// oneway and non-oneway calls on the same IBinder object.
  ///
  static const FLAG_ONEWAY = 1;

  /// from: static public final int INTERFACE_TRANSACTION
  ///
  /// IBinder protocol transaction code: interrogate the recipient side
  /// of the transaction for its canonical interface descriptor.
  static const INTERFACE_TRANSACTION = 1598968902;

  /// from: static public final int LAST_CALL_TRANSACTION
  ///
  /// The last transaction code available for user commands.
  static const LAST_CALL_TRANSACTION = 16777215;

  /// from: static public final int LIKE_TRANSACTION
  ///
  /// IBinder protocol transaction code: tell an app asynchronously that the
  /// caller likes it.  The app is responsible for incrementing and maintaining
  /// its own like counter, and may display this value to the user to indicate the
  /// quality of the app.  This is an optional command that applications do not
  /// need to handle, so the default implementation is to do nothing.
  ///
  /// There is no response returned and nothing about the
  /// system will be functionally affected by it, but it will improve the
  /// app's self-esteem.
  static const LIKE_TRANSACTION = 1598835019;

  /// from: static public final int PING_TRANSACTION
  ///
  /// IBinder protocol transaction code: pingBinder().
  static const PING_TRANSACTION = 1599098439;

  /// from: static public final int TWEET_TRANSACTION
  ///
  /// IBinder protocol transaction code: send a tweet to the target
  /// object.  The data in the parcel is intended to be delivered to
  /// a shared messaging service associated with the object; it can be
  /// anything, as long as it is not more than 130 UTF-8 characters to
  /// conservatively fit within common messaging services.  As part of
  /// Build.VERSION_CODES\#HONEYCOMB_MR2, all Binder objects are
  /// expected to support this protocol for fully integrated tweeting
  /// across the platform.  To support older code, the default implementation
  /// logs the tweet to the main log as a simple emulation of broadcasting
  /// it publicly over the Internet.
  ///
  /// Also, upon completing the dispatch, the object must make a cup
  /// of tea, return it to the caller, and exclaim "jolly good message
  /// old boy!".
  static const TWEET_TRANSACTION = 1599362900;

  static final _id_getInterfaceDescriptor = jniAccessors.getMethodIDOf(
      _classRef, "getInterfaceDescriptor", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getInterfaceDescriptor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the canonical name of the interface supported by this binder.
  ///@return This value may be {@code null}.
  jni.JniString getInterfaceDescriptor() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getInterfaceDescriptor, jni.JniType.objectType, []).object);

  static final _id_pingBinder =
      jniAccessors.getMethodIDOf(_classRef, "pingBinder", "()Z");

  /// from: public abstract boolean pingBinder()
  ///
  /// Check to see if the object still exists.
  ///@return Returns false if the
  /// hosting process is gone, otherwise the result (always by default
  /// true) returned by the pingBinder() implementation on the other
  /// side.
  bool pingBinder() => jniAccessors.callMethodWithArgs(
      reference, _id_pingBinder, jni.JniType.booleanType, []).boolean;

  static final _id_isBinderAlive =
      jniAccessors.getMethodIDOf(_classRef, "isBinderAlive", "()Z");

  /// from: public abstract boolean isBinderAlive()
  ///
  /// Check to see if the process that the binder is in is still alive.
  ///@return false if the process is not alive.  Note that if it returns
  /// true, the process may have died while the call is returning.
  bool isBinderAlive() => jniAccessors.callMethodWithArgs(
      reference, _id_isBinderAlive, jni.JniType.booleanType, []).boolean;

  static final _id_queryLocalInterface = jniAccessors.getMethodIDOf(_classRef,
      "queryLocalInterface", "(Ljava/lang/String;)Landroid/os/IInterface;");

  /// from: public abstract android.os.IInterface queryLocalInterface(java.lang.String descriptor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Attempt to retrieve a local implementation of an interface
  /// for this Binder object.  If null is returned, you will need
  /// to instantiate a proxy class to marshall calls through
  /// the transact() method.
  ///@param descriptor This value must never be {@code null}.
  iinterface_.IInterface queryLocalInterface(jni.JniString descriptor) =>
      iinterface_.IInterface.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_queryLocalInterface,
          jni.JniType.objectType,
          [descriptor.reference]).object);

  static final _id_dump = jniAccessors.getMethodIDOf(
      _classRef, "dump", "(Ljava/io/FileDescriptor;[Ljava/lang/String;)V");

  /// from: public abstract void dump(java.io.FileDescriptor fd, java.lang.String[] args)
  ///
  /// Print the object's state into the given stream.
  ///@param fd The raw file descriptor that the dump is being sent to.
  /// This value must never be {@code null}.
  ///@param args additional arguments to the dump request.
  ///
  /// This value may be {@code null}.
  void dump(jni.JniObject fd, jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(reference, _id_dump, jni.JniType.voidType,
          [fd.reference, args.reference]).check();

  static final _id_dumpAsync = jniAccessors.getMethodIDOf(
      _classRef, "dumpAsync", "(Ljava/io/FileDescriptor;[Ljava/lang/String;)V");

  /// from: public abstract void dumpAsync(java.io.FileDescriptor fd, java.lang.String[] args)
  ///
  /// Like \#dump(FileDescriptor, String[]) but always executes
  /// asynchronously.  If the object is local, a new thread is created
  /// to perform the dump.
  ///@param fd The raw file descriptor that the dump is being sent to.
  /// This value must never be {@code null}.
  ///@param args additional arguments to the dump request.
  ///
  /// This value may be {@code null}.
  void dumpAsync(jni.JniObject fd, jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(reference, _id_dumpAsync,
          jni.JniType.voidType, [fd.reference, args.reference]).check();

  static final _id_transact = jniAccessors.getMethodIDOf(
      _classRef, "transact", "(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z");

  /// from: public abstract boolean transact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)
  ///
  /// Perform a generic operation with the object.
  ///@param code The action to perform.  This should
  /// be a number between \#FIRST_CALL_TRANSACTION and
  /// \#LAST_CALL_TRANSACTION.
  ///@param data Marshalled data to send to the target.  Must not be null.
  /// If you are not sending any data, you must create an empty Parcel
  /// that is given here.
  /// This value must never be {@code null}.
  ///@param reply Marshalled data to be received from the target.  May be
  /// null if you are not interested in the return value.
  /// This value may be {@code null}.
  ///@param flags Additional operation flags.  Either 0 for a normal
  /// RPC, or \#FLAG_ONEWAY for a one-way RPC.
  ///@return Returns the result from Binder\#onTransact.  A successful call
  /// generally returns true; false generally means the transaction code was not
  /// understood.
  bool transact(
          int code, parcel_.Parcel data, parcel_.Parcel reply, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_transact,
          jni.JniType.booleanType,
          [code, data.reference, reply.reference, flags]).boolean;

  static final _id_linkToDeath = jniAccessors.getMethodIDOf(
      _classRef, "linkToDeath", "(Landroid/os/IBinder\$DeathRecipient;I)V");

  /// from: public abstract void linkToDeath(android.os.IBinder.DeathRecipient recipient, int flags)
  ///
  /// Register the recipient for a notification if this binder
  /// goes away.  If this binder object unexpectedly goes away
  /// (typically because its hosting process has been killed),
  /// then the given DeathRecipient's
  /// DeathRecipient\#binderDied DeathRecipient.binderDied() method
  /// will be called.
  ///
  /// You will only receive death notifications for remote binders,
  /// as local binders by definition can't die without you dying as well.
  ///@throws RemoteException if the target IBinder's
  /// process has already died.
  ///@see \#unlinkToDeath
  ///@param recipient This value must never be {@code null}.
  void linkToDeath(IBinder_DeathRecipient recipient, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_linkToDeath,
          jni.JniType.voidType, [recipient.reference, flags]).check();

  static final _id_unlinkToDeath = jniAccessors.getMethodIDOf(
      _classRef, "unlinkToDeath", "(Landroid/os/IBinder\$DeathRecipient;I)Z");

  /// from: public abstract boolean unlinkToDeath(android.os.IBinder.DeathRecipient recipient, int flags)
  ///
  /// Remove a previously registered death notification.
  /// The recipient will no longer be called if this object
  /// dies.
  ///@param recipient This value must never be {@code null}.
  ///@return {@code true} if the <var>recipient</var> is successfully
  /// unlinked, assuring you that its
  /// DeathRecipient\#binderDied DeathRecipient.binderDied() method
  /// will not be called;  {@code false} if the target IBinder has already
  /// died, meaning the method has been (or soon will be) called.
  ///@throws java.util.NoSuchElementException if the given
  /// <var>recipient</var> has not been registered with the IBinder, and
  /// the IBinder is still alive.  Note that if the <var>recipient</var>
  /// was never registered, but the IBinder has already died, then this
  /// exception will _not_ be thrown, and you will receive a false
  /// return value instead.
  bool unlinkToDeath(IBinder_DeathRecipient recipient, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_unlinkToDeath,
          jni.JniType.booleanType, [recipient.reference, flags]).boolean;
}

/// from: android.os.IBinder$DeathRecipient
///
/// Interface for receiving a callback when the process hosting an IBinder
/// has gone away.
///@see \#linkToDeath
class IBinder_DeathRecipient extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/os/IBinder\$DeathRecipient");
  IBinder_DeathRecipient.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_binderDied =
      jniAccessors.getMethodIDOf(_classRef, "binderDied", "()V");

  /// from: public abstract void binderDied()
  void binderDied() => jniAccessors.callMethodWithArgs(
      reference, _id_binderDied, jni.JniType.voidType, []).check();
}
