// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Looper.dart" as looper_;

import "Message.dart" as message_;

import "../util/Printer.dart" as printer_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.Handler
///
/// A Handler allows you to send and process Message and Runnable
/// objects associated with a thread's MessageQueue.  Each Handler
/// instance is associated with a single thread and that thread's message
/// queue.  When you create a new Handler, it is bound to the thread /
/// message queue of the thread that is creating it -- from that point on,
/// it will deliver messages and runnables to that message queue and execute
/// them as they come out of the message queue.
///
/// There are two main uses for a Handler: (1) to schedule messages and
/// runnables to be executed as some point in the future; and (2) to enqueue
/// an action to be performed on a different thread than your own.
///
/// Scheduling messages is accomplished with the
/// \#post, \#postAtTime(Runnable, long),
/// \#postDelayed, \#sendEmptyMessage,
/// \#sendMessage, \#sendMessageAtTime, and
/// \#sendMessageDelayed methods.  The _post_ versions allow
/// you to enqueue Runnable objects to be called by the message queue when
/// they are received; the _sendMessage_ versions allow you to enqueue
/// a Message object containing a bundle of data that will be
/// processed by the Handler's \#handleMessage method (requiring that
/// you implement a subclass of Handler).
///
/// When posting or sending to a Handler, you can either
/// allow the item to be processed as soon as the message queue is ready
/// to do so, or specify a delay before it gets processed or absolute time for
/// it to be processed.  The latter two allow you to implement timeouts,
/// ticks, and other timing-based behavior.
///
/// When a
/// process is created for your application, its main thread is dedicated to
/// running a message queue that takes care of managing the top-level
/// application objects (activities, broadcast receivers, etc) and any windows
/// they create.  You can create your own threads, and communicate back with
/// the main application thread through a Handler.  This is done by calling
/// the same _post_ or _sendMessage_ methods as before, but from
/// your new thread.  The given Runnable or Message will then be scheduled
/// in the Handler's message queue and processed when appropriate.
class Handler extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/Handler");
  Handler.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Default constructor associates this handler with the Looper for the
  /// current thread.
  ///
  /// If this thread does not have a looper, this handler won't be able to receive messages
  /// so an exception is thrown.
  Handler()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/os/Handler\$Callback;)V");

  /// from: public void <init>(android.os.Handler.Callback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor associates this handler with the Looper for the
  /// current thread and takes a callback interface in which you can handle
  /// messages.
  ///
  /// If this thread does not have a looper, this handler won't be able to receive messages
  /// so an exception is thrown.
  ///@param callback The callback interface in which to handle messages, or null.
  Handler.ctor1(Handler_Callback callback)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [callback.reference]).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Landroid/os/Looper;)V");

  /// from: public void <init>(android.os.Looper looper)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Use the provided Looper instead of the default one.
  ///@param looper The looper, must not be null.
  Handler.ctor2(looper_.Looper looper)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor2, [looper.reference]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/os/Looper;Landroid/os/Handler\$Callback;)V");

  /// from: public void <init>(android.os.Looper looper, android.os.Handler.Callback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Use the provided Looper instead of the default one and take a callback
  /// interface in which to handle messages.
  ///@param looper The looper, must not be null.
  ///@param callback The callback interface in which to handle messages, or null.
  Handler.ctor3(looper_.Looper looper, Handler_Callback callback)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3,
            [looper.reference, callback.reference]).object);

  static final _id_handleMessage = jniAccessors.getMethodIDOf(
      _classRef, "handleMessage", "(Landroid/os/Message;)V");

  /// from: public void handleMessage(android.os.Message msg)
  ///
  /// Subclasses must implement this to receive messages.
  void handleMessage(message_.Message msg) => jniAccessors.callMethodWithArgs(
      reference,
      _id_handleMessage,
      jni.JniType.voidType,
      [msg.reference]).check();

  static final _id_dispatchMessage = jniAccessors.getMethodIDOf(
      _classRef, "dispatchMessage", "(Landroid/os/Message;)V");

  /// from: public void dispatchMessage(android.os.Message msg)
  ///
  /// Handle system messages here.
  void dispatchMessage(message_.Message msg) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchMessage,
      jni.JniType.voidType,
      [msg.reference]).check();

  static final _id_createAsync = jniAccessors.getStaticMethodIDOf(
      _classRef, "createAsync", "(Landroid/os/Looper;)Landroid/os/Handler;");

  /// from: static public android.os.Handler createAsync(android.os.Looper looper)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new Handler whose posted messages and runnables are not subject to
  /// synchronization barriers such as display vsync.
  ///
  /// Messages sent to an async handler are guaranteed to be ordered with respect to one another,
  /// but not necessarily with respect to messages from other Handlers.
  ///
  ///@see \#createAsync(Looper, Callback) to create an async Handler with custom message handling.
  ///@param looper the Looper that the new Handler should be bound to
  /// This value must never be {@code null}.
  ///@return a new async Handler instance
  ///
  /// This value will never be {@code null}.
  static Handler createAsync(looper_.Looper looper) =>
      Handler.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_createAsync, jni.JniType.objectType, [looper.reference]).object);

  static final _id_createAsync1 = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createAsync",
      "(Landroid/os/Looper;Landroid/os/Handler\$Callback;)Landroid/os/Handler;");

  /// from: static public android.os.Handler createAsync(android.os.Looper looper, android.os.Handler.Callback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new Handler whose posted messages and runnables are not subject to
  /// synchronization barriers such as display vsync.
  ///
  /// Messages sent to an async handler are guaranteed to be ordered with respect to one another,
  /// but not necessarily with respect to messages from other Handlers.
  ///
  ///@see \#createAsync(Looper) to create an async Handler without custom message handling.
  ///@param looper the Looper that the new Handler should be bound to
  /// This value must never be {@code null}.
  ///@param callback This value must never be {@code null}.
  ///@return a new async Handler instance
  ///
  /// This value will never be {@code null}.
  static Handler createAsync1(
          looper_.Looper looper, Handler_Callback callback) =>
      Handler.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createAsync1,
          jni.JniType.objectType,
          [looper.reference, callback.reference]).object);

  static final _id_getMessageName = jniAccessors.getMethodIDOf(
      _classRef, "getMessageName", "(Landroid/os/Message;)Ljava/lang/String;");

  /// from: public java.lang.String getMessageName(android.os.Message message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a string representing the name of the specified message.
  /// The default implementation will either return the class name of the
  /// message callback if any, or the hexadecimal representation of the
  /// message "what" field.
  ///@param message The message whose name is being queried
  jni.JniString getMessageName(message_.Message message) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getMessageName,
          jni.JniType.objectType,
          [message.reference]).object);

  static final _id_obtainMessage = jniAccessors.getMethodIDOf(
      _classRef, "obtainMessage", "()Landroid/os/Message;");

  /// from: public final android.os.Message obtainMessage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a new android.os.Message Message from the global message pool. More efficient than
  /// creating and allocating new instances. The retrieved message has its handler set to this instance (Message.target == this).
  ///  If you don't want that facility, just call Message.obtain() instead.
  message_.Message obtainMessage() =>
      message_.Message.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_obtainMessage, jni.JniType.objectType, []).object);

  static final _id_obtainMessage1 = jniAccessors.getMethodIDOf(
      _classRef, "obtainMessage", "(I)Landroid/os/Message;");

  /// from: public final android.os.Message obtainMessage(int what)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Same as \#obtainMessage(), except that it also sets the what member of the returned Message.
  ///@param what Value to assign to the returned Message.what field.
  ///@return A Message from the global message pool.
  message_.Message obtainMessage1(int what) =>
      message_.Message.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_obtainMessage1, jni.JniType.objectType, [what]).object);

  static final _id_obtainMessage2 = jniAccessors.getMethodIDOf(
      _classRef, "obtainMessage", "(ILjava/lang/Object;)Landroid/os/Message;");

  /// from: public final android.os.Message obtainMessage(int what, java.lang.Object obj)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Same as \#obtainMessage(), except that it also sets the what and obj members
  /// of the returned Message.
  ///@param what Value to assign to the returned Message.what field.
  ///@param obj Value to assign to the returned Message.obj field.
  ///@return A Message from the global message pool.
  message_.Message obtainMessage2(int what, jni.JniObject obj) =>
      message_.Message.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_obtainMessage2,
          jni.JniType.objectType,
          [what, obj.reference]).object);

  static final _id_obtainMessage3 = jniAccessors.getMethodIDOf(
      _classRef, "obtainMessage", "(III)Landroid/os/Message;");

  /// from: public final android.os.Message obtainMessage(int what, int arg1, int arg2)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Same as \#obtainMessage(), except that it also sets the what, arg1 and arg2 members of the returned
  /// Message.
  ///@param what Value to assign to the returned Message.what field.
  ///@param arg1 Value to assign to the returned Message.arg1 field.
  ///@param arg2 Value to assign to the returned Message.arg2 field.
  ///@return A Message from the global message pool.
  message_.Message obtainMessage3(int what, int arg1, int arg2) =>
      message_.Message.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_obtainMessage3,
          jni.JniType.objectType,
          [what, arg1, arg2]).object);

  static final _id_obtainMessage4 = jniAccessors.getMethodIDOf(_classRef,
      "obtainMessage", "(IIILjava/lang/Object;)Landroid/os/Message;");

  /// from: public final android.os.Message obtainMessage(int what, int arg1, int arg2, java.lang.Object obj)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Same as \#obtainMessage(), except that it also sets the what, obj, arg1,and arg2 values on the
  /// returned Message.
  ///@param what Value to assign to the returned Message.what field.
  ///@param arg1 Value to assign to the returned Message.arg1 field.
  ///@param arg2 Value to assign to the returned Message.arg2 field.
  ///@param obj Value to assign to the returned Message.obj field.
  ///@return A Message from the global message pool.
  message_.Message obtainMessage4(
          int what, int arg1, int arg2, jni.JniObject obj) =>
      message_.Message.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_obtainMessage4,
          jni.JniType.objectType,
          [what, arg1, arg2, obj.reference]).object);

  static final _id_post =
      jniAccessors.getMethodIDOf(_classRef, "post", "(Ljava/lang/Runnable;)Z");

  /// from: public final boolean post(java.lang.Runnable r)
  ///
  /// Causes the Runnable r to be added to the message queue.
  /// The runnable will be run on the thread to which this handler is
  /// attached.
  ///@param r The Runnable that will be executed.
  ///@return Returns true if the Runnable was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.
  bool post(jni.JniObject r) => jniAccessors.callMethodWithArgs(
      reference, _id_post, jni.JniType.booleanType, [r.reference]).boolean;

  static final _id_postAtTime = jniAccessors.getMethodIDOf(
      _classRef, "postAtTime", "(Ljava/lang/Runnable;J)Z");

  /// from: public final boolean postAtTime(java.lang.Runnable r, long uptimeMillis)
  ///
  /// Causes the Runnable r to be added to the message queue, to be run
  /// at a specific time given by <var>uptimeMillis</var>.
  /// __The time-base is android.os.SystemClock\#uptimeMillis.__
  /// Time spent in deep sleep will add an additional delay to execution.
  /// The runnable will be run on the thread to which this handler is attached.
  ///@param r The Runnable that will be executed.
  ///@param uptimeMillis The absolute time at which the callback should run,
  ///         using the android.os.SystemClock\#uptimeMillis time-base.
  ///@return Returns true if the Runnable was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.  Note that a
  ///         result of true does not mean the Runnable will be processed -- if
  ///         the looper is quit before the delivery time of the message
  ///         occurs then the message will be dropped.
  bool postAtTime(jni.JniObject r, int uptimeMillis) =>
      jniAccessors.callMethodWithArgs(reference, _id_postAtTime,
          jni.JniType.booleanType, [r.reference, uptimeMillis]).boolean;

  static final _id_postAtTime1 = jniAccessors.getMethodIDOf(
      _classRef, "postAtTime", "(Ljava/lang/Runnable;Ljava/lang/Object;J)Z");

  /// from: public final boolean postAtTime(java.lang.Runnable r, java.lang.Object token, long uptimeMillis)
  ///
  /// Causes the Runnable r to be added to the message queue, to be run
  /// at a specific time given by <var>uptimeMillis</var>.
  /// __The time-base is android.os.SystemClock\#uptimeMillis.__
  /// Time spent in deep sleep will add an additional delay to execution.
  /// The runnable will be run on the thread to which this handler is attached.
  ///@param r The Runnable that will be executed.
  ///@param token An instance which can be used to cancel {@code r} via
  ///         \#removeCallbacksAndMessages.
  ///@param uptimeMillis The absolute time at which the callback should run,
  ///         using the android.os.SystemClock\#uptimeMillis time-base.
  ///@return Returns true if the Runnable was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.  Note that a
  ///         result of true does not mean the Runnable will be processed -- if
  ///         the looper is quit before the delivery time of the message
  ///         occurs then the message will be dropped.
  ///@see android.os.SystemClock\#uptimeMillis
  bool postAtTime1(jni.JniObject r, jni.JniObject token, int uptimeMillis) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_postAtTime1,
          jni.JniType.booleanType,
          [r.reference, token.reference, uptimeMillis]).boolean;

  static final _id_postDelayed = jniAccessors.getMethodIDOf(
      _classRef, "postDelayed", "(Ljava/lang/Runnable;J)Z");

  /// from: public final boolean postDelayed(java.lang.Runnable r, long delayMillis)
  ///
  /// Causes the Runnable r to be added to the message queue, to be run
  /// after the specified amount of time elapses.
  /// The runnable will be run on the thread to which this handler
  /// is attached.
  /// __The time-base is android.os.SystemClock\#uptimeMillis.__
  /// Time spent in deep sleep will add an additional delay to execution.
  ///@param r The Runnable that will be executed.
  ///@param delayMillis The delay (in milliseconds) until the Runnable
  ///        will be executed.
  ///@return Returns true if the Runnable was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.  Note that a
  ///         result of true does not mean the Runnable will be processed --
  ///         if the looper is quit before the delivery time of the message
  ///         occurs then the message will be dropped.
  bool postDelayed(jni.JniObject r, int delayMillis) =>
      jniAccessors.callMethodWithArgs(reference, _id_postDelayed,
          jni.JniType.booleanType, [r.reference, delayMillis]).boolean;

  static final _id_postDelayed1 = jniAccessors.getMethodIDOf(
      _classRef, "postDelayed", "(Ljava/lang/Runnable;Ljava/lang/Object;J)Z");

  /// from: public final boolean postDelayed(java.lang.Runnable r, java.lang.Object token, long delayMillis)
  ///
  /// Causes the Runnable r to be added to the message queue, to be run
  /// after the specified amount of time elapses.
  /// The runnable will be run on the thread to which this handler
  /// is attached.
  /// __The time-base is android.os.SystemClock\#uptimeMillis.__
  /// Time spent in deep sleep will add an additional delay to execution.
  ///@param r The Runnable that will be executed.
  ///@param token An instance which can be used to cancel {@code r} via
  ///         \#removeCallbacksAndMessages.
  ///@param delayMillis The delay (in milliseconds) until the Runnable
  ///        will be executed.
  ///@return Returns true if the Runnable was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.  Note that a
  ///         result of true does not mean the Runnable will be processed --
  ///         if the looper is quit before the delivery time of the message
  ///         occurs then the message will be dropped.
  bool postDelayed1(jni.JniObject r, jni.JniObject token, int delayMillis) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_postDelayed1,
          jni.JniType.booleanType,
          [r.reference, token.reference, delayMillis]).boolean;

  static final _id_postAtFrontOfQueue = jniAccessors.getMethodIDOf(
      _classRef, "postAtFrontOfQueue", "(Ljava/lang/Runnable;)Z");

  /// from: public final boolean postAtFrontOfQueue(java.lang.Runnable r)
  ///
  /// Posts a message to an object that implements Runnable.
  /// Causes the Runnable r to executed on the next iteration through the
  /// message queue. The runnable will be run on the thread to which this
  /// handler is attached.
  /// __This method is only for use in very special circumstances -- it
  /// can easily starve the message queue, cause ordering problems, or have
  /// other unexpected side-effects.__
  ///@param r The Runnable that will be executed.
  ///@return Returns true if the message was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.
  bool postAtFrontOfQueue(jni.JniObject r) => jniAccessors.callMethodWithArgs(
      reference,
      _id_postAtFrontOfQueue,
      jni.JniType.booleanType,
      [r.reference]).boolean;

  static final _id_removeCallbacks = jniAccessors.getMethodIDOf(
      _classRef, "removeCallbacks", "(Ljava/lang/Runnable;)V");

  /// from: public final void removeCallbacks(java.lang.Runnable r)
  ///
  /// Remove any pending posts of Runnable r that are in the message queue.
  void removeCallbacks(jni.JniObject r) => jniAccessors.callMethodWithArgs(
      reference,
      _id_removeCallbacks,
      jni.JniType.voidType,
      [r.reference]).check();

  static final _id_removeCallbacks1 = jniAccessors.getMethodIDOf(_classRef,
      "removeCallbacks", "(Ljava/lang/Runnable;Ljava/lang/Object;)V");

  /// from: public final void removeCallbacks(java.lang.Runnable r, java.lang.Object token)
  ///
  /// Remove any pending posts of Runnable <var>r</var> with Object
  /// <var>token</var> that are in the message queue.  If <var>token</var> is null,
  /// all callbacks will be removed.
  void removeCallbacks1(jni.JniObject r, jni.JniObject token) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeCallbacks1,
          jni.JniType.voidType, [r.reference, token.reference]).check();

  static final _id_sendMessage = jniAccessors.getMethodIDOf(
      _classRef, "sendMessage", "(Landroid/os/Message;)Z");

  /// from: public final boolean sendMessage(android.os.Message msg)
  ///
  /// Pushes a message onto the end of the message queue after all pending messages
  /// before the current time. It will be received in \#handleMessage,
  /// in the thread attached to this handler.
  ///@return Returns true if the message was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.
  bool sendMessage(message_.Message msg) => jniAccessors.callMethodWithArgs(
      reference,
      _id_sendMessage,
      jni.JniType.booleanType,
      [msg.reference]).boolean;

  static final _id_sendEmptyMessage =
      jniAccessors.getMethodIDOf(_classRef, "sendEmptyMessage", "(I)Z");

  /// from: public final boolean sendEmptyMessage(int what)
  ///
  /// Sends a Message containing only the what value.
  ///@return Returns true if the message was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.
  bool sendEmptyMessage(int what) => jniAccessors.callMethodWithArgs(
      reference, _id_sendEmptyMessage, jni.JniType.booleanType, [what]).boolean;

  static final _id_sendEmptyMessageDelayed =
      jniAccessors.getMethodIDOf(_classRef, "sendEmptyMessageDelayed", "(IJ)Z");

  /// from: public final boolean sendEmptyMessageDelayed(int what, long delayMillis)
  ///
  /// Sends a Message containing only the what value, to be delivered
  /// after the specified amount of time elapses.
  ///@see \#sendMessageDelayed(android.os.Message, long)
  ///@return Returns true if the message was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.
  bool sendEmptyMessageDelayed(int what, int delayMillis) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendEmptyMessageDelayed,
          jni.JniType.booleanType, [what, delayMillis]).boolean;

  static final _id_sendEmptyMessageAtTime =
      jniAccessors.getMethodIDOf(_classRef, "sendEmptyMessageAtTime", "(IJ)Z");

  /// from: public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis)
  ///
  /// Sends a Message containing only the what value, to be delivered
  /// at a specific time.
  ///@see \#sendMessageAtTime(android.os.Message, long)
  ///@return Returns true if the message was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.
  bool sendEmptyMessageAtTime(int what, int uptimeMillis) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendEmptyMessageAtTime,
          jni.JniType.booleanType, [what, uptimeMillis]).boolean;

  static final _id_sendMessageDelayed = jniAccessors.getMethodIDOf(
      _classRef, "sendMessageDelayed", "(Landroid/os/Message;J)Z");

  /// from: public final boolean sendMessageDelayed(android.os.Message msg, long delayMillis)
  ///
  /// Enqueue a message into the message queue after all pending messages
  /// before (current time + delayMillis). You will receive it in
  /// \#handleMessage, in the thread attached to this handler.
  ///@return Returns true if the message was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.  Note that a
  ///         result of true does not mean the message will be processed -- if
  ///         the looper is quit before the delivery time of the message
  ///         occurs then the message will be dropped.
  bool sendMessageDelayed(message_.Message msg, int delayMillis) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendMessageDelayed,
          jni.JniType.booleanType, [msg.reference, delayMillis]).boolean;

  static final _id_sendMessageAtTime = jniAccessors.getMethodIDOf(
      _classRef, "sendMessageAtTime", "(Landroid/os/Message;J)Z");

  /// from: public boolean sendMessageAtTime(android.os.Message msg, long uptimeMillis)
  ///
  /// Enqueue a message into the message queue after all pending messages
  /// before the absolute time (in milliseconds) <var>uptimeMillis</var>.
  /// __The time-base is android.os.SystemClock\#uptimeMillis.__
  /// Time spent in deep sleep will add an additional delay to execution.
  /// You will receive it in \#handleMessage, in the thread attached
  /// to this handler.
  ///@param uptimeMillis The absolute time at which the message should be
  ///         delivered, using the
  ///         android.os.SystemClock\#uptimeMillis time-base.
  ///@return Returns true if the message was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.  Note that a
  ///         result of true does not mean the message will be processed -- if
  ///         the looper is quit before the delivery time of the message
  ///         occurs then the message will be dropped.
  bool sendMessageAtTime(message_.Message msg, int uptimeMillis) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendMessageAtTime,
          jni.JniType.booleanType, [msg.reference, uptimeMillis]).boolean;

  static final _id_sendMessageAtFrontOfQueue = jniAccessors.getMethodIDOf(
      _classRef, "sendMessageAtFrontOfQueue", "(Landroid/os/Message;)Z");

  /// from: public final boolean sendMessageAtFrontOfQueue(android.os.Message msg)
  ///
  /// Enqueue a message at the front of the message queue, to be processed on
  /// the next iteration of the message loop.  You will receive it in
  /// \#handleMessage, in the thread attached to this handler.
  /// __This method is only for use in very special circumstances -- it
  /// can easily starve the message queue, cause ordering problems, or have
  /// other unexpected side-effects.__
  ///@return Returns true if the message was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.
  bool sendMessageAtFrontOfQueue(message_.Message msg) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendMessageAtFrontOfQueue,
          jni.JniType.booleanType, [msg.reference]).boolean;

  static final _id_removeMessages =
      jniAccessors.getMethodIDOf(_classRef, "removeMessages", "(I)V");

  /// from: public final void removeMessages(int what)
  ///
  /// Remove any pending posts of messages with code 'what' that are in the
  /// message queue.
  void removeMessages(int what) => jniAccessors.callMethodWithArgs(
      reference, _id_removeMessages, jni.JniType.voidType, [what]).check();

  static final _id_removeMessages1 = jniAccessors.getMethodIDOf(
      _classRef, "removeMessages", "(ILjava/lang/Object;)V");

  /// from: public final void removeMessages(int what, java.lang.Object object)
  ///
  /// Remove any pending posts of messages with code 'what' and whose obj is
  /// 'object' that are in the message queue.  If <var>object</var> is null,
  /// all messages will be removed.
  void removeMessages1(int what, jni.JniObject object) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeMessages1,
          jni.JniType.voidType, [what, object.reference]).check();

  static final _id_removeCallbacksAndMessages = jniAccessors.getMethodIDOf(
      _classRef, "removeCallbacksAndMessages", "(Ljava/lang/Object;)V");

  /// from: public final void removeCallbacksAndMessages(java.lang.Object token)
  ///
  /// Remove any pending posts of callbacks and sent messages whose
  /// <var>obj</var> is <var>token</var>.  If <var>token</var> is null,
  /// all callbacks and messages will be removed.
  void removeCallbacksAndMessages(jni.JniObject token) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeCallbacksAndMessages,
          jni.JniType.voidType, [token.reference]).check();

  static final _id_hasMessages =
      jniAccessors.getMethodIDOf(_classRef, "hasMessages", "(I)Z");

  /// from: public final boolean hasMessages(int what)
  ///
  /// Check if there are any pending posts of messages with code 'what' in
  /// the message queue.
  bool hasMessages(int what) => jniAccessors.callMethodWithArgs(
      reference, _id_hasMessages, jni.JniType.booleanType, [what]).boolean;

  static final _id_hasMessages1 = jniAccessors.getMethodIDOf(
      _classRef, "hasMessages", "(ILjava/lang/Object;)Z");

  /// from: public final boolean hasMessages(int what, java.lang.Object object)
  ///
  /// Check if there are any pending posts of messages with code 'what' and
  /// whose obj is 'object' in the message queue.
  bool hasMessages1(int what, jni.JniObject object) =>
      jniAccessors.callMethodWithArgs(reference, _id_hasMessages1,
          jni.JniType.booleanType, [what, object.reference]).boolean;

  static final _id_getLooper = jniAccessors.getMethodIDOf(
      _classRef, "getLooper", "()Landroid/os/Looper;");

  /// from: public final android.os.Looper getLooper()
  /// The returned object must be deleted after use, by calling the `delete` method.
  looper_.Looper getLooper() =>
      looper_.Looper.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLooper, jni.JniType.objectType, []).object);

  static final _id_dump = jniAccessors.getMethodIDOf(
      _classRef, "dump", "(Landroid/util/Printer;Ljava/lang/String;)V");

  /// from: public final void dump(android.util.Printer pw, java.lang.String prefix)
  void dump(printer_.Printer pw, jni.JniString prefix) =>
      jniAccessors.callMethodWithArgs(reference, _id_dump, jni.JniType.voidType,
          [pw.reference, prefix.reference]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.os.Handler$Callback
///
/// Callback interface you can use when instantiating a Handler to avoid
/// having to implement your own subclass of Handler.
class Handler_Callback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/os/Handler\$Callback");
  Handler_Callback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_handleMessage = jniAccessors.getMethodIDOf(
      _classRef, "handleMessage", "(Landroid/os/Message;)Z");

  /// from: public abstract boolean handleMessage(android.os.Message msg)
  ///
  /// @param msg A android.os.Message Message object
  ///@return True if no further handling is desired
  bool handleMessage(message_.Message msg) => jniAccessors.callMethodWithArgs(
      reference,
      _id_handleMessage,
      jni.JniType.booleanType,
      [msg.reference]).boolean;
}
