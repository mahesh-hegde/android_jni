// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.AsyncTask
///
/// AsyncTask enables proper and easy use of the UI thread. This class allows you
/// to perform background operations and publish results on the UI thread without
/// having to manipulate threads and/or handlers.
///
///
/// AsyncTask is designed to be a helper class around Thread and Handler
/// and does not constitute a generic threading framework. AsyncTasks should ideally be
/// used for short operations (a few seconds at the most.) If you need to keep threads
/// running for long periods of time, it is highly recommended you use the various APIs
/// provided by the <code>java.util.concurrent</code> package such as Executor,
/// ThreadPoolExecutor and FutureTask.
///
///
/// An asynchronous task is defined by a computation that runs on a background thread and
/// whose result is published on the UI thread. An asynchronous task is defined by 3 generic
/// types, called <code>Params</code>, <code>Progress</code> and <code>Result</code>,
/// and 4 steps, called <code>onPreExecute</code>, <code>doInBackground</code>,
/// <code>onProgressUpdate</code> and <code>onPostExecute</code>.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using tasks and threads, read the
/// <a href="{@docRoot}guide/components/processes-and-threads.html">Processes and
/// Threads</a> developer guide.
///
/// </div>
///
/// <h2>Usage</h2>
/// AsyncTask must be subclassed to be used. The subclass will override at least
/// one method (\#doInBackground), and most often will override a
/// second one (\#onPostExecute.)
///
///
/// Here is an example of subclassing:
///
/// <pre class="prettyprint">
/// private class DownloadFilesTask extends AsyncTask&lt;URL, Integer, Long&gt; {
///     protected Long doInBackground(URL... urls) {
///         int count = urls.length;
///         long totalSize = 0;
///         for (int i = 0; i < count; i++) {
///             totalSize += Downloader.downloadFile(urls[i]);
///             publishProgress((int) ((i / (float) count) * 100));
///             // Escape early if cancel() is called
///             if (isCancelled()) break;
///         }
///         return totalSize;
///     }
///
///     protected void onProgressUpdate(Integer... progress) {
///         setProgressPercent(progress[0]);
///     }
///
///     protected void onPostExecute(Long result) {
///         showDialog("Downloaded " + result + " bytes");
///     }
/// }
/// </pre>
///
/// Once created, a task is executed very simply:
///
/// <pre class="prettyprint">
/// new DownloadFilesTask().execute(url1, url2, url3);
/// </pre>
///
/// <h2>AsyncTask's generic types</h2>
/// The three types used by an asynchronous task are the following:
///
/// <ol>
///     <li><code>Params</code>, the type of the parameters sent to the task upon
///     execution.</li>
///     <li><code>Progress</code>, the type of the progress units published during
///     the background computation.</li>
///     <li><code>Result</code>, the type of the result of the background
///     computation.</li>
/// </ol>
/// Not all types are always used by an asynchronous task. To mark a type as unused,
/// simply use the type Void:
///
/// <pre>
/// private class MyTask extends AsyncTask&lt;Void, Void, Void&gt; { ... }
/// </pre>
///
/// <h2>The 4 steps</h2>
/// When an asynchronous task is executed, the task goes through 4 steps:
///
/// <ol>
///     <li>\#onPreExecute(), invoked on the UI thread before the task
///     is executed. This step is normally used to setup the task, for instance by
///     showing a progress bar in the user interface.</li>
///     <li>\#doInBackground, invoked on the background thread
///     immediately after \#onPreExecute() finishes executing. This step is used
///     to perform background computation that can take a long time. The parameters
///     of the asynchronous task are passed to this step. The result of the computation must
///     be returned by this step and will be passed back to the last step. This step
///     can also use \#publishProgress to publish one or more units
///     of progress. These values are published on the UI thread, in the
///     \#onProgressUpdate step.</li>
///     <li>\#onProgressUpdate, invoked on the UI thread after a
///     call to \#publishProgress. The timing of the execution is
///     undefined. This method is used to display any form of progress in the user
///     interface while the background computation is still executing. For instance,
///     it can be used to animate a progress bar or show logs in a text field.</li>
///     <li>\#onPostExecute, invoked on the UI thread after the background
///     computation finishes. The result of the background computation is passed to
///     this step as a parameter.</li>
/// </ol>
///
/// <h2>Cancelling a task</h2>
/// A task can be cancelled at any time by invoking \#cancel(boolean). Invoking
/// this method will cause subsequent calls to \#isCancelled() to return true.
/// After invoking this method, \#onCancelled(Object), instead of
/// \#onPostExecute(Object) will be invoked after \#doInBackground(Object[])
/// returns. To ensure that a task is cancelled as quickly as possible, you should always
/// check the return value of \#isCancelled() periodically from
/// \#doInBackground(Object[]), if possible (inside a loop for instance.)
///
///
/// <h2>Threading rules</h2>
/// There are a few threading rules that must be followed for this class to
/// work properly:
///
/// <ul>
///     <li>The AsyncTask class must be loaded on the UI thread. This is done
///     automatically as of android.os.Build.VERSION_CODES\#JELLY_BEAN.</li>
///     <li>The task instance must be created on the UI thread.</li>
///     <li>\#execute must be invoked on the UI thread.</li>
///     <li>Do not call \#onPreExecute(), \#onPostExecute,
///     \#doInBackground, \#onProgressUpdate manually.</li>
///     <li>The task can be executed only once (an exception will be thrown if
///     a second execution is attempted.)</li>
/// </ul>
///
/// <h2>Memory observability</h2>
/// AsyncTask guarantees that all callback calls are synchronized in such a way that the following
/// operations are safe without explicit synchronizations.
///
/// <ul>
///     <li>Set member fields in the constructor or \#onPreExecute, and refer to them
///     in \#doInBackground.
///     <li>Set member fields in \#doInBackground, and refer to them in
///     \#onProgressUpdate and \#onPostExecute.
/// </ul>
///
/// <h2>Order of execution</h2>
/// When first introduced, AsyncTasks were executed serially on a single background
/// thread. Starting with android.os.Build.VERSION_CODES\#DONUT, this was changed
/// to a pool of threads allowing multiple tasks to operate in parallel. Starting with
/// android.os.Build.VERSION_CODES\#HONEYCOMB, tasks are executed on a single
/// thread to avoid common application errors caused by parallel execution.
///
/// If you truly want parallel execution, you can invoke
/// \#executeOnExecutor(java.util.concurrent.Executor, Object[]) with
/// \#THREAD_POOL_EXECUTOR.
///
class AsyncTask extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/AsyncTask");
  AsyncTask.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_SERIAL_EXECUTOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "SERIAL_EXECUTOR", "Ljava/util/concurrent/Executor;");

  /// from: static public final java.util.concurrent.Executor SERIAL_EXECUTOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// An Executor that executes tasks one at a time in serial
  /// order.  This serialization is global to a particular process.
  static jni.JniObject get SERIAL_EXECUTOR => jni.JniObject.fromRef(jniAccessors
      .getStaticField(_classRef, _id_SERIAL_EXECUTOR, jni.JniType.objectType)
      .object);

  static final _id_THREAD_POOL_EXECUTOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "THREAD_POOL_EXECUTOR", "Ljava/util/concurrent/Executor;");

  /// from: static public final java.util.concurrent.Executor THREAD_POOL_EXECUTOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// An Executor that can be used to execute tasks in parallel.
  static jni.JniObject get THREAD_POOL_EXECUTOR =>
      jni.JniObject.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_THREAD_POOL_EXECUTOR, jni.JniType.objectType)
          .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new asynchronous task. This constructor must be invoked on the UI thread.
  AsyncTask()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getStatus = jniAccessors.getMethodIDOf(
      _classRef, "getStatus", "()Landroid/os/AsyncTask\$Status;");

  /// from: public final android.os.AsyncTask.Status getStatus()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current status of this task.
  ///@return The current status.
  AsyncTask_Status getStatus() =>
      AsyncTask_Status.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getStatus, jni.JniType.objectType, []).object);

  static final _id_onPreExecute =
      jniAccessors.getMethodIDOf(_classRef, "onPreExecute", "()V");

  /// from: protected void onPreExecute()
  ///
  /// Runs on the UI thread before \#doInBackground.
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  ///@see \#onPostExecute
  ///@see \#doInBackground
  void onPreExecute() => jniAccessors.callMethodWithArgs(
      reference, _id_onPreExecute, jni.JniType.voidType, []).check();

  static final _id_onProgressUpdate = jniAccessors.getMethodIDOf(
      _classRef, "onProgressUpdate", "([Ljava/lang/Object;)V");

  /// from: protected void onProgressUpdate(Progress[] values)
  ///
  /// Runs on the UI thread after \#publishProgress is invoked.
  /// The specified values are the values passed to \#publishProgress.
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  ///@param values The values indicating progress.
  ///@see \#publishProgress
  ///@see \#doInBackground
  void onProgressUpdate(jni.JniObject values) =>
      jniAccessors.callMethodWithArgs(reference, _id_onProgressUpdate,
          jni.JniType.voidType, [values.reference]).check();

  static final _id_onCancelled1 =
      jniAccessors.getMethodIDOf(_classRef, "onCancelled", "()V");

  /// from: protected void onCancelled()
  ///
  /// Applications should preferably override \#onCancelled(Object).
  /// This method is invoked by the default implementation of
  /// \#onCancelled(Object).
  ///
  ///
  /// Runs on the UI thread after \#cancel(boolean) is invoked and
  /// \#doInBackground(Object[]) has finished.
  ///
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  ///@see \#onCancelled(Object)
  ///@see \#cancel(boolean)
  ///@see \#isCancelled()
  void onCancelled1() => jniAccessors.callMethodWithArgs(
      reference, _id_onCancelled1, jni.JniType.voidType, []).check();

  static final _id_isCancelled =
      jniAccessors.getMethodIDOf(_classRef, "isCancelled", "()Z");

  /// from: public final boolean isCancelled()
  ///
  /// Returns <tt>true</tt> if this task was cancelled before it completed
  /// normally. If you are calling \#cancel(boolean) on the task,
  /// the value returned by this method should be checked periodically from
  /// \#doInBackground(Object[]) to end the task as soon as possible.
  ///@return <tt>true</tt> if task was cancelled before it completed
  ///@see \#cancel(boolean)
  bool isCancelled() => jniAccessors.callMethodWithArgs(
      reference, _id_isCancelled, jni.JniType.booleanType, []).boolean;

  static final _id_cancel =
      jniAccessors.getMethodIDOf(_classRef, "cancel", "(Z)Z");

  /// from: public final boolean cancel(boolean mayInterruptIfRunning)
  ///
  /// Attempts to cancel execution of this task.  This attempt will
  /// fail if the task has already completed, already been cancelled,
  /// or could not be cancelled for some other reason. If successful,
  /// and this task has not started when <tt>cancel</tt> is called,
  /// this task should never run. If the task has already started,
  /// then the <tt>mayInterruptIfRunning</tt> parameter determines
  /// whether the thread executing this task should be interrupted in
  /// an attempt to stop the task.
  ///
  ///
  /// Calling this method will result in \#onCancelled(Object) being
  /// invoked on the UI thread after \#doInBackground(Object[])
  /// returns. Calling this method guarantees that \#onPostExecute(Object)
  /// is never invoked. After invoking this method, you should check the
  /// value returned by \#isCancelled() periodically from
  /// \#doInBackground(Object[]) to finish the task as early as
  /// possible.
  ///
  ///@param mayInterruptIfRunning <tt>true</tt> if the thread executing this
  ///        task should be interrupted; otherwise, in-progress tasks are allowed
  ///        to complete.
  ///@return <tt>false</tt> if the task could not be cancelled,
  ///         typically because it has already completed normally;
  ///         <tt>true</tt> otherwise
  ///@see \#isCancelled()
  ///@see \#onCancelled(Object)
  bool cancel(bool mayInterruptIfRunning) => jniAccessors.callMethodWithArgs(
      reference,
      _id_cancel,
      jni.JniType.booleanType,
      [mayInterruptIfRunning]).boolean;

  static final _id_execute = jniAccessors.getMethodIDOf(
      _classRef, "execute", "([Ljava/lang/Object;)Landroid/os/AsyncTask;");

  /// from: public final android.os.AsyncTask<Params,Progress,Result> execute(Params[] params)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Executes the task with the specified parameters. The task returns
  /// itself (this) so that the caller can keep a reference to it.
  ///
  /// Note: this function schedules the task on a queue for a single background
  /// thread or pool of threads depending on the platform version.  When first
  /// introduced, AsyncTasks were executed serially on a single background thread.
  /// Starting with android.os.Build.VERSION_CODES\#DONUT, this was changed
  /// to a pool of threads allowing multiple tasks to operate in parallel. Starting
  /// android.os.Build.VERSION_CODES\#HONEYCOMB, tasks are back to being
  /// executed on a single thread to avoid common application errors caused
  /// by parallel execution.  If you truly want parallel execution, you can use
  /// the \#executeOnExecutor version of this method
  /// with \#THREAD_POOL_EXECUTOR; however, see commentary there for warnings
  /// on its use.
  ///
  /// This method must be invoked on the UI thread.
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  ///@param params The parameters of the task.
  ///@return This instance of AsyncTask.
  ///@throws IllegalStateException If \#getStatus() returns either
  ///         AsyncTask.Status\#RUNNING or AsyncTask.Status\#FINISHED.
  ///@see \#executeOnExecutor(java.util.concurrent.Executor, Object[])
  ///@see \#execute(Runnable)
  AsyncTask execute(jni.JniObject params) =>
      AsyncTask.fromRef(jniAccessors.callMethodWithArgs(reference, _id_execute,
          jni.JniType.objectType, [params.reference]).object);

  static final _id_executeOnExecutor = jniAccessors.getMethodIDOf(
      _classRef,
      "executeOnExecutor",
      "(Ljava/util/concurrent/Executor;[Ljava/lang/Object;)Landroid/os/AsyncTask;");

  /// from: public final android.os.AsyncTask<Params,Progress,Result> executeOnExecutor(java.util.concurrent.Executor exec, Params[] params)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Executes the task with the specified parameters. The task returns
  /// itself (this) so that the caller can keep a reference to it.
  ///
  /// This method is typically used with \#THREAD_POOL_EXECUTOR to
  /// allow multiple tasks to run in parallel on a pool of threads managed by
  /// AsyncTask, however you can also use your own Executor for custom
  /// behavior.
  ///
  /// _Warning:_ Allowing multiple tasks to run in parallel from
  /// a thread pool is generally _not_ what one wants, because the order
  /// of their operation is not defined.  For example, if these tasks are used
  /// to modify any state in common (such as writing a file due to a button click),
  /// there are no guarantees on the order of the modifications.
  /// Without careful work it is possible in rare cases for the newer version
  /// of the data to be over-written by an older one, leading to obscure data
  /// loss and stability issues.  Such changes are best
  /// executed in serial; to guarantee such work is serialized regardless of
  /// platform version you can use this function with \#SERIAL_EXECUTOR.
  ///
  /// This method must be invoked on the UI thread.
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  ///@param exec The executor to use.  \#THREAD_POOL_EXECUTOR is available as a
  ///              convenient process-wide thread pool for tasks that are loosely coupled.
  ///@param params The parameters of the task.
  ///@return This instance of AsyncTask.
  ///@throws IllegalStateException If \#getStatus() returns either
  ///         AsyncTask.Status\#RUNNING or AsyncTask.Status\#FINISHED.
  ///@see \#execute(Object[])
  AsyncTask executeOnExecutor(jni.JniObject exec, jni.JniObject params) =>
      AsyncTask.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_executeOnExecutor,
          jni.JniType.objectType,
          [exec.reference, params.reference]).object);

  static final _id_execute1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "execute", "(Ljava/lang/Runnable;)V");

  /// from: static public void execute(java.lang.Runnable runnable)
  ///
  /// Convenience version of \#execute(Object...) for use with
  /// a simple Runnable object. See \#execute(Object[]) for more
  /// information on the order of execution.
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  ///@see \#execute(Object[])
  ///@see \#executeOnExecutor(java.util.concurrent.Executor, Object[])
  static void execute1(jni.JniObject runnable) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_execute1,
          jni.JniType.voidType, [runnable.reference]).check();

  static final _id_publishProgress = jniAccessors.getMethodIDOf(
      _classRef, "publishProgress", "([Ljava/lang/Object;)V");

  /// from: protected final void publishProgress(Progress[] values)
  ///
  /// This method can be invoked from \#doInBackground to
  /// publish updates on the UI thread while the background computation is
  /// still running. Each call to this method will trigger the execution of
  /// \#onProgressUpdate on the UI thread.
  ///
  /// \#onProgressUpdate will not be called if the task has been
  /// canceled.
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param values The progress values to update the UI with.
  ///@see \#onProgressUpdate
  ///@see \#doInBackground
  void publishProgress(jni.JniObject values) => jniAccessors.callMethodWithArgs(
      reference,
      _id_publishProgress,
      jni.JniType.voidType,
      [values.reference]).check();
}

/// from: android.os.AsyncTask$Status
///
/// Indicates the current status of the task. Each status will be set only once
/// during the lifetime of a task.
class AsyncTask_Status extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/os/AsyncTask\$Status");
  AsyncTask_Status.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/os/AsyncTask\$Status;");

  /// from: static public android.os.AsyncTask.Status[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/os/AsyncTask\$Status;");

  /// from: static public android.os.AsyncTask.Status valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static AsyncTask_Status valueOf(jni.JniString name) =>
      AsyncTask_Status.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_valueOf, jni.JniType.objectType, [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  AsyncTask_Status()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
