// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "MessageQueue.dart" as messagequeue_;

import "../util/Printer.dart" as printer_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.os.Looper
///
/// Class used to run a message loop for a thread.  Threads by default do
/// not have a message loop associated with them; to create one, call
/// \#prepare in the thread that is to run the loop, and then
/// \#loop to have it process messages until the loop is stopped.
///
/// Most interaction with a message loop is through the
/// Handler class.
///
/// This is a typical example of the implementation of a Looper thread,
/// using the separation of \#prepare and \#loop to create an
/// initial Handler to communicate with the Looper.
///
/// <pre>
///  class LooperThread extends Thread {
///      public Handler mHandler;
///
///      public void run() {
///          Looper.prepare();
///
///          mHandler = new Handler() {
///              public void handleMessage(Message msg) {
///                  // process incoming messages here
///              }
///          };
///
///          Looper.loop();
///      }
///  }</pre>
class Looper extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/os/Looper");
  Looper.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Z)V");

  /// from: void <init>(boolean quitAllowed)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Looper(bool quitAllowed)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [quitAllowed]).object);

  static final _id_prepare =
      jniAccessors.getStaticMethodIDOf(_classRef, "prepare", "()V");

  /// from: static public void prepare()
  ///
  /// Initialize the current thread as a looper.
  /// This gives you a chance to create handlers that then reference
  /// this looper, before actually starting the loop. Be sure to call
  /// \#loop() after calling this method, and end it by calling
  /// \#quit().
  static void prepare() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_prepare, jni.JniType.voidType, []).check();

  static final _id_prepareMainLooper =
      jniAccessors.getStaticMethodIDOf(_classRef, "prepareMainLooper", "()V");

  /// from: static public void prepareMainLooper()
  ///
  /// Initialize the current thread as a looper, marking it as an
  /// application's main looper. The main looper for your application
  /// is created by the Android environment, so you should never need
  /// to call this function yourself.  See also: \#prepare()
  static void prepareMainLooper() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_prepareMainLooper, jni.JniType.voidType, []).check();

  static final _id_getMainLooper = jniAccessors.getStaticMethodIDOf(
      _classRef, "getMainLooper", "()Landroid/os/Looper;");

  /// from: static public android.os.Looper getMainLooper()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the application's main looper, which lives in the main thread of the application.
  static Looper getMainLooper() =>
      Looper.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getMainLooper, jni.JniType.objectType, []).object);

  static final _id_loop =
      jniAccessors.getStaticMethodIDOf(_classRef, "loop", "()V");

  /// from: static public void loop()
  ///
  /// Run the message queue in this thread. Be sure to call
  /// \#quit() to end the loop.
  static void loop() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_loop, jni.JniType.voidType, []).check();

  static final _id_myLooper = jniAccessors.getStaticMethodIDOf(
      _classRef, "myLooper", "()Landroid/os/Looper;");

  /// from: static public android.os.Looper myLooper()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Looper object associated with the current thread.  Returns
  /// null if the calling thread is not associated with a Looper.
  static Looper myLooper() =>
      Looper.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_myLooper, jni.JniType.objectType, []).object);

  static final _id_myQueue = jniAccessors.getStaticMethodIDOf(
      _classRef, "myQueue", "()Landroid/os/MessageQueue;");

  /// from: static public android.os.MessageQueue myQueue()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the MessageQueue object associated with the current
  /// thread.  This must be called from a thread running a Looper, or a
  /// NullPointerException will be thrown.
  ///@return This value will never be {@code null}.
  static messagequeue_.MessageQueue myQueue() =>
      messagequeue_.MessageQueue.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_myQueue, jni.JniType.objectType, []).object);

  static final _id_isCurrentThread =
      jniAccessors.getMethodIDOf(_classRef, "isCurrentThread", "()Z");

  /// from: public boolean isCurrentThread()
  ///
  /// Returns true if the current thread is this looper's thread.
  bool isCurrentThread() => jniAccessors.callMethodWithArgs(
      reference, _id_isCurrentThread, jni.JniType.booleanType, []).boolean;

  static final _id_setMessageLogging = jniAccessors.getMethodIDOf(
      _classRef, "setMessageLogging", "(Landroid/util/Printer;)V");

  /// from: public void setMessageLogging(android.util.Printer printer)
  ///
  /// Control logging of messages as they are processed by this Looper.  If
  /// enabled, a log message will be written to <var>printer</var>
  /// at the beginning and ending of each message dispatch, identifying the
  /// target Handler and message contents.
  ///@param printer A Printer object that will receive log messages, or
  /// null to disable message logging.
  ///
  /// This value may be {@code null}.
  void setMessageLogging(printer_.Printer printer) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMessageLogging,
          jni.JniType.voidType, [printer.reference]).check();

  static final _id_quit = jniAccessors.getMethodIDOf(_classRef, "quit", "()V");

  /// from: public void quit()
  ///
  /// Quits the looper.
  ///
  /// Causes the \#loop method to terminate without processing any
  /// more messages in the message queue.
  ///
  ///
  /// Any attempt to post messages to the queue after the looper is asked to quit will fail.
  /// For example, the Handler\#sendMessage(Message) method will return false.
  ///
  ///<p class="note">
  /// Using this method may be unsafe because some messages may not be delivered
  /// before the looper terminates.  Consider using \#quitSafely instead to ensure
  /// that all pending work is completed in an orderly manner.
  ///
  ///
  ///@see \#quitSafely
  void quit() => jniAccessors.callMethodWithArgs(
      reference, _id_quit, jni.JniType.voidType, []).check();

  static final _id_quitSafely =
      jniAccessors.getMethodIDOf(_classRef, "quitSafely", "()V");

  /// from: public void quitSafely()
  ///
  /// Quits the looper safely.
  ///
  /// Causes the \#loop method to terminate as soon as all remaining messages
  /// in the message queue that are already due to be delivered have been handled.
  /// However pending delayed messages with due times in the future will not be
  /// delivered before the loop terminates.
  ///
  ///
  /// Any attempt to post messages to the queue after the looper is asked to quit will fail.
  /// For example, the Handler\#sendMessage(Message) method will return false.
  ///
  ///
  void quitSafely() => jniAccessors.callMethodWithArgs(
      reference, _id_quitSafely, jni.JniType.voidType, []).check();

  static final _id_getThread = jniAccessors.getMethodIDOf(
      _classRef, "getThread", "()Ljava/lang/Thread;");

  /// from: public java.lang.Thread getThread()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the Thread associated with this Looper.
  ///@return The looper's thread.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getThread() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getThread, jni.JniType.objectType, []).object);

  static final _id_getQueue = jniAccessors.getMethodIDOf(
      _classRef, "getQueue", "()Landroid/os/MessageQueue;");

  /// from: public android.os.MessageQueue getQueue()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets this looper's message queue.
  ///@return The looper's message queue.
  ///
  /// This value will never be {@code null}.
  messagequeue_.MessageQueue getQueue() =>
      messagequeue_.MessageQueue.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getQueue, jni.JniType.objectType, []).object);

  static final _id_dump = jniAccessors.getMethodIDOf(
      _classRef, "dump", "(Landroid/util/Printer;Ljava/lang/String;)V");

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  ///
  /// Dumps the state of the looper for debugging purposes.
  ///@param pw A printer to receive the contents of the dump.
  /// This value must never be {@code null}.
  ///@param prefix A prefix to prepend to each line which is printed.
  ///
  /// This value must never be {@code null}.
  void dump(printer_.Printer pw, jni.JniString prefix) =>
      jniAccessors.callMethodWithArgs(reference, _id_dump, jni.JniType.voidType,
          [pw.reference, prefix.reference]).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
