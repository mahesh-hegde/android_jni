// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "UsbDeviceConnection.dart" as usbdeviceconnection_;

import "UsbEndpoint.dart" as usbendpoint_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.usb.UsbRequest
///
/// A class representing USB request packet.
/// This can be used for both reading and writing data to or from a
/// android.hardware.usb.UsbDeviceConnection.
/// UsbRequests can be used to transfer data on bulk and interrupt endpoints.
/// Requests on bulk endpoints can be sent synchronously via UsbDeviceConnection\#bulkTransfer
/// or asynchronously via \#queue and UsbDeviceConnection\#requestWait.
/// Requests on interrupt endpoints are only send and received asynchronously.
///
/// Requests on endpoint zero are not supported by this class;
/// use UsbDeviceConnection\#controlTransfer for endpoint zero requests instead.
class UsbRequest extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/usb/UsbRequest");
  UsbRequest.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  UsbRequest()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_initialize = jniAccessors.getMethodIDOf(
      _classRef,
      "initialize",
      "(Landroid/hardware/usb/UsbDeviceConnection;Landroid/hardware/usb/UsbEndpoint;)Z");

  /// from: public boolean initialize(android.hardware.usb.UsbDeviceConnection connection, android.hardware.usb.UsbEndpoint endpoint)
  ///
  /// Initializes the request so it can read or write data on the given endpoint.
  /// Whether the request allows reading or writing depends on the direction of the endpoint.
  ///@param endpoint the endpoint to be used for this request.
  ///@return true if the request was successfully opened.
  bool initialize(usbdeviceconnection_.UsbDeviceConnection connection,
          usbendpoint_.UsbEndpoint endpoint) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_initialize,
          jni.JniType.booleanType,
          [connection.reference, endpoint.reference]).boolean;

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Releases all resources related to this request.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_getEndpoint = jniAccessors.getMethodIDOf(
      _classRef, "getEndpoint", "()Landroid/hardware/usb/UsbEndpoint;");

  /// from: public android.hardware.usb.UsbEndpoint getEndpoint()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the endpoint for the request, or null if the request is not opened.
  ///@return the request's endpoint
  usbendpoint_.UsbEndpoint getEndpoint() =>
      usbendpoint_.UsbEndpoint.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getEndpoint, jni.JniType.objectType, []).object);

  static final _id_getClientData = jniAccessors.getMethodIDOf(
      _classRef, "getClientData", "()Ljava/lang/Object;");

  /// from: public java.lang.Object getClientData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the client data for the request.
  /// This can be used in conjunction with \#setClientData
  /// to associate another object with this request, which can be useful for
  /// maintaining state between calls to \#queue and
  /// android.hardware.usb.UsbDeviceConnection\#requestWait
  ///@return the client data for the request
  jni.JniObject getClientData() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getClientData, jni.JniType.objectType, []).object);

  static final _id_setClientData = jniAccessors.getMethodIDOf(
      _classRef, "setClientData", "(Ljava/lang/Object;)V");

  /// from: public void setClientData(java.lang.Object data)
  ///
  /// Sets the client data for the request.
  /// This can be used in conjunction with \#getClientData
  /// to associate another object with this request, which can be useful for
  /// maintaining state between calls to \#queue and
  /// android.hardware.usb.UsbDeviceConnection\#requestWait
  ///@param data the client data for the request
  void setClientData(jni.JniObject data) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setClientData,
      jni.JniType.voidType,
      [data.reference]).check();

  static final _id_queue = jniAccessors.getMethodIDOf(
      _classRef, "queue", "(Ljava/nio/ByteBuffer;I)Z");

  /// from: public boolean queue(java.nio.ByteBuffer buffer, int length)
  ///
  /// Queues the request to send or receive data on its endpoint.
  /// For OUT endpoints, the given buffer data will be sent on the endpoint. For IN endpoints,
  /// the endpoint will attempt to read the given number of bytes into the specified buffer. If the
  /// queueing operation is successful, return true. The result will be returned via
  /// UsbDeviceConnection\#requestWait
  ///
  ///@param buffer the buffer containing the bytes to write, or location to store the results of a
  ///               read. Position and array offset will be ignored and assumed to be 0. Limit and
  ///               capacity will be ignored. Once the request
  ///               UsbDeviceConnection\#requestWait() is processed the position will be set
  ///               to the number of bytes read/written.
  ///@param length number of bytes to read or write. Before {@value Build.VERSION_CODES\#P}, a
  ///               value larger than 16384 bytes would be truncated down to 16384. In API
  ///               {@value Build.VERSION_CODES\#P} and after, any value of length is valid.
  ///@return true if the queueing operation succeeded
  ///@deprecated Use \#queue(ByteBuffer) instead.
  bool queue(jni.JniObject buffer, int length) =>
      jniAccessors.callMethodWithArgs(reference, _id_queue,
          jni.JniType.booleanType, [buffer.reference, length]).boolean;

  static final _id_queue1 = jniAccessors.getMethodIDOf(
      _classRef, "queue", "(Ljava/nio/ByteBuffer;)Z");

  /// from: public boolean queue(java.nio.ByteBuffer buffer)
  ///
  /// Queues the request to send or receive data on its endpoint.
  ///
  /// For OUT endpoints, the remaining bytes of the buffer will be sent on the endpoint. For IN
  /// endpoints, the endpoint will attempt to fill the remaining bytes of the buffer. If the
  /// queueing operation is successful, return true. The result will be returned via
  /// UsbDeviceConnection\#requestWait
  ///
  ///@param buffer the buffer containing the bytes to send, or the buffer to fill. The state
  ///               of the buffer is undefined until the request is returned by
  ///               UsbDeviceConnection\#requestWait. If the request failed the buffer
  ///               will be unchanged; if the request succeeded the position of the buffer is
  ///               incremented by the number of bytes sent/received. Before
  ///               {@value Build.VERSION_CODES\#P}, a buffer of length larger than 16384 bytes
  ///               would throw IllegalArgumentException. In API {@value Build.VERSION_CODES\#P}
  ///               and after, any size buffer is valid.
  ///
  /// This value may be {@code null}.
  ///@return true if the queueing operation succeeded
  bool queue1(jni.JniObject buffer) => jniAccessors.callMethodWithArgs(
      reference,
      _id_queue1,
      jni.JniType.booleanType,
      [buffer.reference]).boolean;

  static final _id_cancel =
      jniAccessors.getMethodIDOf(_classRef, "cancel", "()Z");

  /// from: public boolean cancel()
  ///
  /// Cancels a pending queue operation.
  ///@return true if cancelling succeeded
  bool cancel() => jniAccessors.callMethodWithArgs(
      reference, _id_cancel, jni.JniType.booleanType, []).boolean;
}
