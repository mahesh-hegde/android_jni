// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../view/SurfaceHolder.dart" as surfaceholder_;

import "../graphics/SurfaceTexture.dart" as surfacetexture_;

import "../graphics/Point.dart" as point_;

import "../graphics/Rect.dart" as rect_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.Camera
///
/// The Camera class is used to set image capture settings, start/stop preview,
/// snap pictures, and retrieve frames for encoding for video.  This class is a
/// client for the Camera service, which manages the actual camera hardware.
///
/// To access the device camera, you must declare the
/// android.Manifest.permission\#CAMERA permission in your Android
/// Manifest. Also be sure to include the
/// <a href="{@docRoot}guide/topics/manifest/uses-feature-element.html">&lt;uses-feature></a>
/// manifest element to declare camera features used by your application.
/// For example, if you use the camera and auto-focus feature, your Manifest
/// should include the following:
///
/// <pre> &lt;uses-permission android:name="android.permission.CAMERA" />
/// &lt;uses-feature android:name="android.hardware.camera" />
/// &lt;uses-feature android:name="android.hardware.camera.autofocus" /></pre>
///
/// To take pictures with this class, use the following steps:
///
///
/// <ol>
/// <li>Obtain an instance of Camera from \#open(int).
///
/// <li>Get existing (default) settings with \#getParameters().
///
/// <li>If necessary, modify the returned Camera.Parameters object and call
/// \#setParameters(Camera.Parameters).
///
/// <li>Call \#setDisplayOrientation(int) to ensure correct orientation of preview.
///
/// <li>__Important__: Pass a fully initialized SurfaceHolder to
/// \#setPreviewDisplay(SurfaceHolder).  Without a surface, the camera
/// will be unable to start the preview.
///
/// <li>__Important__: Call \#startPreview() to start updating the
/// preview surface.  Preview must be started before you can take a picture.
///
/// <li>When you want, call \#takePicture(Camera.ShutterCallback,
/// Camera.PictureCallback, Camera.PictureCallback, Camera.PictureCallback) to
/// capture a photo.  Wait for the callbacks to provide the actual image data.
///
/// <li>After taking a picture, preview display will have stopped.  To take more
/// photos, call \#startPreview() again first.
///
/// <li>Call \#stopPreview() to stop updating the preview surface.
///
/// <li>__Important:__ Call \#release() to release the camera for
/// use by other applications.  Applications should release the camera
/// immediately in android.app.Activity\#onPause() (and re-\#open()
/// it in android.app.Activity\#onResume()).
/// </ol>
///
/// To quickly switch to video recording mode, use these steps:
///
///
/// <ol>
/// <li>Obtain and initialize a Camera and start preview as described above.
///
/// <li>Call \#unlock() to allow the media process to access the camera.
///
/// <li>Pass the camera to android.media.MediaRecorder\#setCamera(Camera).
/// See android.media.MediaRecorder information about video recording.
///
/// <li>When finished recording, call \#reconnect() to re-acquire
/// and re-lock the camera.
///
/// <li>If desired, restart preview and take more photos or videos.
///
/// <li>Call \#stopPreview() and \#release() as described above.
/// </ol>
///
/// This class is not thread-safe, and is meant for use from one event thread.
/// Most long-running operations (preview, focus, photo capture, etc) happen
/// asynchronously and invoke callbacks as necessary.  Callbacks will be invoked
/// on the event thread \#open(int) was called from.  This class's methods
/// must never be called from multiple threads at once.
///
///
/// <p class="caution"><strong>Caution:</strong> Different Android-powered devices
/// may have different hardware specifications, such as megapixel ratings and
/// auto-focus capabilities. In order for your application to be compatible with
/// more devices, you should not make assumptions about the device camera
/// specifications.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using cameras, read the
/// <a href="{@docRoot}guide/topics/media/camera.html">Camera</a> developer guide.
///
/// </div>
///@deprecated We recommend using the new android.hardware.camera2 API for new
///             applications.
class Camera extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/hardware/Camera");
  Camera.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_NEW_PICTURE
  ///
  /// Broadcast Action:  A new picture is taken by the camera, and the entry of
  /// the picture has been added to the media store.
  /// android.content.Intent\#getData is URI of the picture.
  ///
  /// In android.os.Build.VERSION_CODES\#N Android N this broadcast was removed, and
  /// applications are recommended to use
  /// android.app.job.JobInfo.Builder JobInfo.Builder.android.app.job.JobInfo.Builder\#addTriggerContentUri
  /// instead.
  ///
  ///
  /// In android.os.Build.VERSION_CODES\#O Android O this broadcast has been brought
  /// back, but only for _registered_ receivers.  Apps that are actively running can
  /// again listen to the broadcast if they want an immediate clear signal about a picture
  /// being taken, however anything doing heavy work (or needing to be launched) as a result of
  /// this should still use JobScheduler.
  ///
  static const ACTION_NEW_PICTURE = "android.hardware.action.NEW_PICTURE";

  /// from: static public final java.lang.String ACTION_NEW_VIDEO
  ///
  /// Broadcast Action:  A new video is recorded by the camera, and the entry
  /// of the video has been added to the media store.
  /// android.content.Intent\#getData is URI of the video.
  ///
  /// In android.os.Build.VERSION_CODES\#N Android N this broadcast was removed, and
  /// applications are recommended to use
  /// android.app.job.JobInfo.Builder JobInfo.Builder.android.app.job.JobInfo.Builder\#addTriggerContentUri
  /// instead.
  ///
  ///
  /// In android.os.Build.VERSION_CODES\#O Android O this broadcast has been brought
  /// back, but only for _registered_ receivers.  Apps that are actively running can
  /// again listen to the broadcast if they want an immediate clear signal about a video
  /// being taken, however anything doing heavy work (or needing to be launched) as a result of
  /// this should still use JobScheduler.
  ///
  static const ACTION_NEW_VIDEO = "android.hardware.action.NEW_VIDEO";

  /// from: static public final int CAMERA_ERROR_EVICTED
  ///
  /// Camera was disconnected due to use by higher priority user.
  ///@see Camera.ErrorCallback
  static const CAMERA_ERROR_EVICTED = 2;

  /// from: static public final int CAMERA_ERROR_SERVER_DIED
  ///
  /// Media server died. In this case, the application must release the
  /// Camera object and instantiate a new one.
  ///@see Camera.ErrorCallback
  static const CAMERA_ERROR_SERVER_DIED = 100;

  /// from: static public final int CAMERA_ERROR_UNKNOWN
  ///
  /// Unspecified camera error.
  ///@see Camera.ErrorCallback
  static const CAMERA_ERROR_UNKNOWN = 1;

  static final _id_getNumberOfCameras =
      jniAccessors.getStaticMethodIDOf(_classRef, "getNumberOfCameras", "()I");

  /// from: static public native int getNumberOfCameras()
  ///
  /// Returns the number of physical cameras available on this device.
  /// The return value of this method might change dynamically if the device
  /// supports external cameras and an external camera is connected or
  /// disconnected.
  ///
  /// If there is a
  /// android.hardware.camera2.CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA logical multi-camera in the system, to maintain app backward compatibility, this method will
  /// only expose one camera for every logical camera and underlying physical cameras group.
  /// Use camera2 API to see all cameras.
  ///@return total number of accessible camera devices, or 0 if there are no
  ///   cameras or an error was encountered enumerating them.
  static int getNumberOfCameras() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_getNumberOfCameras, jni.JniType.intType, []).integer;

  static final _id_getCameraInfo = jniAccessors.getStaticMethodIDOf(
      _classRef, "getCameraInfo", "(ILandroid/hardware/Camera\$CameraInfo;)V");

  /// from: static public void getCameraInfo(int cameraId, android.hardware.Camera.CameraInfo cameraInfo)
  ///
  /// Returns the information about a particular camera.
  /// If \#getNumberOfCameras() returns N, the valid id is 0 to N-1.
  ///@throws RuntimeException if an invalid ID is provided, or if there is an
  ///    error retrieving the information (generally due to a hardware or other
  ///    low-level failure).
  static void getCameraInfo(int cameraId, Camera_CameraInfo cameraInfo) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getCameraInfo,
          jni.JniType.voidType, [cameraId, cameraInfo.reference]).check();

  static final _id_open = jniAccessors.getStaticMethodIDOf(
      _classRef, "open", "(I)Landroid/hardware/Camera;");

  /// from: static public android.hardware.Camera open(int cameraId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new Camera object to access a particular hardware camera. If
  /// the same camera is opened by other applications, this will throw a
  /// RuntimeException.
  ///
  /// You must call \#release() when you are done using the camera,
  /// otherwise it will remain locked and be unavailable to other applications.
  ///
  /// Your application should only have one Camera object active at a time
  /// for a particular hardware camera.
  ///
  /// Callbacks from other methods are delivered to the event loop of the
  /// thread which called open().  If this thread has no event loop, then
  /// callbacks are delivered to the main application event loop.  If there
  /// is no main application event loop, callbacks are not delivered.
  ///
  /// <p class="caution">__Caution:__ On some devices, this method may
  /// take a long time to complete.  It is best to call this method from a
  /// worker thread (possibly using android.os.AsyncTask) to avoid
  /// blocking the main application UI thread.
  ///@param cameraId the hardware camera to access, between 0 and
  ///     \#getNumberOfCameras()-1.
  ///@return a new Camera object, connected, locked and ready for use.
  ///@throws RuntimeException if opening the camera fails (for example, if the
  ///     camera is in use by another process or device policy manager has
  ///     disabled the camera).
  ///@see android.app.admin.DevicePolicyManager\#getCameraDisabled(android.content.ComponentName)
  static Camera open(int cameraId) =>
      Camera.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_open, jni.JniType.objectType, [cameraId]).object);

  static final _id_open1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "open", "()Landroid/hardware/Camera;");

  /// from: static public android.hardware.Camera open()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new Camera object to access the first back-facing camera on the
  /// device. If the device does not have a back-facing camera, this returns
  /// null. Otherwise acts like the \#open(int) call.
  ///@return a new Camera object for the first back-facing camera, or null if there is no
  ///  backfacing camera
  ///@see \#open(int)
  static Camera open1() => Camera.fromRef(jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_open1, jni.JniType.objectType, []).object);

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public final void release()
  ///
  /// Disconnects and releases the Camera object resources.
  ///
  /// You must call this as soon as you're done with the Camera object.
  ///
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_unlock =
      jniAccessors.getMethodIDOf(_classRef, "unlock", "()V");

  /// from: public native final void unlock()
  ///
  /// Unlocks the camera to allow another process to access it.
  /// Normally, the camera is locked to the process with an active Camera
  /// object until \#release() is called.  To allow rapid handoff
  /// between processes, you can call this method to release the camera
  /// temporarily for another process to use; once the other process is done
  /// you can call \#reconnect() to reclaim the camera.
  ///
  /// This must be done before calling
  /// android.media.MediaRecorder\#setCamera(Camera). This cannot be
  /// called after recording starts.
  ///
  /// If you are not recording video, you probably do not need this method.
  ///@throws RuntimeException if the camera cannot be unlocked.
  void unlock() => jniAccessors.callMethodWithArgs(
      reference, _id_unlock, jni.JniType.voidType, []).check();

  static final _id_lock = jniAccessors.getMethodIDOf(_classRef, "lock", "()V");

  /// from: public native final void lock()
  ///
  /// Re-locks the camera to prevent other processes from accessing it.
  /// Camera objects are locked by default unless \#unlock() is
  /// called.  Normally \#reconnect() is used instead.
  ///
  /// Since API level 14, camera is automatically locked for applications in
  /// android.media.MediaRecorder\#start(). Applications can use the
  /// camera (ex: zoom) after recording starts. There is no need to call this
  /// after recording starts or stops.
  ///
  /// If you are not recording video, you probably do not need this method.
  ///@throws RuntimeException if the camera cannot be re-locked (for
  ///     example, if the camera is still in use by another process).
  void lock() => jniAccessors.callMethodWithArgs(
      reference, _id_lock, jni.JniType.voidType, []).check();

  static final _id_reconnect =
      jniAccessors.getMethodIDOf(_classRef, "reconnect", "()V");

  /// from: public native final void reconnect()
  ///
  /// Reconnects to the camera service after another process used it.
  /// After \#unlock() is called, another process may use the
  /// camera; when the process is done, you must reconnect to the camera,
  /// which will re-acquire the lock and allow you to continue using the
  /// camera.
  ///
  /// Since API level 14, camera is automatically locked for applications in
  /// android.media.MediaRecorder\#start(). Applications can use the
  /// camera (ex: zoom) after recording starts. There is no need to call this
  /// after recording starts or stops.
  ///
  /// If you are not recording video, you probably do not need this method.
  ///@throws IOException if a connection cannot be re-established (for
  ///     example, if the camera is still in use by another process).
  ///@throws RuntimeException if release() has been called on this Camera
  ///     instance.
  void reconnect() => jniAccessors.callMethodWithArgs(
      reference, _id_reconnect, jni.JniType.voidType, []).check();

  static final _id_setPreviewDisplay = jniAccessors.getMethodIDOf(
      _classRef, "setPreviewDisplay", "(Landroid/view/SurfaceHolder;)V");

  /// from: public final void setPreviewDisplay(android.view.SurfaceHolder holder)
  ///
  /// Sets the Surface to be used for live preview.
  /// Either a surface or surface texture is necessary for preview, and
  /// preview is necessary to take pictures.  The same surface can be re-set
  /// without harm.  Setting a preview surface will un-set any preview surface
  /// texture that was set via \#setPreviewTexture.
  ///
  /// The SurfaceHolder must already contain a surface when this
  /// method is called.  If you are using android.view.SurfaceView,
  /// you will need to register a SurfaceHolder.Callback with
  /// SurfaceHolder\#addCallback(SurfaceHolder.Callback) and wait for
  /// SurfaceHolder.Callback\#surfaceCreated(SurfaceHolder) before
  /// calling setPreviewDisplay() or starting preview.
  ///
  /// This method must be called before \#startPreview().  The
  /// one exception is that if the preview surface is not set (or set to null)
  /// before startPreview() is called, then this method may be called once
  /// with a non-null parameter to set the preview surface.  (This allows
  /// camera setup and surface creation to happen in parallel, saving time.)
  /// The preview surface may not otherwise change while preview is running.
  ///@param holder containing the Surface on which to place the preview,
  ///     or null to remove the preview surface
  ///@throws IOException if the method fails (for example, if the surface
  ///     is unavailable or unsuitable).
  ///@throws RuntimeException if release() has been called on this Camera
  ///    instance.
  void setPreviewDisplay(surfaceholder_.SurfaceHolder holder) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPreviewDisplay,
          jni.JniType.voidType, [holder.reference]).check();

  static final _id_setPreviewTexture = jniAccessors.getMethodIDOf(
      _classRef, "setPreviewTexture", "(Landroid/graphics/SurfaceTexture;)V");

  /// from: public native final void setPreviewTexture(android.graphics.SurfaceTexture surfaceTexture)
  ///
  /// Sets the SurfaceTexture to be used for live preview.
  /// Either a surface or surface texture is necessary for preview, and
  /// preview is necessary to take pictures.  The same surface texture can be
  /// re-set without harm.  Setting a preview surface texture will un-set any
  /// preview surface that was set via \#setPreviewDisplay.
  ///
  /// This method must be called before \#startPreview().  The
  /// one exception is that if the preview surface texture is not set (or set
  /// to null) before startPreview() is called, then this method may be called
  /// once with a non-null parameter to set the preview surface.  (This allows
  /// camera setup and surface creation to happen in parallel, saving time.)
  /// The preview surface texture may not otherwise change while preview is
  /// running.
  ///
  /// The timestamps provided by SurfaceTexture\#getTimestamp() for a
  /// SurfaceTexture set as the preview texture have an unspecified zero point,
  /// and cannot be directly compared between different cameras or different
  /// instances of the same camera, or across multiple runs of the same
  /// program.
  ///
  /// If you are using the preview data to create video or still images,
  /// strongly consider using android.media.MediaActionSound to
  /// properly indicate image capture or recording start/stop to the user.
  ///
  ///@see android.media.MediaActionSound
  ///@see android.graphics.SurfaceTexture
  ///@see android.view.TextureView
  ///@param surfaceTexture the SurfaceTexture to which the preview
  ///     images are to be sent or null to remove the current preview surface
  ///     texture
  ///@throws IOException if the method fails (for example, if the surface
  ///     texture is unavailable or unsuitable).
  ///@throws RuntimeException if release() has been called on this Camera
  ///    instance.
  void setPreviewTexture(surfacetexture_.SurfaceTexture surfaceTexture) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPreviewTexture,
          jni.JniType.voidType, [surfaceTexture.reference]).check();

  static final _id_startPreview =
      jniAccessors.getMethodIDOf(_classRef, "startPreview", "()V");

  /// from: public native final void startPreview()
  ///
  /// Starts capturing and drawing preview frames to the screen.
  /// Preview will not actually start until a surface is supplied
  /// with \#setPreviewDisplay(SurfaceHolder) or
  /// \#setPreviewTexture(SurfaceTexture).
  ///
  /// If \#setPreviewCallback(Camera.PreviewCallback),
  /// \#setOneShotPreviewCallback(Camera.PreviewCallback), or
  /// \#setPreviewCallbackWithBuffer(Camera.PreviewCallback) were
  /// called, Camera.PreviewCallback\#onPreviewFrame(byte[], Camera)
  /// will be called when preview data becomes available.
  ///@throws RuntimeException if starting preview fails; usually this would be
  ///    because of a hardware or other low-level error, or because release()
  ///    has been called on this Camera instance.
  void startPreview() => jniAccessors.callMethodWithArgs(
      reference, _id_startPreview, jni.JniType.voidType, []).check();

  static final _id_stopPreview =
      jniAccessors.getMethodIDOf(_classRef, "stopPreview", "()V");

  /// from: public final void stopPreview()
  ///
  /// Stops capturing and drawing preview frames to the surface, and
  /// resets the camera for a future call to \#startPreview().
  ///@throws RuntimeException if stopping preview fails; usually this would be
  ///    because of a hardware or other low-level error, or because release()
  ///    has been called on this Camera instance.
  void stopPreview() => jniAccessors.callMethodWithArgs(
      reference, _id_stopPreview, jni.JniType.voidType, []).check();

  static final _id_setPreviewCallback = jniAccessors.getMethodIDOf(_classRef,
      "setPreviewCallback", "(Landroid/hardware/Camera\$PreviewCallback;)V");

  /// from: public final void setPreviewCallback(android.hardware.Camera.PreviewCallback cb)
  ///
  /// Installs a callback to be invoked for every preview frame in addition
  /// to displaying them on the screen.  The callback will be repeatedly called
  /// for as long as preview is active.  This method can be called at any time,
  /// even while preview is live.  Any other preview callbacks are
  /// overridden.
  ///
  ///
  /// If you are using the preview data to create video or still images,
  /// strongly consider using android.media.MediaActionSound to
  /// properly indicate image capture or recording start/stop to the user.
  ///
  ///@param cb a callback object that receives a copy of each preview frame,
  ///     or null to stop receiving callbacks.
  ///@throws RuntimeException if release() has been called on this Camera
  ///     instance.
  ///@see android.media.MediaActionSound
  void setPreviewCallback(Camera_PreviewCallback cb) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPreviewCallback,
          jni.JniType.voidType, [cb.reference]).check();

  static final _id_setOneShotPreviewCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "setOneShotPreviewCallback",
      "(Landroid/hardware/Camera\$PreviewCallback;)V");

  /// from: public final void setOneShotPreviewCallback(android.hardware.Camera.PreviewCallback cb)
  ///
  /// Installs a callback to be invoked for the next preview frame in
  /// addition to displaying it on the screen.  After one invocation, the
  /// callback is cleared. This method can be called any time, even when
  /// preview is live.  Any other preview callbacks are overridden.
  ///
  ///
  /// If you are using the preview data to create video or still images,
  /// strongly consider using android.media.MediaActionSound to
  /// properly indicate image capture or recording start/stop to the user.
  ///
  ///@param cb a callback object that receives a copy of the next preview frame,
  ///     or null to stop receiving callbacks.
  ///@throws RuntimeException if release() has been called on this Camera
  ///     instance.
  ///@see android.media.MediaActionSound
  void setOneShotPreviewCallback(Camera_PreviewCallback cb) =>
      jniAccessors.callMethodWithArgs(reference, _id_setOneShotPreviewCallback,
          jni.JniType.voidType, [cb.reference]).check();

  static final _id_setPreviewCallbackWithBuffer = jniAccessors.getMethodIDOf(
      _classRef,
      "setPreviewCallbackWithBuffer",
      "(Landroid/hardware/Camera\$PreviewCallback;)V");

  /// from: public final void setPreviewCallbackWithBuffer(android.hardware.Camera.PreviewCallback cb)
  ///
  /// Installs a callback to be invoked for every preview frame, using
  /// buffers supplied with \#addCallbackBuffer(byte[]), in addition to
  /// displaying them on the screen.  The callback will be repeatedly called
  /// for as long as preview is active and buffers are available.  Any other
  /// preview callbacks are overridden.
  ///
  ///
  /// The purpose of this method is to improve preview efficiency and frame
  /// rate by allowing preview frame memory reuse.  You must call
  /// \#addCallbackBuffer(byte[]) at some point -- before or after
  /// calling this method -- or no callbacks will received.
  ///
  ///
  /// The buffer queue will be cleared if this method is called with a null
  /// callback, \#setPreviewCallback(Camera.PreviewCallback) is called,
  /// or \#setOneShotPreviewCallback(Camera.PreviewCallback) is
  /// called.
  ///
  ///
  /// If you are using the preview data to create video or still images,
  /// strongly consider using android.media.MediaActionSound to
  /// properly indicate image capture or recording start/stop to the user.
  ///
  ///@param cb a callback object that receives a copy of the preview frame,
  ///     or null to stop receiving callbacks and clear the buffer queue.
  ///@throws RuntimeException if release() has been called on this Camera
  ///     instance.
  ///@see \#addCallbackBuffer(byte[])
  ///@see android.media.MediaActionSound
  void setPreviewCallbackWithBuffer(Camera_PreviewCallback cb) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setPreviewCallbackWithBuffer,
          jni.JniType.voidType,
          [cb.reference]).check();

  static final _id_addCallbackBuffer =
      jniAccessors.getMethodIDOf(_classRef, "addCallbackBuffer", "([B)V");

  /// from: public final void addCallbackBuffer(byte[] callbackBuffer)
  ///
  /// Adds a pre-allocated buffer to the preview callback buffer queue.
  /// Applications can add one or more buffers to the queue. When a preview
  /// frame arrives and there is still at least one available buffer, the
  /// buffer will be used and removed from the queue. Then preview callback is
  /// invoked with the buffer. If a frame arrives and there is no buffer left,
  /// the frame is discarded. Applications should add buffers back when they
  /// finish processing the data in them.
  ///
  /// For formats besides YV12, the size of the buffer is determined by
  /// multiplying the preview image width, height, and bytes per pixel. The
  /// width and height can be read from
  /// Camera.Parameters\#getPreviewSize(). Bytes per pixel can be
  /// computed from android.graphics.ImageFormat\#getBitsPerPixel(int) /
  /// 8, using the image format from
  /// Camera.Parameters\#getPreviewFormat().
  ///
  /// If using the android.graphics.ImageFormat\#YV12 format, the
  /// size can be calculated using the equations listed in
  /// Camera.Parameters\#setPreviewFormat.
  ///
  /// This method is only necessary when
  /// \#setPreviewCallbackWithBuffer(PreviewCallback) is used. When
  /// \#setPreviewCallback(PreviewCallback) or
  /// \#setOneShotPreviewCallback(PreviewCallback) are used, buffers
  /// are automatically allocated. When a supplied buffer is too small to
  /// hold the preview frame data, preview callback will return null and
  /// the buffer will be removed from the buffer queue.
  ///@param callbackBuffer the buffer to add to the queue. The size of the
  ///   buffer must match the values described above.
  ///@see \#setPreviewCallbackWithBuffer(PreviewCallback)
  void addCallbackBuffer(jni.JniObject callbackBuffer) =>
      jniAccessors.callMethodWithArgs(reference, _id_addCallbackBuffer,
          jni.JniType.voidType, [callbackBuffer.reference]).check();

  static final _id_autoFocus = jniAccessors.getMethodIDOf(_classRef,
      "autoFocus", "(Landroid/hardware/Camera\$AutoFocusCallback;)V");

  /// from: public final void autoFocus(android.hardware.Camera.AutoFocusCallback cb)
  ///
  /// Starts camera auto-focus and registers a callback function to run when
  /// the camera is focused.  This method is only valid when preview is active
  /// (between \#startPreview() and before \#stopPreview()).
  ///
  /// Callers should check
  /// android.hardware.Camera.Parameters\#getFocusMode() to determine if
  /// this method should be called. If the camera does not support auto-focus,
  /// it is a no-op and AutoFocusCallback\#onAutoFocus(boolean, Camera)
  /// callback will be called immediately.
  ///
  /// If your application should not be installed
  /// on devices without auto-focus, you must declare that your application
  /// uses auto-focus with the
  /// <a href="{@docRoot}guide/topics/manifest/uses-feature-element.html">&lt;uses-feature></a>
  /// manifest element.
  ///
  ///
  /// If the current flash mode is not
  /// android.hardware.Camera.Parameters\#FLASH_MODE_OFF, flash may be
  /// fired during auto-focus, depending on the driver and camera hardware.
  ///
  /// Auto-exposure lock android.hardware.Camera.Parameters\#getAutoExposureLock()
  /// and auto-white balance locks android.hardware.Camera.Parameters\#getAutoWhiteBalanceLock()
  /// do not change during and after autofocus. But auto-focus routine may stop
  /// auto-exposure and auto-white balance transiently during focusing.
  ///
  /// Stopping preview with \#stopPreview(), or triggering still
  /// image capture with \#takePicture(Camera.ShutterCallback,
  /// Camera.PictureCallback, Camera.PictureCallback), will not change the
  /// the focus position. Applications must call cancelAutoFocus to reset the
  /// focus.
  ///
  ///
  /// If autofocus is successful, consider using
  /// android.media.MediaActionSound to properly play back an autofocus
  /// success sound to the user.
  ///
  ///@param cb the callback to run
  ///@throws RuntimeException if starting autofocus fails; usually this would
  ///    be because of a hardware or other low-level error, or because
  ///    release() has been called on this Camera instance.
  ///@see \#cancelAutoFocus()
  ///@see android.hardware.Camera.Parameters\#setAutoExposureLock(boolean)
  ///@see android.hardware.Camera.Parameters\#setAutoWhiteBalanceLock(boolean)
  ///@see android.media.MediaActionSound
  void autoFocus(Camera_AutoFocusCallback cb) =>
      jniAccessors.callMethodWithArgs(reference, _id_autoFocus,
          jni.JniType.voidType, [cb.reference]).check();

  static final _id_cancelAutoFocus =
      jniAccessors.getMethodIDOf(_classRef, "cancelAutoFocus", "()V");

  /// from: public final void cancelAutoFocus()
  ///
  /// Cancels any auto-focus function in progress.
  /// Whether or not auto-focus is currently in progress,
  /// this function will return the focus position to the default.
  /// If the camera does not support auto-focus, this is a no-op.
  ///@throws RuntimeException if canceling autofocus fails; usually this would
  ///    be because of a hardware or other low-level error, or because
  ///    release() has been called on this Camera instance.
  ///@see \#autoFocus(Camera.AutoFocusCallback)
  void cancelAutoFocus() => jniAccessors.callMethodWithArgs(
      reference, _id_cancelAutoFocus, jni.JniType.voidType, []).check();

  static final _id_setAutoFocusMoveCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "setAutoFocusMoveCallback",
      "(Landroid/hardware/Camera\$AutoFocusMoveCallback;)V");

  /// from: public void setAutoFocusMoveCallback(android.hardware.Camera.AutoFocusMoveCallback cb)
  ///
  /// Sets camera auto-focus move callback.
  ///@param cb the callback to run
  ///@throws RuntimeException if enabling the focus move callback fails;
  ///    usually this would be because of a hardware or other low-level error,
  ///    or because release() has been called on this Camera instance.
  void setAutoFocusMoveCallback(Camera_AutoFocusMoveCallback cb) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAutoFocusMoveCallback,
          jni.JniType.voidType, [cb.reference]).check();

  static final _id_takePicture = jniAccessors.getMethodIDOf(
      _classRef,
      "takePicture",
      "(Landroid/hardware/Camera\$ShutterCallback;Landroid/hardware/Camera\$PictureCallback;Landroid/hardware/Camera\$PictureCallback;)V");

  /// from: public final void takePicture(android.hardware.Camera.ShutterCallback shutter, android.hardware.Camera.PictureCallback raw, android.hardware.Camera.PictureCallback jpeg)
  ///
  /// Equivalent to <pre>takePicture(Shutter, raw, null, jpeg)</pre>.
  ///@see \#takePicture(ShutterCallback, PictureCallback, PictureCallback, PictureCallback)
  void takePicture(Camera_ShutterCallback shutter, Camera_PictureCallback raw,
          Camera_PictureCallback jpeg) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_takePicture,
          jni.JniType.voidType,
          [shutter.reference, raw.reference, jpeg.reference]).check();

  static final _id_takePicture1 = jniAccessors.getMethodIDOf(
      _classRef,
      "takePicture",
      "(Landroid/hardware/Camera\$ShutterCallback;Landroid/hardware/Camera\$PictureCallback;Landroid/hardware/Camera\$PictureCallback;Landroid/hardware/Camera\$PictureCallback;)V");

  /// from: public final void takePicture(android.hardware.Camera.ShutterCallback shutter, android.hardware.Camera.PictureCallback raw, android.hardware.Camera.PictureCallback postview, android.hardware.Camera.PictureCallback jpeg)
  ///
  /// Triggers an asynchronous image capture. The camera service will initiate
  /// a series of callbacks to the application as the image capture progresses.
  /// The shutter callback occurs after the image is captured. This can be used
  /// to trigger a sound to let the user know that image has been captured. The
  /// raw callback occurs when the raw image data is available (NOTE: the data
  /// will be null if there is no raw image callback buffer available or the
  /// raw image callback buffer is not large enough to hold the raw image).
  /// The postview callback occurs when a scaled, fully processed postview
  /// image is available (NOTE: not all hardware supports this). The jpeg
  /// callback occurs when the compressed image is available. If the
  /// application does not need a particular callback, a null can be passed
  /// instead of a callback method.
  ///
  /// This method is only valid when preview is active (after
  /// \#startPreview()).  Preview will be stopped after the image is
  /// taken; callers must call \#startPreview() again if they want to
  /// re-start preview or take more pictures. This should not be called between
  /// android.media.MediaRecorder\#start() and
  /// android.media.MediaRecorder\#stop().
  ///
  /// After calling this method, you must not call \#startPreview()
  /// or take another picture until the JPEG callback has returned.
  ///@param shutter the callback for image capture moment, or null
  ///@param raw the callback for raw (uncompressed) image data, or null
  ///@param postview callback with postview image data, may be null
  ///@param jpeg the callback for JPEG image data, or null
  ///@throws RuntimeException if starting picture capture fails; usually this
  ///    would be because of a hardware or other low-level error, or because
  ///    release() has been called on this Camera instance.
  void takePicture1(Camera_ShutterCallback shutter, Camera_PictureCallback raw,
          Camera_PictureCallback postview, Camera_PictureCallback jpeg) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_takePicture1, jni.JniType.voidType, [
        shutter.reference,
        raw.reference,
        postview.reference,
        jpeg.reference
      ]).check();

  static final _id_startSmoothZoom =
      jniAccessors.getMethodIDOf(_classRef, "startSmoothZoom", "(I)V");

  /// from: public native final void startSmoothZoom(int value)
  ///
  /// Zooms to the requested value smoothly. The driver will notify OnZoomChangeListener of the zoom value and whether zoom is stopped at
  /// the time. For example, suppose the current zoom is 0 and startSmoothZoom
  /// is called with value 3. The
  /// Camera.OnZoomChangeListener\#onZoomChange(int, boolean, Camera)
  /// method will be called three times with zoom values 1, 2, and 3.
  /// Applications can call \#stopSmoothZoom to stop the zoom earlier.
  /// Applications should not call startSmoothZoom again or change the zoom
  /// value before zoom stops. If the supplied zoom value equals to the current
  /// zoom value, no zoom callback will be generated. This method is supported
  /// if android.hardware.Camera.Parameters\#isSmoothZoomSupported
  /// returns true.
  ///@param value zoom value. The valid range is 0 to android.hardware.Camera.Parameters\#getMaxZoom.
  ///@throws IllegalArgumentException if the zoom value is invalid.
  ///@throws RuntimeException if the method fails.
  ///@see \#setZoomChangeListener(OnZoomChangeListener)
  void startSmoothZoom(int value) => jniAccessors.callMethodWithArgs(
      reference, _id_startSmoothZoom, jni.JniType.voidType, [value]).check();

  static final _id_stopSmoothZoom =
      jniAccessors.getMethodIDOf(_classRef, "stopSmoothZoom", "()V");

  /// from: public native final void stopSmoothZoom()
  ///
  /// Stops the smooth zoom. Applications should wait for the OnZoomChangeListener to know when the zoom is actually stopped. This
  /// method is supported if android.hardware.Camera.Parameters\#isSmoothZoomSupported is true.
  ///@throws RuntimeException if the method fails.
  void stopSmoothZoom() => jniAccessors.callMethodWithArgs(
      reference, _id_stopSmoothZoom, jni.JniType.voidType, []).check();

  static final _id_setDisplayOrientation =
      jniAccessors.getMethodIDOf(_classRef, "setDisplayOrientation", "(I)V");

  /// from: public native final void setDisplayOrientation(int degrees)
  ///
  /// Set the clockwise rotation of preview display in degrees. This affects
  /// the preview frames and the picture displayed after snapshot. This method
  /// is useful for portrait mode applications. Note that preview display of
  /// front-facing cameras is flipped horizontally before the rotation, that
  /// is, the image is reflected along the central vertical axis of the camera
  /// sensor. So the users can see themselves as looking into a mirror.
  ///
  /// This does not affect the order of byte array passed in PreviewCallback\#onPreviewFrame, JPEG pictures, or recorded videos. This
  /// method is not allowed to be called during preview.
  ///
  /// If you want to make the camera image show in the same orientation as
  /// the display, you can use the following code.
  /// <pre>
  /// public static void setCameraDisplayOrientation(Activity activity,
  ///         int cameraId, android.hardware.Camera camera) {
  ///     android.hardware.Camera.CameraInfo info =
  ///             new android.hardware.Camera.CameraInfo();
  ///     android.hardware.Camera.getCameraInfo(cameraId, info);
  ///     int rotation = activity.getWindowManager().getDefaultDisplay()
  ///             .getRotation();
  ///     int degrees = 0;
  ///     switch (rotation) {
  ///         case Surface.ROTATION_0: degrees = 0; break;
  ///         case Surface.ROTATION_90: degrees = 90; break;
  ///         case Surface.ROTATION_180: degrees = 180; break;
  ///         case Surface.ROTATION_270: degrees = 270; break;
  ///     }
  ///
  ///     int result;
  ///     if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
  ///         result = (info.orientation + degrees) % 360;
  ///         result = (360 - result) % 360;  // compensate the mirror
  ///     } else {  // back-facing
  ///         result = (info.orientation - degrees + 360) % 360;
  ///     }
  ///     camera.setDisplayOrientation(result);
  /// }
  /// </pre>
  ///
  /// Starting from API level 14, this method can be called when preview is
  /// active.
  ///
  /// __Note: __Before API level 24, the default value for orientation is 0. Starting in
  /// API level 24, the default orientation will be such that applications in forced-landscape mode
  /// will have correct preview orientation, which may be either a default of 0 or
  /// 180. Applications that operate in portrait mode or allow for changing orientation must still
  /// call this method after each orientation change to ensure correct preview display in all
  /// cases.
  ///
  ///@param degrees the angle that the picture will be rotated clockwise.
  ///                Valid values are 0, 90, 180, and 270.
  ///@throws RuntimeException if setting orientation fails; usually this would
  ///    be because of a hardware or other low-level error, or because
  ///    release() has been called on this Camera instance.
  ///@see \#setPreviewDisplay(SurfaceHolder)
  void setDisplayOrientation(int degrees) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDisplayOrientation,
      jni.JniType.voidType,
      [degrees]).check();

  static final _id_enableShutterSound =
      jniAccessors.getMethodIDOf(_classRef, "enableShutterSound", "(Z)Z");

  /// from: public final boolean enableShutterSound(boolean enabled)
  ///
  /// Enable or disable the default shutter sound when taking a picture.
  ///
  ///
  /// By default, the camera plays the system-defined camera shutter sound
  /// when \#takePicture is called. Using this method, the shutter sound
  /// can be disabled. It is strongly recommended that an alternative shutter
  /// sound is played in the ShutterCallback when the system shutter
  /// sound is disabled.
  ///
  ///
  /// Note that devices may not always allow disabling the camera shutter
  /// sound. If the shutter sound state cannot be set to the desired value,
  /// this method will return false. CameraInfo\#canDisableShutterSound
  /// can be used to determine whether the device will allow the shutter sound
  /// to be disabled.
  ///
  ///@param enabled whether the camera should play the system shutter sound
  ///                when \#takePicture takePicture is called.
  ///@return {@code true} if the shutter sound state was successfully
  ///         changed. {@code false} if the shutter sound state could not be
  ///         changed. {@code true} is also returned if shutter sound playback
  ///         is already set to the requested state.
  ///@throws RuntimeException if the call fails; usually this would be because
  ///    of a hardware or other low-level error, or because release() has been
  ///    called on this Camera instance.
  ///@see \#takePicture
  ///@see CameraInfo\#canDisableShutterSound
  ///@see ShutterCallback
  bool enableShutterSound(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_enableShutterSound,
      jni.JniType.booleanType,
      [enabled]).boolean;

  static final _id_setZoomChangeListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setZoomChangeListener",
      "(Landroid/hardware/Camera\$OnZoomChangeListener;)V");

  /// from: public final void setZoomChangeListener(android.hardware.Camera.OnZoomChangeListener listener)
  ///
  /// Registers a listener to be notified when the zoom value is updated by the
  /// camera driver during smooth zoom.
  ///@param listener the listener to notify
  ///@see \#startSmoothZoom(int)
  void setZoomChangeListener(Camera_OnZoomChangeListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setZoomChangeListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setFaceDetectionListener = jniAccessors.getMethodIDOf(
      _classRef,
      "setFaceDetectionListener",
      "(Landroid/hardware/Camera\$FaceDetectionListener;)V");

  /// from: public final void setFaceDetectionListener(android.hardware.Camera.FaceDetectionListener listener)
  ///
  /// Registers a listener to be notified about the faces detected in the
  /// preview frame.
  ///@param listener the listener to notify
  ///@see \#startFaceDetection()
  void setFaceDetectionListener(Camera_FaceDetectionListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFaceDetectionListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_startFaceDetection =
      jniAccessors.getMethodIDOf(_classRef, "startFaceDetection", "()V");

  /// from: public final void startFaceDetection()
  ///
  /// Starts the face detection. This should be called after preview is started.
  /// The camera will notify FaceDetectionListener of the detected
  /// faces in the preview frame. The detected faces may be the same as the
  /// previous ones. Applications should call \#stopFaceDetection to
  /// stop the face detection. This method is supported if Parameters\#getMaxNumDetectedFaces() returns a number larger than 0.
  /// If the face detection has started, apps should not call this again.
  ///
  /// When the face detection is running, Parameters\#setWhiteBalance(String),
  /// Parameters\#setFocusAreas(List), and Parameters\#setMeteringAreas(List)
  /// have no effect. The camera uses the detected faces to do auto-white balance,
  /// auto exposure, and autofocus.
  ///
  /// If the apps call \#autoFocus(AutoFocusCallback), the camera
  /// will stop sending face callbacks. The last face callback indicates the
  /// areas used to do autofocus. After focus completes, face detection will
  /// resume sending face callbacks. If the apps call \#cancelAutoFocus(), the face callbacks will also resume.
  ///
  ///
  /// After calling \#takePicture(Camera.ShutterCallback, Camera.PictureCallback,
  /// Camera.PictureCallback) or \#stopPreview(), and then resuming
  /// preview with \#startPreview(), the apps should call this method
  /// again to resume face detection.
  ///
  ///@throws IllegalArgumentException if the face detection is unsupported.
  ///@throws RuntimeException if the method fails or the face detection is
  ///         already running.
  ///@see FaceDetectionListener
  ///@see \#stopFaceDetection()
  ///@see Parameters\#getMaxNumDetectedFaces()
  void startFaceDetection() => jniAccessors.callMethodWithArgs(
      reference, _id_startFaceDetection, jni.JniType.voidType, []).check();

  static final _id_stopFaceDetection =
      jniAccessors.getMethodIDOf(_classRef, "stopFaceDetection", "()V");

  /// from: public final void stopFaceDetection()
  ///
  /// Stops the face detection.
  ///@see \#startFaceDetection()
  void stopFaceDetection() => jniAccessors.callMethodWithArgs(
      reference, _id_stopFaceDetection, jni.JniType.voidType, []).check();

  static final _id_setErrorCallback = jniAccessors.getMethodIDOf(_classRef,
      "setErrorCallback", "(Landroid/hardware/Camera\$ErrorCallback;)V");

  /// from: public final void setErrorCallback(android.hardware.Camera.ErrorCallback cb)
  ///
  /// Registers a callback to be invoked when an error occurs.
  ///@param cb The callback to run
  void setErrorCallback(Camera_ErrorCallback cb) =>
      jniAccessors.callMethodWithArgs(reference, _id_setErrorCallback,
          jni.JniType.voidType, [cb.reference]).check();

  static final _id_setParameters = jniAccessors.getMethodIDOf(
      _classRef, "setParameters", "(Landroid/hardware/Camera\$Parameters;)V");

  /// from: public void setParameters(android.hardware.Camera.Parameters params)
  ///
  /// Changes the settings for this Camera service.
  ///@param params the Parameters to use for this Camera service
  ///@throws RuntimeException if any parameter is invalid or not supported.
  ///@see \#getParameters()
  void setParameters(Camera_Parameters params) =>
      jniAccessors.callMethodWithArgs(reference, _id_setParameters,
          jni.JniType.voidType, [params.reference]).check();

  static final _id_getParameters = jniAccessors.getMethodIDOf(
      _classRef, "getParameters", "()Landroid/hardware/Camera\$Parameters;");

  /// from: public android.hardware.Camera.Parameters getParameters()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current settings for this Camera service.
  /// If modifications are made to the returned Parameters, they must be passed
  /// to \#setParameters(Camera.Parameters) to take effect.
  ///@throws RuntimeException if reading parameters fails; usually this would
  ///    be because of a hardware or other low-level error, or because
  ///    release() has been called on this Camera instance.
  ///@see \#setParameters(Camera.Parameters)
  Camera_Parameters getParameters() =>
      Camera_Parameters.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getParameters, jni.JniType.objectType, []).object);
}

/// from: android.hardware.Camera$Size
///
/// Image size (width and height dimensions).
///@deprecated We recommend using the new android.hardware.camera2 API for new
///             applications.
class Camera_Size extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/Camera\$Size");
  Camera_Size.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_height = jniAccessors.getFieldIDOf(_classRef, "height", "I");

  /// from: public int height
  ///
  /// height of the picture
  int get height =>
      jniAccessors.getField(reference, _id_height, jni.JniType.intType).integer;

  /// from: public int height
  ///
  /// height of the picture
  set height(int value) => jniEnv.SetIntField(reference, _id_height, value);

  static final _id_width = jniAccessors.getFieldIDOf(_classRef, "width", "I");

  /// from: public int width
  ///
  /// width of the picture
  int get width =>
      jniAccessors.getField(reference, _id_width, jni.JniType.intType).integer;

  /// from: public int width
  ///
  /// width of the picture
  set width(int value) => jniEnv.SetIntField(reference, _id_width, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(II)V");

  /// from: public void <init>(int w, int h)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the dimensions for pictures.
  ///@param w the photo width (pixels)
  ///@param h the photo height (pixels)
  Camera_Size(int w, int h)
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [w, h]).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// Compares {@code obj} to this size.
  ///@param obj the object to compare this size with.
  ///@return {@code true} if the width and height of {@code obj} is the
  ///         same as those of this size. {@code false} otherwise.
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}

/// from: android.hardware.Camera$ShutterCallback
///
/// Callback interface used to signal the moment of actual image capture.
///@see \#takePicture(ShutterCallback, PictureCallback, PictureCallback, PictureCallback)
///@deprecated We recommend using the new android.hardware.camera2 API for new
///             applications.
class Camera_ShutterCallback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/Camera\$ShutterCallback");
  Camera_ShutterCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onShutter =
      jniAccessors.getMethodIDOf(_classRef, "onShutter", "()V");

  /// from: public abstract void onShutter()
  ///
  /// Called as near as possible to the moment when a photo is captured
  /// from the sensor.  This is a good opportunity to play a shutter sound
  /// or give other feedback of camera operation.  This may be some time
  /// after the photo was triggered, but some time before the actual data
  /// is available.
  void onShutter() => jniAccessors.callMethodWithArgs(
      reference, _id_onShutter, jni.JniType.voidType, []).check();
}

/// from: android.hardware.Camera$PreviewCallback
///
/// Callback interface used to deliver copies of preview frames as
/// they are displayed.
///@see \#setPreviewCallback(Camera.PreviewCallback)
///@see \#setOneShotPreviewCallback(Camera.PreviewCallback)
///@see \#setPreviewCallbackWithBuffer(Camera.PreviewCallback)
///@see \#startPreview()
///@deprecated We recommend using the new android.hardware.camera2 API for new
///             applications.
class Camera_PreviewCallback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/Camera\$PreviewCallback");
  Camera_PreviewCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onPreviewFrame = jniAccessors.getMethodIDOf(
      _classRef, "onPreviewFrame", "([BLandroid/hardware/Camera;)V");

  /// from: public abstract void onPreviewFrame(byte[] data, android.hardware.Camera camera)
  ///
  /// Called as preview frames are displayed.  This callback is invoked
  /// on the event thread \#open(int) was called from.
  ///
  /// If using the android.graphics.ImageFormat\#YV12 format,
  /// refer to the equations in Camera.Parameters\#setPreviewFormat
  /// for the arrangement of the pixel data in the preview callback
  /// buffers.
  ///@param data the contents of the preview frame in the format defined
  ///  by android.graphics.ImageFormat, which can be queried
  ///  with android.hardware.Camera.Parameters\#getPreviewFormat().
  ///  If android.hardware.Camera.Parameters\#setPreviewFormat(int)
  ///             is never called, the default will be the YCbCr_420_SP
  ///             (NV21) format.
  ///@param camera the Camera service object.
  void onPreviewFrame(jni.JniObject data, Camera camera) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPreviewFrame,
          jni.JniType.voidType, [data.reference, camera.reference]).check();
}

/// from: android.hardware.Camera$PictureCallback
///
/// Callback interface used to supply image data from a photo capture.
///@see \#takePicture(ShutterCallback, PictureCallback, PictureCallback, PictureCallback)
///@deprecated We recommend using the new android.hardware.camera2 API for new
///             applications.
class Camera_PictureCallback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/Camera\$PictureCallback");
  Camera_PictureCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onPictureTaken = jniAccessors.getMethodIDOf(
      _classRef, "onPictureTaken", "([BLandroid/hardware/Camera;)V");

  /// from: public abstract void onPictureTaken(byte[] data, android.hardware.Camera camera)
  ///
  /// Called when image data is available after a picture is taken.
  /// The format of the data depends on the context of the callback
  /// and Camera.Parameters settings.
  ///@param data a byte array of the picture data
  ///@param camera the Camera service object
  void onPictureTaken(jni.JniObject data, Camera camera) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPictureTaken,
          jni.JniType.voidType, [data.reference, camera.reference]).check();
}

/// from: android.hardware.Camera$Parameters
///
/// Camera service settings.
///
/// To make camera parameters take effect, applications have to call
/// Camera\#setParameters(Camera.Parameters). For example, after
/// Camera.Parameters\#setWhiteBalance is called, white balance is not
/// actually changed until Camera\#setParameters(Camera.Parameters)
/// is called with the changed parameters object.
///
/// Different devices may have different camera capabilities, such as
/// picture size or flash modes. The application should query the camera
/// capabilities before setting parameters. For example, the application
/// should call Camera.Parameters\#getSupportedColorEffects() before
/// calling Camera.Parameters\#setColorEffect(String). If the
/// camera does not support color effects,
/// Camera.Parameters\#getSupportedColorEffects() will return null.
///@deprecated We recommend using the new android.hardware.camera2 API for new
///             applications.
class Camera_Parameters extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/Camera\$Parameters");
  Camera_Parameters.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ANTIBANDING_50HZ
  static const ANTIBANDING_50HZ = "50hz";

  /// from: static public final java.lang.String ANTIBANDING_60HZ
  static const ANTIBANDING_60HZ = "60hz";

  /// from: static public final java.lang.String ANTIBANDING_AUTO
  static const ANTIBANDING_AUTO = "auto";

  /// from: static public final java.lang.String ANTIBANDING_OFF
  static const ANTIBANDING_OFF = "off";

  /// from: static public final java.lang.String EFFECT_AQUA
  static const EFFECT_AQUA = "aqua";

  /// from: static public final java.lang.String EFFECT_BLACKBOARD
  static const EFFECT_BLACKBOARD = "blackboard";

  /// from: static public final java.lang.String EFFECT_MONO
  static const EFFECT_MONO = "mono";

  /// from: static public final java.lang.String EFFECT_NEGATIVE
  static const EFFECT_NEGATIVE = "negative";

  /// from: static public final java.lang.String EFFECT_NONE
  static const EFFECT_NONE = "none";

  /// from: static public final java.lang.String EFFECT_POSTERIZE
  static const EFFECT_POSTERIZE = "posterize";

  /// from: static public final java.lang.String EFFECT_SEPIA
  static const EFFECT_SEPIA = "sepia";

  /// from: static public final java.lang.String EFFECT_SOLARIZE
  static const EFFECT_SOLARIZE = "solarize";

  /// from: static public final java.lang.String EFFECT_WHITEBOARD
  static const EFFECT_WHITEBOARD = "whiteboard";

  /// from: static public final java.lang.String FLASH_MODE_AUTO
  ///
  /// Flash will be fired automatically when required. The flash may be fired
  /// during preview, auto-focus, or snapshot depending on the driver.
  static const FLASH_MODE_AUTO = "auto";

  /// from: static public final java.lang.String FLASH_MODE_OFF
  ///
  /// Flash will not be fired.
  static const FLASH_MODE_OFF = "off";

  /// from: static public final java.lang.String FLASH_MODE_ON
  ///
  /// Flash will always be fired during snapshot. The flash may also be
  /// fired during preview or auto-focus depending on the driver.
  static const FLASH_MODE_ON = "on";

  /// from: static public final java.lang.String FLASH_MODE_RED_EYE
  ///
  /// Flash will be fired in red-eye reduction mode.
  static const FLASH_MODE_RED_EYE = "red-eye";

  /// from: static public final java.lang.String FLASH_MODE_TORCH
  ///
  /// Constant emission of light during preview, auto-focus and snapshot.
  /// This can also be used for video recording.
  static const FLASH_MODE_TORCH = "torch";

  /// from: static public final int FOCUS_DISTANCE_FAR_INDEX
  ///
  /// The array index of far focus distance for use with
  /// \#getFocusDistances(float[]).
  static const FOCUS_DISTANCE_FAR_INDEX = 2;

  /// from: static public final int FOCUS_DISTANCE_NEAR_INDEX
  ///
  /// The array index of near focus distance for use with
  /// \#getFocusDistances(float[]).
  static const FOCUS_DISTANCE_NEAR_INDEX = 0;

  /// from: static public final int FOCUS_DISTANCE_OPTIMAL_INDEX
  ///
  /// The array index of optimal focus distance for use with
  /// \#getFocusDistances(float[]).
  static const FOCUS_DISTANCE_OPTIMAL_INDEX = 1;

  /// from: static public final java.lang.String FOCUS_MODE_AUTO
  ///
  /// Auto-focus mode. Applications should call \#autoFocus(AutoFocusCallback) to start the focus in this mode.
  static const FOCUS_MODE_AUTO = "auto";

  /// from: static public final java.lang.String FOCUS_MODE_CONTINUOUS_PICTURE
  ///
  /// Continuous auto focus mode intended for taking pictures. The camera
  /// continuously tries to focus. The speed of focus change is more
  /// aggressive than \#FOCUS_MODE_CONTINUOUS_VIDEO. Auto focus
  /// starts when the parameter is set.
  ///
  /// Applications can call \#autoFocus(AutoFocusCallback) in
  /// this mode. If the autofocus is in the middle of scanning, the focus
  /// callback will return when it completes. If the autofocus is not
  /// scanning, the focus callback will immediately return with a boolean
  /// that indicates whether the focus is sharp or not. The apps can then
  /// decide if they want to take a picture immediately or to change the
  /// focus mode to auto, and run a full autofocus cycle. The focus
  /// position is locked after autoFocus call. If applications want to
  /// resume the continuous focus, cancelAutoFocus must be called.
  /// Restarting the preview will not resume the continuous autofocus. To
  /// stop continuous focus, applications should change the focus mode to
  /// other modes.
  ///@see \#FOCUS_MODE_CONTINUOUS_VIDEO
  static const FOCUS_MODE_CONTINUOUS_PICTURE = "continuous-picture";

  /// from: static public final java.lang.String FOCUS_MODE_CONTINUOUS_VIDEO
  ///
  /// Continuous auto focus mode intended for video recording. The camera
  /// continuously tries to focus. This is the best choice for video
  /// recording because the focus changes smoothly . Applications still can
  /// call \#takePicture(Camera.ShutterCallback,
  /// Camera.PictureCallback, Camera.PictureCallback) in this mode but the
  /// subject may not be in focus. Auto focus starts when the parameter is
  /// set.
  ///
  /// Since API level 14, applications can call \#autoFocus(AutoFocusCallback) in this mode. The focus callback will
  /// immediately return with a boolean that indicates whether the focus is
  /// sharp or not. The focus position is locked after autoFocus call. If
  /// applications want to resume the continuous focus, cancelAutoFocus
  /// must be called. Restarting the preview will not resume the continuous
  /// autofocus. To stop continuous focus, applications should change the
  /// focus mode to other modes.
  ///@see \#FOCUS_MODE_CONTINUOUS_PICTURE
  static const FOCUS_MODE_CONTINUOUS_VIDEO = "continuous-video";

  /// from: static public final java.lang.String FOCUS_MODE_EDOF
  ///
  /// Extended depth of field (EDOF). Focusing is done digitally and
  /// continuously. Applications should not call \#autoFocus(AutoFocusCallback) in this mode.
  static const FOCUS_MODE_EDOF = "edof";

  /// from: static public final java.lang.String FOCUS_MODE_FIXED
  ///
  /// Focus is fixed. The camera is always in this mode if the focus is not
  /// adjustable. If the camera has auto-focus, this mode can fix the
  /// focus, which is usually at hyperfocal distance. Applications should
  /// not call \#autoFocus(AutoFocusCallback) in this mode.
  static const FOCUS_MODE_FIXED = "fixed";

  /// from: static public final java.lang.String FOCUS_MODE_INFINITY
  ///
  /// Focus is set at infinity. Applications should not call
  /// \#autoFocus(AutoFocusCallback) in this mode.
  static const FOCUS_MODE_INFINITY = "infinity";

  /// from: static public final java.lang.String FOCUS_MODE_MACRO
  ///
  /// Macro (close-up) focus mode. Applications should call
  /// \#autoFocus(AutoFocusCallback) to start the focus in this
  /// mode.
  static const FOCUS_MODE_MACRO = "macro";

  /// from: static public final int PREVIEW_FPS_MAX_INDEX
  ///
  /// The array index of maximum preview fps for use with \#getPreviewFpsRange(int[]) or \#getSupportedPreviewFpsRange().
  static const PREVIEW_FPS_MAX_INDEX = 1;

  /// from: static public final int PREVIEW_FPS_MIN_INDEX
  ///
  /// The array index of minimum preview fps for use with \#getPreviewFpsRange(int[]) or \#getSupportedPreviewFpsRange().
  static const PREVIEW_FPS_MIN_INDEX = 0;

  /// from: static public final java.lang.String SCENE_MODE_ACTION
  ///
  /// Take photos of fast moving objects. Same as \#SCENE_MODE_SPORTS.
  static const SCENE_MODE_ACTION = "action";

  /// from: static public final java.lang.String SCENE_MODE_AUTO
  ///
  /// Scene mode is off.
  static const SCENE_MODE_AUTO = "auto";

  /// from: static public final java.lang.String SCENE_MODE_BARCODE
  ///
  /// Applications are looking for a barcode. Camera driver will be
  /// optimized for barcode reading.
  static const SCENE_MODE_BARCODE = "barcode";

  /// from: static public final java.lang.String SCENE_MODE_BEACH
  ///
  /// Take pictures on the beach.
  static const SCENE_MODE_BEACH = "beach";

  /// from: static public final java.lang.String SCENE_MODE_CANDLELIGHT
  ///
  /// Capture the naturally warm color of scenes lit by candles.
  static const SCENE_MODE_CANDLELIGHT = "candlelight";

  /// from: static public final java.lang.String SCENE_MODE_FIREWORKS
  ///
  /// For shooting firework displays.
  static const SCENE_MODE_FIREWORKS = "fireworks";

  /// from: static public final java.lang.String SCENE_MODE_HDR
  ///
  /// Capture a scene using high dynamic range imaging techniques. The
  /// camera will return an image that has an extended dynamic range
  /// compared to a regular capture. Capturing such an image may take
  /// longer than a regular capture.
  static const SCENE_MODE_HDR = "hdr";

  /// from: static public final java.lang.String SCENE_MODE_LANDSCAPE
  ///
  /// Take pictures on distant objects.
  static const SCENE_MODE_LANDSCAPE = "landscape";

  /// from: static public final java.lang.String SCENE_MODE_NIGHT
  ///
  /// Take photos at night.
  static const SCENE_MODE_NIGHT = "night";

  /// from: static public final java.lang.String SCENE_MODE_NIGHT_PORTRAIT
  ///
  /// Take people pictures at night.
  static const SCENE_MODE_NIGHT_PORTRAIT = "night-portrait";

  /// from: static public final java.lang.String SCENE_MODE_PARTY
  ///
  /// Take indoor low-light shot.
  static const SCENE_MODE_PARTY = "party";

  /// from: static public final java.lang.String SCENE_MODE_PORTRAIT
  ///
  /// Take people pictures.
  static const SCENE_MODE_PORTRAIT = "portrait";

  /// from: static public final java.lang.String SCENE_MODE_SNOW
  ///
  /// Take pictures on the snow.
  static const SCENE_MODE_SNOW = "snow";

  /// from: static public final java.lang.String SCENE_MODE_SPORTS
  ///
  /// Take photos of fast moving objects. Same as \#SCENE_MODE_ACTION.
  static const SCENE_MODE_SPORTS = "sports";

  /// from: static public final java.lang.String SCENE_MODE_STEADYPHOTO
  ///
  /// Avoid blurry pictures (for example, due to hand shake).
  static const SCENE_MODE_STEADYPHOTO = "steadyphoto";

  /// from: static public final java.lang.String SCENE_MODE_SUNSET
  ///
  /// Take sunset photos.
  static const SCENE_MODE_SUNSET = "sunset";

  /// from: static public final java.lang.String SCENE_MODE_THEATRE
  ///
  /// Take photos in a theater. Flash light is off.
  static const SCENE_MODE_THEATRE = "theatre";

  /// from: static public final java.lang.String WHITE_BALANCE_AUTO
  static const WHITE_BALANCE_AUTO = "auto";

  /// from: static public final java.lang.String WHITE_BALANCE_CLOUDY_DAYLIGHT
  static const WHITE_BALANCE_CLOUDY_DAYLIGHT = "cloudy-daylight";

  /// from: static public final java.lang.String WHITE_BALANCE_DAYLIGHT
  static const WHITE_BALANCE_DAYLIGHT = "daylight";

  /// from: static public final java.lang.String WHITE_BALANCE_FLUORESCENT
  static const WHITE_BALANCE_FLUORESCENT = "fluorescent";

  /// from: static public final java.lang.String WHITE_BALANCE_INCANDESCENT
  static const WHITE_BALANCE_INCANDESCENT = "incandescent";

  /// from: static public final java.lang.String WHITE_BALANCE_SHADE
  static const WHITE_BALANCE_SHADE = "shade";

  /// from: static public final java.lang.String WHITE_BALANCE_TWILIGHT
  static const WHITE_BALANCE_TWILIGHT = "twilight";

  /// from: static public final java.lang.String WHITE_BALANCE_WARM_FLUORESCENT
  static const WHITE_BALANCE_WARM_FLUORESCENT = "warm-fluorescent";

  static final _id_flatten =
      jniAccessors.getMethodIDOf(_classRef, "flatten", "()Ljava/lang/String;");

  /// from: public java.lang.String flatten()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a single string with all the parameters set in
  /// this Parameters object.
  /// The \#unflatten(String) method does the reverse.
  ///
  ///@return a String with all values from this Parameters object, in
  ///         semi-colon delimited key-value pairs
  jni.JniString flatten() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_flatten, jni.JniType.objectType, []).object);

  static final _id_unflatten = jniAccessors.getMethodIDOf(
      _classRef, "unflatten", "(Ljava/lang/String;)V");

  /// from: public void unflatten(java.lang.String flattened)
  ///
  /// Takes a flattened string of parameters and adds each one to
  /// this Parameters object.
  /// The \#flatten() method does the reverse.
  ///
  ///@param flattened a String of parameters (key-value paired) that
  ///                  are semi-colon delimited
  void unflatten(jni.JniString flattened) => jniAccessors.callMethodWithArgs(
      reference,
      _id_unflatten,
      jni.JniType.voidType,
      [flattened.reference]).check();

  static final _id_remove =
      jniAccessors.getMethodIDOf(_classRef, "remove", "(Ljava/lang/String;)V");

  /// from: public void remove(java.lang.String key)
  void remove(jni.JniString key) => jniAccessors.callMethodWithArgs(
      reference, _id_remove, jni.JniType.voidType, [key.reference]).check();

  static final _id_set0 = jniAccessors.getMethodIDOf(
      _classRef, "set", "(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void set(java.lang.String key, java.lang.String value)
  ///
  /// Sets a String parameter.
  ///@param key the key name for the parameter
  ///@param value the String value of the parameter
  void set0(jni.JniString key, jni.JniString value) =>
      jniAccessors.callMethodWithArgs(reference, _id_set0, jni.JniType.voidType,
          [key.reference, value.reference]).check();

  static final _id_set1 =
      jniAccessors.getMethodIDOf(_classRef, "set", "(Ljava/lang/String;I)V");

  /// from: public void set(java.lang.String key, int value)
  ///
  /// Sets an integer parameter.
  ///@param key the key name for the parameter
  ///@param value the int value of the parameter
  void set1(jni.JniString key, int value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_set1,
      jni.JniType.voidType,
      [key.reference, value]).check();

  static final _id_get0 = jniAccessors.getMethodIDOf(
      _classRef, "get", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String get(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the value of a String parameter.
  ///@param key the key name for the parameter
  ///@return the String value of the parameter
  jni.JniString get0(jni.JniString key) =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_get0, jni.JniType.objectType, [key.reference]).object);

  static final _id_getInt =
      jniAccessors.getMethodIDOf(_classRef, "getInt", "(Ljava/lang/String;)I");

  /// from: public int getInt(java.lang.String key)
  ///
  /// Returns the value of an integer parameter.
  ///@param key the key name for the parameter
  ///@return the int value of the parameter
  int getInt(jni.JniString key) => jniAccessors.callMethodWithArgs(
      reference, _id_getInt, jni.JniType.intType, [key.reference]).integer;

  static final _id_setPreviewSize =
      jniAccessors.getMethodIDOf(_classRef, "setPreviewSize", "(II)V");

  /// from: public void setPreviewSize(int width, int height)
  ///
  /// Sets the dimensions for preview pictures. If the preview has already
  /// started, applications should stop the preview first before changing
  /// preview size.
  ///
  /// The sides of width and height are based on camera orientation. That
  /// is, the preview size is the size before it is rotated by display
  /// orientation. So applications need to consider the display orientation
  /// while setting preview size. For example, suppose the camera supports
  /// both 480x320 and 320x480 preview sizes. The application wants a 3:2
  /// preview ratio. If the display orientation is set to 0 or 180, preview
  /// size should be set to 480x320. If the display orientation is set to
  /// 90 or 270, preview size should be set to 320x480. The display
  /// orientation should also be considered while setting picture size and
  /// thumbnail size.
  ///@param width the width of the pictures, in pixels
  ///@param height the height of the pictures, in pixels
  ///@see \#setDisplayOrientation(int)
  ///@see \#getCameraInfo(int, CameraInfo)
  ///@see \#setPictureSize(int, int)
  ///@see \#setJpegThumbnailSize(int, int)
  void setPreviewSize(int width, int height) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setPreviewSize,
      jni.JniType.voidType,
      [width, height]).check();

  static final _id_getPreviewSize = jniAccessors.getMethodIDOf(
      _classRef, "getPreviewSize", "()Landroid/hardware/Camera\$Size;");

  /// from: public android.hardware.Camera.Size getPreviewSize()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the dimensions setting for preview pictures.
  ///@return a Size object with the width and height setting
  ///          for the preview picture
  Camera_Size getPreviewSize() =>
      Camera_Size.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPreviewSize, jni.JniType.objectType, []).object);

  static final _id_getSupportedPreviewSizes = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedPreviewSizes", "()Ljava/util/List;");

  /// from: public java.util.List<android.hardware.Camera.Size> getSupportedPreviewSizes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the supported preview sizes.
  ///@return a list of Size object. This method will always return a list
  ///         with at least one element.
  jni.JniObject getSupportedPreviewSizes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedPreviewSizes, jni.JniType.objectType, []).object);

  static final _id_getSupportedVideoSizes = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedVideoSizes", "()Ljava/util/List;");

  /// from: public java.util.List<android.hardware.Camera.Size> getSupportedVideoSizes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the supported video frame sizes that can be used by
  /// MediaRecorder.
  ///
  ///
  /// If the returned list is not null, the returned list will contain at
  /// least one Size and one of the sizes in the returned list must be
  /// passed to MediaRecorder.setVideoSize() for camcorder application if
  /// camera is used as the video source. In this case, the size of the
  /// preview can be different from the resolution of the recorded video
  /// during video recording.
  ///
  ///@return a list of Size object if camera has separate preview and
  ///         video output; otherwise, null is returned.
  ///@see \#getPreferredPreviewSizeForVideo()
  jni.JniObject getSupportedVideoSizes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedVideoSizes, jni.JniType.objectType, []).object);

  static final _id_getPreferredPreviewSizeForVideo = jniAccessors.getMethodIDOf(
      _classRef,
      "getPreferredPreviewSizeForVideo",
      "()Landroid/hardware/Camera\$Size;");

  /// from: public android.hardware.Camera.Size getPreferredPreviewSizeForVideo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the preferred or recommended preview size (width and height)
  /// in pixels for video recording. Camcorder applications should
  /// set the preview size to a value that is not larger than the
  /// preferred preview size. In other words, the product of the width
  /// and height of the preview size should not be larger than that of
  /// the preferred preview size. In addition, we recommend to choose a
  /// preview size that has the same aspect ratio as the resolution of
  /// video to be recorded.
  ///@return the preferred preview size (width and height) in pixels for
  ///         video recording if getSupportedVideoSizes() does not return
  ///         null; otherwise, null is returned.
  ///@see \#getSupportedVideoSizes()
  Camera_Size getPreferredPreviewSizeForVideo() =>
      Camera_Size.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getPreferredPreviewSizeForVideo,
          jni.JniType.objectType, []).object);

  static final _id_setJpegThumbnailSize =
      jniAccessors.getMethodIDOf(_classRef, "setJpegThumbnailSize", "(II)V");

  /// from: public void setJpegThumbnailSize(int width, int height)
  ///
  /// Sets the dimensions for EXIF thumbnail in Jpeg picture. If
  /// applications set both width and height to 0, EXIF will not contain
  /// thumbnail.
  ///
  ///
  /// Applications need to consider the display orientation. See \#setPreviewSize(int,int) for reference.
  ///
  ///@param width the width of the thumbnail, in pixels
  ///@param height the height of the thumbnail, in pixels
  ///@see \#setPreviewSize(int,int)
  void setJpegThumbnailSize(int width, int height) =>
      jniAccessors.callMethodWithArgs(reference, _id_setJpegThumbnailSize,
          jni.JniType.voidType, [width, height]).check();

  static final _id_getJpegThumbnailSize = jniAccessors.getMethodIDOf(
      _classRef, "getJpegThumbnailSize", "()Landroid/hardware/Camera\$Size;");

  /// from: public android.hardware.Camera.Size getJpegThumbnailSize()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the dimensions for EXIF thumbnail in Jpeg picture.
  ///@return a Size object with the height and width setting for the EXIF
  ///         thumbnails
  Camera_Size getJpegThumbnailSize() =>
      Camera_Size.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getJpegThumbnailSize, jni.JniType.objectType, []).object);

  static final _id_getSupportedJpegThumbnailSizes = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedJpegThumbnailSizes", "()Ljava/util/List;");

  /// from: public java.util.List<android.hardware.Camera.Size> getSupportedJpegThumbnailSizes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the supported jpeg thumbnail sizes.
  ///@return a list of Size object. This method will always return a list
  ///         with at least two elements. Size 0,0 (no thumbnail) is always
  ///         supported.
  jni.JniObject getSupportedJpegThumbnailSizes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSupportedJpegThumbnailSizes,
          jni.JniType.objectType, []).object);

  static final _id_setJpegThumbnailQuality =
      jniAccessors.getMethodIDOf(_classRef, "setJpegThumbnailQuality", "(I)V");

  /// from: public void setJpegThumbnailQuality(int quality)
  ///
  /// Sets the quality of the EXIF thumbnail in Jpeg picture.
  ///@param quality the JPEG quality of the EXIF thumbnail. The range is 1
  ///                to 100, with 100 being the best.
  void setJpegThumbnailQuality(int quality) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setJpegThumbnailQuality,
      jni.JniType.voidType,
      [quality]).check();

  static final _id_getJpegThumbnailQuality =
      jniAccessors.getMethodIDOf(_classRef, "getJpegThumbnailQuality", "()I");

  /// from: public int getJpegThumbnailQuality()
  ///
  /// Returns the quality setting for the EXIF thumbnail in Jpeg picture.
  ///@return the JPEG quality setting of the EXIF thumbnail.
  int getJpegThumbnailQuality() => jniAccessors.callMethodWithArgs(
      reference, _id_getJpegThumbnailQuality, jni.JniType.intType, []).integer;

  static final _id_setJpegQuality =
      jniAccessors.getMethodIDOf(_classRef, "setJpegQuality", "(I)V");

  /// from: public void setJpegQuality(int quality)
  ///
  /// Sets Jpeg quality of captured picture.
  ///@param quality the JPEG quality of captured picture. The range is 1
  ///                to 100, with 100 being the best.
  void setJpegQuality(int quality) => jniAccessors.callMethodWithArgs(
      reference, _id_setJpegQuality, jni.JniType.voidType, [quality]).check();

  static final _id_getJpegQuality =
      jniAccessors.getMethodIDOf(_classRef, "getJpegQuality", "()I");

  /// from: public int getJpegQuality()
  ///
  /// Returns the quality setting for the JPEG picture.
  ///@return the JPEG picture quality setting.
  int getJpegQuality() => jniAccessors.callMethodWithArgs(
      reference, _id_getJpegQuality, jni.JniType.intType, []).integer;

  static final _id_setPreviewFrameRate =
      jniAccessors.getMethodIDOf(_classRef, "setPreviewFrameRate", "(I)V");

  /// from: public void setPreviewFrameRate(int fps)
  ///
  /// Sets the rate at which preview frames are received. This is the
  /// target frame rate. The actual frame rate depends on the driver.
  ///@param fps the frame rate (frames per second)
  ///@deprecated replaced by \#setPreviewFpsRange(int,int)
  void setPreviewFrameRate(int fps) => jniAccessors.callMethodWithArgs(
      reference, _id_setPreviewFrameRate, jni.JniType.voidType, [fps]).check();

  static final _id_getPreviewFrameRate =
      jniAccessors.getMethodIDOf(_classRef, "getPreviewFrameRate", "()I");

  /// from: public int getPreviewFrameRate()
  ///
  /// Returns the setting for the rate at which preview frames are
  /// received. This is the target frame rate. The actual frame rate
  /// depends on the driver.
  ///@return the frame rate setting (frames per second)
  ///@deprecated replaced by \#getPreviewFpsRange(int[])
  int getPreviewFrameRate() => jniAccessors.callMethodWithArgs(
      reference, _id_getPreviewFrameRate, jni.JniType.intType, []).integer;

  static final _id_getSupportedPreviewFrameRates = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedPreviewFrameRates", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.Integer> getSupportedPreviewFrameRates()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the supported preview frame rates.
  ///@return a list of supported preview frame rates. null if preview
  ///         frame rate setting is not supported.
  ///@deprecated replaced by \#getSupportedPreviewFpsRange()
  jni.JniObject getSupportedPreviewFrameRates() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getSupportedPreviewFrameRates,
          jni.JniType.objectType, []).object);

  static final _id_setPreviewFpsRange =
      jniAccessors.getMethodIDOf(_classRef, "setPreviewFpsRange", "(II)V");

  /// from: public void setPreviewFpsRange(int min, int max)
  ///
  /// Sets the minimum and maximum preview fps. This controls the rate of
  /// preview frames received in PreviewCallback. The minimum and
  /// maximum preview fps must be one of the elements from \#getSupportedPreviewFpsRange.
  ///@param min the minimum preview fps (scaled by 1000).
  ///@param max the maximum preview fps (scaled by 1000).
  ///@throws RuntimeException if fps range is invalid.
  ///@see \#setPreviewCallbackWithBuffer(Camera.PreviewCallback)
  ///@see \#getSupportedPreviewFpsRange()
  void setPreviewFpsRange(int min, int max) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setPreviewFpsRange,
      jni.JniType.voidType,
      [min, max]).check();

  static final _id_getPreviewFpsRange =
      jniAccessors.getMethodIDOf(_classRef, "getPreviewFpsRange", "([I)V");

  /// from: public void getPreviewFpsRange(int[] range)
  ///
  /// Returns the current minimum and maximum preview fps. The values are
  /// one of the elements returned by \#getSupportedPreviewFpsRange.
  ///@return range the minimum and maximum preview fps (scaled by 1000).
  ///@see \#PREVIEW_FPS_MIN_INDEX
  ///@see \#PREVIEW_FPS_MAX_INDEX
  ///@see \#getSupportedPreviewFpsRange()
  void getPreviewFpsRange(jni.JniObject range) =>
      jniAccessors.callMethodWithArgs(reference, _id_getPreviewFpsRange,
          jni.JniType.voidType, [range.reference]).check();

  static final _id_getSupportedPreviewFpsRange = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedPreviewFpsRange", "()Ljava/util/List;");

  /// from: public java.util.List<int[]> getSupportedPreviewFpsRange()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the supported preview fps (frame-per-second) ranges. Each range
  /// contains a minimum fps and maximum fps. If minimum fps equals to
  /// maximum fps, the camera outputs frames in fixed frame rate. If not,
  /// the camera outputs frames in auto frame rate. The actual frame rate
  /// fluctuates between the minimum and the maximum. The values are
  /// multiplied by 1000 and represented in integers. For example, if frame
  /// rate is 26.623 frames per second, the value is 26623.
  ///@return a list of supported preview fps ranges. This method returns a
  ///         list with at least one element. Every element is an int array
  ///         of two values - minimum fps and maximum fps. The list is
  ///         sorted from small to large (first by maximum fps and then
  ///         minimum fps).
  ///@see \#PREVIEW_FPS_MIN_INDEX
  ///@see \#PREVIEW_FPS_MAX_INDEX
  jni.JniObject getSupportedPreviewFpsRange() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedPreviewFpsRange, jni.JniType.objectType, []).object);

  static final _id_setPreviewFormat =
      jniAccessors.getMethodIDOf(_classRef, "setPreviewFormat", "(I)V");

  /// from: public void setPreviewFormat(int pixel_format)
  ///
  /// Sets the image format for preview pictures.
  /// If this is never called, the default format will be
  /// android.graphics.ImageFormat\#NV21, which
  /// uses the NV21 encoding format.
  ///
  ///
  /// Use Parameters\#getSupportedPreviewFormats to get a list of
  /// the available preview formats.
  ///
  /// It is strongly recommended that either
  /// android.graphics.ImageFormat\#NV21 or
  /// android.graphics.ImageFormat\#YV12 is used, since
  /// they are supported by all camera devices.
  ///
  ///
  /// For YV12, the image buffer that is received is not necessarily
  /// tightly packed, as there may be padding at the end of each row of
  /// pixel data, as described in
  /// android.graphics.ImageFormat\#YV12. For camera callback data,
  /// it can be assumed that the stride of the Y and UV data is the
  /// smallest possible that meets the alignment requirements. That is, if
  /// the preview size is <var>width x height</var>, then the following
  /// equations describe the buffer index for the beginning of row
  /// <var>y</var> for the Y plane and row <var>c</var> for the U and V
  /// planes:
  ///
  /// <pre>{@code
  /// yStride   = (int) ceil(width / 16.0) * 16;
  /// uvStride  = (int) ceil( (yStride / 2) / 16.0) * 16;
  /// ySize     = yStride * height;
  /// uvSize    = uvStride * height / 2;
  /// yRowIndex = yStride * y;
  /// uRowIndex = ySize + uvSize + uvStride * c;
  /// vRowIndex = ySize + uvStride * c;
  /// size      = ySize + uvSize * 2;
  /// }
  ///</pre>
  ///@param pixel_format the desired preview picture format, defined by
  ///   one of the android.graphics.ImageFormat constants.  (E.g.,
  ///   <var>ImageFormat.NV21</var> (default), or
  ///   <var>ImageFormat.YV12</var>)
  ///@see android.graphics.ImageFormat
  ///@see android.hardware.Camera.Parameters\#getSupportedPreviewFormats
  void setPreviewFormat(int pixel_format) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setPreviewFormat,
      jni.JniType.voidType,
      [pixel_format]).check();

  static final _id_getPreviewFormat =
      jniAccessors.getMethodIDOf(_classRef, "getPreviewFormat", "()I");

  /// from: public int getPreviewFormat()
  ///
  /// Returns the image format for preview frames got from
  /// PreviewCallback.
  ///@return the preview format.
  ///@see android.graphics.ImageFormat
  ///@see \#setPreviewFormat
  int getPreviewFormat() => jniAccessors.callMethodWithArgs(
      reference, _id_getPreviewFormat, jni.JniType.intType, []).integer;

  static final _id_getSupportedPreviewFormats = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedPreviewFormats", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.Integer> getSupportedPreviewFormats()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the supported preview formats. android.graphics.ImageFormat\#NV21
  /// is always supported. android.graphics.ImageFormat\#YV12
  /// is always supported since API level 12.
  ///@return a list of supported preview formats. This method will always
  ///         return a list with at least one element.
  ///@see android.graphics.ImageFormat
  ///@see \#setPreviewFormat
  jni.JniObject getSupportedPreviewFormats() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedPreviewFormats, jni.JniType.objectType, []).object);

  static final _id_setPictureSize =
      jniAccessors.getMethodIDOf(_classRef, "setPictureSize", "(II)V");

  /// from: public void setPictureSize(int width, int height)
  ///
  /// Sets the dimensions for pictures.
  ///
  ///
  /// Applications need to consider the display orientation. See \#setPreviewSize(int,int) for reference.
  ///
  ///@param width the width for pictures, in pixels
  ///@param height the height for pictures, in pixels
  ///@see \#setPreviewSize(int,int)
  void setPictureSize(int width, int height) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setPictureSize,
      jni.JniType.voidType,
      [width, height]).check();

  static final _id_getPictureSize = jniAccessors.getMethodIDOf(
      _classRef, "getPictureSize", "()Landroid/hardware/Camera\$Size;");

  /// from: public android.hardware.Camera.Size getPictureSize()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the dimension setting for pictures.
  ///@return a Size object with the height and width setting
  ///          for pictures
  Camera_Size getPictureSize() =>
      Camera_Size.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPictureSize, jni.JniType.objectType, []).object);

  static final _id_getSupportedPictureSizes = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedPictureSizes", "()Ljava/util/List;");

  /// from: public java.util.List<android.hardware.Camera.Size> getSupportedPictureSizes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the supported picture sizes.
  ///@return a list of supported picture sizes. This method will always
  ///         return a list with at least one element.
  jni.JniObject getSupportedPictureSizes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedPictureSizes, jni.JniType.objectType, []).object);

  static final _id_setPictureFormat =
      jniAccessors.getMethodIDOf(_classRef, "setPictureFormat", "(I)V");

  /// from: public void setPictureFormat(int pixel_format)
  ///
  /// Sets the image format for pictures.
  ///@param pixel_format the desired picture format
  ///                     (<var>ImageFormat.NV21</var>,
  ///                      <var>ImageFormat.RGB_565</var>, or
  ///                      <var>ImageFormat.JPEG</var>)
  ///@see android.graphics.ImageFormat
  void setPictureFormat(int pixel_format) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setPictureFormat,
      jni.JniType.voidType,
      [pixel_format]).check();

  static final _id_getPictureFormat =
      jniAccessors.getMethodIDOf(_classRef, "getPictureFormat", "()I");

  /// from: public int getPictureFormat()
  ///
  /// Returns the image format for pictures.
  ///@return the picture format
  ///@see android.graphics.ImageFormat
  int getPictureFormat() => jniAccessors.callMethodWithArgs(
      reference, _id_getPictureFormat, jni.JniType.intType, []).integer;

  static final _id_getSupportedPictureFormats = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedPictureFormats", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.Integer> getSupportedPictureFormats()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the supported picture formats.
  ///@return supported picture formats. This method will always return a
  ///         list with at least one element.
  ///@see android.graphics.ImageFormat
  jni.JniObject getSupportedPictureFormats() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedPictureFormats, jni.JniType.objectType, []).object);

  static final _id_setRotation =
      jniAccessors.getMethodIDOf(_classRef, "setRotation", "(I)V");

  /// from: public void setRotation(int rotation)
  ///
  /// Sets the clockwise rotation angle in degrees relative to the
  /// orientation of the camera. This affects the pictures returned from
  /// JPEG PictureCallback. The camera driver may set orientation
  /// in the EXIF header without rotating the picture. Or the driver may
  /// rotate the picture and the EXIF thumbnail. If the Jpeg picture is
  /// rotated, the orientation in the EXIF header will be missing or 1 (row
  /// \#0 is top and column \#0 is left side).
  ///
  ///
  /// If applications want to rotate the picture to match the orientation
  /// of what users see, apps should use
  /// android.view.OrientationEventListener and
  /// android.hardware.Camera.CameraInfo. The value from
  /// OrientationEventListener is relative to the natural orientation of
  /// the device. CameraInfo.orientation is the angle between camera
  /// orientation and natural device orientation. The sum of the two is the
  /// rotation angle for back-facing camera. The difference of the two is
  /// the rotation angle for front-facing camera. Note that the JPEG
  /// pictures of front-facing cameras are not mirrored as in preview
  /// display.
  ///
  ///
  /// For example, suppose the natural orientation of the device is
  /// portrait. The device is rotated 270 degrees clockwise, so the device
  /// orientation is 270. Suppose a back-facing camera sensor is mounted in
  /// landscape and the top side of the camera sensor is aligned with the
  /// right edge of the display in natural orientation. So the camera
  /// orientation is 90. The rotation should be set to 0 (270 + 90).
  ///
  /// The reference code is as follows.
  ///
  /// <pre>
  /// public void onOrientationChanged(int orientation) {
  ///     if (orientation == ORIENTATION_UNKNOWN) return;
  ///     android.hardware.Camera.CameraInfo info =
  ///            new android.hardware.Camera.CameraInfo();
  ///     android.hardware.Camera.getCameraInfo(cameraId, info);
  ///     orientation = (orientation + 45) / 90 * 90;
  ///     int rotation = 0;
  ///     if (info.facing == CameraInfo.CAMERA_FACING_FRONT) {
  ///         rotation = (info.orientation - orientation + 360) % 360;
  ///     } else {  // back-facing camera
  ///         rotation = (info.orientation + orientation) % 360;
  ///     }
  ///     mParameters.setRotation(rotation);
  /// }
  /// </pre>
  ///@param rotation The rotation angle in degrees relative to the
  ///                 orientation of the camera. Rotation can only be 0,
  ///                 90, 180 or 270.
  ///@throws IllegalArgumentException if rotation value is invalid.
  ///@see android.view.OrientationEventListener
  ///@see \#getCameraInfo(int, CameraInfo)
  void setRotation(int rotation) => jniAccessors.callMethodWithArgs(
      reference, _id_setRotation, jni.JniType.voidType, [rotation]).check();

  static final _id_setGpsLatitude =
      jniAccessors.getMethodIDOf(_classRef, "setGpsLatitude", "(D)V");

  /// from: public void setGpsLatitude(double latitude)
  ///
  /// Sets GPS latitude coordinate. This will be stored in JPEG EXIF
  /// header.
  ///@param latitude GPS latitude coordinate.
  void setGpsLatitude(double latitude) => jniAccessors.callMethodWithArgs(
      reference, _id_setGpsLatitude, jni.JniType.voidType, [latitude]).check();

  static final _id_setGpsLongitude =
      jniAccessors.getMethodIDOf(_classRef, "setGpsLongitude", "(D)V");

  /// from: public void setGpsLongitude(double longitude)
  ///
  /// Sets GPS longitude coordinate. This will be stored in JPEG EXIF
  /// header.
  ///@param longitude GPS longitude coordinate.
  void setGpsLongitude(double longitude) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setGpsLongitude,
      jni.JniType.voidType,
      [longitude]).check();

  static final _id_setGpsAltitude =
      jniAccessors.getMethodIDOf(_classRef, "setGpsAltitude", "(D)V");

  /// from: public void setGpsAltitude(double altitude)
  ///
  /// Sets GPS altitude. This will be stored in JPEG EXIF header.
  ///@param altitude GPS altitude in meters.
  void setGpsAltitude(double altitude) => jniAccessors.callMethodWithArgs(
      reference, _id_setGpsAltitude, jni.JniType.voidType, [altitude]).check();

  static final _id_setGpsTimestamp =
      jniAccessors.getMethodIDOf(_classRef, "setGpsTimestamp", "(J)V");

  /// from: public void setGpsTimestamp(long timestamp)
  ///
  /// Sets GPS timestamp. This will be stored in JPEG EXIF header.
  ///@param timestamp GPS timestamp (UTC in seconds since January 1,
  ///                  1970).
  void setGpsTimestamp(int timestamp) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setGpsTimestamp,
      jni.JniType.voidType,
      [timestamp]).check();

  static final _id_setGpsProcessingMethod = jniAccessors.getMethodIDOf(
      _classRef, "setGpsProcessingMethod", "(Ljava/lang/String;)V");

  /// from: public void setGpsProcessingMethod(java.lang.String processing_method)
  ///
  /// Sets GPS processing method. The method will be stored in a UTF-8 string up to 31 bytes
  /// long, in the JPEG EXIF header.
  ///@param processing_method The processing method to get this location.
  void setGpsProcessingMethod(jni.JniString processing_method) =>
      jniAccessors.callMethodWithArgs(reference, _id_setGpsProcessingMethod,
          jni.JniType.voidType, [processing_method.reference]).check();

  static final _id_removeGpsData =
      jniAccessors.getMethodIDOf(_classRef, "removeGpsData", "()V");

  /// from: public void removeGpsData()
  ///
  /// Removes GPS latitude, longitude, altitude, and timestamp from the
  /// parameters.
  void removeGpsData() => jniAccessors.callMethodWithArgs(
      reference, _id_removeGpsData, jni.JniType.voidType, []).check();

  static final _id_getWhiteBalance = jniAccessors.getMethodIDOf(
      _classRef, "getWhiteBalance", "()Ljava/lang/String;");

  /// from: public java.lang.String getWhiteBalance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current white balance setting.
  ///@return current white balance. null if white balance setting is not
  ///         supported.
  ///@see \#WHITE_BALANCE_AUTO
  ///@see \#WHITE_BALANCE_INCANDESCENT
  ///@see \#WHITE_BALANCE_FLUORESCENT
  ///@see \#WHITE_BALANCE_WARM_FLUORESCENT
  ///@see \#WHITE_BALANCE_DAYLIGHT
  ///@see \#WHITE_BALANCE_CLOUDY_DAYLIGHT
  ///@see \#WHITE_BALANCE_TWILIGHT
  ///@see \#WHITE_BALANCE_SHADE
  jni.JniString getWhiteBalance() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWhiteBalance, jni.JniType.objectType, []).object);

  static final _id_setWhiteBalance = jniAccessors.getMethodIDOf(
      _classRef, "setWhiteBalance", "(Ljava/lang/String;)V");

  /// from: public void setWhiteBalance(java.lang.String value)
  ///
  /// Sets the white balance. Changing the setting will release the
  /// auto-white balance lock. It is recommended not to change white
  /// balance and AWB lock at the same time.
  ///@param value new white balance.
  ///@see \#getWhiteBalance()
  ///@see \#setAutoWhiteBalanceLock(boolean)
  void setWhiteBalance(jni.JniString value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setWhiteBalance,
      jni.JniType.voidType,
      [value.reference]).check();

  static final _id_getSupportedWhiteBalance = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedWhiteBalance", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getSupportedWhiteBalance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the supported white balance.
  ///@return a list of supported white balance. null if white balance
  ///         setting is not supported.
  ///@see \#getWhiteBalance()
  jni.JniObject getSupportedWhiteBalance() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedWhiteBalance, jni.JniType.objectType, []).object);

  static final _id_getColorEffect = jniAccessors.getMethodIDOf(
      _classRef, "getColorEffect", "()Ljava/lang/String;");

  /// from: public java.lang.String getColorEffect()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current color effect setting.
  ///@return current color effect. null if color effect
  ///         setting is not supported.
  ///@see \#EFFECT_NONE
  ///@see \#EFFECT_MONO
  ///@see \#EFFECT_NEGATIVE
  ///@see \#EFFECT_SOLARIZE
  ///@see \#EFFECT_SEPIA
  ///@see \#EFFECT_POSTERIZE
  ///@see \#EFFECT_WHITEBOARD
  ///@see \#EFFECT_BLACKBOARD
  ///@see \#EFFECT_AQUA
  jni.JniString getColorEffect() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getColorEffect, jni.JniType.objectType, []).object);

  static final _id_setColorEffect = jniAccessors.getMethodIDOf(
      _classRef, "setColorEffect", "(Ljava/lang/String;)V");

  /// from: public void setColorEffect(java.lang.String value)
  ///
  /// Sets the current color effect setting.
  ///@param value new color effect.
  ///@see \#getColorEffect()
  void setColorEffect(jni.JniString value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setColorEffect,
      jni.JniType.voidType,
      [value.reference]).check();

  static final _id_getSupportedColorEffects = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedColorEffects", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getSupportedColorEffects()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the supported color effects.
  ///@return a list of supported color effects. null if color effect
  ///         setting is not supported.
  ///@see \#getColorEffect()
  jni.JniObject getSupportedColorEffects() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedColorEffects, jni.JniType.objectType, []).object);

  static final _id_getAntibanding = jniAccessors.getMethodIDOf(
      _classRef, "getAntibanding", "()Ljava/lang/String;");

  /// from: public java.lang.String getAntibanding()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current antibanding setting.
  ///@return current antibanding. null if antibanding setting is not
  ///         supported.
  ///@see \#ANTIBANDING_AUTO
  ///@see \#ANTIBANDING_50HZ
  ///@see \#ANTIBANDING_60HZ
  ///@see \#ANTIBANDING_OFF
  jni.JniString getAntibanding() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAntibanding, jni.JniType.objectType, []).object);

  static final _id_setAntibanding = jniAccessors.getMethodIDOf(
      _classRef, "setAntibanding", "(Ljava/lang/String;)V");

  /// from: public void setAntibanding(java.lang.String antibanding)
  ///
  /// Sets the antibanding.
  ///@param antibanding new antibanding value.
  ///@see \#getAntibanding()
  void setAntibanding(jni.JniString antibanding) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAntibanding,
          jni.JniType.voidType, [antibanding.reference]).check();

  static final _id_getSupportedAntibanding = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedAntibanding", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getSupportedAntibanding()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the supported antibanding values.
  ///@return a list of supported antibanding values. null if antibanding
  ///         setting is not supported.
  ///@see \#getAntibanding()
  jni.JniObject getSupportedAntibanding() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedAntibanding, jni.JniType.objectType, []).object);

  static final _id_getSceneMode = jniAccessors.getMethodIDOf(
      _classRef, "getSceneMode", "()Ljava/lang/String;");

  /// from: public java.lang.String getSceneMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current scene mode setting.
  ///@return one of SCENE_MODE_XXX string constant. null if scene mode
  ///         setting is not supported.
  ///@see \#SCENE_MODE_AUTO
  ///@see \#SCENE_MODE_ACTION
  ///@see \#SCENE_MODE_PORTRAIT
  ///@see \#SCENE_MODE_LANDSCAPE
  ///@see \#SCENE_MODE_NIGHT
  ///@see \#SCENE_MODE_NIGHT_PORTRAIT
  ///@see \#SCENE_MODE_THEATRE
  ///@see \#SCENE_MODE_BEACH
  ///@see \#SCENE_MODE_SNOW
  ///@see \#SCENE_MODE_SUNSET
  ///@see \#SCENE_MODE_STEADYPHOTO
  ///@see \#SCENE_MODE_FIREWORKS
  ///@see \#SCENE_MODE_SPORTS
  ///@see \#SCENE_MODE_PARTY
  ///@see \#SCENE_MODE_CANDLELIGHT
  ///@see \#SCENE_MODE_BARCODE
  jni.JniString getSceneMode() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSceneMode, jni.JniType.objectType, []).object);

  static final _id_setSceneMode = jniAccessors.getMethodIDOf(
      _classRef, "setSceneMode", "(Ljava/lang/String;)V");

  /// from: public void setSceneMode(java.lang.String value)
  ///
  /// Sets the scene mode. Changing scene mode may override other
  /// parameters (such as flash mode, focus mode, white balance). For
  /// example, suppose originally flash mode is on and supported flash
  /// modes are on/off. In night scene mode, both flash mode and supported
  /// flash mode may be changed to off. After setting scene mode,
  /// applications should call getParameters to know if some parameters are
  /// changed.
  ///@param value scene mode.
  ///@see \#getSceneMode()
  void setSceneMode(jni.JniString value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSceneMode,
      jni.JniType.voidType,
      [value.reference]).check();

  static final _id_getSupportedSceneModes = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedSceneModes", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getSupportedSceneModes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the supported scene modes.
  ///@return a list of supported scene modes. null if scene mode setting
  ///         is not supported.
  ///@see \#getSceneMode()
  jni.JniObject getSupportedSceneModes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedSceneModes, jni.JniType.objectType, []).object);

  static final _id_getFlashMode = jniAccessors.getMethodIDOf(
      _classRef, "getFlashMode", "()Ljava/lang/String;");

  /// from: public java.lang.String getFlashMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current flash mode setting.
  ///@return current flash mode. null if flash mode setting is not
  ///         supported.
  ///@see \#FLASH_MODE_OFF
  ///@see \#FLASH_MODE_AUTO
  ///@see \#FLASH_MODE_ON
  ///@see \#FLASH_MODE_RED_EYE
  ///@see \#FLASH_MODE_TORCH
  jni.JniString getFlashMode() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFlashMode, jni.JniType.objectType, []).object);

  static final _id_setFlashMode = jniAccessors.getMethodIDOf(
      _classRef, "setFlashMode", "(Ljava/lang/String;)V");

  /// from: public void setFlashMode(java.lang.String value)
  ///
  /// Sets the flash mode.
  ///@param value flash mode.
  ///@see \#getFlashMode()
  void setFlashMode(jni.JniString value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFlashMode,
      jni.JniType.voidType,
      [value.reference]).check();

  static final _id_getSupportedFlashModes = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedFlashModes", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getSupportedFlashModes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the supported flash modes.
  ///@return a list of supported flash modes. null if flash mode setting
  ///         is not supported.
  ///@see \#getFlashMode()
  jni.JniObject getSupportedFlashModes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedFlashModes, jni.JniType.objectType, []).object);

  static final _id_getFocusMode = jniAccessors.getMethodIDOf(
      _classRef, "getFocusMode", "()Ljava/lang/String;");

  /// from: public java.lang.String getFocusMode()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current focus mode setting.
  ///@return current focus mode. This method will always return a non-null
  ///         value. Applications should call \#autoFocus(AutoFocusCallback) to start the focus if focus
  ///         mode is FOCUS_MODE_AUTO or FOCUS_MODE_MACRO.
  ///@see \#FOCUS_MODE_AUTO
  ///@see \#FOCUS_MODE_INFINITY
  ///@see \#FOCUS_MODE_MACRO
  ///@see \#FOCUS_MODE_FIXED
  ///@see \#FOCUS_MODE_EDOF
  ///@see \#FOCUS_MODE_CONTINUOUS_VIDEO
  jni.JniString getFocusMode() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFocusMode, jni.JniType.objectType, []).object);

  static final _id_setFocusMode = jniAccessors.getMethodIDOf(
      _classRef, "setFocusMode", "(Ljava/lang/String;)V");

  /// from: public void setFocusMode(java.lang.String value)
  ///
  /// Sets the focus mode.
  ///@param value focus mode.
  ///@see \#getFocusMode()
  void setFocusMode(jni.JniString value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setFocusMode,
      jni.JniType.voidType,
      [value.reference]).check();

  static final _id_getSupportedFocusModes = jniAccessors.getMethodIDOf(
      _classRef, "getSupportedFocusModes", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getSupportedFocusModes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the supported focus modes.
  ///@return a list of supported focus modes. This method will always
  ///         return a list with at least one element.
  ///@see \#getFocusMode()
  jni.JniObject getSupportedFocusModes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSupportedFocusModes, jni.JniType.objectType, []).object);

  static final _id_getFocalLength =
      jniAccessors.getMethodIDOf(_classRef, "getFocalLength", "()F");

  /// from: public float getFocalLength()
  ///
  /// Gets the focal length (in millimeter) of the camera.
  ///@return the focal length. Returns -1.0 when the device
  ///         doesn't report focal length information.
  double getFocalLength() => jniAccessors.callMethodWithArgs(
      reference, _id_getFocalLength, jni.JniType.floatType, []).float;

  static final _id_getHorizontalViewAngle =
      jniAccessors.getMethodIDOf(_classRef, "getHorizontalViewAngle", "()F");

  /// from: public float getHorizontalViewAngle()
  ///
  /// Gets the horizontal angle of view in degrees.
  ///@return horizontal angle of view. Returns -1.0 when the device
  ///         doesn't report view angle information.
  double getHorizontalViewAngle() => jniAccessors.callMethodWithArgs(
      reference, _id_getHorizontalViewAngle, jni.JniType.floatType, []).float;

  static final _id_getVerticalViewAngle =
      jniAccessors.getMethodIDOf(_classRef, "getVerticalViewAngle", "()F");

  /// from: public float getVerticalViewAngle()
  ///
  /// Gets the vertical angle of view in degrees.
  ///@return vertical angle of view. Returns -1.0 when the device
  ///         doesn't report view angle information.
  double getVerticalViewAngle() => jniAccessors.callMethodWithArgs(
      reference, _id_getVerticalViewAngle, jni.JniType.floatType, []).float;

  static final _id_getExposureCompensation =
      jniAccessors.getMethodIDOf(_classRef, "getExposureCompensation", "()I");

  /// from: public int getExposureCompensation()
  ///
  /// Gets the current exposure compensation index.
  ///@return current exposure compensation index. The range is \#getMinExposureCompensation to \#getMaxExposureCompensation. 0 means exposure is not
  ///         adjusted.
  int getExposureCompensation() => jniAccessors.callMethodWithArgs(
      reference, _id_getExposureCompensation, jni.JniType.intType, []).integer;

  static final _id_setExposureCompensation =
      jniAccessors.getMethodIDOf(_classRef, "setExposureCompensation", "(I)V");

  /// from: public void setExposureCompensation(int value)
  ///
  /// Sets the exposure compensation index.
  ///@param value exposure compensation index. The valid value range is
  ///        from \#getMinExposureCompensation (inclusive) to \#getMaxExposureCompensation (inclusive). 0 means exposure is
  ///        not adjusted. Application should call
  ///        getMinExposureCompensation and getMaxExposureCompensation to
  ///        know if exposure compensation is supported.
  void setExposureCompensation(int value) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setExposureCompensation,
      jni.JniType.voidType,
      [value]).check();

  static final _id_getMaxExposureCompensation = jniAccessors.getMethodIDOf(
      _classRef, "getMaxExposureCompensation", "()I");

  /// from: public int getMaxExposureCompensation()
  ///
  /// Gets the maximum exposure compensation index.
  ///@return maximum exposure compensation index (>=0). If both this
  ///         method and \#getMinExposureCompensation return 0,
  ///         exposure compensation is not supported.
  int getMaxExposureCompensation() => jniAccessors.callMethodWithArgs(reference,
      _id_getMaxExposureCompensation, jni.JniType.intType, []).integer;

  static final _id_getMinExposureCompensation = jniAccessors.getMethodIDOf(
      _classRef, "getMinExposureCompensation", "()I");

  /// from: public int getMinExposureCompensation()
  ///
  /// Gets the minimum exposure compensation index.
  ///@return minimum exposure compensation index (<=0). If both this
  ///         method and \#getMaxExposureCompensation return 0,
  ///         exposure compensation is not supported.
  int getMinExposureCompensation() => jniAccessors.callMethodWithArgs(reference,
      _id_getMinExposureCompensation, jni.JniType.intType, []).integer;

  static final _id_getExposureCompensationStep = jniAccessors.getMethodIDOf(
      _classRef, "getExposureCompensationStep", "()F");

  /// from: public float getExposureCompensationStep()
  ///
  /// Gets the exposure compensation step.
  ///@return exposure compensation step. Applications can get EV by
  ///         multiplying the exposure compensation index and step. Ex: if
  ///         exposure compensation index is -6 and step is 0.333333333, EV
  ///         is -2.
  double getExposureCompensationStep() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getExposureCompensationStep,
      jni.JniType.floatType, []).float;

  static final _id_setAutoExposureLock =
      jniAccessors.getMethodIDOf(_classRef, "setAutoExposureLock", "(Z)V");

  /// from: public void setAutoExposureLock(boolean toggle)
  ///
  /// Sets the auto-exposure lock state. Applications should check
  /// \#isAutoExposureLockSupported before using this method.
  ///
  ///
  /// If set to true, the camera auto-exposure routine will immediately
  /// pause until the lock is set to false. Exposure compensation settings
  /// changes will still take effect while auto-exposure is locked.
  ///
  ///
  /// If auto-exposure is already locked, setting this to true again has
  /// no effect (the driver will not recalculate exposure values).
  ///
  ///
  /// Stopping preview with \#stopPreview(), or triggering still
  /// image capture with \#takePicture(Camera.ShutterCallback,
  /// Camera.PictureCallback, Camera.PictureCallback), will not change the
  /// lock.
  ///
  ///
  /// Exposure compensation, auto-exposure lock, and auto-white balance
  /// lock can be used to capture an exposure-bracketed burst of images,
  /// for example.
  ///
  ///
  /// Auto-exposure state, including the lock state, will not be
  /// maintained after camera \#release() is called.  Locking
  /// auto-exposure after \#open() but before the first call to
  /// \#startPreview() will not allow the auto-exposure routine to
  /// run at all, and may result in severely over- or under-exposed
  /// images.
  ///
  ///@param toggle new state of the auto-exposure lock. True means that
  ///        auto-exposure is locked, false means that the auto-exposure
  ///        routine is free to run normally.
  ///@see \#getAutoExposureLock()
  void setAutoExposureLock(bool toggle) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAutoExposureLock,
      jni.JniType.voidType,
      [toggle]).check();

  static final _id_getAutoExposureLock =
      jniAccessors.getMethodIDOf(_classRef, "getAutoExposureLock", "()Z");

  /// from: public boolean getAutoExposureLock()
  ///
  /// Gets the state of the auto-exposure lock. Applications should check
  /// \#isAutoExposureLockSupported before using this method. See
  /// \#setAutoExposureLock for details about the lock.
  ///@return State of the auto-exposure lock. Returns true if
  ///         auto-exposure is currently locked, and false otherwise.
  ///@see \#setAutoExposureLock(boolean)
  bool getAutoExposureLock() => jniAccessors.callMethodWithArgs(
      reference, _id_getAutoExposureLock, jni.JniType.booleanType, []).boolean;

  static final _id_isAutoExposureLockSupported = jniAccessors.getMethodIDOf(
      _classRef, "isAutoExposureLockSupported", "()Z");

  /// from: public boolean isAutoExposureLockSupported()
  ///
  /// Returns true if auto-exposure locking is supported. Applications
  /// should call this before trying to lock auto-exposure. See
  /// \#setAutoExposureLock for details about the lock.
  ///@return true if auto-exposure lock is supported.
  ///@see \#setAutoExposureLock(boolean)
  bool isAutoExposureLockSupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isAutoExposureLockSupported,
      jni.JniType.booleanType, []).boolean;

  static final _id_setAutoWhiteBalanceLock =
      jniAccessors.getMethodIDOf(_classRef, "setAutoWhiteBalanceLock", "(Z)V");

  /// from: public void setAutoWhiteBalanceLock(boolean toggle)
  ///
  /// Sets the auto-white balance lock state. Applications should check
  /// \#isAutoWhiteBalanceLockSupported before using this
  /// method.
  ///
  ///
  /// If set to true, the camera auto-white balance routine will
  /// immediately pause until the lock is set to false.
  ///
  ///
  /// If auto-white balance is already locked, setting this to true
  /// again has no effect (the driver will not recalculate white balance
  /// values).
  ///
  ///
  /// Stopping preview with \#stopPreview(), or triggering still
  /// image capture with \#takePicture(Camera.ShutterCallback,
  /// Camera.PictureCallback, Camera.PictureCallback), will not change the
  /// the lock.
  ///
  ///
  ///  Changing the white balance mode with \#setWhiteBalance
  /// will release the auto-white balance lock if it is set.
  ///
  ///
  /// Exposure compensation, AE lock, and AWB lock can be used to
  /// capture an exposure-bracketed burst of images, for example.
  /// Auto-white balance state, including the lock state, will not be
  /// maintained after camera \#release() is called.  Locking
  /// auto-white balance after \#open() but before the first call to
  /// \#startPreview() will not allow the auto-white balance routine
  /// to run at all, and may result in severely incorrect color in captured
  /// images.
  ///
  ///@param toggle new state of the auto-white balance lock. True means
  ///        that auto-white balance is locked, false means that the
  ///        auto-white balance routine is free to run normally.
  ///@see \#getAutoWhiteBalanceLock()
  ///@see \#setWhiteBalance(String)
  void setAutoWhiteBalanceLock(bool toggle) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAutoWhiteBalanceLock,
      jni.JniType.voidType,
      [toggle]).check();

  static final _id_getAutoWhiteBalanceLock =
      jniAccessors.getMethodIDOf(_classRef, "getAutoWhiteBalanceLock", "()Z");

  /// from: public boolean getAutoWhiteBalanceLock()
  ///
  /// Gets the state of the auto-white balance lock. Applications should
  /// check \#isAutoWhiteBalanceLockSupported before using this
  /// method. See \#setAutoWhiteBalanceLock for details about the
  /// lock.
  ///@return State of the auto-white balance lock. Returns true if
  ///         auto-white balance is currently locked, and false
  ///         otherwise.
  ///@see \#setAutoWhiteBalanceLock(boolean)
  bool getAutoWhiteBalanceLock() => jniAccessors.callMethodWithArgs(reference,
      _id_getAutoWhiteBalanceLock, jni.JniType.booleanType, []).boolean;

  static final _id_isAutoWhiteBalanceLockSupported = jniAccessors.getMethodIDOf(
      _classRef, "isAutoWhiteBalanceLockSupported", "()Z");

  /// from: public boolean isAutoWhiteBalanceLockSupported()
  ///
  /// Returns true if auto-white balance locking is supported. Applications
  /// should call this before trying to lock auto-white balance. See
  /// \#setAutoWhiteBalanceLock for details about the lock.
  ///@return true if auto-white balance lock is supported.
  ///@see \#setAutoWhiteBalanceLock(boolean)
  bool isAutoWhiteBalanceLockSupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isAutoWhiteBalanceLockSupported,
      jni.JniType.booleanType, []).boolean;

  static final _id_getZoom =
      jniAccessors.getMethodIDOf(_classRef, "getZoom", "()I");

  /// from: public int getZoom()
  ///
  /// Gets current zoom value. This also works when smooth zoom is in
  /// progress. Applications should check \#isZoomSupported before
  /// using this method.
  ///@return the current zoom value. The range is 0 to \#getMaxZoom. 0 means the camera is not zoomed.
  int getZoom() => jniAccessors.callMethodWithArgs(
      reference, _id_getZoom, jni.JniType.intType, []).integer;

  static final _id_setZoom =
      jniAccessors.getMethodIDOf(_classRef, "setZoom", "(I)V");

  /// from: public void setZoom(int value)
  ///
  /// Sets current zoom value. If the camera is zoomed (value > 0), the
  /// actual picture size may be smaller than picture size setting.
  /// Applications can check the actual picture size after picture is
  /// returned from PictureCallback. The preview size remains the
  /// same in zoom. Applications should check \#isZoomSupported
  /// before using this method.
  ///@param value zoom value. The valid range is 0 to \#getMaxZoom.
  void setZoom(int value) => jniAccessors.callMethodWithArgs(
      reference, _id_setZoom, jni.JniType.voidType, [value]).check();

  static final _id_isZoomSupported =
      jniAccessors.getMethodIDOf(_classRef, "isZoomSupported", "()Z");

  /// from: public boolean isZoomSupported()
  ///
  /// Returns true if zoom is supported. Applications should call this
  /// before using other zoom methods.
  ///@return true if zoom is supported.
  bool isZoomSupported() => jniAccessors.callMethodWithArgs(
      reference, _id_isZoomSupported, jni.JniType.booleanType, []).boolean;

  static final _id_getMaxZoom =
      jniAccessors.getMethodIDOf(_classRef, "getMaxZoom", "()I");

  /// from: public int getMaxZoom()
  ///
  /// Gets the maximum zoom value allowed for snapshot. This is the maximum
  /// value that applications can set to \#setZoom(int).
  /// Applications should call \#isZoomSupported before using this
  /// method. This value may change in different preview size. Applications
  /// should call this again after setting preview size.
  ///@return the maximum zoom value supported by the camera.
  int getMaxZoom() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxZoom, jni.JniType.intType, []).integer;

  static final _id_getZoomRatios = jniAccessors.getMethodIDOf(
      _classRef, "getZoomRatios", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.Integer> getZoomRatios()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the zoom ratios of all zoom values. Applications should check
  /// \#isZoomSupported before using this method.
  ///@return the zoom ratios in 1/100 increments. Ex: a zoom of 3.2x is
  ///         returned as 320. The number of elements is \#getMaxZoom + 1. The list is sorted from small to large. The
  ///         first element is always 100. The last element is the zoom
  ///         ratio of the maximum zoom value.
  jni.JniObject getZoomRatios() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getZoomRatios, jni.JniType.objectType, []).object);

  static final _id_isSmoothZoomSupported =
      jniAccessors.getMethodIDOf(_classRef, "isSmoothZoomSupported", "()Z");

  /// from: public boolean isSmoothZoomSupported()
  ///
  /// Returns true if smooth zoom is supported. Applications should call
  /// this before using other smooth zoom methods.
  ///@return true if smooth zoom is supported.
  bool isSmoothZoomSupported() => jniAccessors.callMethodWithArgs(reference,
      _id_isSmoothZoomSupported, jni.JniType.booleanType, []).boolean;

  static final _id_getFocusDistances =
      jniAccessors.getMethodIDOf(_classRef, "getFocusDistances", "([F)V");

  /// from: public void getFocusDistances(float[] output)
  ///
  /// Gets the distances from the camera to where an object appears to be
  /// in focus. The object is sharpest at the optimal focus distance. The
  /// depth of field is the far focus distance minus near focus distance.
  ///
  ///
  /// Focus distances may change after calling \#autoFocus(AutoFocusCallback), \#cancelAutoFocus, or \#startPreview(). Applications can call \#getParameters()
  /// and this method anytime to get the latest focus distances. If the
  /// focus mode is FOCUS_MODE_CONTINUOUS_VIDEO, focus distances may change
  /// from time to time.
  ///
  ///
  /// This method is intended to estimate the distance between the camera
  /// and the subject. After autofocus, the subject distance may be within
  /// near and far focus distance. However, the precision depends on the
  /// camera hardware, autofocus algorithm, the focus area, and the scene.
  /// The error can be large and it should be only used as a reference.
  ///
  ///
  /// Far focus distance >= optimal focus distance >= near focus distance.
  /// If the focus distance is infinity, the value will be
  /// {@code Float.POSITIVE_INFINITY}.
  ///
  ///@param output focus distances in meters. output must be a float
  ///        array with three elements. Near focus distance, optimal focus
  ///        distance, and far focus distance will be filled in the array.
  ///@see \#FOCUS_DISTANCE_NEAR_INDEX
  ///@see \#FOCUS_DISTANCE_OPTIMAL_INDEX
  ///@see \#FOCUS_DISTANCE_FAR_INDEX
  void getFocusDistances(jni.JniObject output) =>
      jniAccessors.callMethodWithArgs(reference, _id_getFocusDistances,
          jni.JniType.voidType, [output.reference]).check();

  static final _id_getMaxNumFocusAreas =
      jniAccessors.getMethodIDOf(_classRef, "getMaxNumFocusAreas", "()I");

  /// from: public int getMaxNumFocusAreas()
  ///
  /// Gets the maximum number of focus areas supported. This is the maximum
  /// length of the list in \#setFocusAreas(List) and
  /// \#getFocusAreas().
  ///@return the maximum number of focus areas supported by the camera.
  ///@see \#getFocusAreas()
  int getMaxNumFocusAreas() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxNumFocusAreas, jni.JniType.intType, []).integer;

  static final _id_getFocusAreas = jniAccessors.getMethodIDOf(
      _classRef, "getFocusAreas", "()Ljava/util/List;");

  /// from: public java.util.List<android.hardware.Camera.Area> getFocusAreas()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current focus areas. Camera driver uses the areas to decide
  /// focus.
  ///
  ///
  /// Before using this API or \#setFocusAreas(List), apps should
  /// call \#getMaxNumFocusAreas() to know the maximum number of
  /// focus areas first. If the value is 0, focus area is not supported.
  ///
  ///
  /// Each focus area is a rectangle with specified weight. The direction
  /// is relative to the sensor orientation, that is, what the sensor sees.
  /// The direction is not affected by the rotation or mirroring of
  /// \#setDisplayOrientation(int). Coordinates of the rectangle
  /// range from -1000 to 1000. (-1000, -1000) is the upper left point.
  /// (1000, 1000) is the lower right point. The width and height of focus
  /// areas cannot be 0 or negative.
  ///
  ///
  /// The weight must range from 1 to 1000. The weight should be
  /// interpreted as a per-pixel weight - all pixels in the area have the
  /// specified weight. This means a small area with the same weight as a
  /// larger area will have less influence on the focusing than the larger
  /// area. Focus areas can partially overlap and the driver will add the
  /// weights in the overlap region.
  ///
  ///
  /// A special case of a {@code null} focus area list means the driver is
  /// free to select focus targets as it wants. For example, the driver may
  /// use more signals to select focus areas and change them
  /// dynamically. Apps can set the focus area list to {@code null} if they
  /// want the driver to completely control focusing.
  ///
  ///
  /// Focus areas are relative to the current field of view
  /// (\#getZoom()). No matter what the zoom level is, (-1000,-1000)
  /// represents the top of the currently visible camera frame. The focus
  /// area cannot be set to be outside the current field of view, even
  /// when using zoom.
  ///
  ///
  /// Focus area only has effect if the current focus mode is
  /// \#FOCUS_MODE_AUTO, \#FOCUS_MODE_MACRO,
  /// \#FOCUS_MODE_CONTINUOUS_VIDEO, or
  /// \#FOCUS_MODE_CONTINUOUS_PICTURE.
  ///
  ///@return a list of current focus areas
  jni.JniObject getFocusAreas() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFocusAreas, jni.JniType.objectType, []).object);

  static final _id_setFocusAreas = jniAccessors.getMethodIDOf(
      _classRef, "setFocusAreas", "(Ljava/util/List;)V");

  /// from: public void setFocusAreas(java.util.List<android.hardware.Camera.Area> focusAreas)
  ///
  /// Sets focus areas. See \#getFocusAreas() for documentation.
  ///@param focusAreas the focus areas
  ///@see \#getFocusAreas()
  void setFocusAreas(jni.JniObject focusAreas) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFocusAreas,
          jni.JniType.voidType, [focusAreas.reference]).check();

  static final _id_getMaxNumMeteringAreas =
      jniAccessors.getMethodIDOf(_classRef, "getMaxNumMeteringAreas", "()I");

  /// from: public int getMaxNumMeteringAreas()
  ///
  /// Gets the maximum number of metering areas supported. This is the
  /// maximum length of the list in \#setMeteringAreas(List) and
  /// \#getMeteringAreas().
  ///@return the maximum number of metering areas supported by the camera.
  ///@see \#getMeteringAreas()
  int getMaxNumMeteringAreas() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxNumMeteringAreas, jni.JniType.intType, []).integer;

  static final _id_getMeteringAreas = jniAccessors.getMethodIDOf(
      _classRef, "getMeteringAreas", "()Ljava/util/List;");

  /// from: public java.util.List<android.hardware.Camera.Area> getMeteringAreas()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current metering areas. Camera driver uses these areas to
  /// decide exposure.
  ///
  ///
  /// Before using this API or \#setMeteringAreas(List), apps should
  /// call \#getMaxNumMeteringAreas() to know the maximum number of
  /// metering areas first. If the value is 0, metering area is not
  /// supported.
  ///
  ///
  /// Each metering area is a rectangle with specified weight. The
  /// direction is relative to the sensor orientation, that is, what the
  /// sensor sees. The direction is not affected by the rotation or
  /// mirroring of \#setDisplayOrientation(int). Coordinates of the
  /// rectangle range from -1000 to 1000. (-1000, -1000) is the upper left
  /// point. (1000, 1000) is the lower right point. The width and height of
  /// metering areas cannot be 0 or negative.
  ///
  ///
  /// The weight must range from 1 to 1000, and represents a weight for
  /// every pixel in the area. This means that a large metering area with
  /// the same weight as a smaller area will have more effect in the
  /// metering result.  Metering areas can partially overlap and the driver
  /// will add the weights in the overlap region.
  ///
  ///
  /// A special case of a {@code null} metering area list means the driver
  /// is free to meter as it chooses. For example, the driver may use more
  /// signals to select metering areas and change them dynamically. Apps
  /// can set the metering area list to {@code null} if they want the
  /// driver to completely control metering.
  ///
  ///
  /// Metering areas are relative to the current field of view
  /// (\#getZoom()). No matter what the zoom level is, (-1000,-1000)
  /// represents the top of the currently visible camera frame. The
  /// metering area cannot be set to be outside the current field of view,
  /// even when using zoom.
  ///
  ///
  /// No matter what metering areas are, the final exposure are compensated
  /// by \#setExposureCompensation(int).
  ///
  ///@return a list of current metering areas
  jni.JniObject getMeteringAreas() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMeteringAreas, jni.JniType.objectType, []).object);

  static final _id_setMeteringAreas = jniAccessors.getMethodIDOf(
      _classRef, "setMeteringAreas", "(Ljava/util/List;)V");

  /// from: public void setMeteringAreas(java.util.List<android.hardware.Camera.Area> meteringAreas)
  ///
  /// Sets metering areas. See \#getMeteringAreas() for
  /// documentation.
  ///@param meteringAreas the metering areas
  ///@see \#getMeteringAreas()
  void setMeteringAreas(jni.JniObject meteringAreas) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMeteringAreas,
          jni.JniType.voidType, [meteringAreas.reference]).check();

  static final _id_getMaxNumDetectedFaces =
      jniAccessors.getMethodIDOf(_classRef, "getMaxNumDetectedFaces", "()I");

  /// from: public int getMaxNumDetectedFaces()
  ///
  /// Gets the maximum number of detected faces supported. This is the
  /// maximum length of the list returned from FaceDetectionListener.
  /// If the return value is 0, face detection of the specified type is not
  /// supported.
  ///@return the maximum number of detected face supported by the camera.
  ///@see \#startFaceDetection()
  int getMaxNumDetectedFaces() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxNumDetectedFaces, jni.JniType.intType, []).integer;

  static final _id_setRecordingHint =
      jniAccessors.getMethodIDOf(_classRef, "setRecordingHint", "(Z)V");

  /// from: public void setRecordingHint(boolean hint)
  ///
  /// Sets recording mode hint. This tells the camera that the intent of
  /// the application is to record videos android.media.MediaRecorder\#start(), not to take still pictures
  /// \#takePicture(Camera.ShutterCallback, Camera.PictureCallback,
  /// Camera.PictureCallback, Camera.PictureCallback). Using this hint can
  /// allow MediaRecorder.start() to start faster or with fewer glitches on
  /// output. This should be called before starting preview for the best
  /// result, but can be changed while the preview is active. The default
  /// value is false.
  ///
  /// The app can still call takePicture() when the hint is true or call
  /// MediaRecorder.start() when the hint is false. But the performance may
  /// be worse.
  ///@param hint true if the apps intend to record videos using
  ///             android.media.MediaRecorder.
  void setRecordingHint(bool hint) => jniAccessors.callMethodWithArgs(
      reference, _id_setRecordingHint, jni.JniType.voidType, [hint]).check();

  static final _id_isVideoSnapshotSupported =
      jniAccessors.getMethodIDOf(_classRef, "isVideoSnapshotSupported", "()Z");

  /// from: public boolean isVideoSnapshotSupported()
  ///
  /// Returns true if video snapshot is supported. That is, applications
  /// can call \#takePicture(Camera.ShutterCallback,
  /// Camera.PictureCallback, Camera.PictureCallback,
  /// Camera.PictureCallback) during recording. Applications do not need
  /// to call \#startPreview() after taking a picture. The preview
  /// will be still active. Other than that, taking a picture during
  /// recording is identical to taking a picture normally. All settings and
  /// methods related to takePicture work identically. Ex:
  /// \#getPictureSize(), \#getSupportedPictureSizes(),
  /// \#setJpegQuality(int), \#setRotation(int), and etc. The
  /// picture will have an EXIF header. \#FLASH_MODE_AUTO and
  /// \#FLASH_MODE_ON also still work, but the video will record the
  /// flash.
  ///
  ///
  /// Applications can set shutter callback as null to avoid the shutter
  /// sound. It is also recommended to set raw picture and post view
  /// callbacks to null to avoid the interrupt of preview display.
  ///
  ///
  /// Field-of-view of the recorded video may be different from that of the
  /// captured pictures. The maximum size of a video snapshot may be
  /// smaller than that for regular still captures. If the current picture
  /// size is set higher than can be supported by video snapshot, the
  /// picture will be captured at the maximum supported size instead.
  ///
  ///@return true if video snapshot is supported.
  bool isVideoSnapshotSupported() => jniAccessors.callMethodWithArgs(reference,
      _id_isVideoSnapshotSupported, jni.JniType.booleanType, []).boolean;

  static final _id_setVideoStabilization =
      jniAccessors.getMethodIDOf(_classRef, "setVideoStabilization", "(Z)V");

  /// from: public void setVideoStabilization(boolean toggle)
  ///
  /// Enables and disables video stabilization. Use
  /// \#isVideoStabilizationSupported to determine if calling this
  /// method is valid.
  ///
  ///
  /// Video stabilization reduces the shaking due to the motion of the
  /// camera in both the preview stream and in recorded videos, including
  /// data received from the preview callback. It does not reduce motion
  /// blur in images captured with
  /// Camera\#takePicture takePicture.
  ///
  ///
  /// Video stabilization can be enabled and disabled while preview or
  /// recording is active, but toggling it may cause a jump in the video
  /// stream that may be undesirable in a recorded video.
  ///
  ///@param toggle Set to true to enable video stabilization, and false to
  /// disable video stabilization.
  ///@see \#isVideoStabilizationSupported()
  ///@see \#getVideoStabilization()
  void setVideoStabilization(bool toggle) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setVideoStabilization,
      jni.JniType.voidType,
      [toggle]).check();

  static final _id_getVideoStabilization =
      jniAccessors.getMethodIDOf(_classRef, "getVideoStabilization", "()Z");

  /// from: public boolean getVideoStabilization()
  ///
  /// Get the current state of video stabilization. See
  /// \#setVideoStabilization for details of video stabilization.
  ///@return true if video stabilization is enabled
  ///@see \#isVideoStabilizationSupported()
  ///@see \#setVideoStabilization(boolean)
  bool getVideoStabilization() => jniAccessors.callMethodWithArgs(reference,
      _id_getVideoStabilization, jni.JniType.booleanType, []).boolean;

  static final _id_isVideoStabilizationSupported = jniAccessors.getMethodIDOf(
      _classRef, "isVideoStabilizationSupported", "()Z");

  /// from: public boolean isVideoStabilizationSupported()
  ///
  /// Returns true if video stabilization is supported. See
  /// \#setVideoStabilization for details of video stabilization.
  ///@return true if video stabilization is supported
  ///@see \#setVideoStabilization(boolean)
  ///@see \#getVideoStabilization()
  bool isVideoStabilizationSupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isVideoStabilizationSupported,
      jni.JniType.booleanType, []).boolean;
}

/// from: android.hardware.Camera$OnZoomChangeListener
///
/// Callback interface for zoom changes during a smooth zoom operation.
///@see \#setZoomChangeListener(OnZoomChangeListener)
///@see \#startSmoothZoom(int)
///@deprecated We recommend using the new android.hardware.camera2 API for new
///             applications.
class Camera_OnZoomChangeListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/Camera\$OnZoomChangeListener");
  Camera_OnZoomChangeListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onZoomChange = jniAccessors.getMethodIDOf(
      _classRef, "onZoomChange", "(IZLandroid/hardware/Camera;)V");

  /// from: public abstract void onZoomChange(int zoomValue, boolean stopped, android.hardware.Camera camera)
  ///
  /// Called when the zoom value has changed during a smooth zoom.
  ///@param zoomValue the current zoom value. In smooth zoom mode, camera
  ///                  calls this for every new zoom value.
  ///@param stopped whether smooth zoom is stopped. If the value is true,
  ///                this is the last zoom update for the application.
  ///@param camera the Camera service object
  void onZoomChange(int zoomValue, bool stopped, Camera camera) =>
      jniAccessors.callMethodWithArgs(reference, _id_onZoomChange,
          jni.JniType.voidType, [zoomValue, stopped, camera.reference]).check();
}

/// from: android.hardware.Camera$FaceDetectionListener
///
/// Callback interface for face detected in the preview frame.
///@deprecated We recommend using the new android.hardware.camera2 API for new
///             applications.
class Camera_FaceDetectionListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/Camera\$FaceDetectionListener");
  Camera_FaceDetectionListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onFaceDetection = jniAccessors.getMethodIDOf(
      _classRef,
      "onFaceDetection",
      "([Landroid/hardware/Camera\$Face;Landroid/hardware/Camera;)V");

  /// from: public abstract void onFaceDetection(android.hardware.Camera.Face[] faces, android.hardware.Camera camera)
  ///
  /// Notify the listener of the detected faces in the preview frame.
  ///@param faces The detected faces in a list
  ///@param camera The Camera service object
  void onFaceDetection(jni.JniObject faces, Camera camera) =>
      jniAccessors.callMethodWithArgs(reference, _id_onFaceDetection,
          jni.JniType.voidType, [faces.reference, camera.reference]).check();
}

/// from: android.hardware.Camera$Face
///
/// Information about a face identified through camera face detection.
///
/// When face detection is used with a camera, the FaceDetectionListener returns a
/// list of face objects for use in focusing and metering.
///
///@see FaceDetectionListener
///@deprecated We recommend using the new android.hardware.camera2 API for new
///             applications.
class Camera_Face extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/Camera\$Face");
  Camera_Face.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_id = jniAccessors.getFieldIDOf(_classRef, "id", "I");

  /// from: public int id
  ///
  /// An unique id per face while the face is visible to the tracker. If
  /// the face leaves the field-of-view and comes back, it will get a new
  /// id. This is an optional field, may not be supported on all devices.
  /// If not supported, id will always be set to -1. The optional fields
  /// are supported as a set. Either they are all valid, or none of them
  /// are.
  int get id =>
      jniAccessors.getField(reference, _id_id, jni.JniType.intType).integer;

  /// from: public int id
  ///
  /// An unique id per face while the face is visible to the tracker. If
  /// the face leaves the field-of-view and comes back, it will get a new
  /// id. This is an optional field, may not be supported on all devices.
  /// If not supported, id will always be set to -1. The optional fields
  /// are supported as a set. Either they are all valid, or none of them
  /// are.
  set id(int value) => jniEnv.SetIntField(reference, _id_id, value);

  static final _id_leftEye = jniAccessors.getFieldIDOf(
      _classRef, "leftEye", "Landroid/graphics/Point;");

  /// from: public android.graphics.Point leftEye
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The coordinates of the center of the left eye. The coordinates are in
  /// the same space as the ones for \#rect. This is an optional
  /// field, may not be supported on all devices. If not supported, the
  /// value will always be set to null. The optional fields are supported
  /// as a set. Either they are all valid, or none of them are.
  point_.Point get leftEye => point_.Point.fromRef(jniAccessors
      .getField(reference, _id_leftEye, jni.JniType.objectType)
      .object);

  /// from: public android.graphics.Point leftEye
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The coordinates of the center of the left eye. The coordinates are in
  /// the same space as the ones for \#rect. This is an optional
  /// field, may not be supported on all devices. If not supported, the
  /// value will always be set to null. The optional fields are supported
  /// as a set. Either they are all valid, or none of them are.
  set leftEye(point_.Point value) =>
      jniEnv.SetObjectField(reference, _id_leftEye, value.reference);

  static final _id_mouth =
      jniAccessors.getFieldIDOf(_classRef, "mouth", "Landroid/graphics/Point;");

  /// from: public android.graphics.Point mouth
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The coordinates of the center of the mouth.  The coordinates are in
  /// the same space as the ones for \#rect. This is an optional
  /// field, may not be supported on all devices. If not supported, the
  /// value will always be set to null. The optional fields are supported
  /// as a set. Either they are all valid, or none of them are.
  point_.Point get mouth => point_.Point.fromRef(jniAccessors
      .getField(reference, _id_mouth, jni.JniType.objectType)
      .object);

  /// from: public android.graphics.Point mouth
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The coordinates of the center of the mouth.  The coordinates are in
  /// the same space as the ones for \#rect. This is an optional
  /// field, may not be supported on all devices. If not supported, the
  /// value will always be set to null. The optional fields are supported
  /// as a set. Either they are all valid, or none of them are.
  set mouth(point_.Point value) =>
      jniEnv.SetObjectField(reference, _id_mouth, value.reference);

  static final _id_rect =
      jniAccessors.getFieldIDOf(_classRef, "rect", "Landroid/graphics/Rect;");

  /// from: public android.graphics.Rect rect
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Bounds of the face. (-1000, -1000) represents the top-left of the
  /// camera field of view, and (1000, 1000) represents the bottom-right of
  /// the field of view. For example, suppose the size of the viewfinder UI
  /// is 800x480. The rect passed from the driver is (-1000, -1000, 0, 0).
  /// The corresponding viewfinder rect should be (0, 0, 400, 240). It is
  /// guaranteed left < right and top < bottom. The coordinates can be
  /// smaller than -1000 or bigger than 1000. But at least one vertex will
  /// be within (-1000, -1000) and (1000, 1000).
  ///
  /// The direction is relative to the sensor orientation, that is, what
  /// the sensor sees. The direction is not affected by the rotation or
  /// mirroring of \#setDisplayOrientation(int). The face bounding
  /// rectangle does not provide any information about face orientation.
  ///
  ///
  /// Here is the matrix to convert driver coordinates to View coordinates
  /// in pixels.
  ///
  /// <pre>
  /// Matrix matrix = new Matrix();
  /// CameraInfo info = CameraHolder.instance().getCameraInfo()[cameraId];
  /// // Need mirror for front camera.
  /// boolean mirror = (info.facing == CameraInfo.CAMERA_FACING_FRONT);
  /// matrix.setScale(mirror ? -1 : 1, 1);
  /// // This is the value for android.hardware.Camera.setDisplayOrientation.
  /// matrix.postRotate(displayOrientation);
  /// // Camera driver coordinates range from (-1000, -1000) to (1000, 1000).
  /// // UI coordinates range from (0, 0) to (width, height).
  /// matrix.postScale(view.getWidth() / 2000f, view.getHeight() / 2000f);
  /// matrix.postTranslate(view.getWidth() / 2f, view.getHeight() / 2f);
  /// </pre>
  ///@see \#startFaceDetection()
  rect_.Rect get rect => rect_.Rect.fromRef(jniAccessors
      .getField(reference, _id_rect, jni.JniType.objectType)
      .object);

  /// from: public android.graphics.Rect rect
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Bounds of the face. (-1000, -1000) represents the top-left of the
  /// camera field of view, and (1000, 1000) represents the bottom-right of
  /// the field of view. For example, suppose the size of the viewfinder UI
  /// is 800x480. The rect passed from the driver is (-1000, -1000, 0, 0).
  /// The corresponding viewfinder rect should be (0, 0, 400, 240). It is
  /// guaranteed left < right and top < bottom. The coordinates can be
  /// smaller than -1000 or bigger than 1000. But at least one vertex will
  /// be within (-1000, -1000) and (1000, 1000).
  ///
  /// The direction is relative to the sensor orientation, that is, what
  /// the sensor sees. The direction is not affected by the rotation or
  /// mirroring of \#setDisplayOrientation(int). The face bounding
  /// rectangle does not provide any information about face orientation.
  ///
  ///
  /// Here is the matrix to convert driver coordinates to View coordinates
  /// in pixels.
  ///
  /// <pre>
  /// Matrix matrix = new Matrix();
  /// CameraInfo info = CameraHolder.instance().getCameraInfo()[cameraId];
  /// // Need mirror for front camera.
  /// boolean mirror = (info.facing == CameraInfo.CAMERA_FACING_FRONT);
  /// matrix.setScale(mirror ? -1 : 1, 1);
  /// // This is the value for android.hardware.Camera.setDisplayOrientation.
  /// matrix.postRotate(displayOrientation);
  /// // Camera driver coordinates range from (-1000, -1000) to (1000, 1000).
  /// // UI coordinates range from (0, 0) to (width, height).
  /// matrix.postScale(view.getWidth() / 2000f, view.getHeight() / 2000f);
  /// matrix.postTranslate(view.getWidth() / 2f, view.getHeight() / 2f);
  /// </pre>
  ///@see \#startFaceDetection()
  set rect(rect_.Rect value) =>
      jniEnv.SetObjectField(reference, _id_rect, value.reference);

  static final _id_rightEye = jniAccessors.getFieldIDOf(
      _classRef, "rightEye", "Landroid/graphics/Point;");

  /// from: public android.graphics.Point rightEye
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The coordinates of the center of the right eye. The coordinates are
  /// in the same space as the ones for \#rect.This is an optional
  /// field, may not be supported on all devices. If not supported, the
  /// value will always be set to null. The optional fields are supported
  /// as a set. Either they are all valid, or none of them are.
  point_.Point get rightEye => point_.Point.fromRef(jniAccessors
      .getField(reference, _id_rightEye, jni.JniType.objectType)
      .object);

  /// from: public android.graphics.Point rightEye
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The coordinates of the center of the right eye. The coordinates are
  /// in the same space as the ones for \#rect.This is an optional
  /// field, may not be supported on all devices. If not supported, the
  /// value will always be set to null. The optional fields are supported
  /// as a set. Either they are all valid, or none of them are.
  set rightEye(point_.Point value) =>
      jniEnv.SetObjectField(reference, _id_rightEye, value.reference);

  static final _id_score = jniAccessors.getFieldIDOf(_classRef, "score", "I");

  /// from: public int score
  ///
  /// The confidence level for the detection of the face. The range is 1 to
  /// 100. 100 is the highest confidence.
  ///
  ///
  /// Depending on the device, even very low-confidence faces may be
  /// listed, so applications should filter out faces with low confidence,
  /// depending on the use case. For a typical point-and-shoot camera
  /// application that wishes to display rectangles around detected faces,
  /// filtering out faces with confidence less than 50 is recommended.
  ///
  ///@see \#startFaceDetection()
  int get score =>
      jniAccessors.getField(reference, _id_score, jni.JniType.intType).integer;

  /// from: public int score
  ///
  /// The confidence level for the detection of the face. The range is 1 to
  /// 100. 100 is the highest confidence.
  ///
  ///
  /// Depending on the device, even very low-confidence faces may be
  /// listed, so applications should filter out faces with low confidence,
  /// depending on the use case. For a typical point-and-shoot camera
  /// application that wishes to display rectangles around detected faces,
  /// filtering out faces with confidence less than 50 is recommended.
  ///
  ///@see \#startFaceDetection()
  set score(int value) => jniEnv.SetIntField(reference, _id_score, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an empty face.
  Camera_Face()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.hardware.Camera$ErrorCallback
///
/// Callback interface for camera error notification.
///@see \#setErrorCallback(ErrorCallback)
///@deprecated We recommend using the new android.hardware.camera2 API for new
///             applications.
class Camera_ErrorCallback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/Camera\$ErrorCallback");
  Camera_ErrorCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onError = jniAccessors.getMethodIDOf(
      _classRef, "onError", "(ILandroid/hardware/Camera;)V");

  /// from: public abstract void onError(int error, android.hardware.Camera camera)
  ///
  /// Callback for camera errors.
  ///@param error error code:
  /// <ul>
  /// <li>\#CAMERA_ERROR_UNKNOWN
  /// <li>\#CAMERA_ERROR_SERVER_DIED
  /// </ul>
  ///@param camera the Camera service object
  void onError(int error, Camera camera) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onError,
      jni.JniType.voidType,
      [error, camera.reference]).check();
}

/// from: android.hardware.Camera$CameraInfo
///
/// Information about a camera
///@deprecated We recommend using the new android.hardware.camera2 API for new
///             applications.
class Camera_CameraInfo extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/Camera\$CameraInfo");
  Camera_CameraInfo.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int CAMERA_FACING_BACK
  ///
  /// The facing of the camera is opposite to that of the screen.
  static const CAMERA_FACING_BACK = 0;

  /// from: static public final int CAMERA_FACING_FRONT
  ///
  /// The facing of the camera is the same as that of the screen.
  static const CAMERA_FACING_FRONT = 1;

  static final _id_canDisableShutterSound =
      jniAccessors.getFieldIDOf(_classRef, "canDisableShutterSound", "Z");

  /// from: public boolean canDisableShutterSound
  ///
  /// Whether the shutter sound can be disabled.
  ///
  ///
  /// On some devices, the camera shutter sound cannot be turned off
  /// through \#enableShutterSound enableShutterSound. This field
  /// can be used to determine whether a call to disable the shutter sound
  /// will succeed.
  ///
  ///
  /// If this field is set to true, then a call of
  /// {@code enableShutterSound(false)} will be successful. If set to
  /// false, then that call will fail, and the shutter sound will be played
  /// when Camera\#takePicture takePicture is called.
  ///
  bool get canDisableShutterSound => jniAccessors
      .getField(reference, _id_canDisableShutterSound, jni.JniType.booleanType)
      .boolean;

  /// from: public boolean canDisableShutterSound
  ///
  /// Whether the shutter sound can be disabled.
  ///
  ///
  /// On some devices, the camera shutter sound cannot be turned off
  /// through \#enableShutterSound enableShutterSound. This field
  /// can be used to determine whether a call to disable the shutter sound
  /// will succeed.
  ///
  ///
  /// If this field is set to true, then a call of
  /// {@code enableShutterSound(false)} will be successful. If set to
  /// false, then that call will fail, and the shutter sound will be played
  /// when Camera\#takePicture takePicture is called.
  ///
  set canDisableShutterSound(bool value) => jniEnv.SetBooleanField(
      reference, _id_canDisableShutterSound, value ? 1 : 0);

  static final _id_facing = jniAccessors.getFieldIDOf(_classRef, "facing", "I");

  /// from: public int facing
  ///
  /// The direction that the camera faces. It should be
  /// CAMERA_FACING_BACK or CAMERA_FACING_FRONT.
  int get facing =>
      jniAccessors.getField(reference, _id_facing, jni.JniType.intType).integer;

  /// from: public int facing
  ///
  /// The direction that the camera faces. It should be
  /// CAMERA_FACING_BACK or CAMERA_FACING_FRONT.
  set facing(int value) => jniEnv.SetIntField(reference, _id_facing, value);

  static final _id_orientation =
      jniAccessors.getFieldIDOf(_classRef, "orientation", "I");

  /// from: public int orientation
  ///
  /// The orientation of the camera image. The value is the angle that the
  /// camera image needs to be rotated clockwise so it shows correctly on
  /// the display in its natural orientation. It should be 0, 90, 180, or 270.
  ///
  ///
  /// For example, suppose a device has a naturally tall screen. The
  /// back-facing camera sensor is mounted in landscape. You are looking at
  /// the screen. If the top side of the camera sensor is aligned with the
  /// right edge of the screen in natural orientation, the value should be
  /// 90. If the top side of a front-facing camera sensor is aligned with
  /// the right of the screen, the value should be 270.
  ///
  ///@see \#setDisplayOrientation(int)
  ///@see Parameters\#setRotation(int)
  ///@see Parameters\#setPreviewSize(int, int)
  ///@see Parameters\#setPictureSize(int, int)
  ///@see Parameters\#setJpegThumbnailSize(int, int)
  int get orientation => jniAccessors
      .getField(reference, _id_orientation, jni.JniType.intType)
      .integer;

  /// from: public int orientation
  ///
  /// The orientation of the camera image. The value is the angle that the
  /// camera image needs to be rotated clockwise so it shows correctly on
  /// the display in its natural orientation. It should be 0, 90, 180, or 270.
  ///
  ///
  /// For example, suppose a device has a naturally tall screen. The
  /// back-facing camera sensor is mounted in landscape. You are looking at
  /// the screen. If the top side of the camera sensor is aligned with the
  /// right edge of the screen in natural orientation, the value should be
  /// 90. If the top side of a front-facing camera sensor is aligned with
  /// the right of the screen, the value should be 270.
  ///
  ///@see \#setDisplayOrientation(int)
  ///@see Parameters\#setRotation(int)
  ///@see Parameters\#setPreviewSize(int, int)
  ///@see Parameters\#setPictureSize(int, int)
  ///@see Parameters\#setJpegThumbnailSize(int, int)
  set orientation(int value) =>
      jniEnv.SetIntField(reference, _id_orientation, value);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Camera_CameraInfo()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.hardware.Camera$AutoFocusMoveCallback
///
/// Callback interface used to notify on auto focus start and stop.
///
/// This is only supported in continuous autofocus modes -- Parameters\#FOCUS_MODE_CONTINUOUS_VIDEO and Parameters\#FOCUS_MODE_CONTINUOUS_PICTURE. Applications can show
/// autofocus animation based on this.
///
///@deprecated We recommend using the new android.hardware.camera2 API for new
///             applications.
class Camera_AutoFocusMoveCallback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/Camera\$AutoFocusMoveCallback");
  Camera_AutoFocusMoveCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onAutoFocusMoving = jniAccessors.getMethodIDOf(
      _classRef, "onAutoFocusMoving", "(ZLandroid/hardware/Camera;)V");

  /// from: public abstract void onAutoFocusMoving(boolean start, android.hardware.Camera camera)
  ///
  /// Called when the camera auto focus starts or stops.
  ///@param start true if focus starts to move, false if focus stops to move
  ///@param camera the Camera service object
  void onAutoFocusMoving(bool start, Camera camera) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAutoFocusMoving,
          jni.JniType.voidType, [start, camera.reference]).check();
}

/// from: android.hardware.Camera$AutoFocusCallback
///
/// Callback interface used to notify on completion of camera auto focus.
///
/// Devices that do not support auto-focus will receive a "fake"
/// callback to this interface. If your application needs auto-focus and
/// should not be installed on devices _without_ auto-focus, you must
/// declare that your app uses the
/// {@code android.hardware.camera.autofocus} feature, in the
/// <a href="{@docRoot}guide/topics/manifest/uses-feature-element.html">&lt;uses-feature></a>
/// manifest element.
///
///@see \#autoFocus(AutoFocusCallback)
///@deprecated We recommend using the new android.hardware.camera2 API for new
///             applications.
class Camera_AutoFocusCallback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/Camera\$AutoFocusCallback");
  Camera_AutoFocusCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onAutoFocus = jniAccessors.getMethodIDOf(
      _classRef, "onAutoFocus", "(ZLandroid/hardware/Camera;)V");

  /// from: public abstract void onAutoFocus(boolean success, android.hardware.Camera camera)
  ///
  /// Called when the camera auto focus completes.  If the camera
  /// does not support auto-focus and autoFocus is called,
  /// onAutoFocus will be called immediately with a fake value of
  /// <code>success</code> set to <code>true</code>.
  ///
  /// The auto-focus routine does not lock auto-exposure and auto-white
  /// balance after it completes.
  ///@param success true if focus was successful, false if otherwise
  ///@param camera the Camera service object
  ///@see android.hardware.Camera.Parameters\#setAutoExposureLock(boolean)
  ///@see android.hardware.Camera.Parameters\#setAutoWhiteBalanceLock(boolean)
  void onAutoFocus(bool success, Camera camera) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAutoFocus,
          jni.JniType.voidType, [success, camera.reference]).check();
}

/// from: android.hardware.Camera$Area
///
/// The Area class is used for choosing specific metering and focus areas for
/// the camera to use when calculating auto-exposure, auto-white balance, and
/// auto-focus.
///
///
/// To find out how many simultaneous areas a given camera supports, use
/// Parameters\#getMaxNumMeteringAreas() and
/// Parameters\#getMaxNumFocusAreas(). If metering or focusing area
/// selection is unsupported, these methods will return 0.
///
///
/// Each Area consists of a rectangle specifying its bounds, and a weight
/// that determines its importance. The bounds are relative to the camera's
/// current field of view. The coordinates are mapped so that (-1000, -1000)
/// is always the top-left corner of the current field of view, and (1000,
/// 1000) is always the bottom-right corner of the current field of
/// view. Setting Areas with bounds outside that range is not allowed. Areas
/// with zero or negative width or height are not allowed.
///
///
/// The weight must range from 1 to 1000, and represents a weight for
/// every pixel in the area. This means that a large metering area with
/// the same weight as a smaller area will have more effect in the
/// metering result.  Metering areas can overlap and the driver
/// will add the weights in the overlap region.
///
///@see Parameters\#setFocusAreas(List)
///@see Parameters\#getFocusAreas()
///@see Parameters\#getMaxNumFocusAreas()
///@see Parameters\#setMeteringAreas(List)
///@see Parameters\#getMeteringAreas()
///@see Parameters\#getMaxNumMeteringAreas()
///@deprecated We recommend using the new android.hardware.camera2 API for new
///             applications.
class Camera_Area extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/Camera\$Area");
  Camera_Area.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_rect =
      jniAccessors.getFieldIDOf(_classRef, "rect", "Landroid/graphics/Rect;");

  /// from: public android.graphics.Rect rect
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Bounds of the area. (-1000, -1000) represents the top-left of the
  /// camera field of view, and (1000, 1000) represents the bottom-right of
  /// the field of view. Setting bounds outside that range is not
  /// allowed. Bounds with zero or negative width or height are not
  /// allowed.
  ///@see Parameters\#getFocusAreas()
  ///@see Parameters\#getMeteringAreas()
  rect_.Rect get rect => rect_.Rect.fromRef(jniAccessors
      .getField(reference, _id_rect, jni.JniType.objectType)
      .object);

  /// from: public android.graphics.Rect rect
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Bounds of the area. (-1000, -1000) represents the top-left of the
  /// camera field of view, and (1000, 1000) represents the bottom-right of
  /// the field of view. Setting bounds outside that range is not
  /// allowed. Bounds with zero or negative width or height are not
  /// allowed.
  ///@see Parameters\#getFocusAreas()
  ///@see Parameters\#getMeteringAreas()
  set rect(rect_.Rect value) =>
      jniEnv.SetObjectField(reference, _id_rect, value.reference);

  static final _id_weight = jniAccessors.getFieldIDOf(_classRef, "weight", "I");

  /// from: public int weight
  ///
  /// Weight of the area. The weight must range from 1 to 1000, and
  /// represents a weight for every pixel in the area. This means that a
  /// large metering area with the same weight as a smaller area will have
  /// more effect in the metering result.  Metering areas can overlap and
  /// the driver will add the weights in the overlap region.
  ///@see Parameters\#getFocusAreas()
  ///@see Parameters\#getMeteringAreas()
  int get weight =>
      jniAccessors.getField(reference, _id_weight, jni.JniType.intType).integer;

  /// from: public int weight
  ///
  /// Weight of the area. The weight must range from 1 to 1000, and
  /// represents a weight for every pixel in the area. This means that a
  /// large metering area with the same weight as a smaller area will have
  /// more effect in the metering result.  Metering areas can overlap and
  /// the driver will add the weights in the overlap region.
  ///@see Parameters\#getFocusAreas()
  ///@see Parameters\#getMeteringAreas()
  set weight(int value) => jniEnv.SetIntField(reference, _id_weight, value);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/graphics/Rect;I)V");

  /// from: public void <init>(android.graphics.Rect rect, int weight)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an area with specified rectangle and weight.
  ///@param rect the bounds of the area.
  ///@param weight the weight of the area.
  Camera_Area(rect_.Rect rect, int weight)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [rect.reference, weight]).object);

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// Compares {@code obj} to this area.
  ///@param obj the object to compare this area with.
  ///@return {@code true} if the rectangle and weight of {@code obj} is
  ///         the same as those of this area. {@code false} otherwise.
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;
}
