// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../view/Surface.dart" as surface_;

import "../../../util/Size.dart" as size_;

import "../../../util/Range.dart" as range_;
import "../../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.camera2.params.StreamConfigurationMap
///
/// Immutable class to store the available stream
/// CameraCharacteristics\#SCALER_STREAM_CONFIGURATION_MAP configurations to set up
/// android.view.Surface Surfaces for creating a
/// android.hardware.camera2.CameraCaptureSession capture session with
/// android.hardware.camera2.CameraDevice\#createCaptureSession.
/// <!-- TODO: link to input stream configuration -->
///
/// This is the authoritative list for all <!-- input/ -->output formats (and sizes respectively
/// for that format) that are supported by a camera device.
///
///
/// This also contains the minimum frame durations and stall durations for each format/size
/// combination that can be used to calculate effective frame rate when submitting multiple captures.
///
///
///
/// An instance of this object is available from CameraCharacteristics using
/// the CameraCharacteristics\#SCALER_STREAM_CONFIGURATION_MAP key and the
/// CameraCharacteristics\#get method.
///
///
/// <pre><code>{@code
/// CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(cameraId);
/// StreamConfigurationMap configs = characteristics.get(
///         CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
/// }</code></pre>
///@see CameraCharacteristics\#SCALER_STREAM_CONFIGURATION_MAP
///@see CameraDevice\#createCaptureSession
class StreamConfigurationMap extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/hardware/camera2/params/StreamConfigurationMap");
  StreamConfigurationMap.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getOutputFormats =
      jniAccessors.getMethodIDOf(_classRef, "getOutputFormats", "()[I");

  /// from: public int[] getOutputFormats()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the image {@code format} output formats in this stream configuration.
  ///
  /// All image formats returned by this function will be defined in either ImageFormat
  /// or in PixelFormat (and there is no possibility of collision).
  ///
  ///
  /// Formats listed in this array are guaranteed to return true if queried with
  /// \#isOutputSupportedFor(int).
  ///
  ///@return an array of integer format
  ///@see ImageFormat
  ///@see PixelFormat
  jni.JniObject getOutputFormats() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getOutputFormats, jni.JniType.objectType, []).object);

  static final _id_getValidOutputFormatsForInput = jniAccessors.getMethodIDOf(
      _classRef, "getValidOutputFormatsForInput", "(I)[I");

  /// from: public int[] getValidOutputFormatsForInput(int inputFormat)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the image {@code format} output formats for a reprocessing input format.
  ///
  /// When submitting a CaptureRequest with an input Surface of a given format,
  /// the only allowed target outputs of the CaptureRequest are the ones with a format
  /// listed in the return value of this method. Including any other output Surface as a target
  /// will throw an IllegalArgumentException. If no output format is supported given the input
  /// format, an empty int[] will be returned.
  ///
  ///
  /// All image formats returned by this function will be defined in either ImageFormat
  /// or in PixelFormat (and there is no possibility of collision).
  ///
  ///
  /// Formats listed in this array are guaranteed to return true if queried with
  /// \#isOutputSupportedFor(int).
  ///
  ///@return an array of integer format
  ///@see ImageFormat
  ///@see PixelFormat
  jni.JniObject getValidOutputFormatsForInput(int inputFormat) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getValidOutputFormatsForInput,
          jni.JniType.objectType,
          [inputFormat]).object);

  static final _id_getInputFormats =
      jniAccessors.getMethodIDOf(_classRef, "getInputFormats", "()[I");

  /// from: public int[] getInputFormats()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the image {@code format} input formats in this stream configuration.
  ///
  /// All image formats returned by this function will be defined in either ImageFormat
  /// or in PixelFormat (and there is no possibility of collision).
  ///
  ///@return an array of integer format
  ///@see ImageFormat
  ///@see PixelFormat
  jni.JniObject getInputFormats() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getInputFormats, jni.JniType.objectType, []).object);

  static final _id_getInputSizes = jniAccessors.getMethodIDOf(
      _classRef, "getInputSizes", "(I)[Landroid/util/Size;");

  /// from: public android.util.Size[] getInputSizes(int format)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the supported input sizes for this input format.
  ///
  /// The format must have come from \#getInputFormats; otherwise
  /// {@code null} is returned.
  ///
  ///@param format a format from \#getInputFormats
  ///@return a non-empty array of sizes, or {@code null} if the format was not available.
  jni.JniObject getInputSizes(int format) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getInputSizes, jni.JniType.objectType, [format]).object);

  static final _id_isOutputSupportedFor =
      jniAccessors.getMethodIDOf(_classRef, "isOutputSupportedFor", "(I)Z");

  /// from: public boolean isOutputSupportedFor(int format)
  ///
  /// Determine whether or not output surfaces with a particular user-defined format can be passed
  /// CameraDevice\#createCaptureSession createCaptureSession.
  ///
  /// This method determines that the output {@code format} is supported by the camera device;
  /// each output {@code surface} target may or may not itself support that {@code format}.
  /// Refer to the class which provides the surface for additional documentation.
  ///
  ///
  /// Formats for which this returns {@code true} are guaranteed to exist in the result
  /// returned by \#getOutputSizes.
  ///
  ///@param format an image format from either ImageFormat or PixelFormat
  ///@return {@code true} iff using a {@code surface} with this {@code format} will be
  ///          supported with CameraDevice\#createCaptureSession
  ///@throws IllegalArgumentException if the image format was not a defined named constant
  ///          from either ImageFormat or PixelFormat
  ///@see ImageFormat
  ///@see PixelFormat
  ///@see CameraDevice\#createCaptureSession
  bool isOutputSupportedFor(int format) => jniAccessors.callMethodWithArgs(
      reference,
      _id_isOutputSupportedFor,
      jni.JniType.booleanType,
      [format]).boolean;

  static final _id_isOutputSupportedFor1 = jniAccessors.getStaticMethodIDOf(
      _classRef, "isOutputSupportedFor", "(Ljava/lang/Class;)Z");

  /// from: static public boolean isOutputSupportedFor(java.lang.Class<T> klass)
  ///
  /// Determine whether or not output streams can be configured with a particular class
  /// as a consumer.
  ///
  /// The following list is generally usable for outputs:
  /// <ul>
  /// <li>android.media.ImageReader -
  /// Recommended for image processing or streaming to external resources (such as a file or
  /// network)
  /// <li>android.media.MediaRecorder -
  /// Recommended for recording video (simple to use)
  /// <li>android.media.MediaCodec -
  /// Recommended for recording video (more complicated to use, with more flexibility)
  /// <li>android.renderscript.Allocation -
  /// Recommended for image processing with android.renderscript RenderScript
  /// <li>android.view.SurfaceHolder -
  /// Recommended for low-power camera preview with android.view.SurfaceView
  /// <li>android.graphics.SurfaceTexture -
  /// Recommended for OpenGL-accelerated preview processing or compositing with
  /// android.view.TextureView
  /// </ul>
  ///
  ///
  ///
  /// Generally speaking this means that creating a Surface from that class <i>may</i>
  /// provide a producer endpoint that is suitable to be used with
  /// CameraDevice\#createCaptureSession.
  ///
  ///
  /// Since not all of the above classes support output of all format and size combinations,
  /// the particular combination should be queried with \#isOutputSupportedFor(Surface).
  ///
  ///@param klass a non-{@code null} Class object reference
  ///@return {@code true} if this class is supported as an output, {@code false} otherwise
  ///@throws NullPointerException if {@code klass} was {@code null}
  ///@see CameraDevice\#createCaptureSession
  ///@see \#isOutputSupportedFor(Surface)
  static bool isOutputSupportedFor1(jni.JniObject klass) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_isOutputSupportedFor1,
          jni.JniType.booleanType,
          [klass.reference]).boolean;

  static final _id_isOutputSupportedFor2 = jniAccessors.getMethodIDOf(
      _classRef, "isOutputSupportedFor", "(Landroid/view/Surface;)Z");

  /// from: public boolean isOutputSupportedFor(android.view.Surface surface)
  ///
  /// Determine whether or not the {@code surface} in its current state is suitable to be included
  /// in a CameraDevice\#createCaptureSession capture session as an output.
  ///
  /// Not all surfaces are usable with the CameraDevice, and not all configurations
  /// of that {@code surface} are compatible. Some classes that provide the {@code surface} are
  /// compatible with the CameraDevice in general
  /// (see \#isOutputSupportedFor(Class), but it is the caller's responsibility to put the
  /// {@code surface} into a state that will be compatible with the CameraDevice.
  ///
  ///
  /// Reasons for a {@code surface} being specifically incompatible might be:
  /// <ul>
  /// <li>Using a format that's not listed by \#getOutputFormats
  /// <li>Using a format/size combination that's not listed by \#getOutputSizes
  /// <li>The {@code surface} itself is not in a state where it can service a new producer.
  ///
  /// </li>
  /// </ul>
  ///
  /// Surfaces from flexible sources will return true even if the exact size of the Surface does
  /// not match a camera-supported size, as long as the format (or class) is supported and the
  /// camera device supports a size that is equal to or less than 1080p in that format. If such as
  /// Surface is used to create a capture session, it will have its size rounded to the nearest
  /// supported size, below or equal to 1080p. Flexible sources include SurfaceView, SurfaceTexture,
  /// and ImageReader.
  ///
  ///
  /// This is not an exhaustive list; see the particular class's documentation for further
  /// possible reasons of incompatibility.
  ///
  ///@param surface a non-{@code null} Surface object reference
  ///@return {@code true} if this is supported, {@code false} otherwise
  ///@throws NullPointerException if {@code surface} was {@code null}
  ///@throws IllegalArgumentException if the Surface endpoint is no longer valid
  ///@see CameraDevice\#createCaptureSession
  ///@see \#isOutputSupportedFor(Class)
  bool isOutputSupportedFor2(surface_.Surface surface) =>
      jniAccessors.callMethodWithArgs(reference, _id_isOutputSupportedFor2,
          jni.JniType.booleanType, [surface.reference]).boolean;

  static final _id_getOutputSizes = jniAccessors.getMethodIDOf(
      _classRef, "getOutputSizes", "(Ljava/lang/Class;)[Landroid/util/Size;");

  /// from: public android.util.Size[] getOutputSizes(java.lang.Class<T> klass)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a list of sizes compatible with {@code klass} to use as an output.
  ///
  /// Some of the supported classes may support additional formats beyond
  /// ImageFormat\#PRIVATE; this function only returns
  /// sizes for ImageFormat\#PRIVATE. For example, android.media.ImageReader
  /// supports ImageFormat\#YUV_420_888 and ImageFormat\#PRIVATE, this method will
  /// only return the sizes for ImageFormat\#PRIVATE for android.media.ImageReader
  /// class.
  ///
  ///
  /// If a well-defined format such as {@code NV21} is required, use
  /// \#getOutputSizes(int) instead.
  ///
  ///
  /// The {@code klass} should be a supported output, that querying
  /// {@code \#isOutputSupportedFor(Class)} should return {@code true}.
  ///
  ///@param klass a non-{@code null} Class object reference
  ///@return an array of supported sizes for ImageFormat\#PRIVATE format,
  ///          or {@code null} iff the {@code klass} is not a supported output.
  ///@throws NullPointerException if {@code klass} was {@code null}
  ///@see \#isOutputSupportedFor(Class)
  jni.JniObject getOutputSizes(jni.JniObject klass) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getOutputSizes,
          jni.JniType.objectType,
          [klass.reference]).object);

  static final _id_getOutputSizes1 = jniAccessors.getMethodIDOf(
      _classRef, "getOutputSizes", "(I)[Landroid/util/Size;");

  /// from: public android.util.Size[] getOutputSizes(int format)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a list of sizes compatible with the requested image {@code format}.
  ///
  /// The {@code format} should be a supported format (one of the formats returned by
  /// \#getOutputFormats).
  ///
  ///
  /// As of API level 23, the \#getHighResolutionOutputSizes method can be used on devices
  /// that support the
  /// android.hardware.camera2.CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE BURST_CAPTURE
  /// capability to get a list of high-resolution output sizes that cannot operate at the preferred
  /// 20fps rate. This means that for some supported formats, this method will return an empty
  /// list, if all the supported resolutions operate at below 20fps.  For devices that do not
  /// support the BURST_CAPTURE capability, all output resolutions are listed through this method.
  ///@param format an image format from ImageFormat or PixelFormat
  ///@return an array of supported sizes,
  ///          or {@code null} if the {@code format} is not a supported output
  ///@see ImageFormat
  ///@see PixelFormat
  ///@see \#getOutputFormats
  jni.JniObject getOutputSizes1(int format) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getOutputSizes1, jni.JniType.objectType, [format]).object);

  static final _id_getHighSpeedVideoSizes = jniAccessors.getMethodIDOf(
      _classRef, "getHighSpeedVideoSizes", "()[Landroid/util/Size;");

  /// from: public android.util.Size[] getHighSpeedVideoSizes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a list of supported high speed video recording sizes.
  ///
  /// When CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO is
  /// supported in CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES, this method will
  /// list the supported high speed video size configurations. All the sizes listed will be a
  /// subset of the sizes reported by \#getOutputSizes for processed non-stalling formats
  /// (typically ImageFormat\#PRIVATE ImageFormat\#YUV_420_888, etc.)
  ///
  ///
  ///
  /// To enable high speed video recording, application must create a constrained create high speed
  /// capture session via CameraDevice\#createConstrainedHighSpeedCaptureSession, and submit
  /// a CaptureRequest list created by
  /// android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession\#createHighSpeedRequestList
  /// to this session. The application must select the video size from this method and
  /// CaptureRequest\#CONTROL_AE_TARGET_FPS_RANGE FPS range from
  /// \#getHighSpeedVideoFpsRangesFor to configure the constrained high speed session and
  /// generate the high speed request list. For example, if the application intends to do high
  /// speed recording, it can select the maximum size reported by this method to create high speed
  /// capture session. Note that for the use case of multiple output streams, application must
  /// select one unique size from this method to use (e.g., preview and recording streams must have
  /// the same size). Otherwise, the high speed session creation will fail. Once the size is
  /// selected, application can get the supported FPS ranges by
  /// \#getHighSpeedVideoFpsRangesFor, and use these FPS ranges to setup the recording
  /// request lists via
  /// android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession\#createHighSpeedRequestList.
  ///
  ///
  ///@return an array of supported high speed video recording sizes
  ///@see \#getHighSpeedVideoFpsRangesFor(Size)
  ///@see CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO
  ///@see CameraDevice\#createConstrainedHighSpeedCaptureSession
  ///@see android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession\#createHighSpeedRequestList
  jni.JniObject getHighSpeedVideoSizes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getHighSpeedVideoSizes, jni.JniType.objectType, []).object);

  static final _id_getHighSpeedVideoFpsRangesFor = jniAccessors.getMethodIDOf(
      _classRef,
      "getHighSpeedVideoFpsRangesFor",
      "(Landroid/util/Size;)[Landroid/util/Range;");

  /// from: public android.util.Range<java.lang.Integer>[] getHighSpeedVideoFpsRangesFor(android.util.Size size)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the frame per second ranges (fpsMin, fpsMax) for input high speed video size.
  ///
  /// See \#getHighSpeedVideoFpsRanges for how to enable high speed recording.
  ///
  ///
  ///
  /// The CaptureRequest\#CONTROL_AE_TARGET_FPS_RANGE FPS ranges reported in this method
  /// must not be used to setup capture requests that are submitted to unconstrained capture
  /// sessions, or it will result in IllegalArgumentException IllegalArgumentExceptions.
  ///
  ///
  ///
  /// See \#getHighSpeedVideoFpsRanges for the characteristics of the returned FPS ranges.
  ///
  ///
  ///@param size one of the sizes returned by \#getHighSpeedVideoSizes()
  ///@return an array of supported high speed video recording FPS ranges The upper bound of
  ///         returned ranges is guaranteed to be greater than or equal to 120.
  ///@throws IllegalArgumentException if input size does not exist in the return value of
  ///             getHighSpeedVideoSizes
  ///@see \#getHighSpeedVideoSizes()
  ///@see \#getHighSpeedVideoFpsRanges()
  jni.JniObject getHighSpeedVideoFpsRangesFor(size_.Size size) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getHighSpeedVideoFpsRangesFor,
          jni.JniType.objectType,
          [size.reference]).object);

  static final _id_getHighSpeedVideoFpsRanges = jniAccessors.getMethodIDOf(
      _classRef, "getHighSpeedVideoFpsRanges", "()[Landroid/util/Range;");

  /// from: public android.util.Range<java.lang.Integer>[] getHighSpeedVideoFpsRanges()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a list of supported high speed video recording FPS ranges.
  ///
  /// When CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO is
  /// supported in CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES, this method will
  /// list the supported high speed video FPS range configurations. Application can then use
  /// \#getHighSpeedVideoSizesFor to query available sizes for one of returned FPS range.
  ///
  ///
  ///
  /// To enable high speed video recording, application must create a constrained create high speed
  /// capture session via CameraDevice\#createConstrainedHighSpeedCaptureSession, and submit
  /// a CaptureRequest list created by
  /// android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession\#createHighSpeedRequestList
  /// to this session. The application must select the video size from this method and
  /// CaptureRequest\#CONTROL_AE_TARGET_FPS_RANGE FPS range from
  /// \#getHighSpeedVideoFpsRangesFor to configure the constrained high speed session and
  /// generate the high speed request list. For example, if the application intends to do high
  /// speed recording, it can select one FPS range reported by this method, query the video sizes
  /// corresponding to this FPS range by \#getHighSpeedVideoSizesFor and use one of reported
  /// sizes to create a high speed capture session. Note that for the use case of multiple output
  /// streams, application must select one unique size from this method to use (e.g., preview and
  /// recording streams must have the same size). Otherwise, the high speed session creation will
  /// fail. Once the high speed capture session is created, the application can set the FPS range
  /// in the recording request lists via
  /// android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession\#createHighSpeedRequestList.
  ///
  ///
  ///
  /// The FPS ranges reported by this method will have below characteristics:
  /// <li>The fpsMin and fpsMax will be a multiple 30fps.</li>
  /// <li>The fpsMin will be no less than 30fps, the fpsMax will be no less than 120fps.</li>
  /// <li>At least one range will be a fixed FPS range where fpsMin == fpsMax.</li>
  /// <li>For each fixed FPS range, there will be one corresponding variable FPS range [30,
  /// fps_max]. These kinds of FPS ranges are suitable for preview-only use cases where the
  /// application doesn't want the camera device always produce higher frame rate than the display
  /// refresh rate.</li>
  ///
  ///
  ///@return an array of supported high speed video recording FPS ranges The upper bound of
  ///         returned ranges is guaranteed to be larger or equal to 120.
  ///@see \#getHighSpeedVideoSizesFor
  ///@see CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO
  ///@see CameraDevice\#createConstrainedHighSpeedCaptureSession
  ///@see CameraDevice\#createHighSpeedRequestList
  jni.JniObject getHighSpeedVideoFpsRanges() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getHighSpeedVideoFpsRanges, jni.JniType.objectType, []).object);

  static final _id_getHighSpeedVideoSizesFor = jniAccessors.getMethodIDOf(
      _classRef,
      "getHighSpeedVideoSizesFor",
      "(Landroid/util/Range;)[Landroid/util/Size;");

  /// from: public android.util.Size[] getHighSpeedVideoSizesFor(android.util.Range<java.lang.Integer> fpsRange)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the supported video sizes for an input high speed FPS range.
  ///
  ///  See \#getHighSpeedVideoSizes for how to enable high speed recording.
  ///
  ///@param fpsRange one of the FPS range returned by \#getHighSpeedVideoFpsRanges()
  ///@return An array of video sizes to create high speed capture sessions for high speed streaming
  ///         use cases.
  ///@throws IllegalArgumentException if input FPS range does not exist in the return value of
  ///         getHighSpeedVideoFpsRanges
  ///@see \#getHighSpeedVideoFpsRanges()
  jni.JniObject getHighSpeedVideoSizesFor(range_.Range fpsRange) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getHighSpeedVideoSizesFor,
          jni.JniType.objectType,
          [fpsRange.reference]).object);

  static final _id_getHighResolutionOutputSizes = jniAccessors.getMethodIDOf(
      _classRef, "getHighResolutionOutputSizes", "(I)[Landroid/util/Size;");

  /// from: public android.util.Size[] getHighResolutionOutputSizes(int format)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a list of supported high resolution sizes, which cannot operate at full BURST_CAPTURE
  /// rate.
  ///
  /// This includes all output sizes that cannot meet the 20 fps frame rate requirements for the
  /// android.hardware.camera2.CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE BURST_CAPTURE
  /// capability.  This does not include the stall duration, so for example, a JPEG or RAW16 output
  /// resolution with a large stall duration but a minimum frame duration that's above 20 fps will
  /// still be listed in the regular \#getOutputSizes list. All the sizes on this list are
  /// still guaranteed to operate at a rate of at least 10 fps, not including stall duration.
  ///
  ///
  /// For a device that does not support the BURST_CAPTURE capability, this list will be
  /// {@code null}, since resolutions in the \#getOutputSizes list are already not
  /// guaranteed to meet &gt;= 20 fps rate requirements. For a device that does support the
  /// BURST_CAPTURE capability, this list may be empty, if all supported resolutions meet the 20
  /// fps requirement.
  ///
  ///@return an array of supported slower high-resolution sizes, or {@code null} if the
  ///         BURST_CAPTURE capability is not supported
  jni.JniObject getHighResolutionOutputSizes(int format) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getHighResolutionOutputSizes,
          jni.JniType.objectType,
          [format]).object);

  static final _id_getOutputMinFrameDuration = jniAccessors.getMethodIDOf(
      _classRef, "getOutputMinFrameDuration", "(ILandroid/util/Size;)J");

  /// from: public long getOutputMinFrameDuration(int format, android.util.Size size)
  ///
  /// Get the minimum CaptureRequest\#SENSOR_FRAME_DURATION frame duration
  /// for the format/size combination (in nanoseconds).
  ///
  /// {@code format} should be one of the ones returned by \#getOutputFormats().
  ///
  /// {@code size} should be one of the ones returned by
  /// \#getOutputSizes(int).
  ///
  ///
  /// This should correspond to the frame duration when only that stream is active, with all
  /// processing (typically in {@code android.*.mode}) set to either {@code OFF} or {@code FAST}.
  ///
  ///
  ///
  /// When multiple streams are used in a request, the minimum frame duration will be
  /// {@code max(individual stream min durations)}.
  ///
  ///
  /// For devices that do not support manual sensor control
  /// (android.hardware.camera2.CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR),
  /// this function may return 0.
  ///
  ///
  /// <!--
  /// TODO: uncomment after adding input stream support
  /// The minimum frame duration of a stream (of a particular format, size) is the same
  /// regardless of whether the stream is input or output.
  ///
  /// -->
  ///@param format an image format from ImageFormat or PixelFormat
  ///@param size an output-compatible size
  ///@return a minimum frame duration {@code >} 0 in nanoseconds, or
  ///          0 if the minimum frame duration is not available.
  ///@throws IllegalArgumentException if {@code format} or {@code size} was not supported
  ///@throws NullPointerException if {@code size} was {@code null}
  ///@see CaptureRequest\#SENSOR_FRAME_DURATION
  ///@see \#getOutputStallDuration(int, Size)
  ///@see ImageFormat
  ///@see PixelFormat
  int getOutputMinFrameDuration(int format, size_.Size size) =>
      jniAccessors.callMethodWithArgs(reference, _id_getOutputMinFrameDuration,
          jni.JniType.longType, [format, size.reference]).long;

  static final _id_getOutputMinFrameDuration1 = jniAccessors.getMethodIDOf(
      _classRef,
      "getOutputMinFrameDuration",
      "(Ljava/lang/Class;Landroid/util/Size;)J");

  /// from: public long getOutputMinFrameDuration(java.lang.Class<T> klass, android.util.Size size)
  ///
  /// Get the minimum CaptureRequest\#SENSOR_FRAME_DURATION frame duration
  /// for the class/size combination (in nanoseconds).
  ///
  /// This assumes a the {@code klass} is set up to use ImageFormat\#PRIVATE.
  /// For user-defined formats, use \#getOutputMinFrameDuration(int, Size).
  ///
  ///
  /// {@code klass} should be one of the ones which is supported by
  /// \#isOutputSupportedFor(Class).
  ///
  ///
  /// {@code size} should be one of the ones returned by
  /// \#getOutputSizes(int).
  ///
  ///
  /// This should correspond to the frame duration when only that stream is active, with all
  /// processing (typically in {@code android.*.mode}) set to either {@code OFF} or {@code FAST}.
  ///
  ///
  ///
  /// When multiple streams are used in a request, the minimum frame duration will be
  /// {@code max(individual stream min durations)}.
  ///
  ///
  /// For devices that do not support manual sensor control
  /// (android.hardware.camera2.CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR),
  /// this function may return 0.
  ///
  ///
  /// <!--
  /// TODO: uncomment after adding input stream support
  /// The minimum frame duration of a stream (of a particular format, size) is the same
  /// regardless of whether the stream is input or output.
  ///
  /// -->
  ///@param klass a class which is supported by \#isOutputSupportedFor(Class) and has a
  ///          non-empty array returned by \#getOutputSizes(Class)
  ///@param size an output-compatible size
  ///@return a minimum frame duration {@code >} 0 in nanoseconds, or
  ///          0 if the minimum frame duration is not available.
  ///@throws IllegalArgumentException if {@code klass} or {@code size} was not supported
  ///@throws NullPointerException if {@code size} or {@code klass} was {@code null}
  ///@see CaptureRequest\#SENSOR_FRAME_DURATION
  ///@see ImageFormat
  ///@see PixelFormat
  int getOutputMinFrameDuration1(jni.JniObject klass, size_.Size size) =>
      jniAccessors.callMethodWithArgs(reference, _id_getOutputMinFrameDuration1,
          jni.JniType.longType, [klass.reference, size.reference]).long;

  static final _id_getOutputStallDuration = jniAccessors.getMethodIDOf(
      _classRef, "getOutputStallDuration", "(ILandroid/util/Size;)J");

  /// from: public long getOutputStallDuration(int format, android.util.Size size)
  ///
  /// Get the stall duration for the format/size combination (in nanoseconds).
  ///
  /// {@code format} should be one of the ones returned by \#getOutputFormats().
  ///
  /// {@code size} should be one of the ones returned by
  /// \#getOutputSizes(int).
  ///
  ///
  ///
  /// A stall duration is how much extra time would get added to the normal minimum frame duration
  /// for a repeating request that has streams with non-zero stall.
  ///
  /// For example, consider JPEG captures which have the following characteristics:
  ///
  /// <ul>
  /// <li>JPEG streams act like processed YUV streams in requests for which they are not included;
  /// in requests in which they are directly referenced, they act as JPEG streams.
  /// This is because supporting a JPEG stream requires the underlying YUV data to always be ready
  /// for use by a JPEG encoder, but the encoder will only be used (and impact frame duration) on
  /// requests that actually reference a JPEG stream.
  /// <li>The JPEG processor can run concurrently to the rest of the camera pipeline, but cannot
  /// process more than 1 capture at a time.
  /// </ul>
  ///
  /// In other words, using a repeating YUV request would result in a steady frame rate
  /// (let's say it's 30 FPS). If a single JPEG request is submitted periodically,
  /// the frame rate will stay at 30 FPS (as long as we wait for the previous JPEG to return each
  /// time). If we try to submit a repeating YUV + JPEG request, then the frame rate will drop from
  /// 30 FPS.
  ///
  ///
  /// In general, submitting a new request with a non-0 stall time stream will _not_ cause a
  /// frame rate drop unless there are still outstanding buffers for that stream from previous
  /// requests.
  ///
  ///
  /// Submitting a repeating request with streams (call this {@code S}) is the same as setting
  /// the minimum frame duration from the normal minimum frame duration corresponding to {@code S},
  /// added with the maximum stall duration for {@code S}.
  ///
  ///
  /// If interleaving requests with and without a stall duration, a request will stall by the
  /// maximum of the remaining times for each can-stall stream with outstanding buffers.
  ///
  ///
  /// This means that a stalling request will not have an exposure start until the stall has
  /// completed.
  ///
  ///
  /// This should correspond to the stall duration when only that stream is active, with all
  /// processing (typically in {@code android.*.mode}) set to {@code FAST} or {@code OFF}.
  /// Setting any of the processing modes to {@code HIGH_QUALITY} effectively results in an
  /// indeterminate stall duration for all streams in a request (the regular stall calculation
  /// rules are ignored).
  ///
  ///
  /// The following formats may always have a stall duration:
  /// <ul>
  /// <li>ImageFormat\#JPEG JPEG
  /// <li>ImageFormat\#RAW_SENSOR RAW16
  /// <li>ImageFormat\#RAW_PRIVATE RAW_PRIVATE
  /// </ul>
  ///
  ///
  ///
  /// The following formats will never have a stall duration:
  /// <ul>
  /// <li>ImageFormat\#YUV_420_888 YUV_420_888
  /// <li>\#isOutputSupportedFor(Class) Implementation-Defined
  /// </ul>
  ///
  ///
  ///
  /// All other formats may or may not have an allowed stall duration on a per-capability basis;
  /// refer to CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities for more details.
  ///
  ///
  ///
  ///
  /// See CaptureRequest\#SENSOR_FRAME_DURATION android.sensor.frameDuration
  /// for more information about calculating the max frame rate (absent stalls).
  ///
  ///@param format an image format from ImageFormat or PixelFormat
  ///@param size an output-compatible size
  ///@return a stall duration {@code >=} 0 in nanoseconds
  ///@throws IllegalArgumentException if {@code format} or {@code size} was not supported
  ///@throws NullPointerException if {@code size} was {@code null}
  ///@see CaptureRequest\#SENSOR_FRAME_DURATION
  ///@see ImageFormat
  ///@see PixelFormat
  int getOutputStallDuration(int format, size_.Size size) =>
      jniAccessors.callMethodWithArgs(reference, _id_getOutputStallDuration,
          jni.JniType.longType, [format, size.reference]).long;

  static final _id_getOutputStallDuration1 = jniAccessors.getMethodIDOf(
      _classRef,
      "getOutputStallDuration",
      "(Ljava/lang/Class;Landroid/util/Size;)J");

  /// from: public long getOutputStallDuration(java.lang.Class<T> klass, android.util.Size size)
  ///
  /// Get the stall duration for the class/size combination (in nanoseconds).
  ///
  /// This assumes a the {@code klass} is set up to use ImageFormat\#PRIVATE.
  /// For user-defined formats, use \#getOutputMinFrameDuration(int, Size).
  ///
  ///
  /// {@code klass} should be one of the ones with a non-empty array returned by
  /// \#getOutputSizes(Class).
  ///
  ///
  /// {@code size} should be one of the ones returned by
  /// \#getOutputSizes(Class).
  ///
  ///
  /// See \#getOutputStallDuration(int, Size) for a definition of a
  /// _stall duration_.
  ///
  ///@param klass a class which is supported by \#isOutputSupportedFor(Class) and has a
  ///          non-empty array returned by \#getOutputSizes(Class)
  ///@param size an output-compatible size
  ///@return a minimum frame duration {@code >=} 0 in nanoseconds
  ///@throws IllegalArgumentException if {@code klass} or {@code size} was not supported
  ///@throws NullPointerException if {@code size} or {@code klass} was {@code null}
  ///@see CaptureRequest\#SENSOR_FRAME_DURATION
  ///@see ImageFormat
  ///@see PixelFormat
  int getOutputStallDuration1(jni.JniObject klass, size_.Size size) =>
      jniAccessors.callMethodWithArgs(reference, _id_getOutputStallDuration1,
          jni.JniType.longType, [klass.reference, size.reference]).long;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// Check if this StreamConfigurationMap is equal to another
  /// StreamConfigurationMap.
  ///
  /// Two vectors are only equal if and only if each of the respective elements is equal.
  ///
  ///@return {@code true} if the objects were equal, {@code false} otherwise
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// {@inheritDoc}
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return this StreamConfigurationMap as a string representation.
  ///
  /// {@code "StreamConfigurationMap(Outputs([w:%d, h:%d, format:%s(%d), min_duration:%d,
  /// stall:%d], ... [w:%d, h:%d, format:%s(%d), min_duration:%d, stall:%d]), Inputs([w:%d, h:%d,
  /// format:%s(%d)], ... [w:%d, h:%d, format:%s(%d)]), ValidOutputFormatsForInput(
  /// [in:%d, out:%d, ... %d], ... [in:%d, out:%d, ... %d]), HighSpeedVideoConfigurations(
  /// [w:%d, h:%d, min_fps:%d, max_fps:%d], ... [w:%d, h:%d, min_fps:%d, max_fps:%d]))"}.
  ///
  ///
  /// {@code Outputs([w:%d, h:%d, format:%s(%d), min_duration:%d, stall:%d], ...
  /// [w:%d, h:%d, format:%s(%d), min_duration:%d, stall:%d])}, where
  /// {@code [w:%d, h:%d, format:%s(%d), min_duration:%d, stall:%d]} represents an output
  /// configuration's width, height, format, minimal frame duration in nanoseconds, and stall
  /// duration in nanoseconds.
  ///
  ///
  /// {@code Inputs([w:%d, h:%d, format:%s(%d)], ... [w:%d, h:%d, format:%s(%d)])}, where
  /// {@code [w:%d, h:%d, format:%s(%d)]} represents an input configuration's width, height, and
  /// format.
  ///
  ///
  /// {@code ValidOutputFormatsForInput([in:%s(%d), out:%s(%d), ... %s(%d)],
  /// ... [in:%s(%d), out:%s(%d), ... %s(%d)])}, where {@code [in:%s(%d), out:%s(%d), ... %s(%d)]}
  /// represents an input fomat and its valid output formats.
  ///
  ///
  /// {@code HighSpeedVideoConfigurations([w:%d, h:%d, min_fps:%d, max_fps:%d],
  /// ... [w:%d, h:%d, min_fps:%d, max_fps:%d])}, where
  /// {@code [w:%d, h:%d, min_fps:%d, max_fps:%d]} represents a high speed video output
  /// configuration's width, height, minimal frame rate, and maximal frame rate.
  ///
  ///@return string representation of StreamConfigurationMap
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
