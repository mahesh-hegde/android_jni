// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../os/Parcelable.dart" as parcelable_;

import "../../../view/Surface.dart" as surface_;

import "../../../util/Size.dart" as size_;

import "../../../os/Parcel.dart" as parcel_;
import "../../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.camera2.params.OutputConfiguration
///
/// A class for describing camera output, which contains a Surface and its specific
/// configuration for creating capture session.
///
/// There are several ways to instantiate, modify and use OutputConfigurations. The most common
/// and recommended usage patterns are summarized in the following list:
///
///<ul>
/// <li>Passing a Surface to the constructor and using the OutputConfiguration instance as
/// argument to CameraDevice\#createCaptureSessionByOutputConfigurations. This is the most
/// frequent usage and clients should consider it first before other more complicated alternatives.
/// </li>
///
/// <li>Passing only a surface source class as an argument to the constructor. This is usually
/// followed by a call to create a capture session
/// (see CameraDevice\#createCaptureSessionByOutputConfigurations and a Surface add
/// call \#addSurface with a valid Surface. The sequence completes with
/// CameraCaptureSession\#finalizeOutputConfigurations. This is the deferred usage case which
/// aims to enhance performance by allowing the resource-intensive capture session create call to
/// execute in parallel with any Surface initialization, such as waiting for a
/// android.view.SurfaceView to be ready as part of the UI initialization.</li>
///
/// <li>The third and most complex usage pattern inlvolves surface sharing. Once instantiated an
/// OutputConfiguration can be enabled for surface sharing via \#enableSurfaceSharing. This
/// must be done before creating a new capture session and enables calls to
/// CameraCaptureSession\#updateOutputConfiguration. An OutputConfiguration with enabled
/// surface sharing can be modified via \#addSurface or \#removeSurface. The updates
/// to this OutputConfiguration will only come into effect after
/// CameraCaptureSession\#updateOutputConfiguration returns without throwing exceptions.
/// Such updates can be done as long as the session is active. Clients should always consider the
/// additional requirements and limitations placed on the output surfaces (for more details see
/// \#enableSurfaceSharing, \#addSurface, \#removeSurface,
/// CameraCaptureSession\#updateOutputConfiguration). A trade-off exists between additional
/// complexity and flexibility. If exercised correctly surface sharing can switch between different
/// output surfaces without interrupting any ongoing repeating capture requests. This saves time and
/// can significantly improve the user experience.</li>
///
/// <li>Surface sharing can be used in combination with deferred surfaces. The rules from both cases
/// are combined and clients must call \#enableSurfaceSharing before creating a capture
/// session. Attach and/or remove output surfaces via  \#addSurface/\#removeSurface and
/// finalize the configuration using CameraCaptureSession\#finalizeOutputConfigurations.
/// CameraCaptureSession\#updateOutputConfiguration can be called after the configuration
/// finalize method returns without exceptions.</li>
///
/// </ul>
///
///  As of android.os.Build.VERSION_CODES\#P Android P, all formats except
/// ImageFormat\#JPEG and ImageFormat\#RAW_PRIVATE can be used for sharing, subject to
/// device support. On prior API levels, only ImageFormat\#PRIVATE format may be used.
///
///@see CameraDevice\#createCaptureSessionByOutputConfigurations
class OutputConfiguration extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/hardware/camera2/params/OutputConfiguration");
  OutputConfiguration.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.hardware.camera2.params.OutputConfiguration> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  /// from: static public final int SURFACE_GROUP_ID_NONE
  ///
  /// Invalid surface group ID.
  ///
  ///An OutputConfiguration with this value indicates that the included surface
  ///doesn't belong to any surface group.
  ///
  static const SURFACE_GROUP_ID_NONE = -1;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/view/Surface;)V");

  /// from: public void <init>(android.view.Surface surface)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new OutputConfiguration instance with a Surface.
  ///@param surface A Surface for camera to output to.
  ///
  /// This constructor creates a default configuration, with a surface group ID of
  /// {@value \#SURFACE_GROUP_ID_NONE}.
  ///
  ///
  ///
  /// This value must never be {@code null}.
  OutputConfiguration(surface_.Surface surface)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [surface.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(ILandroid/view/Surface;)V");

  /// from: public void <init>(int surfaceGroupId, android.view.Surface surface)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new OutputConfiguration instance with a Surface,
  /// with a surface group ID.
  ///
  ///
  /// A surface group ID is used to identify which surface group this output surface belongs to. A
  /// surface group is a group of output surfaces that are not intended to receive camera output
  /// buffer streams simultaneously. The CameraDevice may be able to share the buffers used
  /// by all the surfaces from the same surface group, therefore may reduce the overall memory
  /// footprint. The application should only set the same set ID for the streams that are not
  /// simultaneously streaming. A negative ID indicates that this surface doesn't belong to any
  /// surface group. The default value is {@value \#SURFACE_GROUP_ID_NONE}.
  ///
  ///
  /// For example, a video chat application that has an adaptive output resolution feature would
  /// need two (or more) output resolutions, to switch resolutions without any output glitches.
  /// However, at any given time, only one output is active to minimize outgoing network bandwidth
  /// and encoding overhead.  To save memory, the application should set the video outputs to have
  /// the same non-negative group ID, so that the camera device can share the same memory region
  /// for the alternating outputs.
  ///
  ///
  /// It is not an error to include output streams with the same group ID in the same capture
  /// request, but the resulting memory consumption may be higher than if the two streams were
  /// not in the same surface group to begin with, especially if the outputs have substantially
  /// different dimensions.
  ///
  ///@param surfaceGroupId A group ID for this output, used for sharing memory between multiple outputs.
  ///@param surface A Surface for camera to output to.
  ///
  ///
  /// This value must never be {@code null}.
  OutputConfiguration.ctor1(int surfaceGroupId, surface_.Surface surface)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [surfaceGroupId, surface.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/util/Size;Ljava/lang/Class;)V");

  /// from: public void <init>(android.util.Size surfaceSize, java.lang.Class<T> klass)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new OutputConfiguration instance, with desired Surface size and Surface
  /// source class.
  ///
  /// This constructor takes an argument for desired Surface size and the Surface source class
  /// without providing the actual output Surface. This is used to setup an output configuration
  /// with a deferred Surface. The application can use this output configuration to create a
  /// session.
  ///
  ///
  ///
  /// However, the actual output Surface must be set via \#addSurface and the deferred
  /// Surface configuration must be finalized via CameraCaptureSession\#finalizeOutputConfigurations before submitting a request with this
  /// Surface target. The deferred Surface can only be obtained either from android.view.SurfaceView by calling android.view.SurfaceHolder\#getSurface, or from
  /// android.graphics.SurfaceTexture via
  /// android.view.Surface\#Surface(android.graphics.SurfaceTexture)).
  ///
  ///
  ///@param surfaceSize Size for the deferred surface.
  /// This value must never be {@code null}.
  ///@param klass a non-{@code null} Class object reference that indicates the source of
  ///            this surface. Only android.view.SurfaceHolder SurfaceHolder.class and
  ///            android.graphics.SurfaceTexture SurfaceTexture.class are supported.
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if the Surface source class is not supported, or Surface
  ///         size is zero.
  OutputConfiguration.ctor2(size_.Size surfaceSize, jni.JniObject klass)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [surfaceSize.reference, klass.reference]).object);

  static final _id_enableSurfaceSharing =
      jniAccessors.getMethodIDOf(_classRef, "enableSurfaceSharing", "()V");

  /// from: public void enableSurfaceSharing()
  ///
  /// Enable multiple surfaces sharing the same OutputConfiguration
  ///
  /// For advanced use cases, a camera application may require more streams than the combination
  /// guaranteed by CameraDevice\#createCaptureSession. In this case, more than one
  /// compatible surface can be attached to an OutputConfiguration so that they map to one
  /// camera stream, and the outputs share memory buffers when possible. Due to buffer sharing
  /// clients should be careful when adding surface outputs that modify their input data. If such
  /// case exists, camera clients should have an additional mechanism to synchronize read and write
  /// access between individual consumers.
  ///
  ///
  /// Two surfaces are compatible in the below cases:
  ///
  ///
  /// <li> Surfaces with the same size, format, dataSpace, and Surface source class. In this case,
  /// CameraDevice\#createCaptureSessionByOutputConfigurations is guaranteed to succeed.
  ///
  /// <li> Surfaces with the same size, format, and dataSpace, but different Surface source classes
  /// that are generally not compatible. However, on some devices, the underlying camera device is
  /// able to use the same buffer layout for both surfaces. The only way to discover if this is the
  /// case is to create a capture session with that output configuration. For example, if the
  /// camera device uses the same private buffer format between a SurfaceView/SurfaceTexture and a
  /// MediaRecorder/MediaCodec, CameraDevice\#createCaptureSessionByOutputConfigurations
  /// will succeed. Otherwise, it fails with CameraCaptureSession.StateCallback\#onConfigureFailed.
  /// </ol>
  ///
  /// To enable surface sharing, this function must be called before CameraDevice\#createCaptureSessionByOutputConfigurations or CameraDevice\#createReprocessableCaptureSessionByConfigurations. Calling this function after
  /// CameraDevice\#createCaptureSessionByOutputConfigurations has no effect.
  ///
  ///
  /// Up to \#getMaxSharedSurfaceCount surfaces can be shared for an OutputConfiguration.
  /// The supported surfaces for sharing must be of type SurfaceTexture, SurfaceView,
  /// MediaRecorder, MediaCodec, or implementation defined ImageReader.
  ///
  void enableSurfaceSharing() => jniAccessors.callMethodWithArgs(
      reference, _id_enableSurfaceSharing, jni.JniType.voidType, []).check();

  static final _id_setPhysicalCameraId = jniAccessors.getMethodIDOf(
      _classRef, "setPhysicalCameraId", "(Ljava/lang/String;)V");

  /// from: public void setPhysicalCameraId(java.lang.String physicalCameraId)
  ///
  /// Set the id of the physical camera for this OutputConfiguration
  ///
  /// In the case one logical camera is made up of multiple physical cameras, it could be
  /// desirable for the camera application to request streams from individual physical cameras.
  /// This call achieves it by mapping the OutputConfiguration to the physical camera id.
  ///
  ///
  /// The valid physical camera ids can be queried by android.hardware.camera2.CameraCharacteristics\#getPhysicalCameraIds.
  ///
  ///
  ///
  /// Passing in a null physicalCameraId means that the OutputConfiguration is for a logical
  /// stream.
  ///
  ///
  /// This function must be called before CameraDevice\#createCaptureSessionByOutputConfigurations or CameraDevice\#createReprocessableCaptureSessionByConfigurations. Calling this function
  /// after CameraDevice\#createCaptureSessionByOutputConfigurations or CameraDevice\#createReprocessableCaptureSessionByConfigurations has no effect.
  ///
  ///
  /// The surface belonging to a physical camera OutputConfiguration must not be used as input
  /// or output of a reprocessing request.
  ///
  ///@param physicalCameraId This value may be {@code null}.
  void setPhysicalCameraId(jni.JniString physicalCameraId) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPhysicalCameraId,
          jni.JniType.voidType, [physicalCameraId.reference]).check();

  static final _id_addSurface = jniAccessors.getMethodIDOf(
      _classRef, "addSurface", "(Landroid/view/Surface;)V");

  /// from: public void addSurface(android.view.Surface surface)
  ///
  /// Add a surface to this OutputConfiguration.
  ///
  ///  This function can be called before or after CameraDevice\#createCaptureSessionByOutputConfigurations. If it's called after,
  /// the application must finalize the capture session with
  /// CameraCaptureSession\#finalizeOutputConfigurations. It is possible to call this method
  /// after the output configurations have been finalized only in cases of enabled surface sharing
  /// see \#enableSurfaceSharing. The modified output configuration must be updated with
  /// CameraCaptureSession\#updateOutputConfiguration.
  ///
  ///
  ///  If the OutputConfiguration was constructed with a deferred surface by OutputConfiguration\#OutputConfiguration(Size, Class), the added surface must be obtained
  /// from android.view.SurfaceView by calling android.view.SurfaceHolder\#getSurface,
  /// or from android.graphics.SurfaceTexture via
  /// android.view.Surface\#Surface(android.graphics.SurfaceTexture)).
  ///
  ///
  ///  If the OutputConfiguration was constructed by other constructors, the added
  /// surface must be compatible with the existing surface. See \#enableSurfaceSharing for
  /// details of compatible surfaces.
  ///
  ///
  ///  If the OutputConfiguration already contains a Surface, \#enableSurfaceSharing must
  /// be called before calling this function to add a new Surface.
  ///
  ///@param surface The surface to be added.
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if the Surface is invalid, the Surface's
  ///         dataspace/format doesn't match, or adding the Surface would exceed number of
  ///         shared surfaces supported.
  ///@throws IllegalStateException if the Surface was already added to this OutputConfiguration,
  ///         or if the OutputConfiguration is not shared and it already has a surface associated
  ///         with it.
  void addSurface(surface_.Surface surface) => jniAccessors.callMethodWithArgs(
      reference,
      _id_addSurface,
      jni.JniType.voidType,
      [surface.reference]).check();

  static final _id_removeSurface = jniAccessors.getMethodIDOf(
      _classRef, "removeSurface", "(Landroid/view/Surface;)V");

  /// from: public void removeSurface(android.view.Surface surface)
  ///
  /// Remove a surface from this OutputConfiguration.
  ///
  ///  Surfaces added via calls to \#addSurface can also be removed from the
  ///  OutputConfiguration. The only notable exception is the surface associated with
  ///  the OutputConfigration see \#getSurface which was passed as part of the constructor
  ///  or was added first in the deferred case
  ///  OutputConfiguration\#OutputConfiguration(Size, Class).
  ///
  ///@param surface The surface to be removed.
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException If the surface is associated with this OutputConfiguration
  ///                                  (see \#getSurface) or the surface didn't get added
  ///                                  with \#addSurface.
  void removeSurface(surface_.Surface surface) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeSurface,
          jni.JniType.voidType, [surface.reference]).check();

  static final _id_getMaxSharedSurfaceCount =
      jniAccessors.getMethodIDOf(_classRef, "getMaxSharedSurfaceCount", "()I");

  /// from: public int getMaxSharedSurfaceCount()
  ///
  /// Get the maximum supported shared Surface count.
  ///@return the maximum number of surfaces that can be added per each OutputConfiguration.
  ///@see \#enableSurfaceSharing
  int getMaxSharedSurfaceCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxSharedSurfaceCount, jni.JniType.intType, []).integer;

  static final _id_getSurface = jniAccessors.getMethodIDOf(
      _classRef, "getSurface", "()Landroid/view/Surface;");

  /// from: public android.view.Surface getSurface()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the Surface associated with this OutputConfiguration.
  ///
  /// If more than one surface is associated with this OutputConfiguration, return the
  /// first one as specified in the constructor or OutputConfiguration\#addSurface.
  ///@return This value may be {@code null}.
  surface_.Surface getSurface() =>
      surface_.Surface.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSurface, jni.JniType.objectType, []).object);

  static final _id_getSurfaces = jniAccessors.getMethodIDOf(
      _classRef, "getSurfaces", "()Ljava/util/List;");

  /// from: public java.util.List<android.view.Surface> getSurfaces()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the immutable list of surfaces associated with this OutputConfiguration.
  ///@return the list of surfaces associated with this OutputConfiguration as specified in
  /// the constructor and OutputConfiguration\#addSurface. The list should not be modified.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getSurfaces() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSurfaces, jni.JniType.objectType, []).object);

  static final _id_getSurfaceGroupId =
      jniAccessors.getMethodIDOf(_classRef, "getSurfaceGroupId", "()I");

  /// from: public int getSurfaceGroupId()
  ///
  /// Get the surface group ID associated with this OutputConfiguration.
  ///@return the surface group ID associated with this OutputConfiguration.
  ///         The default value is {@value \#SURFACE_GROUP_ID_NONE}.
  int getSurfaceGroupId() => jniAccessors.callMethodWithArgs(
      reference, _id_getSurfaceGroupId, jni.JniType.intType, []).integer;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// Check if this OutputConfiguration is equal to another OutputConfiguration.
  ///
  /// Two output configurations are only equal if and only if the underlying surfaces, surface
  /// properties (width, height, format, dataspace) when the output configurations are created,
  /// and all other configuration parameters are equal.
  ///
  ///@return {@code true} if the objects were equal, {@code false} otherwise
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// {@inheritDoc}
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;
}
