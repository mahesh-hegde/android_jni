// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "RggbChannelVector.dart" as rggbchannelvector_;
import "../../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.camera2.params.LensShadingMap
///
/// Immutable class for describing a {@code 4 x N x M} lens shading map of floats.
///@see CaptureResult\#STATISTICS_LENS_SHADING_CORRECTION_MAP
class LensShadingMap extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/camera2/params/LensShadingMap");
  LensShadingMap.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final float MINIMUM_GAIN_FACTOR
  ///
  /// The smallest gain factor in this map.
  ///
  /// All values in this map will be at least this large.
  ///
  static const MINIMUM_GAIN_FACTOR = 1.0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "([FII)V");

  /// from: void <init>(float[] elements, int rows, int columns)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new immutable LensShadingMap instance.
  ///
  /// The elements must be stored in a row-major order (fully packed).
  ///
  ///
  /// This constructor takes over the array; do not write to the array afterwards.
  ///
  ///@param elements An array of elements whose length is
  ///          {@code RggbChannelVector.COUNT * rows * columns}
  ///@throws IllegalArgumentException if the {@code elements} array length is invalid,
  ///            if any of the subelems are not finite or less than {@value \#MINIMUM_GAIN_FACTOR},
  ///            or if rows or columns is not positive
  ///@throws NullPointerException if {@code elements} is {@code null}
  ///@hide
  LensShadingMap(jni.JniObject elements, int rows, int columns)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [elements.reference, rows, columns]).object);

  static final _id_getRowCount =
      jniAccessors.getMethodIDOf(_classRef, "getRowCount", "()I");

  /// from: public int getRowCount()
  ///
  /// Get the number of rows in this map.
  int getRowCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getRowCount, jni.JniType.intType, []).integer;

  static final _id_getColumnCount =
      jniAccessors.getMethodIDOf(_classRef, "getColumnCount", "()I");

  /// from: public int getColumnCount()
  ///
  /// Get the number of columns in this map.
  int getColumnCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getColumnCount, jni.JniType.intType, []).integer;

  static final _id_getGainFactorCount =
      jniAccessors.getMethodIDOf(_classRef, "getGainFactorCount", "()I");

  /// from: public int getGainFactorCount()
  ///
  /// Get the total number of gain factors in this map.
  ///
  /// A single gain factor contains exactly one color channel.
  /// Use with \#copyGainFactors to allocate a large-enough array.
  ///
  int getGainFactorCount() => jniAccessors.callMethodWithArgs(
      reference, _id_getGainFactorCount, jni.JniType.intType, []).integer;

  static final _id_getGainFactor =
      jniAccessors.getMethodIDOf(_classRef, "getGainFactor", "(III)F");

  /// from: public float getGainFactor(int colorChannel, int column, int row)
  ///
  /// Get a single color channel gain factor from this lens shading map by its row and column.
  ///
  /// The rows must be within the range [0, \#getRowCount),
  /// the column must be within the range [0, \#getColumnCount),
  /// and the color channel must be within the range [0, {@value RggbChannelVector\#COUNT}).
  ///
  ///
  /// The channel order is {@code [R, Geven, Godd, B]}, where
  /// {@code Geven} is the green channel for the even rows of a Bayer pattern, and
  /// {@code Godd} is the odd rows.
  ///
  ///
  ///@param colorChannel color channel from {@code [R, Geven, Godd, B]}
  ///@param column within the range [0, \#getColumnCount)
  ///@param row within the range [0, \#getRowCount)
  ///@return a gain factor >= {@value \#MINIMUM_GAIN_FACTOR}
  ///@throws IllegalArgumentException if any of the parameters was out of range
  ///@see \#RED
  ///@see \#GREEN_EVEN
  ///@see \#GREEN_ODD
  ///@see \#BLUE
  ///@see \#getRowCount
  ///@see \#getColumnCount
  double getGainFactor(int colorChannel, int column, int row) =>
      jniAccessors.callMethodWithArgs(reference, _id_getGainFactor,
          jni.JniType.floatType, [colorChannel, column, row]).float;

  static final _id_getGainFactorVector = jniAccessors.getMethodIDOf(
      _classRef,
      "getGainFactorVector",
      "(II)Landroid/hardware/camera2/params/RggbChannelVector;");

  /// from: public android.hardware.camera2.params.RggbChannelVector getGainFactorVector(int column, int row)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a gain factor vector from this lens shading map by its row and column.
  ///
  /// The rows must be within the range [0, \#getRowCount),
  /// the column must be within the range [0, \#getColumnCount).
  ///
  ///@param column within the range [0, \#getColumnCount)
  ///@param row within the range [0, \#getRowCount)
  ///@return an RggbChannelVector where each gain factor >= {@value \#MINIMUM_GAIN_FACTOR}
  ///@throws IllegalArgumentException if any of the parameters was out of range
  ///@see \#getRowCount
  ///@see \#getColumnCount
  rggbchannelvector_.RggbChannelVector getGainFactorVector(
          int column, int row) =>
      rggbchannelvector_.RggbChannelVector.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getGainFactorVector,
              jni.JniType.objectType, [column, row]).object);

  static final _id_copyGainFactors =
      jniAccessors.getMethodIDOf(_classRef, "copyGainFactors", "([FI)V");

  /// from: public void copyGainFactors(float[] destination, int offset)
  ///
  /// Copy all gain factors in row-major order from this lens shading map into the destination.
  ///
  /// Each gain factor will be >= \#MINIMUM_GAIN_FACTOR.
  ///
  ///@param destination an array big enough to hold at least RggbChannelVector\#COUNT
  ///          elements after the {@code offset}
  ///@param offset a non-negative offset into the array
  ///@throws NullPointerException If {@code destination} was {@code null}
  ///@throws IllegalArgumentException If offset was negative
  ///@throws ArrayIndexOutOfBoundsException If there's not enough room to write the elements at the specified destination and
  ///          offset.
  ///@see CaptureResult\#STATISTICS_LENS_SHADING_MAP
  void copyGainFactors(jni.JniObject destination, int offset) =>
      jniAccessors.callMethodWithArgs(reference, _id_copyGainFactors,
          jni.JniType.voidType, [destination.reference, offset]).check();

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// Check if this LensShadingMap is equal to another LensShadingMap.
  ///
  /// Two lens shading maps are equal if and only if they have the same rows/columns,
  /// and all of their elements are Object\#equals equal.
  ///
  ///@return {@code true} if the objects were equal, {@code false} otherwise
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// {@inheritDoc}
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the LensShadingMap as a string representation.
  ///
  ///  {@code "LensShadingMap{R:([%f, %f, ... %f], ... [%f, %f, ... %f]), G_even:([%f, %f, ...
  ///  %f], ... [%f, %f, ... %f]), G_odd:([%f, %f, ... %f], ... [%f, %f, ... %f]), B:([%f, %f, ...
  ///  %f], ... [%f, %f, ... %f])}"},
  /// where each {@code %f} represents one gain factor and each {@code [%f, %f, ... %f]} represents
  /// a row of the lens shading map
  ///
  ///@return string representation of LensShadingMap
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
