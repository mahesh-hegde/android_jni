// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.camera2.params.BlackLevelPattern
///
/// Immutable class to store a 4-element vector of integers corresponding to a 2x2 pattern
/// of color channel offsets used for the black level offsets of each color channel.
class BlackLevelPattern extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/hardware/camera2/params/BlackLevelPattern");
  BlackLevelPattern.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int COUNT
  ///
  /// The number of offsets in this vector.
  static const COUNT = 4;

  static final _id_getOffsetForIndex =
      jniAccessors.getMethodIDOf(_classRef, "getOffsetForIndex", "(II)I");

  /// from: public int getOffsetForIndex(int column, int row)
  ///
  /// Return the color channel offset for a given index into the array of raw pixel values.
  ///@param column the column index in the the raw pixel array.
  ///@param row the row index in the raw pixel array.
  ///@return a color channel offset.
  ///@throws IllegalArgumentException if a column or row given is negative.
  int getOffsetForIndex(int column, int row) => jniAccessors.callMethodWithArgs(
      reference,
      _id_getOffsetForIndex,
      jni.JniType.intType,
      [column, row]).integer;

  static final _id_copyTo =
      jniAccessors.getMethodIDOf(_classRef, "copyTo", "([II)V");

  /// from: public void copyTo(int[] destination, int offset)
  ///
  /// Copy the ColorChannel offsets into the destination vector.
  ///
  /// Offsets are given in row-column scan order for a given 2x2 color pattern.
  ///
  ///@param destination an array big enough to hold at least {@value \#COUNT} elements after the
  ///          {@code offset}
  ///@param offset a non-negative offset into the array
  ///@throws IllegalArgumentException if the offset is invalid.
  ///@throws ArrayIndexOutOfBoundsException if the destination vector is too small.
  ///@throws NullPointerException if the destination is null.
  void copyTo(jni.JniObject destination, int offset) =>
      jniAccessors.callMethodWithArgs(reference, _id_copyTo,
          jni.JniType.voidType, [destination.reference, offset]).check();

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// Check if this BlackLevelPattern is equal to another BlackLevelPattern.
  ///
  /// Two vectors are only equal if and only if each of the respective elements is equal.
  ///
  ///@return {@code true} if the objects were equal, {@code false} otherwise
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// {@inheritDoc}
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return this BlackLevelPattern as a string representation.
  ///
  ///  {@code "BlackLevelPattern([%d, %d], [%d, %d])"}, where each {@code %d} represents one
  /// black level offset of a color channel. The values are in the same order as channels listed
  /// for the CFA layout key (see
  /// android.hardware.camera2.CameraCharacteristics\#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT).
  ///
  ///
  ///@return string representation of BlackLevelPattern
  ///@see android.hardware.camera2.CameraCharacteristics\#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
