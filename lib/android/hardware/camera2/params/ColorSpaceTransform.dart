// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../util/Rational.dart" as rational_;
import "../../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.camera2.params.ColorSpaceTransform
///
/// Immutable class for describing a 3x3 matrix of Rational values in row-major order.
///
/// This matrix maps a transform from one color space to another. For the particular color space
/// source and target, see the appropriate camera metadata documentation for the key that provides
/// this value.
///
///@see CameraMetadata
class ColorSpaceTransform extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/hardware/camera2/params/ColorSpaceTransform");
  ColorSpaceTransform.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "([Landroid/util/Rational;)V");

  /// from: public void <init>(android.util.Rational[] elements)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new immutable ColorSpaceTransform instance from a Rational array.
  ///
  /// The elements must be stored in a row-major order.
  ///
  ///@param elements An array of {@code 9} elements
  ///@throws IllegalArgumentException if the count of {@code elements} is not {@code 9}
  ///@throws NullPointerException if {@code elements} or any sub-element is {@code null}
  ColorSpaceTransform(jni.JniObject elements)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [elements.reference]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "([I)V");

  /// from: public void <init>(int[] elements)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new immutable ColorSpaceTransform instance from an {@code int} array.
  ///
  /// The elements must be stored in a row-major order. Each rational is stored
  /// contiguously as a {@code (numerator, denominator)} pair.
  ///
  ///
  /// In particular:<pre>{@code
  /// int[] elements = new int[
  ///     N11, D11, N12, D12, N13, D13,
  ///     N21, D21, N22, D22, N23, D23,
  ///     N31, D31, N32, D32, N33, D33
  /// ];
  ///
  /// new ColorSpaceTransform(elements)}</pre>
  ///
  /// where {@code Nij} and {@code Dij} is the numerator and denominator for row {@code i} and
  /// column {@code j}.
  ///
  ///@param elements An array of {@code 18} elements
  ///@throws IllegalArgumentException if the count of {@code elements} is not {@code 18}
  ///@throws NullPointerException if {@code elements} is {@code null}
  ColorSpaceTransform.ctor1(jni.JniObject elements)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [elements.reference]).object);

  static final _id_getElement = jniAccessors.getMethodIDOf(
      _classRef, "getElement", "(II)Landroid/util/Rational;");

  /// from: public android.util.Rational getElement(int column, int row)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get an element of this matrix by its row and column.
  ///
  /// The rows must be within the range [0, 3),
  /// and the column must be within the range [0, 3).
  ///
  ///@return element (non-{@code null})
  ///@throws IllegalArgumentException if column or row was out of range
  rational_.Rational getElement(int column, int row) =>
      rational_.Rational.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getElement, jni.JniType.objectType, [column, row]).object);

  static final _id_copyElements = jniAccessors.getMethodIDOf(
      _classRef, "copyElements", "([Landroid/util/Rational;I)V");

  /// from: public void copyElements(android.util.Rational[] destination, int offset)
  ///
  /// Copy the Rational elements in row-major order from this matrix into the destination.
  ///@param destination an array big enough to hold at least {@code 9} elements after the
  ///          {@code offset}
  ///@param offset a non-negative offset into the array
  ///@throws NullPointerException If {@code destination} was {@code null}
  ///@throws ArrayIndexOutOfBoundsException If there's not enough room to write the elements at the specified destination and
  ///          offset.
  void copyElements(jni.JniObject destination, int offset) =>
      jniAccessors.callMethodWithArgs(reference, _id_copyElements,
          jni.JniType.voidType, [destination.reference, offset]).check();

  static final _id_copyElements1 =
      jniAccessors.getMethodIDOf(_classRef, "copyElements", "([II)V");

  /// from: public void copyElements(int[] destination, int offset)
  ///
  /// Copy the Rational elements in row-major order from this matrix into the destination.
  ///
  /// Each element is stored as a contiguous rational packed as a
  /// {@code (numerator, denominator)} pair of ints, identical to the
  /// ColorSpaceTransform\#ColorSpaceTransform(int[]) constructor.
  ///
  ///@param destination an array big enough to hold at least {@code 18} elements after the
  ///          {@code offset}
  ///@param offset a non-negative offset into the array
  ///@throws NullPointerException If {@code destination} was {@code null}
  ///@throws ArrayIndexOutOfBoundsException If there's not enough room to write the elements at the specified destination and
  ///          offset.
  ///@see ColorSpaceTransform\#ColorSpaceTransform(int[])
  void copyElements1(jni.JniObject destination, int offset) =>
      jniAccessors.callMethodWithArgs(reference, _id_copyElements1,
          jni.JniType.voidType, [destination.reference, offset]).check();

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// Check if this ColorSpaceTransform is equal to another ColorSpaceTransform.
  ///
  /// Two color space transforms are equal if and only if all of their elements are
  /// Object\#equals equal.
  ///
  ///@return {@code true} if the objects were equal, {@code false} otherwise
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// {@inheritDoc}
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the color space transform as a string representation.
  ///
  ///   Example:
  /// {@code "ColorSpaceTransform([1/1, 0/1, 0/1], [0/1, 1/1, 0/1], [0/1, 0/1, 1/1])"} is an
  /// identity transform. Elements are printed in row major order.
  ///
  ///@return string representation of color space transform
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
