// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.camera2.params.RggbChannelVector
///
/// Immutable class to store a 4-element vector of floats indexable by a bayer RAW 2x2 pixel block.
class RggbChannelVector extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/hardware/camera2/params/RggbChannelVector");
  RggbChannelVector.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int BLUE
  ///
  /// Blue color channel in a bayer Raw pattern.
  static const BLUE = 3;

  /// from: static public final int COUNT
  ///
  /// The number of color channels in this vector.
  static const COUNT = 4;

  /// from: static public final int GREEN_EVEN
  ///
  /// Green color channel in a bayer Raw pattern used by the even rows.
  static const GREEN_EVEN = 1;

  /// from: static public final int GREEN_ODD
  ///
  /// Green color channel in a bayer Raw pattern used by the odd rows.
  static const GREEN_ODD = 2;

  /// from: static public final int RED
  ///
  /// Red color channel in a bayer Raw pattern.
  static const RED = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(FFFF)V");

  /// from: public void <init>(float red, float greenEven, float greenOdd, float blue)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new RggbChannelVector from an RGGB 2x2 pixel.
  ///
  /// All pixel values are considered normalized within {@code [0.0f, 1.0f]}
  /// (i.e. {@code 1.0f} could be linearized to {@code 255} if converting to a
  /// non-floating point pixel representation).
  ///
  ///
  /// All arguments must be finite; NaN and infinity is not allowed.
  ///
  ///@param red red pixel
  ///@param greenEven green pixel (even row)
  ///@param greenOdd green pixel (odd row)
  ///@param blue blue pixel
  ///@throws IllegalArgumentException if any of the arguments were not finite
  RggbChannelVector(double red, double greenEven, double greenOdd, double blue)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [red, greenEven, greenOdd, blue]).object);

  static final _id_getRed =
      jniAccessors.getMethodIDOf(_classRef, "getRed", "()F");

  /// from: public float getRed()
  ///
  /// Get the red component.
  ///@return a floating point value (guaranteed to be finite)
  double getRed() => jniAccessors.callMethodWithArgs(
      reference, _id_getRed, jni.JniType.floatType, []).float;

  static final _id_getGreenEven =
      jniAccessors.getMethodIDOf(_classRef, "getGreenEven", "()F");

  /// from: public float getGreenEven()
  ///
  /// Get the green (even rows) component.
  ///@return a floating point value (guaranteed to be finite)
  double getGreenEven() => jniAccessors.callMethodWithArgs(
      reference, _id_getGreenEven, jni.JniType.floatType, []).float;

  static final _id_getGreenOdd =
      jniAccessors.getMethodIDOf(_classRef, "getGreenOdd", "()F");

  /// from: public float getGreenOdd()
  ///
  /// Get the green (odd rows) component.
  ///@return a floating point value (guaranteed to be finite)
  double getGreenOdd() => jniAccessors.callMethodWithArgs(
      reference, _id_getGreenOdd, jni.JniType.floatType, []).float;

  static final _id_getBlue =
      jniAccessors.getMethodIDOf(_classRef, "getBlue", "()F");

  /// from: public float getBlue()
  ///
  /// Get the blue component.
  ///@return a floating point value (guaranteed to be finite)
  double getBlue() => jniAccessors.callMethodWithArgs(
      reference, _id_getBlue, jni.JniType.floatType, []).float;

  static final _id_getComponent =
      jniAccessors.getMethodIDOf(_classRef, "getComponent", "(I)F");

  /// from: public float getComponent(int colorChannel)
  ///
  /// Get the component by the color channel index.
  ///
  /// {@code colorChannel} must be one of \#RED, \#GREEN_EVEN, \#GREEN_ODD,
  /// \#BLUE.
  ///
  ///@param colorChannel greater or equal to {@code 0} and less than \#COUNT
  ///@return a floating point value (guaranteed to be finite)
  ///@throws IllegalArgumentException if {@code colorChannel} was out of range
  double getComponent(int colorChannel) => jniAccessors.callMethodWithArgs(
      reference, _id_getComponent, jni.JniType.floatType, [colorChannel]).float;

  static final _id_copyTo =
      jniAccessors.getMethodIDOf(_classRef, "copyTo", "([FI)V");

  /// from: public void copyTo(float[] destination, int offset)
  ///
  /// Copy the vector into the destination in the order {@code [R, Geven, Godd, B]}.
  ///@param destination an array big enough to hold at least {@value \#COUNT} elements after the
  ///          {@code offset}
  ///@param offset a non-negative offset into the array
  ///@throws NullPointerException If {@code destination} was {@code null}
  ///@throws ArrayIndexOutOfBoundsException If there's not enough room to write the elements at the specified destination and
  ///          offset.
  void copyTo(jni.JniObject destination, int offset) =>
      jniAccessors.callMethodWithArgs(reference, _id_copyTo,
          jni.JniType.voidType, [destination.reference, offset]).check();

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object obj)
  ///
  /// Check if this RggbChannelVector is equal to another RggbChannelVector.
  ///
  /// Two vectors are only equal if and only if each of the respective elements is equal.
  ///
  ///@return {@code true} if the objects were equal, {@code false} otherwise
  bool equals1(jni.JniObject obj) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [obj.reference]).boolean;

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// {@inheritDoc}
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the RggbChannelVector as a string representation.
  ///
  ///  {@code "RggbChannelVector{R:%f, G_even:%f, G_odd:%f, B:%f}"}, where each
  /// {@code %f} respectively represents one of the the four color channels.
  ///
  ///@return string representation of RggbChannelVector
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
