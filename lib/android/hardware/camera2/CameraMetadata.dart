// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.camera2.CameraMetadata
///
/// The base class for camera controls and information.
///
///
/// This class defines the basic key/value map used for querying for camera
/// characteristics or capture results, and for setting camera request
/// parameters.
///
///
///
///
/// All instances of CameraMetadata are immutable. The list of keys with \#getKeys()
/// never changes, nor do the values returned by any key with {@code \#get} throughout
/// the lifetime of the object.
///
///
///@see CameraDevice
///@see CameraManager
///@see CameraCharacteristics
class CameraMetadata extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/camera2/CameraMetadata");
  CameraMetadata.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int COLOR_CORRECTION_ABERRATION_MODE_FAST
  ///
  /// Aberration correction will not slow down capture rate
  /// relative to sensor raw output.
  ///
  ///@see CaptureRequest\#COLOR_CORRECTION_ABERRATION_MODE
  static const COLOR_CORRECTION_ABERRATION_MODE_FAST = 1;

  /// from: static public final int COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY
  ///
  /// Aberration correction operates at improved quality but the capture rate might be
  /// reduced (relative to sensor raw output rate)
  ///
  ///@see CaptureRequest\#COLOR_CORRECTION_ABERRATION_MODE
  static const COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY = 2;

  /// from: static public final int COLOR_CORRECTION_ABERRATION_MODE_OFF
  ///
  /// No aberration correction is applied.
  ///
  ///@see CaptureRequest\#COLOR_CORRECTION_ABERRATION_MODE
  static const COLOR_CORRECTION_ABERRATION_MODE_OFF = 0;

  /// from: static public final int COLOR_CORRECTION_MODE_FAST
  ///
  /// Color correction processing must not slow down
  /// capture rate relative to sensor raw output.
  ///
  /// Advanced white balance adjustments above and beyond
  /// the specified white balance pipeline may be applied.
  ///
  /// If AWB is enabled with <code>CaptureRequest\#CONTROL_AWB_MODE android.control.awbMode != OFF</code>, then
  /// the camera device uses the last frame's AWB values
  /// (or defaults if AWB has never been run).
  ///
  ///@see CaptureRequest\#CONTROL_AWB_MODE
  ///@see CaptureRequest\#COLOR_CORRECTION_MODE
  static const COLOR_CORRECTION_MODE_FAST = 1;

  /// from: static public final int COLOR_CORRECTION_MODE_HIGH_QUALITY
  ///
  /// Color correction processing operates at improved
  /// quality but the capture rate might be reduced (relative to sensor
  /// raw output rate)
  ///
  /// Advanced white balance adjustments above and beyond
  /// the specified white balance pipeline may be applied.
  ///
  /// If AWB is enabled with <code>CaptureRequest\#CONTROL_AWB_MODE android.control.awbMode != OFF</code>, then
  /// the camera device uses the last frame's AWB values
  /// (or defaults if AWB has never been run).
  ///
  ///@see CaptureRequest\#CONTROL_AWB_MODE
  ///@see CaptureRequest\#COLOR_CORRECTION_MODE
  static const COLOR_CORRECTION_MODE_HIGH_QUALITY = 2;

  /// from: static public final int COLOR_CORRECTION_MODE_TRANSFORM_MATRIX
  ///
  /// Use the CaptureRequest\#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform matrix
  /// and CaptureRequest\#COLOR_CORRECTION_GAINS android.colorCorrection.gains to do color conversion.
  ///
  /// All advanced white balance adjustments (not specified
  /// by our white balance pipeline) must be disabled.
  ///
  /// If AWB is enabled with <code>CaptureRequest\#CONTROL_AWB_MODE android.control.awbMode != OFF</code>, then
  /// TRANSFORM_MATRIX is ignored. The camera device will override
  /// this value to either FAST or HIGH_QUALITY.
  ///
  ///@see CaptureRequest\#COLOR_CORRECTION_GAINS
  ///@see CaptureRequest\#COLOR_CORRECTION_TRANSFORM
  ///@see CaptureRequest\#CONTROL_AWB_MODE
  ///@see CaptureRequest\#COLOR_CORRECTION_MODE
  static const COLOR_CORRECTION_MODE_TRANSFORM_MATRIX = 0;

  /// from: static public final int CONTROL_AE_ANTIBANDING_MODE_50HZ
  ///
  /// The camera device will adjust exposure duration to
  /// avoid banding problems with 50Hz illumination sources.
  ///
  ///@see CaptureRequest\#CONTROL_AE_ANTIBANDING_MODE
  static const CONTROL_AE_ANTIBANDING_MODE_50HZ = 1;

  /// from: static public final int CONTROL_AE_ANTIBANDING_MODE_60HZ
  ///
  /// The camera device will adjust exposure duration to
  /// avoid banding problems with 60Hz illumination
  /// sources.
  ///
  ///@see CaptureRequest\#CONTROL_AE_ANTIBANDING_MODE
  static const CONTROL_AE_ANTIBANDING_MODE_60HZ = 2;

  /// from: static public final int CONTROL_AE_ANTIBANDING_MODE_AUTO
  ///
  /// The camera device will automatically adapt its
  /// antibanding routine to the current illumination
  /// condition. This is the default mode if AUTO is
  /// available on given camera device.
  ///
  ///@see CaptureRequest\#CONTROL_AE_ANTIBANDING_MODE
  static const CONTROL_AE_ANTIBANDING_MODE_AUTO = 3;

  /// from: static public final int CONTROL_AE_ANTIBANDING_MODE_OFF
  ///
  /// The camera device will not adjust exposure duration to
  /// avoid banding problems.
  ///
  ///@see CaptureRequest\#CONTROL_AE_ANTIBANDING_MODE
  static const CONTROL_AE_ANTIBANDING_MODE_OFF = 0;

  /// from: static public final int CONTROL_AE_MODE_OFF
  ///
  /// The camera device's autoexposure routine is disabled.
  ///
  /// The application-selected CaptureRequest\#SENSOR_EXPOSURE_TIME android.sensor.exposureTime,
  /// CaptureRequest\#SENSOR_SENSITIVITY android.sensor.sensitivity and
  /// CaptureRequest\#SENSOR_FRAME_DURATION android.sensor.frameDuration are used by the camera
  /// device, along with android.flash.* fields, if there's
  /// a flash unit for this camera device.
  ///
  /// Note that auto-white balance (AWB) and auto-focus (AF)
  /// behavior is device dependent when AE is in OFF mode.
  /// To have consistent behavior across different devices,
  /// it is recommended to either set AWB and AF to OFF mode
  /// or lock AWB and AF before setting AE to OFF.
  /// See CaptureRequest\#CONTROL_AWB_MODE android.control.awbMode, CaptureRequest\#CONTROL_AF_MODE android.control.afMode,
  /// CaptureRequest\#CONTROL_AWB_LOCK android.control.awbLock, and CaptureRequest\#CONTROL_AF_TRIGGER android.control.afTrigger
  /// for more details.
  ///
  /// LEGACY devices do not support the OFF mode and will
  /// override attempts to use this value to ON.
  ///
  ///@see CaptureRequest\#CONTROL_AF_MODE
  ///@see CaptureRequest\#CONTROL_AF_TRIGGER
  ///@see CaptureRequest\#CONTROL_AWB_LOCK
  ///@see CaptureRequest\#CONTROL_AWB_MODE
  ///@see CaptureRequest\#SENSOR_EXPOSURE_TIME
  ///@see CaptureRequest\#SENSOR_FRAME_DURATION
  ///@see CaptureRequest\#SENSOR_SENSITIVITY
  ///@see CaptureRequest\#CONTROL_AE_MODE
  static const CONTROL_AE_MODE_OFF = 0;

  /// from: static public final int CONTROL_AE_MODE_ON
  ///
  /// The camera device's autoexposure routine is active,
  /// with no flash control.
  ///
  /// The application's values for
  /// CaptureRequest\#SENSOR_EXPOSURE_TIME android.sensor.exposureTime,
  /// CaptureRequest\#SENSOR_SENSITIVITY android.sensor.sensitivity, and
  /// CaptureRequest\#SENSOR_FRAME_DURATION android.sensor.frameDuration are ignored. The
  /// application has control over the various
  /// android.flash.* fields.
  ///
  ///@see CaptureRequest\#SENSOR_EXPOSURE_TIME
  ///@see CaptureRequest\#SENSOR_FRAME_DURATION
  ///@see CaptureRequest\#SENSOR_SENSITIVITY
  ///@see CaptureRequest\#CONTROL_AE_MODE
  static const CONTROL_AE_MODE_ON = 1;

  /// from: static public final int CONTROL_AE_MODE_ON_ALWAYS_FLASH
  ///
  /// Like ON, except that the camera device also controls
  /// the camera's flash unit, always firing it for still
  /// captures.
  ///
  /// The flash may be fired during a precapture sequence
  /// (triggered by CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger) and
  /// will always be fired for captures for which the
  /// CaptureRequest\#CONTROL_CAPTURE_INTENT android.control.captureIntent field is set to
  /// STILL_CAPTURE
  ///
  ///@see CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER
  ///@see CaptureRequest\#CONTROL_CAPTURE_INTENT
  ///@see CaptureRequest\#CONTROL_AE_MODE
  static const CONTROL_AE_MODE_ON_ALWAYS_FLASH = 3;

  /// from: static public final int CONTROL_AE_MODE_ON_AUTO_FLASH
  ///
  /// Like ON, except that the camera device also controls
  /// the camera's flash unit, firing it in low-light
  /// conditions.
  ///
  /// The flash may be fired during a precapture sequence
  /// (triggered by CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger) and
  /// may be fired for captures for which the
  /// CaptureRequest\#CONTROL_CAPTURE_INTENT android.control.captureIntent field is set to
  /// STILL_CAPTURE
  ///
  ///@see CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER
  ///@see CaptureRequest\#CONTROL_CAPTURE_INTENT
  ///@see CaptureRequest\#CONTROL_AE_MODE
  static const CONTROL_AE_MODE_ON_AUTO_FLASH = 2;

  /// from: static public final int CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE
  ///
  /// Like ON_AUTO_FLASH, but with automatic red eye
  /// reduction.
  ///
  /// If deemed necessary by the camera device, a red eye
  /// reduction flash will fire during the precapture
  /// sequence.
  ///
  ///@see CaptureRequest\#CONTROL_AE_MODE
  static const CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE = 4;

  /// from: static public final int CONTROL_AE_MODE_ON_EXTERNAL_FLASH
  ///
  /// An external flash has been turned on.
  ///
  /// It informs the camera device that an external flash has been turned on, and that
  /// metering (and continuous focus if active) should be quickly recaculated to account
  /// for the external flash. Otherwise, this mode acts like ON.
  ///
  /// When the external flash is turned off, AE mode should be changed to one of the
  /// other available AE modes.
  ///
  /// If the camera device supports AE external flash mode, CaptureResult\#CONTROL_AE_STATE android.control.aeState must
  /// be FLASH_REQUIRED after the camera device finishes AE scan and it's too dark without
  /// flash.
  ///
  ///@see CaptureResult\#CONTROL_AE_STATE
  ///@see CaptureRequest\#CONTROL_AE_MODE
  static const CONTROL_AE_MODE_ON_EXTERNAL_FLASH = 5;

  /// from: static public final int CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL
  ///
  /// The camera device will cancel any currently active or completed
  /// precapture metering sequence, the auto-exposure routine will return to its
  /// initial state.
  ///
  ///@see CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER
  static const CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL = 2;

  /// from: static public final int CONTROL_AE_PRECAPTURE_TRIGGER_IDLE
  ///
  /// The trigger is idle.
  ///
  ///@see CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER
  static const CONTROL_AE_PRECAPTURE_TRIGGER_IDLE = 0;

  /// from: static public final int CONTROL_AE_PRECAPTURE_TRIGGER_START
  ///
  /// The precapture metering sequence will be started
  /// by the camera device.
  ///
  /// The exact effect of the precapture trigger depends on
  /// the current AE mode and state.
  ///
  ///@see CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER
  static const CONTROL_AE_PRECAPTURE_TRIGGER_START = 1;

  /// from: static public final int CONTROL_AE_STATE_CONVERGED
  ///
  /// AE has a good set of control values for the
  /// current scene.
  ///
  ///@see CaptureResult\#CONTROL_AE_STATE
  static const CONTROL_AE_STATE_CONVERGED = 2;

  /// from: static public final int CONTROL_AE_STATE_FLASH_REQUIRED
  ///
  /// AE has a good set of control values, but flash
  /// needs to be fired for good quality still
  /// capture.
  ///
  ///@see CaptureResult\#CONTROL_AE_STATE
  static const CONTROL_AE_STATE_FLASH_REQUIRED = 4;

  /// from: static public final int CONTROL_AE_STATE_INACTIVE
  ///
  /// AE is off or recently reset.
  ///
  /// When a camera device is opened, it starts in
  /// this state. This is a transient state, the camera device may skip reporting
  /// this state in capture result.
  ///
  ///@see CaptureResult\#CONTROL_AE_STATE
  static const CONTROL_AE_STATE_INACTIVE = 0;

  /// from: static public final int CONTROL_AE_STATE_LOCKED
  ///
  /// AE has been locked.
  ///
  ///@see CaptureResult\#CONTROL_AE_STATE
  static const CONTROL_AE_STATE_LOCKED = 3;

  /// from: static public final int CONTROL_AE_STATE_PRECAPTURE
  ///
  /// AE has been asked to do a precapture sequence
  /// and is currently executing it.
  ///
  /// Precapture can be triggered through setting
  /// CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger to START. Currently
  /// active and completed (if it causes camera device internal AE lock) precapture
  /// metering sequence can be canceled through setting
  /// CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger to CANCEL.
  ///
  /// Once PRECAPTURE completes, AE will transition to CONVERGED
  /// or FLASH_REQUIRED as appropriate. This is a transient
  /// state, the camera device may skip reporting this state in
  /// capture result.
  ///
  ///@see CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER
  ///@see CaptureResult\#CONTROL_AE_STATE
  static const CONTROL_AE_STATE_PRECAPTURE = 5;

  /// from: static public final int CONTROL_AE_STATE_SEARCHING
  ///
  /// AE doesn't yet have a good set of control values
  /// for the current scene.
  ///
  /// This is a transient state, the camera device may skip
  /// reporting this state in capture result.
  ///
  ///@see CaptureResult\#CONTROL_AE_STATE
  static const CONTROL_AE_STATE_SEARCHING = 1;

  /// from: static public final int CONTROL_AF_MODE_AUTO
  ///
  /// Basic automatic focus mode.
  ///
  /// In this mode, the lens does not move unless
  /// the autofocus trigger action is called. When that trigger
  /// is activated, AF will transition to ACTIVE_SCAN, then to
  /// the outcome of the scan (FOCUSED or NOT_FOCUSED).
  ///
  /// Always supported if lens is not fixed focus.
  ///
  /// Use CameraCharacteristics\#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance to determine if lens
  /// is fixed-focus.
  ///
  /// Triggering AF_CANCEL resets the lens position to default,
  /// and sets the AF state to INACTIVE.
  ///
  ///@see CameraCharacteristics\#LENS_INFO_MINIMUM_FOCUS_DISTANCE
  ///@see CaptureRequest\#CONTROL_AF_MODE
  static const CONTROL_AF_MODE_AUTO = 1;

  /// from: static public final int CONTROL_AF_MODE_CONTINUOUS_PICTURE
  ///
  /// In this mode, the AF algorithm modifies the lens
  /// position continually to attempt to provide a
  /// constantly-in-focus image stream.
  ///
  /// The focusing behavior should be suitable for still image
  /// capture; typically this means focusing as fast as
  /// possible. When the AF trigger is not involved, the AF
  /// algorithm should start in INACTIVE state, and then
  /// transition into PASSIVE_SCAN and PASSIVE_FOCUSED states as
  /// appropriate as it attempts to maintain focus. When the AF
  /// trigger is activated, the algorithm should finish its
  /// PASSIVE_SCAN if active, and then transition into
  /// AF_FOCUSED or AF_NOT_FOCUSED as appropriate, and lock the
  /// lens position until a cancel AF trigger is received.
  ///
  /// When the AF cancel trigger is activated, the algorithm
  /// should transition back to INACTIVE and then act as if it
  /// has just been started.
  ///
  ///@see CaptureRequest\#CONTROL_AF_MODE
  static const CONTROL_AF_MODE_CONTINUOUS_PICTURE = 4;

  /// from: static public final int CONTROL_AF_MODE_CONTINUOUS_VIDEO
  ///
  /// In this mode, the AF algorithm modifies the lens
  /// position continually to attempt to provide a
  /// constantly-in-focus image stream.
  ///
  /// The focusing behavior should be suitable for good quality
  /// video recording; typically this means slower focus
  /// movement and no overshoots. When the AF trigger is not
  /// involved, the AF algorithm should start in INACTIVE state,
  /// and then transition into PASSIVE_SCAN and PASSIVE_FOCUSED
  /// states as appropriate. When the AF trigger is activated,
  /// the algorithm should immediately transition into
  /// AF_FOCUSED or AF_NOT_FOCUSED as appropriate, and lock the
  /// lens position until a cancel AF trigger is received.
  ///
  /// Once cancel is received, the algorithm should transition
  /// back to INACTIVE and resume passive scan. Note that this
  /// behavior is not identical to CONTINUOUS_PICTURE, since an
  /// ongoing PASSIVE_SCAN must immediately be
  /// canceled.
  ///
  ///@see CaptureRequest\#CONTROL_AF_MODE
  static const CONTROL_AF_MODE_CONTINUOUS_VIDEO = 3;

  /// from: static public final int CONTROL_AF_MODE_EDOF
  ///
  /// Extended depth of field (digital focus) mode.
  ///
  /// The camera device will produce images with an extended
  /// depth of field automatically; no special focusing
  /// operations need to be done before taking a picture.
  ///
  /// AF triggers are ignored, and the AF state will always be
  /// INACTIVE.
  ///
  ///@see CaptureRequest\#CONTROL_AF_MODE
  static const CONTROL_AF_MODE_EDOF = 5;

  /// from: static public final int CONTROL_AF_MODE_MACRO
  ///
  /// Close-up focusing mode.
  ///
  /// In this mode, the lens does not move unless the
  /// autofocus trigger action is called. When that trigger is
  /// activated, AF will transition to ACTIVE_SCAN, then to
  /// the outcome of the scan (FOCUSED or NOT_FOCUSED). This
  /// mode is optimized for focusing on objects very close to
  /// the camera.
  ///
  /// When that trigger is activated, AF will transition to
  /// ACTIVE_SCAN, then to the outcome of the scan (FOCUSED or
  /// NOT_FOCUSED). Triggering cancel AF resets the lens
  /// position to default, and sets the AF state to
  /// INACTIVE.
  ///
  ///@see CaptureRequest\#CONTROL_AF_MODE
  static const CONTROL_AF_MODE_MACRO = 2;

  /// from: static public final int CONTROL_AF_MODE_OFF
  ///
  /// The auto-focus routine does not control the lens;
  /// CaptureRequest\#LENS_FOCUS_DISTANCE android.lens.focusDistance is controlled by the
  /// application.
  ///
  ///@see CaptureRequest\#LENS_FOCUS_DISTANCE
  ///@see CaptureRequest\#CONTROL_AF_MODE
  static const CONTROL_AF_MODE_OFF = 0;

  /// from: static public final int CONTROL_AF_SCENE_CHANGE_DETECTED
  ///
  /// Scene change is detected within the AF region(s).
  ///
  ///@see CaptureResult\#CONTROL_AF_SCENE_CHANGE
  static const CONTROL_AF_SCENE_CHANGE_DETECTED = 1;

  /// from: static public final int CONTROL_AF_SCENE_CHANGE_NOT_DETECTED
  ///
  /// Scene change is not detected within the AF region(s).
  ///
  ///@see CaptureResult\#CONTROL_AF_SCENE_CHANGE
  static const CONTROL_AF_SCENE_CHANGE_NOT_DETECTED = 0;

  /// from: static public final int CONTROL_AF_STATE_ACTIVE_SCAN
  ///
  /// AF is performing an AF scan because it was
  /// triggered by AF trigger.
  ///
  /// Only used by AUTO or MACRO AF modes. This is a transient
  /// state, the camera device may skip reporting this state in
  /// capture result.
  ///
  ///@see CaptureResult\#CONTROL_AF_STATE
  static const CONTROL_AF_STATE_ACTIVE_SCAN = 3;

  /// from: static public final int CONTROL_AF_STATE_FOCUSED_LOCKED
  ///
  /// AF believes it is focused correctly and has locked
  /// focus.
  ///
  /// This state is reached only after an explicit START AF trigger has been
  /// sent (CaptureRequest\#CONTROL_AF_TRIGGER android.control.afTrigger), when good focus has been obtained.
  ///
  /// The lens will remain stationary until the AF mode (CaptureRequest\#CONTROL_AF_MODE android.control.afMode) is changed or
  /// a new AF trigger is sent to the camera device (CaptureRequest\#CONTROL_AF_TRIGGER android.control.afTrigger).
  ///
  ///@see CaptureRequest\#CONTROL_AF_MODE
  ///@see CaptureRequest\#CONTROL_AF_TRIGGER
  ///@see CaptureResult\#CONTROL_AF_STATE
  static const CONTROL_AF_STATE_FOCUSED_LOCKED = 4;

  /// from: static public final int CONTROL_AF_STATE_INACTIVE
  ///
  /// AF is off or has not yet tried to scan/been asked
  /// to scan.
  ///
  /// When a camera device is opened, it starts in this
  /// state. This is a transient state, the camera device may
  /// skip reporting this state in capture
  /// result.
  ///
  ///@see CaptureResult\#CONTROL_AF_STATE
  static const CONTROL_AF_STATE_INACTIVE = 0;

  /// from: static public final int CONTROL_AF_STATE_NOT_FOCUSED_LOCKED
  ///
  /// AF has failed to focus successfully and has locked
  /// focus.
  ///
  /// This state is reached only after an explicit START AF trigger has been
  /// sent (CaptureRequest\#CONTROL_AF_TRIGGER android.control.afTrigger), when good focus cannot be obtained.
  ///
  /// The lens will remain stationary until the AF mode (CaptureRequest\#CONTROL_AF_MODE android.control.afMode) is changed or
  /// a new AF trigger is sent to the camera device (CaptureRequest\#CONTROL_AF_TRIGGER android.control.afTrigger).
  ///
  ///@see CaptureRequest\#CONTROL_AF_MODE
  ///@see CaptureRequest\#CONTROL_AF_TRIGGER
  ///@see CaptureResult\#CONTROL_AF_STATE
  static const CONTROL_AF_STATE_NOT_FOCUSED_LOCKED = 5;

  /// from: static public final int CONTROL_AF_STATE_PASSIVE_FOCUSED
  ///
  /// AF currently believes it is in focus, but may
  /// restart scanning at any time.
  ///
  /// Only used by CONTINUOUS_* AF modes. This is a transient
  /// state, the camera device may skip reporting this state in
  /// capture result.
  ///
  ///@see CaptureResult\#CONTROL_AF_STATE
  static const CONTROL_AF_STATE_PASSIVE_FOCUSED = 2;

  /// from: static public final int CONTROL_AF_STATE_PASSIVE_SCAN
  ///
  /// AF is currently performing an AF scan initiated the
  /// camera device in a continuous autofocus mode.
  ///
  /// Only used by CONTINUOUS_* AF modes. This is a transient
  /// state, the camera device may skip reporting this state in
  /// capture result.
  ///
  ///@see CaptureResult\#CONTROL_AF_STATE
  static const CONTROL_AF_STATE_PASSIVE_SCAN = 1;

  /// from: static public final int CONTROL_AF_STATE_PASSIVE_UNFOCUSED
  ///
  /// AF finished a passive scan without finding focus,
  /// and may restart scanning at any time.
  ///
  /// Only used by CONTINUOUS_* AF modes. This is a transient state, the camera
  /// device may skip reporting this state in capture result.
  ///
  /// LEGACY camera devices do not support this state. When a passive
  /// scan has finished, it will always go to PASSIVE_FOCUSED.
  ///
  ///@see CaptureResult\#CONTROL_AF_STATE
  static const CONTROL_AF_STATE_PASSIVE_UNFOCUSED = 6;

  /// from: static public final int CONTROL_AF_TRIGGER_CANCEL
  ///
  /// Autofocus will return to its initial
  /// state, and cancel any currently active trigger.
  ///
  ///@see CaptureRequest\#CONTROL_AF_TRIGGER
  static const CONTROL_AF_TRIGGER_CANCEL = 2;

  /// from: static public final int CONTROL_AF_TRIGGER_IDLE
  ///
  /// The trigger is idle.
  ///
  ///@see CaptureRequest\#CONTROL_AF_TRIGGER
  static const CONTROL_AF_TRIGGER_IDLE = 0;

  /// from: static public final int CONTROL_AF_TRIGGER_START
  ///
  /// Autofocus will trigger now.
  ///
  ///@see CaptureRequest\#CONTROL_AF_TRIGGER
  static const CONTROL_AF_TRIGGER_START = 1;

  /// from: static public final int CONTROL_AWB_MODE_AUTO
  ///
  /// The camera device's auto-white balance routine is active.
  ///
  /// The application's values for CaptureRequest\#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform
  /// and CaptureRequest\#COLOR_CORRECTION_GAINS android.colorCorrection.gains are ignored.
  /// For devices that support the MANUAL_POST_PROCESSING capability, the
  /// values used by the camera device for the transform and gains
  /// will be available in the capture result for this request.
  ///
  ///@see CaptureRequest\#COLOR_CORRECTION_GAINS
  ///@see CaptureRequest\#COLOR_CORRECTION_TRANSFORM
  ///@see CaptureRequest\#CONTROL_AWB_MODE
  static const CONTROL_AWB_MODE_AUTO = 1;

  /// from: static public final int CONTROL_AWB_MODE_CLOUDY_DAYLIGHT
  ///
  /// The camera device's auto-white balance routine is disabled;
  /// the camera device uses cloudy daylight light as the assumed scene
  /// illumination for white balance.
  ///
  /// The application's values for CaptureRequest\#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform
  /// and CaptureRequest\#COLOR_CORRECTION_GAINS android.colorCorrection.gains are ignored.
  /// For devices that support the MANUAL_POST_PROCESSING capability, the
  /// values used by the camera device for the transform and gains
  /// will be available in the capture result for this request.
  ///
  ///@see CaptureRequest\#COLOR_CORRECTION_GAINS
  ///@see CaptureRequest\#COLOR_CORRECTION_TRANSFORM
  ///@see CaptureRequest\#CONTROL_AWB_MODE
  static const CONTROL_AWB_MODE_CLOUDY_DAYLIGHT = 6;

  /// from: static public final int CONTROL_AWB_MODE_DAYLIGHT
  ///
  /// The camera device's auto-white balance routine is disabled;
  /// the camera device uses daylight light as the assumed scene
  /// illumination for white balance.
  ///
  /// While the exact white balance transforms are up to the
  /// camera device, they will approximately match the CIE
  /// standard illuminant D65.
  ///
  /// The application's values for CaptureRequest\#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform
  /// and CaptureRequest\#COLOR_CORRECTION_GAINS android.colorCorrection.gains are ignored.
  /// For devices that support the MANUAL_POST_PROCESSING capability, the
  /// values used by the camera device for the transform and gains
  /// will be available in the capture result for this request.
  ///
  ///@see CaptureRequest\#COLOR_CORRECTION_GAINS
  ///@see CaptureRequest\#COLOR_CORRECTION_TRANSFORM
  ///@see CaptureRequest\#CONTROL_AWB_MODE
  static const CONTROL_AWB_MODE_DAYLIGHT = 5;

  /// from: static public final int CONTROL_AWB_MODE_FLUORESCENT
  ///
  /// The camera device's auto-white balance routine is disabled;
  /// the camera device uses fluorescent light as the assumed scene
  /// illumination for white balance.
  ///
  /// While the exact white balance transforms are up to the
  /// camera device, they will approximately match the CIE
  /// standard illuminant F2.
  ///
  /// The application's values for CaptureRequest\#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform
  /// and CaptureRequest\#COLOR_CORRECTION_GAINS android.colorCorrection.gains are ignored.
  /// For devices that support the MANUAL_POST_PROCESSING capability, the
  /// values used by the camera device for the transform and gains
  /// will be available in the capture result for this request.
  ///
  ///@see CaptureRequest\#COLOR_CORRECTION_GAINS
  ///@see CaptureRequest\#COLOR_CORRECTION_TRANSFORM
  ///@see CaptureRequest\#CONTROL_AWB_MODE
  static const CONTROL_AWB_MODE_FLUORESCENT = 3;

  /// from: static public final int CONTROL_AWB_MODE_INCANDESCENT
  ///
  /// The camera device's auto-white balance routine is disabled;
  /// the camera device uses incandescent light as the assumed scene
  /// illumination for white balance.
  ///
  /// While the exact white balance transforms are up to the
  /// camera device, they will approximately match the CIE
  /// standard illuminant A.
  ///
  /// The application's values for CaptureRequest\#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform
  /// and CaptureRequest\#COLOR_CORRECTION_GAINS android.colorCorrection.gains are ignored.
  /// For devices that support the MANUAL_POST_PROCESSING capability, the
  /// values used by the camera device for the transform and gains
  /// will be available in the capture result for this request.
  ///
  ///@see CaptureRequest\#COLOR_CORRECTION_GAINS
  ///@see CaptureRequest\#COLOR_CORRECTION_TRANSFORM
  ///@see CaptureRequest\#CONTROL_AWB_MODE
  static const CONTROL_AWB_MODE_INCANDESCENT = 2;

  /// from: static public final int CONTROL_AWB_MODE_OFF
  ///
  /// The camera device's auto-white balance routine is disabled.
  ///
  /// The application-selected color transform matrix
  /// (CaptureRequest\#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform) and gains
  /// (CaptureRequest\#COLOR_CORRECTION_GAINS android.colorCorrection.gains) are used by the camera
  /// device for manual white balance control.
  ///
  ///@see CaptureRequest\#COLOR_CORRECTION_GAINS
  ///@see CaptureRequest\#COLOR_CORRECTION_TRANSFORM
  ///@see CaptureRequest\#CONTROL_AWB_MODE
  static const CONTROL_AWB_MODE_OFF = 0;

  /// from: static public final int CONTROL_AWB_MODE_SHADE
  ///
  /// The camera device's auto-white balance routine is disabled;
  /// the camera device uses shade light as the assumed scene
  /// illumination for white balance.
  ///
  /// The application's values for CaptureRequest\#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform
  /// and CaptureRequest\#COLOR_CORRECTION_GAINS android.colorCorrection.gains are ignored.
  /// For devices that support the MANUAL_POST_PROCESSING capability, the
  /// values used by the camera device for the transform and gains
  /// will be available in the capture result for this request.
  ///
  ///@see CaptureRequest\#COLOR_CORRECTION_GAINS
  ///@see CaptureRequest\#COLOR_CORRECTION_TRANSFORM
  ///@see CaptureRequest\#CONTROL_AWB_MODE
  static const CONTROL_AWB_MODE_SHADE = 8;

  /// from: static public final int CONTROL_AWB_MODE_TWILIGHT
  ///
  /// The camera device's auto-white balance routine is disabled;
  /// the camera device uses twilight light as the assumed scene
  /// illumination for white balance.
  ///
  /// The application's values for CaptureRequest\#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform
  /// and CaptureRequest\#COLOR_CORRECTION_GAINS android.colorCorrection.gains are ignored.
  /// For devices that support the MANUAL_POST_PROCESSING capability, the
  /// values used by the camera device for the transform and gains
  /// will be available in the capture result for this request.
  ///
  ///@see CaptureRequest\#COLOR_CORRECTION_GAINS
  ///@see CaptureRequest\#COLOR_CORRECTION_TRANSFORM
  ///@see CaptureRequest\#CONTROL_AWB_MODE
  static const CONTROL_AWB_MODE_TWILIGHT = 7;

  /// from: static public final int CONTROL_AWB_MODE_WARM_FLUORESCENT
  ///
  /// The camera device's auto-white balance routine is disabled;
  /// the camera device uses warm fluorescent light as the assumed scene
  /// illumination for white balance.
  ///
  /// While the exact white balance transforms are up to the
  /// camera device, they will approximately match the CIE
  /// standard illuminant F4.
  ///
  /// The application's values for CaptureRequest\#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform
  /// and CaptureRequest\#COLOR_CORRECTION_GAINS android.colorCorrection.gains are ignored.
  /// For devices that support the MANUAL_POST_PROCESSING capability, the
  /// values used by the camera device for the transform and gains
  /// will be available in the capture result for this request.
  ///
  ///@see CaptureRequest\#COLOR_CORRECTION_GAINS
  ///@see CaptureRequest\#COLOR_CORRECTION_TRANSFORM
  ///@see CaptureRequest\#CONTROL_AWB_MODE
  static const CONTROL_AWB_MODE_WARM_FLUORESCENT = 4;

  /// from: static public final int CONTROL_AWB_STATE_CONVERGED
  ///
  /// AWB has a good set of control values for the
  /// current scene.
  ///
  ///@see CaptureResult\#CONTROL_AWB_STATE
  static const CONTROL_AWB_STATE_CONVERGED = 2;

  /// from: static public final int CONTROL_AWB_STATE_INACTIVE
  ///
  /// AWB is not in auto mode, or has not yet started metering.
  ///
  /// When a camera device is opened, it starts in this
  /// state. This is a transient state, the camera device may
  /// skip reporting this state in capture
  /// result.
  ///
  ///@see CaptureResult\#CONTROL_AWB_STATE
  static const CONTROL_AWB_STATE_INACTIVE = 0;

  /// from: static public final int CONTROL_AWB_STATE_LOCKED
  ///
  /// AWB has been locked.
  ///
  ///@see CaptureResult\#CONTROL_AWB_STATE
  static const CONTROL_AWB_STATE_LOCKED = 3;

  /// from: static public final int CONTROL_AWB_STATE_SEARCHING
  ///
  /// AWB doesn't yet have a good set of control
  /// values for the current scene.
  ///
  /// This is a transient state, the camera device
  /// may skip reporting this state in capture result.
  ///
  ///@see CaptureResult\#CONTROL_AWB_STATE
  static const CONTROL_AWB_STATE_SEARCHING = 1;

  /// from: static public final int CONTROL_CAPTURE_INTENT_CUSTOM
  ///
  /// The goal of this request doesn't fall into the other
  /// categories. The camera device will default to preview-like
  /// behavior.
  ///
  ///@see CaptureRequest\#CONTROL_CAPTURE_INTENT
  static const CONTROL_CAPTURE_INTENT_CUSTOM = 0;

  /// from: static public final int CONTROL_CAPTURE_INTENT_MANUAL
  ///
  /// This request is for manual capture use case where
  /// the applications want to directly control the capture parameters.
  ///
  /// For example, the application may wish to manually control
  /// CaptureRequest\#SENSOR_EXPOSURE_TIME android.sensor.exposureTime, CaptureRequest\#SENSOR_SENSITIVITY android.sensor.sensitivity, etc.
  ///
  ///@see CaptureRequest\#SENSOR_EXPOSURE_TIME
  ///@see CaptureRequest\#SENSOR_SENSITIVITY
  ///@see CaptureRequest\#CONTROL_CAPTURE_INTENT
  static const CONTROL_CAPTURE_INTENT_MANUAL = 6;

  /// from: static public final int CONTROL_CAPTURE_INTENT_MOTION_TRACKING
  ///
  /// This request is for a motion tracking use case, where
  /// the application will use camera and inertial sensor data to
  /// locate and track objects in the world.
  ///
  /// The camera device auto-exposure routine will limit the exposure time
  /// of the camera to no more than 20 milliseconds, to minimize motion blur.
  ///
  ///@see CaptureRequest\#CONTROL_CAPTURE_INTENT
  static const CONTROL_CAPTURE_INTENT_MOTION_TRACKING = 7;

  /// from: static public final int CONTROL_CAPTURE_INTENT_PREVIEW
  ///
  /// This request is for a preview-like use case.
  ///
  /// The precapture trigger may be used to start off a metering
  /// w/flash sequence.
  ///
  ///@see CaptureRequest\#CONTROL_CAPTURE_INTENT
  static const CONTROL_CAPTURE_INTENT_PREVIEW = 1;

  /// from: static public final int CONTROL_CAPTURE_INTENT_STILL_CAPTURE
  ///
  /// This request is for a still capture-type
  /// use case.
  ///
  /// If the flash unit is under automatic control, it may fire as needed.
  ///
  ///@see CaptureRequest\#CONTROL_CAPTURE_INTENT
  static const CONTROL_CAPTURE_INTENT_STILL_CAPTURE = 2;

  /// from: static public final int CONTROL_CAPTURE_INTENT_VIDEO_RECORD
  ///
  /// This request is for a video recording
  /// use case.
  ///
  ///@see CaptureRequest\#CONTROL_CAPTURE_INTENT
  static const CONTROL_CAPTURE_INTENT_VIDEO_RECORD = 3;

  /// from: static public final int CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT
  ///
  /// This request is for a video snapshot (still
  /// image while recording video) use case.
  ///
  /// The camera device should take the highest-quality image
  /// possible (given the other settings) without disrupting the
  /// frame rate of video recording.
  ///
  ///@see CaptureRequest\#CONTROL_CAPTURE_INTENT
  static const CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT = 4;

  /// from: static public final int CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG
  ///
  /// This request is for a ZSL usecase; the
  /// application will stream full-resolution images and
  /// reprocess one or several later for a final
  /// capture.
  ///
  ///@see CaptureRequest\#CONTROL_CAPTURE_INTENT
  static const CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG = 5;

  /// from: static public final int CONTROL_EFFECT_MODE_AQUA
  ///
  /// An "aqua" effect where a blue hue is added to the image.
  ///
  ///@see CaptureRequest\#CONTROL_EFFECT_MODE
  static const CONTROL_EFFECT_MODE_AQUA = 8;

  /// from: static public final int CONTROL_EFFECT_MODE_BLACKBOARD
  ///
  /// A "blackboard" effect where the image is typically displayed
  /// as regions of black, with white or grey details.
  ///
  ///@see CaptureRequest\#CONTROL_EFFECT_MODE
  static const CONTROL_EFFECT_MODE_BLACKBOARD = 7;

  /// from: static public final int CONTROL_EFFECT_MODE_MONO
  ///
  /// A "monocolor" effect where the image is mapped into
  /// a single color.
  ///
  /// This will typically be grayscale.
  ///
  ///@see CaptureRequest\#CONTROL_EFFECT_MODE
  static const CONTROL_EFFECT_MODE_MONO = 1;

  /// from: static public final int CONTROL_EFFECT_MODE_NEGATIVE
  ///
  /// A "photo-negative" effect where the image's colors
  /// are inverted.
  ///
  ///@see CaptureRequest\#CONTROL_EFFECT_MODE
  static const CONTROL_EFFECT_MODE_NEGATIVE = 2;

  /// from: static public final int CONTROL_EFFECT_MODE_OFF
  ///
  /// No color effect will be applied.
  ///
  ///@see CaptureRequest\#CONTROL_EFFECT_MODE
  static const CONTROL_EFFECT_MODE_OFF = 0;

  /// from: static public final int CONTROL_EFFECT_MODE_POSTERIZE
  ///
  /// A "posterization" effect where the image uses
  /// discrete regions of tone rather than a continuous
  /// gradient of tones.
  ///
  ///@see CaptureRequest\#CONTROL_EFFECT_MODE
  static const CONTROL_EFFECT_MODE_POSTERIZE = 5;

  /// from: static public final int CONTROL_EFFECT_MODE_SEPIA
  ///
  /// A "sepia" effect where the image is mapped into warm
  /// gray, red, and brown tones.
  ///
  ///@see CaptureRequest\#CONTROL_EFFECT_MODE
  static const CONTROL_EFFECT_MODE_SEPIA = 4;

  /// from: static public final int CONTROL_EFFECT_MODE_SOLARIZE
  ///
  /// A "solarisation" effect (Sabattier effect) where the
  /// image is wholly or partially reversed in
  /// tone.
  ///
  ///@see CaptureRequest\#CONTROL_EFFECT_MODE
  static const CONTROL_EFFECT_MODE_SOLARIZE = 3;

  /// from: static public final int CONTROL_EFFECT_MODE_WHITEBOARD
  ///
  /// A "whiteboard" effect where the image is typically displayed
  /// as regions of white, with black or grey details.
  ///
  ///@see CaptureRequest\#CONTROL_EFFECT_MODE
  static const CONTROL_EFFECT_MODE_WHITEBOARD = 6;

  /// from: static public final int CONTROL_MODE_AUTO
  ///
  /// Use settings for each individual 3A routine.
  ///
  /// Manual control of capture parameters is disabled. All
  /// controls in android.control.* besides sceneMode take
  /// effect.
  ///
  ///@see CaptureRequest\#CONTROL_MODE
  static const CONTROL_MODE_AUTO = 1;

  /// from: static public final int CONTROL_MODE_OFF
  ///
  /// Full application control of pipeline.
  ///
  /// All control by the device's metering and focusing (3A)
  /// routines is disabled, and no other settings in
  /// android.control.* have any effect, except that
  /// CaptureRequest\#CONTROL_CAPTURE_INTENT android.control.captureIntent may be used by the camera
  /// device to select post-processing values for processing
  /// blocks that do not allow for manual control, or are not
  /// exposed by the camera API.
  ///
  /// However, the camera device's 3A routines may continue to
  /// collect statistics and update their internal state so that
  /// when control is switched to AUTO mode, good control values
  /// can be immediately applied.
  ///
  ///@see CaptureRequest\#CONTROL_CAPTURE_INTENT
  ///@see CaptureRequest\#CONTROL_MODE
  static const CONTROL_MODE_OFF = 0;

  /// from: static public final int CONTROL_MODE_OFF_KEEP_STATE
  ///
  /// Same as OFF mode, except that this capture will not be
  /// used by camera device background auto-exposure, auto-white balance and
  /// auto-focus algorithms (3A) to update their statistics.
  ///
  /// Specifically, the 3A routines are locked to the last
  /// values set from a request with AUTO, OFF, or
  /// USE_SCENE_MODE, and any statistics or state updates
  /// collected from manual captures with OFF_KEEP_STATE will be
  /// discarded by the camera device.
  ///
  ///@see CaptureRequest\#CONTROL_MODE
  static const CONTROL_MODE_OFF_KEEP_STATE = 3;

  /// from: static public final int CONTROL_MODE_USE_SCENE_MODE
  ///
  /// Use a specific scene mode.
  ///
  /// Enabling this disables control.aeMode, control.awbMode and
  /// control.afMode controls; the camera device will ignore
  /// those settings while USE_SCENE_MODE is active (except for
  /// FACE_PRIORITY scene mode). Other control entries are still active.
  /// This setting can only be used if scene mode is supported (i.e.
  /// CameraCharacteristics\#CONTROL_AVAILABLE_SCENE_MODES android.control.availableSceneModes
  /// contain some modes other than DISABLED).
  ///
  ///@see CameraCharacteristics\#CONTROL_AVAILABLE_SCENE_MODES
  ///@see CaptureRequest\#CONTROL_MODE
  static const CONTROL_MODE_USE_SCENE_MODE = 2;

  /// from: static public final int CONTROL_SCENE_MODE_ACTION
  ///
  /// Optimized for photos of quickly moving objects.
  ///
  /// Similar to SPORTS.
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_ACTION = 2;

  /// from: static public final int CONTROL_SCENE_MODE_BARCODE
  ///
  /// Optimized for accurately capturing a photo of barcode
  /// for use by camera applications that wish to read the
  /// barcode value.
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_BARCODE = 16;

  /// from: static public final int CONTROL_SCENE_MODE_BEACH
  ///
  /// Optimized for bright, outdoor beach settings.
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_BEACH = 8;

  /// from: static public final int CONTROL_SCENE_MODE_CANDLELIGHT
  ///
  /// Optimized for dim settings where the main light source
  /// is a flame.
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_CANDLELIGHT = 15;

  /// from: static public final int CONTROL_SCENE_MODE_DISABLED
  ///
  /// Indicates that no scene modes are set for a given capture request.
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_DISABLED = 0;

  /// from: static public final int CONTROL_SCENE_MODE_FACE_PRIORITY
  ///
  /// If face detection support exists, use face
  /// detection data for auto-focus, auto-white balance, and
  /// auto-exposure routines.
  ///
  /// If face detection statistics are disabled
  /// (i.e. CaptureRequest\#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode is set to OFF),
  /// this should still operate correctly (but will not return
  /// face detection statistics to the framework).
  ///
  /// Unlike the other scene modes, CaptureRequest\#CONTROL_AE_MODE android.control.aeMode,
  /// CaptureRequest\#CONTROL_AWB_MODE android.control.awbMode, and CaptureRequest\#CONTROL_AF_MODE android.control.afMode
  /// remain active when FACE_PRIORITY is set.
  ///
  ///@see CaptureRequest\#CONTROL_AE_MODE
  ///@see CaptureRequest\#CONTROL_AF_MODE
  ///@see CaptureRequest\#CONTROL_AWB_MODE
  ///@see CaptureRequest\#STATISTICS_FACE_DETECT_MODE
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_FACE_PRIORITY = 1;

  /// from: static public final int CONTROL_SCENE_MODE_FIREWORKS
  ///
  /// Optimized for nighttime photos of fireworks.
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_FIREWORKS = 12;

  /// from: static public final int CONTROL_SCENE_MODE_HDR
  ///
  /// Turn on a device-specific high dynamic range (HDR) mode.
  ///
  /// In this scene mode, the camera device captures images
  /// that keep a larger range of scene illumination levels
  /// visible in the final image. For example, when taking a
  /// picture of a object in front of a bright window, both
  /// the object and the scene through the window may be
  /// visible when using HDR mode, while in normal AUTO mode,
  /// one or the other may be poorly exposed. As a tradeoff,
  /// HDR mode generally takes much longer to capture a single
  /// image, has no user control, and may have other artifacts
  /// depending on the HDR method used.
  ///
  /// Therefore, HDR captures operate at a much slower rate
  /// than regular captures.
  ///
  /// In this mode, on LIMITED or FULL devices, when a request
  /// is made with a CaptureRequest\#CONTROL_CAPTURE_INTENT android.control.captureIntent of
  /// STILL_CAPTURE, the camera device will capture an image
  /// using a high dynamic range capture technique.  On LEGACY
  /// devices, captures that target a JPEG-format output will
  /// be captured with HDR, and the capture intent is not
  /// relevant.
  ///
  /// The HDR capture may involve the device capturing a burst
  /// of images internally and combining them into one, or it
  /// may involve the device using specialized high dynamic
  /// range capture hardware. In all cases, a single image is
  /// produced in response to a capture request submitted
  /// while in HDR mode.
  ///
  /// Since substantial post-processing is generally needed to
  /// produce an HDR image, only YUV, PRIVATE, and JPEG
  /// outputs are supported for LIMITED/FULL device HDR
  /// captures, and only JPEG outputs are supported for LEGACY
  /// HDR captures. Using a RAW output for HDR capture is not
  /// supported.
  ///
  /// Some devices may also support always-on HDR, which
  /// applies HDR processing at full frame rate.  For these
  /// devices, intents other than STILL_CAPTURE will also
  /// produce an HDR output with no frame rate impact compared
  /// to normal operation, though the quality may be lower
  /// than for STILL_CAPTURE intents.
  ///
  /// If SCENE_MODE_HDR is used with unsupported output types
  /// or capture intents, the images captured will be as if
  /// the SCENE_MODE was not enabled at all.
  ///
  ///@see CaptureRequest\#CONTROL_CAPTURE_INTENT
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_HDR = 18;

  /// from: static public final int CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO
  ///
  /// This is deprecated, please use android.hardware.camera2.CameraDevice\#createConstrainedHighSpeedCaptureSession
  /// and android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession\#createHighSpeedRequestList
  /// for high speed video recording.
  ///
  /// Optimized for high speed video recording (frame rate &gt;=60fps) use case.
  ///
  /// The supported high speed video sizes and fps ranges are specified in
  /// android.control.availableHighSpeedVideoConfigurations. To get desired
  /// output frame rates, the application is only allowed to select video size
  /// and fps range combinations listed in this static metadata. The fps range
  /// can be control via CaptureRequest\#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange.
  ///
  /// In this mode, the camera device will override aeMode, awbMode, and afMode to
  /// ON, ON, and CONTINUOUS_VIDEO, respectively. All post-processing block mode
  /// controls will be overridden to be FAST. Therefore, no manual control of capture
  /// and post-processing parameters is possible. All other controls operate the
  /// same as when CaptureRequest\#CONTROL_MODE android.control.mode == AUTO. This means that all other
  /// android.control.* fields continue to work, such as
  ///
  /// <ul>
  /// <li>CaptureRequest\#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange</li>
  /// <li>CaptureRequest\#CONTROL_AE_EXPOSURE_COMPENSATION android.control.aeExposureCompensation</li>
  /// <li>CaptureRequest\#CONTROL_AE_LOCK android.control.aeLock</li>
  /// <li>CaptureRequest\#CONTROL_AWB_LOCK android.control.awbLock</li>
  /// <li>CaptureRequest\#CONTROL_EFFECT_MODE android.control.effectMode</li>
  /// <li>CaptureRequest\#CONTROL_AE_REGIONS android.control.aeRegions</li>
  /// <li>CaptureRequest\#CONTROL_AF_REGIONS android.control.afRegions</li>
  /// <li>CaptureRequest\#CONTROL_AWB_REGIONS android.control.awbRegions</li>
  /// <li>CaptureRequest\#CONTROL_AF_TRIGGER android.control.afTrigger</li>
  /// <li>CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger</li>
  /// </ul>
  /// Outside of android.control.*, the following controls will work:
  ///
  /// <ul>
  /// <li>CaptureRequest\#FLASH_MODE android.flash.mode (automatic flash for still capture will not work since aeMode is ON)</li>
  /// <li>CaptureRequest\#LENS_OPTICAL_STABILIZATION_MODE android.lens.opticalStabilizationMode (if it is supported)</li>
  /// <li>CaptureRequest\#SCALER_CROP_REGION android.scaler.cropRegion</li>
  /// <li>CaptureRequest\#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode</li>
  /// </ul>
  /// For high speed recording use case, the actual maximum supported frame rate may
  /// be lower than what camera can output, depending on the destination Surfaces for
  /// the image data. For example, if the destination surface is from video encoder,
  /// the application need check if the video encoder is capable of supporting the
  /// high frame rate for a given video size, or it will end up with lower recording
  /// frame rate. If the destination surface is from preview window, the preview frame
  /// rate will be bounded by the screen refresh rate.
  ///
  /// The camera device will only support up to 2 output high speed streams
  /// (processed non-stalling format defined in android.request.maxNumOutputStreams)
  /// in this mode. This control will be effective only if all of below conditions are true:
  ///
  /// <ul>
  /// <li>The application created no more than maxNumHighSpeedStreams processed non-stalling
  /// format output streams, where maxNumHighSpeedStreams is calculated as
  /// min(2, android.request.maxNumOutputStreams[Processed (but not-stalling)]).</li>
  /// <li>The stream sizes are selected from the sizes reported by
  /// android.control.availableHighSpeedVideoConfigurations.</li>
  /// <li>No processed non-stalling or raw streams are configured.</li>
  /// </ul>
  /// When above conditions are NOT satistied, the controls of this mode and
  /// CaptureRequest\#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange will be ignored by the camera device,
  /// the camera device will fall back to CaptureRequest\#CONTROL_MODE android.control.mode <code>==</code> AUTO,
  /// and the returned capture result metadata will give the fps range choosen
  /// by the camera device.
  ///
  /// Switching into or out of this mode may trigger some camera ISP/sensor
  /// reconfigurations, which may introduce extra latency. It is recommended that
  /// the application avoids unnecessary scene mode switch as much as possible.
  ///
  ///@see CaptureRequest\#CONTROL_AE_EXPOSURE_COMPENSATION
  ///@see CaptureRequest\#CONTROL_AE_LOCK
  ///@see CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER
  ///@see CaptureRequest\#CONTROL_AE_REGIONS
  ///@see CaptureRequest\#CONTROL_AE_TARGET_FPS_RANGE
  ///@see CaptureRequest\#CONTROL_AF_REGIONS
  ///@see CaptureRequest\#CONTROL_AF_TRIGGER
  ///@see CaptureRequest\#CONTROL_AWB_LOCK
  ///@see CaptureRequest\#CONTROL_AWB_REGIONS
  ///@see CaptureRequest\#CONTROL_EFFECT_MODE
  ///@see CaptureRequest\#CONTROL_MODE
  ///@see CaptureRequest\#FLASH_MODE
  ///@see CaptureRequest\#LENS_OPTICAL_STABILIZATION_MODE
  ///@see CaptureRequest\#SCALER_CROP_REGION
  ///@see CaptureRequest\#STATISTICS_FACE_DETECT_MODE
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  ///@deprecated Please refer to this API documentation to find the alternatives
  static const CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO = 17;

  /// from: static public final int CONTROL_SCENE_MODE_LANDSCAPE
  ///
  /// Optimized for photos of distant macroscopic objects.
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_LANDSCAPE = 4;

  /// from: static public final int CONTROL_SCENE_MODE_NIGHT
  ///
  /// Optimized for low-light settings.
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_NIGHT = 5;

  /// from: static public final int CONTROL_SCENE_MODE_NIGHT_PORTRAIT
  ///
  /// Optimized for still photos of people in low-light
  /// settings.
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_NIGHT_PORTRAIT = 6;

  /// from: static public final int CONTROL_SCENE_MODE_PARTY
  ///
  /// Optimized for dim, indoor settings with multiple moving
  /// people.
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_PARTY = 14;

  /// from: static public final int CONTROL_SCENE_MODE_PORTRAIT
  ///
  /// Optimized for still photos of people.
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_PORTRAIT = 3;

  /// from: static public final int CONTROL_SCENE_MODE_SNOW
  ///
  /// Optimized for bright, outdoor settings containing snow.
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_SNOW = 9;

  /// from: static public final int CONTROL_SCENE_MODE_SPORTS
  ///
  /// Optimized for photos of quickly moving people.
  ///
  /// Similar to ACTION.
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_SPORTS = 13;

  /// from: static public final int CONTROL_SCENE_MODE_STEADYPHOTO
  ///
  /// Optimized to avoid blurry photos due to small amounts of
  /// device motion (for example: due to hand shake).
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_STEADYPHOTO = 11;

  /// from: static public final int CONTROL_SCENE_MODE_SUNSET
  ///
  /// Optimized for scenes of the setting sun.
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_SUNSET = 10;

  /// from: static public final int CONTROL_SCENE_MODE_THEATRE
  ///
  /// Optimized for dim, indoor settings where flash must
  /// remain off.
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  static const CONTROL_SCENE_MODE_THEATRE = 7;

  /// from: static public final int CONTROL_VIDEO_STABILIZATION_MODE_OFF
  ///
  /// Video stabilization is disabled.
  ///
  ///@see CaptureRequest\#CONTROL_VIDEO_STABILIZATION_MODE
  static const CONTROL_VIDEO_STABILIZATION_MODE_OFF = 0;

  /// from: static public final int CONTROL_VIDEO_STABILIZATION_MODE_ON
  ///
  /// Video stabilization is enabled.
  ///
  ///@see CaptureRequest\#CONTROL_VIDEO_STABILIZATION_MODE
  static const CONTROL_VIDEO_STABILIZATION_MODE_ON = 1;

  /// from: static public final int DISTORTION_CORRECTION_MODE_FAST
  ///
  /// Lens distortion correction is applied without reducing frame rate
  /// relative to sensor output. It may be the same as OFF if distortion correction would
  /// reduce frame rate relative to sensor.
  ///
  ///@see CaptureRequest\#DISTORTION_CORRECTION_MODE
  static const DISTORTION_CORRECTION_MODE_FAST = 1;

  /// from: static public final int DISTORTION_CORRECTION_MODE_HIGH_QUALITY
  ///
  /// High-quality distortion correction is applied, at the cost of
  /// possibly reduced frame rate relative to sensor output.
  ///
  ///@see CaptureRequest\#DISTORTION_CORRECTION_MODE
  static const DISTORTION_CORRECTION_MODE_HIGH_QUALITY = 2;

  /// from: static public final int DISTORTION_CORRECTION_MODE_OFF
  ///
  /// No distortion correction is applied.
  ///
  ///@see CaptureRequest\#DISTORTION_CORRECTION_MODE
  static const DISTORTION_CORRECTION_MODE_OFF = 0;

  /// from: static public final int EDGE_MODE_FAST
  ///
  /// Apply edge enhancement at a quality level that does not slow down frame rate
  /// relative to sensor output. It may be the same as OFF if edge enhancement will
  /// slow down frame rate relative to sensor.
  ///
  ///@see CaptureRequest\#EDGE_MODE
  static const EDGE_MODE_FAST = 1;

  /// from: static public final int EDGE_MODE_HIGH_QUALITY
  ///
  /// Apply high-quality edge enhancement, at a cost of possibly reduced output frame rate.
  ///
  ///@see CaptureRequest\#EDGE_MODE
  static const EDGE_MODE_HIGH_QUALITY = 2;

  /// from: static public final int EDGE_MODE_OFF
  ///
  /// No edge enhancement is applied.
  ///
  ///@see CaptureRequest\#EDGE_MODE
  static const EDGE_MODE_OFF = 0;

  /// from: static public final int EDGE_MODE_ZERO_SHUTTER_LAG
  ///
  /// Edge enhancement is applied at different
  /// levels for different output streams, based on resolution. Streams at maximum recording
  /// resolution (see android.hardware.camera2.CameraDevice\#createCaptureSession)
  /// or below have edge enhancement applied, while higher-resolution streams have no edge
  /// enhancement applied. The level of edge enhancement for low-resolution streams is tuned
  /// so that frame rate is not impacted, and the quality is equal to or better than FAST
  /// (since it is only applied to lower-resolution outputs, quality may improve from FAST).
  ///
  /// This mode is intended to be used by applications operating in a zero-shutter-lag mode
  /// with YUV or PRIVATE reprocessing, where the application continuously captures
  /// high-resolution intermediate buffers into a circular buffer, from which a final image is
  /// produced via reprocessing when a user takes a picture.  For such a use case, the
  /// high-resolution buffers must not have edge enhancement applied to maximize efficiency of
  /// preview and to avoid double-applying enhancement when reprocessed, while low-resolution
  /// buffers (used for recording or preview, generally) need edge enhancement applied for
  /// reasonable preview quality.
  ///
  /// This mode is guaranteed to be supported by devices that support either the
  /// YUV_REPROCESSING or PRIVATE_REPROCESSING capabilities
  /// (CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities lists either of those capabilities) and it will
  /// be the default mode for CAMERA3_TEMPLATE_ZERO_SHUTTER_LAG template.
  ///
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  ///@see CaptureRequest\#EDGE_MODE
  static const EDGE_MODE_ZERO_SHUTTER_LAG = 3;

  /// from: static public final int FLASH_MODE_OFF
  ///
  /// Do not fire the flash for this capture.
  ///
  ///@see CaptureRequest\#FLASH_MODE
  static const FLASH_MODE_OFF = 0;

  /// from: static public final int FLASH_MODE_SINGLE
  ///
  /// If the flash is available and charged, fire flash
  /// for this capture.
  ///
  ///@see CaptureRequest\#FLASH_MODE
  static const FLASH_MODE_SINGLE = 1;

  /// from: static public final int FLASH_MODE_TORCH
  ///
  /// Transition flash to continuously on.
  ///
  ///@see CaptureRequest\#FLASH_MODE
  static const FLASH_MODE_TORCH = 2;

  /// from: static public final int FLASH_STATE_CHARGING
  ///
  /// Flash is charging and cannot be fired.
  ///
  ///@see CaptureResult\#FLASH_STATE
  static const FLASH_STATE_CHARGING = 1;

  /// from: static public final int FLASH_STATE_FIRED
  ///
  /// Flash fired for this capture.
  ///
  ///@see CaptureResult\#FLASH_STATE
  static const FLASH_STATE_FIRED = 3;

  /// from: static public final int FLASH_STATE_PARTIAL
  ///
  /// Flash partially illuminated this frame.
  ///
  /// This is usually due to the next or previous frame having
  /// the flash fire, and the flash spilling into this capture
  /// due to hardware limitations.
  ///
  ///@see CaptureResult\#FLASH_STATE
  static const FLASH_STATE_PARTIAL = 4;

  /// from: static public final int FLASH_STATE_READY
  ///
  /// Flash is ready to fire.
  ///
  ///@see CaptureResult\#FLASH_STATE
  static const FLASH_STATE_READY = 2;

  /// from: static public final int FLASH_STATE_UNAVAILABLE
  ///
  /// No flash on camera.
  ///
  ///@see CaptureResult\#FLASH_STATE
  static const FLASH_STATE_UNAVAILABLE = 0;

  /// from: static public final int HOT_PIXEL_MODE_FAST
  ///
  /// Hot pixel correction is applied, without reducing frame
  /// rate relative to sensor raw output.
  ///
  /// The hotpixel map may be returned in CaptureResult\#STATISTICS_HOT_PIXEL_MAP android.statistics.hotPixelMap.
  ///
  ///@see CaptureResult\#STATISTICS_HOT_PIXEL_MAP
  ///@see CaptureRequest\#HOT_PIXEL_MODE
  static const HOT_PIXEL_MODE_FAST = 1;

  /// from: static public final int HOT_PIXEL_MODE_HIGH_QUALITY
  ///
  /// High-quality hot pixel correction is applied, at a cost
  /// of possibly reduced frame rate relative to sensor raw output.
  ///
  /// The hotpixel map may be returned in CaptureResult\#STATISTICS_HOT_PIXEL_MAP android.statistics.hotPixelMap.
  ///
  ///@see CaptureResult\#STATISTICS_HOT_PIXEL_MAP
  ///@see CaptureRequest\#HOT_PIXEL_MODE
  static const HOT_PIXEL_MODE_HIGH_QUALITY = 2;

  /// from: static public final int HOT_PIXEL_MODE_OFF
  ///
  /// No hot pixel correction is applied.
  ///
  /// The frame rate must not be reduced relative to sensor raw output
  /// for this option.
  ///
  /// The hotpixel map may be returned in CaptureResult\#STATISTICS_HOT_PIXEL_MAP android.statistics.hotPixelMap.
  ///
  ///@see CaptureResult\#STATISTICS_HOT_PIXEL_MAP
  ///@see CaptureRequest\#HOT_PIXEL_MODE
  static const HOT_PIXEL_MODE_OFF = 0;

  /// from: static public final int INFO_SUPPORTED_HARDWARE_LEVEL_3
  ///
  /// This camera device is capable of YUV reprocessing and RAW data capture, in addition to
  /// FULL-level capabilities.
  ///
  /// The stream configurations listed in the <code>LEVEL_3</code>, <code>RAW</code>, <code>FULL</code>, <code>LEGACY</code> and
  /// <code>LIMITED</code> tables in the android.hardware.camera2.CameraDevice\#createCaptureSession createCaptureSession documentation are guaranteed to be supported.
  ///
  /// The following additional capabilities are guaranteed to be supported:
  ///
  /// <ul>
  /// <li><code>YUV_REPROCESSING</code> capability (CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities contains
  ///   <code>YUV_REPROCESSING</code>)</li>
  /// <li><code>RAW</code> capability (CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities contains
  ///   <code>RAW</code>)</li>
  /// </ul>
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  static const INFO_SUPPORTED_HARDWARE_LEVEL_3 = 3;

  /// from: static public final int INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL
  ///
  /// This camera device is backed by an external camera connected to this Android device.
  ///
  /// The device has capability identical to a LIMITED level device, with the following
  /// exceptions:
  ///
  /// <ul>
  /// <li>The device may not report lens/sensor related information such as<ul>
  /// <li>CaptureRequest\#LENS_FOCAL_LENGTH android.lens.focalLength</li>
  /// <li>CameraCharacteristics\#LENS_INFO_HYPERFOCAL_DISTANCE android.lens.info.hyperfocalDistance</li>
  /// <li>CameraCharacteristics\#SENSOR_INFO_PHYSICAL_SIZE android.sensor.info.physicalSize</li>
  /// <li>CameraCharacteristics\#SENSOR_INFO_WHITE_LEVEL android.sensor.info.whiteLevel</li>
  /// <li>CameraCharacteristics\#SENSOR_BLACK_LEVEL_PATTERN android.sensor.blackLevelPattern</li>
  /// <li>CameraCharacteristics\#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT android.sensor.info.colorFilterArrangement</li>
  /// <li>CaptureResult\#SENSOR_ROLLING_SHUTTER_SKEW android.sensor.rollingShutterSkew</li>
  /// </ul>
  /// </li>
  /// <li>The device will report 0 for CameraCharacteristics\#SENSOR_ORIENTATION android.sensor.orientation</li>
  /// <li>The device has less guarantee on stable framerate, as the framerate partly depends
  ///   on the external camera being used.</li>
  /// </ul>
  ///@see CaptureRequest\#LENS_FOCAL_LENGTH
  ///@see CameraCharacteristics\#LENS_INFO_HYPERFOCAL_DISTANCE
  ///@see CameraCharacteristics\#SENSOR_BLACK_LEVEL_PATTERN
  ///@see CameraCharacteristics\#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT
  ///@see CameraCharacteristics\#SENSOR_INFO_PHYSICAL_SIZE
  ///@see CameraCharacteristics\#SENSOR_INFO_WHITE_LEVEL
  ///@see CameraCharacteristics\#SENSOR_ORIENTATION
  ///@see CaptureResult\#SENSOR_ROLLING_SHUTTER_SKEW
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  static const INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL = 4;

  /// from: static public final int INFO_SUPPORTED_HARDWARE_LEVEL_FULL
  ///
  /// This camera device is capable of supporting advanced imaging applications.
  ///
  /// The stream configurations listed in the <code>FULL</code>, <code>LEGACY</code> and <code>LIMITED</code> tables in the
  /// android.hardware.camera2.CameraDevice\#createCaptureSession createCaptureSession documentation are guaranteed to be supported.
  ///
  /// A <code>FULL</code> device will support below capabilities:
  ///
  /// <ul>
  /// <li><code>BURST_CAPTURE</code> capability (CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities contains
  ///   <code>BURST_CAPTURE</code>)</li>
  /// <li>Per frame control (CameraCharacteristics\#SYNC_MAX_LATENCY android.sync.maxLatency <code>==</code> PER_FRAME_CONTROL)</li>
  /// <li>Manual sensor control (CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities contains <code>MANUAL_SENSOR</code>)</li>
  /// <li>Manual post-processing control (CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities contains
  ///   <code>MANUAL_POST_PROCESSING</code>)</li>
  /// <li>The required exposure time range defined in CameraCharacteristics\#SENSOR_INFO_EXPOSURE_TIME_RANGE android.sensor.info.exposureTimeRange</li>
  /// <li>The required maxFrameDuration defined in CameraCharacteristics\#SENSOR_INFO_MAX_FRAME_DURATION android.sensor.info.maxFrameDuration</li>
  /// </ul>
  /// Note:
  /// Pre-API level 23, FULL devices also supported arbitrary cropping region
  /// (CameraCharacteristics\#SCALER_CROPPING_TYPE android.scaler.croppingType <code>== FREEFORM</code>); this requirement was relaxed in API level
  /// 23, and <code>FULL</code> devices may only support <code>CENTERED</code> cropping.
  ///
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  ///@see CameraCharacteristics\#SCALER_CROPPING_TYPE
  ///@see CameraCharacteristics\#SENSOR_INFO_EXPOSURE_TIME_RANGE
  ///@see CameraCharacteristics\#SENSOR_INFO_MAX_FRAME_DURATION
  ///@see CameraCharacteristics\#SYNC_MAX_LATENCY
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  static const INFO_SUPPORTED_HARDWARE_LEVEL_FULL = 1;

  /// from: static public final int INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY
  ///
  /// This camera device is running in backward compatibility mode.
  ///
  /// Only the stream configurations listed in the <code>LEGACY</code> table in the android.hardware.camera2.CameraDevice\#createCaptureSession createCaptureSession documentation are supported.
  ///
  /// A <code>LEGACY</code> device does not support per-frame control, manual sensor control, manual
  /// post-processing, arbitrary cropping regions, and has relaxed performance constraints.
  /// No additional capabilities beyond <code>BACKWARD_COMPATIBLE</code> will ever be listed by a
  /// <code>LEGACY</code> device in CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities.
  ///
  /// In addition, the CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger is not functional on <code>LEGACY</code>
  /// devices. Instead, every request that includes a JPEG-format output target is treated
  /// as triggering a still capture, internally executing a precapture trigger.  This may
  /// fire the flash for flash power metering during precapture, and then fire the flash
  /// for the final capture, if a flash is available on the device and the AE mode is set to
  /// enable the flash.
  ///
  ///@see CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  static const INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY = 2;

  /// from: static public final int INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED
  ///
  /// This camera device does not have enough capabilities to qualify as a <code>FULL</code> device or
  /// better.
  ///
  /// Only the stream configurations listed in the <code>LEGACY</code> and <code>LIMITED</code> tables in the
  /// android.hardware.camera2.CameraDevice\#createCaptureSession createCaptureSession documentation are guaranteed to be supported.
  ///
  /// All <code>LIMITED</code> devices support the <code>BACKWARDS_COMPATIBLE</code> capability, indicating basic
  /// support for color image capture. The only exception is that the device may
  /// alternatively support only the <code>DEPTH_OUTPUT</code> capability, if it can only output depth
  /// measurements and not color images.
  ///
  /// <code>LIMITED</code> devices and above require the use of CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger
  /// to lock exposure metering (and calculate flash power, for cameras with flash) before
  /// capturing a high-quality still image.
  ///
  /// A <code>LIMITED</code> device that only lists the <code>BACKWARDS_COMPATIBLE</code> capability is only
  /// required to support full-automatic operation and post-processing (<code>OFF</code> is not
  /// supported for CaptureRequest\#CONTROL_AE_MODE android.control.aeMode, CaptureRequest\#CONTROL_AF_MODE android.control.afMode, or
  /// CaptureRequest\#CONTROL_AWB_MODE android.control.awbMode)
  ///
  /// Additional capabilities may optionally be supported by a <code>LIMITED</code>-level device, and
  /// can be checked for in CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities.
  ///
  ///@see CaptureRequest\#CONTROL_AE_MODE
  ///@see CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER
  ///@see CaptureRequest\#CONTROL_AF_MODE
  ///@see CaptureRequest\#CONTROL_AWB_MODE
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  static const INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED = 0;

  /// from: static public final int LENS_FACING_BACK
  ///
  /// The camera device faces the opposite direction as the device's screen.
  ///
  ///@see CameraCharacteristics\#LENS_FACING
  static const LENS_FACING_BACK = 1;

  /// from: static public final int LENS_FACING_EXTERNAL
  ///
  /// The camera device is an external camera, and has no fixed facing relative to the
  /// device's screen.
  ///
  ///@see CameraCharacteristics\#LENS_FACING
  static const LENS_FACING_EXTERNAL = 2;

  /// from: static public final int LENS_FACING_FRONT
  ///
  /// The camera device faces the same direction as the device's screen.
  ///
  ///@see CameraCharacteristics\#LENS_FACING
  static const LENS_FACING_FRONT = 0;

  /// from: static public final int LENS_INFO_FOCUS_DISTANCE_CALIBRATION_APPROXIMATE
  ///
  /// The lens focus distance is measured in diopters.
  ///
  /// However, setting the lens to the same focus distance
  /// on separate occasions may result in a different real
  /// focus distance, depending on factors such as the
  /// orientation of the device, the age of the focusing
  /// mechanism, and the device temperature.
  ///
  ///@see CameraCharacteristics\#LENS_INFO_FOCUS_DISTANCE_CALIBRATION
  static const LENS_INFO_FOCUS_DISTANCE_CALIBRATION_APPROXIMATE = 1;

  /// from: static public final int LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED
  ///
  /// The lens focus distance is measured in diopters, and
  /// is calibrated.
  ///
  /// The lens mechanism is calibrated so that setting the
  /// same focus distance is repeatable on multiple
  /// occasions with good accuracy, and the focus distance
  /// corresponds to the real physical distance to the plane
  /// of best focus.
  ///
  ///@see CameraCharacteristics\#LENS_INFO_FOCUS_DISTANCE_CALIBRATION
  static const LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED = 2;

  /// from: static public final int LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED
  ///
  /// The lens focus distance is not accurate, and the units used for
  /// CaptureRequest\#LENS_FOCUS_DISTANCE android.lens.focusDistance do not correspond to any physical units.
  ///
  /// Setting the lens to the same focus distance on separate occasions may
  /// result in a different real focus distance, depending on factors such
  /// as the orientation of the device, the age of the focusing mechanism,
  /// and the device temperature. The focus distance value will still be
  /// in the range of <code>[0, CameraCharacteristics\#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance]</code>, where 0
  /// represents the farthest focus.
  ///
  ///@see CaptureRequest\#LENS_FOCUS_DISTANCE
  ///@see CameraCharacteristics\#LENS_INFO_MINIMUM_FOCUS_DISTANCE
  ///@see CameraCharacteristics\#LENS_INFO_FOCUS_DISTANCE_CALIBRATION
  static const LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED = 0;

  /// from: static public final int LENS_OPTICAL_STABILIZATION_MODE_OFF
  ///
  /// Optical stabilization is unavailable.
  ///
  ///@see CaptureRequest\#LENS_OPTICAL_STABILIZATION_MODE
  static const LENS_OPTICAL_STABILIZATION_MODE_OFF = 0;

  /// from: static public final int LENS_OPTICAL_STABILIZATION_MODE_ON
  ///
  /// Optical stabilization is enabled.
  ///
  ///@see CaptureRequest\#LENS_OPTICAL_STABILIZATION_MODE
  static const LENS_OPTICAL_STABILIZATION_MODE_ON = 1;

  /// from: static public final int LENS_POSE_REFERENCE_GYROSCOPE
  ///
  /// The value of CameraCharacteristics\#LENS_POSE_TRANSLATION android.lens.poseTranslation is relative to the position of the
  /// primary gyroscope of this Android device.
  ///
  ///@see CameraCharacteristics\#LENS_POSE_TRANSLATION
  ///@see CameraCharacteristics\#LENS_POSE_REFERENCE
  static const LENS_POSE_REFERENCE_GYROSCOPE = 1;

  /// from: static public final int LENS_POSE_REFERENCE_PRIMARY_CAMERA
  ///
  /// The value of CameraCharacteristics\#LENS_POSE_TRANSLATION android.lens.poseTranslation is relative to the optical center of
  /// the largest camera device facing the same direction as this camera.
  ///
  /// This is the default value for API levels before Android P.
  ///
  ///@see CameraCharacteristics\#LENS_POSE_TRANSLATION
  ///@see CameraCharacteristics\#LENS_POSE_REFERENCE
  static const LENS_POSE_REFERENCE_PRIMARY_CAMERA = 0;

  /// from: static public final int LENS_STATE_MOVING
  ///
  /// One or several of the lens parameters
  /// (CaptureRequest\#LENS_FOCAL_LENGTH android.lens.focalLength, CaptureRequest\#LENS_FOCUS_DISTANCE android.lens.focusDistance,
  /// CaptureRequest\#LENS_FILTER_DENSITY android.lens.filterDensity or CaptureRequest\#LENS_APERTURE android.lens.aperture) is
  /// currently changing.
  ///
  ///@see CaptureRequest\#LENS_APERTURE
  ///@see CaptureRequest\#LENS_FILTER_DENSITY
  ///@see CaptureRequest\#LENS_FOCAL_LENGTH
  ///@see CaptureRequest\#LENS_FOCUS_DISTANCE
  ///@see CaptureResult\#LENS_STATE
  static const LENS_STATE_MOVING = 1;

  /// from: static public final int LENS_STATE_STATIONARY
  ///
  /// The lens parameters (CaptureRequest\#LENS_FOCAL_LENGTH android.lens.focalLength, CaptureRequest\#LENS_FOCUS_DISTANCE android.lens.focusDistance,
  /// CaptureRequest\#LENS_FILTER_DENSITY android.lens.filterDensity and CaptureRequest\#LENS_APERTURE android.lens.aperture) are not changing.
  ///
  ///@see CaptureRequest\#LENS_APERTURE
  ///@see CaptureRequest\#LENS_FILTER_DENSITY
  ///@see CaptureRequest\#LENS_FOCAL_LENGTH
  ///@see CaptureRequest\#LENS_FOCUS_DISTANCE
  ///@see CaptureResult\#LENS_STATE
  static const LENS_STATE_STATIONARY = 0;

  /// from: static public final int LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_APPROXIMATE
  ///
  /// A software mechanism is used to synchronize between the physical cameras. As a result,
  /// the timestamp of an image from a physical stream is only an approximation of the
  /// image sensor start-of-exposure time.
  ///
  ///@see CameraCharacteristics\#LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE
  static const LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_APPROXIMATE = 0;

  /// from: static public final int LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED
  ///
  /// The camera device supports frame timestamp synchronization at the hardware level,
  /// and the timestamp of a physical stream image accurately reflects its
  /// start-of-exposure time.
  ///
  ///@see CameraCharacteristics\#LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE
  static const LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED = 1;

  /// from: static public final int NOISE_REDUCTION_MODE_FAST
  ///
  /// Noise reduction is applied without reducing frame rate relative to sensor
  /// output. It may be the same as OFF if noise reduction will reduce frame rate
  /// relative to sensor.
  ///
  ///@see CaptureRequest\#NOISE_REDUCTION_MODE
  static const NOISE_REDUCTION_MODE_FAST = 1;

  /// from: static public final int NOISE_REDUCTION_MODE_HIGH_QUALITY
  ///
  /// High-quality noise reduction is applied, at the cost of possibly reduced frame
  /// rate relative to sensor output.
  ///
  ///@see CaptureRequest\#NOISE_REDUCTION_MODE
  static const NOISE_REDUCTION_MODE_HIGH_QUALITY = 2;

  /// from: static public final int NOISE_REDUCTION_MODE_MINIMAL
  ///
  /// MINIMAL noise reduction is applied without reducing frame rate relative to
  /// sensor output.
  ///
  ///@see CaptureRequest\#NOISE_REDUCTION_MODE
  static const NOISE_REDUCTION_MODE_MINIMAL = 3;

  /// from: static public final int NOISE_REDUCTION_MODE_OFF
  ///
  /// No noise reduction is applied.
  ///
  ///@see CaptureRequest\#NOISE_REDUCTION_MODE
  static const NOISE_REDUCTION_MODE_OFF = 0;

  /// from: static public final int NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG
  ///
  /// Noise reduction is applied at different levels for different output streams,
  /// based on resolution. Streams at maximum recording resolution (see android.hardware.camera2.CameraDevice\#createCaptureSession)
  /// or below have noise reduction applied, while higher-resolution streams have MINIMAL (if
  /// supported) or no noise reduction applied (if MINIMAL is not supported.) The degree of
  /// noise reduction for low-resolution streams is tuned so that frame rate is not impacted,
  /// and the quality is equal to or better than FAST (since it is only applied to
  /// lower-resolution outputs, quality may improve from FAST).
  ///
  /// This mode is intended to be used by applications operating in a zero-shutter-lag mode
  /// with YUV or PRIVATE reprocessing, where the application continuously captures
  /// high-resolution intermediate buffers into a circular buffer, from which a final image is
  /// produced via reprocessing when a user takes a picture.  For such a use case, the
  /// high-resolution buffers must not have noise reduction applied to maximize efficiency of
  /// preview and to avoid over-applying noise filtering when reprocessing, while
  /// low-resolution buffers (used for recording or preview, generally) need noise reduction
  /// applied for reasonable preview quality.
  ///
  /// This mode is guaranteed to be supported by devices that support either the
  /// YUV_REPROCESSING or PRIVATE_REPROCESSING capabilities
  /// (CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities lists either of those capabilities) and it will
  /// be the default mode for CAMERA3_TEMPLATE_ZERO_SHUTTER_LAG template.
  ///
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  ///@see CaptureRequest\#NOISE_REDUCTION_MODE
  static const NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG = 4;

  /// from: static public final int REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE
  ///
  /// The minimal set of capabilities that every camera
  /// device (regardless of CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel)
  /// supports.
  ///
  /// This capability is listed by all normal devices, and
  /// indicates that the camera device has a feature set
  /// that's comparable to the baseline requirements for the
  /// older android.hardware.Camera API.
  ///
  /// Devices with the DEPTH_OUTPUT capability might not list this
  /// capability, indicating that they support only depth measurement,
  /// not standard color output.
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  static const REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE = 0;

  /// from: static public final int REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE
  ///
  /// The camera device supports capturing high-resolution images at &gt;= 20 frames per
  /// second, in at least the uncompressed YUV format, when post-processing settings are set
  /// to FAST. Additionally, maximum-resolution images can be captured at &gt;= 10 frames
  /// per second.  Here, 'high resolution' means at least 8 megapixels, or the maximum
  /// resolution of the device, whichever is smaller.
  ///
  /// More specifically, this means that a size matching the camera device's active array
  /// size is listed as a supported size for the android.graphics.ImageFormat\#YUV_420_888 format in either android.hardware.camera2.params.StreamConfigurationMap\#getOutputSizes or android.hardware.camera2.params.StreamConfigurationMap\#getHighResolutionOutputSizes,
  /// with a minimum frame duration for that format and size of either &lt;= 1/20 s, or
  /// &lt;= 1/10 s, respectively; and the CameraCharacteristics\#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES android.control.aeAvailableTargetFpsRanges entry
  /// lists at least one FPS range where the minimum FPS is &gt;= 1 / minimumFrameDuration
  /// for the maximum-size YUV_420_888 format.  If that maximum size is listed in android.hardware.camera2.params.StreamConfigurationMap\#getHighResolutionOutputSizes,
  /// then the list of resolutions for YUV_420_888 from android.hardware.camera2.params.StreamConfigurationMap\#getOutputSizes contains at
  /// least one resolution &gt;= 8 megapixels, with a minimum frame duration of &lt;= 1/20
  /// s.
  ///
  /// If the device supports the android.graphics.ImageFormat\#RAW10, android.graphics.ImageFormat\#RAW12, then those can also be
  /// captured at the same rate as the maximum-size YUV_420_888 resolution is.
  ///
  /// If the device supports the PRIVATE_REPROCESSING capability, then the same guarantees
  /// as for the YUV_420_888 format also apply to the android.graphics.ImageFormat\#PRIVATE format.
  ///
  /// In addition, the CameraCharacteristics\#SYNC_MAX_LATENCY android.sync.maxLatency field is guaranted to have a value between 0
  /// and 4, inclusive. CameraCharacteristics\#CONTROL_AE_LOCK_AVAILABLE android.control.aeLockAvailable and CameraCharacteristics\#CONTROL_AWB_LOCK_AVAILABLE android.control.awbLockAvailable
  /// are also guaranteed to be <code>true</code> so burst capture with these two locks ON yields
  /// consistent image output.
  ///
  ///@see CameraCharacteristics\#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES
  ///@see CameraCharacteristics\#CONTROL_AE_LOCK_AVAILABLE
  ///@see CameraCharacteristics\#CONTROL_AWB_LOCK_AVAILABLE
  ///@see CameraCharacteristics\#SYNC_MAX_LATENCY
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  static const REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE = 6;

  /// from: static public final int REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO
  ///
  /// The device supports constrained high speed video recording (frame rate &gt;=120fps) use
  /// case. The camera device will support high speed capture session created by android.hardware.camera2.CameraDevice\#createConstrainedHighSpeedCaptureSession, which
  /// only accepts high speed request lists created by android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession\#createHighSpeedRequestList.
  ///
  /// A camera device can still support high speed video streaming by advertising the high
  /// speed FPS ranges in CameraCharacteristics\#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES android.control.aeAvailableTargetFpsRanges. For this case, all
  /// normal capture request per frame control and synchronization requirements will apply
  /// to the high speed fps ranges, the same as all other fps ranges. This capability
  /// describes the capability of a specialized operating mode with many limitations (see
  /// below), which is only targeted at high speed video recording.
  ///
  /// The supported high speed video sizes and fps ranges are specified in android.hardware.camera2.params.StreamConfigurationMap\#getHighSpeedVideoFpsRanges.
  /// To get desired output frame rates, the application is only allowed to select video
  /// size and FPS range combinations provided by android.hardware.camera2.params.StreamConfigurationMap\#getHighSpeedVideoSizes.  The
  /// fps range can be controlled via CaptureRequest\#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange.
  ///
  /// In this capability, the camera device will override aeMode, awbMode, and afMode to
  /// ON, AUTO, and CONTINUOUS_VIDEO, respectively. All post-processing block mode
  /// controls will be overridden to be FAST. Therefore, no manual control of capture
  /// and post-processing parameters is possible. All other controls operate the
  /// same as when CaptureRequest\#CONTROL_MODE android.control.mode == AUTO. This means that all other
  /// android.control.* fields continue to work, such as
  ///
  /// <ul>
  /// <li>CaptureRequest\#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange</li>
  /// <li>CaptureRequest\#CONTROL_AE_EXPOSURE_COMPENSATION android.control.aeExposureCompensation</li>
  /// <li>CaptureRequest\#CONTROL_AE_LOCK android.control.aeLock</li>
  /// <li>CaptureRequest\#CONTROL_AWB_LOCK android.control.awbLock</li>
  /// <li>CaptureRequest\#CONTROL_EFFECT_MODE android.control.effectMode</li>
  /// <li>CaptureRequest\#CONTROL_AE_REGIONS android.control.aeRegions</li>
  /// <li>CaptureRequest\#CONTROL_AF_REGIONS android.control.afRegions</li>
  /// <li>CaptureRequest\#CONTROL_AWB_REGIONS android.control.awbRegions</li>
  /// <li>CaptureRequest\#CONTROL_AF_TRIGGER android.control.afTrigger</li>
  /// <li>CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger</li>
  /// </ul>
  /// Outside of android.control.*, the following controls will work:
  ///
  /// <ul>
  /// <li>CaptureRequest\#FLASH_MODE android.flash.mode (TORCH mode only, automatic flash for still capture will not
  /// work since aeMode is ON)</li>
  /// <li>CaptureRequest\#LENS_OPTICAL_STABILIZATION_MODE android.lens.opticalStabilizationMode (if it is supported)</li>
  /// <li>CaptureRequest\#SCALER_CROP_REGION android.scaler.cropRegion</li>
  /// <li>CaptureRequest\#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode (if it is supported)</li>
  /// </ul>
  /// For high speed recording use case, the actual maximum supported frame rate may
  /// be lower than what camera can output, depending on the destination Surfaces for
  /// the image data. For example, if the destination surface is from video encoder,
  /// the application need check if the video encoder is capable of supporting the
  /// high frame rate for a given video size, or it will end up with lower recording
  /// frame rate. If the destination surface is from preview window, the actual preview frame
  /// rate will be bounded by the screen refresh rate.
  ///
  /// The camera device will only support up to 2 high speed simultaneous output surfaces
  /// (preview and recording surfaces) in this mode. Above controls will be effective only
  /// if all of below conditions are true:
  ///
  /// <ul>
  /// <li>The application creates a camera capture session with no more than 2 surfaces via
  /// android.hardware.camera2.CameraDevice\#createConstrainedHighSpeedCaptureSession. The
  /// targeted surfaces must be preview surface (either from android.view.SurfaceView or android.graphics.SurfaceTexture) or recording
  /// surface(either from android.media.MediaRecorder\#getSurface or android.media.MediaCodec\#createInputSurface).</li>
  /// <li>The stream sizes are selected from the sizes reported by
  /// android.hardware.camera2.params.StreamConfigurationMap\#getHighSpeedVideoSizes.</li>
  /// <li>The FPS ranges are selected from android.hardware.camera2.params.StreamConfigurationMap\#getHighSpeedVideoFpsRanges.</li>
  /// </ul>
  /// When above conditions are NOT satistied,
  /// android.hardware.camera2.CameraDevice\#createConstrainedHighSpeedCaptureSession
  /// will fail.
  ///
  /// Switching to a FPS range that has different maximum FPS may trigger some camera device
  /// reconfigurations, which may introduce extra latency. It is recommended that
  /// the application avoids unnecessary maximum target FPS changes as much as possible
  /// during high speed streaming.
  ///
  ///@see CameraCharacteristics\#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES
  ///@see CaptureRequest\#CONTROL_AE_EXPOSURE_COMPENSATION
  ///@see CaptureRequest\#CONTROL_AE_LOCK
  ///@see CaptureRequest\#CONTROL_AE_PRECAPTURE_TRIGGER
  ///@see CaptureRequest\#CONTROL_AE_REGIONS
  ///@see CaptureRequest\#CONTROL_AE_TARGET_FPS_RANGE
  ///@see CaptureRequest\#CONTROL_AF_REGIONS
  ///@see CaptureRequest\#CONTROL_AF_TRIGGER
  ///@see CaptureRequest\#CONTROL_AWB_LOCK
  ///@see CaptureRequest\#CONTROL_AWB_REGIONS
  ///@see CaptureRequest\#CONTROL_EFFECT_MODE
  ///@see CaptureRequest\#CONTROL_MODE
  ///@see CaptureRequest\#FLASH_MODE
  ///@see CaptureRequest\#LENS_OPTICAL_STABILIZATION_MODE
  ///@see CaptureRequest\#SCALER_CROP_REGION
  ///@see CaptureRequest\#STATISTICS_FACE_DETECT_MODE
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  static const REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO = 9;

  /// from: static public final int REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT
  ///
  /// The camera device can produce depth measurements from its field of view.
  ///
  /// This capability requires the camera device to support the following:
  ///
  /// <ul>
  /// <li>android.graphics.ImageFormat\#DEPTH16 is supported as
  ///   an output format.</li>
  /// <li>android.graphics.ImageFormat\#DEPTH_POINT_CLOUD is
  ///   optionally supported as an output format.</li>
  /// <li>This camera device, and all camera devices with the same CameraCharacteristics\#LENS_FACING android.lens.facing, will
  ///   list the following calibration metadata entries in both android.hardware.camera2.CameraCharacteristics
  ///   and android.hardware.camera2.CaptureResult:<ul>
  /// <li>CameraCharacteristics\#LENS_POSE_TRANSLATION android.lens.poseTranslation</li>
  /// <li>CameraCharacteristics\#LENS_POSE_ROTATION android.lens.poseRotation</li>
  /// <li>CameraCharacteristics\#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration</li>
  /// <li>CameraCharacteristics\#LENS_DISTORTION android.lens.distortion</li>
  /// </ul>
  /// </li>
  /// <li>The CameraCharacteristics\#DEPTH_DEPTH_IS_EXCLUSIVE android.depth.depthIsExclusive entry is listed by this device.</li>
  /// <li>As of Android P, the CameraCharacteristics\#LENS_POSE_REFERENCE android.lens.poseReference entry is listed by this device.</li>
  /// <li>A LIMITED camera with only the DEPTH_OUTPUT capability does not have to support
  ///   normal YUV_420_888, JPEG, and PRIV-format outputs. It only has to support the DEPTH16
  ///   format.</li>
  /// </ul>
  /// Generally, depth output operates at a slower frame rate than standard color capture,
  /// so the DEPTH16 and DEPTH_POINT_CLOUD formats will commonly have a stall duration that
  /// should be accounted for (see android.hardware.camera2.params.StreamConfigurationMap\#getOutputStallDuration).
  /// On a device that supports both depth and color-based output, to enable smooth preview,
  /// using a repeating burst is recommended, where a depth-output target is only included
  /// once every N frames, where N is the ratio between preview output rate and depth output
  /// rate, including depth stall time.
  ///
  ///@see CameraCharacteristics\#DEPTH_DEPTH_IS_EXCLUSIVE
  ///@see CameraCharacteristics\#LENS_DISTORTION
  ///@see CameraCharacteristics\#LENS_FACING
  ///@see CameraCharacteristics\#LENS_INTRINSIC_CALIBRATION
  ///@see CameraCharacteristics\#LENS_POSE_REFERENCE
  ///@see CameraCharacteristics\#LENS_POSE_ROTATION
  ///@see CameraCharacteristics\#LENS_POSE_TRANSLATION
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  static const REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT = 8;

  /// from: static public final int REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA
  ///
  /// The camera device is a logical camera backed by two or more physical cameras that are
  /// also exposed to the application.
  ///
  /// Camera application shouldn't assume that there are at most 1 rear camera and 1 front
  /// camera in the system. For an application that switches between front and back cameras,
  /// the recommendation is to switch between the first rear camera and the first front
  /// camera in the list of supported camera devices.
  ///
  /// This capability requires the camera device to support the following:
  ///
  /// <ul>
  /// <li>This camera device must list the following static metadata entries in android.hardware.camera2.CameraCharacteristics:<ul>
  /// <li>android.logicalMultiCamera.physicalIds</li>
  /// <li>CameraCharacteristics\#LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE android.logicalMultiCamera.sensorSyncType</li>
  /// </ul>
  /// </li>
  /// <li>The underlying physical cameras' static metadata must list the following entries,
  ///   so that the application can correlate pixels from the physical streams:<ul>
  /// <li>CameraCharacteristics\#LENS_POSE_REFERENCE android.lens.poseReference</li>
  /// <li>CameraCharacteristics\#LENS_POSE_ROTATION android.lens.poseRotation</li>
  /// <li>CameraCharacteristics\#LENS_POSE_TRANSLATION android.lens.poseTranslation</li>
  /// <li>CameraCharacteristics\#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration</li>
  /// <li>CameraCharacteristics\#LENS_DISTORTION android.lens.distortion</li>
  /// </ul>
  /// </li>
  /// <li>The SENSOR_INFO_TIMESTAMP_SOURCE of the logical device and physical devices must be
  ///   the same.</li>
  /// <li>The logical camera device must be LIMITED or higher device.</li>
  /// </ul>
  /// Both the logical camera device and its underlying physical devices support the
  /// mandatory stream combinations required for their device levels.
  ///
  /// Additionally, for each guaranteed stream combination, the logical camera supports:
  ///
  /// <ul>
  /// <li>For each guaranteed stream combination, the logical camera supports replacing one
  ///   logical android.graphics.ImageFormat\#YUV_420_888 YUV_420_888
  ///   or raw stream with two physical streams of the same size and format, each from a
  ///   separate physical camera, given that the size and format are supported by both
  ///   physical cameras.</li>
  /// <li>If the logical camera doesn't advertise RAW capability, but the underlying physical
  ///   cameras do, the logical camera will support guaranteed stream combinations for RAW
  ///   capability, except that the RAW streams will be physical streams, each from a separate
  ///   physical camera. This is usually the case when the physical cameras have different
  ///   sensor sizes.</li>
  /// </ul>
  /// Using physical streams in place of a logical stream of the same size and format will
  /// not slow down the frame rate of the capture, as long as the minimum frame duration
  /// of the physical and logical streams are the same.
  ///
  ///@see CameraCharacteristics\#LENS_DISTORTION
  ///@see CameraCharacteristics\#LENS_INTRINSIC_CALIBRATION
  ///@see CameraCharacteristics\#LENS_POSE_REFERENCE
  ///@see CameraCharacteristics\#LENS_POSE_ROTATION
  ///@see CameraCharacteristics\#LENS_POSE_TRANSLATION
  ///@see CameraCharacteristics\#LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  static const REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA = 11;

  /// from: static public final int REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING
  ///
  /// The camera device post-processing stages can be manually controlled.
  /// The camera device supports basic manual control of the image post-processing
  /// stages. This means the following controls are guaranteed to be supported:
  ///
  /// <ul>
  /// <li>
  /// Manual tonemap control
  ///
  /// <ul>
  /// <li>CaptureRequest\#TONEMAP_CURVE android.tonemap.curve</li>
  /// <li>CaptureRequest\#TONEMAP_MODE android.tonemap.mode</li>
  /// <li>CameraCharacteristics\#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints</li>
  /// <li>CaptureRequest\#TONEMAP_GAMMA android.tonemap.gamma</li>
  /// <li>CaptureRequest\#TONEMAP_PRESET_CURVE android.tonemap.presetCurve</li>
  /// </ul>
  /// </li>
  /// <li>
  /// Manual white balance control
  ///
  /// <ul>
  /// <li>CaptureRequest\#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform</li>
  /// <li>CaptureRequest\#COLOR_CORRECTION_GAINS android.colorCorrection.gains</li>
  /// </ul>
  /// </li>
  /// <li>Manual lens shading map control<ul>
  /// <li>CaptureRequest\#SHADING_MODE android.shading.mode</li>
  /// <li>CaptureRequest\#STATISTICS_LENS_SHADING_MAP_MODE android.statistics.lensShadingMapMode</li>
  /// <li>android.statistics.lensShadingMap</li>
  /// <li>android.lens.info.shadingMapSize</li>
  /// </ul>
  /// </li>
  /// <li>Manual aberration correction control (if aberration correction is supported)<ul>
  /// <li>CaptureRequest\#COLOR_CORRECTION_ABERRATION_MODE android.colorCorrection.aberrationMode</li>
  /// <li>CameraCharacteristics\#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES android.colorCorrection.availableAberrationModes</li>
  /// </ul>
  /// </li>
  /// <li>Auto white balance lock<ul>
  /// <li>CaptureRequest\#CONTROL_AWB_LOCK android.control.awbLock</li>
  /// </ul>
  /// </li>
  /// </ul>
  /// If auto white balance is enabled, then the camera device
  /// will accurately report the values applied by AWB in the result.
  ///
  /// A given camera device may also support additional post-processing
  /// controls, but this capability only covers the above list of controls.
  ///
  ///@see CaptureRequest\#COLOR_CORRECTION_ABERRATION_MODE
  ///@see CameraCharacteristics\#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES
  ///@see CaptureRequest\#COLOR_CORRECTION_GAINS
  ///@see CaptureRequest\#COLOR_CORRECTION_TRANSFORM
  ///@see CaptureRequest\#CONTROL_AWB_LOCK
  ///@see CaptureRequest\#SHADING_MODE
  ///@see CaptureRequest\#STATISTICS_LENS_SHADING_MAP_MODE
  ///@see CaptureRequest\#TONEMAP_CURVE
  ///@see CaptureRequest\#TONEMAP_GAMMA
  ///@see CameraCharacteristics\#TONEMAP_MAX_CURVE_POINTS
  ///@see CaptureRequest\#TONEMAP_MODE
  ///@see CaptureRequest\#TONEMAP_PRESET_CURVE
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  static const REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING = 2;

  /// from: static public final int REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR
  ///
  /// The camera device can be manually controlled (3A algorithms such
  /// as auto-exposure, and auto-focus can be bypassed).
  /// The camera device supports basic manual control of the sensor image
  /// acquisition related stages. This means the following controls are
  /// guaranteed to be supported:
  ///
  /// <ul>
  /// <li>Manual frame duration control<ul>
  /// <li>CaptureRequest\#SENSOR_FRAME_DURATION android.sensor.frameDuration</li>
  /// <li>CameraCharacteristics\#SENSOR_INFO_MAX_FRAME_DURATION android.sensor.info.maxFrameDuration</li>
  /// </ul>
  /// </li>
  /// <li>Manual exposure control<ul>
  /// <li>CaptureRequest\#SENSOR_EXPOSURE_TIME android.sensor.exposureTime</li>
  /// <li>CameraCharacteristics\#SENSOR_INFO_EXPOSURE_TIME_RANGE android.sensor.info.exposureTimeRange</li>
  /// </ul>
  /// </li>
  /// <li>Manual sensitivity control<ul>
  /// <li>CaptureRequest\#SENSOR_SENSITIVITY android.sensor.sensitivity</li>
  /// <li>CameraCharacteristics\#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange</li>
  /// </ul>
  /// </li>
  /// <li>Manual lens control (if the lens is adjustable)<ul>
  /// <li>android.lens.*</li>
  /// </ul>
  /// </li>
  /// <li>Manual flash control (if a flash unit is present)<ul>
  /// <li>android.flash.*</li>
  /// </ul>
  /// </li>
  /// <li>Manual black level locking<ul>
  /// <li>CaptureRequest\#BLACK_LEVEL_LOCK android.blackLevel.lock</li>
  /// </ul>
  /// </li>
  /// <li>Auto exposure lock<ul>
  /// <li>CaptureRequest\#CONTROL_AE_LOCK android.control.aeLock</li>
  /// </ul>
  /// </li>
  /// </ul>
  /// If any of the above 3A algorithms are enabled, then the camera
  /// device will accurately report the values applied by 3A in the
  /// result.
  ///
  /// A given camera device may also support additional manual sensor controls,
  /// but this capability only covers the above list of controls.
  ///
  /// If this is supported, CameraCharacteristics\#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap will
  /// additionally return a min frame duration that is greater than
  /// zero for each supported size-format combination.
  ///
  ///@see CaptureRequest\#BLACK_LEVEL_LOCK
  ///@see CaptureRequest\#CONTROL_AE_LOCK
  ///@see CameraCharacteristics\#SCALER_STREAM_CONFIGURATION_MAP
  ///@see CaptureRequest\#SENSOR_EXPOSURE_TIME
  ///@see CaptureRequest\#SENSOR_FRAME_DURATION
  ///@see CameraCharacteristics\#SENSOR_INFO_EXPOSURE_TIME_RANGE
  ///@see CameraCharacteristics\#SENSOR_INFO_MAX_FRAME_DURATION
  ///@see CameraCharacteristics\#SENSOR_INFO_SENSITIVITY_RANGE
  ///@see CaptureRequest\#SENSOR_SENSITIVITY
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  static const REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR = 1;

  /// from: static public final int REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME
  ///
  /// The camera device is a monochrome camera that doesn't contain a color filter array,
  /// and the pixel values on U and V planes are all 128.
  ///
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  static const REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME = 12;

  /// from: static public final int REQUEST_AVAILABLE_CAPABILITIES_MOTION_TRACKING
  ///
  /// The camera device supports the MOTION_TRACKING value for
  /// CaptureRequest\#CONTROL_CAPTURE_INTENT android.control.captureIntent, which limits maximum exposure time to 20 ms.
  ///
  /// This limits the motion blur of capture images, resulting in better image tracking
  /// results for use cases such as image stabilization or augmented reality.
  ///
  ///@see CaptureRequest\#CONTROL_CAPTURE_INTENT
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  static const REQUEST_AVAILABLE_CAPABILITIES_MOTION_TRACKING = 10;

  /// from: static public final int REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING
  ///
  /// The camera device supports the Zero Shutter Lag reprocessing use case.
  ///
  /// <ul>
  /// <li>One input stream is supported, that is, <code>CameraCharacteristics\#REQUEST_MAX_NUM_INPUT_STREAMS android.request.maxNumInputStreams == 1</code>.</li>
  /// <li>android.graphics.ImageFormat\#PRIVATE is supported as an output/input format,
  ///   that is, android.graphics.ImageFormat\#PRIVATE is included in the lists of
  ///   formats returned by android.hardware.camera2.params.StreamConfigurationMap\#getInputFormats and android.hardware.camera2.params.StreamConfigurationMap\#getOutputFormats.</li>
  /// <li>android.hardware.camera2.params.StreamConfigurationMap\#getValidOutputFormatsForInput
  ///   returns non empty int[] for each supported input format returned by android.hardware.camera2.params.StreamConfigurationMap\#getInputFormats.</li>
  /// <li>Each size returned by android.hardware.camera2.params.StreamConfigurationMap\#getInputSizes getInputSizes(ImageFormat.PRIVATE) is also included in android.hardware.camera2.params.StreamConfigurationMap\#getOutputSizes getOutputSizes(ImageFormat.PRIVATE)</li>
  /// <li>Using android.graphics.ImageFormat\#PRIVATE does not cause a frame rate drop
  ///   relative to the sensor's maximum capture rate (at that resolution).</li>
  /// <li>android.graphics.ImageFormat\#PRIVATE will be reprocessable into both
  ///   android.graphics.ImageFormat\#YUV_420_888 and
  ///   android.graphics.ImageFormat\#JPEG formats.</li>
  /// <li>The maximum available resolution for PRIVATE streams
  ///   (both input/output) will match the maximum available
  ///   resolution of JPEG streams.</li>
  /// <li>Static metadata CameraCharacteristics\#REPROCESS_MAX_CAPTURE_STALL android.reprocess.maxCaptureStall.</li>
  /// <li>Only below controls are effective for reprocessing requests and
  ///   will be present in capture results, other controls in reprocess
  ///   requests will be ignored by the camera device.<ul>
  /// <li>android.jpeg.*</li>
  /// <li>CaptureRequest\#NOISE_REDUCTION_MODE android.noiseReduction.mode</li>
  /// <li>CaptureRequest\#EDGE_MODE android.edge.mode</li>
  /// </ul>
  /// </li>
  /// <li>CameraCharacteristics\#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES android.noiseReduction.availableNoiseReductionModes and
  ///   CameraCharacteristics\#EDGE_AVAILABLE_EDGE_MODES android.edge.availableEdgeModes will both list ZERO_SHUTTER_LAG as a supported mode.</li>
  /// </ul>
  ///@see CameraCharacteristics\#EDGE_AVAILABLE_EDGE_MODES
  ///@see CaptureRequest\#EDGE_MODE
  ///@see CameraCharacteristics\#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES
  ///@see CaptureRequest\#NOISE_REDUCTION_MODE
  ///@see CameraCharacteristics\#REPROCESS_MAX_CAPTURE_STALL
  ///@see CameraCharacteristics\#REQUEST_MAX_NUM_INPUT_STREAMS
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  static const REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING = 4;

  /// from: static public final int REQUEST_AVAILABLE_CAPABILITIES_RAW
  ///
  /// The camera device supports outputting RAW buffers and
  /// metadata for interpreting them.
  ///
  /// Devices supporting the RAW capability allow both for
  /// saving DNG files, and for direct application processing of
  /// raw sensor images.
  ///
  /// <ul>
  /// <li>RAW_SENSOR is supported as an output format.</li>
  /// <li>The maximum available resolution for RAW_SENSOR streams
  ///   will match either the value in
  ///   CameraCharacteristics\#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize or
  ///   CameraCharacteristics\#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize.</li>
  /// <li>All DNG-related optional metadata entries are provided
  ///   by the camera device.</li>
  /// </ul>
  ///@see CameraCharacteristics\#SENSOR_INFO_PIXEL_ARRAY_SIZE
  ///@see CameraCharacteristics\#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  static const REQUEST_AVAILABLE_CAPABILITIES_RAW = 3;

  /// from: static public final int REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS
  ///
  /// The camera device supports accurately reporting the sensor settings for many of
  /// the sensor controls while the built-in 3A algorithm is running.  This allows
  /// reporting of sensor settings even when these settings cannot be manually changed.
  ///
  /// The values reported for the following controls are guaranteed to be available
  /// in the CaptureResult, including when 3A is enabled:
  ///
  /// <ul>
  /// <li>Exposure control<ul>
  /// <li>CaptureRequest\#SENSOR_EXPOSURE_TIME android.sensor.exposureTime</li>
  /// </ul>
  /// </li>
  /// <li>Sensitivity control<ul>
  /// <li>CaptureRequest\#SENSOR_SENSITIVITY android.sensor.sensitivity</li>
  /// </ul>
  /// </li>
  /// <li>Lens controls (if the lens is adjustable)<ul>
  /// <li>CaptureRequest\#LENS_FOCUS_DISTANCE android.lens.focusDistance</li>
  /// <li>CaptureRequest\#LENS_APERTURE android.lens.aperture</li>
  /// </ul>
  /// </li>
  /// </ul>
  /// This capability is a subset of the MANUAL_SENSOR control capability, and will
  /// always be included if the MANUAL_SENSOR capability is available.
  ///
  ///@see CaptureRequest\#LENS_APERTURE
  ///@see CaptureRequest\#LENS_FOCUS_DISTANCE
  ///@see CaptureRequest\#SENSOR_EXPOSURE_TIME
  ///@see CaptureRequest\#SENSOR_SENSITIVITY
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  static const REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS = 5;

  /// from: static public final int REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING
  ///
  /// The camera device supports the YUV_420_888 reprocessing use case, similar as
  /// PRIVATE_REPROCESSING, This capability requires the camera device to support the
  /// following:
  ///
  /// <ul>
  /// <li>One input stream is supported, that is, <code>CameraCharacteristics\#REQUEST_MAX_NUM_INPUT_STREAMS android.request.maxNumInputStreams == 1</code>.</li>
  /// <li>android.graphics.ImageFormat\#YUV_420_888 is supported as an output/input
  ///   format, that is, YUV_420_888 is included in the lists of formats returned by android.hardware.camera2.params.StreamConfigurationMap\#getInputFormats and android.hardware.camera2.params.StreamConfigurationMap\#getOutputFormats.</li>
  /// <li>android.hardware.camera2.params.StreamConfigurationMap\#getValidOutputFormatsForInput
  ///   returns non-empty int[] for each supported input format returned by android.hardware.camera2.params.StreamConfigurationMap\#getInputFormats.</li>
  /// <li>Each size returned by android.hardware.camera2.params.StreamConfigurationMap\#getInputSizes getInputSizes(YUV_420_888) is also included in android.hardware.camera2.params.StreamConfigurationMap\#getOutputSizes getOutputSizes(YUV_420_888)</li>
  /// <li>Using android.graphics.ImageFormat\#YUV_420_888 does not cause a frame rate
  ///   drop relative to the sensor's maximum capture rate (at that resolution).</li>
  /// <li>android.graphics.ImageFormat\#YUV_420_888 will be reprocessable into both
  ///   android.graphics.ImageFormat\#YUV_420_888 and android.graphics.ImageFormat\#JPEG formats.</li>
  /// <li>The maximum available resolution for android.graphics.ImageFormat\#YUV_420_888 streams (both input/output) will match the
  ///   maximum available resolution of android.graphics.ImageFormat\#JPEG streams.</li>
  /// <li>Static metadata CameraCharacteristics\#REPROCESS_MAX_CAPTURE_STALL android.reprocess.maxCaptureStall.</li>
  /// <li>Only the below controls are effective for reprocessing requests and will be present
  ///   in capture results. The reprocess requests are from the original capture results
  ///   that are associated with the intermediate android.graphics.ImageFormat\#YUV_420_888 output buffers.  All other controls in the
  ///   reprocess requests will be ignored by the camera device.<ul>
  /// <li>android.jpeg.*</li>
  /// <li>CaptureRequest\#NOISE_REDUCTION_MODE android.noiseReduction.mode</li>
  /// <li>CaptureRequest\#EDGE_MODE android.edge.mode</li>
  /// <li>CaptureRequest\#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR android.reprocess.effectiveExposureFactor</li>
  /// </ul>
  /// </li>
  /// <li>CameraCharacteristics\#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES android.noiseReduction.availableNoiseReductionModes and
  ///   CameraCharacteristics\#EDGE_AVAILABLE_EDGE_MODES android.edge.availableEdgeModes will both list ZERO_SHUTTER_LAG as a supported mode.</li>
  /// </ul>
  ///@see CameraCharacteristics\#EDGE_AVAILABLE_EDGE_MODES
  ///@see CaptureRequest\#EDGE_MODE
  ///@see CameraCharacteristics\#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES
  ///@see CaptureRequest\#NOISE_REDUCTION_MODE
  ///@see CaptureRequest\#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR
  ///@see CameraCharacteristics\#REPROCESS_MAX_CAPTURE_STALL
  ///@see CameraCharacteristics\#REQUEST_MAX_NUM_INPUT_STREAMS
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  static const REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING = 7;

  /// from: static public final int SCALER_CROPPING_TYPE_CENTER_ONLY
  ///
  /// The camera device only supports centered crop regions.
  ///
  ///@see CameraCharacteristics\#SCALER_CROPPING_TYPE
  static const SCALER_CROPPING_TYPE_CENTER_ONLY = 0;

  /// from: static public final int SCALER_CROPPING_TYPE_FREEFORM
  ///
  /// The camera device supports arbitrarily chosen crop regions.
  ///
  ///@see CameraCharacteristics\#SCALER_CROPPING_TYPE
  static const SCALER_CROPPING_TYPE_FREEFORM = 1;

  /// from: static public final int SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_BGGR
  ///
  /// @see CameraCharacteristics\#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT
  static const SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_BGGR = 3;

  /// from: static public final int SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GBRG
  ///
  /// @see CameraCharacteristics\#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT
  static const SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GBRG = 2;

  /// from: static public final int SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GRBG
  ///
  /// @see CameraCharacteristics\#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT
  static const SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GRBG = 1;

  /// from: static public final int SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGB
  ///
  /// Sensor is not Bayer; output has 3 16-bit
  /// values for each pixel, instead of just 1 16-bit value
  /// per pixel.
  ///
  ///@see CameraCharacteristics\#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT
  static const SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGB = 4;

  /// from: static public final int SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGGB
  ///
  /// @see CameraCharacteristics\#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT
  static const SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGGB = 0;

  /// from: static public final int SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME
  ///
  /// Timestamps from CaptureResult\#SENSOR_TIMESTAMP android.sensor.timestamp are in the same timebase as
  /// android.os.SystemClock\#elapsedRealtimeNanos,
  /// and they can be compared to other timestamps using that base.
  ///
  ///@see CaptureResult\#SENSOR_TIMESTAMP
  ///@see CameraCharacteristics\#SENSOR_INFO_TIMESTAMP_SOURCE
  static const SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME = 1;

  /// from: static public final int SENSOR_INFO_TIMESTAMP_SOURCE_UNKNOWN
  ///
  /// Timestamps from CaptureResult\#SENSOR_TIMESTAMP android.sensor.timestamp are in nanoseconds and monotonic,
  /// but can not be compared to timestamps from other subsystems
  /// (e.g. accelerometer, gyro etc.), or other instances of the same or different
  /// camera devices in the same system. Timestamps between streams and results for
  /// a single camera instance are comparable, and the timestamps for all buffers
  /// and the result metadata generated by a single capture are identical.
  ///
  ///@see CaptureResult\#SENSOR_TIMESTAMP
  ///@see CameraCharacteristics\#SENSOR_INFO_TIMESTAMP_SOURCE
  static const SENSOR_INFO_TIMESTAMP_SOURCE_UNKNOWN = 0;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_CLOUDY_WEATHER
  ///
  /// @see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_CLOUDY_WEATHER = 10;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_COOL_WHITE_FLUORESCENT
  ///
  /// W 3900 - 4500K
  ///
  ///@see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_COOL_WHITE_FLUORESCENT = 14;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_D50
  ///
  /// @see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_D50 = 23;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_D55
  ///
  /// @see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_D55 = 20;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_D65
  ///
  /// @see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_D65 = 21;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_D75
  ///
  /// @see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_D75 = 22;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT
  ///
  /// @see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT = 1;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT_FLUORESCENT
  ///
  /// D 5700 - 7100K
  ///
  ///@see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT_FLUORESCENT = 12;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_DAY_WHITE_FLUORESCENT
  ///
  /// N 4600 - 5400K
  ///
  ///@see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_DAY_WHITE_FLUORESCENT = 13;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_FINE_WEATHER
  ///
  /// @see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_FINE_WEATHER = 9;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_FLASH
  ///
  /// @see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_FLASH = 4;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_FLUORESCENT
  ///
  /// @see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_FLUORESCENT = 2;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_ISO_STUDIO_TUNGSTEN
  ///
  /// @see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_ISO_STUDIO_TUNGSTEN = 24;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_SHADE
  ///
  /// @see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_SHADE = 11;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_STANDARD_A
  ///
  /// @see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_STANDARD_A = 17;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_STANDARD_B
  ///
  /// @see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_STANDARD_B = 18;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_STANDARD_C
  ///
  /// @see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_STANDARD_C = 19;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_TUNGSTEN
  ///
  /// Incandescent light
  ///
  ///@see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_TUNGSTEN = 3;

  /// from: static public final int SENSOR_REFERENCE_ILLUMINANT1_WHITE_FLUORESCENT
  ///
  /// WW 3200 - 3700K
  ///
  ///@see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static const SENSOR_REFERENCE_ILLUMINANT1_WHITE_FLUORESCENT = 15;

  /// from: static public final int SENSOR_TEST_PATTERN_MODE_COLOR_BARS
  ///
  /// All pixel data is replaced with an 8-bar color pattern.
  ///
  /// The vertical bars (left-to-right) are as follows:
  ///
  /// <ul>
  /// <li>100% white</li>
  /// <li>yellow</li>
  /// <li>cyan</li>
  /// <li>green</li>
  /// <li>magenta</li>
  /// <li>red</li>
  /// <li>blue</li>
  /// <li>black</li>
  /// </ul>
  /// In general the image would look like the following:
  ///
  /// <pre><code>W Y C G M R B K
  /// W Y C G M R B K
  /// W Y C G M R B K
  /// W Y C G M R B K
  /// W Y C G M R B K
  /// . . . . . . . .
  /// . . . . . . . .
  /// . . . . . . . .
  ///
  /// (B = Blue, K = Black)
  /// </code></pre>
  /// Each bar should take up 1/8 of the sensor pixel array width.
  /// When this is not possible, the bar size should be rounded
  /// down to the nearest integer and the pattern can repeat
  /// on the right side.
  ///
  /// Each bar's height must always take up the full sensor
  /// pixel array height.
  ///
  /// Each pixel in this test pattern must be set to either
  /// 0% intensity or 100% intensity.
  ///
  ///@see CaptureRequest\#SENSOR_TEST_PATTERN_MODE
  static const SENSOR_TEST_PATTERN_MODE_COLOR_BARS = 2;

  /// from: static public final int SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY
  ///
  /// The test pattern is similar to COLOR_BARS, except that
  /// each bar should start at its specified color at the top,
  /// and fade to gray at the bottom.
  ///
  /// Furthermore each bar is further subdivided into a left and
  /// right half. The left half should have a smooth gradient,
  /// and the right half should have a quantized gradient.
  ///
  /// In particular, the right half's should consist of blocks of the
  /// same color for 1/16th active sensor pixel array width.
  ///
  /// The least significant bits in the quantized gradient should
  /// be copied from the most significant bits of the smooth gradient.
  ///
  /// The height of each bar should always be a multiple of 128.
  /// When this is not the case, the pattern should repeat at the bottom
  /// of the image.
  ///
  ///@see CaptureRequest\#SENSOR_TEST_PATTERN_MODE
  static const SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY = 3;

  /// from: static public final int SENSOR_TEST_PATTERN_MODE_CUSTOM1
  ///
  /// The first custom test pattern. All custom patterns that are
  /// available only on this camera device are at least this numeric
  /// value.
  ///
  /// All of the custom test patterns will be static
  /// (that is the raw image must not vary from frame to frame).
  ///
  ///@see CaptureRequest\#SENSOR_TEST_PATTERN_MODE
  static const SENSOR_TEST_PATTERN_MODE_CUSTOM1 = 256;

  /// from: static public final int SENSOR_TEST_PATTERN_MODE_OFF
  ///
  /// No test pattern mode is used, and the camera
  /// device returns captures from the image sensor.
  ///
  /// This is the default if the key is not set.
  ///
  ///@see CaptureRequest\#SENSOR_TEST_PATTERN_MODE
  static const SENSOR_TEST_PATTERN_MODE_OFF = 0;

  /// from: static public final int SENSOR_TEST_PATTERN_MODE_PN9
  ///
  /// All pixel data is replaced by a pseudo-random sequence
  /// generated from a PN9 512-bit sequence (typically implemented
  /// in hardware with a linear feedback shift register).
  ///
  /// The generator should be reset at the beginning of each frame,
  /// and thus each subsequent raw frame with this test pattern should
  /// be exactly the same as the last.
  ///
  ///@see CaptureRequest\#SENSOR_TEST_PATTERN_MODE
  static const SENSOR_TEST_PATTERN_MODE_PN9 = 4;

  /// from: static public final int SENSOR_TEST_PATTERN_MODE_SOLID_COLOR
  ///
  /// Each pixel in <code>[R, G_even, G_odd, B]</code> is replaced by its
  /// respective color channel provided in
  /// CaptureRequest\#SENSOR_TEST_PATTERN_DATA android.sensor.testPatternData.
  ///
  /// For example:
  ///
  /// <pre><code>android.testPatternData = [0, 0xFFFFFFFF, 0xFFFFFFFF, 0]
  /// </code></pre>
  /// All green pixels are 100% green. All red/blue pixels are black.
  ///
  /// <pre><code>android.testPatternData = [0xFFFFFFFF, 0, 0xFFFFFFFF, 0]
  /// </code></pre>
  /// All red pixels are 100% red. Only the odd green pixels
  /// are 100% green. All blue pixels are 100% black.
  ///
  ///@see CaptureRequest\#SENSOR_TEST_PATTERN_DATA
  ///@see CaptureRequest\#SENSOR_TEST_PATTERN_MODE
  static const SENSOR_TEST_PATTERN_MODE_SOLID_COLOR = 1;

  /// from: static public final int SHADING_MODE_FAST
  ///
  /// Apply lens shading corrections, without slowing
  /// frame rate relative to sensor raw output
  ///
  ///@see CaptureRequest\#SHADING_MODE
  static const SHADING_MODE_FAST = 1;

  /// from: static public final int SHADING_MODE_HIGH_QUALITY
  ///
  /// Apply high-quality lens shading correction, at the
  /// cost of possibly reduced frame rate.
  ///
  ///@see CaptureRequest\#SHADING_MODE
  static const SHADING_MODE_HIGH_QUALITY = 2;

  /// from: static public final int SHADING_MODE_OFF
  ///
  /// No lens shading correction is applied.
  ///
  ///@see CaptureRequest\#SHADING_MODE
  static const SHADING_MODE_OFF = 0;

  /// from: static public final int STATISTICS_FACE_DETECT_MODE_FULL
  ///
  /// Return all face
  /// metadata.
  ///
  /// In this mode, face rectangles, scores, landmarks, and face IDs are all valid.
  ///
  ///@see CaptureRequest\#STATISTICS_FACE_DETECT_MODE
  static const STATISTICS_FACE_DETECT_MODE_FULL = 2;

  /// from: static public final int STATISTICS_FACE_DETECT_MODE_OFF
  ///
  /// Do not include face detection statistics in capture
  /// results.
  ///
  ///@see CaptureRequest\#STATISTICS_FACE_DETECT_MODE
  static const STATISTICS_FACE_DETECT_MODE_OFF = 0;

  /// from: static public final int STATISTICS_FACE_DETECT_MODE_SIMPLE
  ///
  /// Return face rectangle and confidence values only.
  ///
  ///@see CaptureRequest\#STATISTICS_FACE_DETECT_MODE
  static const STATISTICS_FACE_DETECT_MODE_SIMPLE = 1;

  /// from: static public final int STATISTICS_LENS_SHADING_MAP_MODE_OFF
  ///
  /// Do not include a lens shading map in the capture result.
  ///
  ///@see CaptureRequest\#STATISTICS_LENS_SHADING_MAP_MODE
  static const STATISTICS_LENS_SHADING_MAP_MODE_OFF = 0;

  /// from: static public final int STATISTICS_LENS_SHADING_MAP_MODE_ON
  ///
  /// Include a lens shading map in the capture result.
  ///
  ///@see CaptureRequest\#STATISTICS_LENS_SHADING_MAP_MODE
  static const STATISTICS_LENS_SHADING_MAP_MODE_ON = 1;

  /// from: static public final int STATISTICS_OIS_DATA_MODE_OFF
  ///
  /// Do not include OIS data in the capture result.
  ///
  ///@see CaptureRequest\#STATISTICS_OIS_DATA_MODE
  static const STATISTICS_OIS_DATA_MODE_OFF = 0;

  /// from: static public final int STATISTICS_OIS_DATA_MODE_ON
  ///
  /// Include OIS data in the capture result.
  ///
  /// CaptureResult\#STATISTICS_OIS_SAMPLES android.statistics.oisSamples provides OIS sample data in the
  /// output result metadata.
  ///
  ///@see CaptureResult\#STATISTICS_OIS_SAMPLES
  ///@see CaptureRequest\#STATISTICS_OIS_DATA_MODE
  static const STATISTICS_OIS_DATA_MODE_ON = 1;

  /// from: static public final int STATISTICS_SCENE_FLICKER_50HZ
  ///
  /// The camera device detects illumination flickering at 50Hz
  /// in the current scene.
  ///
  ///@see CaptureResult\#STATISTICS_SCENE_FLICKER
  static const STATISTICS_SCENE_FLICKER_50HZ = 1;

  /// from: static public final int STATISTICS_SCENE_FLICKER_60HZ
  ///
  /// The camera device detects illumination flickering at 60Hz
  /// in the current scene.
  ///
  ///@see CaptureResult\#STATISTICS_SCENE_FLICKER
  static const STATISTICS_SCENE_FLICKER_60HZ = 2;

  /// from: static public final int STATISTICS_SCENE_FLICKER_NONE
  ///
  /// The camera device does not detect any flickering illumination
  /// in the current scene.
  ///
  ///@see CaptureResult\#STATISTICS_SCENE_FLICKER
  static const STATISTICS_SCENE_FLICKER_NONE = 0;

  /// from: static public final int SYNC_MAX_LATENCY_PER_FRAME_CONTROL
  ///
  /// Every frame has the requests immediately applied.
  ///
  /// Changing controls over multiple requests one after another will
  /// produce results that have those controls applied atomically
  /// each frame.
  ///
  /// All FULL capability devices will have this as their maxLatency.
  ///
  ///@see CameraCharacteristics\#SYNC_MAX_LATENCY
  static const SYNC_MAX_LATENCY_PER_FRAME_CONTROL = 0;

  /// from: static public final int SYNC_MAX_LATENCY_UNKNOWN
  ///
  /// Each new frame has some subset (potentially the entire set)
  /// of the past requests applied to the camera settings.
  ///
  /// By submitting a series of identical requests, the camera device
  /// will eventually have the camera settings applied, but it is
  /// unknown when that exact point will be.
  ///
  /// All LEGACY capability devices will have this as their maxLatency.
  ///
  ///@see CameraCharacteristics\#SYNC_MAX_LATENCY
  static const SYNC_MAX_LATENCY_UNKNOWN = -1;

  /// from: static public final int TONEMAP_MODE_CONTRAST_CURVE
  ///
  /// Use the tone mapping curve specified in
  /// the CaptureRequest\#TONEMAP_CURVE android.tonemap.curve* entries.
  ///
  /// All color enhancement and tonemapping must be disabled, except
  /// for applying the tonemapping curve specified by
  /// CaptureRequest\#TONEMAP_CURVE android.tonemap.curve.
  ///
  /// Must not slow down frame rate relative to raw
  /// sensor output.
  ///
  ///@see CaptureRequest\#TONEMAP_CURVE
  ///@see CaptureRequest\#TONEMAP_MODE
  static const TONEMAP_MODE_CONTRAST_CURVE = 0;

  /// from: static public final int TONEMAP_MODE_FAST
  ///
  /// Advanced gamma mapping and color enhancement may be applied, without
  /// reducing frame rate compared to raw sensor output.
  ///
  ///@see CaptureRequest\#TONEMAP_MODE
  static const TONEMAP_MODE_FAST = 1;

  /// from: static public final int TONEMAP_MODE_GAMMA_VALUE
  ///
  /// Use the gamma value specified in CaptureRequest\#TONEMAP_GAMMA android.tonemap.gamma to peform
  /// tonemapping.
  ///
  /// All color enhancement and tonemapping must be disabled, except
  /// for applying the tonemapping curve specified by CaptureRequest\#TONEMAP_GAMMA android.tonemap.gamma.
  ///
  /// Must not slow down frame rate relative to raw sensor output.
  ///
  ///@see CaptureRequest\#TONEMAP_GAMMA
  ///@see CaptureRequest\#TONEMAP_MODE
  static const TONEMAP_MODE_GAMMA_VALUE = 3;

  /// from: static public final int TONEMAP_MODE_HIGH_QUALITY
  ///
  /// High-quality gamma mapping and color enhancement will be applied, at
  /// the cost of possibly reduced frame rate compared to raw sensor output.
  ///
  ///@see CaptureRequest\#TONEMAP_MODE
  static const TONEMAP_MODE_HIGH_QUALITY = 2;

  /// from: static public final int TONEMAP_MODE_PRESET_CURVE
  ///
  /// Use the preset tonemapping curve specified in
  /// CaptureRequest\#TONEMAP_PRESET_CURVE android.tonemap.presetCurve to peform tonemapping.
  ///
  /// All color enhancement and tonemapping must be disabled, except
  /// for applying the tonemapping curve specified by
  /// CaptureRequest\#TONEMAP_PRESET_CURVE android.tonemap.presetCurve.
  ///
  /// Must not slow down frame rate relative to raw sensor output.
  ///
  ///@see CaptureRequest\#TONEMAP_PRESET_CURVE
  ///@see CaptureRequest\#TONEMAP_MODE
  static const TONEMAP_MODE_PRESET_CURVE = 4;

  /// from: static public final int TONEMAP_PRESET_CURVE_REC709
  ///
  /// Tonemapping curve is defined by ITU-R BT.709
  ///
  ///@see CaptureRequest\#TONEMAP_PRESET_CURVE
  static const TONEMAP_PRESET_CURVE_REC709 = 1;

  /// from: static public final int TONEMAP_PRESET_CURVE_SRGB
  ///
  /// Tonemapping curve is defined by sRGB
  ///
  ///@see CaptureRequest\#TONEMAP_PRESET_CURVE
  static const TONEMAP_PRESET_CURVE_SRGB = 0;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a camera metadata field to a value. The field definitions can be
  /// found in CameraCharacteristics, CaptureResult, and
  /// CaptureRequest.
  ///@param key The metadata field to write.
  ///@param value The value to set the field to, which must be of a matching
  /// type to the key.
  ///@hide
  CameraMetadata()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getKeys =
      jniAccessors.getMethodIDOf(_classRef, "getKeys", "()Ljava/util/List;");

  /// from: public java.util.List<TKey> getKeys()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of the keys contained in this map.
  ///
  /// The list returned is not modifiable, so any attempts to modify it will throw
  /// a {@code UnsupportedOperationException}.
  ///
  ///
  /// All values retrieved by a key from this list with {@code \#get} are guaranteed to be
  /// non-{@code null}. Each key is only listed once in the list. The order of the keys
  /// is undefined.
  ///
  ///@return List of the keys contained in this map.
  jni.JniObject getKeys() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getKeys, jni.JniType.objectType, []).object);
}
