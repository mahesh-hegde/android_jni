// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "CameraMetadata.dart" as camerametadata_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.camera2.CameraCharacteristics
///
/// The properties describing a
/// CameraDevice CameraDevice.
///
///
/// These properties are fixed for a given CameraDevice, and can be queried
/// through the CameraManager CameraManager
/// interface with CameraManager\#getCameraCharacteristics.
///
///
/// CameraCharacteristics objects are immutable.
///
///@see CameraDevice
///@see CameraManager
class CameraCharacteristics extends camerametadata_.CameraMetadata {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/camera2/CameraCharacteristics");
  CameraCharacteristics.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of aberration correction modes for CaptureRequest\#COLOR_CORRECTION_ABERRATION_MODE android.colorCorrection.aberrationMode that are
  /// supported by this camera device.
  ///
  /// This key lists the valid modes for CaptureRequest\#COLOR_CORRECTION_ABERRATION_MODE android.colorCorrection.aberrationMode.  If no
  /// aberration correction modes are available for a device, this list will solely include
  /// OFF mode. All camera devices will support either OFF or FAST mode.
  ///
  /// Camera devices that support the MANUAL_POST_PROCESSING capability will always list
  /// OFF mode. This includes all FULL level devices.
  ///
  /// LEGACY devices will always only support FAST mode.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#COLOR_CORRECTION_ABERRATION_MODE android.colorCorrection.aberrationMode
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#COLOR_CORRECTION_ABERRATION_MODE
  static CameraCharacteristics_Key
      get COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES =>
          CameraCharacteristics_Key.fromRef(jniAccessors
              .getStaticField(
                  _classRef,
                  _id_COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES,
                  jni.JniType.objectType)
              .object);

  static final _id_CONTROL_AE_AVAILABLE_ANTIBANDING_MODES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "CONTROL_AE_AVAILABLE_ANTIBANDING_MODES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> CONTROL_AE_AVAILABLE_ANTIBANDING_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of auto-exposure antibanding modes for CaptureRequest\#CONTROL_AE_ANTIBANDING_MODE android.control.aeAntibandingMode that are
  /// supported by this camera device.
  ///
  /// Not all of the auto-exposure anti-banding modes may be
  /// supported by a given camera device. This field lists the
  /// valid anti-banding modes that the application may request
  /// for this camera device with the
  /// CaptureRequest\#CONTROL_AE_ANTIBANDING_MODE android.control.aeAntibandingMode control.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#CONTROL_AE_ANTIBANDING_MODE android.control.aeAntibandingMode
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#CONTROL_AE_ANTIBANDING_MODE
  static CameraCharacteristics_Key get CONTROL_AE_AVAILABLE_ANTIBANDING_MODES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CONTROL_AE_AVAILABLE_ANTIBANDING_MODES,
              jni.JniType.objectType)
          .object);

  static final _id_CONTROL_AE_AVAILABLE_MODES = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "CONTROL_AE_AVAILABLE_MODES",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> CONTROL_AE_AVAILABLE_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of auto-exposure modes for CaptureRequest\#CONTROL_AE_MODE android.control.aeMode that are supported by this camera
  /// device.
  ///
  /// Not all the auto-exposure modes may be supported by a
  /// given camera device, especially if no flash unit is
  /// available. This entry lists the valid modes for
  /// CaptureRequest\#CONTROL_AE_MODE android.control.aeMode for this camera device.
  ///
  /// All camera devices support ON, and all camera devices with flash
  /// units support ON_AUTO_FLASH and ON_ALWAYS_FLASH.
  ///
  /// FULL mode camera devices always support OFF mode,
  /// which enables application control of camera exposure time,
  /// sensitivity, and frame duration.
  ///
  /// LEGACY mode camera devices never support OFF mode.
  /// LIMITED mode devices support OFF if they support the MANUAL_SENSOR
  /// capability.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#CONTROL_AE_MODE android.control.aeMode
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#CONTROL_AE_MODE
  static CameraCharacteristics_Key get CONTROL_AE_AVAILABLE_MODES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_CONTROL_AE_AVAILABLE_MODES, jni.JniType.objectType)
          .object);

  static final _id_CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.util.Range<java.lang.Integer>[]> CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of frame rate ranges for CaptureRequest\#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange supported by
  /// this camera device.
  ///
  /// For devices at the LEGACY level or above:
  ///
  /// <ul>
  /// <li>
  /// For constant-framerate recording, for each normal
  /// android.media.CamcorderProfile CamcorderProfile, that is, a
  /// android.media.CamcorderProfile CamcorderProfile that has
  /// android.media.CamcorderProfile\#quality quality in
  /// the range [android.media.CamcorderProfile\#QUALITY_LOW QUALITY_LOW,
  /// android.media.CamcorderProfile\#QUALITY_2160P QUALITY_2160P], if the profile is
  /// supported by the device and has
  /// android.media.CamcorderProfile\#videoFrameRate videoFrameRate <code>x</code>, this list will
  /// always include (<code>x</code>,<code>x</code>).
  ///
  /// </li>
  /// <li>
  /// Also, a camera device must either not support any
  /// android.media.CamcorderProfile CamcorderProfile,
  /// or support at least one
  /// normal android.media.CamcorderProfile CamcorderProfile that has
  /// android.media.CamcorderProfile\#videoFrameRate videoFrameRate <code>x</code> &gt;= 24.
  ///
  /// </li>
  /// </ul>
  /// For devices at the LIMITED level or above:
  ///
  /// <ul>
  /// <li>For YUV_420_888 burst capture use case, this list will always include (<code>min</code>, <code>max</code>)
  /// and (<code>max</code>, <code>max</code>) where <code>min</code> &lt;= 15 and <code>max</code> = the maximum output frame rate of the
  /// maximum YUV_420_888 output size.</li>
  /// </ul>
  /// __Units__: Frames per second (FPS)
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#CONTROL_AE_TARGET_FPS_RANGE
  static CameraCharacteristics_Key get CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES,
              jni.JniType.objectType)
          .object);

  static final _id_CONTROL_AE_COMPENSATION_RANGE =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "CONTROL_AE_COMPENSATION_RANGE",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.util.Range<java.lang.Integer>> CONTROL_AE_COMPENSATION_RANGE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Maximum and minimum exposure compensation values for
  /// CaptureRequest\#CONTROL_AE_EXPOSURE_COMPENSATION android.control.aeExposureCompensation, in counts of CameraCharacteristics\#CONTROL_AE_COMPENSATION_STEP android.control.aeCompensationStep,
  /// that are supported by this camera device.
  ///
  /// __Range of valid values:__<br>
  ///
  /// Range [0,0] indicates that exposure compensation is not supported.
  ///
  /// For LIMITED and FULL devices, range must follow below requirements if exposure
  /// compensation is supported (<code>range != [0, 0]</code>):
  ///
  /// <code>Min.exposure compensation * CameraCharacteristics\#CONTROL_AE_COMPENSATION_STEP android.control.aeCompensationStep &lt;= -2 EV</code>
  ///
  /// <code>Max.exposure compensation * CameraCharacteristics\#CONTROL_AE_COMPENSATION_STEP android.control.aeCompensationStep &gt;= 2 EV</code>
  ///
  /// LEGACY devices may support a smaller range than this.
  ///
  /// This key is available on all devices.
  ///
  ///@see CameraCharacteristics\#CONTROL_AE_COMPENSATION_STEP
  ///@see CaptureRequest\#CONTROL_AE_EXPOSURE_COMPENSATION
  static CameraCharacteristics_Key get CONTROL_AE_COMPENSATION_RANGE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CONTROL_AE_COMPENSATION_RANGE,
              jni.JniType.objectType)
          .object);

  static final _id_CONTROL_AE_COMPENSATION_STEP =
      jniAccessors.getStaticFieldIDOf(_classRef, "CONTROL_AE_COMPENSATION_STEP",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.util.Rational> CONTROL_AE_COMPENSATION_STEP
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Smallest step by which the exposure compensation
  /// can be changed.
  ///
  /// This is the unit for CaptureRequest\#CONTROL_AE_EXPOSURE_COMPENSATION android.control.aeExposureCompensation. For example, if this key has
  /// a value of <code>1/2</code>, then a setting of <code>-2</code> for CaptureRequest\#CONTROL_AE_EXPOSURE_COMPENSATION android.control.aeExposureCompensation means
  /// that the target EV offset for the auto-exposure routine is -1 EV.
  ///
  /// One unit of EV compensation changes the brightness of the captured image by a factor
  /// of two. +1 EV doubles the image brightness, while -1 EV halves the image brightness.
  ///
  /// __Units__: Exposure Value (EV)
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#CONTROL_AE_EXPOSURE_COMPENSATION
  static CameraCharacteristics_Key get CONTROL_AE_COMPENSATION_STEP =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CONTROL_AE_COMPENSATION_STEP,
              jni.JniType.objectType)
          .object);

  static final _id_CONTROL_AE_LOCK_AVAILABLE = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "CONTROL_AE_LOCK_AVAILABLE",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Boolean> CONTROL_AE_LOCK_AVAILABLE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Whether the camera device supports CaptureRequest\#CONTROL_AE_LOCK android.control.aeLock
  ///
  /// Devices with MANUAL_SENSOR capability or BURST_CAPTURE capability will always
  /// list <code>true</code>. This includes FULL devices.
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#CONTROL_AE_LOCK
  static CameraCharacteristics_Key get CONTROL_AE_LOCK_AVAILABLE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_CONTROL_AE_LOCK_AVAILABLE, jni.JniType.objectType)
          .object);

  static final _id_CONTROL_AF_AVAILABLE_MODES = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "CONTROL_AF_AVAILABLE_MODES",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> CONTROL_AF_AVAILABLE_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of auto-focus (AF) modes for CaptureRequest\#CONTROL_AF_MODE android.control.afMode that are
  /// supported by this camera device.
  ///
  /// Not all the auto-focus modes may be supported by a
  /// given camera device. This entry lists the valid modes for
  /// CaptureRequest\#CONTROL_AF_MODE android.control.afMode for this camera device.
  ///
  /// All LIMITED and FULL mode camera devices will support OFF mode, and all
  /// camera devices with adjustable focuser units
  /// (<code>CameraCharacteristics\#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance &gt; 0</code>) will support AUTO mode.
  ///
  /// LEGACY devices will support OFF mode only if they support
  /// focusing to infinity (by also setting CaptureRequest\#LENS_FOCUS_DISTANCE android.lens.focusDistance to
  /// <code>0.0f</code>).
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#CONTROL_AF_MODE android.control.afMode
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#CONTROL_AF_MODE
  ///@see CaptureRequest\#LENS_FOCUS_DISTANCE
  ///@see CameraCharacteristics\#LENS_INFO_MINIMUM_FOCUS_DISTANCE
  static CameraCharacteristics_Key get CONTROL_AF_AVAILABLE_MODES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_CONTROL_AF_AVAILABLE_MODES, jni.JniType.objectType)
          .object);

  static final _id_CONTROL_AVAILABLE_EFFECTS = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "CONTROL_AVAILABLE_EFFECTS",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> CONTROL_AVAILABLE_EFFECTS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of color effects for CaptureRequest\#CONTROL_EFFECT_MODE android.control.effectMode that are supported by this camera
  /// device.
  ///
  /// This list contains the color effect modes that can be applied to
  /// images produced by the camera device.
  /// Implementations are not expected to be consistent across all devices.
  /// If no color effect modes are available for a device, this will only list
  /// OFF.
  ///
  /// A color effect will only be applied if
  /// CaptureRequest\#CONTROL_MODE android.control.mode != OFF.  OFF is always included in this list.
  ///
  /// This control has no effect on the operation of other control routines such
  /// as auto-exposure, white balance, or focus.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#CONTROL_EFFECT_MODE android.control.effectMode
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#CONTROL_EFFECT_MODE
  ///@see CaptureRequest\#CONTROL_MODE
  static CameraCharacteristics_Key get CONTROL_AVAILABLE_EFFECTS =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_CONTROL_AVAILABLE_EFFECTS, jni.JniType.objectType)
          .object);

  static final _id_CONTROL_AVAILABLE_MODES = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "CONTROL_AVAILABLE_MODES",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> CONTROL_AVAILABLE_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of control modes for CaptureRequest\#CONTROL_MODE android.control.mode that are supported by this camera
  /// device.
  ///
  /// This list contains control modes that can be set for the camera device.
  /// LEGACY mode devices will always support AUTO mode. LIMITED and FULL
  /// devices will always support OFF, AUTO modes.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#CONTROL_MODE android.control.mode
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#CONTROL_MODE
  static CameraCharacteristics_Key get CONTROL_AVAILABLE_MODES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_CONTROL_AVAILABLE_MODES, jni.JniType.objectType)
          .object);

  static final _id_CONTROL_AVAILABLE_SCENE_MODES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "CONTROL_AVAILABLE_SCENE_MODES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> CONTROL_AVAILABLE_SCENE_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of scene modes for CaptureRequest\#CONTROL_SCENE_MODE android.control.sceneMode that are supported by this camera
  /// device.
  ///
  /// This list contains scene modes that can be set for the camera device.
  /// Only scene modes that have been fully implemented for the
  /// camera device may be included here. Implementations are not expected
  /// to be consistent across all devices.
  ///
  /// If no scene modes are supported by the camera device, this
  /// will be set to DISABLED. Otherwise DISABLED will not be listed.
  ///
  /// FACE_PRIORITY is always listed if face detection is
  /// supported (i.e.<code>CameraCharacteristics\#STATISTICS_INFO_MAX_FACE_COUNT android.statistics.info.maxFaceCount &gt;
  /// 0</code>).
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#CONTROL_SCENE_MODE android.control.sceneMode
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#CONTROL_SCENE_MODE
  ///@see CameraCharacteristics\#STATISTICS_INFO_MAX_FACE_COUNT
  static CameraCharacteristics_Key get CONTROL_AVAILABLE_SCENE_MODES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CONTROL_AVAILABLE_SCENE_MODES,
              jni.JniType.objectType)
          .object);

  static final _id_CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of video stabilization modes for CaptureRequest\#CONTROL_VIDEO_STABILIZATION_MODE android.control.videoStabilizationMode
  /// that are supported by this camera device.
  ///
  /// OFF will always be listed.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#CONTROL_VIDEO_STABILIZATION_MODE android.control.videoStabilizationMode
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#CONTROL_VIDEO_STABILIZATION_MODE
  static CameraCharacteristics_Key
      get CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES =>
          CameraCharacteristics_Key.fromRef(jniAccessors
              .getStaticField(
                  _classRef,
                  _id_CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES,
                  jni.JniType.objectType)
              .object);

  static final _id_CONTROL_AWB_AVAILABLE_MODES =
      jniAccessors.getStaticFieldIDOf(_classRef, "CONTROL_AWB_AVAILABLE_MODES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> CONTROL_AWB_AVAILABLE_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of auto-white-balance modes for CaptureRequest\#CONTROL_AWB_MODE android.control.awbMode that are supported by this
  /// camera device.
  ///
  /// Not all the auto-white-balance modes may be supported by a
  /// given camera device. This entry lists the valid modes for
  /// CaptureRequest\#CONTROL_AWB_MODE android.control.awbMode for this camera device.
  ///
  /// All camera devices will support ON mode.
  ///
  /// Camera devices that support the MANUAL_POST_PROCESSING capability will always support OFF
  /// mode, which enables application control of white balance, by using
  /// CaptureRequest\#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform and CaptureRequest\#COLOR_CORRECTION_GAINS android.colorCorrection.gains(CaptureRequest\#COLOR_CORRECTION_MODE android.colorCorrection.mode must be set to TRANSFORM_MATRIX). This includes all FULL
  /// mode camera devices.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#CONTROL_AWB_MODE android.control.awbMode
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#COLOR_CORRECTION_GAINS
  ///@see CaptureRequest\#COLOR_CORRECTION_MODE
  ///@see CaptureRequest\#COLOR_CORRECTION_TRANSFORM
  ///@see CaptureRequest\#CONTROL_AWB_MODE
  static CameraCharacteristics_Key get CONTROL_AWB_AVAILABLE_MODES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CONTROL_AWB_AVAILABLE_MODES,
              jni.JniType.objectType)
          .object);

  static final _id_CONTROL_AWB_LOCK_AVAILABLE = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "CONTROL_AWB_LOCK_AVAILABLE",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Boolean> CONTROL_AWB_LOCK_AVAILABLE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Whether the camera device supports CaptureRequest\#CONTROL_AWB_LOCK android.control.awbLock
  ///
  /// Devices with MANUAL_POST_PROCESSING capability or BURST_CAPTURE capability will
  /// always list <code>true</code>. This includes FULL devices.
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#CONTROL_AWB_LOCK
  static CameraCharacteristics_Key get CONTROL_AWB_LOCK_AVAILABLE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_CONTROL_AWB_LOCK_AVAILABLE, jni.JniType.objectType)
          .object);

  static final _id_CONTROL_MAX_REGIONS_AE = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "CONTROL_MAX_REGIONS_AE",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> CONTROL_MAX_REGIONS_AE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The maximum number of metering regions that can be used by the auto-exposure (AE)
  /// routine.
  ///
  /// This corresponds to the the maximum allowed number of elements in
  /// CaptureRequest\#CONTROL_AE_REGIONS android.control.aeRegions.
  ///
  /// __Range of valid values:__<br>
  /// Value will be &gt;= 0. For FULL-capability devices, this
  /// value will be &gt;= 1.
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#CONTROL_AE_REGIONS
  static CameraCharacteristics_Key get CONTROL_MAX_REGIONS_AE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_CONTROL_MAX_REGIONS_AE, jni.JniType.objectType)
          .object);

  static final _id_CONTROL_MAX_REGIONS_AF = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "CONTROL_MAX_REGIONS_AF",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> CONTROL_MAX_REGIONS_AF
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The maximum number of metering regions that can be used by the auto-focus (AF) routine.
  ///
  /// This corresponds to the the maximum allowed number of elements in
  /// CaptureRequest\#CONTROL_AF_REGIONS android.control.afRegions.
  ///
  /// __Range of valid values:__<br>
  /// Value will be &gt;= 0. For FULL-capability devices, this
  /// value will be &gt;= 1.
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#CONTROL_AF_REGIONS
  static CameraCharacteristics_Key get CONTROL_MAX_REGIONS_AF =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_CONTROL_MAX_REGIONS_AF, jni.JniType.objectType)
          .object);

  static final _id_CONTROL_MAX_REGIONS_AWB = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "CONTROL_MAX_REGIONS_AWB",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> CONTROL_MAX_REGIONS_AWB
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The maximum number of metering regions that can be used by the auto-white balance (AWB)
  /// routine.
  ///
  /// This corresponds to the the maximum allowed number of elements in
  /// CaptureRequest\#CONTROL_AWB_REGIONS android.control.awbRegions.
  ///
  /// __Range of valid values:__<br>
  /// Value will be &gt;= 0.
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#CONTROL_AWB_REGIONS
  static CameraCharacteristics_Key get CONTROL_MAX_REGIONS_AWB =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_CONTROL_MAX_REGIONS_AWB, jni.JniType.objectType)
          .object);

  static final _id_CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.util.Range<java.lang.Integer>> CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Range of boosts for CaptureRequest\#CONTROL_POST_RAW_SENSITIVITY_BOOST android.control.postRawSensitivityBoost supported
  /// by this camera device.
  ///
  /// Devices support post RAW sensitivity boost  will advertise
  /// CaptureRequest\#CONTROL_POST_RAW_SENSITIVITY_BOOST android.control.postRawSensitivityBoost key for controling
  /// post RAW sensitivity boost.
  ///
  /// This key will be <code>null</code> for devices that do not support any RAW format
  /// outputs. For devices that do support RAW format outputs, this key will always
  /// present, and if a device does not support post RAW sensitivity boost, it will
  /// list <code>(100, 100)</code> in this key.
  ///
  /// __Units__: ISO arithmetic units, the same as CaptureRequest\#SENSOR_SENSITIVITY android.sensor.sensitivity
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CaptureRequest\#CONTROL_POST_RAW_SENSITIVITY_BOOST
  ///@see CaptureRequest\#SENSOR_SENSITIVITY
  static CameraCharacteristics_Key
      get CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE =>
          CameraCharacteristics_Key.fromRef(jniAccessors
              .getStaticField(
                  _classRef,
                  _id_CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE,
                  jni.JniType.objectType)
              .object);

  static final _id_DEPTH_DEPTH_IS_EXCLUSIVE = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "DEPTH_DEPTH_IS_EXCLUSIVE",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Boolean> DEPTH_DEPTH_IS_EXCLUSIVE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Indicates whether a capture request may target both a
  /// DEPTH16 / DEPTH_POINT_CLOUD output, and normal color outputs (such as
  /// YUV_420_888, JPEG, or RAW) simultaneously.
  ///
  /// If TRUE, including both depth and color outputs in a single
  /// capture request is not supported. An application must interleave color
  /// and depth requests.  If FALSE, a single request can target both types
  /// of output.
  ///
  /// Typically, this restriction exists on camera devices that
  /// need to emit a specific pattern or wavelength of light to
  /// measure depth values, which causes the color image to be
  /// corrupted during depth measurement.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Limited capability__ -
  /// Present on all camera devices that report being at least CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  static CameraCharacteristics_Key get DEPTH_DEPTH_IS_EXCLUSIVE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_DEPTH_DEPTH_IS_EXCLUSIVE, jni.JniType.objectType)
          .object);

  static final _id_DISTORTION_CORRECTION_AVAILABLE_MODES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "DISTORTION_CORRECTION_AVAILABLE_MODES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> DISTORTION_CORRECTION_AVAILABLE_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of distortion correction modes for CaptureRequest\#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode that are
  /// supported by this camera device.
  ///
  /// No device is required to support this API; such devices will always list only 'OFF'.
  /// All devices that support this API will list both FAST and HIGH_QUALITY.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CaptureRequest\#DISTORTION_CORRECTION_MODE
  static CameraCharacteristics_Key get DISTORTION_CORRECTION_AVAILABLE_MODES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_DISTORTION_CORRECTION_AVAILABLE_MODES,
              jni.JniType.objectType)
          .object);

  static final _id_EDGE_AVAILABLE_EDGE_MODES = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "EDGE_AVAILABLE_EDGE_MODES",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> EDGE_AVAILABLE_EDGE_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of edge enhancement modes for CaptureRequest\#EDGE_MODE android.edge.mode that are supported by this camera
  /// device.
  ///
  /// Full-capability camera devices must always support OFF; camera devices that support
  /// YUV_REPROCESSING or PRIVATE_REPROCESSING will list ZERO_SHUTTER_LAG; all devices will
  /// list FAST.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#EDGE_MODE android.edge.mode
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Full capability__ -
  /// Present on all camera devices that report being CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CaptureRequest\#EDGE_MODE
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  static CameraCharacteristics_Key get EDGE_AVAILABLE_EDGE_MODES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_EDGE_AVAILABLE_EDGE_MODES, jni.JniType.objectType)
          .object);

  static final _id_FLASH_INFO_AVAILABLE = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "FLASH_INFO_AVAILABLE",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Boolean> FLASH_INFO_AVAILABLE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Whether this camera device has a
  /// flash unit.
  ///
  /// Will be <code>false</code> if no flash is available.
  ///
  /// If there is no flash unit, none of the flash controls do
  /// anything.
  /// This key is available on all devices.
  ///
  static CameraCharacteristics_Key get FLASH_INFO_AVAILABLE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_FLASH_INFO_AVAILABLE, jni.JniType.objectType)
          .object);

  static final _id_HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of hot pixel correction modes for CaptureRequest\#HOT_PIXEL_MODE android.hotPixel.mode that are supported by this
  /// camera device.
  ///
  /// FULL mode camera devices will always support FAST.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#HOT_PIXEL_MODE android.hotPixel.mode
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CaptureRequest\#HOT_PIXEL_MODE
  static CameraCharacteristics_Key get HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES,
              jni.JniType.objectType)
          .object);

  static final _id_INFO_SUPPORTED_HARDWARE_LEVEL =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "INFO_SUPPORTED_HARDWARE_LEVEL",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> INFO_SUPPORTED_HARDWARE_LEVEL
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Generally classifies the overall set of the camera device functionality.
  ///
  /// The supported hardware level is a high-level description of the camera device's
  /// capabilities, summarizing several capabilities into one field.  Each level adds additional
  /// features to the previous one, and is always a strict superset of the previous level.
  /// The ordering is <code>LEGACY &lt; LIMITED &lt; FULL &lt; LEVEL_3</code>.
  ///
  /// Starting from <code>LEVEL_3</code>, the level enumerations are guaranteed to be in increasing
  /// numerical value as well. To check if a given device is at least at a given hardware level,
  /// the following code snippet can be used:
  ///
  /// <pre><code>// Returns true if the device supports the required hardware level, or better.
  /// boolean isHardwareLevelSupported(CameraCharacteristics c, int requiredLevel) {
  ///     final int[] sortedHwLevels = {
  ///         CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY,
  ///         CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL,
  ///         CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED,
  ///         CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_FULL,
  ///         CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_3
  ///     };
  ///     int deviceLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);
  ///     if (requiredLevel == deviceLevel) {
  ///         return true;
  ///     }
  ///
  ///     for (int sortedlevel : sortedHwLevels) {
  ///         if (sortedlevel == requiredLevel) {
  ///             return true;
  ///         } else if (sortedlevel == deviceLevel) {
  ///             return false;
  ///         }
  ///     }
  ///     return false; // Should never reach here
  /// }
  /// </code></pre>
  /// At a high level, the levels are:
  ///
  /// <ul>
  /// <li><code>LEGACY</code> devices operate in a backwards-compatibility mode for older
  ///   Android devices, and have very limited capabilities.</li>
  /// <li><code>LIMITED</code> devices represent the
  ///   baseline feature set, and may also include additional capabilities that are
  ///   subsets of <code>FULL</code>.</li>
  /// <li><code>FULL</code> devices additionally support per-frame manual control of sensor, flash, lens and
  ///   post-processing settings, and image capture at a high rate.</li>
  /// <li><code>LEVEL_3</code> devices additionally support YUV reprocessing and RAW image capture, along
  ///   with additional output stream configurations.</li>
  /// <li><code>EXTERNAL</code> devices are similar to <code>LIMITED</code> devices with exceptions like some sensor or
  ///   lens information not reorted or less stable framerates.</li>
  /// </ul>
  /// See the individual level enums for full descriptions of the supported capabilities.  The
  /// CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities entry describes the device's capabilities at a
  /// finer-grain level, if needed. In addition, many controls have their available settings or
  /// ranges defined in individual entries from android.hardware.camera2.CameraCharacteristics.
  ///
  /// Some features are not part of any particular hardware level or capability and must be
  /// queried separately. These include:
  ///
  /// <ul>
  /// <li>Calibrated timestamps (CameraCharacteristics\#SENSOR_INFO_TIMESTAMP_SOURCE android.sensor.info.timestampSource <code>==</code> REALTIME)</li>
  /// <li>Precision lens control (CameraCharacteristics\#LENS_INFO_FOCUS_DISTANCE_CALIBRATION android.lens.info.focusDistanceCalibration <code>==</code> CALIBRATED)</li>
  /// <li>Face detection (CameraCharacteristics\#STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES android.statistics.info.availableFaceDetectModes)</li>
  /// <li>Optical or electrical image stabilization
  ///   (CameraCharacteristics\#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION android.lens.info.availableOpticalStabilization,
  ///    CameraCharacteristics\#CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES android.control.availableVideoStabilizationModes)</li>
  /// </ul>
  /// __Possible values:__
  /// <ul>
  ///   <li>\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED</li>
  ///   <li>\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL</li>
  ///   <li>\#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY LEGACY</li>
  ///   <li>\#INFO_SUPPORTED_HARDWARE_LEVEL_3 3</li>
  ///   <li>\#INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL EXTERNAL</li>
  /// </ul>
  ///
  /// This key is available on all devices.
  ///
  ///@see CameraCharacteristics\#CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES
  ///@see CameraCharacteristics\#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION
  ///@see CameraCharacteristics\#LENS_INFO_FOCUS_DISTANCE_CALIBRATION
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  ///@see CameraCharacteristics\#SENSOR_INFO_TIMESTAMP_SOURCE
  ///@see CameraCharacteristics\#STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES
  ///@see \#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED
  ///@see \#INFO_SUPPORTED_HARDWARE_LEVEL_FULL
  ///@see \#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY
  ///@see \#INFO_SUPPORTED_HARDWARE_LEVEL_3
  ///@see \#INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL
  static CameraCharacteristics_Key get INFO_SUPPORTED_HARDWARE_LEVEL =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_INFO_SUPPORTED_HARDWARE_LEVEL,
              jni.JniType.objectType)
          .object);

  static final _id_INFO_VERSION = jniAccessors.getStaticFieldIDOf(_classRef,
      "INFO_VERSION", "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.String> INFO_VERSION
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A short string for manufacturer version information about the camera device, such as
  /// ISP hardware, sensors, etc.
  ///
  /// This can be used in android.media.ExifInterface\#TAG_IMAGE_DESCRIPTION TAG_IMAGE_DESCRIPTION
  /// in jpeg EXIF. This key may be absent if no version information is available on the
  /// device.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  static CameraCharacteristics_Key get INFO_VERSION =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_INFO_VERSION, jni.JniType.objectType)
          .object);

  static final _id_JPEG_AVAILABLE_THUMBNAIL_SIZES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "JPEG_AVAILABLE_THUMBNAIL_SIZES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.util.Size[]> JPEG_AVAILABLE_THUMBNAIL_SIZES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of JPEG thumbnail sizes for CaptureRequest\#JPEG_THUMBNAIL_SIZE android.jpeg.thumbnailSize supported by this
  /// camera device.
  ///
  /// This list will include at least one non-zero resolution, plus <code>(0,0)</code> for indicating no
  /// thumbnail should be generated.
  ///
  /// Below condiditions will be satisfied for this size list:
  ///
  /// <ul>
  /// <li>The sizes will be sorted by increasing pixel area (width x height).
  /// If several resolutions have the same area, they will be sorted by increasing width.</li>
  /// <li>The aspect ratio of the largest thumbnail size will be same as the
  /// aspect ratio of largest JPEG output size in android.scaler.availableStreamConfigurations.
  /// The largest size is defined as the size that has the largest pixel area
  /// in a given size list.</li>
  /// <li>Each output JPEG size in android.scaler.availableStreamConfigurations will have at least
  /// one corresponding size that has the same aspect ratio in availableThumbnailSizes,
  /// and vice versa.</li>
  /// <li>All non-<code>(0, 0)</code> sizes will have non-zero widths and heights.
  /// This key is available on all devices.</li>
  /// </ul>
  ///@see CaptureRequest\#JPEG_THUMBNAIL_SIZE
  static CameraCharacteristics_Key get JPEG_AVAILABLE_THUMBNAIL_SIZES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_JPEG_AVAILABLE_THUMBNAIL_SIZES,
              jni.JniType.objectType)
          .object);

  static final _id_LENS_DISTORTION = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "LENS_DISTORTION",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<float[]> LENS_DISTORTION
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The correction coefficients to correct for this camera device's
  /// radial and tangential lens distortion.
  ///
  /// Replaces the deprecated CameraCharacteristics\#LENS_RADIAL_DISTORTION android.lens.radialDistortion field, which was
  /// inconsistently defined.
  ///
  /// Three radial distortion coefficients <code>[kappa_1, kappa_2,
  /// kappa_3]</code> and two tangential distortion coefficients
  /// <code>[kappa_4, kappa_5]</code> that can be used to correct the
  /// lens's geometric distortion with the mapping equations:
  ///
  /// <pre><code> x_c = x_i * ( 1 + kappa_1 * r^2 + kappa_2 * r^4 + kappa_3 * r^6 ) +
  ///        kappa_4 * (2 * x_i * y_i) + kappa_5 * ( r^2 + 2 * x_i^2 )
  ///  y_c = y_i * ( 1 + kappa_1 * r^2 + kappa_2 * r^4 + kappa_3 * r^6 ) +
  ///        kappa_5 * (2 * x_i * y_i) + kappa_4 * ( r^2 + 2 * y_i^2 )
  /// </code></pre>
  /// Here, <code>[x_c, y_c]</code> are the coordinates to sample in the
  /// input image that correspond to the pixel values in the
  /// corrected image at the coordinate <code>[x_i, y_i]</code>:
  ///
  /// <pre><code> correctedImage(x_i, y_i) = sample_at(x_c, y_c, inputImage)
  /// </code></pre>
  /// The pixel coordinates are defined in a coordinate system
  /// related to the CameraCharacteristics\#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration
  /// calibration fields; see that entry for details of the mapping stages.
  /// Both <code>[x_i, y_i]</code> and <code>[x_c, y_c]</code>
  /// have <code>(0,0)</code> at the lens optical center <code>[c_x, c_y]</code>, and
  /// the range of the coordinates depends on the focal length
  /// terms of the intrinsic calibration.
  ///
  /// Finally, <code>r</code> represents the radial distance from the
  /// optical center, <code>r^2 = x_i^2 + y_i^2</code>.
  ///
  /// The distortion model used is the Brown-Conrady model.
  ///
  /// __Units__:
  /// Unitless coefficients.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CameraCharacteristics\#LENS_INTRINSIC_CALIBRATION
  ///@see CameraCharacteristics\#LENS_RADIAL_DISTORTION
  static CameraCharacteristics_Key get LENS_DISTORTION =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_LENS_DISTORTION, jni.JniType.objectType)
          .object);

  static final _id_LENS_FACING = jniAccessors.getStaticFieldIDOf(_classRef,
      "LENS_FACING", "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> LENS_FACING
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Direction the camera faces relative to
  /// device screen.
  ///
  /// __Possible values:__
  /// <ul>
  ///   <li>\#LENS_FACING_FRONT FRONT</li>
  ///   <li>\#LENS_FACING_BACK BACK</li>
  ///   <li>\#LENS_FACING_EXTERNAL EXTERNAL</li>
  /// </ul>
  ///
  /// This key is available on all devices.
  ///
  ///@see \#LENS_FACING_FRONT
  ///@see \#LENS_FACING_BACK
  ///@see \#LENS_FACING_EXTERNAL
  static CameraCharacteristics_Key get LENS_FACING =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_LENS_FACING, jni.JniType.objectType)
          .object);

  static final _id_LENS_INFO_AVAILABLE_APERTURES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "LENS_INFO_AVAILABLE_APERTURES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<float[]> LENS_INFO_AVAILABLE_APERTURES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of aperture size values for CaptureRequest\#LENS_APERTURE android.lens.aperture that are
  /// supported by this camera device.
  ///
  /// If the camera device doesn't support a variable lens aperture,
  /// this list will contain only one value, which is the fixed aperture size.
  ///
  /// If the camera device supports a variable aperture, the aperture values
  /// in this list will be sorted in ascending order.
  ///
  /// __Units__: The aperture f-number
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Full capability__ -
  /// Present on all camera devices that report being CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CaptureRequest\#LENS_APERTURE
  static CameraCharacteristics_Key get LENS_INFO_AVAILABLE_APERTURES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_LENS_INFO_AVAILABLE_APERTURES,
              jni.JniType.objectType)
          .object);

  static final _id_LENS_INFO_AVAILABLE_FILTER_DENSITIES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "LENS_INFO_AVAILABLE_FILTER_DENSITIES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<float[]> LENS_INFO_AVAILABLE_FILTER_DENSITIES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of neutral density filter values for
  /// CaptureRequest\#LENS_FILTER_DENSITY android.lens.filterDensity that are supported by this camera device.
  ///
  /// If a neutral density filter is not supported by this camera device,
  /// this list will contain only 0. Otherwise, this list will include every
  /// filter density supported by the camera device, in ascending order.
  ///
  /// __Units__: Exposure value (EV)
  ///
  /// __Range of valid values:__<br>
  ///
  /// Values are &gt;= 0
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Full capability__ -
  /// Present on all camera devices that report being CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CaptureRequest\#LENS_FILTER_DENSITY
  static CameraCharacteristics_Key get LENS_INFO_AVAILABLE_FILTER_DENSITIES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_LENS_INFO_AVAILABLE_FILTER_DENSITIES,
              jni.JniType.objectType)
          .object);

  static final _id_LENS_INFO_AVAILABLE_FOCAL_LENGTHS =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "LENS_INFO_AVAILABLE_FOCAL_LENGTHS",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<float[]> LENS_INFO_AVAILABLE_FOCAL_LENGTHS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of focal lengths for CaptureRequest\#LENS_FOCAL_LENGTH android.lens.focalLength that are supported by this camera
  /// device.
  ///
  /// If optical zoom is not supported, this list will only contain
  /// a single value corresponding to the fixed focal length of the
  /// device. Otherwise, this list will include every focal length supported
  /// by the camera device, in ascending order.
  ///
  /// __Units__: Millimeters
  ///
  /// __Range of valid values:__<br>
  ///
  /// Values are &gt; 0
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#LENS_FOCAL_LENGTH
  static CameraCharacteristics_Key get LENS_INFO_AVAILABLE_FOCAL_LENGTHS =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_LENS_INFO_AVAILABLE_FOCAL_LENGTHS,
              jni.JniType.objectType)
          .object);

  static final _id_LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of optical image stabilization (OIS) modes for
  /// CaptureRequest\#LENS_OPTICAL_STABILIZATION_MODE android.lens.opticalStabilizationMode that are supported by this camera device.
  ///
  /// If OIS is not supported by a given camera device, this list will
  /// contain only OFF.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#LENS_OPTICAL_STABILIZATION_MODE android.lens.opticalStabilizationMode
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Limited capability__ -
  /// Present on all camera devices that report being at least CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CaptureRequest\#LENS_OPTICAL_STABILIZATION_MODE
  static CameraCharacteristics_Key
      get LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION =>
          CameraCharacteristics_Key.fromRef(jniAccessors
              .getStaticField(
                  _classRef,
                  _id_LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION,
                  jni.JniType.objectType)
              .object);

  static final _id_LENS_INFO_FOCUS_DISTANCE_CALIBRATION =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "LENS_INFO_FOCUS_DISTANCE_CALIBRATION",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> LENS_INFO_FOCUS_DISTANCE_CALIBRATION
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The lens focus distance calibration quality.
  ///
  /// The lens focus distance calibration quality determines the reliability of
  /// focus related metadata entries, i.e. CaptureRequest\#LENS_FOCUS_DISTANCE android.lens.focusDistance,
  /// CaptureResult\#LENS_FOCUS_RANGE android.lens.focusRange, CameraCharacteristics\#LENS_INFO_HYPERFOCAL_DISTANCE android.lens.info.hyperfocalDistance, and
  /// CameraCharacteristics\#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance.
  ///
  /// APPROXIMATE and CALIBRATED devices report the focus metadata in
  /// units of diopters (1/meter), so <code>0.0f</code> represents focusing at infinity,
  /// and increasing positive numbers represent focusing closer and closer
  /// to the camera device. The focus distance control also uses diopters
  /// on these devices.
  ///
  /// UNCALIBRATED devices do not use units that are directly comparable
  /// to any real physical measurement, but <code>0.0f</code> still represents farthest
  /// focus, and CameraCharacteristics\#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance represents the
  /// nearest focus the device can achieve.
  ///
  /// __Possible values:__
  /// <ul>
  ///   <li>\#LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED UNCALIBRATED</li>
  ///   <li>\#LENS_INFO_FOCUS_DISTANCE_CALIBRATION_APPROXIMATE APPROXIMATE</li>
  ///   <li>\#LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED CALIBRATED</li>
  /// </ul>
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Limited capability__ -
  /// Present on all camera devices that report being at least CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CaptureRequest\#LENS_FOCUS_DISTANCE
  ///@see CaptureResult\#LENS_FOCUS_RANGE
  ///@see CameraCharacteristics\#LENS_INFO_HYPERFOCAL_DISTANCE
  ///@see CameraCharacteristics\#LENS_INFO_MINIMUM_FOCUS_DISTANCE
  ///@see \#LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED
  ///@see \#LENS_INFO_FOCUS_DISTANCE_CALIBRATION_APPROXIMATE
  ///@see \#LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED
  static CameraCharacteristics_Key get LENS_INFO_FOCUS_DISTANCE_CALIBRATION =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_LENS_INFO_FOCUS_DISTANCE_CALIBRATION,
              jni.JniType.objectType)
          .object);

  static final _id_LENS_INFO_HYPERFOCAL_DISTANCE =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "LENS_INFO_HYPERFOCAL_DISTANCE",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Float> LENS_INFO_HYPERFOCAL_DISTANCE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Hyperfocal distance for this lens.
  ///
  /// If the lens is not fixed focus, the camera device will report this
  /// field when CameraCharacteristics\#LENS_INFO_FOCUS_DISTANCE_CALIBRATION android.lens.info.focusDistanceCalibration is APPROXIMATE or CALIBRATED.
  ///
  /// __Units__: See CameraCharacteristics\#LENS_INFO_FOCUS_DISTANCE_CALIBRATION android.lens.info.focusDistanceCalibration for details
  ///
  /// __Range of valid values:__<br>
  /// If lens is fixed focus, &gt;= 0. If lens has focuser unit, the value is
  /// within <code>(0.0f, CameraCharacteristics\#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance]</code>
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Limited capability__ -
  /// Present on all camera devices that report being at least CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CameraCharacteristics\#LENS_INFO_FOCUS_DISTANCE_CALIBRATION
  ///@see CameraCharacteristics\#LENS_INFO_MINIMUM_FOCUS_DISTANCE
  static CameraCharacteristics_Key get LENS_INFO_HYPERFOCAL_DISTANCE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_LENS_INFO_HYPERFOCAL_DISTANCE,
              jni.JniType.objectType)
          .object);

  static final _id_LENS_INFO_MINIMUM_FOCUS_DISTANCE =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "LENS_INFO_MINIMUM_FOCUS_DISTANCE",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Float> LENS_INFO_MINIMUM_FOCUS_DISTANCE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Shortest distance from frontmost surface
  /// of the lens that can be brought into sharp focus.
  ///
  /// If the lens is fixed-focus, this will be
  /// 0.
  ///
  /// __Units__: See CameraCharacteristics\#LENS_INFO_FOCUS_DISTANCE_CALIBRATION android.lens.info.focusDistanceCalibration for details
  ///
  /// __Range of valid values:__<br>
  /// &gt;= 0
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Limited capability__ -
  /// Present on all camera devices that report being at least CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CameraCharacteristics\#LENS_INFO_FOCUS_DISTANCE_CALIBRATION
  static CameraCharacteristics_Key get LENS_INFO_MINIMUM_FOCUS_DISTANCE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_LENS_INFO_MINIMUM_FOCUS_DISTANCE,
              jni.JniType.objectType)
          .object);

  static final _id_LENS_INTRINSIC_CALIBRATION = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "LENS_INTRINSIC_CALIBRATION",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<float[]> LENS_INTRINSIC_CALIBRATION
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The parameters for this camera device's intrinsic
  /// calibration.
  ///
  /// The five calibration parameters that describe the
  /// transform from camera-centric 3D coordinates to sensor
  /// pixel coordinates:
  ///
  /// <pre><code>[f_x, f_y, c_x, c_y, s]
  /// </code></pre>
  /// Where <code>f_x</code> and <code>f_y</code> are the horizontal and vertical
  /// focal lengths, <code>[c_x, c_y]</code> is the position of the optical
  /// axis, and <code>s</code> is a skew parameter for the sensor plane not
  /// being aligned with the lens plane.
  ///
  /// These are typically used within a transformation matrix K:
  ///
  /// <pre><code>K = [ f_x,   s, c_x,
  ///        0, f_y, c_y,
  ///        0    0,   1 ]
  /// </code></pre>
  /// which can then be combined with the camera pose rotation
  /// <code>R</code> and translation <code>t</code> (CameraCharacteristics\#LENS_POSE_ROTATION android.lens.poseRotation and
  /// CameraCharacteristics\#LENS_POSE_TRANSLATION android.lens.poseTranslation, respective) to calculate the
  /// complete transform from world coordinates to pixel
  /// coordinates:
  ///
  /// <pre><code>P = [ K 0   * [ R t
  ///      0 1 ]     0 1 ]
  /// </code></pre>
  /// and with <code>p_w</code> being a point in the world coordinate system
  /// and <code>p_s</code> being a point in the camera active pixel array
  /// coordinate system, and with the mapping including the
  /// homogeneous division by z:
  ///
  /// <pre><code> p_h = (x_h, y_h, z_h) = P p_w
  /// p_s = p_h / z_h
  /// </code></pre>
  /// so <code>[x_s, y_s]</code> is the pixel coordinates of the world
  /// point, <code>z_s = 1</code>, and <code>w_s</code> is a measurement of disparity
  /// (depth) in pixel coordinates.
  ///
  /// Note that the coordinate system for this transform is the
  /// CameraCharacteristics\#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize system,
  /// where <code>(0,0)</code> is the top-left of the
  /// preCorrectionActiveArraySize rectangle. Once the pose and
  /// intrinsic calibration transforms have been applied to a
  /// world point, then the CameraCharacteristics\#LENS_DISTORTION android.lens.distortion
  /// transform needs to be applied, and the result adjusted to
  /// be in the CameraCharacteristics\#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize coordinate
  /// system (where <code>(0, 0)</code> is the top-left of the
  /// activeArraySize rectangle), to determine the final pixel
  /// coordinate of the world point for processed (non-RAW)
  /// output buffers.
  ///
  /// __Units__:
  /// Pixels in the
  /// CameraCharacteristics\#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize
  /// coordinate system.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CameraCharacteristics\#LENS_DISTORTION
  ///@see CameraCharacteristics\#LENS_POSE_ROTATION
  ///@see CameraCharacteristics\#LENS_POSE_TRANSLATION
  ///@see CameraCharacteristics\#SENSOR_INFO_ACTIVE_ARRAY_SIZE
  ///@see CameraCharacteristics\#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE
  static CameraCharacteristics_Key get LENS_INTRINSIC_CALIBRATION =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_LENS_INTRINSIC_CALIBRATION, jni.JniType.objectType)
          .object);

  static final _id_LENS_POSE_REFERENCE = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "LENS_POSE_REFERENCE",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> LENS_POSE_REFERENCE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The origin for CameraCharacteristics\#LENS_POSE_TRANSLATION android.lens.poseTranslation.
  ///
  /// Different calibration methods and use cases can produce better or worse results
  /// depending on the selected coordinate origin.
  ///
  /// __Possible values:__
  /// <ul>
  ///   <li>\#LENS_POSE_REFERENCE_PRIMARY_CAMERA PRIMARY_CAMERA</li>
  ///   <li>\#LENS_POSE_REFERENCE_GYROSCOPE GYROSCOPE</li>
  /// </ul>
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CameraCharacteristics\#LENS_POSE_TRANSLATION
  ///@see \#LENS_POSE_REFERENCE_PRIMARY_CAMERA
  ///@see \#LENS_POSE_REFERENCE_GYROSCOPE
  static CameraCharacteristics_Key get LENS_POSE_REFERENCE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_LENS_POSE_REFERENCE, jni.JniType.objectType)
          .object);

  static final _id_LENS_POSE_ROTATION = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "LENS_POSE_ROTATION",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<float[]> LENS_POSE_ROTATION
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The orientation of the camera relative to the sensor
  /// coordinate system.
  ///
  /// The four coefficients that describe the quaternion
  /// rotation from the Android sensor coordinate system to a
  /// camera-aligned coordinate system where the X-axis is
  /// aligned with the long side of the image sensor, the Y-axis
  /// is aligned with the short side of the image sensor, and
  /// the Z-axis is aligned with the optical axis of the sensor.
  ///
  /// To convert from the quaternion coefficients <code>(x,y,z,w)</code>
  /// to the axis of rotation <code>(a_x, a_y, a_z)</code> and rotation
  /// amount <code>theta</code>, the following formulas can be used:
  ///
  /// <pre><code> theta = 2 * acos(w)
  /// a_x = x / sin(theta/2)
  /// a_y = y / sin(theta/2)
  /// a_z = z / sin(theta/2)
  /// </code></pre>
  /// To create a 3x3 rotation matrix that applies the rotation
  /// defined by this quaternion, the following matrix can be
  /// used:
  ///
  /// <pre><code>R = [ 1 - 2y^2 - 2z^2,       2xy - 2zw,       2xz + 2yw,
  ///            2xy + 2zw, 1 - 2x^2 - 2z^2,       2yz - 2xw,
  ///            2xz - 2yw,       2yz + 2xw, 1 - 2x^2 - 2y^2 ]
  /// </code></pre>
  /// This matrix can then be used to apply the rotation to a
  ///  column vector point with
  ///
  /// <code>p' = Rp</code>
  ///
  /// where <code>p</code> is in the device sensor coordinate system, and
  ///  <code>p'</code> is in the camera-oriented coordinate system.
  ///
  /// __Units__:
  /// Quaternion coefficients
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  static CameraCharacteristics_Key get LENS_POSE_ROTATION =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_LENS_POSE_ROTATION, jni.JniType.objectType)
          .object);

  static final _id_LENS_POSE_TRANSLATION = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "LENS_POSE_TRANSLATION",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<float[]> LENS_POSE_TRANSLATION
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Position of the camera optical center.
  ///
  /// The position of the camera device's lens optical center,
  /// as a three-dimensional vector <code>(x,y,z)</code>.
  ///
  /// Prior to Android P, or when CameraCharacteristics\#LENS_POSE_REFERENCE android.lens.poseReference is PRIMARY_CAMERA, this position
  /// is relative to the optical center of the largest camera device facing in the same
  /// direction as this camera, in the android.hardware.SensorEvent Android sensor
  /// coordinate axes. Note that only the axis definitions are shared with the sensor
  /// coordinate system, but not the origin.
  ///
  /// If this device is the largest or only camera device with a given facing, then this
  /// position will be <code>(0, 0, 0)</code>; a camera device with a lens optical center located 3 cm
  /// from the main sensor along the +X axis (to the right from the user's perspective) will
  /// report <code>(0.03, 0, 0)</code>.
  ///
  /// To transform a pixel coordinates between two cameras facing the same direction, first
  /// the source camera CameraCharacteristics\#LENS_DISTORTION android.lens.distortion must be corrected for.  Then the source
  /// camera CameraCharacteristics\#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration needs to be applied, followed by the
  /// CameraCharacteristics\#LENS_POSE_ROTATION android.lens.poseRotation of the source camera, the translation of the source camera
  /// relative to the destination camera, the CameraCharacteristics\#LENS_POSE_ROTATION android.lens.poseRotation of the destination
  /// camera, and finally the inverse of CameraCharacteristics\#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration of the destination
  /// camera. This obtains a radial-distortion-free coordinate in the destination camera pixel
  /// coordinates.
  ///
  /// To compare this against a real image from the destination camera, the destination camera
  /// image then needs to be corrected for radial distortion before comparison or sampling.
  ///
  /// When CameraCharacteristics\#LENS_POSE_REFERENCE android.lens.poseReference is GYROSCOPE, then this position is relative to
  /// the center of the primary gyroscope on the device.
  ///
  /// __Units__: Meters
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CameraCharacteristics\#LENS_DISTORTION
  ///@see CameraCharacteristics\#LENS_INTRINSIC_CALIBRATION
  ///@see CameraCharacteristics\#LENS_POSE_REFERENCE
  ///@see CameraCharacteristics\#LENS_POSE_ROTATION
  static CameraCharacteristics_Key get LENS_POSE_TRANSLATION =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_LENS_POSE_TRANSLATION, jni.JniType.objectType)
          .object);

  static final _id_LENS_RADIAL_DISTORTION = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "LENS_RADIAL_DISTORTION",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<float[]> LENS_RADIAL_DISTORTION
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The correction coefficients to correct for this camera device's
  /// radial and tangential lens distortion.
  ///
  /// Four radial distortion coefficients <code>[kappa_0, kappa_1, kappa_2,
  /// kappa_3]</code> and two tangential distortion coefficients
  /// <code>[kappa_4, kappa_5]</code> that can be used to correct the
  /// lens's geometric distortion with the mapping equations:
  ///
  /// <pre><code> x_c = x_i * ( kappa_0 + kappa_1 * r^2 + kappa_2 * r^4 + kappa_3 * r^6 ) +
  ///        kappa_4 * (2 * x_i * y_i) + kappa_5 * ( r^2 + 2 * x_i^2 )
  ///  y_c = y_i * ( kappa_0 + kappa_1 * r^2 + kappa_2 * r^4 + kappa_3 * r^6 ) +
  ///        kappa_5 * (2 * x_i * y_i) + kappa_4 * ( r^2 + 2 * y_i^2 )
  /// </code></pre>
  /// Here, <code>[x_c, y_c]</code> are the coordinates to sample in the
  /// input image that correspond to the pixel values in the
  /// corrected image at the coordinate <code>[x_i, y_i]</code>:
  ///
  /// <pre><code> correctedImage(x_i, y_i) = sample_at(x_c, y_c, inputImage)
  /// </code></pre>
  /// The pixel coordinates are defined in a normalized
  /// coordinate system related to the
  /// CameraCharacteristics\#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration calibration fields.
  /// Both <code>[x_i, y_i]</code> and <code>[x_c, y_c]</code> have <code>(0,0)</code> at the
  /// lens optical center <code>[c_x, c_y]</code>. The maximum magnitudes
  /// of both x and y coordinates are normalized to be 1 at the
  /// edge further from the optical center, so the range
  /// for both dimensions is <code>-1 &lt;= x &lt;= 1</code>.
  ///
  /// Finally, <code>r</code> represents the radial distance from the
  /// optical center, <code>r^2 = x_i^2 + y_i^2</code>, and its magnitude
  /// is therefore no larger than <code>|r| &lt;= sqrt(2)</code>.
  ///
  /// The distortion model used is the Brown-Conrady model.
  ///
  /// __Units__:
  /// Unitless coefficients.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CameraCharacteristics\#LENS_INTRINSIC_CALIBRATION
  ///@deprecated This field was inconsistently defined in terms of its
  /// normalization. Use CameraCharacteristics\#LENS_DISTORTION android.lens.distortion instead.
  ///
  ///@see CameraCharacteristics\#LENS_DISTORTION
  static CameraCharacteristics_Key get LENS_RADIAL_DISTORTION =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_LENS_RADIAL_DISTORTION, jni.JniType.objectType)
          .object);

  static final _id_LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The accuracy of frame timestamp synchronization between physical cameras
  ///
  /// The accuracy of the frame timestamp synchronization determines the physical cameras'
  /// ability to start exposure at the same time. If the sensorSyncType is CALIBRATED,
  /// the physical camera sensors usually run in master-slave mode so that their shutter
  /// time is synchronized. For APPROXIMATE sensorSyncType, the camera sensors usually run in
  /// master-master mode, and there could be offset between their start of exposure.
  ///
  /// In both cases, all images generated for a particular capture request still carry the same
  /// timestamps, so that they can be used to look up the matching frame number and
  /// onCaptureStarted callback.
  ///
  /// __Possible values:__
  /// <ul>
  ///   <li>\#LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_APPROXIMATE APPROXIMATE</li>
  ///   <li>\#LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED CALIBRATED</li>
  /// </ul>
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Limited capability__ -
  /// Present on all camera devices that report being at least CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see \#LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_APPROXIMATE
  ///@see \#LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED
  static CameraCharacteristics_Key get LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE,
              jni.JniType.objectType)
          .object);

  static final _id_NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of noise reduction modes for CaptureRequest\#NOISE_REDUCTION_MODE android.noiseReduction.mode that are supported
  /// by this camera device.
  ///
  /// Full-capability camera devices will always support OFF and FAST.
  ///
  /// Camera devices that support YUV_REPROCESSING or PRIVATE_REPROCESSING will support
  /// ZERO_SHUTTER_LAG.
  ///
  /// Legacy-capability camera devices will only support FAST mode.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#NOISE_REDUCTION_MODE android.noiseReduction.mode
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Limited capability__ -
  /// Present on all camera devices that report being at least CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CaptureRequest\#NOISE_REDUCTION_MODE
  static CameraCharacteristics_Key
      get NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES =>
          CameraCharacteristics_Key.fromRef(jniAccessors
              .getStaticField(
                  _classRef,
                  _id_NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES,
                  jni.JniType.objectType)
              .object);

  static final _id_REPROCESS_MAX_CAPTURE_STALL =
      jniAccessors.getStaticFieldIDOf(_classRef, "REPROCESS_MAX_CAPTURE_STALL",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> REPROCESS_MAX_CAPTURE_STALL
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The maximal camera capture pipeline stall (in unit of frame count) introduced by a
  /// reprocess capture request.
  ///
  /// The key describes the maximal interference that one reprocess (input) request
  /// can introduce to the camera simultaneous streaming of regular (output) capture
  /// requests, including repeating requests.
  ///
  /// When a reprocessing capture request is submitted while a camera output repeating request
  /// (e.g. preview) is being served by the camera device, it may preempt the camera capture
  /// pipeline for at least one frame duration so that the camera device is unable to process
  /// the following capture request in time for the next sensor start of exposure boundary.
  /// When this happens, the application may observe a capture time gap (longer than one frame
  /// duration) between adjacent capture output frames, which usually exhibits as preview
  /// glitch if the repeating request output targets include a preview surface. This key gives
  /// the worst-case number of frame stall introduced by one reprocess request with any kind of
  /// formats/sizes combination.
  ///
  /// If this key reports 0, it means a reprocess request doesn't introduce any glitch to the
  /// ongoing camera repeating request outputs, as if this reprocess request is never issued.
  ///
  /// This key is supported if the camera device supports PRIVATE or YUV reprocessing (
  /// i.e. CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities contains PRIVATE_REPROCESSING or
  /// YUV_REPROCESSING).
  ///
  /// __Units__: Number of frames.
  ///
  /// __Range of valid values:__<br>
  /// &lt;= 4
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Limited capability__ -
  /// Present on all camera devices that report being at least CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  static CameraCharacteristics_Key get REPROCESS_MAX_CAPTURE_STALL =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_REPROCESS_MAX_CAPTURE_STALL,
              jni.JniType.objectType)
          .object);

  static final _id_REQUEST_AVAILABLE_CAPABILITIES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "REQUEST_AVAILABLE_CAPABILITIES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> REQUEST_AVAILABLE_CAPABILITIES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of capabilities that this camera device
  /// advertises as fully supporting.
  ///
  /// A capability is a contract that the camera device makes in order
  /// to be able to satisfy one or more use cases.
  ///
  /// Listing a capability guarantees that the whole set of features
  /// required to support a common use will all be available.
  ///
  /// Using a subset of the functionality provided by an unsupported
  /// capability may be possible on a specific camera device implementation;
  /// to do this query each of android.request.availableRequestKeys,
  /// android.request.availableResultKeys,
  /// android.request.availableCharacteristicsKeys.
  ///
  /// The following capabilities are guaranteed to be available on
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel <code>==</code> FULL devices:
  ///
  /// <ul>
  /// <li>MANUAL_SENSOR</li>
  /// <li>MANUAL_POST_PROCESSING</li>
  /// </ul>
  /// Other capabilities may be available on either FULL or LIMITED
  /// devices, but the application should query this key to be sure.
  ///
  /// __Possible values:__
  /// <ul>
  ///   <li>\#REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE BACKWARD_COMPATIBLE</li>
  ///   <li>\#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR MANUAL_SENSOR</li>
  ///   <li>\#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING MANUAL_POST_PROCESSING</li>
  ///   <li>\#REQUEST_AVAILABLE_CAPABILITIES_RAW RAW</li>
  ///   <li>\#REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING PRIVATE_REPROCESSING</li>
  ///   <li>\#REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS READ_SENSOR_SETTINGS</li>
  ///   <li>\#REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE BURST_CAPTURE</li>
  ///   <li>\#REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING YUV_REPROCESSING</li>
  ///   <li>\#REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT DEPTH_OUTPUT</li>
  ///   <li>\#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO CONSTRAINED_HIGH_SPEED_VIDEO</li>
  ///   <li>\#REQUEST_AVAILABLE_CAPABILITIES_MOTION_TRACKING MOTION_TRACKING</li>
  ///   <li>\#REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA LOGICAL_MULTI_CAMERA</li>
  ///   <li>\#REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME MONOCHROME</li>
  /// </ul>
  ///
  /// This key is available on all devices.
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see \#REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE
  ///@see \#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR
  ///@see \#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING
  ///@see \#REQUEST_AVAILABLE_CAPABILITIES_RAW
  ///@see \#REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING
  ///@see \#REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS
  ///@see \#REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE
  ///@see \#REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING
  ///@see \#REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT
  ///@see \#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO
  ///@see \#REQUEST_AVAILABLE_CAPABILITIES_MOTION_TRACKING
  ///@see \#REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA
  ///@see \#REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME
  static CameraCharacteristics_Key get REQUEST_AVAILABLE_CAPABILITIES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_REQUEST_AVAILABLE_CAPABILITIES,
              jni.JniType.objectType)
          .object);

  static final _id_REQUEST_MAX_NUM_INPUT_STREAMS =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "REQUEST_MAX_NUM_INPUT_STREAMS",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> REQUEST_MAX_NUM_INPUT_STREAMS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The maximum numbers of any type of input streams
  /// that can be configured and used simultaneously by a camera device.
  ///
  /// When set to 0, it means no input stream is supported.
  ///
  /// The image format for a input stream can be any supported format returned by android.hardware.camera2.params.StreamConfigurationMap\#getInputFormats. When using an
  /// input stream, there must be at least one output stream configured to to receive the
  /// reprocessed images.
  ///
  /// When an input stream and some output streams are used in a reprocessing request,
  /// only the input buffer will be used to produce these output stream buffers, and a
  /// new sensor image will not be captured.
  ///
  /// For example, for Zero Shutter Lag (ZSL) still capture use case, the input
  /// stream image format will be PRIVATE, the associated output stream image format
  /// should be JPEG.
  ///
  /// __Range of valid values:__<br>
  ///
  /// 0 or 1.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Full capability__ -
  /// Present on all camera devices that report being CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  static CameraCharacteristics_Key get REQUEST_MAX_NUM_INPUT_STREAMS =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_REQUEST_MAX_NUM_INPUT_STREAMS,
              jni.JniType.objectType)
          .object);

  static final _id_REQUEST_MAX_NUM_OUTPUT_PROC =
      jniAccessors.getStaticFieldIDOf(_classRef, "REQUEST_MAX_NUM_OUTPUT_PROC",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> REQUEST_MAX_NUM_OUTPUT_PROC
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The maximum numbers of different types of output streams
  /// that can be configured and used simultaneously by a camera device
  /// for any processed (but not-stalling) formats.
  ///
  /// This value contains the max number of output simultaneous
  /// streams for any processed (but not-stalling) formats.
  ///
  /// This lists the upper bound of the number of output streams supported by
  /// the camera device. Using more streams simultaneously may require more hardware and
  /// CPU resources that will consume more power. The image format for this kind of an output stream can
  /// be any non-<code>RAW</code> and supported format provided by CameraCharacteristics\#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap.
  ///
  /// Processed (but not-stalling) is defined as any non-RAW format without a stall duration.
  /// Typically:
  ///
  /// <ul>
  /// <li>android.graphics.ImageFormat\#YUV_420_888 YUV_420_888</li>
  /// <li>android.graphics.ImageFormat\#NV21 NV21</li>
  /// <li>android.graphics.ImageFormat\#YV12 YV12</li>
  /// <li>Implementation-defined formats, i.e. android.hardware.camera2.params.StreamConfigurationMap\#isOutputSupportedFor(Class)</li>
  /// </ul>
  /// For full guarantees, query android.hardware.camera2.params.StreamConfigurationMap\#getOutputStallDuration with a
  /// processed format -- it will return 0 for a non-stalling stream.
  ///
  /// LEGACY devices will support at least 2 processing/non-stalling streams.
  ///
  /// __Range of valid values:__<br>
  ///
  /// &gt;= 3
  /// for FULL mode devices (<code>CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel == FULL</code>);
  /// &gt;= 2 for LIMITED mode devices (<code>CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel == LIMITED</code>).
  ///
  /// This key is available on all devices.
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CameraCharacteristics\#SCALER_STREAM_CONFIGURATION_MAP
  static CameraCharacteristics_Key get REQUEST_MAX_NUM_OUTPUT_PROC =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_REQUEST_MAX_NUM_OUTPUT_PROC,
              jni.JniType.objectType)
          .object);

  static final _id_REQUEST_MAX_NUM_OUTPUT_PROC_STALLING =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "REQUEST_MAX_NUM_OUTPUT_PROC_STALLING",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> REQUEST_MAX_NUM_OUTPUT_PROC_STALLING
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The maximum numbers of different types of output streams
  /// that can be configured and used simultaneously by a camera device
  /// for any processed (and stalling) formats.
  ///
  /// This value contains the max number of output simultaneous
  /// streams for any processed (but not-stalling) formats.
  ///
  /// This lists the upper bound of the number of output streams supported by
  /// the camera device. Using more streams simultaneously may require more hardware and
  /// CPU resources that will consume more power. The image format for this kind of an output stream can
  /// be any non-<code>RAW</code> and supported format provided by CameraCharacteristics\#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap.
  ///
  /// A processed and stalling format is defined as any non-RAW format with a stallDurations
  /// &gt; 0.  Typically only the android.graphics.ImageFormat\#JPEG JPEG format is a stalling format.
  ///
  /// For full guarantees, query android.hardware.camera2.params.StreamConfigurationMap\#getOutputStallDuration with a
  /// processed format -- it will return a non-0 value for a stalling stream.
  ///
  /// LEGACY devices will support up to 1 processing/stalling stream.
  ///
  /// __Range of valid values:__<br>
  ///
  /// &gt;= 1
  ///
  /// This key is available on all devices.
  ///
  ///@see CameraCharacteristics\#SCALER_STREAM_CONFIGURATION_MAP
  static CameraCharacteristics_Key get REQUEST_MAX_NUM_OUTPUT_PROC_STALLING =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_REQUEST_MAX_NUM_OUTPUT_PROC_STALLING,
              jni.JniType.objectType)
          .object);

  static final _id_REQUEST_MAX_NUM_OUTPUT_RAW = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "REQUEST_MAX_NUM_OUTPUT_RAW",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> REQUEST_MAX_NUM_OUTPUT_RAW
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The maximum numbers of different types of output streams
  /// that can be configured and used simultaneously by a camera device
  /// for any <code>RAW</code> formats.
  ///
  /// This value contains the max number of output simultaneous
  /// streams from the raw sensor.
  ///
  /// This lists the upper bound of the number of output streams supported by
  /// the camera device. Using more streams simultaneously may require more hardware and
  /// CPU resources that will consume more power. The image format for this kind of an output stream can
  /// be any <code>RAW</code> and supported format provided by CameraCharacteristics\#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap.
  ///
  /// In particular, a <code>RAW</code> format is typically one of:
  ///
  /// <ul>
  /// <li>android.graphics.ImageFormat\#RAW_SENSOR RAW_SENSOR</li>
  /// <li>android.graphics.ImageFormat\#RAW10 RAW10</li>
  /// <li>android.graphics.ImageFormat\#RAW12 RAW12</li>
  /// </ul>
  /// LEGACY mode devices (CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel <code>==</code> LEGACY)
  /// never support raw streams.
  ///
  /// __Range of valid values:__<br>
  ///
  /// &gt;= 0
  ///
  /// This key is available on all devices.
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CameraCharacteristics\#SCALER_STREAM_CONFIGURATION_MAP
  static CameraCharacteristics_Key get REQUEST_MAX_NUM_OUTPUT_RAW =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_REQUEST_MAX_NUM_OUTPUT_RAW, jni.JniType.objectType)
          .object);

  static final _id_REQUEST_PARTIAL_RESULT_COUNT =
      jniAccessors.getStaticFieldIDOf(_classRef, "REQUEST_PARTIAL_RESULT_COUNT",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> REQUEST_PARTIAL_RESULT_COUNT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Defines how many sub-components
  /// a result will be composed of.
  ///
  /// In order to combat the pipeline latency, partial results
  /// may be delivered to the application layer from the camera device as
  /// soon as they are available.
  ///
  /// Optional; defaults to 1. A value of 1 means that partial
  /// results are not supported, and only the final TotalCaptureResult will
  /// be produced by the camera device.
  ///
  /// A typical use case for this might be: after requesting an
  /// auto-focus (AF) lock the new AF state might be available 50%
  /// of the way through the pipeline.  The camera device could
  /// then immediately dispatch this state via a partial result to
  /// the application, and the rest of the metadata via later
  /// partial results.
  ///
  /// __Range of valid values:__<br>
  /// &gt;= 1
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  static CameraCharacteristics_Key get REQUEST_PARTIAL_RESULT_COUNT =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_REQUEST_PARTIAL_RESULT_COUNT,
              jni.JniType.objectType)
          .object);

  static final _id_REQUEST_PIPELINE_MAX_DEPTH = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "REQUEST_PIPELINE_MAX_DEPTH",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Byte> REQUEST_PIPELINE_MAX_DEPTH
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specifies the number of maximum pipeline stages a frame
  /// has to go through from when it's exposed to when it's available
  /// to the framework.
  ///
  /// A typical minimum value for this is 2 (one stage to expose,
  /// one stage to readout) from the sensor. The ISP then usually adds
  /// its own stages to do custom HW processing. Further stages may be
  /// added by SW processing.
  ///
  /// Depending on what settings are used (e.g. YUV, JPEG) and what
  /// processing is enabled (e.g. face detection), the actual pipeline
  /// depth (specified by CaptureResult\#REQUEST_PIPELINE_DEPTH android.request.pipelineDepth) may be less than
  /// the max pipeline depth.
  ///
  /// A pipeline depth of X stages is equivalent to a pipeline latency of
  /// X frame intervals.
  ///
  /// This value will normally be 8 or less, however, for high speed capture session,
  /// the max pipeline depth will be up to 8 x size of high speed capture request list.
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureResult\#REQUEST_PIPELINE_DEPTH
  static CameraCharacteristics_Key get REQUEST_PIPELINE_MAX_DEPTH =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_REQUEST_PIPELINE_MAX_DEPTH, jni.JniType.objectType)
          .object);

  static final _id_SCALER_AVAILABLE_MAX_DIGITAL_ZOOM =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "SCALER_AVAILABLE_MAX_DIGITAL_ZOOM",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Float> SCALER_AVAILABLE_MAX_DIGITAL_ZOOM
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The maximum ratio between both active area width
  /// and crop region width, and active area height and
  /// crop region height, for CaptureRequest\#SCALER_CROP_REGION android.scaler.cropRegion.
  ///
  /// This represents the maximum amount of zooming possible by
  /// the camera device, or equivalently, the minimum cropping
  /// window size.
  ///
  /// Crop regions that have a width or height that is smaller
  /// than this ratio allows will be rounded up to the minimum
  /// allowed size by the camera device.
  ///
  /// __Units__: Zoom scale factor
  ///
  /// __Range of valid values:__<br>
  /// &gt;=1
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#SCALER_CROP_REGION
  static CameraCharacteristics_Key get SCALER_AVAILABLE_MAX_DIGITAL_ZOOM =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SCALER_AVAILABLE_MAX_DIGITAL_ZOOM,
              jni.JniType.objectType)
          .object);

  static final _id_SCALER_CROPPING_TYPE = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "SCALER_CROPPING_TYPE",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> SCALER_CROPPING_TYPE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The crop type that this camera device supports.
  ///
  /// When passing a non-centered crop region (CaptureRequest\#SCALER_CROP_REGION android.scaler.cropRegion) to a camera
  /// device that only supports CENTER_ONLY cropping, the camera device will move the
  /// crop region to the center of the sensor active array (CameraCharacteristics\#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize)
  /// and keep the crop region width and height unchanged. The camera device will return the
  /// final used crop region in metadata result CaptureRequest\#SCALER_CROP_REGION android.scaler.cropRegion.
  ///
  /// Camera devices that support FREEFORM cropping will support any crop region that
  /// is inside of the active array. The camera device will apply the same crop region and
  /// return the final used crop region in capture result metadata CaptureRequest\#SCALER_CROP_REGION android.scaler.cropRegion.
  ///
  /// LEGACY capability devices will only support CENTER_ONLY cropping.
  ///
  /// __Possible values:__
  /// <ul>
  ///   <li>\#SCALER_CROPPING_TYPE_CENTER_ONLY CENTER_ONLY</li>
  ///   <li>\#SCALER_CROPPING_TYPE_FREEFORM FREEFORM</li>
  /// </ul>
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#SCALER_CROP_REGION
  ///@see CameraCharacteristics\#SENSOR_INFO_ACTIVE_ARRAY_SIZE
  ///@see \#SCALER_CROPPING_TYPE_CENTER_ONLY
  ///@see \#SCALER_CROPPING_TYPE_FREEFORM
  static CameraCharacteristics_Key get SCALER_CROPPING_TYPE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_SCALER_CROPPING_TYPE, jni.JniType.objectType)
          .object);

  static final _id_SCALER_STREAM_CONFIGURATION_MAP =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "SCALER_STREAM_CONFIGURATION_MAP",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.hardware.camera2.params.StreamConfigurationMap> SCALER_STREAM_CONFIGURATION_MAP
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The available stream configurations that this
  /// camera device supports; also includes the minimum frame durations
  /// and the stall durations for each format/size combination.
  ///
  /// All camera devices will support sensor maximum resolution (defined by
  /// CameraCharacteristics\#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize) for the JPEG format.
  ///
  /// For a given use case, the actual maximum supported resolution
  /// may be lower than what is listed here, depending on the destination
  /// Surface for the image data. For example, for recording video,
  /// the video encoder chosen may have a maximum size limit (e.g. 1080p)
  /// smaller than what the camera (e.g. maximum resolution is 3264x2448)
  /// can provide.
  ///
  /// Please reference the documentation for the image data destination to
  /// check if it limits the maximum size for image data.
  ///
  /// The following table describes the minimum required output stream
  /// configurations based on the hardware level
  /// (CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel):
  ///
  /// <table>
  /// <thead>
  /// <tr>
  /// <th align="center">Format</th>
  /// <th align="center">Size</th>
  /// <th align="center">Hardware Level</th>
  /// <th align="center">Notes</th>
  /// </tr>
  /// </thead>
  /// <tbody>
  /// <tr>
  /// <td align="center">android.graphics.ImageFormat\#JPEG</td>
  /// <td align="center">CameraCharacteristics\#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize (*1)</td>
  /// <td align="center">Any</td>
  /// <td align="center"></td>
  /// </tr>
  /// <tr>
  /// <td align="center">android.graphics.ImageFormat\#JPEG</td>
  /// <td align="center">1920x1080 (1080p)</td>
  /// <td align="center">Any</td>
  /// <td align="center">if 1080p &lt;= activeArraySize</td>
  /// </tr>
  /// <tr>
  /// <td align="center">android.graphics.ImageFormat\#JPEG</td>
  /// <td align="center">1280x720 (720p)</td>
  /// <td align="center">Any</td>
  /// <td align="center">if 720p &lt;= activeArraySize</td>
  /// </tr>
  /// <tr>
  /// <td align="center">android.graphics.ImageFormat\#JPEG</td>
  /// <td align="center">640x480 (480p)</td>
  /// <td align="center">Any</td>
  /// <td align="center">if 480p &lt;= activeArraySize</td>
  /// </tr>
  /// <tr>
  /// <td align="center">android.graphics.ImageFormat\#JPEG</td>
  /// <td align="center">320x240 (240p)</td>
  /// <td align="center">Any</td>
  /// <td align="center">if 240p &lt;= activeArraySize</td>
  /// </tr>
  /// <tr>
  /// <td align="center">android.graphics.ImageFormat\#YUV_420_888</td>
  /// <td align="center">all output sizes available for JPEG</td>
  /// <td align="center">FULL</td>
  /// <td align="center"></td>
  /// </tr>
  /// <tr>
  /// <td align="center">android.graphics.ImageFormat\#YUV_420_888</td>
  /// <td align="center">all output sizes available for JPEG, up to the maximum video size</td>
  /// <td align="center">LIMITED</td>
  /// <td align="center"></td>
  /// </tr>
  /// <tr>
  /// <td align="center">android.graphics.ImageFormat\#PRIVATE</td>
  /// <td align="center">same as YUV_420_888</td>
  /// <td align="center">Any</td>
  /// <td align="center"></td>
  /// </tr>
  /// </tbody>
  /// </table>
  /// Refer to CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities and android.hardware.camera2.CameraDevice\#createCaptureSession for additional mandatory
  /// stream configurations on a per-capability basis.
  ///
  /// *1: For JPEG format, the sizes may be restricted by below conditions:
  ///
  /// <ul>
  /// <li>The HAL may choose the aspect ratio of each Jpeg size to be one of well known ones
  /// (e.g. 4:3, 16:9, 3:2 etc.). If the sensor maximum resolution
  /// (defined by CameraCharacteristics\#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize) has an aspect ratio other than these,
  /// it does not have to be included in the supported JPEG sizes.</li>
  /// <li>Some hardware JPEG encoders may have pixel boundary alignment requirements, such as
  /// the dimensions being a multiple of 16.
  /// Therefore, the maximum JPEG size may be smaller than sensor maximum resolution.
  /// However, the largest JPEG size will be as close as possible to the sensor maximum
  /// resolution given above constraints. It is required that after aspect ratio adjustments,
  /// additional size reduction due to other issues must be less than 3% in area. For example,
  /// if the sensor maximum resolution is 3280x2464, if the maximum JPEG size has aspect
  /// ratio 4:3, and the JPEG encoder alignment requirement is 16, the maximum JPEG size will be
  /// 3264x2448.</li>
  /// </ul>
  /// This key is available on all devices.
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  ///@see CameraCharacteristics\#SENSOR_INFO_ACTIVE_ARRAY_SIZE
  static CameraCharacteristics_Key get SCALER_STREAM_CONFIGURATION_MAP =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SCALER_STREAM_CONFIGURATION_MAP,
              jni.JniType.objectType)
          .object);

  static final _id_SENSOR_AVAILABLE_TEST_PATTERN_MODES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "SENSOR_AVAILABLE_TEST_PATTERN_MODES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> SENSOR_AVAILABLE_TEST_PATTERN_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of sensor test pattern modes for CaptureRequest\#SENSOR_TEST_PATTERN_MODE android.sensor.testPatternMode
  /// supported by this camera device.
  ///
  /// Defaults to OFF, and always includes OFF if defined.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#SENSOR_TEST_PATTERN_MODE android.sensor.testPatternMode
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CaptureRequest\#SENSOR_TEST_PATTERN_MODE
  static CameraCharacteristics_Key get SENSOR_AVAILABLE_TEST_PATTERN_MODES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SENSOR_AVAILABLE_TEST_PATTERN_MODES,
              jni.JniType.objectType)
          .object);

  static final _id_SENSOR_BLACK_LEVEL_PATTERN = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "SENSOR_BLACK_LEVEL_PATTERN",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.hardware.camera2.params.BlackLevelPattern> SENSOR_BLACK_LEVEL_PATTERN
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A fixed black level offset for each of the color filter arrangement
  /// (CFA) mosaic channels.
  ///
  /// This key specifies the zero light value for each of the CFA mosaic
  /// channels in the camera sensor.  The maximal value output by the
  /// sensor is represented by the value in CameraCharacteristics\#SENSOR_INFO_WHITE_LEVEL android.sensor.info.whiteLevel.
  ///
  /// The values are given in the same order as channels listed for the CFA
  /// layout key (see CameraCharacteristics\#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT android.sensor.info.colorFilterArrangement), i.e. the
  /// nth value given corresponds to the black level offset for the nth
  /// color channel listed in the CFA.
  ///
  /// The black level values of captured images may vary for different
  /// capture settings (e.g., CaptureRequest\#SENSOR_SENSITIVITY android.sensor.sensitivity). This key
  /// represents a coarse approximation for such case. It is recommended to
  /// use CaptureResult\#SENSOR_DYNAMIC_BLACK_LEVEL android.sensor.dynamicBlackLevel or use pixels from
  /// CameraCharacteristics\#SENSOR_OPTICAL_BLACK_REGIONS android.sensor.opticalBlackRegions directly for captures when
  /// supported by the camera device, which provides more accurate black
  /// level values. For raw capture in particular, it is recommended to use
  /// pixels from CameraCharacteristics\#SENSOR_OPTICAL_BLACK_REGIONS android.sensor.opticalBlackRegions to calculate black
  /// level values for each frame.
  ///
  /// __Range of valid values:__<br>
  /// &gt;= 0 for each.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CaptureResult\#SENSOR_DYNAMIC_BLACK_LEVEL
  ///@see CameraCharacteristics\#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT
  ///@see CameraCharacteristics\#SENSOR_INFO_WHITE_LEVEL
  ///@see CameraCharacteristics\#SENSOR_OPTICAL_BLACK_REGIONS
  ///@see CaptureRequest\#SENSOR_SENSITIVITY
  static CameraCharacteristics_Key get SENSOR_BLACK_LEVEL_PATTERN =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_SENSOR_BLACK_LEVEL_PATTERN, jni.JniType.objectType)
          .object);

  static final _id_SENSOR_CALIBRATION_TRANSFORM1 =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "SENSOR_CALIBRATION_TRANSFORM1",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.hardware.camera2.params.ColorSpaceTransform> SENSOR_CALIBRATION_TRANSFORM1
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A per-device calibration transform matrix that maps from the
  /// reference sensor colorspace to the actual device sensor colorspace.
  ///
  /// This matrix is used to correct for per-device variations in the
  /// sensor colorspace, and is used for processing raw buffer data.
  ///
  /// The matrix is expressed as a 3x3 matrix in row-major-order, and
  /// contains a per-device calibration transform that maps colors
  /// from reference sensor color space (i.e. the "golden module"
  /// colorspace) into this camera device's native sensor color
  /// space under the first reference illuminant
  /// (CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1 android.sensor.referenceIlluminant1).
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static CameraCharacteristics_Key get SENSOR_CALIBRATION_TRANSFORM1 =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SENSOR_CALIBRATION_TRANSFORM1,
              jni.JniType.objectType)
          .object);

  static final _id_SENSOR_CALIBRATION_TRANSFORM2 =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "SENSOR_CALIBRATION_TRANSFORM2",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.hardware.camera2.params.ColorSpaceTransform> SENSOR_CALIBRATION_TRANSFORM2
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A per-device calibration transform matrix that maps from the
  /// reference sensor colorspace to the actual device sensor colorspace
  /// (this is the colorspace of the raw buffer data).
  ///
  /// This matrix is used to correct for per-device variations in the
  /// sensor colorspace, and is used for processing raw buffer data.
  ///
  /// The matrix is expressed as a 3x3 matrix in row-major-order, and
  /// contains a per-device calibration transform that maps colors
  /// from reference sensor color space (i.e. the "golden module"
  /// colorspace) into this camera device's native sensor color
  /// space under the second reference illuminant
  /// (CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT2 android.sensor.referenceIlluminant2).
  ///
  /// This matrix will only be present if the second reference
  /// illuminant is present.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT2
  static CameraCharacteristics_Key get SENSOR_CALIBRATION_TRANSFORM2 =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SENSOR_CALIBRATION_TRANSFORM2,
              jni.JniType.objectType)
          .object);

  static final _id_SENSOR_COLOR_TRANSFORM1 = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "SENSOR_COLOR_TRANSFORM1",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.hardware.camera2.params.ColorSpaceTransform> SENSOR_COLOR_TRANSFORM1
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A matrix that transforms color values from CIE XYZ color space to
  /// reference sensor color space.
  ///
  /// This matrix is used to convert from the standard CIE XYZ color
  /// space to the reference sensor colorspace, and is used when processing
  /// raw buffer data.
  ///
  /// The matrix is expressed as a 3x3 matrix in row-major-order, and
  /// contains a color transform matrix that maps colors from the CIE
  /// XYZ color space to the reference sensor color space (i.e. the
  /// "golden module" colorspace) under the first reference illuminant
  /// (CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1 android.sensor.referenceIlluminant1).
  ///
  /// The white points chosen in both the reference sensor color space
  /// and the CIE XYZ colorspace when calculating this transform will
  /// match the standard white point for the first reference illuminant
  /// (i.e. no chromatic adaptation will be applied by this transform).
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static CameraCharacteristics_Key get SENSOR_COLOR_TRANSFORM1 =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_SENSOR_COLOR_TRANSFORM1, jni.JniType.objectType)
          .object);

  static final _id_SENSOR_COLOR_TRANSFORM2 = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "SENSOR_COLOR_TRANSFORM2",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.hardware.camera2.params.ColorSpaceTransform> SENSOR_COLOR_TRANSFORM2
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A matrix that transforms color values from CIE XYZ color space to
  /// reference sensor color space.
  ///
  /// This matrix is used to convert from the standard CIE XYZ color
  /// space to the reference sensor colorspace, and is used when processing
  /// raw buffer data.
  ///
  /// The matrix is expressed as a 3x3 matrix in row-major-order, and
  /// contains a color transform matrix that maps colors from the CIE
  /// XYZ color space to the reference sensor color space (i.e. the
  /// "golden module" colorspace) under the second reference illuminant
  /// (CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT2 android.sensor.referenceIlluminant2).
  ///
  /// The white points chosen in both the reference sensor color space
  /// and the CIE XYZ colorspace when calculating this transform will
  /// match the standard white point for the second reference illuminant
  /// (i.e. no chromatic adaptation will be applied by this transform).
  ///
  /// This matrix will only be present if the second reference
  /// illuminant is present.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT2
  static CameraCharacteristics_Key get SENSOR_COLOR_TRANSFORM2 =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_SENSOR_COLOR_TRANSFORM2, jni.JniType.objectType)
          .object);

  static final _id_SENSOR_FORWARD_MATRIX1 = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "SENSOR_FORWARD_MATRIX1",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.hardware.camera2.params.ColorSpaceTransform> SENSOR_FORWARD_MATRIX1
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A matrix that transforms white balanced camera colors from the reference
  /// sensor colorspace to the CIE XYZ colorspace with a D50 whitepoint.
  ///
  /// This matrix is used to convert to the standard CIE XYZ colorspace, and
  /// is used when processing raw buffer data.
  ///
  /// This matrix is expressed as a 3x3 matrix in row-major-order, and contains
  /// a color transform matrix that maps white balanced colors from the
  /// reference sensor color space to the CIE XYZ color space with a D50 white
  /// point.
  ///
  /// Under the first reference illuminant (CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1 android.sensor.referenceIlluminant1)
  /// this matrix is chosen so that the standard white point for this reference
  /// illuminant in the reference sensor colorspace is mapped to D50 in the
  /// CIE XYZ colorspace.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static CameraCharacteristics_Key get SENSOR_FORWARD_MATRIX1 =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_SENSOR_FORWARD_MATRIX1, jni.JniType.objectType)
          .object);

  static final _id_SENSOR_FORWARD_MATRIX2 = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "SENSOR_FORWARD_MATRIX2",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.hardware.camera2.params.ColorSpaceTransform> SENSOR_FORWARD_MATRIX2
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A matrix that transforms white balanced camera colors from the reference
  /// sensor colorspace to the CIE XYZ colorspace with a D50 whitepoint.
  ///
  /// This matrix is used to convert to the standard CIE XYZ colorspace, and
  /// is used when processing raw buffer data.
  ///
  /// This matrix is expressed as a 3x3 matrix in row-major-order, and contains
  /// a color transform matrix that maps white balanced colors from the
  /// reference sensor color space to the CIE XYZ color space with a D50 white
  /// point.
  ///
  /// Under the second reference illuminant (CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT2 android.sensor.referenceIlluminant2)
  /// this matrix is chosen so that the standard white point for this reference
  /// illuminant in the reference sensor colorspace is mapped to D50 in the
  /// CIE XYZ colorspace.
  ///
  /// This matrix will only be present if the second reference
  /// illuminant is present.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT2
  static CameraCharacteristics_Key get SENSOR_FORWARD_MATRIX2 =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_SENSOR_FORWARD_MATRIX2, jni.JniType.objectType)
          .object);

  static final _id_SENSOR_INFO_ACTIVE_ARRAY_SIZE =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "SENSOR_INFO_ACTIVE_ARRAY_SIZE",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.graphics.Rect> SENSOR_INFO_ACTIVE_ARRAY_SIZE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The area of the image sensor which corresponds to active pixels after any geometric
  /// distortion correction has been applied.
  ///
  /// This is the rectangle representing the size of the active region of the sensor (i.e.
  /// the region that actually receives light from the scene) after any geometric correction
  /// has been applied, and should be treated as the maximum size in pixels of any of the
  /// image output formats aside from the raw formats.
  ///
  /// This rectangle is defined relative to the full pixel array; (0,0) is the top-left of
  /// the full pixel array, and the size of the full pixel array is given by
  /// CameraCharacteristics\#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize.
  ///
  /// The coordinate system for most other keys that list pixel coordinates, including
  /// CaptureRequest\#SCALER_CROP_REGION android.scaler.cropRegion, is defined relative to the active array rectangle given in
  /// this field, with <code>(0, 0)</code> being the top-left of this rectangle.
  ///
  /// The active array may be smaller than the full pixel array, since the full array may
  /// include black calibration pixels or other inactive regions.
  ///
  /// For devices that do not support CaptureRequest\#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode control, the active
  /// array must be the same as CameraCharacteristics\#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize.
  ///
  /// For devices that support CaptureRequest\#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode control, the active array must
  /// be enclosed by CameraCharacteristics\#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize. The difference between
  /// pre-correction active array and active array accounts for scaling or cropping caused
  /// by lens geometric distortion correction.
  ///
  /// In general, application should always refer to active array size for controls like
  /// metering regions or crop region. Two exceptions are when the application is dealing with
  /// RAW image buffers (RAW_SENSOR, RAW10, RAW12 etc), or when application explicitly set
  /// CaptureRequest\#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode to OFF. In these cases, application should refer
  /// to CameraCharacteristics\#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize.
  ///
  /// __Units__: Pixel coordinates on the image sensor
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#DISTORTION_CORRECTION_MODE
  ///@see CaptureRequest\#SCALER_CROP_REGION
  ///@see CameraCharacteristics\#SENSOR_INFO_PIXEL_ARRAY_SIZE
  ///@see CameraCharacteristics\#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE
  static CameraCharacteristics_Key get SENSOR_INFO_ACTIVE_ARRAY_SIZE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SENSOR_INFO_ACTIVE_ARRAY_SIZE,
              jni.JniType.objectType)
          .object);

  static final _id_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> SENSOR_INFO_COLOR_FILTER_ARRANGEMENT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The arrangement of color filters on sensor;
  /// represents the colors in the top-left 2x2 section of
  /// the sensor, in reading order.
  ///
  /// __Possible values:__
  /// <ul>
  ///   <li>\#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGGB RGGB</li>
  ///   <li>\#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GRBG GRBG</li>
  ///   <li>\#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GBRG GBRG</li>
  ///   <li>\#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_BGGR BGGR</li>
  ///   <li>\#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGB RGB</li>
  /// </ul>
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Full capability__ -
  /// Present on all camera devices that report being CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see \#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGGB
  ///@see \#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GRBG
  ///@see \#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GBRG
  ///@see \#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_BGGR
  ///@see \#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGB
  static CameraCharacteristics_Key get SENSOR_INFO_COLOR_FILTER_ARRANGEMENT =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT,
              jni.JniType.objectType)
          .object);

  static final _id_SENSOR_INFO_EXPOSURE_TIME_RANGE =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "SENSOR_INFO_EXPOSURE_TIME_RANGE",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.util.Range<java.lang.Long>> SENSOR_INFO_EXPOSURE_TIME_RANGE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The range of image exposure times for CaptureRequest\#SENSOR_EXPOSURE_TIME android.sensor.exposureTime supported
  /// by this camera device.
  ///
  /// __Units__: Nanoseconds
  ///
  /// __Range of valid values:__<br>
  /// The minimum exposure time will be less than 100 us. For FULL
  /// capability devices (CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel == FULL),
  /// the maximum exposure time will be greater than 100ms.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Full capability__ -
  /// Present on all camera devices that report being CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CaptureRequest\#SENSOR_EXPOSURE_TIME
  static CameraCharacteristics_Key get SENSOR_INFO_EXPOSURE_TIME_RANGE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SENSOR_INFO_EXPOSURE_TIME_RANGE,
              jni.JniType.objectType)
          .object);

  static final _id_SENSOR_INFO_LENS_SHADING_APPLIED =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "SENSOR_INFO_LENS_SHADING_APPLIED",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Boolean> SENSOR_INFO_LENS_SHADING_APPLIED
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Whether the RAW images output from this camera device are subject to
  /// lens shading correction.
  ///
  /// If TRUE, all images produced by the camera device in the RAW image formats will
  /// have lens shading correction already applied to it. If FALSE, the images will
  /// not be adjusted for lens shading correction.
  /// See CameraCharacteristics\#REQUEST_MAX_NUM_OUTPUT_RAW android.request.maxNumOutputRaw for a list of RAW image formats.
  ///
  /// This key will be <code>null</code> for all devices do not report this information.
  /// Devices with RAW capability will always report this information in this key.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CameraCharacteristics\#REQUEST_MAX_NUM_OUTPUT_RAW
  static CameraCharacteristics_Key get SENSOR_INFO_LENS_SHADING_APPLIED =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SENSOR_INFO_LENS_SHADING_APPLIED,
              jni.JniType.objectType)
          .object);

  static final _id_SENSOR_INFO_MAX_FRAME_DURATION =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "SENSOR_INFO_MAX_FRAME_DURATION",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Long> SENSOR_INFO_MAX_FRAME_DURATION
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The maximum possible frame duration (minimum frame rate) for
  /// CaptureRequest\#SENSOR_FRAME_DURATION android.sensor.frameDuration that is supported this camera device.
  ///
  /// Attempting to use frame durations beyond the maximum will result in the frame
  /// duration being clipped to the maximum. See that control for a full definition of frame
  /// durations.
  ///
  /// Refer to android.hardware.camera2.params.StreamConfigurationMap\#getOutputMinFrameDuration
  /// for the minimum frame duration values.
  ///
  /// __Units__: Nanoseconds
  ///
  /// __Range of valid values:__<br>
  /// For FULL capability devices
  /// (CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel == FULL), at least 100ms.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Full capability__ -
  /// Present on all camera devices that report being CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CaptureRequest\#SENSOR_FRAME_DURATION
  static CameraCharacteristics_Key get SENSOR_INFO_MAX_FRAME_DURATION =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SENSOR_INFO_MAX_FRAME_DURATION,
              jni.JniType.objectType)
          .object);

  static final _id_SENSOR_INFO_PHYSICAL_SIZE = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "SENSOR_INFO_PHYSICAL_SIZE",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.util.SizeF> SENSOR_INFO_PHYSICAL_SIZE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The physical dimensions of the full pixel
  /// array.
  ///
  /// This is the physical size of the sensor pixel
  /// array defined by CameraCharacteristics\#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize.
  ///
  /// __Units__: Millimeters
  ///
  /// This key is available on all devices.
  ///
  ///@see CameraCharacteristics\#SENSOR_INFO_PIXEL_ARRAY_SIZE
  static CameraCharacteristics_Key get SENSOR_INFO_PHYSICAL_SIZE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_SENSOR_INFO_PHYSICAL_SIZE, jni.JniType.objectType)
          .object);

  static final _id_SENSOR_INFO_PIXEL_ARRAY_SIZE =
      jniAccessors.getStaticFieldIDOf(_classRef, "SENSOR_INFO_PIXEL_ARRAY_SIZE",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.util.Size> SENSOR_INFO_PIXEL_ARRAY_SIZE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Dimensions of the full pixel array, possibly
  /// including black calibration pixels.
  ///
  /// The pixel count of the full pixel array of the image sensor, which covers
  /// CameraCharacteristics\#SENSOR_INFO_PHYSICAL_SIZE android.sensor.info.physicalSize area.  This represents the full pixel dimensions of
  /// the raw buffers produced by this sensor.
  ///
  /// If a camera device supports raw sensor formats, either this or
  /// CameraCharacteristics\#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize is the maximum dimensions for the raw
  /// output formats listed in android.hardware.camera2.params.StreamConfigurationMap
  /// (this depends on whether or not the image sensor returns buffers containing pixels that
  /// are not part of the active array region for blacklevel calibration or other purposes).
  ///
  /// Some parts of the full pixel array may not receive light from the scene,
  /// or be otherwise inactive.  The CameraCharacteristics\#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize key
  /// defines the rectangle of active pixels that will be included in processed image
  /// formats.
  ///
  /// __Units__: Pixels
  ///
  /// This key is available on all devices.
  ///
  ///@see CameraCharacteristics\#SENSOR_INFO_PHYSICAL_SIZE
  ///@see CameraCharacteristics\#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE
  static CameraCharacteristics_Key get SENSOR_INFO_PIXEL_ARRAY_SIZE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SENSOR_INFO_PIXEL_ARRAY_SIZE,
              jni.JniType.objectType)
          .object);

  static final _id_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.graphics.Rect> SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The area of the image sensor which corresponds to active pixels prior to the
  /// application of any geometric distortion correction.
  ///
  /// This is the rectangle representing the size of the active region of the sensor (i.e.
  /// the region that actually receives light from the scene) before any geometric correction
  /// has been applied, and should be treated as the active region rectangle for any of the
  /// raw formats.  All metadata associated with raw processing (e.g. the lens shading
  /// correction map, and radial distortion fields) treats the top, left of this rectangle as
  /// the origin, (0,0).
  ///
  /// The size of this region determines the maximum field of view and the maximum number of
  /// pixels that an image from this sensor can contain, prior to the application of
  /// geometric distortion correction. The effective maximum pixel dimensions of a
  /// post-distortion-corrected image is given by the CameraCharacteristics\#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize
  /// field, and the effective maximum field of view for a post-distortion-corrected image
  /// can be calculated by applying the geometric distortion correction fields to this
  /// rectangle, and cropping to the rectangle given in CameraCharacteristics\#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize.
  ///
  /// E.g. to calculate position of a pixel, (x,y), in a processed YUV output image with the
  /// dimensions in CameraCharacteristics\#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize given the position of a pixel,
  /// (x', y'), in the raw pixel array with dimensions give in
  /// CameraCharacteristics\#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize:
  ///
  /// <ol>
  /// <li>Choose a pixel (x', y') within the active array region of the raw buffer given in
  /// CameraCharacteristics\#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize, otherwise this pixel is considered
  /// to be outside of the FOV, and will not be shown in the processed output image.</li>
  /// <li>Apply geometric distortion correction to get the post-distortion pixel coordinate,
  /// (x_i, y_i). When applying geometric correction metadata, note that metadata for raw
  /// buffers is defined relative to the top, left of the
  /// CameraCharacteristics\#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize rectangle.</li>
  /// <li>If the resulting corrected pixel coordinate is within the region given in
  /// CameraCharacteristics\#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize, then the position of this pixel in the
  /// processed output image buffer is <code>(x_i - activeArray.left, y_i - activeArray.top)</code>,
  /// when the top, left coordinate of that buffer is treated as (0, 0).</li>
  /// </ol>
  /// Thus, for pixel x',y' = (25, 25) on a sensor where CameraCharacteristics\#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize
  /// is (100,100), CameraCharacteristics\#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize is (10, 10, 100, 100),
  /// CameraCharacteristics\#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize is (20, 20, 80, 80), and the geometric distortion
  /// correction doesn't change the pixel coordinate, the resulting pixel selected in
  /// pixel coordinates would be x,y = (25, 25) relative to the top,left of the raw buffer
  /// with dimensions given in CameraCharacteristics\#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize, and would be (5, 5)
  /// relative to the top,left of post-processed YUV output buffer with dimensions given in
  /// CameraCharacteristics\#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize.
  ///
  /// The currently supported fields that correct for geometric distortion are:
  ///
  /// <ol>
  /// <li>CameraCharacteristics\#LENS_DISTORTION android.lens.distortion.</li>
  /// </ol>
  /// If the camera device doesn't support geometric distortion correction, or all of the
  /// geometric distortion fields are no-ops, this rectangle will be the same as the
  /// post-distortion-corrected rectangle given in CameraCharacteristics\#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize.
  ///
  /// This rectangle is defined relative to the full pixel array; (0,0) is the top-left of
  /// the full pixel array, and the size of the full pixel array is given by
  /// CameraCharacteristics\#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize.
  ///
  /// The pre-correction active array may be smaller than the full pixel array, since the
  /// full array may include black calibration pixels or other inactive regions.
  ///
  /// __Units__: Pixel coordinates on the image sensor
  ///
  /// This key is available on all devices.
  ///
  ///@see CameraCharacteristics\#LENS_DISTORTION
  ///@see CameraCharacteristics\#SENSOR_INFO_ACTIVE_ARRAY_SIZE
  ///@see CameraCharacteristics\#SENSOR_INFO_PIXEL_ARRAY_SIZE
  ///@see CameraCharacteristics\#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE
  static CameraCharacteristics_Key
      get SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE =>
          CameraCharacteristics_Key.fromRef(jniAccessors
              .getStaticField(
                  _classRef,
                  _id_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE,
                  jni.JniType.objectType)
              .object);

  static final _id_SENSOR_INFO_SENSITIVITY_RANGE =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "SENSOR_INFO_SENSITIVITY_RANGE",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.util.Range<java.lang.Integer>> SENSOR_INFO_SENSITIVITY_RANGE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Range of sensitivities for CaptureRequest\#SENSOR_SENSITIVITY android.sensor.sensitivity supported by this
  /// camera device.
  ///
  /// The values are the standard ISO sensitivity values,
  /// as defined in ISO 12232:2006.
  ///
  /// __Range of valid values:__<br>
  /// Min &lt;= 100, Max &gt;= 800
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Full capability__ -
  /// Present on all camera devices that report being CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CaptureRequest\#SENSOR_SENSITIVITY
  static CameraCharacteristics_Key get SENSOR_INFO_SENSITIVITY_RANGE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SENSOR_INFO_SENSITIVITY_RANGE,
              jni.JniType.objectType)
          .object);

  static final _id_SENSOR_INFO_TIMESTAMP_SOURCE =
      jniAccessors.getStaticFieldIDOf(_classRef, "SENSOR_INFO_TIMESTAMP_SOURCE",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> SENSOR_INFO_TIMESTAMP_SOURCE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The time base source for sensor capture start timestamps.
  ///
  /// The timestamps provided for captures are always in nanoseconds and monotonic, but
  /// may not based on a time source that can be compared to other system time sources.
  ///
  /// This characteristic defines the source for the timestamps, and therefore whether they
  /// can be compared against other system time sources/timestamps.
  ///
  /// __Possible values:__
  /// <ul>
  ///   <li>\#SENSOR_INFO_TIMESTAMP_SOURCE_UNKNOWN UNKNOWN</li>
  ///   <li>\#SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME REALTIME</li>
  /// </ul>
  ///
  /// This key is available on all devices.
  ///
  ///@see \#SENSOR_INFO_TIMESTAMP_SOURCE_UNKNOWN
  ///@see \#SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME
  static CameraCharacteristics_Key get SENSOR_INFO_TIMESTAMP_SOURCE =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SENSOR_INFO_TIMESTAMP_SOURCE,
              jni.JniType.objectType)
          .object);

  static final _id_SENSOR_INFO_WHITE_LEVEL = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "SENSOR_INFO_WHITE_LEVEL",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> SENSOR_INFO_WHITE_LEVEL
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Maximum raw value output by sensor.
  ///
  /// This specifies the fully-saturated encoding level for the raw
  /// sample values from the sensor.  This is typically caused by the
  /// sensor becoming highly non-linear or clipping. The minimum for
  /// each channel is specified by the offset in the
  /// CameraCharacteristics\#SENSOR_BLACK_LEVEL_PATTERN android.sensor.blackLevelPattern key.
  ///
  /// The white level is typically determined either by sensor bit depth
  /// (8-14 bits is expected), or by the point where the sensor response
  /// becomes too non-linear to be useful.  The default value for this is
  /// maximum representable value for a 16-bit raw sample (2^16 - 1).
  ///
  /// The white level values of captured images may vary for different
  /// capture settings (e.g., CaptureRequest\#SENSOR_SENSITIVITY android.sensor.sensitivity). This key
  /// represents a coarse approximation for such case. It is recommended
  /// to use CaptureResult\#SENSOR_DYNAMIC_WHITE_LEVEL android.sensor.dynamicWhiteLevel for captures when supported
  /// by the camera device, which provides more accurate white level values.
  ///
  /// __Range of valid values:__<br>
  /// &gt; 255 (8-bit output)
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CameraCharacteristics\#SENSOR_BLACK_LEVEL_PATTERN
  ///@see CaptureResult\#SENSOR_DYNAMIC_WHITE_LEVEL
  ///@see CaptureRequest\#SENSOR_SENSITIVITY
  static CameraCharacteristics_Key get SENSOR_INFO_WHITE_LEVEL =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_SENSOR_INFO_WHITE_LEVEL, jni.JniType.objectType)
          .object);

  static final _id_SENSOR_MAX_ANALOG_SENSITIVITY =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "SENSOR_MAX_ANALOG_SENSITIVITY",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> SENSOR_MAX_ANALOG_SENSITIVITY
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Maximum sensitivity that is implemented
  /// purely through analog gain.
  ///
  /// For CaptureRequest\#SENSOR_SENSITIVITY android.sensor.sensitivity values less than or
  /// equal to this, all applied gain must be analog. For
  /// values above this, the gain applied can be a mix of analog and
  /// digital.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Full capability__ -
  /// Present on all camera devices that report being CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CaptureRequest\#SENSOR_SENSITIVITY
  static CameraCharacteristics_Key get SENSOR_MAX_ANALOG_SENSITIVITY =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SENSOR_MAX_ANALOG_SENSITIVITY,
              jni.JniType.objectType)
          .object);

  static final _id_SENSOR_OPTICAL_BLACK_REGIONS =
      jniAccessors.getStaticFieldIDOf(_classRef, "SENSOR_OPTICAL_BLACK_REGIONS",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<android.graphics.Rect[]> SENSOR_OPTICAL_BLACK_REGIONS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of disjoint rectangles indicating the sensor
  /// optically shielded black pixel regions.
  ///
  /// In most camera sensors, the active array is surrounded by some
  /// optically shielded pixel areas. By blocking light, these pixels
  /// provides a reliable black reference for black level compensation
  /// in active array region.
  ///
  /// This key provides a list of disjoint rectangles specifying the
  /// regions of optically shielded (with metal shield) black pixel
  /// regions if the camera device is capable of reading out these black
  /// pixels in the output raw images. In comparison to the fixed black
  /// level values reported by CameraCharacteristics\#SENSOR_BLACK_LEVEL_PATTERN android.sensor.blackLevelPattern, this key
  /// may provide a more accurate way for the application to calculate
  /// black level of each captured raw images.
  ///
  /// When this key is reported, the CaptureResult\#SENSOR_DYNAMIC_BLACK_LEVEL android.sensor.dynamicBlackLevel and
  /// CaptureResult\#SENSOR_DYNAMIC_WHITE_LEVEL android.sensor.dynamicWhiteLevel will also be reported.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CameraCharacteristics\#SENSOR_BLACK_LEVEL_PATTERN
  ///@see CaptureResult\#SENSOR_DYNAMIC_BLACK_LEVEL
  ///@see CaptureResult\#SENSOR_DYNAMIC_WHITE_LEVEL
  static CameraCharacteristics_Key get SENSOR_OPTICAL_BLACK_REGIONS =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SENSOR_OPTICAL_BLACK_REGIONS,
              jni.JniType.objectType)
          .object);

  static final _id_SENSOR_ORIENTATION = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "SENSOR_ORIENTATION",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> SENSOR_ORIENTATION
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Clockwise angle through which the output image needs to be rotated to be
  /// upright on the device screen in its native orientation.
  ///
  /// Also defines the direction of rolling shutter readout, which is from top to bottom in
  /// the sensor's coordinate system.
  ///
  /// __Units__: Degrees of clockwise rotation; always a multiple of
  /// 90
  ///
  /// __Range of valid values:__<br>
  /// 0, 90, 180, 270
  ///
  /// This key is available on all devices.
  ///
  static CameraCharacteristics_Key get SENSOR_ORIENTATION =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_SENSOR_ORIENTATION, jni.JniType.objectType)
          .object);

  static final _id_SENSOR_REFERENCE_ILLUMINANT1 =
      jniAccessors.getStaticFieldIDOf(_classRef, "SENSOR_REFERENCE_ILLUMINANT1",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> SENSOR_REFERENCE_ILLUMINANT1
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The standard reference illuminant used as the scene light source when
  /// calculating the CameraCharacteristics\#SENSOR_COLOR_TRANSFORM1 android.sensor.colorTransform1,
  /// CameraCharacteristics\#SENSOR_CALIBRATION_TRANSFORM1 android.sensor.calibrationTransform1, and
  /// CameraCharacteristics\#SENSOR_FORWARD_MATRIX1 android.sensor.forwardMatrix1 matrices.
  ///
  /// The values in this key correspond to the values defined for the
  /// EXIF LightSource tag. These illuminants are standard light sources
  /// that are often used calibrating camera devices.
  ///
  /// If this key is present, then CameraCharacteristics\#SENSOR_COLOR_TRANSFORM1 android.sensor.colorTransform1,
  /// CameraCharacteristics\#SENSOR_CALIBRATION_TRANSFORM1 android.sensor.calibrationTransform1, and
  /// CameraCharacteristics\#SENSOR_FORWARD_MATRIX1 android.sensor.forwardMatrix1 will also be present.
  ///
  /// Some devices may choose to provide a second set of calibration
  /// information for improved quality, including
  /// CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT2 android.sensor.referenceIlluminant2 and its corresponding matrices.
  ///
  /// __Possible values:__
  /// <ul>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT DAYLIGHT</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_FLUORESCENT FLUORESCENT</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_TUNGSTEN TUNGSTEN</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_FLASH FLASH</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_FINE_WEATHER FINE_WEATHER</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_CLOUDY_WEATHER CLOUDY_WEATHER</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_SHADE SHADE</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT_FLUORESCENT DAYLIGHT_FLUORESCENT</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_DAY_WHITE_FLUORESCENT DAY_WHITE_FLUORESCENT</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_COOL_WHITE_FLUORESCENT COOL_WHITE_FLUORESCENT</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_WHITE_FLUORESCENT WHITE_FLUORESCENT</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_STANDARD_A STANDARD_A</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_STANDARD_B STANDARD_B</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_STANDARD_C STANDARD_C</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_D55 D55</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_D65 D65</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_D75 D75</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_D50 D50</li>
  ///   <li>\#SENSOR_REFERENCE_ILLUMINANT1_ISO_STUDIO_TUNGSTEN ISO_STUDIO_TUNGSTEN</li>
  /// </ul>
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CameraCharacteristics\#SENSOR_CALIBRATION_TRANSFORM1
  ///@see CameraCharacteristics\#SENSOR_COLOR_TRANSFORM1
  ///@see CameraCharacteristics\#SENSOR_FORWARD_MATRIX1
  ///@see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT2
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_FLUORESCENT
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_TUNGSTEN
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_FLASH
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_FINE_WEATHER
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_CLOUDY_WEATHER
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_SHADE
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT_FLUORESCENT
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_DAY_WHITE_FLUORESCENT
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_COOL_WHITE_FLUORESCENT
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_WHITE_FLUORESCENT
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_STANDARD_A
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_STANDARD_B
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_STANDARD_C
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_D55
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_D65
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_D75
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_D50
  ///@see \#SENSOR_REFERENCE_ILLUMINANT1_ISO_STUDIO_TUNGSTEN
  static CameraCharacteristics_Key get SENSOR_REFERENCE_ILLUMINANT1 =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SENSOR_REFERENCE_ILLUMINANT1,
              jni.JniType.objectType)
          .object);

  static final _id_SENSOR_REFERENCE_ILLUMINANT2 =
      jniAccessors.getStaticFieldIDOf(_classRef, "SENSOR_REFERENCE_ILLUMINANT2",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Byte> SENSOR_REFERENCE_ILLUMINANT2
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The standard reference illuminant used as the scene light source when
  /// calculating the CameraCharacteristics\#SENSOR_COLOR_TRANSFORM2 android.sensor.colorTransform2,
  /// CameraCharacteristics\#SENSOR_CALIBRATION_TRANSFORM2 android.sensor.calibrationTransform2, and
  /// CameraCharacteristics\#SENSOR_FORWARD_MATRIX2 android.sensor.forwardMatrix2 matrices.
  ///
  /// See CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1 android.sensor.referenceIlluminant1 for more details.
  ///
  /// If this key is present, then CameraCharacteristics\#SENSOR_COLOR_TRANSFORM2 android.sensor.colorTransform2,
  /// CameraCharacteristics\#SENSOR_CALIBRATION_TRANSFORM2 android.sensor.calibrationTransform2, and
  /// CameraCharacteristics\#SENSOR_FORWARD_MATRIX2 android.sensor.forwardMatrix2 will also be present.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1 android.sensor.referenceIlluminant1
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CameraCharacteristics\#SENSOR_CALIBRATION_TRANSFORM2
  ///@see CameraCharacteristics\#SENSOR_COLOR_TRANSFORM2
  ///@see CameraCharacteristics\#SENSOR_FORWARD_MATRIX2
  ///@see CameraCharacteristics\#SENSOR_REFERENCE_ILLUMINANT1
  static CameraCharacteristics_Key get SENSOR_REFERENCE_ILLUMINANT2 =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_SENSOR_REFERENCE_ILLUMINANT2,
              jni.JniType.objectType)
          .object);

  static final _id_SHADING_AVAILABLE_MODES = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "SHADING_AVAILABLE_MODES",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> SHADING_AVAILABLE_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of lens shading modes for CaptureRequest\#SHADING_MODE android.shading.mode that are supported by this camera device.
  ///
  /// This list contains lens shading modes that can be set for the camera device.
  /// Camera devices that support the MANUAL_POST_PROCESSING capability will always
  /// list OFF and FAST mode. This includes all FULL level devices.
  /// LEGACY devices will always only support FAST mode.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#SHADING_MODE android.shading.mode
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#SHADING_MODE
  static CameraCharacteristics_Key get SHADING_AVAILABLE_MODES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_SHADING_AVAILABLE_MODES, jni.JniType.objectType)
          .object);

  static final _id_STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of face detection modes for CaptureRequest\#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode that are
  /// supported by this camera device.
  ///
  /// OFF is always supported.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode
  ///
  /// This key is available on all devices.
  ///
  ///@see CaptureRequest\#STATISTICS_FACE_DETECT_MODE
  static CameraCharacteristics_Key
      get STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES =>
          CameraCharacteristics_Key.fromRef(jniAccessors
              .getStaticField(
                  _classRef,
                  _id_STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES,
                  jni.JniType.objectType)
              .object);

  static final _id_STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<boolean[]> STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of hot pixel map output modes for CaptureRequest\#STATISTICS_HOT_PIXEL_MAP_MODE android.statistics.hotPixelMapMode that are
  /// supported by this camera device.
  ///
  /// If no hotpixel map output is available for this camera device, this will contain only
  /// <code>false</code>.
  ///
  /// ON is always supported on devices with the RAW capability.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#STATISTICS_HOT_PIXEL_MAP_MODE android.statistics.hotPixelMapMode
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CaptureRequest\#STATISTICS_HOT_PIXEL_MAP_MODE
  static CameraCharacteristics_Key
      get STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES =>
          CameraCharacteristics_Key.fromRef(jniAccessors
              .getStaticField(
                  _classRef,
                  _id_STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES,
                  jni.JniType.objectType)
              .object);

  static final _id_STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of lens shading map output modes for CaptureRequest\#STATISTICS_LENS_SHADING_MAP_MODE android.statistics.lensShadingMapMode that
  /// are supported by this camera device.
  ///
  /// If no lens shading map output is available for this camera device, this key will
  /// contain only OFF.
  ///
  /// ON is always supported on devices with the RAW capability.
  /// LEGACY mode devices will always only support OFF.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#STATISTICS_LENS_SHADING_MAP_MODE android.statistics.lensShadingMapMode
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CaptureRequest\#STATISTICS_LENS_SHADING_MAP_MODE
  static CameraCharacteristics_Key
      get STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES =>
          CameraCharacteristics_Key.fromRef(jniAccessors
              .getStaticField(
                  _classRef,
                  _id_STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES,
                  jni.JniType.objectType)
              .object);

  static final _id_STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of OIS data output modes for CaptureRequest\#STATISTICS_OIS_DATA_MODE android.statistics.oisDataMode that
  /// are supported by this camera device.
  ///
  /// If no OIS data output is available for this camera device, this key will
  /// contain only OFF.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#STATISTICS_OIS_DATA_MODE android.statistics.oisDataMode
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  ///@see CaptureRequest\#STATISTICS_OIS_DATA_MODE
  static CameraCharacteristics_Key
      get STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES =>
          CameraCharacteristics_Key.fromRef(jniAccessors
              .getStaticField(
                  _classRef,
                  _id_STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES,
                  jni.JniType.objectType)
              .object);

  static final _id_STATISTICS_INFO_MAX_FACE_COUNT =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "STATISTICS_INFO_MAX_FACE_COUNT",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> STATISTICS_INFO_MAX_FACE_COUNT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The maximum number of simultaneously detectable
  /// faces.
  ///
  /// __Range of valid values:__<br>
  /// 0 for cameras without available face detection; otherwise:
  /// <code>&gt;=4</code> for LIMITED or FULL hwlevel devices or
  /// <code>&gt;0</code> for LEGACY devices.
  ///
  /// This key is available on all devices.
  ///
  static CameraCharacteristics_Key get STATISTICS_INFO_MAX_FACE_COUNT =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_STATISTICS_INFO_MAX_FACE_COUNT,
              jni.JniType.objectType)
          .object);

  static final _id_SYNC_MAX_LATENCY = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "SYNC_MAX_LATENCY",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> SYNC_MAX_LATENCY
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The maximum number of frames that can occur after a request
  /// (different than the previous) has been submitted, and before the
  /// result's state becomes synchronized.
  ///
  /// This defines the maximum distance (in number of metadata results),
  /// between the frame number of the request that has new controls to apply
  /// and the frame number of the result that has all the controls applied.
  ///
  /// In other words this acts as an upper boundary for how many frames
  /// must occur before the camera device knows for a fact that the new
  /// submitted camera settings have been applied in outgoing frames.
  ///
  /// __Units__: Frame counts
  ///
  /// __Possible values:__
  /// <ul>
  ///   <li>\#SYNC_MAX_LATENCY_PER_FRAME_CONTROL PER_FRAME_CONTROL</li>
  ///   <li>\#SYNC_MAX_LATENCY_UNKNOWN UNKNOWN</li>
  /// </ul>
  ///
  /// __Available values for this device:__<br>
  /// A positive value, PER_FRAME_CONTROL, or UNKNOWN.
  ///
  /// This key is available on all devices.
  ///
  ///@see \#SYNC_MAX_LATENCY_PER_FRAME_CONTROL
  ///@see \#SYNC_MAX_LATENCY_UNKNOWN
  static CameraCharacteristics_Key get SYNC_MAX_LATENCY =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_SYNC_MAX_LATENCY, jni.JniType.objectType)
          .object);

  static final _id_TONEMAP_AVAILABLE_TONE_MAP_MODES =
      jniAccessors.getStaticFieldIDOf(
          _classRef,
          "TONEMAP_AVAILABLE_TONE_MAP_MODES",
          "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<int[]> TONEMAP_AVAILABLE_TONE_MAP_MODES
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// List of tonemapping modes for CaptureRequest\#TONEMAP_MODE android.tonemap.mode that are supported by this camera
  /// device.
  ///
  /// Camera devices that support the MANUAL_POST_PROCESSING capability will always contain
  /// at least one of below mode combinations:
  ///
  /// <ul>
  /// <li>CONTRAST_CURVE, FAST and HIGH_QUALITY</li>
  /// <li>GAMMA_VALUE, PRESET_CURVE, FAST and HIGH_QUALITY</li>
  /// </ul>
  /// This includes all FULL level devices.
  ///
  /// __Range of valid values:__<br>
  /// Any value listed in CaptureRequest\#TONEMAP_MODE android.tonemap.mode
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Full capability__ -
  /// Present on all camera devices that report being CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CaptureRequest\#TONEMAP_MODE
  static CameraCharacteristics_Key get TONEMAP_AVAILABLE_TONE_MAP_MODES =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(_classRef, _id_TONEMAP_AVAILABLE_TONE_MAP_MODES,
              jni.JniType.objectType)
          .object);

  static final _id_TONEMAP_MAX_CURVE_POINTS = jniAccessors.getStaticFieldIDOf(
      _classRef,
      "TONEMAP_MAX_CURVE_POINTS",
      "Landroid/hardware/camera2/CameraCharacteristics\$Key;");

  /// from: static public final android.hardware.camera2.CameraCharacteristics.Key<java.lang.Integer> TONEMAP_MAX_CURVE_POINTS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Maximum number of supported points in the
  /// tonemap curve that can be used for CaptureRequest\#TONEMAP_CURVE android.tonemap.curve.
  ///
  /// If the actual number of points provided by the application (in CaptureRequest\#TONEMAP_CURVE android.tonemap.curve*) is
  /// less than this maximum, the camera device will resample the curve to its internal
  /// representation, using linear interpolation.
  ///
  /// The output curves in the result metadata may have a different number
  /// of points than the input curves, and will represent the actual
  /// hardware curves used as closely as possible when linearly interpolated.
  ///
  /// __Optional__ - This value may be {@code null} on some devices.
  ///
  /// __Full capability__ -
  /// Present on all camera devices that report being CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL devices in the
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel key
  ///
  ///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  ///@see CaptureRequest\#TONEMAP_CURVE
  static CameraCharacteristics_Key get TONEMAP_MAX_CURVE_POINTS =>
      CameraCharacteristics_Key.fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_TONEMAP_MAX_CURVE_POINTS, jni.JniType.objectType)
          .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  CameraCharacteristics()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getKeys =
      jniAccessors.getMethodIDOf(_classRef, "getKeys", "()Ljava/util/List;");

  /// from: public java.util.List<android.hardware.camera2.CameraCharacteristics.Key<?>> getKeys()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  ///@return This value will never be {@code null}.
  jni.JniObject getKeys() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getKeys, jni.JniType.objectType, []).object);

  static final _id_getAvailableSessionKeys = jniAccessors.getMethodIDOf(
      _classRef, "getAvailableSessionKeys", "()Ljava/util/List;");

  /// from: public java.util.List<android.hardware.camera2.CaptureRequest.Key<?>> getAvailableSessionKeys()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a subset of \#getAvailableCaptureRequestKeys keys that the
  /// camera device can pass as part of the capture session initialization.
  ///
  ///
  /// This list includes keys that are difficult to apply per-frame and
  /// can result in unexpected delays when modified during the capture session
  /// lifetime. Typical examples include parameters that require a
  /// time-consuming hardware re-configuration or internal camera pipeline
  /// change. For performance reasons we suggest clients to pass their initial
  /// values as part of SessionConfiguration\#setSessionParameters. Once
  /// the camera capture session is enabled it is also recommended to avoid
  /// changing them from their initial values set in
  /// SessionConfiguration\#setSessionParameters.
  /// Control over session parameters can still be exerted in capture requests
  /// but clients should be aware and expect delays during their application.
  /// An example usage scenario could look like this:
  ///
  /// <ul>
  /// <li>The camera client starts by quering the session parameter key list via
  ///   android.hardware.camera2.CameraCharacteristics\#getAvailableSessionKeys.</li>
  /// <li>Before triggering the capture session create sequence, a capture request
  ///   must be built via CameraDevice\#createCaptureRequest using an
  ///   appropriate template matching the particular use case.</li>
  /// <li>The client should go over the list of session parameters and check
  ///   whether some of the keys listed matches with the parameters that
  ///   they intend to modify as part of the first capture request.</li>
  /// <li>If there is no such match, the capture request can be  passed
  ///   unmodified to SessionConfiguration\#setSessionParameters.</li>
  /// <li>If matches do exist, the client should update the respective values
  ///   and pass the request to SessionConfiguration\#setSessionParameters.</li>
  /// <li>After the capture session initialization completes the session parameter
  ///   key list can continue to serve as reference when posting or updating
  ///   further requests. As mentioned above further changes to session
  ///   parameters should ideally be avoided, if updates are necessary
  ///   however clients could expect a delay/glitch during the
  ///   parameter switch.</li>
  /// </ul>
  ///
  /// The list returned is not modifiable, so any attempts to modify it will throw
  /// a {@code UnsupportedOperationException}.
  ///
  ///
  /// Each key is only listed once in the list. The order of the keys is undefined.
  ///
  ///@return List of keys that can be passed during capture session initialization. In case the
  /// camera device doesn't support such keys the list can be null.
  jni.JniObject getAvailableSessionKeys() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAvailableSessionKeys, jni.JniType.objectType, []).object);

  static final _id_getAvailablePhysicalCameraRequestKeys =
      jniAccessors.getMethodIDOf(_classRef,
          "getAvailablePhysicalCameraRequestKeys", "()Ljava/util/List;");

  /// from: public java.util.List<android.hardware.camera2.CaptureRequest.Key<?>> getAvailablePhysicalCameraRequestKeys()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a subset of \#getAvailableCaptureRequestKeys keys that can
  /// be overriden for physical devices backing a logical multi-camera.
  ///
  ///
  /// This is a subset of android.request.availableRequestKeys which contains a list
  /// of keys that can be overriden using CaptureRequest.Builder\#setPhysicalCameraKey.
  /// The respective value of such request key can be obtained by calling
  /// CaptureRequest.Builder\#getPhysicalCameraKey. Capture requests that contain
  /// individual physical device requests must be built via
  /// android.hardware.camera2.CameraDevice\#createCaptureRequest(int, Set).
  /// Such extended capture requests can be passed only to
  /// CameraCaptureSession\#capture or CameraCaptureSession\#captureBurst and
  /// not to CameraCaptureSession\#setRepeatingRequest or
  /// CameraCaptureSession\#setRepeatingBurst.
  ///
  ///
  /// The list returned is not modifiable, so any attempts to modify it will throw
  /// a {@code UnsupportedOperationException}.
  ///
  ///
  /// Each key is only listed once in the list. The order of the keys is undefined.
  ///
  ///@return List of keys that can be overriden in individual physical device requests.
  /// In case the camera device doesn't support such keys the list can be null.
  jni.JniObject getAvailablePhysicalCameraRequestKeys() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAvailablePhysicalCameraRequestKeys,
          jni.JniType.objectType, []).object);

  static final _id_getAvailableCaptureRequestKeys = jniAccessors.getMethodIDOf(
      _classRef, "getAvailableCaptureRequestKeys", "()Ljava/util/List;");

  /// from: public java.util.List<android.hardware.camera2.CaptureRequest.Key<?>> getAvailableCaptureRequestKeys()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of keys supported by this CameraDevice for querying
  /// with a CaptureRequest.
  ///
  /// The list returned is not modifiable, so any attempts to modify it will throw
  /// a {@code UnsupportedOperationException}.
  ///
  ///
  /// Each key is only listed once in the list. The order of the keys is undefined.
  ///
  ///
  /// Note that there is no {@code getAvailableCameraCharacteristicsKeys()} -- use
  /// \#getKeys() instead.
  ///
  ///@return List of keys supported by this CameraDevice for CaptureRequests.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getAvailableCaptureRequestKeys() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAvailableCaptureRequestKeys,
          jni.JniType.objectType, []).object);

  static final _id_getAvailableCaptureResultKeys = jniAccessors.getMethodIDOf(
      _classRef, "getAvailableCaptureResultKeys", "()Ljava/util/List;");

  /// from: public java.util.List<android.hardware.camera2.CaptureResult.Key<?>> getAvailableCaptureResultKeys()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of keys supported by this CameraDevice for querying
  /// with a CaptureResult.
  ///
  /// The list returned is not modifiable, so any attempts to modify it will throw
  /// a {@code UnsupportedOperationException}.
  ///
  ///
  /// Each key is only listed once in the list. The order of the keys is undefined.
  ///
  ///
  /// Note that there is no {@code getAvailableCameraCharacteristicsKeys()} -- use
  /// \#getKeys() instead.
  ///
  ///@return List of keys supported by this CameraDevice for CaptureResults.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getAvailableCaptureResultKeys() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getAvailableCaptureResultKeys,
          jni.JniType.objectType, []).object);

  static final _id_getPhysicalCameraIds = jniAccessors.getMethodIDOf(
      _classRef, "getPhysicalCameraIds", "()Ljava/util/Set;");

  /// from: public java.util.Set<java.lang.String> getPhysicalCameraIds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the set of physical camera ids that this logical CameraDevice is
  /// made up of.
  ///
  /// A camera device is a logical camera if it has
  /// REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA capability. If the camera device
  /// doesn't have the capability, the return value will be an empty set.
  ///
  ///
  /// The set returned is not modifiable, so any attempts to modify it will throw
  /// a {@code UnsupportedOperationException}.
  ///
  ///@return Set of physical camera ids for this logical camera device.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getPhysicalCameraIds() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getPhysicalCameraIds, jni.JniType.objectType, []).object);
}

/// from: android.hardware.camera2.CameraCharacteristics$Key
///
/// A {@code Key} is used to do camera characteristics field lookups with
/// CameraCharacteristics\#get.
///
/// For example, to get the stream configuration map:
/// <code><pre>
/// StreamConfigurationMap map = cameraCharacteristics.get(
///      CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
/// </pre></code>
///
///
///
/// To enumerate over all possible keys for CameraCharacteristics, see
/// CameraCharacteristics\#getKeys().
///
///@see CameraCharacteristics\#get
///@see CameraCharacteristics\#getKeys()
class CameraCharacteristics_Key extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/hardware/camera2/CameraCharacteristics\$Key");
  CameraCharacteristics_Key.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/lang/String;Ljava/lang/Class;)V");

  /// from: void <init>(java.lang.String name, java.lang.Class<T> type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Visible for testing and vendor extensions only.
  ///@hide
  CameraCharacteristics_Key(jni.JniString name, jni.JniObject type)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [name.reference, type.reference]).object);

  static final _id_getName =
      jniAccessors.getMethodIDOf(_classRef, "getName", "()Ljava/lang/String;");

  /// from: public java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a camelCase, period separated name formatted like:
  /// {@code "root.section[.subsections].name"}.
  ///
  /// Built-in keys exposed by the Android SDK are always prefixed with {@code "android."};
  /// keys that are device/platform-specific are prefixed with {@code "com."}.
  ///
  ///
  /// For example, {@code CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP} would
  /// have a name of {@code "android.scaler.streamConfigurationMap"}; whereas a device
  /// specific key might look like {@code "com.google.nexus.data.private"}.
  ///
  ///@return String representation of the key name
  ///
  /// This value will never be {@code null}.
  jni.JniString getName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);

  static final _id_hashCode1 =
      jniAccessors.getMethodIDOf(_classRef, "hashCode", "()I");

  /// from: public int hashCode()
  ///
  /// {@inheritDoc}
  int hashCode1() => jniAccessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniType.intType, []).integer;

  static final _id_equals1 =
      jniAccessors.getMethodIDOf(_classRef, "equals", "(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object o)
  ///
  /// {@inheritDoc}
  bool equals1(jni.JniObject o) => jniAccessors.callMethodWithArgs(
      reference, _id_equals1, jni.JniType.booleanType, [o.reference]).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return this Key as a string representation.
  ///
  /// {@code "CameraCharacteristics.Key(%s)"}, where {@code %s} represents
  /// the name of this key as returned by \#getName.
  ///
  ///@return string representation of Key
  ///
  /// This value will never be {@code null}.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}
