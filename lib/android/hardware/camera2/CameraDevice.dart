// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "CameraCaptureSession.dart" as cameracapturesession_;

import "../../os/Handler.dart" as handler_;

import "params/InputConfiguration.dart" as inputconfiguration_;

import "params/SessionConfiguration.dart" as sessionconfiguration_;

import "CaptureRequest.dart" as capturerequest_;

import "TotalCaptureResult.dart" as totalcaptureresult_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.camera2.CameraDevice
///
/// The CameraDevice class is a representation of a single camera connected to an
/// Android device, allowing for fine-grain control of image capture and
/// post-processing at high frame rates.
///
///
/// Your application must declare the
/// android.Manifest.permission\#CAMERA Camera permission in its manifest
/// in order to access camera devices.
///
///
/// A given camera device may provide support at one of several levels defined
/// in CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL.
/// If a device supports CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY LEGACY level,
/// the camera device is running in backward compatibility mode and has minimum camera2 API support.
/// If a device supports the CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED
/// level, then Camera2 exposes a feature set that is roughly equivalent to the older
/// android.hardware.Camera Camera API, although with a cleaner and more
/// efficient interface.
/// If a device supports the CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL EXTERNAL
/// level, then the device is a removable camera that provides similar but slightly less features
/// as the CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED level.
/// Devices that implement the CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL or
/// CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_3 LEVEL3 level of support
/// provide substantially improved capabilities over the older camera
/// API. If your application requires a full-level device for
/// proper operation, declare the "android.hardware.camera.level.full" feature in your
/// manifest.
///
///@see CameraManager\#openCamera
///@see android.Manifest.permission\#CAMERA
///@see CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
class CameraDevice extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/camera2/CameraDevice");
  CameraDevice.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int TEMPLATE_MANUAL
  ///
  /// A basic template for direct application control of capture
  /// parameters. All automatic control is disabled (auto-exposure, auto-white
  /// balance, auto-focus), and post-processing parameters are set to preview
  /// quality. The manual capture parameters (exposure, sensitivity, and so on)
  /// are set to reasonable defaults, but should be overriden by the
  /// application depending on the intended use case.
  /// This template is guaranteed to be supported on camera devices that support the
  /// CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR MANUAL_SENSOR
  /// capability.
  ///@see \#createCaptureRequest
  static const TEMPLATE_MANUAL = 6;

  /// from: static public final int TEMPLATE_PREVIEW
  ///
  /// Create a request suitable for a camera preview window. Specifically, this
  /// means that high frame rate is given priority over the highest-quality
  /// post-processing. These requests would normally be used with the
  /// CameraCaptureSession\#setRepeatingRequest method.
  /// This template is guaranteed to be supported on all camera devices.
  ///@see \#createCaptureRequest
  static const TEMPLATE_PREVIEW = 1;

  /// from: static public final int TEMPLATE_RECORD
  ///
  /// Create a request suitable for video recording. Specifically, this means
  /// that a stable frame rate is used, and post-processing is set for
  /// recording quality. These requests would commonly be used with the
  /// CameraCaptureSession\#setRepeatingRequest method.
  /// This template is guaranteed to be supported on all camera devices except
  /// CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT DEPTH_OUTPUT devices
  /// that are not CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE BACKWARD_COMPATIBLE.
  ///@see \#createCaptureRequest
  static const TEMPLATE_RECORD = 3;

  /// from: static public final int TEMPLATE_STILL_CAPTURE
  ///
  /// Create a request suitable for still image capture. Specifically, this
  /// means prioritizing image quality over frame rate. These requests would
  /// commonly be used with the CameraCaptureSession\#capture method.
  /// This template is guaranteed to be supported on all camera devices except
  /// CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT DEPTH_OUTPUT devices
  /// that are not CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE BACKWARD_COMPATIBLE.
  ///@see \#createCaptureRequest
  static const TEMPLATE_STILL_CAPTURE = 2;

  /// from: static public final int TEMPLATE_VIDEO_SNAPSHOT
  ///
  /// Create a request suitable for still image capture while recording
  /// video. Specifically, this means maximizing image quality without
  /// disrupting the ongoing recording. These requests would commonly be used
  /// with the CameraCaptureSession\#capture method while a request based on
  /// \#TEMPLATE_RECORD is is in use with CameraCaptureSession\#setRepeatingRequest.
  /// This template is guaranteed to be supported on all camera devices except
  /// legacy devices (CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  /// {@code == }CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY LEGACY) and
  /// CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT DEPTH_OUTPUT devices
  /// that are not CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE BACKWARD_COMPATIBLE.
  ///@see \#createCaptureRequest
  static const TEMPLATE_VIDEO_SNAPSHOT = 4;

  /// from: static public final int TEMPLATE_ZERO_SHUTTER_LAG
  ///
  /// Create a request suitable for zero shutter lag still capture. This means
  /// means maximizing image quality without compromising preview frame rate.
  /// AE/AWB/AF should be on auto mode. This is intended for application-operated ZSL. For
  /// device-operated ZSL, use CaptureRequest\#CONTROL_ENABLE_ZSL if available.
  /// This template is guaranteed to be supported on camera devices that support the
  /// CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING PRIVATE_REPROCESSING
  /// capability or the
  /// CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING YUV_REPROCESSING
  /// capability.
  ///@see \#createCaptureRequest
  ///@see CaptureRequest\#CONTROL_ENABLE_ZSL
  static const TEMPLATE_ZERO_SHUTTER_LAG = 5;

  static final _id_getId =
      jniAccessors.getMethodIDOf(_classRef, "getId", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the ID of this camera device.
  ///
  /// This matches the ID given to CameraManager\#openCamera to instantiate this
  /// this camera device.
  ///
  ///
  /// This ID can be used to query the camera device's CameraCharacteristics fixed properties with CameraManager\#getCameraCharacteristics.
  ///
  ///
  /// This method can be called even if the device has been closed or has encountered
  /// a serious error.
  ///
  ///@return the ID for this camera device
  ///
  /// This value will never be {@code null}.
  ///@see CameraManager\#getCameraCharacteristics
  ///@see CameraManager\#getCameraIdList
  jni.JniString getId() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getId, jni.JniType.objectType, []).object);

  static final _id_createCaptureSession = jniAccessors.getMethodIDOf(
      _classRef,
      "createCaptureSession",
      "(Ljava/util/List;Landroid/hardware/camera2/CameraCaptureSession\$StateCallback;Landroid/os/Handler;)V");

  /// from: public abstract void createCaptureSession(java.util.List<android.view.Surface> outputs, android.hardware.camera2.CameraCaptureSession.StateCallback callback, android.os.Handler handler)
  ///
  /// Create a new camera capture session by providing the target output set of Surfaces to the
  /// camera device.
  ///
  ///
  /// The active capture session determines the set of potential output Surfaces for
  /// the camera device for each capture request. A given request may use all
  /// or only some of the outputs. Once the CameraCaptureSession is created, requests can be
  /// submitted with CameraCaptureSession\#capture capture,
  /// CameraCaptureSession\#captureBurst captureBurst,
  /// CameraCaptureSession\#setRepeatingRequest setRepeatingRequest, or
  /// CameraCaptureSession\#setRepeatingBurst setRepeatingBurst.
  ///
  ///
  /// Surfaces suitable for inclusion as a camera output can be created for
  /// various use cases and targets:
  ///
  ///
  /// <ul>
  ///
  /// <li>For drawing to a android.view.SurfaceView SurfaceView: Once the SurfaceView's
  ///   Surface is android.view.SurfaceHolder.Callback\#surfaceCreated created, set the size
  ///   of the Surface with android.view.SurfaceHolder\#setFixedSize to be one of the sizes
  ///   returned by StreamConfigurationMap\#getOutputSizes(Class) getOutputSizes(SurfaceHolder.class) and then obtain the Surface by calling android.view.SurfaceHolder\#getSurface. If the size is not set by the application, it will
  ///   be rounded to the nearest supported size less than 1080p, by the camera device.</li>
  ///
  /// <li>For accessing through an OpenGL texture via a android.graphics.SurfaceTexture SurfaceTexture: Set the size of the SurfaceTexture with android.graphics.SurfaceTexture\#setDefaultBufferSize to be one of the sizes returned by
  ///   StreamConfigurationMap\#getOutputSizes(Class) getOutputSizes(SurfaceTexture.class)
  ///   before creating a Surface from the SurfaceTexture with Surface\#Surface. If the size
  ///   is not set by the application, it will be set to be the smallest supported size less than
  ///   1080p, by the camera device.</li>
  ///
  /// <li>For recording with android.media.MediaCodec: Call
  ///   android.media.MediaCodec\#createInputSurface after configuring
  ///   the media codec to use one of the sizes returned by
  ///   StreamConfigurationMap\#getOutputSizes(Class) getOutputSizes(MediaCodec.class)
  ///   </li>
  ///
  /// <li>For recording with android.media.MediaRecorder: Call
  ///   android.media.MediaRecorder\#getSurface after configuring the media recorder to use
  ///   one of the sizes returned by
  ///   StreamConfigurationMap\#getOutputSizes(Class) getOutputSizes(MediaRecorder.class),
  ///   or configuring it to use one of the supported
  ///   android.media.CamcorderProfile CamcorderProfiles.</li>
  ///
  /// <li>For efficient YUV processing with android.renderscript:
  ///   Create a RenderScript
  ///   android.renderscript.Allocation Allocation with a supported YUV
  ///   type, the IO_INPUT flag, and one of the sizes returned by
  ///   StreamConfigurationMap\#getOutputSizes(Class) getOutputSizes(Allocation.class),
  ///   Then obtain the Surface with
  ///   android.renderscript.Allocation\#getSurface.</li>
  ///
  /// <li>For access to RAW, uncompressed YUV, or compressed JPEG data in the application: Create an
  ///   android.media.ImageReader object with one of the supported output formats given by
  ///   StreamConfigurationMap\#getOutputFormats(), setting its size to one of the
  ///   corresponding supported sizes by passing the chosen output format into
  ///   StreamConfigurationMap\#getOutputSizes(int). Then obtain a
  ///   android.view.Surface from it with android.media.ImageReader\#getSurface().
  ///   If the ImageReader size is not set to a supported size, it will be rounded to a supported
  ///   size less than 1080p by the camera device.
  ///   </li>
  ///
  /// </ul>
  ///
  /// The camera device will query each Surface's size and formats upon this
  /// call, so they must be set to a valid setting at this time.
  ///
  ///
  /// It can take several hundred milliseconds for the session's configuration to complete,
  /// since camera hardware may need to be powered on or reconfigured. Once the configuration is
  /// complete and the session is ready to actually capture data, the provided
  /// CameraCaptureSession.StateCallback's
  /// CameraCaptureSession.StateCallback\#onConfigured callback will be called.
  ///
  ///
  /// If a prior CameraCaptureSession already exists when this method is called, the previous
  /// session will no longer be able to accept new capture requests and will be closed. Any
  /// in-progress capture requests made on the prior session will be completed before it's closed.
  /// CameraCaptureSession.StateCallback\#onConfigured for the new session may be invoked
  /// before CameraCaptureSession.StateCallback\#onClosed is invoked for the prior
  /// session. Once the new session is CameraCaptureSession.StateCallback\#onConfigured configured, it is able to start capturing its own requests. To minimize the transition time,
  /// the CameraCaptureSession\#abortCaptures call can be used to discard the remaining
  /// requests for the prior capture session before a new one is created. Note that once the new
  /// session is created, the old one can no longer have its captures aborted.
  ///
  ///
  /// Using larger resolution outputs, or more outputs, can result in slower
  /// output rate from the device.
  ///
  ///
  /// Configuring a session with an empty or null list will close the current session, if
  /// any. This can be used to release the current session's target surfaces for another use.
  ///
  ///
  /// While any of the sizes from StreamConfigurationMap\#getOutputSizes can be used when
  /// a single output stream is configured, a given camera device may not be able to support all
  /// combination of sizes, formats, and targets when multiple outputs are configured at once.  The
  /// tables below list the maximum guaranteed resolutions for combinations of streams and targets,
  /// given the capabilities of the camera device.
  ///
  ///
  /// If an application tries to create a session using a set of targets that exceed the limits
  /// described in the below tables, one of three possibilities may occur. First, the session may
  /// be successfully created and work normally. Second, the session may be successfully created,
  /// but the camera device won't meet the frame rate guarantees as described in
  /// StreamConfigurationMap\#getOutputMinFrameDuration. Or third, if the output set
  /// cannot be used at all, session creation will fail entirely, with
  /// CameraCaptureSession.StateCallback\#onConfigureFailed being invoked.
  ///
  ///
  /// For the type column, {@code PRIV} refers to any target whose available sizes are found
  /// using StreamConfigurationMap\#getOutputSizes(Class) with no direct application-visible
  /// format, {@code YUV} refers to a target Surface using the
  /// android.graphics.ImageFormat\#YUV_420_888 format, {@code JPEG} refers to the
  /// android.graphics.ImageFormat\#JPEG format, and {@code RAW} refers to the
  /// android.graphics.ImageFormat\#RAW_SENSOR format.
  ///
  ///
  /// For the maximum size column, {@code PREVIEW} refers to the best size match to the
  /// device's screen resolution, or to 1080p ({@code 1920x1080}), whichever is
  /// smaller. {@code RECORD} refers to the camera device's maximum supported recording resolution,
  /// as determined by android.media.CamcorderProfile. And {@code MAXIMUM} refers to the
  /// camera device's maximum output resolution for that format or target from
  /// StreamConfigurationMap\#getOutputSizes.
  ///
  ///
  /// To use these tables, determine the number and the formats/targets of outputs needed, and
  /// find the row(s) of the table with those targets. The sizes indicate the maximum set of sizes
  /// that can be used; it is guaranteed that for those targets, the listed sizes and anything
  /// smaller from the list given by StreamConfigurationMap\#getOutputSizes can be
  /// successfully used to create a session.  For example, if a row indicates that a 8 megapixel
  /// (MP) YUV_420_888 output can be used together with a 2 MP {@code PRIV} output, then a session
  /// can be created with targets {@code [8 MP YUV, 2 MP PRIV]} or targets {@code [2 MP YUV, 2 MP
  /// PRIV]}; but a session with targets {@code [8 MP YUV, 4 MP PRIV]}, targets {@code [4 MP YUV, 4
  /// MP PRIV]}, or targets {@code [8 MP PRIV, 2 MP YUV]} would not be guaranteed to work, unless
  /// some other row of the table lists such a combination.
  ///
  ///
  /// <style scoped>
  ///  \#rb { border-right-width: thick; }
  /// </style>
  /// Legacy devices (CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  /// {@code == }CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY LEGACY) support at
  /// least the following stream combinations:
  ///
  /// <table>
  /// <tr><th colspan="7">LEGACY-level guaranteed configurations</th></tr>
  /// <tr> <th colspan="2"id="rb">Target 1</th> <th colspan="2"id="rb">Target 2</th>  <th colspan="2"id="rb">Target 3</th> <th rowspan="2">Sample use case(s)</th> </tr>
  /// <tr> <th>Type</th><th id="rb">Max size</th> <th>Type</th><th id="rb">Max size</th> <th>Type</th><th id="rb">Max size</th></tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code MAXIMUM}</td> <td colspan="2"id="rb"></td> <td colspan="2"id="rb"></td> <td>Simple preview, GPU video processing, or no-preview video recording.</td> </tr>
  /// <tr> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td> <td colspan="2"id="rb"></td> <td colspan="2"id="rb"></td> <td>No-viewfinder still image capture.</td> </tr>
  /// <tr> <td>{@code YUV }</td><td id="rb">{@code MAXIMUM}</td> <td colspan="2"id="rb"></td> <td colspan="2"id="rb"></td> <td>In-application video/image processing.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td> <td colspan="2"id="rb"></td> <td>Standard still imaging.</td> </tr>
  /// <tr> <td>{@code YUV }</td><td id="rb">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td> <td colspan="2"id="rb"></td> <td>In-app processing plus still capture.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td colspan="2"id="rb"></td> <td>Standard recording.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV }</td><td id="rb">{@code PREVIEW}</td> <td colspan="2"id="rb"></td> <td>Preview plus in-app processing.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV }</td><td id="rb">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td> <td>Still capture plus in-app processing.</td> </tr>
  /// </table><br>
  ///
  ///
  ///
  /// Limited-level (CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  /// {@code == }CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED) devices
  /// support at least the following stream combinations in addition to those for
  /// CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY LEGACY devices:
  ///
  /// <table>
  /// <tr><th colspan="7">LIMITED-level additional guaranteed configurations</th></tr>
  /// <tr><th colspan="2"id="rb">Target 1</th><th colspan="2"id="rb">Target 2</th><th colspan="2"id="rb">Target 3</th> <th rowspan="2">Sample use case(s)</th> </tr>
  /// <tr><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th></tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id="rb">{@code RECORD }</td> <td colspan="2"id="rb"></td> <td>High-resolution video recording with preview.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV }</td><td id="rb">{@code RECORD }</td> <td colspan="2"id="rb"></td> <td>High-resolution in-app video processing with preview.</td> </tr>
  /// <tr> <td>{@code YUV }</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV }</td><td id="rb">{@code RECORD }</td> <td colspan="2"id="rb"></td> <td>Two-input in-app video processing.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id="rb">{@code RECORD }</td> <td>{@code JPEG}</td><td id="rb">{@code RECORD }</td> <td>High-resolution recording with video snapshot.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV }</td><td id="rb">{@code RECORD }</td> <td>{@code JPEG}</td><td id="rb">{@code RECORD }</td> <td>High-resolution in-app processing with video snapshot.</td> </tr>
  /// <tr> <td>{@code YUV }</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV }</td><td id="rb">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td> <td>Two-input in-app processing with still capture.</td> </tr>
  /// </table><br>
  ///
  ///
  ///
  /// FULL-level (CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  /// {@code == }CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL) devices
  /// support at least the following stream combinations in addition to those for
  /// CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED devices:
  ///
  /// <table>
  /// <tr><th colspan="7">FULL-level additional guaranteed configurations</th></tr>
  /// <tr><th colspan="2"id="rb">Target 1</th><th colspan="2"id="rb">Target 2</th><th colspan="2"id="rb">Target 3</th> <th rowspan="2">Sample use case(s)</th> </tr>
  /// <tr><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id="rb">{@code MAXIMUM}</td> <td colspan="2"id="rb"></td> <td>Maximum-resolution GPU processing with preview.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV }</td><td id="rb">{@code MAXIMUM}</td> <td colspan="2"id="rb"></td> <td>Maximum-resolution in-app processing with preview.</td> </tr>
  /// <tr> <td>{@code YUV }</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV }</td><td id="rb">{@code MAXIMUM}</td> <td colspan="2"id="rb"></td> <td>Maximum-resolution two-input in-app processsing.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td> <td>Video recording with maximum-size video snapshot</td> </tr>
  /// <tr> <td>{@code YUV }</td><td id="rb">{@code 640x480}</td> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV }</td><td id="rb">{@code MAXIMUM}</td> <td>Standard video recording plus maximum-resolution in-app processing.</td> </tr>
  /// <tr> <td>{@code YUV }</td><td id="rb">{@code 640x480}</td> <td>{@code YUV }</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV }</td><td id="rb">{@code MAXIMUM}</td> <td>Preview plus two-input maximum-resolution in-app processing.</td> </tr>
  /// </table><br>
  ///
  ///
  ///
  /// RAW-capability (CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES includes
  /// CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_RAW RAW) devices additionally support
  /// at least the following stream combinations on both
  /// CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL and
  /// CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED devices:
  ///
  /// <table>
  /// <tr><th colspan="7">RAW-capability additional guaranteed configurations</th></tr>
  /// <tr><th colspan="2"id="rb">Target 1</th><th colspan="2"id="rb">Target 2</th><th colspan="2"id="rb">Target 3</th> <th rowspan="2">Sample use case(s)</th> </tr>
  /// <tr><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th> </tr>
  /// <tr> <td>{@code RAW }</td><td id="rb">{@code MAXIMUM}</td> <td colspan="2"id="rb"></td> <td colspan="2"id="rb"></td> <td>No-preview DNG capture.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code RAW }</td><td id="rb">{@code MAXIMUM}</td> <td colspan="2"id="rb"></td> <td>Standard DNG capture.</td> </tr>
  /// <tr> <td>{@code YUV }</td><td id="rb">{@code PREVIEW}</td> <td>{@code RAW }</td><td id="rb">{@code MAXIMUM}</td> <td colspan="2"id="rb"></td> <td>In-app processing plus DNG capture.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code RAW }</td><td id="rb">{@code MAXIMUM}</td> <td>Video recording with DNG capture.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV }</td><td id="rb">{@code PREVIEW}</td> <td>{@code RAW }</td><td id="rb">{@code MAXIMUM}</td> <td>Preview with in-app processing and DNG capture.</td> </tr>
  /// <tr> <td>{@code YUV }</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV }</td><td id="rb">{@code PREVIEW}</td> <td>{@code RAW }</td><td id="rb">{@code MAXIMUM}</td> <td>Two-input in-app processing plus DNG capture.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code RAW }</td><td id="rb">{@code MAXIMUM}</td> <td>Still capture with simultaneous JPEG and DNG.</td> </tr>
  /// <tr> <td>{@code YUV }</td><td id="rb">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code RAW }</td><td id="rb">{@code MAXIMUM}</td> <td>In-app processing with simultaneous JPEG and DNG.</td> </tr>
  /// </table><br>
  ///
  ///
  ///
  /// BURST-capability (CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES includes
  /// CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE BURST_CAPTURE) devices
  /// support at least the below stream combinations in addition to those for
  /// CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED devices. Note that all
  /// FULL-level devices support the BURST capability, and the below list is a strict subset of the
  /// list for FULL-level devices, so this table is only relevant for LIMITED-level devices that
  /// support the BURST_CAPTURE capability.
  ///
  /// <table>
  /// <tr><th colspan="5">BURST-capability additional guaranteed configurations</th></tr>
  /// <tr><th colspan="2"id="rb">Target 1</th><th colspan="2"id="rb">Target 2</th><th rowspan="2">Sample use case(s)</th> </tr>
  /// <tr><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id="rb">{@code MAXIMUM}</td> <td>Maximum-resolution GPU processing with preview.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV }</td><td id="rb">{@code MAXIMUM}</td> <td>Maximum-resolution in-app processing with preview.</td> </tr>
  /// <tr> <td>{@code YUV }</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV }</td><td id="rb">{@code MAXIMUM}</td> <td>Maximum-resolution two-input in-app processsing.</td> </tr>
  /// </table><br>
  ///
  ///
  ///
  /// LEVEL-3 (CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  /// {@code == }CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_3 LEVEL_3)
  /// support at least the following stream combinations in addition to the combinations for
  /// CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL and for
  /// RAW capability (CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES includes
  /// CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_RAW RAW):
  ///
  /// <table>
  /// <tr><th colspan="11">LEVEL-3 additional guaranteed configurations</th></tr>
  /// <tr><th colspan="2"id="rb">Target 1</th><th colspan="2"id="rb">Target 2</th><th colspan="2"id="rb">Target 3</th><th colspan="2"id="rb">Target 4</th><th rowspan="2">Sample use case(s)</th> </tr>
  /// <tr><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id="rb">{@code 640x480}</td> <td>{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code RAW}</td><td id="rb">{@code MAXIMUM}</td> <td>In-app viewfinder analysis with dynamic selection of output format.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id="rb">{@code 640x480}</td> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code RAW}</td><td id="rb">{@code MAXIMUM}</td> <td>In-app viewfinder analysis with dynamic selection of output format.</td> </tr>
  /// </table><br>
  ///
  ///
  ///
  /// Since the capabilities of camera devices vary greatly, a given camera device may support
  /// target combinations with sizes outside of these guarantees, but this can only be tested for
  /// by attempting to create a session with such targets.
  ///
  ///@param outputs The new set of Surfaces that should be made available as
  ///                targets for captured image data.
  /// This value must never be {@code null}.
  ///@param callback The callback to notify about the status of the new capture session.
  /// This value must never be {@code null}.
  ///@param handler The handler on which the callback should be invoked, or {@code null} to use
  ///                the current thread's android.os.Looper looper.
  ///
  /// This value may be {@code null}.
  ///@throws IllegalArgumentException if the set of output Surfaces do not meet the requirements,
  ///                                  the callback is null, or the handler is null but the current
  ///                                  thread has no looper.
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if the camera device has been closed
  ///@see CameraCaptureSession
  ///@see StreamConfigurationMap\#getOutputFormats()
  ///@see StreamConfigurationMap\#getOutputSizes(int)
  ///@see StreamConfigurationMap\#getOutputSizes(Class)
  void createCaptureSession(
          jni.JniObject outputs,
          cameracapturesession_.CameraCaptureSession_StateCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_createCaptureSession,
          jni.JniType.voidType,
          [outputs.reference, callback.reference, handler.reference]).check();

  static final _id_createCaptureSessionByOutputConfigurations =
      jniAccessors.getMethodIDOf(
          _classRef,
          "createCaptureSessionByOutputConfigurations",
          "(Ljava/util/List;Landroid/hardware/camera2/CameraCaptureSession\$StateCallback;Landroid/os/Handler;)V");

  /// from: public abstract void createCaptureSessionByOutputConfigurations(java.util.List<android.hardware.camera2.params.OutputConfiguration> outputConfigurations, android.hardware.camera2.CameraCaptureSession.StateCallback callback, android.os.Handler handler)
  ///
  /// Create a new camera capture session by providing the target output set of Surfaces and
  /// its corresponding surface configuration to the camera device.
  ///
  ///@see \#createCaptureSession
  ///@see OutputConfiguration
  ///@param handler This value may be {@code null}.
  void createCaptureSessionByOutputConfigurations(
          jni.JniObject outputConfigurations,
          cameracapturesession_.CameraCaptureSession_StateCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_createCaptureSessionByOutputConfigurations,
          jni.JniType.voidType, [
        outputConfigurations.reference,
        callback.reference,
        handler.reference
      ]).check();

  static final _id_createReprocessableCaptureSession = jniAccessors.getMethodIDOf(
      _classRef,
      "createReprocessableCaptureSession",
      "(Landroid/hardware/camera2/params/InputConfiguration;Ljava/util/List;Landroid/hardware/camera2/CameraCaptureSession\$StateCallback;Landroid/os/Handler;)V");

  /// from: public abstract void createReprocessableCaptureSession(android.hardware.camera2.params.InputConfiguration inputConfig, java.util.List<android.view.Surface> outputs, android.hardware.camera2.CameraCaptureSession.StateCallback callback, android.os.Handler handler)
  ///
  /// Create a new reprocessable camera capture session by providing the desired reprocessing
  /// input Surface configuration and the target output set of Surfaces to the camera device.
  ///
  /// If a camera device supports YUV reprocessing
  /// (CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING) or PRIVATE
  /// reprocessing
  /// (CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING), besides
  /// the capture session created via \#createCaptureSession createCaptureSession, the
  /// application can also create a reprocessable capture session to submit reprocess capture
  /// requests in addition to regular capture requests. A reprocess capture request takes the next
  /// available buffer from the session's input Surface, and sends it through the camera device's
  /// processing pipeline again, to produce buffers for the request's target output Surfaces. No
  /// new image data is captured for a reprocess request. However the input buffer provided by
  /// the application must be captured previously by the same camera device in the same session
  /// directly (e.g. for Zero-Shutter-Lag use case) or indirectly (e.g. combining multiple output
  /// images).
  ///
  ///
  /// The active reprocessable capture session determines an input Surface and the set
  /// of potential output Surfaces for the camera devices for each capture request. The application
  /// can use \#createCaptureRequest createCaptureRequest to create regular capture requests
  /// to capture new images from the camera device, and use \#createReprocessCaptureRequest createReprocessCaptureRequest to create reprocess capture requests to process buffers from
  /// the input Surface. Some combinations of output Surfaces in a session may not be used
  /// in a request simultaneously. The guaranteed combinations of output Surfaces that can be used
  /// in a request simultaneously are listed in the tables under \#createCaptureSession createCaptureSession. All the output Surfaces in one capture request will come from the
  /// same source, either from a new capture by the camera device, or from the input Surface
  /// depending on if the request is a reprocess capture request.
  ///
  ///
  /// Input formats and sizes supported by the camera device can be queried via
  /// StreamConfigurationMap\#getInputFormats and
  /// StreamConfigurationMap\#getInputSizes. For each supported input format, the camera
  /// device supports a set of output formats and sizes for reprocessing that can be queried via
  /// StreamConfigurationMap\#getValidOutputFormatsForInput and
  /// StreamConfigurationMap\#getOutputSizes. While output Surfaces with formats that
  /// aren't valid reprocess output targets for the input configuration can be part of a session,
  /// they cannot be used as targets for a reprocessing request.
  ///
  ///
  /// Since the application cannot access android.graphics.ImageFormat\#PRIVATE images
  /// directly, an output Surface created by android.media.ImageReader\#newInstance with
  /// android.graphics.ImageFormat\#PRIVATE as the format will be considered as intended to
  /// be used for reprocessing input and thus the android.media.ImageReader size must
  /// match one of the supported input sizes for android.graphics.ImageFormat\#PRIVATE
  /// format. Otherwise, creating a reprocessable capture session will fail.
  ///
  ///
  /// The guaranteed stream configurations listed in
  /// \#createCaptureSession createCaptureSession are also guaranteed to work for
  /// \#createReprocessableCaptureSession createReprocessableCaptureSession. In addition,
  /// the configurations in the tables below are also guaranteed for creating a reprocessable
  /// capture session if the camera device supports YUV reprocessing or PRIVATE reprocessing.
  /// However, not all output targets used to create a reprocessable session may be used in a
  /// CaptureRequest simultaneously. For devices that support only 1 output target in a
  /// reprocess CaptureRequest, submitting a reprocess CaptureRequest with multiple
  /// output targets will result in a CaptureFailure. For devices that support multiple
  /// output targets in a reprocess CaptureRequest, the guaranteed output targets that can
  /// be included in a CaptureRequest simultaneously are listed in the tables under
  /// \#createCaptureSession createCaptureSession. For example, with a FULL-capability
  /// (CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL {@code == }
  /// CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL) device that supports PRIVATE
  /// reprocessing, an application can create a reprocessable capture session with 1 input,
  /// ({@code PRIV}, {@code MAXIMUM}), and 3 outputs, ({@code PRIV}, {@code MAXIMUM}),
  /// ({@code PRIV}, {@code PREVIEW}), and ({@code YUV}, {@code MAXIMUM}). However, it's not
  /// guaranteed that an application can submit a regular or reprocess capture with ({@code PRIV},
  /// {@code MAXIMUM}) and ({@code YUV}, {@code MAXIMUM}) outputs based on the table listed under
  /// \#createCaptureSession createCaptureSession. In other words, use the tables below to
  /// determine the guaranteed stream configurations for creating a reprocessable capture session,
  /// and use the tables under \#createCaptureSession createCaptureSession to determine the
  /// guaranteed output targets that can be submitted in a regular or reprocess
  /// CaptureRequest simultaneously.
  ///
  ///
  /// <style scoped>
  ///  \#rb { border-right-width: thick; }
  /// </style>
  ///
  /// LIMITED-level (CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  /// {@code == }CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED) devices
  /// support at least the following stream combinations for creating a reprocessable capture
  /// session in addition to those listed in \#createCaptureSession createCaptureSession for
  /// CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED devices:
  ///
  /// <table>
  /// <tr><th colspan="11">LIMITED-level additional guaranteed configurations for creating a reprocessable capture session<br>({@code PRIV} input is guaranteed only if PRIVATE reprocessing is supported. {@code YUV} input is guaranteed only if YUV reprocessing is supported)</th></tr>
  /// <tr><th colspan="2"id="rb">Input</th><th colspan="2"id="rb">Target 1</th><th colspan="2"id="rb">Target 2</th><th colspan="2"id="rb">Target 3</th><th colspan="2"id="rb">Target 4</th><th rowspan="2">Sample use case(s)</th> </tr>
  /// <tr><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th></tr>
  /// <tr> <td>{@code PRIV}/{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>Same as input</td><td id="rb">{@code MAXIMUM}</td> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td> <td></td><td id="rb"></td> <td></td><td id="rb"></td> <td>No-viewfinder still image reprocessing.</td> </tr>
  /// <tr> <td>{@code PRIV}/{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>Same as input</td><td id="rb">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td> <td></td><td id="rb"></td> <td>ZSL(Zero-Shutter-Lag) still imaging.</td> </tr>
  /// <tr> <td>{@code PRIV}/{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>Same as input</td><td id="rb">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td> <td></td><td id="rb"></td> <td>ZSL still and in-app processing imaging.</td> </tr>
  /// <tr> <td>{@code PRIV}/{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>Same as input</td><td id="rb">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td> <td>ZSL in-app processing with still capture.</td> </tr>
  /// </table><br>
  ///
  ///
  ///
  /// FULL-level (CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  /// {@code == }CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL) devices
  /// support at least the following stream combinations for creating a reprocessable capture
  /// session in addition to those for
  /// CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED devices:
  ///
  /// <table>
  /// <tr><th colspan="11">FULL-level additional guaranteed configurations for creating a reprocessable capture session<br>({@code PRIV} input is guaranteed only if PRIVATE reprocessing is supported. {@code YUV} input is guaranteed only if YUV reprocessing is supported)</th></tr>
  /// <tr><th colspan="2"id="rb">Input</th><th colspan="2"id="rb">Target 1</th><th colspan="2"id="rb">Target 2</th><th colspan="2"id="rb">Target 3</th><th colspan="2"id="rb">Target 4</th><th rowspan="2">Sample use case(s)</th> </tr>
  /// <tr><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th></tr>
  /// <tr> <td>{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td></td><td id="rb"></td> <td></td><td id="rb"></td> <td>Maximum-resolution multi-frame image fusion in-app processing with regular preview.</td> </tr>
  /// <tr> <td>{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id="rb">{@code PREVIEW}</td> <td></td><td id="rb"></td> <td></td><td id="rb"></td> <td>Maximum-resolution multi-frame image fusion two-input in-app processing.</td> </tr>
  /// <tr> <td>{@code PRIV}/{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>Same as input</td><td id="rb">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV}</td><td id="rb">{@code RECORD}</td> <td></td><td id="rb"></td> <td>High-resolution ZSL in-app video processing with regular preview.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td></td><td id="rb"></td> <td>Maximum-resolution ZSL in-app processing with regular preview.</td> </tr>
  /// <tr> <td>{@code PRIV}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td></td><td id="rb"></td> <td>Maximum-resolution two-input ZSL in-app processing.</td> </tr>
  /// <tr> <td>{@code PRIV}/{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>Same as input</td><td id="rb">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td> <td>ZSL still capture and in-app processing.</td> </tr>
  /// </table><br>
  ///
  ///
  ///
  /// RAW-capability (CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES includes
  /// CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_RAW RAW) devices additionally support
  /// at least the following stream combinations for creating a reprocessable capture session
  /// on both CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL and
  /// CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED devices
  ///
  /// <table>
  /// <tr><th colspan="11">RAW-capability additional guaranteed configurations for creating a reprocessable capture session<br>({@code PRIV} input is guaranteed only if PRIVATE reprocessing is supported. {@code YUV} input is guaranteed only if YUV reprocessing is supported)</th></tr>
  /// <tr><th colspan="2"id="rb">Input</th><th colspan="2"id="rb">Target 1</th><th colspan="2"id="rb">Target 2</th><th colspan="2"id="rb">Target 3</th><th colspan="2"id="rb">Target 4</th><th rowspan="2">Sample use case(s)</th> </tr>
  /// <tr><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th></tr>
  /// <tr> <td>{@code PRIV}/{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>Same as input</td><td id="rb">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code RAW}</td><td id="rb">{@code MAXIMUM}</td> <td></td><td id="rb"></td> <td>Mutually exclusive ZSL in-app processing and DNG capture.</td> </tr>
  /// <tr> <td>{@code PRIV}/{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>Same as input</td><td id="rb">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code RAW}</td><td id="rb">{@code MAXIMUM}</td> <td>Mutually exclusive ZSL in-app processing and preview with DNG capture.</td> </tr>
  /// <tr> <td>{@code PRIV}/{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>Same as input</td><td id="rb">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code YUV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code RAW}</td><td id="rb">{@code MAXIMUM}</td> <td>Mutually exclusive ZSL two-input in-app processing and DNG capture.</td> </tr>
  /// <tr> <td>{@code PRIV}/{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>Same as input</td><td id="rb">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code RAW}</td><td id="rb">{@code MAXIMUM}</td> <td>Mutually exclusive ZSL still capture and preview with DNG capture.</td> </tr>
  /// <tr> <td>{@code PRIV}/{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>Same as input</td><td id="rb">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code RAW}</td><td id="rb">{@code MAXIMUM}</td> <td>Mutually exclusive ZSL in-app processing with still capture and DNG capture.</td> </tr>
  /// </table><br>
  ///
  ///
  ///
  /// LEVEL-3 (CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL
  /// {@code == }CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_3 LEVEL_3) devices
  /// support at least the following stream combinations for creating a reprocessable capture
  /// session in addition to those for
  /// CameraMetadata\#INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL devices. Note that while
  /// the second configuration allows for configuring {@code MAXIMUM} {@code YUV} and {@code JPEG}
  /// outputs at the same time, that configuration is not listed for regular capture sessions, and
  /// therefore simultaneous output to both targets is not allowed.
  ///
  /// <table>
  /// <tr><th colspan="13">LEVEL-3 additional guaranteed configurations for creating a reprocessable capture session<br>({@code PRIV} input is guaranteed only if PRIVATE reprocessing is supported. {@code YUV} input is always guaranteed.</th></tr>
  /// <tr><th colspan="2"id="rb">Input</th><th colspan="2"id="rb">Target 1</th><th colspan="2"id="rb">Target 2</th><th colspan="2"id="rb">Target 3</th><th colspan="2"id="rb">Target 4</th><th colspan="2"id="rb">Target 5</th><th rowspan="2">Sample use case(s)</th> </tr>
  /// <tr><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th><th>Type</th><th id="rb">Max size</th></tr>
  /// <tr> <td>{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id="rb">{@code 640x480}</td> <td>{@code RAW}</td><td id="rb">{@code MAXIMUM}</td> <td></td><td id="rb"></td> <td>In-app viewfinder analysis with ZSL and RAW.</td> </tr>
  /// <tr> <td>{@code PRIV}/{@code YUV}</td><td id="rb">{@code MAXIMUM}</td> <td>Same as input</td><td id="rb">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id="rb">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id="rb">{@code 640x480}</td> <td>{@code RAW}</td><td id="rb">{@code MAXIMUM}</td> <td>{@code JPEG}</td><td id="rb">{@code MAXIMUM}</td><td>In-app viewfinder analysis with ZSL, RAW, and JPEG reprocessing output.</td> </tr>
  /// </table><br>
  ///
  ///
  ///@param inputConfig The configuration for the input Surface
  /// This value must never be {@code null}.
  ///@param outputs The new set of Surfaces that should be made available as
  ///                targets for captured image data.
  /// This value must never be {@code null}.
  ///@param callback The callback to notify about the status of the new capture session.
  /// This value must never be {@code null}.
  ///@param handler The handler on which the callback should be invoked, or {@code null} to use
  ///                the current thread's android.os.Looper looper.
  ///
  /// This value may be {@code null}.
  ///@throws IllegalArgumentException if the input configuration is null or not supported, the set
  ///                                  of output Surfaces do not meet the requirements, the
  ///                                  callback is null, or the handler is null but the current
  ///                                  thread has no looper.
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if the camera device has been closed
  ///@see \#createCaptureSession
  ///@see CameraCaptureSession
  ///@see StreamConfigurationMap\#getInputFormats
  ///@see StreamConfigurationMap\#getInputSizes
  ///@see StreamConfigurationMap\#getValidOutputFormatsForInput
  ///@see StreamConfigurationMap\#getOutputSizes
  ///@see android.media.ImageWriter
  ///@see android.media.ImageReader
  void createReprocessableCaptureSession(
          inputconfiguration_.InputConfiguration inputConfig,
          jni.JniObject outputs,
          cameracapturesession_.CameraCaptureSession_StateCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(reference,
          _id_createReprocessableCaptureSession, jni.JniType.voidType, [
        inputConfig.reference,
        outputs.reference,
        callback.reference,
        handler.reference
      ]).check();

  static final _id_createReprocessableCaptureSessionByConfigurations =
      jniAccessors.getMethodIDOf(
          _classRef,
          "createReprocessableCaptureSessionByConfigurations",
          "(Landroid/hardware/camera2/params/InputConfiguration;Ljava/util/List;Landroid/hardware/camera2/CameraCaptureSession\$StateCallback;Landroid/os/Handler;)V");

  /// from: public abstract void createReprocessableCaptureSessionByConfigurations(android.hardware.camera2.params.InputConfiguration inputConfig, java.util.List<android.hardware.camera2.params.OutputConfiguration> outputs, android.hardware.camera2.CameraCaptureSession.StateCallback callback, android.os.Handler handler)
  ///
  /// Create a new reprocessable camera capture session by providing the desired reprocessing
  /// input configuration and output OutputConfiguration
  /// to the camera device.
  ///@see \#createReprocessableCaptureSession
  ///@see OutputConfiguration
  ///@param inputConfig This value must never be {@code null}.
  ///@param outputs This value must never be {@code null}.
  ///@param callback This value must never be {@code null}.
  ///@param handler This value may be {@code null}.
  void createReprocessableCaptureSessionByConfigurations(
          inputconfiguration_.InputConfiguration inputConfig,
          jni.JniObject outputs,
          cameracapturesession_.CameraCaptureSession_StateCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_createReprocessableCaptureSessionByConfigurations,
          jni.JniType.voidType, [
        inputConfig.reference,
        outputs.reference,
        callback.reference,
        handler.reference
      ]).check();

  static final _id_createConstrainedHighSpeedCaptureSession =
      jniAccessors.getMethodIDOf(
          _classRef,
          "createConstrainedHighSpeedCaptureSession",
          "(Ljava/util/List;Landroid/hardware/camera2/CameraCaptureSession\$StateCallback;Landroid/os/Handler;)V");

  /// from: public abstract void createConstrainedHighSpeedCaptureSession(java.util.List<android.view.Surface> outputs, android.hardware.camera2.CameraCaptureSession.StateCallback callback, android.os.Handler handler)
  ///
  /// Create a new constrained high speed capture session.
  ///
  ///
  /// The application can use normal capture session (created via \#createCaptureSession)
  /// for high speed capture if the desired high speed FPS ranges are advertised by
  /// CameraCharacteristics\#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES, in which case all API
  /// semantics associated with normal capture sessions applies.
  ///
  ///
  /// The method creates a specialized capture session that is only targeted at high speed
  /// video recording (>=120fps) use case if the camera device supports high speed video
  /// capability (i.e., CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES contains
  /// CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO).
  /// Therefore, it has special characteristics compared with a normal capture session:
  ///
  ///
  /// <ul>
  ///
  /// <li>In addition to the output target Surface requirements specified by the
  ///   \#createCaptureSession method, an active high speed capture session will support up
  ///   to 2 output Surfaces, though the application might choose to configure just one Surface
  ///   (e.g., preview only). All Surfaces must be either video encoder surfaces (acquired by
  ///   android.media.MediaRecorder\#getSurface or
  ///   android.media.MediaCodec\#createInputSurface) or preview surfaces (obtained from
  ///   android.view.SurfaceView, android.graphics.SurfaceTexture via
  ///   android.view.Surface\#Surface(android.graphics.SurfaceTexture)). The Surface sizes
  ///   must be one of the sizes reported by StreamConfigurationMap\#getHighSpeedVideoSizes.
  ///   When multiple Surfaces are configured, their size must be same.</li>
  ///
  /// <li>An active high speed capture session only accepts request lists created via
  ///   CameraConstrainedHighSpeedCaptureSession\#createHighSpeedRequestList, and the
  ///   request list can only be submitted to this session via
  ///   CameraCaptureSession\#captureBurst captureBurst, or
  ///   CameraCaptureSession\#setRepeatingBurst setRepeatingBurst.</li>
  ///
  /// <li>The FPS ranges being requested to this session must be selected from
  ///   StreamConfigurationMap\#getHighSpeedVideoFpsRangesFor. The application can still use
  ///   CaptureRequest\#CONTROL_AE_TARGET_FPS_RANGE to control the desired FPS range.
  ///   Switching to an FPS range that has different
  ///   android.util.Range\#getUpper() maximum FPS may trigger some camera device
  ///   reconfigurations, which may introduce extra latency. It is recommended that the
  ///   application avoids unnecessary maximum target FPS changes as much as possible during high
  ///   speed streaming.</li>
  ///
  /// <li>For the request lists submitted to this session, the camera device will override the
  ///   CaptureRequest\#CONTROL_MODE control mode, auto-exposure (AE), auto-white balance
  ///   (AWB) and auto-focus (AF) to CameraMetadata\#CONTROL_MODE_AUTO,
  ///   CameraMetadata\#CONTROL_AE_MODE_ON, CameraMetadata\#CONTROL_AWB_MODE_AUTO
  ///   and CameraMetadata\#CONTROL_AF_MODE_CONTINUOUS_VIDEO, respectively. All
  ///   post-processing block mode controls will be overridden to be FAST. Therefore, no manual
  ///   control of capture and post-processing parameters is possible. Beside these, only a subset
  ///   of controls will work, see
  ///   CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO for
  ///   more details.</li>
  ///
  /// </ul>
  ///@param outputs The new set of Surfaces that should be made available as
  ///                targets for captured high speed image data.
  /// This value must never be {@code null}.
  ///@param callback The callback to notify about the status of the new capture session.
  /// This value must never be {@code null}.
  ///@param handler The handler on which the callback should be invoked, or {@code null} to use
  ///                the current thread's android.os.Looper looper.
  ///
  /// This value may be {@code null}.
  ///@throws IllegalArgumentException if the set of output Surfaces do not meet the requirements,
  ///                                  the callback is null, or the handler is null but the current
  ///                                  thread has no looper, or the camera device doesn't support
  ///                                  high speed video capability.
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if the camera device has been closed
  ///@see \#createCaptureSession
  ///@see CaptureRequest\#CONTROL_AE_TARGET_FPS_RANGE
  ///@see StreamConfigurationMap\#getHighSpeedVideoSizes
  ///@see StreamConfigurationMap\#getHighSpeedVideoFpsRangesFor
  ///@see CameraCharacteristics\#REQUEST_AVAILABLE_CAPABILITIES
  ///@see CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO
  ///@see CameraCaptureSession\#captureBurst
  ///@see CameraCaptureSession\#setRepeatingBurst
  ///@see CameraConstrainedHighSpeedCaptureSession\#createHighSpeedRequestList
  void createConstrainedHighSpeedCaptureSession(
          jni.JniObject outputs,
          cameracapturesession_.CameraCaptureSession_StateCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_createConstrainedHighSpeedCaptureSession,
          jni.JniType.voidType,
          [outputs.reference, callback.reference, handler.reference]).check();

  static final _id_createCaptureSession1 = jniAccessors.getMethodIDOf(
      _classRef,
      "createCaptureSession",
      "(Landroid/hardware/camera2/params/SessionConfiguration;)V");

  /// from: public void createCaptureSession(android.hardware.camera2.params.SessionConfiguration config)
  ///
  /// Create a new CameraCaptureSession using a SessionConfiguration helper
  /// object that aggregates all supported parameters.
  ///
  ///@param config A session configuration (see SessionConfiguration).
  ///@throws IllegalArgumentException In case the session configuration is invalid; or the output
  ///                                  configurations are empty; or the session configuration
  ///                                  executor is invalid.
  ///@throws CameraAccessException In case the camera device is no longer connected or has
  ///                               encountered a fatal error.
  ///@see \#createCaptureSession(List, CameraCaptureSession.StateCallback, Handler)
  ///@see \#createCaptureSessionByOutputConfigurations
  ///@see \#createReprocessableCaptureSession
  ///@see \#createConstrainedHighSpeedCaptureSession
  void createCaptureSession1(
          sessionconfiguration_.SessionConfiguration config) =>
      jniAccessors.callMethodWithArgs(reference, _id_createCaptureSession1,
          jni.JniType.voidType, [config.reference]).check();

  static final _id_createCaptureRequest = jniAccessors.getMethodIDOf(
      _classRef,
      "createCaptureRequest",
      "(I)Landroid/hardware/camera2/CaptureRequest\$Builder;");

  /// from: public abstract android.hardware.camera2.CaptureRequest.Builder createCaptureRequest(int templateType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a CaptureRequest.Builder for new capture requests,
  /// initialized with template for a target use case. The settings are chosen
  /// to be the best options for the specific camera device, so it is not
  /// recommended to reuse the same request for a different camera device;
  /// create a builder specific for that device and template and override the
  /// settings as desired, instead.
  ///
  ///@param templateType An enumeration selecting the use case for this request. Not all template
  /// types are supported on every device. See the documentation for each template type for
  /// details.
  /// Value is android.hardware.camera2.CameraDevice\#TEMPLATE_PREVIEW, android.hardware.camera2.CameraDevice\#TEMPLATE_STILL_CAPTURE, android.hardware.camera2.CameraDevice\#TEMPLATE_RECORD, android.hardware.camera2.CameraDevice\#TEMPLATE_VIDEO_SNAPSHOT, android.hardware.camera2.CameraDevice\#TEMPLATE_ZERO_SHUTTER_LAG, or android.hardware.camera2.CameraDevice\#TEMPLATE_MANUAL
  ///@return a builder for a capture request, initialized with default
  /// settings for that template, and no output streams
  ///
  /// This value will never be {@code null}.
  ///@throws IllegalArgumentException if the templateType is not supported by
  /// this device.
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if the camera device has been closed
  capturerequest_.CaptureRequest_Builder createCaptureRequest(
          int templateType) =>
      capturerequest_.CaptureRequest_Builder.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_createCaptureRequest,
              jni.JniType.objectType, [templateType]).object);

  static final _id_createCaptureRequest1 = jniAccessors.getMethodIDOf(
      _classRef,
      "createCaptureRequest",
      "(ILjava/util/Set;)Landroid/hardware/camera2/CaptureRequest\$Builder;");

  /// from: public android.hardware.camera2.CaptureRequest.Builder createCaptureRequest(int templateType, java.util.Set<java.lang.String> physicalCameraIdSet)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a CaptureRequest.Builder for new capture requests,
  /// initialized with template for a target use case. This methods allows
  /// clients to pass physical camera ids which can be used to customize the
  /// request for a specific physical camera. The settings are chosen
  /// to be the best options for the specific logical camera device. If
  /// additional physical camera ids are passed, then they will also use the
  /// same settings template. Clients can further modify individual camera
  /// settings by calling CaptureRequest.Builder\#setPhysicalCameraKey.
  ///
  ///
  /// Individual physical camera settings will only be honored for camera session
  /// that was initialiazed with corresponding physical camera id output configuration
  /// OutputConfiguration\#setPhysicalCameraId and the same output targets are
  /// also attached in the request by CaptureRequest.Builder\#addTarget.
  ///
  ///
  /// The output is undefined for any logical camera streams in case valid physical camera
  /// settings are attached.
  ///
  ///@param templateType An enumeration selecting the use case for this request. Not all template
  /// types are supported on every device. See the documentation for each template type for
  /// details.
  /// Value is android.hardware.camera2.CameraDevice\#TEMPLATE_PREVIEW, android.hardware.camera2.CameraDevice\#TEMPLATE_STILL_CAPTURE, android.hardware.camera2.CameraDevice\#TEMPLATE_RECORD, android.hardware.camera2.CameraDevice\#TEMPLATE_VIDEO_SNAPSHOT, android.hardware.camera2.CameraDevice\#TEMPLATE_ZERO_SHUTTER_LAG, or android.hardware.camera2.CameraDevice\#TEMPLATE_MANUAL
  ///@param physicalCameraIdSet A set of physical camera ids that can be used to customize
  ///                            the request for a specific physical camera.
  ///@return a builder for a capture request, initialized with default
  /// settings for that template, and no output streams
  ///
  /// This value will never be {@code null}.
  ///@throws IllegalArgumentException if the templateType is not supported by
  /// this device, or one of the physical id arguments matches with logical camera id.
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if the camera device has been closed
  ///@see \#TEMPLATE_PREVIEW
  ///@see \#TEMPLATE_RECORD
  ///@see \#TEMPLATE_STILL_CAPTURE
  ///@see \#TEMPLATE_VIDEO_SNAPSHOT
  ///@see \#TEMPLATE_MANUAL
  ///@see CaptureRequest.Builder\#setPhysicalCameraKey
  ///@see CaptureRequest.Builder\#getPhysicalCameraKey
  capturerequest_.CaptureRequest_Builder createCaptureRequest1(
          int templateType, jni.JniObject physicalCameraIdSet) =>
      capturerequest_.CaptureRequest_Builder.fromRef(jniAccessors
          .callMethodWithArgs(
              reference,
              _id_createCaptureRequest1,
              jni.JniType.objectType,
              [templateType, physicalCameraIdSet.reference]).object);

  static final _id_createReprocessCaptureRequest = jniAccessors.getMethodIDOf(
      _classRef,
      "createReprocessCaptureRequest",
      "(Landroid/hardware/camera2/TotalCaptureResult;)Landroid/hardware/camera2/CaptureRequest\$Builder;");

  /// from: public abstract android.hardware.camera2.CaptureRequest.Builder createReprocessCaptureRequest(android.hardware.camera2.TotalCaptureResult inputResult)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a CaptureRequest.Builder for a new reprocess CaptureRequest from a
  /// TotalCaptureResult.
  ///
  /// Each reprocess CaptureRequest processes one buffer from
  /// CameraCaptureSession's input Surface to all output Surface Surfaces
  /// included in the reprocess capture request. The reprocess input images must be generated from
  /// one or multiple output images captured from the same camera device. The application can
  /// provide input images to camera device via android.media.ImageWriter\#queueInputImage.
  /// The application must use the capture result of one of those output images to create a
  /// reprocess capture request so that the camera device can use the information to achieve
  /// optimal reprocess image quality. For camera devices that support only 1 output
  /// Surface, submitting a reprocess CaptureRequest with multiple
  /// output targets will result in a CaptureFailure.
  ///@param inputResult The capture result of the output image or one of the output images used
  ///                       to generate the reprocess input image for this capture request.
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if inputResult is null.
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if the camera device has been closed
  ///@see CaptureRequest.Builder
  ///@see TotalCaptureResult
  ///@see CameraDevice\#createReprocessableCaptureSession
  ///@see android.media.ImageWriter
  capturerequest_.CaptureRequest_Builder createReprocessCaptureRequest(
          totalcaptureresult_.TotalCaptureResult inputResult) =>
      capturerequest_.CaptureRequest_Builder.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_createReprocessCaptureRequest,
              jni.JniType.objectType, [inputResult.reference]).object);

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public abstract void close()
  ///
  /// Close the connection to this camera device as quickly as possible.
  ///
  /// Immediately after this call, all calls to the camera device or active session interface
  /// will throw a IllegalStateException, except for calls to close(). Once the device has
  /// fully shut down, the StateCallback\#onClosed callback will be called, and the camera
  /// is free to be re-opened.
  ///
  ///
  /// Immediately after this call, besides the final StateCallback\#onClosed calls, no
  /// further callbacks from the device or the active session will occur, and any remaining
  /// submitted capture requests will be discarded, as if
  /// CameraCaptureSession\#abortCaptures had been called, except that no success or failure
  /// callbacks will be invoked.
  ///
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();
}

/// from: android.hardware.camera2.CameraDevice$StateCallback
///
/// A callback objects for receiving updates about the state of a camera device.
///
/// A callback instance must be provided to the CameraManager\#openCamera method to
/// open a camera device.
///
///
/// These state updates include notifications about the device completing startup (
/// allowing for \#createCaptureSession to be called), about device
/// disconnection or closure, and about unexpected device errors.
///
///
/// Events about the progress of specific CaptureRequest CaptureRequests are provided
/// through a CameraCaptureSession.CaptureCallback given to the
/// CameraCaptureSession\#capture, CameraCaptureSession\#captureBurst,
/// CameraCaptureSession\#setRepeatingRequest, or
/// CameraCaptureSession\#setRepeatingBurst methods.
///@see CameraManager\#openCamera
class CameraDevice_StateCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/hardware/camera2/CameraDevice\$StateCallback");
  CameraDevice_StateCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ERROR_CAMERA_DEVICE
  ///
  /// An error code that can be reported by \#onError
  /// indicating that the camera device has encountered a fatal error.
  ///
  /// The camera device needs to be re-opened to be used again.
  ///
  ///@see \#onError
  static const ERROR_CAMERA_DEVICE = 4;

  /// from: static public final int ERROR_CAMERA_DISABLED
  ///
  /// An error code that can be reported by \#onError
  /// indicating that the camera device could not be opened due to a device
  /// policy.
  ///@see android.app.admin.DevicePolicyManager\#setCameraDisabled(android.content.ComponentName, boolean)
  ///@see \#onError
  static const ERROR_CAMERA_DISABLED = 3;

  /// from: static public final int ERROR_CAMERA_IN_USE
  ///
  /// An error code that can be reported by \#onError
  /// indicating that the camera device is in use already.
  ///
  ///
  /// This error can be produced when opening the camera fails due to the camera
  ///  being used by a higher-priority camera API client.
  ///
  ///
  ///@see \#onError
  static const ERROR_CAMERA_IN_USE = 1;

  /// from: static public final int ERROR_CAMERA_SERVICE
  ///
  /// An error code that can be reported by \#onError
  /// indicating that the camera service has encountered a fatal error.
  ///
  /// The Android device may need to be shut down and restarted to restore
  /// camera function, or there may be a persistent hardware problem.
  ///
  ///
  /// An attempt at recovery <i>may</i> be possible by closing the
  /// CameraDevice and the CameraManager, and trying to acquire all resources
  /// again from scratch.
  ///
  ///@see \#onError
  static const ERROR_CAMERA_SERVICE = 5;

  /// from: static public final int ERROR_MAX_CAMERAS_IN_USE
  ///
  /// An error code that can be reported by \#onError
  /// indicating that the camera device could not be opened
  /// because there are too many other open camera devices.
  ///
  ///
  /// The system-wide limit for number of open cameras has been reached,
  /// and more camera devices cannot be opened until previous instances are
  /// closed.
  ///
  ///
  ///
  ///
  /// This error can be produced when opening the camera fails.
  ///
  ///
  ///@see \#onError
  static const ERROR_MAX_CAMERAS_IN_USE = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  CameraDevice_StateCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onOpened = jniAccessors.getMethodIDOf(
      _classRef, "onOpened", "(Landroid/hardware/camera2/CameraDevice;)V");

  /// from: public abstract void onOpened(android.hardware.camera2.CameraDevice camera)
  ///
  /// The method called when a camera device has finished opening.
  ///
  /// At this point, the camera device is ready to use, and
  /// CameraDevice\#createCaptureSession can be called to set up the first capture
  /// session.
  ///
  ///@param camera the camera device that has become opened
  ///
  /// This value must never be {@code null}.
  void onOpened(CameraDevice camera) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onOpened,
      jni.JniType.voidType,
      [camera.reference]).check();

  static final _id_onClosed = jniAccessors.getMethodIDOf(
      _classRef, "onClosed", "(Landroid/hardware/camera2/CameraDevice;)V");

  /// from: public void onClosed(android.hardware.camera2.CameraDevice camera)
  ///
  /// The method called when a camera device has been closed with
  /// CameraDevice\#close.
  ///
  /// Any attempt to call methods on this CameraDevice in the
  /// future will throw a IllegalStateException.
  ///
  ///
  /// The default implementation of this method does nothing.
  ///
  ///@param camera the camera device that has become closed
  ///
  /// This value must never be {@code null}.
  void onClosed(CameraDevice camera) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onClosed,
      jni.JniType.voidType,
      [camera.reference]).check();

  static final _id_onDisconnected = jniAccessors.getMethodIDOf(_classRef,
      "onDisconnected", "(Landroid/hardware/camera2/CameraDevice;)V");

  /// from: public abstract void onDisconnected(android.hardware.camera2.CameraDevice camera)
  ///
  /// The method called when a camera device is no longer available for
  /// use.
  ///
  /// This callback may be called instead of \#onOpened
  /// if opening the camera fails.
  ///
  ///
  /// Any attempt to call methods on this CameraDevice will throw a
  /// CameraAccessException. The disconnection could be due to a
  /// change in security policy or permissions; the physical disconnection
  /// of a removable camera device; or the camera being needed for a
  /// higher-priority camera API client.
  ///
  ///
  /// There may still be capture callbacks that are invoked
  /// after this method is called, or new image buffers that are delivered
  /// to active outputs.
  ///
  ///
  /// The default implementation logs a notice to the system log
  /// about the disconnection.
  ///
  ///
  /// You should clean up the camera with CameraDevice\#close after
  /// this happens, as it is not recoverable until the camera can be opened
  /// again. For most use cases, this will be when the camera again becomes
  /// CameraManager.AvailabilityCallback\#onCameraAvailable available.
  ///
  ///
  ///@param camera the device that has been disconnected
  ///
  /// This value must never be {@code null}.
  void onDisconnected(CameraDevice camera) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onDisconnected,
      jni.JniType.voidType,
      [camera.reference]).check();

  static final _id_onError = jniAccessors.getMethodIDOf(
      _classRef, "onError", "(Landroid/hardware/camera2/CameraDevice;I)V");

  /// from: public abstract void onError(android.hardware.camera2.CameraDevice camera, int error)
  ///
  /// The method called when a camera device has encountered a serious error.
  ///
  /// This callback may be called instead of \#onOpened
  /// if opening the camera fails.
  ///
  ///
  /// This indicates a failure of the camera device or camera service in
  /// some way. Any attempt to call methods on this CameraDevice in the
  /// future will throw a CameraAccessException with the
  /// CameraAccessException\#CAMERA_ERROR CAMERA_ERROR reason.
  ///
  ///
  ///
  /// There may still be capture completion or camera stream callbacks
  /// that will be called after this error is received.
  ///
  ///
  /// You should clean up the camera with CameraDevice\#close after
  /// this happens. Further attempts at recovery are error-code specific.
  ///
  ///@param camera The device reporting the error
  /// This value must never be {@code null}.
  ///@param error The error code.
  ///
  /// Value is android.hardware.camera2.CameraDevice.StateCallback\#ERROR_CAMERA_IN_USE, android.hardware.camera2.CameraDevice.StateCallback\#ERROR_MAX_CAMERAS_IN_USE, android.hardware.camera2.CameraDevice.StateCallback\#ERROR_CAMERA_DISABLED, android.hardware.camera2.CameraDevice.StateCallback\#ERROR_CAMERA_DEVICE, or android.hardware.camera2.CameraDevice.StateCallback\#ERROR_CAMERA_SERVICE
  ///@see \#ERROR_CAMERA_IN_USE
  ///@see \#ERROR_MAX_CAMERAS_IN_USE
  ///@see \#ERROR_CAMERA_DISABLED
  ///@see \#ERROR_CAMERA_DEVICE
  ///@see \#ERROR_CAMERA_SERVICE
  void onError(CameraDevice camera, int error) =>
      jniAccessors.callMethodWithArgs(reference, _id_onError,
          jni.JniType.voidType, [camera.reference, error]).check();
}
