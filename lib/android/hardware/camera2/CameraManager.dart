// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../content/Context.dart" as context_;

import "../../os/Handler.dart" as handler_;

import "CameraCharacteristics.dart" as cameracharacteristics_;

import "CameraDevice.dart" as cameradevice_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.camera2.CameraManager
///
/// A system service manager for detecting, characterizing, and connecting to
/// CameraDevice CameraDevices.
///
///
/// For more details about communicating with camera devices, read the Camera
/// developer guide or the android.hardware.camera2 camera2
/// package documentation.
///
class CameraManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/camera2/CameraManager");
  CameraManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  CameraManager(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_getCameraIdList = jniAccessors.getMethodIDOf(
      _classRef, "getCameraIdList", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getCameraIdList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the list of currently connected camera devices by identifier, including
  /// cameras that may be in use by other camera API clients.
  ///
  /// Non-removable cameras use integers starting at 0 for their
  /// identifiers, while removable cameras have a unique identifier for each
  /// individual device, even if they are the same model.
  ///
  ///@return The list of currently connected camera devices.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getCameraIdList() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCameraIdList, jni.JniType.objectType, []).object);

  static final _id_registerAvailabilityCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerAvailabilityCallback",
      "(Landroid/hardware/camera2/CameraManager\$AvailabilityCallback;Landroid/os/Handler;)V");

  /// from: public void registerAvailabilityCallback(android.hardware.camera2.CameraManager.AvailabilityCallback callback, android.os.Handler handler)
  ///
  /// Register a callback to be notified about camera device availability.
  ///
  /// Registering the same callback again will replace the handler with the
  /// new one provided.
  ///
  ///
  /// The first time a callback is registered, it is immediately called
  /// with the availability status of all currently known camera devices.
  ///
  ///
  /// AvailabilityCallback\#onCameraUnavailable(String) will be called whenever a camera
  /// device is opened by any camera API client. As of API level 23, other camera API clients may
  /// still be able to open such a camera device, evicting the existing client if they have higher
  /// priority than the existing client of a camera device. See open() for more details.
  ///
  ///
  /// Since this callback will be registered with the camera service, remember to unregister it
  /// once it is no longer needed; otherwise the callback will continue to receive events
  /// indefinitely and it may prevent other resources from being released. Specifically, the
  /// callbacks will be invoked independently of the general activity lifecycle and independently
  /// of the state of individual CameraManager instances.
  ///
  ///@param callback the new callback to send camera availability notices to
  /// This value must never be {@code null}.
  ///@param handler The handler on which the callback should be invoked, or {@code null} to use
  ///             the current thread's android.os.Looper looper.
  ///
  /// This value may be {@code null}.
  ///@throws IllegalArgumentException if the handler is {@code null} but the current thread has
  ///             no looper.
  void registerAvailabilityCallback(CameraManager_AvailabilityCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerAvailabilityCallback,
          jni.JniType.voidType,
          [callback.reference, handler.reference]).check();

  static final _id_registerAvailabilityCallback1 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerAvailabilityCallback",
      "(Ljava/util/concurrent/Executor;Landroid/hardware/camera2/CameraManager\$AvailabilityCallback;)V");

  /// from: public void registerAvailabilityCallback(java.util.concurrent.Executor executor, android.hardware.camera2.CameraManager.AvailabilityCallback callback)
  ///
  /// Register a callback to be notified about camera device availability.
  ///
  /// The behavior of this method matches that of
  /// \#registerAvailabilityCallback(AvailabilityCallback, Handler),
  /// except that it uses java.util.concurrent.Executor as an argument
  /// instead of android.os.Handler.
  ///
  ///@param executor The executor which will be used to invoke the callback.
  /// This value must never be {@code null}.
  /// Callback and listener events are dispatched through this
  ///  *           Executor, providing an easy way to control which thread is
  ///  *           used. To dispatch events through the main thread of your
  ///  *           application, you can use Context\#getMainExecutor(). To
  ///  *           dispatch events through a shared thread pool, you can use
  ///  *           AsyncTask\#THREAD_POOL_EXECUTOR.
  ///@param callback the new callback to send camera availability notices to
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if the executor is {@code null}.
  void registerAvailabilityCallback1(jni.JniObject executor,
          CameraManager_AvailabilityCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerAvailabilityCallback1,
          jni.JniType.voidType,
          [executor.reference, callback.reference]).check();

  static final _id_unregisterAvailabilityCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterAvailabilityCallback",
      "(Landroid/hardware/camera2/CameraManager\$AvailabilityCallback;)V");

  /// from: public void unregisterAvailabilityCallback(android.hardware.camera2.CameraManager.AvailabilityCallback callback)
  ///
  /// Remove a previously-added callback; the callback will no longer receive connection and
  /// disconnection callbacks.
  ///
  /// Removing a callback that isn't registered has no effect.
  ///
  ///@param callback The callback to remove from the notification list
  ///
  /// This value must never be {@code null}.
  void unregisterAvailabilityCallback(
          CameraManager_AvailabilityCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterAvailabilityCallback,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_registerTorchCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerTorchCallback",
      "(Landroid/hardware/camera2/CameraManager\$TorchCallback;Landroid/os/Handler;)V");

  /// from: public void registerTorchCallback(android.hardware.camera2.CameraManager.TorchCallback callback, android.os.Handler handler)
  ///
  /// Register a callback to be notified about torch mode status.
  ///
  /// Registering the same callback again will replace the handler with the
  /// new one provided.
  ///
  ///
  /// The first time a callback is registered, it is immediately called
  /// with the torch mode status of all currently known camera devices with a flash unit.
  ///
  ///
  /// Since this callback will be registered with the camera service, remember to unregister it
  /// once it is no longer needed; otherwise the callback will continue to receive events
  /// indefinitely and it may prevent other resources from being released. Specifically, the
  /// callbacks will be invoked independently of the general activity lifecycle and independently
  /// of the state of individual CameraManager instances.
  ///
  ///@param callback The new callback to send torch mode status to
  /// This value must never be {@code null}.
  ///@param handler The handler on which the callback should be invoked, or {@code null} to use
  ///             the current thread's android.os.Looper looper.
  ///
  /// This value may be {@code null}.
  ///@throws IllegalArgumentException if the handler is {@code null} but the current thread has
  ///             no looper.
  void registerTorchCallback(
          CameraManager_TorchCallback callback, handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerTorchCallback,
          jni.JniType.voidType,
          [callback.reference, handler.reference]).check();

  static final _id_registerTorchCallback1 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerTorchCallback",
      "(Ljava/util/concurrent/Executor;Landroid/hardware/camera2/CameraManager\$TorchCallback;)V");

  /// from: public void registerTorchCallback(java.util.concurrent.Executor executor, android.hardware.camera2.CameraManager.TorchCallback callback)
  ///
  /// Register a callback to be notified about torch mode status.
  ///
  /// The behavior of this method matches that of
  /// \#registerTorchCallback(TorchCallback, Handler),
  /// except that it uses java.util.concurrent.Executor as an argument
  /// instead of android.os.Handler.
  ///
  ///@param executor The executor which will be used to invoke the callback
  /// This value must never be {@code null}.
  /// Callback and listener events are dispatched through this
  ///  *           Executor, providing an easy way to control which thread is
  ///  *           used. To dispatch events through the main thread of your
  ///  *           application, you can use Context\#getMainExecutor(). To
  ///  *           dispatch events through a shared thread pool, you can use
  ///  *           AsyncTask\#THREAD_POOL_EXECUTOR.
  ///@param callback The new callback to send torch mode status to
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if the executor is {@code null}.
  void registerTorchCallback1(
          jni.JniObject executor, CameraManager_TorchCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerTorchCallback1,
          jni.JniType.voidType,
          [executor.reference, callback.reference]).check();

  static final _id_unregisterTorchCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterTorchCallback",
      "(Landroid/hardware/camera2/CameraManager\$TorchCallback;)V");

  /// from: public void unregisterTorchCallback(android.hardware.camera2.CameraManager.TorchCallback callback)
  ///
  /// Remove a previously-added callback; the callback will no longer receive torch mode status
  /// callbacks.
  ///
  /// Removing a callback that isn't registered has no effect.
  ///
  ///@param callback The callback to remove from the notification list
  ///
  /// This value must never be {@code null}.
  void unregisterTorchCallback(CameraManager_TorchCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterTorchCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_getCameraCharacteristics = jniAccessors.getMethodIDOf(
      _classRef,
      "getCameraCharacteristics",
      "(Ljava/lang/String;)Landroid/hardware/camera2/CameraCharacteristics;");

  /// from: public android.hardware.camera2.CameraCharacteristics getCameraCharacteristics(java.lang.String cameraId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the capabilities of a camera device. These capabilities are
  /// immutable for a given camera.
  ///
  ///@param cameraId The id of the camera device to query
  /// This value must never be {@code null}.
  ///@return The properties of the given camera
  ///
  /// This value will never be {@code null}.
  ///@throws IllegalArgumentException if the cameraId does not match any
  ///         known camera device.
  ///@throws CameraAccessException if the camera device has been disconnected.
  ///@see \#getCameraIdList
  ///@see android.app.admin.DevicePolicyManager\#setCameraDisabled
  cameracharacteristics_.CameraCharacteristics getCameraCharacteristics(
          jni.JniString cameraId) =>
      cameracharacteristics_.CameraCharacteristics.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getCameraCharacteristics,
              jni.JniType.objectType, [cameraId.reference]).object);

  static final _id_openCamera = jniAccessors.getMethodIDOf(
      _classRef,
      "openCamera",
      "(Ljava/lang/String;Landroid/hardware/camera2/CameraDevice\$StateCallback;Landroid/os/Handler;)V");

  /// from: public void openCamera(java.lang.String cameraId, android.hardware.camera2.CameraDevice.StateCallback callback, android.os.Handler handler)
  ///
  /// Open a connection to a camera with the given ID.
  ///
  /// Use \#getCameraIdList to get the list of available camera
  /// devices. Note that even if an id is listed, open may fail if the device
  /// is disconnected between the calls to \#getCameraIdList and
  /// \#openCamera, or if a higher-priority camera API client begins using the
  /// camera device.
  ///
  ///
  /// As of API level 23, devices for which the
  /// AvailabilityCallback\#onCameraUnavailable(String) callback has been called due to the
  /// device being in use by a lower-priority, background camera API client can still potentially
  /// be opened by calling this method when the calling camera API client has a higher priority
  /// than the current camera API client using this device.  In general, if the top, foreground
  /// activity is running within your application process, your process will be given the highest
  /// priority when accessing the camera, and this method will succeed even if the camera device is
  /// in use by another camera API client. Any lower-priority application that loses control of the
  /// camera in this way will receive an
  /// android.hardware.camera2.CameraDevice.StateCallback\#onDisconnected callback.
  ///
  ///
  /// Once the camera is successfully opened, CameraDevice.StateCallback\#onOpened will
  /// be invoked with the newly opened CameraDevice. The camera device can then be set up
  /// for operation by calling CameraDevice\#createCaptureSession and
  /// CameraDevice\#createCaptureRequest
  ///
  ///
  /// <!--
  /// Since the camera device will be opened asynchronously, any asynchronous operations done
  /// on the returned CameraDevice instance will be queued up until the device startup has
  /// completed and the callback's CameraDevice.StateCallback\#onOpened onOpened method is
  /// called. The pending operations are then processed in order.
  ///
  /// -->
  /// If the camera becomes disconnected during initialization
  /// after this function call returns,
  /// CameraDevice.StateCallback\#onDisconnected with a
  /// CameraDevice in the disconnected state (and
  /// CameraDevice.StateCallback\#onOpened will be skipped).
  ///
  ///
  /// If opening the camera device fails, then the device callback's
  /// CameraDevice.StateCallback\#onError onError method will be called, and subsequent
  /// calls on the camera device will throw a CameraAccessException.
  ///
  ///
  /// Requires android.Manifest.permission\#CAMERA
  ///@param cameraId The unique identifier of the camera device to open
  /// This value must never be {@code null}.
  ///@param callback The callback which is invoked once the camera is opened
  /// This value must never be {@code null}.
  ///@param handler The handler on which the callback should be invoked, or
  ///             {@code null} to use the current thread's android.os.Looper looper.
  ///
  /// This value may be {@code null}.
  ///@throws CameraAccessException if the camera is disabled by device policy,
  /// has been disconnected, or is being used by a higher-priority camera API client.
  ///@throws IllegalArgumentException if cameraId or the callback was null,
  /// or the cameraId does not match any currently or previously available
  /// camera device.
  ///@throws SecurityException if the application does not have permission to
  /// access the camera
  ///@see \#getCameraIdList
  ///@see android.app.admin.DevicePolicyManager\#setCameraDisabled
  void openCamera(
          jni.JniString cameraId,
          cameradevice_.CameraDevice_StateCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_openCamera,
          jni.JniType.voidType,
          [cameraId.reference, callback.reference, handler.reference]).check();

  static final _id_openCamera1 = jniAccessors.getMethodIDOf(
      _classRef,
      "openCamera",
      "(Ljava/lang/String;Ljava/util/concurrent/Executor;Landroid/hardware/camera2/CameraDevice\$StateCallback;)V");

  /// from: public void openCamera(java.lang.String cameraId, java.util.concurrent.Executor executor, android.hardware.camera2.CameraDevice.StateCallback callback)
  ///
  /// Open a connection to a camera with the given ID.
  ///
  /// The behavior of this method matches that of
  /// \#openCamera(String, StateCallback, Handler), except that it uses
  /// java.util.concurrent.Executor as an argument instead of
  /// android.os.Handler.
  ///
  ///
  /// Requires android.Manifest.permission\#CAMERA
  ///@param cameraId The unique identifier of the camera device to open
  /// This value must never be {@code null}.
  ///@param executor The executor which will be used when invoking the callback.
  /// This value must never be {@code null}.
  /// Callback and listener events are dispatched through this
  ///  *           Executor, providing an easy way to control which thread is
  ///  *           used. To dispatch events through the main thread of your
  ///  *           application, you can use Context\#getMainExecutor(). To
  ///  *           dispatch events through a shared thread pool, you can use
  ///  *           AsyncTask\#THREAD_POOL_EXECUTOR.
  ///@param callback The callback which is invoked once the camera is opened
  ///
  /// This value must never be {@code null}.
  ///@throws CameraAccessException if the camera is disabled by device policy,
  /// has been disconnected, or is being used by a higher-priority camera API client.
  ///@throws IllegalArgumentException if cameraId, the callback or the executor was null,
  /// or the cameraId does not match any currently or previously available
  /// camera device.
  ///@throws SecurityException if the application does not have permission to
  /// access the camera
  ///@see \#getCameraIdList
  ///@see android.app.admin.DevicePolicyManager\#setCameraDisabled
  void openCamera1(jni.JniString cameraId, jni.JniObject executor,
          cameradevice_.CameraDevice_StateCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_openCamera1,
          jni.JniType.voidType,
          [cameraId.reference, executor.reference, callback.reference]).check();

  static final _id_setTorchMode = jniAccessors.getMethodIDOf(
      _classRef, "setTorchMode", "(Ljava/lang/String;Z)V");

  /// from: public void setTorchMode(java.lang.String cameraId, boolean enabled)
  ///
  /// Set the flash unit's torch mode of the camera of the given ID without opening the camera
  /// device.
  ///
  /// Use \#getCameraIdList to get the list of available camera devices and use
  /// \#getCameraCharacteristics to check whether the camera device has a flash unit.
  /// Note that even if a camera device has a flash unit, turning on the torch mode may fail
  /// if the camera device or other camera resources needed to turn on the torch mode are in use.
  ///
  ///
  ///
  ///  If \#setTorchMode is called to turn on or off the torch mode successfully,
  /// CameraManager.TorchCallback\#onTorchModeChanged will be invoked.
  /// However, even if turning on the torch mode is successful, the application does not have the
  /// exclusive ownership of the flash unit or the camera device. The torch mode will be turned
  /// off and becomes unavailable when the camera device that the flash unit belongs to becomes
  /// unavailable or when other camera resources to keep the torch on become unavailable (
  /// CameraManager.TorchCallback\#onTorchModeUnavailable will be invoked). Also,
  /// other applications are free to call \#setTorchMode to turn off the torch mode (
  /// CameraManager.TorchCallback\#onTorchModeChanged will be invoked). If the latest
  /// application that turned on the torch mode exits, the torch mode will be turned off.
  ///@param cameraId The unique identifier of the camera device that the flash unit belongs to.
  /// This value must never be {@code null}.
  ///@param enabled The desired state of the torch mode for the target camera device. Set to
  ///             {@code true} to turn on the torch mode. Set to {@code false} to turn off the
  ///             torch mode.
  ///@throws CameraAccessException if it failed to access the flash unit.
  ///             CameraAccessException\#CAMERA_IN_USE will be thrown if the camera device
  ///             is in use. CameraAccessException\#MAX_CAMERAS_IN_USE will be thrown if
  ///             other camera resources needed to turn on the torch mode are in use.
  ///             CameraAccessException\#CAMERA_DISCONNECTED will be thrown if camera
  ///             service is not available.
  ///@throws IllegalArgumentException if cameraId was null, cameraId doesn't match any currently
  ///             or previously available camera device, or the camera device doesn't have a
  ///             flash unit.
  void setTorchMode(jni.JniString cameraId, bool enabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTorchMode,
          jni.JniType.voidType, [cameraId.reference, enabled]).check();
}

/// from: android.hardware.camera2.CameraManager$TorchCallback
///
/// A callback for camera flash torch modes becoming unavailable, disabled, or enabled.
///
/// The torch mode becomes unavailable when the camera device it belongs to becomes
/// unavailable or other camera resources it needs become busy due to other higher priority
/// camera activities. The torch mode becomes disabled when it was turned off or when the camera
/// device it belongs to is no longer in use and other camera resources it needs are no longer
/// busy. A camera's torch mode is turned off when an application calls \#setTorchMode to
/// turn off the camera's torch mode, or when an application turns on another camera's torch mode
/// if keeping multiple torch modes on simultaneously is not supported. The torch mode becomes
/// enabled when it is turned on via \#setTorchMode.
///
///
/// The torch mode is available to set via \#setTorchMode only when it's in a disabled
/// or enabled state.
///
///
/// Extend this callback and pass an instance of the subclass to
/// CameraManager\#registerTorchCallback to be notified of such status changes.
///
///
///@see \#registerTorchCallback
class CameraManager_TorchCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/hardware/camera2/CameraManager\$TorchCallback");
  CameraManager_TorchCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  CameraManager_TorchCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onTorchModeUnavailable = jniAccessors.getMethodIDOf(
      _classRef, "onTorchModeUnavailable", "(Ljava/lang/String;)V");

  /// from: public void onTorchModeUnavailable(java.lang.String cameraId)
  ///
  /// A camera's torch mode has become unavailable to set via \#setTorchMode.
  ///
  /// If torch mode was previously turned on by calling \#setTorchMode, it will be
  /// turned off before CameraManager.TorchCallback\#onTorchModeUnavailable is
  /// invoked. \#setTorchMode will fail until the torch mode has entered a disabled or
  /// enabled state again.
  ///
  ///
  /// The default implementation of this method does nothing.
  ///
  ///@param cameraId The unique identifier of the camera whose torch mode has become
  ///                 unavailable.
  ///
  /// This value must never be {@code null}.
  void onTorchModeUnavailable(jni.JniString cameraId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTorchModeUnavailable,
          jni.JniType.voidType, [cameraId.reference]).check();

  static final _id_onTorchModeChanged = jniAccessors.getMethodIDOf(
      _classRef, "onTorchModeChanged", "(Ljava/lang/String;Z)V");

  /// from: public void onTorchModeChanged(java.lang.String cameraId, boolean enabled)
  ///
  /// A camera's torch mode has become enabled or disabled and can be changed via
  /// \#setTorchMode.
  ///
  /// The default implementation of this method does nothing.
  ///
  ///@param cameraId The unique identifier of the camera whose torch mode has been changed.
  ///
  /// This value must never be {@code null}.
  ///@param enabled The state that the torch mode of the camera has been changed to.
  ///                {@code true} when the torch mode has become on and available to be turned
  ///                off. {@code false} when the torch mode has becomes off and available to
  ///                be turned on.
  void onTorchModeChanged(jni.JniString cameraId, bool enabled) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTorchModeChanged,
          jni.JniType.voidType, [cameraId.reference, enabled]).check();
}

/// from: android.hardware.camera2.CameraManager$AvailabilityCallback
///
/// A callback for camera devices becoming available or unavailable to open.
///
/// Cameras become available when they are no longer in use, or when a new
/// removable camera is connected. They become unavailable when some
/// application or service starts using a camera, or when a removable camera
/// is disconnected.
///
///
/// Extend this callback and pass an instance of the subclass to
/// CameraManager\#registerAvailabilityCallback to be notified of such availability
/// changes.
///
///@see \#registerAvailabilityCallback
class CameraManager_AvailabilityCallback extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/hardware/camera2/CameraManager\$AvailabilityCallback");
  CameraManager_AvailabilityCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  CameraManager_AvailabilityCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onCameraAvailable = jniAccessors.getMethodIDOf(
      _classRef, "onCameraAvailable", "(Ljava/lang/String;)V");

  /// from: public void onCameraAvailable(java.lang.String cameraId)
  ///
  /// A new camera has become available to use.
  ///
  /// The default implementation of this method does nothing.
  ///
  ///@param cameraId The unique identifier of the new camera.
  ///
  /// This value must never be {@code null}.
  void onCameraAvailable(jni.JniString cameraId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCameraAvailable,
          jni.JniType.voidType, [cameraId.reference]).check();

  static final _id_onCameraUnavailable = jniAccessors.getMethodIDOf(
      _classRef, "onCameraUnavailable", "(Ljava/lang/String;)V");

  /// from: public void onCameraUnavailable(java.lang.String cameraId)
  ///
  /// A previously-available camera has become unavailable for use.
  ///
  /// If an application had an active CameraDevice instance for the
  /// now-disconnected camera, that application will receive a
  /// CameraDevice.StateCallback\#onDisconnected disconnection error.
  ///
  ///
  /// The default implementation of this method does nothing.
  ///
  ///@param cameraId The unique identifier of the disconnected camera.
  ///
  /// This value must never be {@code null}.
  void onCameraUnavailable(jni.JniString cameraId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCameraUnavailable,
          jni.JniType.voidType, [cameraId.reference]).check();
}
