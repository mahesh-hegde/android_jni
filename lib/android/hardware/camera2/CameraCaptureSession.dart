// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "CameraDevice.dart" as cameradevice_;

import "../../view/Surface.dart" as surface_;

import "CaptureRequest.dart" as capturerequest_;

import "../../os/Handler.dart" as handler_;

import "params/OutputConfiguration.dart" as outputconfiguration_;

import "CaptureResult.dart" as captureresult_;

import "TotalCaptureResult.dart" as totalcaptureresult_;

import "CaptureFailure.dart" as capturefailure_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.camera2.CameraCaptureSession
///
/// A configured capture session for a CameraDevice, used for capturing images from the
/// camera or reprocessing images captured from the camera in the same session previously.
///
/// A CameraCaptureSession is created by providing a set of target output surfaces to
/// CameraDevice\#createCaptureSession createCaptureSession, or by providing an
/// android.hardware.camera2.params.InputConfiguration and a set of target output surfaces to
/// CameraDevice\#createReprocessableCaptureSession createReprocessableCaptureSession for a
/// reprocessable capture session. Once created, the session is active until a new session is
/// created by the camera device, or the camera device is closed.
///
///
/// All capture sessions can be used for capturing images from the camera but only reprocessable
/// capture sessions can reprocess images captured from the camera in the same session previously.
///
///
///
/// Creating a session is an expensive operation and can take several hundred milliseconds, since
/// it requires configuring the camera device's internal pipelines and allocating memory buffers for
/// sending images to the desired targets. Therefore the setup is done asynchronously, and
/// CameraDevice\#createCaptureSession createCaptureSession and
/// CameraDevice\#createReprocessableCaptureSession createReprocessableCaptureSession will
/// send the ready-to-use CameraCaptureSession to the provided listener's
/// CameraCaptureSession.StateCallback\#onConfigured onConfigured callback. If configuration
/// cannot be completed, then the
/// CameraCaptureSession.StateCallback\#onConfigureFailed onConfigureFailed is called, and the
/// session will not become active.
///
///<!--
/// Any capture requests (repeating or non-repeating) submitted before the session is ready will
/// be queued up and will begin capture once the session becomes ready. In case the session cannot be
/// configured and StateCallback\#onConfigureFailed onConfigureFailed is called, all queued
/// capture requests are discarded.
///
///-->
/// If a new session is created by the camera device, then the previous session is closed, and its
/// associated StateCallback\#onClosed onClosed callback will be invoked.  All
/// of the session methods will throw an IllegalStateException if called once the session is
/// closed.
///
///
/// A closed session clears any repeating requests (as if \#stopRepeating had been called),
/// but will still complete all of its in-progress capture requests as normal, before a newly
/// created session takes over and reconfigures the camera device.
///
class CameraCaptureSession extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/camera2/CameraCaptureSession");
  CameraCaptureSession.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  CameraCaptureSession()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getDevice = jniAccessors.getMethodIDOf(
      _classRef, "getDevice", "()Landroid/hardware/camera2/CameraDevice;");

  /// from: public abstract android.hardware.camera2.CameraDevice getDevice()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the camera device that this session is created for.
  ///@return This value will never be {@code null}.
  cameradevice_.CameraDevice getDevice() =>
      cameradevice_.CameraDevice.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDevice, jni.JniType.objectType, []).object);

  static final _id_prepare = jniAccessors.getMethodIDOf(
      _classRef, "prepare", "(Landroid/view/Surface;)V");

  /// from: public abstract void prepare(android.view.Surface surface)
  ///
  /// Pre-allocate all buffers for an output Surface.
  ///
  ///
  /// Normally, the image buffers for a given output Surface are allocated on-demand,
  /// to minimize startup latency and memory overhead.
  ///
  ///
  /// However, in some cases, it may be desirable for the buffers to be allocated before
  /// any requests targeting the Surface are actually submitted to the device. Large buffers
  /// may take some time to allocate, which can result in delays in submitting requests until
  /// sufficient buffers are allocated to reach steady-state behavior. Such delays can cause
  /// bursts to take longer than desired, or cause skips or stutters in preview output.
  ///
  ///
  /// The prepare() method can be used to perform this preallocation. It may only be called for
  /// a given output Surface before that Surface is used as a target for a request. The number of
  /// buffers allocated is the sum of the count needed by the consumer providing the output
  /// Surface, and the maximum number needed by the camera device to fill its pipeline. Since this
  /// may be a larger number than what is actually required for steady-state operation, using
  /// prepare may result in higher memory consumption than the normal on-demand behavior results
  /// in. Prepare() will also delay the time to first output to a given Surface, in exchange for
  /// smoother frame rate once the allocation is complete.
  ///
  ///
  /// For example, an application that creates an
  /// android.media.ImageReader\#newInstance ImageReader with a maxImages argument of 10,
  /// but only uses 3 simultaneous Images at once would normally only cause those 3 images to be
  /// allocated (plus what is needed by the camera device for smooth operation).  But using
  /// prepare() on the ImageReader Surface will result in all 10 Images being allocated. So
  /// applications using this method should take care to request only the number of buffers
  /// actually necessary for their application.
  ///
  ///
  /// If the same output Surface is used in consecutive sessions (without closing the first
  /// session explicitly), then its already-allocated buffers are carried over, and if it was
  /// used as a target of a capture request in the first session, prepare cannot be called on it
  /// in the second session.
  ///
  ///
  /// Once allocation is complete, StateCallback\#onSurfacePrepared will be invoked with
  /// the Surface provided to this method. Between the prepare call and the onSurfacePrepared call,
  /// the Surface provided to prepare must not be used as a target of a CaptureRequest submitted
  /// to this session.
  ///
  ///
  /// Note that if 2 surfaces share the same stream via OutputConfiguration\#enableSurfaceSharing and OutputConfiguration\#addSurface,
  /// prepare() only needs to be called on one surface, and {link
  /// StateCallback\#onSurfacePrepared} will be triggered for both surfaces.
  ///
  ///
  /// android.hardware.camera2.CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY LEGACY
  /// devices cannot pre-allocate output buffers; for those devices,
  /// StateCallback\#onSurfacePrepared will be immediately called, and no preallocation is
  /// done.
  ///
  ///@param surface the output Surface for which buffers should be pre-allocated. Must be one of
  /// the output Surfaces used to create this session.
  ///
  /// This value must never be {@code null}.
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if this session is no longer active, either because the session
  ///                               was explicitly closed, a new session has been created
  ///                               or the camera device has been closed.
  ///@throws IllegalArgumentException if the Surface is invalid, not part of this Session, or has
  ///                                  already been used as a target of a CaptureRequest in this
  ///                                  session or immediately prior sessions.
  ///@see StateCallback\#onSurfacePrepared
  void prepare(surface_.Surface surface) => jniAccessors.callMethodWithArgs(
      reference,
      _id_prepare,
      jni.JniType.voidType,
      [surface.reference]).check();

  static final _id_finalizeOutputConfigurations = jniAccessors.getMethodIDOf(
      _classRef, "finalizeOutputConfigurations", "(Ljava/util/List;)V");

  /// from: public abstract void finalizeOutputConfigurations(java.util.List<android.hardware.camera2.params.OutputConfiguration> outputConfigs)
  ///
  /// Finalize the output configurations that now have their deferred and/or extra Surfaces
  /// included.
  ///
  ///
  /// For camera use cases where a preview and other output configurations need to be
  /// configured, it can take some time for the preview Surface to be ready. For example, if the
  /// preview Surface is obtained from android.view.SurfaceView, the SurfaceView will only
  /// be ready after the UI layout is done, potentially delaying camera startup.
  ///
  ///
  /// To speed up camera startup time, the application can configure the
  /// CameraCaptureSession with the eventual preview size (via
  /// OutputConfiguration\#OutputConfiguration(Size,Class) a deferred OutputConfiguration),
  /// and defer the preview output configuration until the Surface is ready. After the
  /// CameraCaptureSession is created successfully with this deferred output and other
  /// normal outputs, the application can start submitting requests as long as they do not include
  /// deferred output Surfaces. Once a deferred Surface is ready, the application can add the
  /// Surface to the deferred output configuration with the
  /// OutputConfiguration\#addSurface method, and then update the deferred output
  /// configuration via this method, before it can submit capture requests with this output
  /// target.
  ///
  ///
  /// This function can also be called in case where multiple surfaces share the same
  /// OutputConfiguration, and one of the surfaces becomes available after the CameraCaptureSession is created. In that case, the application must first create the
  /// OutputConfiguration with the available Surface, then enable further surface sharing via
  /// OutputConfiguration\#enableSurfaceSharing, before creating the CameraCaptureSession.
  /// After the CameraCaptureSession is created, and once the extra Surface becomes available, the
  /// application must then call OutputConfiguration\#addSurface before finalizing the
  /// configuration with this method.
  ///
  ///
  /// If the provided OutputConfigurations are unchanged from session creation, this function
  /// call has no effect. This function must only be called once for a particular output
  /// configuration.
  ///
  ///
  /// The output Surfaces included by this list of
  /// OutputConfiguration OutputConfigurations can be used as CaptureRequest
  /// targets as soon as this call returns.
  ///
  ///
  /// This method is not supported by
  /// CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY LEGACY-level devices.
  ///
  ///@param outputConfigs a list of OutputConfiguration OutputConfigurations that
  ///            have had OutputConfiguration\#addSurface addSurface invoked with a valid
  ///            output Surface after CameraDevice\#createCaptureSessionByOutputConfigurations.
  ///@throws CameraAccessException if the camera device is no longer connected or has encountered
  ///             a fatal error.
  ///@throws IllegalStateException if this session is no longer active, either because the session
  ///             was explicitly closed, a new session has been created, or the camera device has
  ///             been closed.
  ///@throws IllegalArgumentException for invalid output configurations, including ones where the
  ///             source of the Surface is no longer valid or the Surface is from a unsupported
  ///             source. Or if one of the output configuration was already finished with an
  ///             included surface in a prior call.
  void finalizeOutputConfigurations(jni.JniObject outputConfigs) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_finalizeOutputConfigurations,
          jni.JniType.voidType,
          [outputConfigs.reference]).check();

  static final _id_capture = jniAccessors.getMethodIDOf(_classRef, "capture",
      "(Landroid/hardware/camera2/CaptureRequest;Landroid/hardware/camera2/CameraCaptureSession\$CaptureCallback;Landroid/os/Handler;)I");

  /// from: public abstract int capture(android.hardware.camera2.CaptureRequest request, android.hardware.camera2.CameraCaptureSession.CaptureCallback listener, android.os.Handler handler)
  ///
  /// Submit a request for an image to be captured by the camera device.
  ///
  ///
  /// The request defines all the parameters for capturing the single image,
  /// including sensor, lens, flash, and post-processing settings.
  ///
  ///
  /// Each request will produce one CaptureResult and produce new frames for one or more
  /// target Surfaces, set with the CaptureRequest builder's
  /// CaptureRequest.Builder\#addTarget method. The target surfaces (set with
  /// CaptureRequest.Builder\#addTarget) must be a subset of the surfaces provided when this
  /// capture session was created.
  ///
  ///
  /// Multiple regular and reprocess requests can be in progress at once. If there are only
  /// regular requests or reprocess requests in progress, they are processed in first-in,
  /// first-out order. If there are both regular and reprocess requests in progress, regular
  /// requests are processed in first-in, first-out order and reprocess requests are processed in
  /// first-in, first-out order, respectively. However, the processing order of a regular request
  /// and a reprocess request in progress is not specified. In other words, a regular request
  /// will always be processed before regular requets that are submitted later. A reprocess request
  /// will always be processed before reprocess requests that are submitted later. However, a
  /// regular request may not be processed before reprocess requests that are submitted later.
  ///
  /// Requests submitted through this method have higher priority than
  /// those submitted through \#setRepeatingRequest or
  /// \#setRepeatingBurst, and will be processed as soon as the current
  /// repeat/repeatBurst processing completes.
  ///
  ///
  /// All capture sessions can be used for capturing images from the camera but only capture
  /// sessions created by
  /// CameraDevice\#createReprocessableCaptureSession createReprocessableCaptureSession
  /// can submit reprocess capture requests. Submitting a reprocess request to a regular capture
  /// session will result in an IllegalArgumentException.
  ///
  ///@param request the settings for this capture
  /// This value must never be {@code null}.
  ///@param listener The callback object to notify once this request has been
  /// processed. If null, no metadata will be produced for this capture,
  /// although image data will still be produced.
  /// This value may be {@code null}.
  ///@param handler the handler on which the listener should be invoked, or
  /// {@code null} to use the current thread's android.os.Looper looper.
  ///
  /// This value may be {@code null}.
  ///@return int A unique capture sequence ID used by
  ///             CaptureCallback\#onCaptureSequenceCompleted.
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if this session is no longer active, either because the session
  ///                               was explicitly closed, a new session has been created
  ///                               or the camera device has been closed.
  ///@throws IllegalArgumentException if the request targets no Surfaces or Surfaces that are not
  ///                                  configured as outputs for this session; or the request
  ///                                  targets a set of Surfaces that cannot be submitted
  ///                                  simultaneously in a reprocessable capture session; or a
  ///                                  reprocess capture request is submitted in a
  ///                                  non-reprocessable capture session; or the reprocess capture
  ///                                  request was created with a TotalCaptureResult from
  ///                                  a different session; or the capture targets a Surface in
  ///                                  the middle of being \#prepare prepared; or the
  ///                                  handler is null, the listener is not null, and the calling
  ///                                  thread has no looper.
  ///@see \#captureBurst
  ///@see \#setRepeatingRequest
  ///@see \#setRepeatingBurst
  ///@see \#abortCaptures
  ///@see CameraDevice\#createReprocessableCaptureSession
  int capture(
          capturerequest_.CaptureRequest request,
          CameraCaptureSession_CaptureCallback listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_capture,
          jni.JniType.intType,
          [request.reference, listener.reference, handler.reference]).integer;

  static final _id_captureSingleRequest = jniAccessors.getMethodIDOf(
      _classRef,
      "captureSingleRequest",
      "(Landroid/hardware/camera2/CaptureRequest;Ljava/util/concurrent/Executor;Landroid/hardware/camera2/CameraCaptureSession\$CaptureCallback;)I");

  /// from: public int captureSingleRequest(android.hardware.camera2.CaptureRequest request, java.util.concurrent.Executor executor, android.hardware.camera2.CameraCaptureSession.CaptureCallback listener)
  ///
  /// Submit a request for an image to be captured by the camera device.
  ///
  ///
  /// The behavior of this method matches that of
  /// \#capture(CaptureRequest, CaptureCallback, Handler),
  /// except that it uses java.util.concurrent.Executor as an argument
  /// instead of android.os.Handler.
  ///
  ///@param request the settings for this capture
  /// This value must never be {@code null}.
  ///@param executor the executor which will be used for invoking the listener.
  /// This value must never be {@code null}.
  /// Callback and listener events are dispatched through this
  ///  *           Executor, providing an easy way to control which thread is
  ///  *           used. To dispatch events through the main thread of your
  ///  *           application, you can use Context\#getMainExecutor(). To
  ///  *           dispatch events through a shared thread pool, you can use
  ///  *           AsyncTask\#THREAD_POOL_EXECUTOR.
  ///@param listener The callback object to notify once this request has been
  /// processed.
  ///
  /// This value must never be {@code null}.
  ///@return int A unique capture sequence ID used by
  ///             CaptureCallback\#onCaptureSequenceCompleted.
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if this session is no longer active, either because the session
  ///                               was explicitly closed, a new session has been created
  ///                               or the camera device has been closed.
  ///@throws IllegalArgumentException if the request targets no Surfaces or Surfaces that are not
  ///                                  configured as outputs for this session; or the request
  ///                                  targets a set of Surfaces that cannot be submitted
  ///                                  simultaneously in a reprocessable capture session; or a
  ///                                  reprocess capture request is submitted in a
  ///                                  non-reprocessable capture session; or the reprocess capture
  ///                                  request was created with a TotalCaptureResult from
  ///                                  a different session; or the capture targets a Surface in
  ///                                  the middle of being \#prepare prepared; or the
  ///                                  executor is null, or the listener is not null.
  ///@see \#captureBurst
  ///@see \#setRepeatingRequest
  ///@see \#setRepeatingBurst
  ///@see \#abortCaptures
  ///@see CameraDevice\#createReprocessableCaptureSession
  int captureSingleRequest(
          capturerequest_.CaptureRequest request,
          jni.JniObject executor,
          CameraCaptureSession_CaptureCallback listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_captureSingleRequest,
          jni.JniType.intType,
          [request.reference, executor.reference, listener.reference]).integer;

  static final _id_captureBurst = jniAccessors.getMethodIDOf(
      _classRef,
      "captureBurst",
      "(Ljava/util/List;Landroid/hardware/camera2/CameraCaptureSession\$CaptureCallback;Landroid/os/Handler;)I");

  /// from: public abstract int captureBurst(java.util.List<android.hardware.camera2.CaptureRequest> requests, android.hardware.camera2.CameraCaptureSession.CaptureCallback listener, android.os.Handler handler)
  ///
  /// Submit a list of requests to be captured in sequence as a burst. The
  /// burst will be captured in the minimum amount of time possible, and will
  /// not be interleaved with requests submitted by other capture or repeat
  /// calls.
  ///
  /// Regular and reprocess requests can be mixed together in a single burst. Regular requests
  /// will be captured in order and reprocess requests will be processed in order, respectively.
  /// However, the processing order between a regular request and a reprocess request is not
  /// specified. Each capture produces one CaptureResult and image buffers for one or more
  /// target android.view.Surface surfaces. The target surfaces (set with
  /// CaptureRequest.Builder\#addTarget) must be a subset of the surfaces provided when
  /// this capture session was created.
  ///
  ///
  /// The main difference between this method and simply calling
  /// \#capture repeatedly is that this method guarantees that no
  /// other requests will be interspersed with the burst.
  ///
  ///
  /// All capture sessions can be used for capturing images from the camera but only capture
  /// sessions created by
  /// CameraDevice\#createReprocessableCaptureSession createReprocessableCaptureSession
  /// can submit reprocess capture requests. Submitting a reprocess request to a regular
  /// capture session will result in an IllegalArgumentException.
  ///
  ///@param requests the list of settings for this burst capture
  /// This value must never be {@code null}.
  ///@param listener The callback object to notify each time one of the
  /// requests in the burst has been processed. If null, no metadata will be
  /// produced for any requests in this burst, although image data will still
  /// be produced.
  /// This value may be {@code null}.
  ///@param handler the handler on which the listener should be invoked, or
  /// {@code null} to use the current thread's android.os.Looper looper.
  ///
  /// This value may be {@code null}.
  ///@return int A unique capture sequence ID used by
  ///             CaptureCallback\#onCaptureSequenceCompleted.
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if this session is no longer active, either because the session
  ///                               was explicitly closed, a new session has been created
  ///                               or the camera device has been closed.
  ///@throws IllegalArgumentException If the requests target no Surfaces, or the requests target
  ///                                  Surfaces not currently configured as outputs; or one of the
  ///                                  requests targets a set of Surfaces that cannot be submitted
  ///                                  simultaneously in a reprocessable capture session; or a
  ///                                  reprocess capture request is submitted in a
  ///                                  non-reprocessable capture session; or one of the reprocess
  ///                                  capture requests was created with a
  ///                                  TotalCaptureResult from a different session; or one
  ///                                  of the captures targets a Surface in the middle of being
  ///                                  \#prepare prepared; or if the handler is null, the
  ///                                  listener is not null, and the calling thread has no looper.
  ///@see \#capture
  ///@see \#setRepeatingRequest
  ///@see \#setRepeatingBurst
  ///@see \#abortCaptures
  int captureBurst(
          jni.JniObject requests,
          CameraCaptureSession_CaptureCallback listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_captureBurst,
          jni.JniType.intType,
          [requests.reference, listener.reference, handler.reference]).integer;

  static final _id_captureBurstRequests = jniAccessors.getMethodIDOf(
      _classRef,
      "captureBurstRequests",
      "(Ljava/util/List;Ljava/util/concurrent/Executor;Landroid/hardware/camera2/CameraCaptureSession\$CaptureCallback;)I");

  /// from: public int captureBurstRequests(java.util.List<android.hardware.camera2.CaptureRequest> requests, java.util.concurrent.Executor executor, android.hardware.camera2.CameraCaptureSession.CaptureCallback listener)
  ///
  /// Submit a list of requests to be captured in sequence as a burst. The
  /// burst will be captured in the minimum amount of time possible, and will
  /// not be interleaved with requests submitted by other capture or repeat
  /// calls.
  ///
  /// The behavior of this method matches that of
  /// \#captureBurst(List, CaptureCallback, Handler),
  /// except that it uses java.util.concurrent.Executor as an argument
  /// instead of android.os.Handler.
  ///
  ///@param requests the list of settings for this burst capture
  /// This value must never be {@code null}.
  ///@param executor the executor which will be used for invoking the listener.
  /// This value must never be {@code null}.
  /// Callback and listener events are dispatched through this
  ///  *           Executor, providing an easy way to control which thread is
  ///  *           used. To dispatch events through the main thread of your
  ///  *           application, you can use Context\#getMainExecutor(). To
  ///  *           dispatch events through a shared thread pool, you can use
  ///  *           AsyncTask\#THREAD_POOL_EXECUTOR.
  ///@param listener The callback object to notify each time one of the
  /// requests in the burst has been processed.
  ///
  /// This value must never be {@code null}.
  ///@return int A unique capture sequence ID used by
  ///             CaptureCallback\#onCaptureSequenceCompleted.
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if this session is no longer active, either because the session
  ///                               was explicitly closed, a new session has been created
  ///                               or the camera device has been closed.
  ///@throws IllegalArgumentException If the requests target no Surfaces, or the requests target
  ///                                  Surfaces not currently configured as outputs; or one of the
  ///                                  requests targets a set of Surfaces that cannot be submitted
  ///                                  simultaneously in a reprocessable capture session; or a
  ///                                  reprocess capture request is submitted in a
  ///                                  non-reprocessable capture session; or one of the reprocess
  ///                                  capture requests was created with a
  ///                                  TotalCaptureResult from a different session; or one
  ///                                  of the captures targets a Surface in the middle of being
  ///                                  \#prepare prepared; or if the executor is null; or if
  ///                                  the listener is null.
  ///@see \#capture
  ///@see \#setRepeatingRequest
  ///@see \#setRepeatingBurst
  ///@see \#abortCaptures
  int captureBurstRequests(jni.JniObject requests, jni.JniObject executor,
          CameraCaptureSession_CaptureCallback listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_captureBurstRequests,
          jni.JniType.intType,
          [requests.reference, executor.reference, listener.reference]).integer;

  static final _id_setRepeatingRequest = jniAccessors.getMethodIDOf(
      _classRef,
      "setRepeatingRequest",
      "(Landroid/hardware/camera2/CaptureRequest;Landroid/hardware/camera2/CameraCaptureSession\$CaptureCallback;Landroid/os/Handler;)I");

  /// from: public abstract int setRepeatingRequest(android.hardware.camera2.CaptureRequest request, android.hardware.camera2.CameraCaptureSession.CaptureCallback listener, android.os.Handler handler)
  ///
  /// Request endlessly repeating capture of images by this capture session.
  ///
  /// With this method, the camera device will continually capture images
  /// using the settings in the provided CaptureRequest, at the maximum
  /// rate possible.
  ///
  ///
  /// Repeating requests are a simple way for an application to maintain a
  /// preview or other continuous stream of frames, without having to
  /// continually submit identical requests through \#capture.
  ///
  ///
  /// Repeat requests have lower priority than those submitted
  /// through \#capture or \#captureBurst, so if
  /// \#capture is called when a repeating request is active, the
  /// capture request will be processed before any further repeating
  /// requests are processed.
  ///
  /// To stop the repeating capture, call \#stopRepeating. Calling
  /// \#abortCaptures will also clear the request.
  ///
  ///
  /// Calling this method will replace any earlier repeating request or
  /// burst set up by this method or \#setRepeatingBurst, although any
  /// in-progress burst will be completed before the new repeat request will be
  /// used.
  ///
  ///
  /// This method does not support reprocess capture requests because each reprocess
  /// CaptureRequest must be created from the TotalCaptureResult that matches
  /// the input image to be reprocessed. This is either the TotalCaptureResult of capture
  /// that is sent for reprocessing, or one of the TotalCaptureResult TotalCaptureResults
  /// of a set of captures, when data from the whole set is combined by the application into a
  /// single reprocess input image. The request must be capturing images from the camera. If a
  /// reprocess capture request is submitted, this method will throw IllegalArgumentException.
  ///
  ///@param request the request to repeat indefinitely
  /// This value must never be {@code null}.
  ///@param listener The callback object to notify every time the
  /// request finishes processing. If null, no metadata will be
  /// produced for this stream of requests, although image data will
  /// still be produced.
  /// This value may be {@code null}.
  ///@param handler the handler on which the listener should be invoked, or
  /// {@code null} to use the current thread's android.os.Looper looper.
  ///
  /// This value may be {@code null}.
  ///@return int A unique capture sequence ID used by
  ///             CaptureCallback\#onCaptureSequenceCompleted.
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if this session is no longer active, either because the session
  ///                               was explicitly closed, a new session has been created
  ///                               or the camera device has been closed.
  ///@throws IllegalArgumentException If the request references no Surfaces or references Surfaces
  ///                                  that are not currently configured as outputs; or the request
  ///                                  is a reprocess capture request; or the capture targets a
  ///                                  Surface in the middle of being \#prepare prepared; or
  ///                                  the handler is null, the listener is not null, and the
  ///                                  calling thread has no looper; or no requests were passed in.
  ///@see \#capture
  ///@see \#captureBurst
  ///@see \#setRepeatingBurst
  ///@see \#stopRepeating
  ///@see \#abortCaptures
  int setRepeatingRequest(
          capturerequest_.CaptureRequest request,
          CameraCaptureSession_CaptureCallback listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setRepeatingRequest,
          jni.JniType.intType,
          [request.reference, listener.reference, handler.reference]).integer;

  static final _id_setSingleRepeatingRequest = jniAccessors.getMethodIDOf(
      _classRef,
      "setSingleRepeatingRequest",
      "(Landroid/hardware/camera2/CaptureRequest;Ljava/util/concurrent/Executor;Landroid/hardware/camera2/CameraCaptureSession\$CaptureCallback;)I");

  /// from: public int setSingleRepeatingRequest(android.hardware.camera2.CaptureRequest request, java.util.concurrent.Executor executor, android.hardware.camera2.CameraCaptureSession.CaptureCallback listener)
  ///
  /// Request endlessly repeating capture of images by this capture session.
  ///
  /// The behavior of this method matches that of
  /// \#setRepeatingRequest(CaptureRequest, CaptureCallback, Handler),
  /// except that it uses java.util.concurrent.Executor as an argument
  /// instead of android.os.Handler.
  ///
  ///@param request the request to repeat indefinitely
  /// This value must never be {@code null}.
  ///@param executor the executor which will be used for invoking the listener.
  /// This value must never be {@code null}.
  /// Callback and listener events are dispatched through this
  ///  *           Executor, providing an easy way to control which thread is
  ///  *           used. To dispatch events through the main thread of your
  ///  *           application, you can use Context\#getMainExecutor(). To
  ///  *           dispatch events through a shared thread pool, you can use
  ///  *           AsyncTask\#THREAD_POOL_EXECUTOR.
  ///@param listener The callback object to notify every time the
  /// request finishes processing.
  ///
  /// This value must never be {@code null}.
  ///@return int A unique capture sequence ID used by
  ///             CaptureCallback\#onCaptureSequenceCompleted.
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if this session is no longer active, either because the session
  ///                               was explicitly closed, a new session has been created
  ///                               or the camera device has been closed.
  ///@throws IllegalArgumentException If the request references no Surfaces or references Surfaces
  ///                                  that are not currently configured as outputs; or the request
  ///                                  is a reprocess capture request; or the capture targets a
  ///                                  Surface in the middle of being \#prepare prepared; or
  ///                                  the executor is null; or the listener is null.
  ///@see \#capture
  ///@see \#captureBurst
  ///@see \#setRepeatingBurst
  ///@see \#stopRepeating
  ///@see \#abortCaptures
  int setSingleRepeatingRequest(
          capturerequest_.CaptureRequest request,
          jni.JniObject executor,
          CameraCaptureSession_CaptureCallback listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setSingleRepeatingRequest,
          jni.JniType.intType,
          [request.reference, executor.reference, listener.reference]).integer;

  static final _id_setRepeatingBurst = jniAccessors.getMethodIDOf(
      _classRef,
      "setRepeatingBurst",
      "(Ljava/util/List;Landroid/hardware/camera2/CameraCaptureSession\$CaptureCallback;Landroid/os/Handler;)I");

  /// from: public abstract int setRepeatingBurst(java.util.List<android.hardware.camera2.CaptureRequest> requests, android.hardware.camera2.CameraCaptureSession.CaptureCallback listener, android.os.Handler handler)
  ///
  /// Request endlessly repeating capture of a sequence of images by this
  /// capture session.
  ///
  ///
  /// With this method, the camera device will continually capture images,
  /// cycling through the settings in the provided list of
  /// CaptureRequest CaptureRequests, at the maximum rate possible.
  ///
  ///
  /// If a request is submitted through \#capture or
  /// \#captureBurst, the current repetition of the request list will be
  /// completed before the higher-priority request is handled. This guarantees
  /// that the application always receives a complete repeat burst captured in
  /// minimal time, instead of bursts interleaved with higher-priority
  /// captures, or incomplete captures.
  ///
  ///
  /// Repeating burst requests are a simple way for an application to
  /// maintain a preview or other continuous stream of frames where each
  /// request is different in a predicatable way, without having to continually
  /// submit requests through \#captureBurst.
  ///
  ///
  /// To stop the repeating capture, call \#stopRepeating. Any
  /// ongoing burst will still be completed, however. Calling
  /// \#abortCaptures will also clear the request.
  ///
  ///
  /// Calling this method will replace a previously-set repeating request or
  /// burst set up by this method or \#setRepeatingRequest, although any
  /// in-progress burst will be completed before the new repeat burst will be
  /// used.
  ///
  ///
  /// This method does not support reprocess capture requests because each reprocess
  /// CaptureRequest must be created from the TotalCaptureResult that matches
  /// the input image to be reprocessed. This is either the TotalCaptureResult of capture
  /// that is sent for reprocessing, or one of the TotalCaptureResult TotalCaptureResults
  /// of a set of captures, when data from the whole set is combined by the application into a
  /// single reprocess input image. The request must be capturing images from the camera. If a
  /// reprocess capture request is submitted, this method will throw IllegalArgumentException.
  ///
  ///@param requests the list of requests to cycle through indefinitely
  /// This value must never be {@code null}.
  ///@param listener The callback object to notify each time one of the
  /// requests in the repeating bursts has finished processing. If null, no
  /// metadata will be produced for this stream of requests, although image
  /// data will still be produced.
  /// This value may be {@code null}.
  ///@param handler the handler on which the listener should be invoked, or
  /// {@code null} to use the current thread's android.os.Looper looper.
  ///
  /// This value may be {@code null}.
  ///@return int A unique capture sequence ID used by
  ///             CaptureCallback\#onCaptureSequenceCompleted.
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if this session is no longer active, either because the session
  ///                               was explicitly closed, a new session has been created
  ///                               or the camera device has been closed.
  ///@throws IllegalArgumentException If the requests reference no Surfaces or reference Surfaces
  ///                                  not currently configured as outputs; or one of the requests
  ///                                  is a reprocess capture request; or one of the captures
  ///                                  targets a Surface in the middle of being
  ///                                  \#prepare prepared; or the handler is null, the
  ///                                  listener is not null, and the calling thread has no looper;
  ///                                  or no requests were passed in.
  ///@see \#capture
  ///@see \#captureBurst
  ///@see \#setRepeatingRequest
  ///@see \#stopRepeating
  ///@see \#abortCaptures
  int setRepeatingBurst(
          jni.JniObject requests,
          CameraCaptureSession_CaptureCallback listener,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setRepeatingBurst,
          jni.JniType.intType,
          [requests.reference, listener.reference, handler.reference]).integer;

  static final _id_setRepeatingBurstRequests = jniAccessors.getMethodIDOf(
      _classRef,
      "setRepeatingBurstRequests",
      "(Ljava/util/List;Ljava/util/concurrent/Executor;Landroid/hardware/camera2/CameraCaptureSession\$CaptureCallback;)I");

  /// from: public int setRepeatingBurstRequests(java.util.List<android.hardware.camera2.CaptureRequest> requests, java.util.concurrent.Executor executor, android.hardware.camera2.CameraCaptureSession.CaptureCallback listener)
  ///
  /// Request endlessly repeating capture of a sequence of images by this
  /// capture session.
  ///
  ///
  /// The behavior of this method matches that of
  /// \#setRepeatingBurst(List, CaptureCallback, Handler),
  /// except that it uses java.util.concurrent.Executor as an argument
  /// instead of android.os.Handler.
  ///
  ///@param requests the list of requests to cycle through indefinitely
  /// This value must never be {@code null}.
  ///@param executor the executor which will be used for invoking the listener.
  /// This value must never be {@code null}.
  /// Callback and listener events are dispatched through this
  ///  *           Executor, providing an easy way to control which thread is
  ///  *           used. To dispatch events through the main thread of your
  ///  *           application, you can use Context\#getMainExecutor(). To
  ///  *           dispatch events through a shared thread pool, you can use
  ///  *           AsyncTask\#THREAD_POOL_EXECUTOR.
  ///@param listener The callback object to notify each time one of the
  /// requests in the repeating bursts has finished processing.
  ///
  /// This value must never be {@code null}.
  ///@return int A unique capture sequence ID used by
  ///             CaptureCallback\#onCaptureSequenceCompleted.
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if this session is no longer active, either because the session
  ///                               was explicitly closed, a new session has been created
  ///                               or the camera device has been closed.
  ///@throws IllegalArgumentException If the requests reference no Surfaces or reference Surfaces
  ///                                  not currently configured as outputs; or one of the requests
  ///                                  is a reprocess capture request; or one of the captures
  ///                                  targets a Surface in the middle of being
  ///                                  \#prepare prepared; or the executor is null; or the
  ///                                  listener is null.
  ///@see \#capture
  ///@see \#captureBurst
  ///@see \#setRepeatingRequest
  ///@see \#stopRepeating
  ///@see \#abortCaptures
  int setRepeatingBurstRequests(jni.JniObject requests, jni.JniObject executor,
          CameraCaptureSession_CaptureCallback listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setRepeatingBurstRequests,
          jni.JniType.intType,
          [requests.reference, executor.reference, listener.reference]).integer;

  static final _id_stopRepeating =
      jniAccessors.getMethodIDOf(_classRef, "stopRepeating", "()V");

  /// from: public abstract void stopRepeating()
  ///
  /// Cancel any ongoing repeating capture set by either
  /// \#setRepeatingRequest setRepeatingRequest or
  /// \#setRepeatingBurst. Has no effect on requests submitted through
  /// \#capture capture or \#captureBurst captureBurst.
  ///
  ///
  /// Any currently in-flight captures will still complete, as will any burst that is
  /// mid-capture. To ensure that the device has finished processing all of its capture requests
  /// and is in ready state, wait for the StateCallback\#onReady callback after
  /// calling this method.
  ///
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if this session is no longer active, either because the session
  ///                               was explicitly closed, a new session has been created
  ///                               or the camera device has been closed.
  ///@see \#setRepeatingRequest
  ///@see \#setRepeatingBurst
  ///@see StateCallback\#onIdle
  void stopRepeating() => jniAccessors.callMethodWithArgs(
      reference, _id_stopRepeating, jni.JniType.voidType, []).check();

  static final _id_abortCaptures =
      jniAccessors.getMethodIDOf(_classRef, "abortCaptures", "()V");

  /// from: public abstract void abortCaptures()
  ///
  /// Discard all captures currently pending and in-progress as fast as possible.
  ///
  /// The camera device will discard all of its current work as fast as possible. Some in-flight
  /// captures may complete successfully and call CaptureCallback\#onCaptureCompleted, while
  /// others will trigger their CaptureCallback\#onCaptureFailed callbacks. If a repeating
  /// request or a repeating burst is set, it will be cleared.
  ///
  ///
  /// This method is the fastest way to switch the camera device to a new session with
  /// CameraDevice\#createCaptureSession or
  /// CameraDevice\#createReprocessableCaptureSession, at the cost of discarding in-progress
  /// work. It must be called before the new session is created. Once all pending requests are
  /// either completed or thrown away, the StateCallback\#onReady callback will be called,
  /// if the session has not been closed. Otherwise, the StateCallback\#onClosed
  /// callback will be fired when a new session is created by the camera device.
  ///
  ///
  /// Cancelling will introduce at least a brief pause in the stream of data from the camera
  /// device, since once the camera device is emptied, the first new request has to make it through
  /// the entire camera pipeline before new output buffers are produced.
  ///
  ///
  /// This means that using {@code abortCaptures()} to simply remove pending requests is not
  /// recommended; it's best used for quickly switching output configurations, or for cancelling
  /// long in-progress requests (such as a multi-second capture).
  ///
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error
  ///@throws IllegalStateException if this session is no longer active, either because the session
  ///                               was explicitly closed, a new session has been created
  ///                               or the camera device has been closed.
  ///@see \#setRepeatingRequest
  ///@see \#setRepeatingBurst
  ///@see CameraDevice\#createCaptureSession
  ///@see CameraDevice\#createReprocessableCaptureSession
  void abortCaptures() => jniAccessors.callMethodWithArgs(
      reference, _id_abortCaptures, jni.JniType.voidType, []).check();

  static final _id_isReprocessable =
      jniAccessors.getMethodIDOf(_classRef, "isReprocessable", "()Z");

  /// from: public abstract boolean isReprocessable()
  ///
  /// Return if the application can submit reprocess capture requests with this camera capture
  /// session.
  ///@return {@code true} if the application can submit reprocess capture requests with this
  ///         camera capture session. {@code false} otherwise.
  ///@see CameraDevice\#createReprocessableCaptureSession
  bool isReprocessable() => jniAccessors.callMethodWithArgs(
      reference, _id_isReprocessable, jni.JniType.booleanType, []).boolean;

  static final _id_getInputSurface = jniAccessors.getMethodIDOf(
      _classRef, "getInputSurface", "()Landroid/view/Surface;");

  /// from: public abstract android.view.Surface getInputSurface()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the input Surface associated with a reprocessable capture session.
  ///
  /// Each reprocessable capture session has an input Surface where the reprocess
  /// capture requests get the input images from, rather than the camera device. The application
  /// can create a android.media.ImageWriter ImageWriter with this input Surface
  /// and use it to provide input images for reprocess capture requests. When the reprocessable
  /// capture session is closed, the input Surface is abandoned and becomes invalid.
  ///
  ///@return The Surface where reprocessing capture requests get the input images from. If
  ///         this is not a reprocess capture session, {@code null} will be returned.
  ///@see CameraDevice\#createReprocessableCaptureSession
  ///@see android.media.ImageWriter
  ///@see android.media.ImageReader
  surface_.Surface getInputSurface() =>
      surface_.Surface.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getInputSurface, jni.JniType.objectType, []).object);

  static final _id_updateOutputConfiguration = jniAccessors.getMethodIDOf(
      _classRef,
      "updateOutputConfiguration",
      "(Landroid/hardware/camera2/params/OutputConfiguration;)V");

  /// from: public void updateOutputConfiguration(android.hardware.camera2.params.OutputConfiguration config)
  ///
  /// Update OutputConfiguration after configuration finalization see
  /// \#finalizeOutputConfigurations.
  ///
  /// Any OutputConfiguration that has been modified via calls to
  /// OutputConfiguration\#addSurface or OutputConfiguration\#removeSurface must be
  /// updated. After the update call returns without throwing exceptions any newly added surfaces
  /// can be referenced in subsequent capture requests.
  ///
  ///
  /// Surfaces that get removed must not be part of any active repeating or single/burst
  /// request or have any pending results. Consider updating any repeating requests first via
  /// \#setRepeatingRequest or \#setRepeatingBurst and then wait for the last frame
  /// number when the sequence completes CaptureCallback\#onCaptureSequenceCompleted
  /// before calling updateOutputConfiguration to remove a previously active Surface.
  ///
  ///
  /// Surfaces that get added must not be part of any other registered
  /// OutputConfiguration.
  ///
  ///@param config Modified output configuration.
  ///@throws CameraAccessException if the camera device is no longer connected or has
  ///                               encountered a fatal error.
  ///@throws IllegalArgumentException if an attempt was made to add a Surface already
  ///                               in use by another buffer-producing API, such as MediaCodec or
  ///                               a different camera device or OutputConfiguration; or
  ///                               new surfaces are not compatible (see
  ///                               OutputConfiguration\#enableSurfaceSharing); or a
  ///                               Surface that was removed from the modified
  ///                               OutputConfiguration still has pending requests.
  ///@throws IllegalStateException if this session is no longer active, either because the session
  ///                               was explicitly closed, a new session has been created
  ///                               or the camera device has been closed.
  void updateOutputConfiguration(
          outputconfiguration_.OutputConfiguration config) =>
      jniAccessors.callMethodWithArgs(reference, _id_updateOutputConfiguration,
          jni.JniType.voidType, [config.reference]).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public abstract void close()
  ///
  /// Close this capture session asynchronously.
  ///
  /// Closing a session frees up the target output Surfaces of the session for reuse with either
  /// a new session, or to other APIs that can draw to Surfaces.
  ///
  ///
  /// Note that creating a new capture session with CameraDevice\#createCaptureSession
  /// will close any existing capture session automatically, and call the older session listener's
  /// StateCallback\#onClosed callback. Using CameraDevice\#createCaptureSession
  /// directly without closing is the recommended approach for quickly switching to a new session,
  /// since unchanged target outputs can be reused more efficiently.
  ///
  ///
  /// Once a session is closed, all methods on it will throw an IllegalStateException, and any
  /// repeating requests or bursts are stopped (as if \#stopRepeating() was called).
  /// However, any in-progress capture requests submitted to the session will be completed as
  /// normal; once all captures have completed and the session has been torn down,
  /// StateCallback\#onClosed will be called.
  ///
  ///
  /// Closing a session is idempotent; closing more than once has no effect.
  ///
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();
}

/// from: android.hardware.camera2.CameraCaptureSession$StateCallback
///
/// A callback object for receiving updates about the state of a camera capture session.
class CameraCaptureSession_StateCallback extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/hardware/camera2/CameraCaptureSession\$StateCallback");
  CameraCaptureSession_StateCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  CameraCaptureSession_StateCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onConfigured = jniAccessors.getMethodIDOf(_classRef,
      "onConfigured", "(Landroid/hardware/camera2/CameraCaptureSession;)V");

  /// from: public abstract void onConfigured(android.hardware.camera2.CameraCaptureSession session)
  ///
  /// This method is called when the camera device has finished configuring itself, and the
  /// session can start processing capture requests.
  ///
  /// If there are capture requests already queued with the session, they will start
  /// processing once this callback is invoked, and the session will call \#onActive
  /// right after this callback is invoked.
  ///
  ///
  /// If no capture requests have been submitted, then the session will invoke
  /// \#onReady right after this callback.
  ///
  ///
  /// If the camera device configuration fails, then \#onConfigureFailed will
  /// be invoked instead of this callback.
  ///
  ///@param session the session returned by CameraDevice\#createCaptureSession
  ///
  /// This value must never be {@code null}.
  void onConfigured(CameraCaptureSession session) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConfigured,
          jni.JniType.voidType, [session.reference]).check();

  static final _id_onConfigureFailed = jniAccessors.getMethodIDOf(
      _classRef,
      "onConfigureFailed",
      "(Landroid/hardware/camera2/CameraCaptureSession;)V");

  /// from: public abstract void onConfigureFailed(android.hardware.camera2.CameraCaptureSession session)
  ///
  /// This method is called if the session cannot be configured as requested.
  ///
  /// This can happen if the set of requested outputs contains unsupported sizes,
  /// or too many outputs are requested at once.
  ///
  ///
  /// The session is considered to be closed, and all methods called on it after this
  /// callback is invoked will throw an IllegalStateException. Any capture requests submitted
  /// to the session prior to this callback will be discarded and will not produce any
  /// callbacks on their listeners.
  ///
  ///@param session the session returned by CameraDevice\#createCaptureSession
  ///
  /// This value must never be {@code null}.
  void onConfigureFailed(CameraCaptureSession session) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConfigureFailed,
          jni.JniType.voidType, [session.reference]).check();

  static final _id_onReady = jniAccessors.getMethodIDOf(_classRef, "onReady",
      "(Landroid/hardware/camera2/CameraCaptureSession;)V");

  /// from: public void onReady(android.hardware.camera2.CameraCaptureSession session)
  ///
  /// This method is called every time the session has no more capture requests to process.
  ///
  /// During the creation of a new session, this callback is invoked right after
  /// \#onConfigured if no capture requests were submitted to the session prior to it
  /// completing configuration.
  ///
  ///
  /// Otherwise, this callback will be invoked any time the session finishes processing
  /// all of its active capture requests, and no repeating request or burst is set up.
  ///
  ///@param session the session returned by CameraDevice\#createCaptureSession
  ///
  ///
  /// This value must never be {@code null}.
  void onReady(CameraCaptureSession session) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onReady,
      jni.JniType.voidType,
      [session.reference]).check();

  static final _id_onActive = jniAccessors.getMethodIDOf(_classRef, "onActive",
      "(Landroid/hardware/camera2/CameraCaptureSession;)V");

  /// from: public void onActive(android.hardware.camera2.CameraCaptureSession session)
  ///
  /// This method is called when the session starts actively processing capture requests.
  ///
  /// If capture requests are submitted prior to \#onConfigured being called,
  /// then the session will start processing those requests immediately after the callback,
  /// and this method will be immediately called after \#onConfigured.
  ///
  /// If the session runs out of capture requests to process and calls \#onReady,
  /// then this callback will be invoked again once new requests are submitted for capture.
  ///
  ///@param session the session returned by CameraDevice\#createCaptureSession
  ///
  /// This value must never be {@code null}.
  void onActive(CameraCaptureSession session) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActive,
          jni.JniType.voidType, [session.reference]).check();

  static final _id_onCaptureQueueEmpty = jniAccessors.getMethodIDOf(
      _classRef,
      "onCaptureQueueEmpty",
      "(Landroid/hardware/camera2/CameraCaptureSession;)V");

  /// from: public void onCaptureQueueEmpty(android.hardware.camera2.CameraCaptureSession session)
  ///
  /// This method is called when camera device's input capture queue becomes empty,
  /// and is ready to accept the next request.
  ///
  /// Pending capture requests exist in one of two queues: the in-flight queue where requests
  /// are already in different stages of processing pipeline, and an input queue where requests
  /// wait to enter the in-flight queue. The input queue is needed because more requests may be
  /// submitted than the current camera device pipeline depth.
  ///
  ///
  /// This callback is fired when the input queue becomes empty, and the camera device may
  /// have to fall back to the repeating request if set, or completely skip the next frame from
  /// the sensor. This can cause glitches to camera preview output, for example. This callback
  /// will only fire after requests queued by capture() or captureBurst(), not after a
  /// repeating request or burst enters the in-flight queue. For example, in the common case
  /// of a repeating request and a single-shot JPEG capture, this callback only fires when the
  /// JPEG request has entered the in-flight queue for capture.
  ///
  ///
  /// By only sending a new \#capture or \#captureBurst when the input
  /// queue is empty, pipeline latency can be minimized.
  ///
  ///
  /// This callback is not fired when the session is first created. It is different from
  /// \#onReady, which is fired when all requests in both queues have been processed.
  ///
  ///@param session The session returned by CameraDevice\#createCaptureSession
  ///
  /// This value must never be {@code null}.
  void onCaptureQueueEmpty(CameraCaptureSession session) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCaptureQueueEmpty,
          jni.JniType.voidType, [session.reference]).check();

  static final _id_onClosed = jniAccessors.getMethodIDOf(_classRef, "onClosed",
      "(Landroid/hardware/camera2/CameraCaptureSession;)V");

  /// from: public void onClosed(android.hardware.camera2.CameraCaptureSession session)
  ///
  /// This method is called when the session is closed.
  ///
  /// A session is closed when a new session is created by the parent camera device,
  /// or when the parent camera device is closed (either by the user closing the device,
  /// or due to a camera device disconnection or fatal error).
  ///
  ///
  /// Once a session is closed, all methods on it will throw an IllegalStateException, and
  /// any repeating requests or bursts are stopped (as if \#stopRepeating() was called).
  /// However, any in-progress capture requests submitted to the session will be completed
  /// as normal.
  ///
  ///@param session the session returned by CameraDevice\#createCaptureSession
  ///
  /// This value must never be {@code null}.
  void onClosed(CameraCaptureSession session) =>
      jniAccessors.callMethodWithArgs(reference, _id_onClosed,
          jni.JniType.voidType, [session.reference]).check();

  static final _id_onSurfacePrepared = jniAccessors.getMethodIDOf(
      _classRef,
      "onSurfacePrepared",
      "(Landroid/hardware/camera2/CameraCaptureSession;Landroid/view/Surface;)V");

  /// from: public void onSurfacePrepared(android.hardware.camera2.CameraCaptureSession session, android.view.Surface surface)
  ///
  /// This method is called when the buffer pre-allocation for an output Surface is complete.
  ///
  /// Buffer pre-allocation for an output Surface is started by the \#prepare call.
  /// While allocation is underway, the Surface must not be used as a capture target.
  /// Once this callback fires, the output Surface provided can again be used as a target for
  /// a capture request.
  ///
  ///
  /// In case of a error during pre-allocation (such as running out of suitable memory),
  /// this callback is still invoked after the error is encountered, though some buffers may
  /// not have been successfully pre-allocated.
  ///
  ///@param session the session returned by CameraDevice\#createCaptureSession
  /// This value must never be {@code null}.
  ///@param surface the Surface that was used with the \#prepare call.
  ///
  /// This value must never be {@code null}.
  void onSurfacePrepared(
          CameraCaptureSession session, surface_.Surface surface) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSurfacePrepared,
          jni.JniType.voidType, [session.reference, surface.reference]).check();
}

/// from: android.hardware.camera2.CameraCaptureSession$CaptureCallback
///
/// A callback object for tracking the progress of a CaptureRequest submitted to the
/// camera device.
///
///
/// This callback is invoked when a request triggers a capture to start,
/// and when the capture is complete. In case on an error capturing an image,
/// the error method is triggered instead of the completion method.
///
///@see \#capture
///@see \#captureBurst
///@see \#setRepeatingRequest
///@see \#setRepeatingBurst
class CameraCaptureSession_CaptureCallback extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/hardware/camera2/CameraCaptureSession\$CaptureCallback");
  CameraCaptureSession_CaptureCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  CameraCaptureSession_CaptureCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onCaptureStarted = jniAccessors.getMethodIDOf(
      _classRef,
      "onCaptureStarted",
      "(Landroid/hardware/camera2/CameraCaptureSession;Landroid/hardware/camera2/CaptureRequest;JJ)V");

  /// from: public void onCaptureStarted(android.hardware.camera2.CameraCaptureSession session, android.hardware.camera2.CaptureRequest request, long timestamp, long frameNumber)
  ///
  /// This method is called when the camera device has started capturing
  /// the output image for the request, at the beginning of image exposure, or
  /// when the camera device has started processing an input image for a reprocess
  /// request.
  ///
  /// For a regular capture request, this callback is invoked right as
  /// the capture of a frame begins, so it is the most appropriate time
  /// for playing a shutter sound, or triggering UI indicators of capture.
  ///
  ///
  /// The request that is being used for this capture is provided, along
  /// with the actual timestamp for the start of exposure. For a reprocess
  /// request, this timestamp will be the input image's start of exposure
  /// which matches CaptureResult\#SENSOR_TIMESTAMP the result timestamp field
  /// of the TotalCaptureResult that was used to
  /// CameraDevice\#createReprocessCaptureRequest create the reprocess request.
  /// This timestamp matches the timestamps that will be
  /// included in CaptureResult\#SENSOR_TIMESTAMP the result timestamp field,
  /// and in the buffers sent to each output Surface. These buffer
  /// timestamps are accessible through, for example,
  /// android.media.Image\#getTimestamp() Image.getTimestamp() or
  /// android.graphics.SurfaceTexture\#getTimestamp().
  /// The frame number included is equal to the frame number that will be included in
  /// CaptureResult\#getFrameNumber.
  ///
  ///
  /// For the simplest way to play a shutter sound camera shutter or a
  /// video recording start/stop sound, see the
  /// android.media.MediaActionSound class.
  ///
  ///
  /// The default implementation of this method does nothing.
  ///
  ///@param session the session returned by CameraDevice\#createCaptureSession
  /// This value must never be {@code null}.
  ///@param request the request for the capture that just begun
  /// This value must never be {@code null}.
  ///@param timestamp the timestamp at start of capture for a regular request, or
  ///                  the timestamp at the input image's start of capture for a
  ///                  reprocess request, in nanoseconds.
  ///@param frameNumber the frame number for this capture
  ///@see android.media.MediaActionSound
  void onCaptureStarted(
          CameraCaptureSession session,
          capturerequest_.CaptureRequest request,
          int timestamp,
          int frameNumber) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onCaptureStarted, jni.JniType.voidType, [
        session.reference,
        request.reference,
        timestamp,
        frameNumber
      ]).check();

  static final _id_onCaptureProgressed = jniAccessors.getMethodIDOf(
      _classRef,
      "onCaptureProgressed",
      "(Landroid/hardware/camera2/CameraCaptureSession;Landroid/hardware/camera2/CaptureRequest;Landroid/hardware/camera2/CaptureResult;)V");

  /// from: public void onCaptureProgressed(android.hardware.camera2.CameraCaptureSession session, android.hardware.camera2.CaptureRequest request, android.hardware.camera2.CaptureResult partialResult)
  ///
  /// This method is called when an image capture makes partial forward progress; some
  /// (but not all) results from an image capture are available.
  ///
  /// The result provided here will contain some subset of the fields of
  /// a full result. Multiple \#onCaptureProgressed calls may happen per
  /// capture; a given result field will only be present in one partial
  /// capture at most. The final \#onCaptureCompleted call will always
  /// contain all the fields (in particular, the union of all the fields of all
  /// the partial results composing the total result).
  ///
  ///
  /// For each request, some result data might be available earlier than others. The typical
  /// delay between each partial result (per request) is a single frame interval.
  /// For performance-oriented use-cases, applications should query the metadata they need
  /// to make forward progress from the partial results and avoid waiting for the completed
  /// result.
  ///
  ///
  /// For a particular request, \#onCaptureProgressed may happen before or after
  /// \#onCaptureStarted.
  ///
  ///
  /// Each request will generate at least {@code 1} partial results, and at most
  /// CameraCharacteristics\#REQUEST_PARTIAL_RESULT_COUNT partial results.
  ///
  ///
  /// Depending on the request settings, the number of partial results per request
  /// will vary, although typically the partial count could be the same as long as the
  /// camera device subsystems enabled stay the same.
  ///
  ///
  /// The default implementation of this method does nothing.
  ///
  ///@param session the session returned by CameraDevice\#createCaptureSession
  /// This value must never be {@code null}.
  ///@param request The request that was given to the CameraDevice
  /// This value must never be {@code null}.
  ///@param partialResult The partial output metadata from the capture, which
  /// includes a subset of the TotalCaptureResult fields.
  ///
  /// This value must never be {@code null}.
  ///@see \#capture
  ///@see \#captureBurst
  ///@see \#setRepeatingRequest
  ///@see \#setRepeatingBurst
  void onCaptureProgressed(
          CameraCaptureSession session,
          capturerequest_.CaptureRequest request,
          captureresult_.CaptureResult partialResult) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onCaptureProgressed, jni.JniType.voidType, [
        session.reference,
        request.reference,
        partialResult.reference
      ]).check();

  static final _id_onCaptureCompleted = jniAccessors.getMethodIDOf(
      _classRef,
      "onCaptureCompleted",
      "(Landroid/hardware/camera2/CameraCaptureSession;Landroid/hardware/camera2/CaptureRequest;Landroid/hardware/camera2/TotalCaptureResult;)V");

  /// from: public void onCaptureCompleted(android.hardware.camera2.CameraCaptureSession session, android.hardware.camera2.CaptureRequest request, android.hardware.camera2.TotalCaptureResult result)
  ///
  /// This method is called when an image capture has fully completed and all the
  /// result metadata is available.
  ///
  /// This callback will always fire after the last \#onCaptureProgressed;
  /// in other words, no more partial results will be delivered once the completed result
  /// is available.
  ///
  ///
  /// For performance-intensive use-cases where latency is a factor, consider
  /// using \#onCaptureProgressed instead.
  ///
  ///
  /// The default implementation of this method does nothing.
  ///
  ///@param session the session returned by CameraDevice\#createCaptureSession
  /// This value must never be {@code null}.
  ///@param request The request that was given to the CameraDevice
  /// This value must never be {@code null}.
  ///@param result The total output metadata from the capture, including the
  /// final capture parameters and the state of the camera system during
  /// capture.
  ///
  /// This value must never be {@code null}.
  ///@see \#capture
  ///@see \#captureBurst
  ///@see \#setRepeatingRequest
  ///@see \#setRepeatingBurst
  void onCaptureCompleted(
          CameraCaptureSession session,
          capturerequest_.CaptureRequest request,
          totalcaptureresult_.TotalCaptureResult result) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCaptureCompleted,
          jni.JniType.voidType,
          [session.reference, request.reference, result.reference]).check();

  static final _id_onCaptureFailed = jniAccessors.getMethodIDOf(
      _classRef,
      "onCaptureFailed",
      "(Landroid/hardware/camera2/CameraCaptureSession;Landroid/hardware/camera2/CaptureRequest;Landroid/hardware/camera2/CaptureFailure;)V");

  /// from: public void onCaptureFailed(android.hardware.camera2.CameraCaptureSession session, android.hardware.camera2.CaptureRequest request, android.hardware.camera2.CaptureFailure failure)
  ///
  /// This method is called instead of \#onCaptureCompleted when the
  /// camera device failed to produce a CaptureResult for the
  /// request.
  ///
  /// Other requests are unaffected, and some or all image buffers from
  /// the capture may have been pushed to their respective output
  /// streams.
  ///
  ///
  /// The default implementation of this method does nothing.
  ///
  ///@param session The session returned by CameraDevice\#createCaptureSession
  /// This value must never be {@code null}.
  ///@param request The request that was given to the CameraDevice
  /// This value must never be {@code null}.
  ///@param failure The output failure from the capture, including the failure reason
  ///            and the frame number.
  ///
  /// This value must never be {@code null}.
  ///@see \#capture
  ///@see \#captureBurst
  ///@see \#setRepeatingRequest
  ///@see \#setRepeatingBurst
  void onCaptureFailed(
          CameraCaptureSession session,
          capturerequest_.CaptureRequest request,
          capturefailure_.CaptureFailure failure) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCaptureFailed,
          jni.JniType.voidType,
          [session.reference, request.reference, failure.reference]).check();

  static final _id_onCaptureSequenceCompleted = jniAccessors.getMethodIDOf(
      _classRef,
      "onCaptureSequenceCompleted",
      "(Landroid/hardware/camera2/CameraCaptureSession;IJ)V");

  /// from: public void onCaptureSequenceCompleted(android.hardware.camera2.CameraCaptureSession session, int sequenceId, long frameNumber)
  ///
  /// This method is called independently of the others in CaptureCallback,
  /// when a capture sequence finishes and all CaptureResult
  /// or CaptureFailure for it have been returned via this listener.
  ///
  /// In total, there will be at least one result/failure returned by this listener
  /// before this callback is invoked. If the capture sequence is aborted before any
  /// requests have been processed, \#onCaptureSequenceAborted is invoked instead.
  ///
  ///
  /// The default implementation does nothing.
  ///
  ///@param session The session returned by CameraDevice\#createCaptureSession
  /// This value must never be {@code null}.
  ///@param sequenceId A sequence ID returned by the \#capture family of functions.
  ///@param frameNumber The last frame number (returned by CaptureResult\#getFrameNumber
  ///            or CaptureFailure\#getFrameNumber) in the capture sequence.
  ///@see CaptureResult\#getFrameNumber()
  ///@see CaptureFailure\#getFrameNumber()
  ///@see CaptureResult\#getSequenceId()
  ///@see CaptureFailure\#getSequenceId()
  ///@see \#onCaptureSequenceAborted
  void onCaptureSequenceCompleted(
          CameraCaptureSession session, int sequenceId, int frameNumber) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onCaptureSequenceCompleted,
          jni.JniType.voidType,
          [session.reference, sequenceId, frameNumber]).check();

  static final _id_onCaptureSequenceAborted = jniAccessors.getMethodIDOf(
      _classRef,
      "onCaptureSequenceAborted",
      "(Landroid/hardware/camera2/CameraCaptureSession;I)V");

  /// from: public void onCaptureSequenceAborted(android.hardware.camera2.CameraCaptureSession session, int sequenceId)
  ///
  /// This method is called independently of the others in CaptureCallback,
  /// when a capture sequence aborts before any CaptureResult
  /// or CaptureFailure for it have been returned via this listener.
  ///
  /// Due to the asynchronous nature of the camera device, not all submitted captures
  /// are immediately processed. It is possible to clear out the pending requests
  /// by a variety of operations such as CameraCaptureSession\#stopRepeating or
  /// CameraCaptureSession\#abortCaptures. When such an event happens,
  /// \#onCaptureSequenceCompleted will not be called.
  ///
  ///
  /// The default implementation does nothing.
  ///
  ///@param session The session returned by CameraDevice\#createCaptureSession
  /// This value must never be {@code null}.
  ///@param sequenceId A sequence ID returned by the \#capture family of functions.
  ///@see CaptureResult\#getFrameNumber()
  ///@see CaptureFailure\#getFrameNumber()
  ///@see CaptureResult\#getSequenceId()
  ///@see CaptureFailure\#getSequenceId()
  ///@see \#onCaptureSequenceCompleted
  void onCaptureSequenceAborted(CameraCaptureSession session, int sequenceId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCaptureSequenceAborted,
          jni.JniType.voidType, [session.reference, sequenceId]).check();

  static final _id_onCaptureBufferLost = jniAccessors.getMethodIDOf(
      _classRef,
      "onCaptureBufferLost",
      "(Landroid/hardware/camera2/CameraCaptureSession;Landroid/hardware/camera2/CaptureRequest;Landroid/view/Surface;J)V");

  /// from: public void onCaptureBufferLost(android.hardware.camera2.CameraCaptureSession session, android.hardware.camera2.CaptureRequest request, android.view.Surface target, long frameNumber)
  ///
  /// This method is called if a single buffer for a capture could not be sent to its
  /// destination surface.
  ///
  ///
  /// If the whole capture failed, then \#onCaptureFailed will be called instead. If
  /// some but not all buffers were captured but the result metadata will not be available,
  /// then onCaptureFailed will be invoked with CaptureFailure\#wasImageCaptured
  /// returning true, along with one or more calls to \#onCaptureBufferLost for the
  /// failed outputs.
  ///
  ///@param session The session returned by CameraDevice\#createCaptureSession
  /// This value must never be {@code null}.
  ///@param request The request that was given to the CameraDevice
  /// This value must never be {@code null}.
  ///@param target The target Surface that the buffer will not be produced for
  /// This value must never be {@code null}.
  ///@param frameNumber The frame number for the request
  void onCaptureBufferLost(
          CameraCaptureSession session,
          capturerequest_.CaptureRequest request,
          surface_.Surface target,
          int frameNumber) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onCaptureBufferLost, jni.JniType.voidType, [
        session.reference,
        request.reference,
        target.reference,
        frameNumber
      ]).check();
}
