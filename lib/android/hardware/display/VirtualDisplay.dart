// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../view/Display.dart" as display_;

import "../../view/Surface.dart" as surface_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.display.VirtualDisplay
///
/// Represents a virtual display. The content of a virtual display is rendered to a
/// android.view.Surface that you must provide to DisplayManager\#createVirtualDisplay createVirtualDisplay().
///
/// Because a virtual display renders to a surface provided by the application, it will be
/// released automatically when the process terminates and all remaining windows on it will
/// be forcibly removed.  However, you should also explicitly call \#release when
/// you're done with it.
///
///
///@see DisplayManager\#createVirtualDisplay
class VirtualDisplay extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/display/VirtualDisplay");
  VirtualDisplay.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getDisplay = jniAccessors.getMethodIDOf(
      _classRef, "getDisplay", "()Landroid/view/Display;");

  /// from: public android.view.Display getDisplay()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the virtual display.
  display_.Display getDisplay() =>
      display_.Display.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDisplay, jni.JniType.objectType, []).object);

  static final _id_getSurface = jniAccessors.getMethodIDOf(
      _classRef, "getSurface", "()Landroid/view/Surface;");

  /// from: public android.view.Surface getSurface()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the surface that backs the virtual display.
  surface_.Surface getSurface() =>
      surface_.Surface.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSurface, jni.JniType.objectType, []).object);

  static final _id_setSurface = jniAccessors.getMethodIDOf(
      _classRef, "setSurface", "(Landroid/view/Surface;)V");

  /// from: public void setSurface(android.view.Surface surface)
  ///
  /// Sets the surface that backs the virtual display.
  ///
  /// Detaching the surface that backs a virtual display has a similar effect to
  /// turning off the screen.
  ///
  ///
  /// It is still the caller's responsibility to destroy the surface after it has
  /// been detached.
  ///
  ///
  ///@param surface The surface to set, or null to detach the surface from the virtual display.
  void setSurface(surface_.Surface surface) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSurface,
      jni.JniType.voidType,
      [surface.reference]).check();

  static final _id_resize =
      jniAccessors.getMethodIDOf(_classRef, "resize", "(III)V");

  /// from: public void resize(int width, int height, int densityDpi)
  ///
  /// Asks the virtual display to resize.
  ///
  /// This is really just a convenience to allow applications using
  /// virtual displays to adapt to changing conditions without having
  /// to tear down and recreate the display.
  ///
  ///
  void resize(int width, int height, int densityDpi) =>
      jniAccessors.callMethodWithArgs(reference, _id_resize,
          jni.JniType.voidType, [width, height, densityDpi]).check();

  static final _id_release =
      jniAccessors.getMethodIDOf(_classRef, "release", "()V");

  /// from: public void release()
  ///
  /// Releases the virtual display and destroys its underlying surface.
  ///
  /// All remaining windows on the virtual display will be forcibly removed
  /// as part of releasing the virtual display.
  ///
  ///
  void release() => jniAccessors.callMethodWithArgs(
      reference, _id_release, jni.JniType.voidType, []).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.hardware.display.VirtualDisplay$Callback
///
/// Interface for receiving information about a VirtualDisplay's state changes.
class VirtualDisplay_Callback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/hardware/display/VirtualDisplay\$Callback");
  VirtualDisplay_Callback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  VirtualDisplay_Callback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onPaused =
      jniAccessors.getMethodIDOf(_classRef, "onPaused", "()V");

  /// from: public void onPaused()
  ///
  /// Called when the virtual display video projection has been
  /// paused by the system or when the surface has been detached
  /// by the application by calling setSurface(null).
  /// The surface will not receive any more buffers while paused.
  void onPaused() => jniAccessors.callMethodWithArgs(
      reference, _id_onPaused, jni.JniType.voidType, []).check();

  static final _id_onResumed =
      jniAccessors.getMethodIDOf(_classRef, "onResumed", "()V");

  /// from: public void onResumed()
  ///
  /// Called when the virtual display video projection has been
  /// resumed after having been paused.
  void onResumed() => jniAccessors.callMethodWithArgs(
      reference, _id_onResumed, jni.JniType.voidType, []).check();

  static final _id_onStopped =
      jniAccessors.getMethodIDOf(_classRef, "onStopped", "()V");

  /// from: public void onStopped()
  ///
  /// Called when the virtual display video projection has been
  /// stopped by the system.  It will no longer receive frames
  /// and it will never be resumed.  It is still the responsibility
  /// of the application to release() the virtual display.
  void onStopped() => jniAccessors.callMethodWithArgs(
      reference, _id_onStopped, jni.JniType.voidType, []).check();
}
