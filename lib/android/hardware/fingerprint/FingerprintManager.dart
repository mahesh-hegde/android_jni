// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/CancellationSignal.dart" as cancellationsignal_;

import "../../os/Handler.dart" as handler_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.fingerprint.FingerprintManager
///
/// A class that coordinates access to the fingerprint hardware.
/// Requires the android.content.pm.PackageManager\#FEATURE_FINGERPRINT PackageManager\#FEATURE_FINGERPRINT feature which can be detected using android.content.pm.PackageManager\#hasSystemFeature(String) PackageManager.hasSystemFeature(String).
///@deprecated See BiometricPrompt which shows a system-provided dialog upon starting
/// authentication. In a world where devices may have different types of biometric authentication,
/// it's much more realistic to have a system-provided authentication dialog since the method may
/// vary by vendor/device.
class FingerprintManager extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/hardware/fingerprint/FingerprintManager");
  FingerprintManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int FINGERPRINT_ACQUIRED_GOOD
  ///
  /// The image acquired was good.
  static const FINGERPRINT_ACQUIRED_GOOD = 0;

  /// from: static public final int FINGERPRINT_ACQUIRED_IMAGER_DIRTY
  ///
  /// The fingerprint image was too noisy due to suspected or detected dirt on the sensor.
  /// For example, it's reasonable return this after multiple
  /// \#FINGERPRINT_ACQUIRED_INSUFFICIENT or actual detection of dirt on the sensor
  /// (stuck pixels, swaths, etc.). The user is expected to take action to clean the sensor
  /// when this is returned.
  static const FINGERPRINT_ACQUIRED_IMAGER_DIRTY = 3;

  /// from: static public final int FINGERPRINT_ACQUIRED_INSUFFICIENT
  ///
  /// The fingerprint image was too noisy to process due to a detected condition (i.e. dry skin) or
  /// a possibly dirty sensor (See \#FINGERPRINT_ACQUIRED_IMAGER_DIRTY).
  static const FINGERPRINT_ACQUIRED_INSUFFICIENT = 2;

  /// from: static public final int FINGERPRINT_ACQUIRED_PARTIAL
  ///
  /// Only a partial fingerprint image was detected. During enrollment, the user should be
  /// informed on what needs to happen to resolve this problem, e.g. "press firmly on sensor."
  static const FINGERPRINT_ACQUIRED_PARTIAL = 1;

  /// from: static public final int FINGERPRINT_ACQUIRED_TOO_FAST
  ///
  /// The fingerprint image was incomplete due to quick motion. While mostly appropriate for
  /// linear array sensors,  this could also happen if the finger was moved during acquisition.
  /// The user should be asked to move the finger slower (linear) or leave the finger on the sensor
  /// longer.
  static const FINGERPRINT_ACQUIRED_TOO_FAST = 5;

  /// from: static public final int FINGERPRINT_ACQUIRED_TOO_SLOW
  ///
  /// The fingerprint image was unreadable due to lack of motion. This is most appropriate for
  /// linear array sensors that require a swipe motion.
  static const FINGERPRINT_ACQUIRED_TOO_SLOW = 4;

  /// from: static public final int FINGERPRINT_ERROR_CANCELED
  ///
  /// The operation was canceled because the fingerprint sensor is unavailable. For example,
  /// this may happen when the user is switched, the device is locked or another pending operation
  /// prevents or disables it.
  static const FINGERPRINT_ERROR_CANCELED = 5;

  /// from: static public final int FINGERPRINT_ERROR_HW_NOT_PRESENT
  ///
  /// The device does not have a fingerprint sensor.
  static const FINGERPRINT_ERROR_HW_NOT_PRESENT = 12;

  /// from: static public final int FINGERPRINT_ERROR_HW_UNAVAILABLE
  ///
  /// The hardware is unavailable. Try again later.
  static const FINGERPRINT_ERROR_HW_UNAVAILABLE = 1;

  /// from: static public final int FINGERPRINT_ERROR_LOCKOUT
  ///
  /// The operation was canceled because the API is locked out due to too many attempts.
  /// This occurs after 5 failed attempts, and lasts for 30 seconds.
  static const FINGERPRINT_ERROR_LOCKOUT = 7;

  /// from: static public final int FINGERPRINT_ERROR_LOCKOUT_PERMANENT
  ///
  /// The operation was canceled because FINGERPRINT_ERROR_LOCKOUT occurred too many times.
  /// Fingerprint authentication is disabled until the user unlocks with strong authentication
  /// (PIN/Pattern/Password)
  static const FINGERPRINT_ERROR_LOCKOUT_PERMANENT = 9;

  /// from: static public final int FINGERPRINT_ERROR_NO_FINGERPRINTS
  ///
  /// The user does not have any fingerprints enrolled.
  static const FINGERPRINT_ERROR_NO_FINGERPRINTS = 11;

  /// from: static public final int FINGERPRINT_ERROR_NO_SPACE
  ///
  /// Error state returned for operations like enrollment; the operation cannot be completed
  /// because there's not enough storage remaining to complete the operation.
  static const FINGERPRINT_ERROR_NO_SPACE = 4;

  /// from: static public final int FINGERPRINT_ERROR_TIMEOUT
  ///
  /// Error state returned when the current request has been running too long. This is intended to
  /// prevent programs from waiting for the fingerprint sensor indefinitely. The timeout is
  /// platform and sensor-specific, but is generally on the order of 30 seconds.
  static const FINGERPRINT_ERROR_TIMEOUT = 3;

  /// from: static public final int FINGERPRINT_ERROR_UNABLE_TO_PROCESS
  ///
  /// Error state returned when the sensor was unable to process the current image.
  static const FINGERPRINT_ERROR_UNABLE_TO_PROCESS = 2;

  /// from: static public final int FINGERPRINT_ERROR_USER_CANCELED
  ///
  /// The user canceled the operation. Upon receiving this, applications should use alternate
  /// authentication (e.g. a password). The application should also provide the means to return
  /// to fingerprint authentication, such as a "use fingerprint" button.
  static const FINGERPRINT_ERROR_USER_CANCELED = 10;

  /// from: static public final int FINGERPRINT_ERROR_VENDOR
  ///
  /// Hardware vendors may extend this list if there are conditions that do not fall under one of
  /// the above categories. Vendors are responsible for providing error strings for these errors.
  /// These messages are typically reserved for internal operations such as enrollment, but may be
  /// used to express vendor errors not covered by the ones in fingerprint.h. Applications are
  /// expected to show the error message string if they happen, but are advised not to rely on the
  /// message id since they will be device and vendor-specific
  static const FINGERPRINT_ERROR_VENDOR = 8;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  FingerprintManager()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_authenticate = jniAccessors.getMethodIDOf(
      _classRef,
      "authenticate",
      "(Landroid/hardware/fingerprint/FingerprintManager\$CryptoObject;Landroid/os/CancellationSignal;ILandroid/hardware/fingerprint/FingerprintManager\$AuthenticationCallback;Landroid/os/Handler;)V");

  /// from: public void authenticate(android.hardware.fingerprint.FingerprintManager.CryptoObject crypto, android.os.CancellationSignal cancel, int flags, android.hardware.fingerprint.FingerprintManager.AuthenticationCallback callback, android.os.Handler handler)
  ///
  /// Request authentication of a crypto object. This call warms up the fingerprint hardware
  /// and starts scanning for a fingerprint. It terminates when
  /// AuthenticationCallback\#onAuthenticationError(int, CharSequence) or
  /// AuthenticationCallback\#onAuthenticationSucceeded(AuthenticationResult) is called, at
  /// which point the object is no longer valid. The operation can be canceled by using the
  /// provided cancel object.
  ///
  /// Requires android.Manifest.permission\#USE_BIOMETRIC or android.Manifest.permission\#USE_FINGERPRINT
  ///@param crypto object associated with the call or null if none required.
  /// This value may be {@code null}.
  ///@param cancel an object that can be used to cancel authentication
  /// This value may be {@code null}.
  ///@param flags optional flags; should be 0
  ///@param callback an object to receive authentication events
  /// This value must never be {@code null}.
  ///@param handler an optional handler to handle callback events
  ///
  /// This value may be {@code null}.
  ///@throws IllegalArgumentException if the crypto operation is not supported or is not backed
  ///         by <a href="{@docRoot}training/articles/keystore.html">Android Keystore
  ///         facility</a>.
  ///@throws IllegalStateException if the crypto primitive is not initialized.
  ///@deprecated See BiometricPrompt\#authenticate(CancellationSignal, Executor,
  /// BiometricPrompt.AuthenticationCallback) and BiometricPrompt\#authenticate(
  /// BiometricPrompt.CryptoObject, CancellationSignal, Executor,
  /// BiometricPrompt.AuthenticationCallback)
  void authenticate(
          FingerprintManager_CryptoObject crypto,
          cancellationsignal_.CancellationSignal cancel,
          int flags,
          FingerprintManager_AuthenticationCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_authenticate, jni.JniType.voidType, [
        crypto.reference,
        cancel.reference,
        flags,
        callback.reference,
        handler.reference
      ]).check();

  static final _id_hasEnrolledFingerprints =
      jniAccessors.getMethodIDOf(_classRef, "hasEnrolledFingerprints", "()Z");

  /// from: public boolean hasEnrolledFingerprints()
  ///
  /// Determine if there is at least one fingerprint enrolled.
  ///
  /// Requires android.Manifest.permission\#USE_FINGERPRINT
  ///@return true if at least one fingerprint is enrolled, false otherwise
  ///@deprecated See BiometricPrompt and
  /// FingerprintManager\#FINGERPRINT_ERROR_NO_FINGERPRINTS
  bool hasEnrolledFingerprints() => jniAccessors.callMethodWithArgs(reference,
      _id_hasEnrolledFingerprints, jni.JniType.booleanType, []).boolean;

  static final _id_isHardwareDetected =
      jniAccessors.getMethodIDOf(_classRef, "isHardwareDetected", "()Z");

  /// from: public boolean isHardwareDetected()
  ///
  /// Determine if fingerprint hardware is present and functional.
  ///
  /// Requires android.Manifest.permission\#USE_FINGERPRINT
  ///@return true if hardware is present and functional, false otherwise.
  ///@deprecated See BiometricPrompt and
  /// FingerprintManager\#FINGERPRINT_ERROR_HW_UNAVAILABLE
  bool isHardwareDetected() => jniAccessors.callMethodWithArgs(
      reference, _id_isHardwareDetected, jni.JniType.booleanType, []).boolean;
}

/// from: android.hardware.fingerprint.FingerprintManager$CryptoObject
///
/// A wrapper class for the crypto objects supported by FingerprintManager. Currently the
/// framework supports Signature, Cipher and Mac objects.
///@deprecated See android.hardware.biometrics.BiometricPrompt.CryptoObject
class FingerprintManager_CryptoObject extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/hardware/fingerprint/FingerprintManager\$CryptoObject");
  FingerprintManager_CryptoObject.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/security/Signature;)V");

  /// from: public void <init>(java.security.Signature signature)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param signature This value must never be {@code null}.
  FingerprintManager_CryptoObject(jni.JniObject signature)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [signature.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljavax/crypto/Cipher;)V");

  /// from: public void <init>(javax.crypto.Cipher cipher)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param cipher This value must never be {@code null}.
  FingerprintManager_CryptoObject.ctor1(jni.JniObject cipher)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [cipher.reference]).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljavax/crypto/Mac;)V");

  /// from: public void <init>(javax.crypto.Mac mac)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param mac This value must never be {@code null}.
  FingerprintManager_CryptoObject.ctor2(jni.JniObject mac)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [mac.reference]).object);

  static final _id_getSignature = jniAccessors.getMethodIDOf(
      _classRef, "getSignature", "()Ljava/security/Signature;");

  /// from: public java.security.Signature getSignature()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get Signature object.
  ///@return Signature object or null if this doesn't contain one.
  jni.JniObject getSignature() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSignature, jni.JniType.objectType, []).object);

  static final _id_getCipher = jniAccessors.getMethodIDOf(
      _classRef, "getCipher", "()Ljavax/crypto/Cipher;");

  /// from: public javax.crypto.Cipher getCipher()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get Cipher object.
  ///@return Cipher object or null if this doesn't contain one.
  jni.JniObject getCipher() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCipher, jni.JniType.objectType, []).object);

  static final _id_getMac =
      jniAccessors.getMethodIDOf(_classRef, "getMac", "()Ljavax/crypto/Mac;");

  /// from: public javax.crypto.Mac getMac()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get Mac object.
  ///@return Mac object or null if this doesn't contain one.
  jni.JniObject getMac() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMac, jni.JniType.objectType, []).object);
}

/// from: android.hardware.fingerprint.FingerprintManager$AuthenticationResult
///
/// Container for callback data from FingerprintManager\#authenticate(CryptoObject,
///     CancellationSignal, int, AuthenticationCallback, Handler).
///@deprecated See android.hardware.biometrics.BiometricPrompt.AuthenticationResult
class FingerprintManager_AuthenticationResult extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/hardware/fingerprint/FingerprintManager\$AuthenticationResult");
  FingerprintManager_AuthenticationResult.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  FingerprintManager_AuthenticationResult()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getCryptoObject = jniAccessors.getMethodIDOf(
      _classRef,
      "getCryptoObject",
      "()Landroid/hardware/fingerprint/FingerprintManager\$CryptoObject;");

  /// from: public android.hardware.fingerprint.FingerprintManager.CryptoObject getCryptoObject()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtain the crypto object associated with this transaction
  ///@return crypto object provided to FingerprintManager\#authenticate(CryptoObject,
  ///     CancellationSignal, int, AuthenticationCallback, Handler).
  FingerprintManager_CryptoObject getCryptoObject() =>
      FingerprintManager_CryptoObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCryptoObject, jni.JniType.objectType, []).object);
}

/// from: android.hardware.fingerprint.FingerprintManager$AuthenticationCallback
///
/// Callback structure provided to FingerprintManager\#authenticate(CryptoObject,
/// CancellationSignal, int, AuthenticationCallback, Handler). Users of FingerprintManager\#authenticate(CryptoObject, CancellationSignal,
/// int, AuthenticationCallback, Handler) must provide an implementation of this for listening to
/// fingerprint events.
///@deprecated See android.hardware.biometrics.BiometricPrompt.AuthenticationCallback
class FingerprintManager_AuthenticationCallback extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/hardware/fingerprint/FingerprintManager\$AuthenticationCallback");
  FingerprintManager_AuthenticationCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  FingerprintManager_AuthenticationCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onAuthenticationError = jniAccessors.getMethodIDOf(
      _classRef, "onAuthenticationError", "(ILjava/lang/CharSequence;)V");

  /// from: public void onAuthenticationError(int errorCode, java.lang.CharSequence errString)
  ///
  /// Called when an unrecoverable error has been encountered and the operation is complete.
  /// No further callbacks will be made on this object.
  ///@param errorCode An integer identifying the error message
  ///@param errString A human-readable error string that can be shown in UI
  void onAuthenticationError(int errorCode, jni.JniObject errString) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAuthenticationError,
          jni.JniType.voidType, [errorCode, errString.reference]).check();

  static final _id_onAuthenticationHelp = jniAccessors.getMethodIDOf(
      _classRef, "onAuthenticationHelp", "(ILjava/lang/CharSequence;)V");

  /// from: public void onAuthenticationHelp(int helpCode, java.lang.CharSequence helpString)
  ///
  /// Called when a recoverable error has been encountered during authentication. The help
  /// string is provided to give the user guidance for what went wrong, such as
  /// "Sensor dirty, please clean it."
  ///@param helpCode An integer identifying the error message
  ///@param helpString A human-readable string that can be shown in UI
  void onAuthenticationHelp(int helpCode, jni.JniObject helpString) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAuthenticationHelp,
          jni.JniType.voidType, [helpCode, helpString.reference]).check();

  static final _id_onAuthenticationSucceeded = jniAccessors.getMethodIDOf(
      _classRef,
      "onAuthenticationSucceeded",
      "(Landroid/hardware/fingerprint/FingerprintManager\$AuthenticationResult;)V");

  /// from: public void onAuthenticationSucceeded(android.hardware.fingerprint.FingerprintManager.AuthenticationResult result)
  ///
  /// Called when a fingerprint is recognized.
  ///@param result An object containing authentication-related data
  void onAuthenticationSucceeded(
          FingerprintManager_AuthenticationResult result) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAuthenticationSucceeded,
          jni.JniType.voidType, [result.reference]).check();

  static final _id_onAuthenticationFailed =
      jniAccessors.getMethodIDOf(_classRef, "onAuthenticationFailed", "()V");

  /// from: public void onAuthenticationFailed()
  ///
  /// Called when a fingerprint is valid but not recognized.
  void onAuthenticationFailed() => jniAccessors.callMethodWithArgs(
      reference, _id_onAuthenticationFailed, jni.JniType.voidType, []).check();
}
