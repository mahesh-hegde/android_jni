// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Sensor.dart" as sensor_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.SensorDirectChannel
///
/// Class representing a sensor direct channel. Use
/// SensorManager\#createDirectChannel(android.os.MemoryFile) or
/// SensorManager\#createDirectChannel(android.hardware.HardwareBuffer)
/// to obtain an object. The channel object can be then configured
/// (see \#configure(Sensor, int))
/// to start delivery of sensor events into shared memory buffer.
class SensorDirectChannel extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/SensorDirectChannel");
  SensorDirectChannel.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int RATE_FAST
  ///
  /// Sensor operates at nominal rate of 200Hz.
  ///
  /// The actual rate is expected to be between 55% to 220% of nominal rate, thus between 110Hz to
  /// 440Hz.
  ///@see \#configure(Sensor, int)
  static const RATE_FAST = 2;

  /// from: static public final int RATE_NORMAL
  ///
  /// Sensor operates at nominal rate of 50Hz.
  ///
  /// The actual rate is expected to be between 55% to 220% of nominal rate, thus between 27.5Hz to
  /// 110Hz.
  ///@see \#configure(Sensor, int)
  static const RATE_NORMAL = 1;

  /// from: static public final int RATE_STOP
  ///
  /// Sensor stopped (no event output).
  ///@see \#configure(Sensor, int)
  static const RATE_STOP = 0;

  /// from: static public final int RATE_VERY_FAST
  ///
  /// Sensor operates at nominal rate of 800Hz.
  ///
  /// The actual rate is expected to be between 55% to 220% of nominal rate, thus between 440Hz to
  /// 1760Hz.
  ///@see \#configure(Sensor, int)
  static const RATE_VERY_FAST = 3;

  /// from: static public final int TYPE_HARDWARE_BUFFER
  ///
  /// Shared memory type wrapped by HardwareBuffer object.
  ///@see SensorManager\#createDirectChannel(HardwareBuffer)
  static const TYPE_HARDWARE_BUFFER = 2;

  /// from: static public final int TYPE_MEMORY_FILE
  ///
  /// Shared memory type ashmem, wrapped in MemoryFile object.
  ///@see SensorManager\#createDirectChannel(MemoryFile)
  static const TYPE_MEMORY_FILE = 1;

  static final _id_isOpen =
      jniAccessors.getMethodIDOf(_classRef, "isOpen", "()Z");

  /// from: public boolean isOpen()
  ///
  /// Determine if a channel is still valid. A channel is invalidated after \#close() is
  /// called.
  ///@return <code>true</code> if channel is valid.
  bool isOpen() => jniAccessors.callMethodWithArgs(
      reference, _id_isOpen, jni.JniType.booleanType, []).boolean;

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Close sensor direct channel.
  ///
  /// Stop all active sensor in the channel and free sensor system resource related to channel.
  /// Shared memory used for creating the direct channel need to be closed or freed separately.
  ///@see SensorManager\#createDirectChannel(MemoryFile)
  ///@see SensorManager\#createDirectChannel(HardwareBuffer)
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_configure = jniAccessors.getMethodIDOf(
      _classRef, "configure", "(Landroid/hardware/Sensor;I)I");

  /// from: public int configure(android.hardware.Sensor sensor, int rateLevel)
  ///
  /// Configure sensor rate or stop sensor report.
  ///
  /// To start event report of a sensor, or change rate of existing report, call this function with
  /// rateLevel other than android.hardware.SensorDirectChannel\#RATE_STOP. Sensor events
  /// will be added into a queue formed by the shared memory used in creation of direction channel.
  /// Each element of the queue has size of 104 bytes and represents a sensor event. Data
  /// structure of an element (all fields in little-endian):
  ///
  /// <pre>
  ///   offset   type                    name
  /// ------------------------------------------------------------------------
  ///   0x0000   int32_t                 size (always 104)
  ///   0x0004   int32_t                 sensor report token
  ///   0x0008   int32_t                 type (see SensorType)
  ///   0x000C   uint32_t                atomic counter
  ///   0x0010   int64_t                 timestamp (see Event)
  ///   0x0018   float[16]/int64_t[8]    data (data type depends on sensor type)
  ///   0x0058   int32_t[4]              reserved (set to zero)
  /// </pre>
  ///
  /// There are no head or tail pointers. The sequence and frontier of new sensor events is
  /// determined by the atomic counter, which counts from 1 after creation of direct channel and
  /// increments 1 for each new event. Atomic counter will wrap back to 1 after it reaches
  /// UINT32_MAX, skipping value 0 to avoid confusion with uninitialized memory. The writer in
  /// sensor system will wrap around from the start of shared memory region when it reaches the
  /// end. If size of memory region is not a multiple of size of element (104 bytes), the residual
  /// is not used at the end.  Function returns a positive sensor report token on success. This
  /// token can be used to differentiate sensor events from multiple sensor of the same type. For
  /// example, if there are two accelerometers in the system A and B, it is guaranteed different
  /// report tokens will be returned when starting sensor A and B.
  ///
  /// To stop a sensor, call this function with rateLevel equal android.hardware.SensorDirectChannel\#RATE_STOP. If the sensor parameter is left to be null,
  /// this will stop all active sensor report associated with the direct channel specified.
  /// Function return 1 on success or 0 on failure.
  ///@param sensor A android.hardware.Sensor object to denote sensor to be operated.
  ///@param rateLevel rate level defined in android.hardware.SensorDirectChannel.
  /// Value is either <code>0</code> or a combination of android.hardware.SensorDirectChannel\#RATE_STOP, android.hardware.SensorDirectChannel\#RATE_NORMAL, android.hardware.SensorDirectChannel\#RATE_FAST, and android.hardware.SensorDirectChannel\#RATE_VERY_FAST
  ///@return * starting report or changing rate: positive sensor report token on success,
  ///                                             0 on failure;
  ///         * stopping report: 1 on success, 0 on failure.
  ///@throws NullPointerException when channel is null.
  int configure(sensor_.Sensor sensor, int rateLevel) =>
      jniAccessors.callMethodWithArgs(reference, _id_configure,
          jni.JniType.intType, [sensor.reference, rateLevel]).integer;

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();
}
