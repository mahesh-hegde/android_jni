// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../os/CancellationSignal.dart" as cancellationsignal_;

import "../../content/Context.dart" as context_;

import "../../content/DialogInterface.dart" as dialoginterface_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.biometrics.BiometricPrompt
///
/// A class that manages a system-provided biometric dialog.
class BiometricPrompt extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/biometrics/BiometricPrompt");
  BiometricPrompt.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int BIOMETRIC_ACQUIRED_GOOD
  ///
  /// The image acquired was good.
  static const BIOMETRIC_ACQUIRED_GOOD = 0;

  /// from: static public final int BIOMETRIC_ACQUIRED_IMAGER_DIRTY
  ///
  /// The biometric image was too noisy due to suspected or detected dirt on the sensor.  For
  /// example, it's reasonable return this after multiple \#BIOMETRIC_ACQUIRED_INSUFFICIENT
  /// or actual detection of dirt on the sensor (stuck pixels, swaths, etc.). The user is expected
  /// to take action to clean the sensor when this is returned.
  static const BIOMETRIC_ACQUIRED_IMAGER_DIRTY = 3;

  /// from: static public final int BIOMETRIC_ACQUIRED_INSUFFICIENT
  ///
  /// The biometric image was too noisy to process due to a detected condition or a possibly dirty
  /// sensor (See \#BIOMETRIC_ACQUIRED_IMAGER_DIRTY).
  static const BIOMETRIC_ACQUIRED_INSUFFICIENT = 2;

  /// from: static public final int BIOMETRIC_ACQUIRED_PARTIAL
  ///
  /// Only a partial biometric image was detected. During enrollment, the user should be informed
  /// on what needs to happen to resolve this problem, e.g. "press firmly on sensor." (for
  /// fingerprint)
  static const BIOMETRIC_ACQUIRED_PARTIAL = 1;

  /// from: static public final int BIOMETRIC_ACQUIRED_TOO_FAST
  ///
  /// The biometric image was incomplete due to quick motion. For example, this could also happen
  /// if the user moved during acquisition. The user should be asked to repeat the operation more
  /// slowly.
  static const BIOMETRIC_ACQUIRED_TOO_FAST = 5;

  /// from: static public final int BIOMETRIC_ACQUIRED_TOO_SLOW
  ///
  /// The biometric image was unreadable due to lack of motion.
  static const BIOMETRIC_ACQUIRED_TOO_SLOW = 4;

  /// from: static public final int BIOMETRIC_ERROR_CANCELED
  ///
  /// The operation was canceled because the biometric sensor is unavailable. For example, this may
  /// happen when the user is switched, the device is locked or another pending operation prevents
  /// or disables it.
  static const BIOMETRIC_ERROR_CANCELED = 5;

  /// from: static public final int BIOMETRIC_ERROR_HW_NOT_PRESENT
  ///
  /// The device does not have a biometric sensor.
  static const BIOMETRIC_ERROR_HW_NOT_PRESENT = 12;

  /// from: static public final int BIOMETRIC_ERROR_HW_UNAVAILABLE
  ///
  /// The hardware is unavailable. Try again later.
  static const BIOMETRIC_ERROR_HW_UNAVAILABLE = 1;

  /// from: static public final int BIOMETRIC_ERROR_LOCKOUT
  ///
  /// The operation was canceled because the API is locked out due to too many attempts.
  /// This occurs after 5 failed attempts, and lasts for 30 seconds.
  static const BIOMETRIC_ERROR_LOCKOUT = 7;

  /// from: static public final int BIOMETRIC_ERROR_LOCKOUT_PERMANENT
  ///
  /// The operation was canceled because BIOMETRIC_ERROR_LOCKOUT occurred too many times.
  /// Biometric authentication is disabled until the user unlocks with strong authentication
  /// (PIN/Pattern/Password)
  static const BIOMETRIC_ERROR_LOCKOUT_PERMANENT = 9;

  /// from: static public final int BIOMETRIC_ERROR_NO_BIOMETRICS
  ///
  /// The user does not have any biometrics enrolled.
  static const BIOMETRIC_ERROR_NO_BIOMETRICS = 11;

  /// from: static public final int BIOMETRIC_ERROR_NO_SPACE
  ///
  /// Error state returned for operations like enrollment; the operation cannot be completed
  /// because there's not enough storage remaining to complete the operation.
  static const BIOMETRIC_ERROR_NO_SPACE = 4;

  /// from: static public final int BIOMETRIC_ERROR_TIMEOUT
  ///
  /// Error state returned when the current request has been running too long. This is intended to
  /// prevent programs from waiting for the biometric sensor indefinitely. The timeout is platform
  /// and sensor-specific, but is generally on the order of 30 seconds.
  static const BIOMETRIC_ERROR_TIMEOUT = 3;

  /// from: static public final int BIOMETRIC_ERROR_UNABLE_TO_PROCESS
  ///
  /// Error state returned when the sensor was unable to process the current image.
  static const BIOMETRIC_ERROR_UNABLE_TO_PROCESS = 2;

  /// from: static public final int BIOMETRIC_ERROR_USER_CANCELED
  ///
  /// The user canceled the operation. Upon receiving this, applications should use alternate
  /// authentication (e.g. a password). The application should also provide the means to return to
  /// biometric authentication, such as a "use <biometric>" button.
  static const BIOMETRIC_ERROR_USER_CANCELED = 10;

  /// from: static public final int BIOMETRIC_ERROR_VENDOR
  ///
  /// Hardware vendors may extend this list if there are conditions that do not fall under one of
  /// the above categories. Vendors are responsible for providing error strings for these errors.
  /// These messages are typically reserved for internal operations such as enrollment, but may be
  /// used to express vendor errors not otherwise covered. Applications are expected to show the
  /// error message string if they happen, but are advised not to rely on the message id since they
  /// will be device and vendor-specific
  static const BIOMETRIC_ERROR_VENDOR = 8;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  BiometricPrompt()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_authenticate = jniAccessors.getMethodIDOf(
      _classRef,
      "authenticate",
      "(Landroid/hardware/biometrics/BiometricPrompt\$CryptoObject;Landroid/os/CancellationSignal;Ljava/util/concurrent/Executor;Landroid/hardware/biometrics/BiometricPrompt\$AuthenticationCallback;)V");

  /// from: public void authenticate(android.hardware.biometrics.BiometricPrompt.CryptoObject crypto, android.os.CancellationSignal cancel, java.util.concurrent.Executor executor, android.hardware.biometrics.BiometricPrompt.AuthenticationCallback callback)
  ///
  /// This call warms up the fingerprint hardware, displays a system-provided dialog, and starts
  /// scanning for a fingerprint. It terminates when AuthenticationCallback\#onAuthenticationError(int, CharSequence) is called, when AuthenticationCallback\#onAuthenticationSucceeded( AuthenticationResult), or when the user
  /// dismisses the system-provided dialog, at which point the crypto object becomes invalid. This
  /// operation can be canceled by using the provided cancel object. The application will receive
  /// authentication errors through AuthenticationCallback, and button events through the
  /// corresponding callback set in Builder\#setNegativeButton(CharSequence, Executor,
  /// DialogInterface.OnClickListener). It is safe to reuse the BiometricPrompt object,
  /// and calling BiometricPrompt\#authenticate( CancellationSignal, Executor,
  /// AuthenticationCallback) while an existing authentication attempt is occurring will stop the
  /// previous client and start a new authentication. The interrupted client will receive a
  /// cancelled notification through AuthenticationCallback\#onAuthenticationError(int,
  /// CharSequence).
  ///
  /// Requires android.Manifest.permission\#USE_BIOMETRIC
  ///@throws IllegalArgumentException If any of the arguments are null
  ///@param crypto Object associated with the call
  /// This value must never be {@code null}.
  ///@param cancel An object that can be used to cancel authentication
  /// This value must never be {@code null}.
  ///@param executor An executor to handle callback events
  /// This value must never be {@code null}.
  /// Callback and listener events are dispatched through this
  ///  *           Executor, providing an easy way to control which thread is
  ///  *           used. To dispatch events through the main thread of your
  ///  *           application, you can use Context\#getMainExecutor(). To
  ///  *           dispatch events through a shared thread pool, you can use
  ///  *           AsyncTask\#THREAD_POOL_EXECUTOR.
  ///@param callback An object to receive authentication events
  ///
  /// This value must never be {@code null}.
  void authenticate(
          BiometricPrompt_CryptoObject crypto,
          cancellationsignal_.CancellationSignal cancel,
          jni.JniObject executor,
          BiometricPrompt_AuthenticationCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_authenticate, jni.JniType.voidType, [
        crypto.reference,
        cancel.reference,
        executor.reference,
        callback.reference
      ]).check();

  static final _id_authenticate1 = jniAccessors.getMethodIDOf(
      _classRef,
      "authenticate",
      "(Landroid/os/CancellationSignal;Ljava/util/concurrent/Executor;Landroid/hardware/biometrics/BiometricPrompt\$AuthenticationCallback;)V");

  /// from: public void authenticate(android.os.CancellationSignal cancel, java.util.concurrent.Executor executor, android.hardware.biometrics.BiometricPrompt.AuthenticationCallback callback)
  ///
  /// This call warms up the fingerprint hardware, displays a system-provided dialog, and starts
  /// scanning for a fingerprint. It terminates when AuthenticationCallback\#onAuthenticationError(int, CharSequence) is called, when AuthenticationCallback\#onAuthenticationSucceeded( AuthenticationResult) is called, or when
  /// the user dismisses the system-provided dialog.  This operation can be canceled by using the
  /// provided cancel object. The application will receive authentication errors through AuthenticationCallback, and button events through the corresponding callback set in Builder\#setNegativeButton(CharSequence, Executor, DialogInterface.OnClickListener).  It is
  /// safe to reuse the BiometricPrompt object, and calling BiometricPrompt\#authenticate(CancellationSignal, Executor, AuthenticationCallback) while
  /// an existing authentication attempt is occurring will stop the previous client and start a new
  /// authentication. The interrupted client will receive a cancelled notification through AuthenticationCallback\#onAuthenticationError(int, CharSequence).
  ///
  /// Requires android.Manifest.permission\#USE_BIOMETRIC
  ///@throws IllegalArgumentException If any of the arguments are null
  ///@param cancel An object that can be used to cancel authentication
  /// This value must never be {@code null}.
  ///@param executor An executor to handle callback events
  /// This value must never be {@code null}.
  /// Callback and listener events are dispatched through this
  ///  *           Executor, providing an easy way to control which thread is
  ///  *           used. To dispatch events through the main thread of your
  ///  *           application, you can use Context\#getMainExecutor(). To
  ///  *           dispatch events through a shared thread pool, you can use
  ///  *           AsyncTask\#THREAD_POOL_EXECUTOR.
  ///@param callback An object to receive authentication events
  ///
  /// This value must never be {@code null}.
  void authenticate1(
          cancellationsignal_.CancellationSignal cancel,
          jni.JniObject executor,
          BiometricPrompt_AuthenticationCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_authenticate1,
          jni.JniType.voidType,
          [cancel.reference, executor.reference, callback.reference]).check();
}

/// from: android.hardware.biometrics.BiometricPrompt$CryptoObject
///
/// A wrapper class for the crypto objects supported by BiometricPrompt. Currently the framework
/// supports Signature, Cipher and Mac objects.
class BiometricPrompt_CryptoObject extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/hardware/biometrics/BiometricPrompt\$CryptoObject");
  BiometricPrompt_CryptoObject.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljava/security/Signature;)V");

  /// from: public void <init>(java.security.Signature signature)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param signature This value must never be {@code null}.
  BiometricPrompt_CryptoObject(jni.JniObject signature)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [signature.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Ljavax/crypto/Cipher;)V");

  /// from: public void <init>(javax.crypto.Cipher cipher)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param cipher This value must never be {@code null}.
  BiometricPrompt_CryptoObject.ctor1(jni.JniObject cipher)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [cipher.reference]).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljavax/crypto/Mac;)V");

  /// from: public void <init>(javax.crypto.Mac mac)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param mac This value must never be {@code null}.
  BiometricPrompt_CryptoObject.ctor2(jni.JniObject mac)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [mac.reference]).object);

  static final _id_getSignature = jniAccessors.getMethodIDOf(
      _classRef, "getSignature", "()Ljava/security/Signature;");

  /// from: public java.security.Signature getSignature()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get Signature object.
  ///@return Signature object or null if this doesn't contain one.
  jni.JniObject getSignature() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSignature, jni.JniType.objectType, []).object);

  static final _id_getCipher = jniAccessors.getMethodIDOf(
      _classRef, "getCipher", "()Ljavax/crypto/Cipher;");

  /// from: public javax.crypto.Cipher getCipher()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get Cipher object.
  ///@return Cipher object or null if this doesn't contain one.
  jni.JniObject getCipher() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCipher, jni.JniType.objectType, []).object);

  static final _id_getMac =
      jniAccessors.getMethodIDOf(_classRef, "getMac", "()Ljavax/crypto/Mac;");

  /// from: public javax.crypto.Mac getMac()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get Mac object.
  ///@return Mac object or null if this doesn't contain one.
  jni.JniObject getMac() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMac, jni.JniType.objectType, []).object);
}

/// from: android.hardware.biometrics.BiometricPrompt$Builder
///
/// A builder that collects arguments to be shown on the system-provided biometric dialog.
class BiometricPrompt_Builder extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/hardware/biometrics/BiometricPrompt\$Builder");
  BiometricPrompt_Builder.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a builder for a biometric dialog.
  ///@param context
  BiometricPrompt_Builder(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_setTitle = jniAccessors.getMethodIDOf(_classRef, "setTitle",
      "(Ljava/lang/CharSequence;)Landroid/hardware/biometrics/BiometricPrompt\$Builder;");

  /// from: public android.hardware.biometrics.BiometricPrompt.Builder setTitle(java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Required: Set the title to display.
  ///@param title This value must never be {@code null}.
  ///@return
  BiometricPrompt_Builder setTitle(jni.JniObject title) =>
      BiometricPrompt_Builder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setTitle, jni.JniType.objectType, [title.reference]).object);

  static final _id_setSubtitle = jniAccessors.getMethodIDOf(
      _classRef,
      "setSubtitle",
      "(Ljava/lang/CharSequence;)Landroid/hardware/biometrics/BiometricPrompt\$Builder;");

  /// from: public android.hardware.biometrics.BiometricPrompt.Builder setSubtitle(java.lang.CharSequence subtitle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Optional: Set the subtitle to display.
  ///@param subtitle This value must never be {@code null}.
  ///@return
  BiometricPrompt_Builder setSubtitle(jni.JniObject subtitle) =>
      BiometricPrompt_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setSubtitle,
          jni.JniType.objectType,
          [subtitle.reference]).object);

  static final _id_setDescription = jniAccessors.getMethodIDOf(
      _classRef,
      "setDescription",
      "(Ljava/lang/CharSequence;)Landroid/hardware/biometrics/BiometricPrompt\$Builder;");

  /// from: public android.hardware.biometrics.BiometricPrompt.Builder setDescription(java.lang.CharSequence description)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Optional: Set the description to display.
  ///@param description This value must never be {@code null}.
  ///@return
  BiometricPrompt_Builder setDescription(jni.JniObject description) =>
      BiometricPrompt_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setDescription,
          jni.JniType.objectType,
          [description.reference]).object);

  static final _id_setNegativeButton = jniAccessors.getMethodIDOf(
      _classRef,
      "setNegativeButton",
      "(Ljava/lang/CharSequence;Ljava/util/concurrent/Executor;Landroid/content/DialogInterface\$OnClickListener;)Landroid/hardware/biometrics/BiometricPrompt\$Builder;");

  /// from: public android.hardware.biometrics.BiometricPrompt.Builder setNegativeButton(java.lang.CharSequence text, java.util.concurrent.Executor executor, android.content.DialogInterface.OnClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Required: Set the text for the negative button. This would typically be used as a
  /// "Cancel" button, but may be also used to show an alternative method for authentication,
  /// such as screen that asks for a backup password.
  ///@param text This value must never be {@code null}.
  ///@param executor This value must never be {@code null}.
  /// Callback and listener events are dispatched through this
  ///  *           Executor, providing an easy way to control which thread is
  ///  *           used. To dispatch events through the main thread of your
  ///  *           application, you can use Context\#getMainExecutor(). To
  ///  *           dispatch events through a shared thread pool, you can use
  ///  *           AsyncTask\#THREAD_POOL_EXECUTOR.
  ///@param listener This value must never be {@code null}.
  ///@return
  BiometricPrompt_Builder setNegativeButton(
          jni.JniObject text,
          jni.JniObject executor,
          dialoginterface_.DialogInterface_OnClickListener listener) =>
      BiometricPrompt_Builder.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setNegativeButton,
          jni.JniType.objectType,
          [text.reference, executor.reference, listener.reference]).object);

  static final _id_build = jniAccessors.getMethodIDOf(
      _classRef, "build", "()Landroid/hardware/biometrics/BiometricPrompt;");

  /// from: public android.hardware.biometrics.BiometricPrompt build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a BiometricPrompt.
  ///@return a BiometricPrompt
  ///@throws IllegalArgumentException if any of the required fields are not set.
  BiometricPrompt build() =>
      BiometricPrompt.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_build, jni.JniType.objectType, []).object);
}

/// from: android.hardware.biometrics.BiometricPrompt$AuthenticationResult
///
/// Container for callback data from \#authenticate( CancellationSignal, Executor,
/// AuthenticationCallback) and \#authenticate(CryptoObject, CancellationSignal, Executor,
/// AuthenticationCallback)
class BiometricPrompt_AuthenticationResult extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/hardware/biometrics/BiometricPrompt\$AuthenticationResult");
  BiometricPrompt_AuthenticationResult.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  BiometricPrompt_AuthenticationResult()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getCryptoObject = jniAccessors.getMethodIDOf(
      _classRef,
      "getCryptoObject",
      "()Landroid/hardware/biometrics/BiometricPrompt\$CryptoObject;");

  /// from: public android.hardware.biometrics.BiometricPrompt.CryptoObject getCryptoObject()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtain the crypto object associated with this transaction
  ///@return crypto object provided to \#authenticate( CryptoObject, CancellationSignal,
  /// Executor, AuthenticationCallback)
  BiometricPrompt_CryptoObject getCryptoObject() =>
      BiometricPrompt_CryptoObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCryptoObject, jni.JniType.objectType, []).object);
}

/// from: android.hardware.biometrics.BiometricPrompt$AuthenticationCallback
///
/// Callback structure provided to BiometricPrompt\#authenticate(CancellationSignal,
/// Executor, AuthenticationCallback) or BiometricPrompt\#authenticate(CryptoObject,
/// CancellationSignal, Executor, AuthenticationCallback). Users must provide an implementation
/// of this for listening to authentication events.
class BiometricPrompt_AuthenticationCallback extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/hardware/biometrics/BiometricPrompt\$AuthenticationCallback");
  BiometricPrompt_AuthenticationCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  BiometricPrompt_AuthenticationCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onAuthenticationError = jniAccessors.getMethodIDOf(
      _classRef, "onAuthenticationError", "(ILjava/lang/CharSequence;)V");

  /// from: public void onAuthenticationError(int errorCode, java.lang.CharSequence errString)
  ///
  /// Called when an unrecoverable error has been encountered and the operation is complete.
  /// No further actions will be made on this object.
  ///@param errorCode An integer identifying the error message
  ///@param errString A human-readable error string that can be shown on an UI
  void onAuthenticationError(int errorCode, jni.JniObject errString) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAuthenticationError,
          jni.JniType.voidType, [errorCode, errString.reference]).check();

  static final _id_onAuthenticationHelp = jniAccessors.getMethodIDOf(
      _classRef, "onAuthenticationHelp", "(ILjava/lang/CharSequence;)V");

  /// from: public void onAuthenticationHelp(int helpCode, java.lang.CharSequence helpString)
  ///
  /// Called when a recoverable error has been encountered during authentication. The help
  /// string is provided to give the user guidance for what went wrong, such as "Sensor dirty,
  /// please clean it."
  ///@param helpCode An integer identifying the error message
  ///@param helpString A human-readable string that can be shown on an UI
  void onAuthenticationHelp(int helpCode, jni.JniObject helpString) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAuthenticationHelp,
          jni.JniType.voidType, [helpCode, helpString.reference]).check();

  static final _id_onAuthenticationSucceeded = jniAccessors.getMethodIDOf(
      _classRef,
      "onAuthenticationSucceeded",
      "(Landroid/hardware/biometrics/BiometricPrompt\$AuthenticationResult;)V");

  /// from: public void onAuthenticationSucceeded(android.hardware.biometrics.BiometricPrompt.AuthenticationResult result)
  ///
  /// Called when a biometric is recognized.
  ///@param result An object containing authentication-related data
  void onAuthenticationSucceeded(BiometricPrompt_AuthenticationResult result) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAuthenticationSucceeded,
          jni.JniType.voidType, [result.reference]).check();

  static final _id_onAuthenticationFailed =
      jniAccessors.getMethodIDOf(_classRef, "onAuthenticationFailed", "()V");

  /// from: public void onAuthenticationFailed()
  ///
  /// Called when a biometric is valid but not recognized.
  void onAuthenticationFailed() => jniAccessors.callMethodWithArgs(
      reference, _id_onAuthenticationFailed, jni.JniType.voidType, []).check();
}
