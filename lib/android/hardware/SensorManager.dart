// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Sensor.dart" as sensor_;

import "SensorListener.dart" as sensorlistener_;

import "SensorEventListener.dart" as sensoreventlistener_;

import "../os/Handler.dart" as handler_;

import "SensorDirectChannel.dart" as sensordirectchannel_;

import "../os/MemoryFile.dart" as memoryfile_;

import "HardwareBuffer.dart" as hardwarebuffer_;

import "TriggerEventListener.dart" as triggereventlistener_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.SensorManager
///
///
/// SensorManager lets you access the device's android.hardware.Sensor sensors.
///
///
///
/// Always make sure to disable sensors you don't need, especially when your
/// activity is paused. Failing to do so can drain the battery in just a few
/// hours. Note that the system will <i>not</i> disable sensors automatically when
/// the screen turns off.
///
///
/// <p class="note">
/// Note: Don't use this mechanism with a Trigger Sensor, have a look
/// at TriggerEventListener. Sensor\#TYPE_SIGNIFICANT_MOTION
/// is an example of a trigger sensor.
///
///
/// <pre class="prettyprint">
/// public class SensorActivity extends Activity implements SensorEventListener {
///     private final SensorManager mSensorManager;
///     private final Sensor mAccelerometer;
///
///     public SensorActivity() {
///         mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);
///         mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
///     }
///
///     protected void onResume() {
///         super.onResume();
///         mSensorManager.registerListener(this, mAccelerometer, SensorManager.SENSOR_DELAY_NORMAL);
///     }
///
///     protected void onPause() {
///         super.onPause();
///         mSensorManager.unregisterListener(this);
///     }
///
///     public void onAccuracyChanged(Sensor sensor, int accuracy) {
///     }
///
///     public void onSensorChanged(SensorEvent event) {
///     }
/// }
/// </pre>
///@see SensorEventListener
///@see SensorEvent
///@see Sensor
class SensorManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/SensorManager");
  SensorManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int AXIS_MINUS_X
  ///
  /// see \#remapCoordinateSystem
  static const AXIS_MINUS_X = 129;

  /// from: static public final int AXIS_MINUS_Y
  ///
  /// see \#remapCoordinateSystem
  static const AXIS_MINUS_Y = 130;

  /// from: static public final int AXIS_MINUS_Z
  ///
  /// see \#remapCoordinateSystem
  static const AXIS_MINUS_Z = 131;

  /// from: static public final int AXIS_X
  ///
  /// see \#remapCoordinateSystem
  static const AXIS_X = 1;

  /// from: static public final int AXIS_Y
  ///
  /// see \#remapCoordinateSystem
  static const AXIS_Y = 2;

  /// from: static public final int AXIS_Z
  ///
  /// see \#remapCoordinateSystem
  static const AXIS_Z = 3;

  /// from: static public final int DATA_X
  ///
  /// Index of the X value in the array returned by
  /// android.hardware.SensorListener\#onSensorChanged
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const DATA_X = 0;

  /// from: static public final int DATA_Y
  ///
  /// Index of the Y value in the array returned by
  /// android.hardware.SensorListener\#onSensorChanged
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const DATA_Y = 1;

  /// from: static public final int DATA_Z
  ///
  /// Index of the Z value in the array returned by
  /// android.hardware.SensorListener\#onSensorChanged
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const DATA_Z = 2;

  /// from: static public final float GRAVITY_DEATH_STAR_I
  ///
  /// Gravity (estimate) on the first Death Star in Empire units (m/s^2)
  static const GRAVITY_DEATH_STAR_I = 3.5303614e-7;

  /// from: static public final float GRAVITY_EARTH
  ///
  /// Earth's gravity in SI units (m/s^2)
  static const GRAVITY_EARTH = 9.80665;

  /// from: static public final float GRAVITY_JUPITER
  ///
  /// Jupiter's gravity in SI units (m/s^2)
  static const GRAVITY_JUPITER = 23.12;

  /// from: static public final float GRAVITY_MARS
  ///
  /// Mars' gravity in SI units (m/s^2)
  static const GRAVITY_MARS = 3.71;

  /// from: static public final float GRAVITY_MERCURY
  ///
  /// Mercury's gravity in SI units (m/s^2)
  static const GRAVITY_MERCURY = 3.7;

  /// from: static public final float GRAVITY_MOON
  ///
  /// The Moon's gravity in SI units (m/s^2)
  static const GRAVITY_MOON = 1.6;

  /// from: static public final float GRAVITY_NEPTUNE
  ///
  /// Neptune's gravity in SI units (m/s^2)
  static const GRAVITY_NEPTUNE = 11.0;

  /// from: static public final float GRAVITY_PLUTO
  ///
  /// Pluto's gravity in SI units (m/s^2)
  static const GRAVITY_PLUTO = 0.6;

  /// from: static public final float GRAVITY_SATURN
  ///
  /// Saturn's gravity in SI units (m/s^2)
  static const GRAVITY_SATURN = 8.96;

  /// from: static public final float GRAVITY_SUN
  ///
  /// Sun's gravity in SI units (m/s^2)
  static const GRAVITY_SUN = 275.0;

  /// from: static public final float GRAVITY_THE_ISLAND
  ///
  /// Gravity on the island
  static const GRAVITY_THE_ISLAND = 4.815162;

  /// from: static public final float GRAVITY_URANUS
  ///
  /// Uranus' gravity in SI units (m/s^2)
  static const GRAVITY_URANUS = 8.69;

  /// from: static public final float GRAVITY_VENUS
  ///
  /// Venus' gravity in SI units (m/s^2)
  static const GRAVITY_VENUS = 8.87;

  /// from: static public final float LIGHT_CLOUDY
  ///
  /// luminance under a cloudy sky in lux
  static const LIGHT_CLOUDY = 100.0;

  /// from: static public final float LIGHT_FULLMOON
  ///
  /// luminance at night with full moon in lux
  static const LIGHT_FULLMOON = 0.25;

  /// from: static public final float LIGHT_NO_MOON
  ///
  /// luminance at night with no moon in lux
  static const LIGHT_NO_MOON = 0.001;

  /// from: static public final float LIGHT_OVERCAST
  ///
  /// luminance under an overcast sky in lux
  static const LIGHT_OVERCAST = 10000.0;

  /// from: static public final float LIGHT_SHADE
  ///
  /// luminance in shade in lux
  static const LIGHT_SHADE = 20000.0;

  /// from: static public final float LIGHT_SUNLIGHT
  ///
  /// luminance of sunlight in lux
  static const LIGHT_SUNLIGHT = 110000.0;

  /// from: static public final float LIGHT_SUNLIGHT_MAX
  ///
  /// Maximum luminance of sunlight in lux
  static const LIGHT_SUNLIGHT_MAX = 120000.0;

  /// from: static public final float LIGHT_SUNRISE
  ///
  /// luminance at sunrise in lux
  static const LIGHT_SUNRISE = 400.0;

  /// from: static public final float MAGNETIC_FIELD_EARTH_MAX
  ///
  /// Maximum magnetic field on Earth's surface
  static const MAGNETIC_FIELD_EARTH_MAX = 60.0;

  /// from: static public final float MAGNETIC_FIELD_EARTH_MIN
  ///
  /// Minimum magnetic field on Earth's surface
  static const MAGNETIC_FIELD_EARTH_MIN = 30.0;

  /// from: static public final float PRESSURE_STANDARD_ATMOSPHERE
  ///
  /// Standard atmosphere, or average sea-level pressure in hPa (millibar)
  static const PRESSURE_STANDARD_ATMOSPHERE = 1013.25;

  /// from: static public final int RAW_DATA_INDEX
  ///
  /// Offset to the untransformed values in the array returned by
  /// android.hardware.SensorListener\#onSensorChanged
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const RAW_DATA_INDEX = 3;

  /// from: static public final int RAW_DATA_X
  ///
  /// Index of the untransformed X value in the array returned by
  /// android.hardware.SensorListener\#onSensorChanged
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const RAW_DATA_X = 3;

  /// from: static public final int RAW_DATA_Y
  ///
  /// Index of the untransformed Y value in the array returned by
  /// android.hardware.SensorListener\#onSensorChanged
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const RAW_DATA_Y = 4;

  /// from: static public final int RAW_DATA_Z
  ///
  /// Index of the untransformed Z value in the array returned by
  /// android.hardware.SensorListener\#onSensorChanged
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const RAW_DATA_Z = 5;

  /// from: static public final int SENSOR_ACCELEROMETER
  ///
  /// A constant describing an accelerometer. See
  /// android.hardware.SensorListener SensorListener for more details.
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const SENSOR_ACCELEROMETER = 2;

  /// from: static public final int SENSOR_ALL
  ///
  /// A constant that includes all sensors
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const SENSOR_ALL = 127;

  /// from: static public final int SENSOR_DELAY_FASTEST
  ///
  /// get sensor data as fast as possible
  static const SENSOR_DELAY_FASTEST = 0;

  /// from: static public final int SENSOR_DELAY_GAME
  ///
  /// rate suitable for games
  static const SENSOR_DELAY_GAME = 1;

  /// from: static public final int SENSOR_DELAY_NORMAL
  ///
  /// rate (default) suitable for screen orientation changes
  static const SENSOR_DELAY_NORMAL = 3;

  /// from: static public final int SENSOR_DELAY_UI
  ///
  /// rate suitable for the user interface
  static const SENSOR_DELAY_UI = 2;

  /// from: static public final int SENSOR_LIGHT
  ///
  /// A constant describing an ambient light sensor See
  /// android.hardware.SensorListener SensorListener for more details.
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const SENSOR_LIGHT = 16;

  /// from: static public final int SENSOR_MAGNETIC_FIELD
  ///
  /// A constant describing a magnetic sensor See
  /// android.hardware.SensorListener SensorListener for more details.
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const SENSOR_MAGNETIC_FIELD = 8;

  /// from: static public final int SENSOR_MAX
  ///
  /// Largest sensor ID
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const SENSOR_MAX = 64;

  /// from: static public final int SENSOR_MIN
  ///
  /// Smallest sensor ID
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const SENSOR_MIN = 1;

  /// from: static public final int SENSOR_ORIENTATION
  ///
  /// A constant describing an orientation sensor. See
  /// android.hardware.SensorListener SensorListener for more details.
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const SENSOR_ORIENTATION = 1;

  /// from: static public final int SENSOR_ORIENTATION_RAW
  ///
  /// A constant describing an orientation sensor. See
  /// android.hardware.SensorListener SensorListener for more details.
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const SENSOR_ORIENTATION_RAW = 128;

  /// from: static public final int SENSOR_PROXIMITY
  ///
  /// A constant describing a proximity sensor See
  /// android.hardware.SensorListener SensorListener for more details.
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const SENSOR_PROXIMITY = 32;

  /// from: static public final int SENSOR_STATUS_ACCURACY_HIGH
  ///
  /// This sensor is reporting data with maximum accuracy
  static const SENSOR_STATUS_ACCURACY_HIGH = 3;

  /// from: static public final int SENSOR_STATUS_ACCURACY_LOW
  ///
  /// This sensor is reporting data with low accuracy, calibration with the
  /// environment is needed
  static const SENSOR_STATUS_ACCURACY_LOW = 1;

  /// from: static public final int SENSOR_STATUS_ACCURACY_MEDIUM
  ///
  /// This sensor is reporting data with an average level of accuracy,
  /// calibration with the environment may improve the readings
  static const SENSOR_STATUS_ACCURACY_MEDIUM = 2;

  /// from: static public final int SENSOR_STATUS_NO_CONTACT
  ///
  /// The values returned by this sensor cannot be trusted because the sensor
  /// had no contact with what it was measuring (for example, the heart rate
  /// monitor is not in contact with the user).
  static const SENSOR_STATUS_NO_CONTACT = -1;

  /// from: static public final int SENSOR_STATUS_UNRELIABLE
  ///
  /// The values returned by this sensor cannot be trusted, calibration is
  /// needed or the environment doesn't allow readings
  static const SENSOR_STATUS_UNRELIABLE = 0;

  /// from: static public final int SENSOR_TEMPERATURE
  ///
  /// A constant describing a temperature sensor See
  /// android.hardware.SensorListener SensorListener for more details.
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const SENSOR_TEMPERATURE = 4;

  /// from: static public final int SENSOR_TRICORDER
  ///
  /// A constant describing a Tricorder See
  /// android.hardware.SensorListener SensorListener for more details.
  ///@deprecated use android.hardware.Sensor Sensor instead.
  static const SENSOR_TRICORDER = 64;

  /// from: static public final float STANDARD_GRAVITY
  ///
  /// Standard gravity (g) on Earth. This value is equivalent to 1G
  static const STANDARD_GRAVITY = 9.80665;

  static final _id_getSensors =
      jniAccessors.getMethodIDOf(_classRef, "getSensors", "()I");

  /// from: public int getSensors()
  ///
  /// @return available sensors.
  ///@deprecated This method is deprecated, use
  ///             SensorManager\#getSensorList(int) instead
  int getSensors() => jniAccessors.callMethodWithArgs(
      reference, _id_getSensors, jni.JniType.intType, []).integer;

  static final _id_getSensorList = jniAccessors.getMethodIDOf(
      _classRef, "getSensorList", "(I)Ljava/util/List;");

  /// from: public java.util.List<android.hardware.Sensor> getSensorList(int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Use this method to get the list of available sensors of a certain type.
  /// Make multiple calls to get sensors of different types or use
  /// android.hardware.Sensor\#TYPE_ALL Sensor.TYPE_ALL to get all the
  /// sensors.
  ///
  /// <p class="note">
  /// NOTE: Both wake-up and non wake-up sensors matching the given type are
  /// returned. Check Sensor\#isWakeUpSensor() to know the wake-up properties
  /// of the returned Sensor.
  ///
  ///
  ///@param type of sensors requested
  ///@return a list of sensors matching the asked type.
  ///@see \#getDefaultSensor(int)
  ///@see Sensor
  jni.JniObject getSensorList(int type) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSensorList, jni.JniType.objectType, [type]).object);

  static final _id_getDynamicSensorList = jniAccessors.getMethodIDOf(
      _classRef, "getDynamicSensorList", "(I)Ljava/util/List;");

  /// from: public java.util.List<android.hardware.Sensor> getDynamicSensorList(int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Use this method to get a list of available dynamic sensors of a certain type.
  /// Make multiple calls to get sensors of different types or use
  /// android.hardware.Sensor\#TYPE_ALL Sensor.TYPE_ALL to get all dynamic sensors.
  ///
  /// <p class="note">
  /// NOTE: Both wake-up and non wake-up sensors matching the given type are
  /// returned. Check Sensor\#isWakeUpSensor() to know the wake-up properties
  /// of the returned Sensor.
  ///
  ///
  ///@param type of sensors requested
  ///@return a list of dynamic sensors matching the requested type.
  ///@see Sensor
  jni.JniObject getDynamicSensorList(int type) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDynamicSensorList, jni.JniType.objectType, [type]).object);

  static final _id_getDefaultSensor = jniAccessors.getMethodIDOf(
      _classRef, "getDefaultSensor", "(I)Landroid/hardware/Sensor;");

  /// from: public android.hardware.Sensor getDefaultSensor(int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Use this method to get the default sensor for a given type. Note that the
  /// returned sensor could be a composite sensor, and its data could be
  /// averaged or filtered. If you need to access the raw sensors use
  /// SensorManager\#getSensorList(int) getSensorList.
  ///@param type of sensors requested
  ///@return the default sensor matching the requested type if one exists and the application
  ///         has the necessary permissions, or null otherwise.
  ///@see \#getSensorList(int)
  ///@see Sensor
  sensor_.Sensor getDefaultSensor(int type) =>
      sensor_.Sensor.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDefaultSensor, jni.JniType.objectType, [type]).object);

  static final _id_getDefaultSensor1 = jniAccessors.getMethodIDOf(
      _classRef, "getDefaultSensor", "(IZ)Landroid/hardware/Sensor;");

  /// from: public android.hardware.Sensor getDefaultSensor(int type, boolean wakeUp)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a Sensor with the given type and wakeUp properties. If multiple sensors of this
  /// type exist, any one of them may be returned.
  ///
  /// For example,
  /// <ul>
  ///     <li>getDefaultSensor(Sensor\#TYPE_ACCELEROMETER, true) returns a wake-up
  ///     accelerometer sensor if it exists. </li>
  ///     <li>getDefaultSensor(Sensor\#TYPE_PROXIMITY, false) returns a non wake-up
  ///     proximity sensor if it exists. </li>
  ///     <li>getDefaultSensor(Sensor\#TYPE_PROXIMITY, true) returns a wake-up proximity
  ///     sensor which is the same as the Sensor returned by \#getDefaultSensor(int). </li>
  /// </ul>
  ///
  ///
  /// <p class="note">
  /// Note: Sensors like Sensor\#TYPE_PROXIMITY and Sensor\#TYPE_SIGNIFICANT_MOTION
  /// are declared as wake-up sensors by default.
  ///
  ///
  ///@param type type of sensor requested
  ///@param wakeUp flag to indicate whether the Sensor is a wake-up or non wake-up sensor.
  ///@return the default sensor matching the requested type and wakeUp properties if one exists
  ///         and the application has the necessary permissions, or null otherwise.
  ///@see Sensor\#isWakeUpSensor()
  sensor_.Sensor getDefaultSensor1(int type, bool wakeUp) =>
      sensor_.Sensor.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getDefaultSensor1,
          jni.JniType.objectType,
          [type, wakeUp]).object);

  static final _id_registerListener = jniAccessors.getMethodIDOf(
      _classRef, "registerListener", "(Landroid/hardware/SensorListener;I)Z");

  /// from: public boolean registerListener(android.hardware.SensorListener listener, int sensors)
  ///
  /// Registers a listener for given sensors.
  ///@deprecated This method is deprecated, use
  ///             SensorManager\#registerListener(SensorEventListener, Sensor, int)
  ///             instead.
  ///@param listener sensor listener object
  ///@param sensors a bit masks of the sensors to register to
  ///@return <code>true</code> if the sensor is supported and successfully
  ///         enabled
  bool registerListener(sensorlistener_.SensorListener listener, int sensors) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerListener,
          jni.JniType.booleanType, [listener.reference, sensors]).boolean;

  static final _id_registerListener1 = jniAccessors.getMethodIDOf(
      _classRef, "registerListener", "(Landroid/hardware/SensorListener;II)Z");

  /// from: public boolean registerListener(android.hardware.SensorListener listener, int sensors, int rate)
  ///
  /// Registers a SensorListener for given sensors.
  ///@deprecated This method is deprecated, use
  ///             SensorManager\#registerListener(SensorEventListener, Sensor, int)
  ///             instead.
  ///@param listener sensor listener object
  ///@param sensors a bit masks of the sensors to register to
  ///@param rate rate of events. This is only a hint to the system. events may be
  ///        received faster or slower than the specified rate. Usually events
  ///        are received faster. The value must be one of
  ///        \#SENSOR_DELAY_NORMAL, \#SENSOR_DELAY_UI,
  ///        \#SENSOR_DELAY_GAME, or \#SENSOR_DELAY_FASTEST.
  ///@return <code>true</code> if the sensor is supported and successfully
  ///         enabled
  bool registerListener1(
          sensorlistener_.SensorListener listener, int sensors, int rate) =>
      jniAccessors.callMethodWithArgs(reference, _id_registerListener1,
          jni.JniType.booleanType, [listener.reference, sensors, rate]).boolean;

  static final _id_unregisterListener = jniAccessors.getMethodIDOf(
      _classRef, "unregisterListener", "(Landroid/hardware/SensorListener;)V");

  /// from: public void unregisterListener(android.hardware.SensorListener listener)
  ///
  /// Unregisters a listener for all sensors.
  ///@deprecated This method is deprecated, use
  ///             SensorManager\#unregisterListener(SensorEventListener)
  ///             instead.
  ///@param listener a SensorListener object
  void unregisterListener(sensorlistener_.SensorListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_unregisterListener1 = jniAccessors.getMethodIDOf(
      _classRef, "unregisterListener", "(Landroid/hardware/SensorListener;I)V");

  /// from: public void unregisterListener(android.hardware.SensorListener listener, int sensors)
  ///
  /// Unregisters a listener for the sensors with which it is registered.
  ///@deprecated This method is deprecated, use
  ///             SensorManager\#unregisterListener(SensorEventListener, Sensor)
  ///             instead.
  ///@param listener a SensorListener object
  ///@param sensors a bit masks of the sensors to unregister from
  void unregisterListener1(
          sensorlistener_.SensorListener listener, int sensors) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterListener1,
          jni.JniType.voidType, [listener.reference, sensors]).check();

  static final _id_unregisterListener2 = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterListener",
      "(Landroid/hardware/SensorEventListener;Landroid/hardware/Sensor;)V");

  /// from: public void unregisterListener(android.hardware.SensorEventListener listener, android.hardware.Sensor sensor)
  ///
  /// Unregisters a listener for the sensors with which it is registered.
  ///
  /// <p class="note">
  ///
  /// Note: Don't use this method with a one shot trigger sensor such as
  /// Sensor\#TYPE_SIGNIFICANT_MOTION.
  /// Use \#cancelTriggerSensor(TriggerEventListener, Sensor) instead.
  ///
  ///
  ///@param listener a SensorEventListener object
  ///@param sensor the sensor to unregister from
  ///@see \#unregisterListener(SensorEventListener)
  ///@see \#registerListener(SensorEventListener, Sensor, int)
  void unregisterListener2(sensoreventlistener_.SensorEventListener listener,
          sensor_.Sensor sensor) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterListener2,
          jni.JniType.voidType, [listener.reference, sensor.reference]).check();

  static final _id_unregisterListener3 = jniAccessors.getMethodIDOf(_classRef,
      "unregisterListener", "(Landroid/hardware/SensorEventListener;)V");

  /// from: public void unregisterListener(android.hardware.SensorEventListener listener)
  ///
  /// Unregisters a listener for all sensors.
  ///@param listener a SensorListener object
  ///@see \#unregisterListener(SensorEventListener, Sensor)
  ///@see \#registerListener(SensorEventListener, Sensor, int)
  void unregisterListener3(sensoreventlistener_.SensorEventListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_unregisterListener3,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_registerListener2 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerListener",
      "(Landroid/hardware/SensorEventListener;Landroid/hardware/Sensor;I)Z");

  /// from: public boolean registerListener(android.hardware.SensorEventListener listener, android.hardware.Sensor sensor, int samplingPeriodUs)
  ///
  /// Registers a android.hardware.SensorEventListener SensorEventListener for the given
  /// sensor at the given sampling frequency.
  ///
  /// The events will be delivered to the provided {@code SensorEventListener} as soon as they are
  /// available. To reduce the power consumption, applications can use
  /// \#registerListener(SensorEventListener, Sensor, int, int) instead and specify a
  /// positive non-zero maximum reporting latency.
  ///
  ///
  ///
  /// In the case of non-wake-up sensors, the events are only delivered while the Application
  /// Processor (AP) is not in suspend mode. See Sensor\#isWakeUpSensor() for more details.
  /// To ensure delivery of events from non-wake-up sensors even when the screen is OFF, the
  /// application registering to the sensor must hold a partial wake-lock to keep the AP awake,
  /// otherwise some events might be lost while the AP is asleep. Note that although events might
  /// be lost while the AP is asleep, the sensor will still consume power if it is not explicitly
  /// deactivated by the application. Applications must unregister their {@code
  /// SensorEventListener}s in their activity's {@code onPause()} method to avoid consuming power
  /// while the device is inactive.  See \#registerListener(SensorEventListener, Sensor, int,
  /// int) for more details on hardware FIFO (queueing) capabilities and when some sensor events
  /// might be lost.
  ///
  ///
  ///
  /// In the case of wake-up sensors, each event generated by the sensor will cause the AP to
  /// wake-up, ensuring that each event can be delivered. Because of this, registering to a wake-up
  /// sensor has very significant power implications. Call Sensor\#isWakeUpSensor() to check
  /// whether a sensor is a wake-up sensor. See
  /// \#registerListener(SensorEventListener, Sensor, int, int) for information on how to
  /// reduce the power impact of registering to wake-up sensors.
  ///
  ///
  /// <p class="note">
  /// Note: Don't use this method with one-shot trigger sensors such as
  /// Sensor\#TYPE_SIGNIFICANT_MOTION. Use
  /// \#requestTriggerSensor(TriggerEventListener, Sensor) instead. Use
  /// Sensor\#getReportingMode() to obtain the reporting mode of a given sensor.
  ///
  ///
  ///@param listener A android.hardware.SensorEventListener SensorEventListener object.
  ///@param sensor The android.hardware.Sensor Sensor to register to.
  ///@param samplingPeriodUs The rate android.hardware.SensorEvent sensor events are
  ///            delivered at. This is only a hint to the system. Events may be received faster or
  ///            slower than the specified rate. Usually events are received faster. The value must
  ///            be one of \#SENSOR_DELAY_NORMAL, \#SENSOR_DELAY_UI,
  ///            \#SENSOR_DELAY_GAME, or \#SENSOR_DELAY_FASTEST or, the desired delay
  ///            between events in microseconds. Specifying the delay in microseconds only works
  ///            from Android 2.3 (API level 9) onwards. For earlier releases, you must use one of
  ///            the {@code SENSOR_DELAY_*} constants.
  ///@return <code>true</code> if the sensor is supported and successfully enabled.
  ///@see \#registerListener(SensorEventListener, Sensor, int, Handler)
  ///@see \#unregisterListener(SensorEventListener)
  ///@see \#unregisterListener(SensorEventListener, Sensor)
  bool registerListener2(sensoreventlistener_.SensorEventListener listener,
          sensor_.Sensor sensor, int samplingPeriodUs) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerListener2,
          jni.JniType.booleanType,
          [listener.reference, sensor.reference, samplingPeriodUs]).boolean;

  static final _id_registerListener3 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerListener",
      "(Landroid/hardware/SensorEventListener;Landroid/hardware/Sensor;II)Z");

  /// from: public boolean registerListener(android.hardware.SensorEventListener listener, android.hardware.Sensor sensor, int samplingPeriodUs, int maxReportLatencyUs)
  ///
  /// Registers a android.hardware.SensorEventListener SensorEventListener for the given
  /// sensor at the given sampling frequency and the given maximum reporting latency.
  ///
  /// This function is similar to \#registerListener(SensorEventListener, Sensor, int) but
  /// it allows events to stay temporarily in the hardware FIFO (queue) before being delivered. The
  /// events can be stored in the hardware FIFO up to {@code maxReportLatencyUs} microseconds. Once
  /// one of the events in the FIFO needs to be reported, all of the events in the FIFO are
  /// reported sequentially. This means that some events will be reported before the maximum
  /// reporting latency has elapsed.
  ///
  ///
  /// When {@code maxReportLatencyUs} is 0, the call is equivalent to a call to
  /// \#registerListener(SensorEventListener, Sensor, int), as it requires the events to be
  /// delivered as soon as possible.
  ///
  ///
  /// When {@code sensor.maxFifoEventCount()} is 0, the sensor does not use a FIFO, so the call
  /// will also be equivalent to \#registerListener(SensorEventListener, Sensor, int).
  ///
  ///
  /// Setting {@code maxReportLatencyUs} to a positive value allows to reduce the number of
  /// interrupts the AP (Application Processor) receives, hence reducing power consumption, as the
  /// AP can switch to a lower power state while the sensor is capturing the data. This is
  /// especially important when registering to wake-up sensors, for which each interrupt causes the
  /// AP to wake up if it was in suspend mode. See Sensor\#isWakeUpSensor() for more
  /// information on wake-up sensors.
  ///
  ///
  /// <p class="note">
  ///
  ///
  /// Note: Don't use this method with one-shot trigger sensors such as
  /// Sensor\#TYPE_SIGNIFICANT_MOTION. Use
  /// \#requestTriggerSensor(TriggerEventListener, Sensor) instead.
  ///
  ///@param listener A android.hardware.SensorEventListener SensorEventListener object
  ///            that will receive the sensor events. If the application is interested in receiving
  ///            flush complete notifications, it should register with
  ///            android.hardware.SensorEventListener SensorEventListener2 instead.
  ///@param sensor The android.hardware.Sensor Sensor to register to.
  ///@param samplingPeriodUs The desired delay between two consecutive events in microseconds.
  ///            This is only a hint to the system. Events may be received faster or slower than
  ///            the specified rate. Usually events are received faster. Can be one of
  ///            \#SENSOR_DELAY_NORMAL, \#SENSOR_DELAY_UI,
  ///            \#SENSOR_DELAY_GAME, \#SENSOR_DELAY_FASTEST or the delay in
  ///            microseconds.
  ///@param maxReportLatencyUs Maximum time in microseconds that events can be delayed before
  ///            being reported to the application. A large value allows reducing the power
  ///            consumption associated with the sensor. If maxReportLatencyUs is set to zero,
  ///            events are delivered as soon as they are available, which is equivalent to calling
  ///            \#registerListener(SensorEventListener, Sensor, int).
  ///@return <code>true</code> if the sensor is supported and successfully enabled.
  ///@see \#registerListener(SensorEventListener, Sensor, int)
  ///@see \#unregisterListener(SensorEventListener)
  ///@see \#flush(SensorEventListener)
  bool registerListener3(
          sensoreventlistener_.SensorEventListener listener,
          sensor_.Sensor sensor,
          int samplingPeriodUs,
          int maxReportLatencyUs) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_registerListener3, jni.JniType.booleanType, [
        listener.reference,
        sensor.reference,
        samplingPeriodUs,
        maxReportLatencyUs
      ]).boolean;

  static final _id_registerListener4 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerListener",
      "(Landroid/hardware/SensorEventListener;Landroid/hardware/Sensor;ILandroid/os/Handler;)Z");

  /// from: public boolean registerListener(android.hardware.SensorEventListener listener, android.hardware.Sensor sensor, int samplingPeriodUs, android.os.Handler handler)
  ///
  /// Registers a android.hardware.SensorEventListener SensorEventListener for the given
  /// sensor. Events are delivered in continuous mode as soon as they are available. To reduce the
  /// power consumption, applications can use
  /// \#registerListener(SensorEventListener, Sensor, int, int) instead and specify a
  /// positive non-zero maximum reporting latency.
  /// <p class="note">
  ///
  ///
  /// Note: Don't use this method with a one shot trigger sensor such as
  /// Sensor\#TYPE_SIGNIFICANT_MOTION. Use
  /// \#requestTriggerSensor(TriggerEventListener, Sensor) instead.
  ///
  ///@param listener A android.hardware.SensorEventListener SensorEventListener object.
  ///@param sensor The android.hardware.Sensor Sensor to register to.
  ///@param samplingPeriodUs The rate android.hardware.SensorEvent sensor events are
  ///            delivered at. This is only a hint to the system. Events may be received faster or
  ///            slower than the specified rate. Usually events are received faster. The value must
  ///            be one of \#SENSOR_DELAY_NORMAL, \#SENSOR_DELAY_UI,
  ///            \#SENSOR_DELAY_GAME, or \#SENSOR_DELAY_FASTEST or, the desired
  ///            delay between events in microseconds. Specifying the delay in microseconds only
  ///            works from Android 2.3 (API level 9) onwards. For earlier releases, you must use
  ///            one of the {@code SENSOR_DELAY_*} constants.
  ///@param handler The android.os.Handler Handler the android.hardware.SensorEvent sensor events will be delivered to.
  ///@return <code>true</code> if the sensor is supported and successfully enabled.
  ///@see \#registerListener(SensorEventListener, Sensor, int)
  ///@see \#unregisterListener(SensorEventListener)
  ///@see \#unregisterListener(SensorEventListener, Sensor)
  bool registerListener4(
          sensoreventlistener_.SensorEventListener listener,
          sensor_.Sensor sensor,
          int samplingPeriodUs,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_registerListener4, jni.JniType.booleanType, [
        listener.reference,
        sensor.reference,
        samplingPeriodUs,
        handler.reference
      ]).boolean;

  static final _id_registerListener5 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerListener",
      "(Landroid/hardware/SensorEventListener;Landroid/hardware/Sensor;IILandroid/os/Handler;)Z");

  /// from: public boolean registerListener(android.hardware.SensorEventListener listener, android.hardware.Sensor sensor, int samplingPeriodUs, int maxReportLatencyUs, android.os.Handler handler)
  ///
  /// Registers a android.hardware.SensorEventListener SensorEventListener for the given
  /// sensor at the given sampling frequency and the given maximum reporting latency.
  ///@param listener A android.hardware.SensorEventListener SensorEventListener object
  ///            that will receive the sensor events. If the application is interested in receiving
  ///            flush complete notifications, it should register with
  ///            android.hardware.SensorEventListener SensorEventListener2 instead.
  ///@param sensor The android.hardware.Sensor Sensor to register to.
  ///@param samplingPeriodUs The desired delay between two consecutive events in microseconds.
  ///            This is only a hint to the system. Events may be received faster or slower than
  ///            the specified rate. Usually events are received faster. Can be one of
  ///            \#SENSOR_DELAY_NORMAL, \#SENSOR_DELAY_UI,
  ///            \#SENSOR_DELAY_GAME, \#SENSOR_DELAY_FASTEST or the delay in
  ///            microseconds.
  ///@param maxReportLatencyUs Maximum time in microseconds that events can be delayed before
  ///            being reported to the application. A large value allows reducing the power
  ///            consumption associated with the sensor. If maxReportLatencyUs is set to zero,
  ///            events are delivered as soon as they are available, which is equivalent to calling
  ///            \#registerListener(SensorEventListener, Sensor, int).
  ///@param handler The android.os.Handler Handler the android.hardware.SensorEvent sensor events will be delivered to.
  ///@return <code>true</code> if the sensor is supported and successfully enabled.
  ///@see \#registerListener(SensorEventListener, Sensor, int, int)
  bool registerListener5(
          sensoreventlistener_.SensorEventListener listener,
          sensor_.Sensor sensor,
          int samplingPeriodUs,
          int maxReportLatencyUs,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_registerListener5, jni.JniType.booleanType, [
        listener.reference,
        sensor.reference,
        samplingPeriodUs,
        maxReportLatencyUs,
        handler.reference
      ]).boolean;

  static final _id_flush = jniAccessors.getMethodIDOf(
      _classRef, "flush", "(Landroid/hardware/SensorEventListener;)Z");

  /// from: public boolean flush(android.hardware.SensorEventListener listener)
  ///
  /// Flushes the FIFO of all the sensors registered for this listener. If there are events
  /// in the FIFO of the sensor, they are returned as if the maxReportLantecy of the FIFO has
  /// expired. Events are returned in the usual way through the SensorEventListener.
  /// This call doesn't affect the maxReportLantecy for this sensor. This call is asynchronous and
  /// returns immediately.
  /// android.hardware.SensorEventListener2\#onFlushCompleted onFlushCompleted is called
  /// after all the events in the batch at the time of calling this method have been delivered
  /// successfully. If the hardware doesn't support flush, it still returns true and a trivial
  /// flush complete event is sent after the current event for all the clients registered for this
  /// sensor.
  ///@param listener A android.hardware.SensorEventListener SensorEventListener object
  ///        which was previously used in a registerListener call.
  ///@return <code>true</code> if the flush is initiated successfully on all the sensors
  ///         registered for this listener, false if no sensor is previously registered for this
  ///         listener or flush on one of the sensors fails.
  ///@see \#registerListener(SensorEventListener, Sensor, int, int)
  ///@throws IllegalArgumentException when listener is null.
  bool flush(sensoreventlistener_.SensorEventListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_flush,
          jni.JniType.booleanType, [listener.reference]).boolean;

  static final _id_createDirectChannel = jniAccessors.getMethodIDOf(
      _classRef,
      "createDirectChannel",
      "(Landroid/os/MemoryFile;)Landroid/hardware/SensorDirectChannel;");

  /// from: public android.hardware.SensorDirectChannel createDirectChannel(android.os.MemoryFile mem)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a sensor direct channel backed by shared memory wrapped in MemoryFile object.
  ///
  /// The resulting channel can be used for delivering sensor events to native code, other
  /// processes, GPU/DSP or other co-processors without CPU intervention. This is the recommanded
  /// for high performance sensor applications that use high sensor rates (e.g. greater than 200Hz)
  /// and cares about sensor event latency.
  ///
  /// Use the returned android.hardware.SensorDirectChannel object to configure direct
  /// report of sensor events. After use, call android.hardware.SensorDirectChannel\#close()
  /// to free up resource in sensor system associated with the direct channel.
  ///@param mem A android.os.MemoryFile shared memory object.
  ///@return A android.hardware.SensorDirectChannel object.
  ///@throws NullPointerException when mem is null.
  ///@throws UncheckedIOException if not able to create channel.
  ///@see SensorDirectChannel\#close()
  ///@see \#configureDirectChannel(SensorDirectChannel, Sensor, int)
  sensordirectchannel_.SensorDirectChannel createDirectChannel(
          memoryfile_.MemoryFile mem) =>
      sensordirectchannel_.SensorDirectChannel.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_createDirectChannel,
              jni.JniType.objectType, [mem.reference]).object);

  static final _id_createDirectChannel1 = jniAccessors.getMethodIDOf(
      _classRef,
      "createDirectChannel",
      "(Landroid/hardware/HardwareBuffer;)Landroid/hardware/SensorDirectChannel;");

  /// from: public android.hardware.SensorDirectChannel createDirectChannel(android.hardware.HardwareBuffer mem)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a sensor direct channel backed by shared memory wrapped in HardwareBuffer object.
  ///
  /// The resulting channel can be used for delivering sensor events to native code, other
  /// processes, GPU/DSP or other co-processors without CPU intervention. This is the recommanded
  /// for high performance sensor applications that use high sensor rates (e.g. greater than 200Hz)
  /// and cares about sensor event latency.
  ///
  /// Use the returned android.hardware.SensorDirectChannel object to configure direct
  /// report of sensor events. After use, call android.hardware.SensorDirectChannel\#close()
  /// to free up resource in sensor system associated with the direct channel.
  ///@param mem A android.hardware.HardwareBuffer shared memory object.
  ///@return A android.hardware.SensorDirectChannel object.
  ///@throws NullPointerException when mem is null.
  ///@throws UncheckedIOException if not able to create channel.
  ///@see SensorDirectChannel\#close()
  ///@see \#configureDirectChannel(SensorDirectChannel, Sensor, int)
  sensordirectchannel_.SensorDirectChannel createDirectChannel1(
          hardwarebuffer_.HardwareBuffer mem) =>
      sensordirectchannel_.SensorDirectChannel.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_createDirectChannel1,
              jni.JniType.objectType, [mem.reference]).object);

  static final _id_registerDynamicSensorCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "registerDynamicSensorCallback",
      "(Landroid/hardware/SensorManager\$DynamicSensorCallback;)V");

  /// from: public void registerDynamicSensorCallback(android.hardware.SensorManager.DynamicSensorCallback callback)
  ///
  /// Add a android.hardware.SensorManager.DynamicSensorCallback DynamicSensorCallback to receive dynamic sensor connection callbacks. Repeat
  /// registration with the already registered callback object will have no additional effect.
  ///@param callback An object that implements the
  ///        android.hardware.SensorManager.DynamicSensorCallback DynamicSensorCallback
  ///        interface for receiving callbacks.
  ///@see \#addDynamicSensorCallback(DynamicSensorCallback, Handler)
  ///@throws IllegalArgumentException when callback is null.
  void registerDynamicSensorCallback(
          SensorManager_DynamicSensorCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerDynamicSensorCallback,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_registerDynamicSensorCallback1 = jniAccessors.getMethodIDOf(
      _classRef,
      "registerDynamicSensorCallback",
      "(Landroid/hardware/SensorManager\$DynamicSensorCallback;Landroid/os/Handler;)V");

  /// from: public void registerDynamicSensorCallback(android.hardware.SensorManager.DynamicSensorCallback callback, android.os.Handler handler)
  ///
  /// Add a android.hardware.SensorManager.DynamicSensorCallback DynamicSensorCallback to receive dynamic sensor connection callbacks. Repeat
  /// registration with the already registered callback object will have no additional effect.
  ///@param callback An object that implements the
  ///        android.hardware.SensorManager.DynamicSensorCallback DynamicSensorCallback interface for receiving callbacks.
  ///@param handler The android.os.Handler Handler the android.hardware.SensorManager.DynamicSensorCallback sensor connection events will be delivered to.
  ///@throws IllegalArgumentException when callback is null.
  void registerDynamicSensorCallback1(
          SensorManager_DynamicSensorCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_registerDynamicSensorCallback1,
          jni.JniType.voidType,
          [callback.reference, handler.reference]).check();

  static final _id_unregisterDynamicSensorCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "unregisterDynamicSensorCallback",
      "(Landroid/hardware/SensorManager\$DynamicSensorCallback;)V");

  /// from: public void unregisterDynamicSensorCallback(android.hardware.SensorManager.DynamicSensorCallback callback)
  ///
  /// Remove a android.hardware.SensorManager.DynamicSensorCallback DynamicSensorCallback to stop sending dynamic sensor connection events to that
  /// callback.
  ///@param callback An object that implements the
  ///        android.hardware.SensorManager.DynamicSensorCallback DynamicSensorCallback
  ///        interface for receiving callbacks.
  void unregisterDynamicSensorCallback(
          SensorManager_DynamicSensorCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_unregisterDynamicSensorCallback,
          jni.JniType.voidType,
          [callback.reference]).check();

  static final _id_isDynamicSensorDiscoverySupported = jniAccessors
      .getMethodIDOf(_classRef, "isDynamicSensorDiscoverySupported", "()Z");

  /// from: public boolean isDynamicSensorDiscoverySupported()
  ///
  /// Tell if dynamic sensor discovery feature is supported by system.
  ///@return <code>true</code> if dynamic sensor discovery is supported, <code>false</code>
  /// otherwise.
  bool isDynamicSensorDiscoverySupported() => jniAccessors.callMethodWithArgs(
      reference,
      _id_isDynamicSensorDiscoverySupported,
      jni.JniType.booleanType, []).boolean;

  static final _id_getRotationMatrix = jniAccessors.getStaticMethodIDOf(
      _classRef, "getRotationMatrix", "([F[F[F[F)Z");

  /// from: static public boolean getRotationMatrix(float[] R, float[] I, float[] gravity, float[] geomagnetic)
  ///
  ///
  /// Computes the inclination matrix __I__ as well as the rotation matrix
  /// __R__ transforming a vector from the device coordinate system to the
  /// world's coordinate system which is defined as a direct orthonormal basis,
  /// where:
  ///
  ///
  ///
  /// <ul>
  /// <li>X is defined as the vector product __Y.Z__ (It is tangential to
  /// the ground at the device's current location and roughly points East).</li>
  /// <li>Y is tangential to the ground at the device's current location and
  /// points towards the magnetic North Pole.</li>
  /// <li>Z points towards the sky and is perpendicular to the ground.</li>
  /// </ul>
  ///
  ///
  /// <center><img src="../../../images/axis_globe.png"alt="World coordinate-system diagram."border="0"/></center>
  ///
  ///
  ///
  ///
  /// <hr>
  ///
  /// By definition:
  ///
  /// [0 0 g] = __R__ * __gravity__ (g = magnitude of gravity)
  ///
  /// [0 m 0] = __I__ * __R__ * __geomagnetic__ (m = magnitude of
  /// geomagnetic field)
  ///
  /// __R__ is the identity matrix when the device is aligned with the
  /// world's coordinate system, that is, when the device's X axis points
  /// toward East, the Y axis points to the North Pole and the device is facing
  /// the sky.
  ///
  ///
  /// __I__ is a rotation matrix transforming the geomagnetic vector into
  /// the same coordinate space as gravity (the world's coordinate space).
  /// __I__ is a simple rotation around the X axis. The inclination angle in
  /// radians can be computed with \#getInclination.
  /// <hr>
  ///
  ///
  /// Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending
  /// on the length of the passed array:
  ///
  /// <u>If the array length is 16:</u>
  ///
  /// <pre>
  ///   /  M[ 0]   M[ 1]   M[ 2]   M[ 3]  \
  ///   |  M[ 4]   M[ 5]   M[ 6]   M[ 7]  |
  ///   |  M[ 8]   M[ 9]   M[10]   M[11]  |
  ///   \  M[12]   M[13]   M[14]   M[15]  /
  ///</pre>
  ///
  /// This matrix is ready to be used by OpenGL ES's
  /// javax.microedition.khronos.opengles.GL10\#glLoadMatrixf(float[], int) glLoadMatrixf(float[], int).
  ///
  /// Note that because OpenGL matrices are column-major matrices you must
  /// transpose the matrix before using it. However, since the matrix is a
  /// rotation matrix, its transpose is also its inverse, conveniently, it is
  /// often the inverse of the rotation that is needed for rendering; it can
  /// therefore be used with OpenGL ES directly.
  ///
  /// Also note that the returned matrices always have this form:
  ///
  /// <pre>
  ///   /  M[ 0]   M[ 1]   M[ 2]   0  \
  ///   |  M[ 4]   M[ 5]   M[ 6]   0  |
  ///   |  M[ 8]   M[ 9]   M[10]   0  |
  ///   \      0       0       0   1  /
  ///</pre>
  ///
  ///
  /// <u>If the array length is 9:</u>
  ///
  /// <pre>
  ///   /  M[ 0]   M[ 1]   M[ 2]  \
  ///   |  M[ 3]   M[ 4]   M[ 5]  |
  ///   \  M[ 6]   M[ 7]   M[ 8]  /
  ///</pre>
  ///
  /// <hr>
  ///
  /// The inverse of each matrix can be computed easily by taking its
  /// transpose.
  ///
  ///
  /// The matrices returned by this function are meaningful only when the
  /// device is not free-falling and it is not close to the magnetic north. If
  /// the device is accelerating, or placed into a strong magnetic field, the
  /// returned matrices may be inaccurate.
  ///@param R is an array of 9 floats holding the rotation matrix __R__ when
  ///        this function returns. R can be null.
  ///
  ///@param I is an array of 9 floats holding the rotation matrix __I__ when
  ///        this function returns. I can be null.
  ///
  ///@param gravity is an array of 3 floats containing the gravity vector expressed in
  ///        the device's coordinate. You can simply use the
  ///        android.hardware.SensorEvent\#values values returned by a
  ///        android.hardware.SensorEvent SensorEvent of a
  ///        android.hardware.Sensor Sensor of type
  ///        android.hardware.Sensor\#TYPE_ACCELEROMETER TYPE_ACCELEROMETER.
  ///
  ///@param geomagnetic is an array of 3 floats containing the geomagnetic vector
  ///        expressed in the device's coordinate. You can simply use the
  ///        android.hardware.SensorEvent\#values values returned by a
  ///        android.hardware.SensorEvent SensorEvent of a
  ///        android.hardware.Sensor Sensor of type
  ///        android.hardware.Sensor\#TYPE_MAGNETIC_FIELD TYPE_MAGNETIC_FIELD.
  ///@return <code>true</code> on success, <code>false</code> on failure (for
  ///         instance, if the device is in free fall). Free fall is defined as
  ///         condition when the magnitude of the gravity is less than 1/10 of
  ///         the nominal value. On failure the output matrices are not modified.
  ///@see \#getInclination(float[])
  ///@see \#getOrientation(float[], float[])
  ///@see \#remapCoordinateSystem(float[], int, int, float[])
  static bool getRotationMatrix(jni.JniObject R, jni.JniObject I,
          jni.JniObject gravity, jni.JniObject geomagnetic) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getRotationMatrix, jni.JniType.booleanType, [
        R.reference,
        I.reference,
        gravity.reference,
        geomagnetic.reference
      ]).boolean;

  static final _id_getInclination =
      jniAccessors.getStaticMethodIDOf(_classRef, "getInclination", "([F)F");

  /// from: static public float getInclination(float[] I)
  ///
  /// Computes the geomagnetic inclination angle in radians from the
  /// inclination matrix __I__ returned by \#getRotationMatrix.
  ///@param I inclination matrix see \#getRotationMatrix.
  ///@return The geomagnetic inclination angle in radians.
  ///@see \#getRotationMatrix(float[], float[], float[], float[])
  ///@see \#getOrientation(float[], float[])
  ///@see GeomagneticField
  static double getInclination(jni.JniObject I) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_getInclination,
          jni.JniType.floatType, [I.reference]).float;

  static final _id_remapCoordinateSystem = jniAccessors.getStaticMethodIDOf(
      _classRef, "remapCoordinateSystem", "([FII[F)Z");

  /// from: static public boolean remapCoordinateSystem(float[] inR, int X, int Y, float[] outR)
  ///
  ///
  /// Rotates the supplied rotation matrix so it is expressed in a different
  /// coordinate system. This is typically used when an application needs to
  /// compute the three orientation angles of the device (see
  /// \#getOrientation) in a different coordinate system.
  ///
  ///
  ///
  ///
  /// When the rotation matrix is used for drawing (for instance with OpenGL
  /// ES), it usually __doesn't need__ to be transformed by this function,
  /// unless the screen is physically rotated, in which case you can use
  /// android.view.Display\#getRotation() Display.getRotation() to
  /// retrieve the current rotation of the screen. Note that because the user
  /// is generally free to rotate their screen, you often should consider the
  /// rotation in deciding the parameters to use here.
  ///
  ///
  ///
  ///
  /// <u>Examples:</u>
  ///
  ///
  /// <ul>
  /// <li>Using the camera (Y axis along the camera's axis) for an augmented
  /// reality application where the rotation angles are needed:</li>
  ///
  ///
  /// <ul>
  /// <code>remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR);</code>
  /// </ul>
  ///
  ///
  ///
  /// <li>Using the device as a mechanical compass when rotation is
  /// android.view.Surface\#ROTATION_90 Surface.ROTATION_90:</li>
  ///
  ///
  /// <ul>
  /// <code>remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR);</code>
  /// </ul>
  ///
  ///
  ///
  /// Beware of the above example. This call is needed only to account for a
  /// rotation from its natural orientation when calculating the rotation
  /// angles (see \#getOrientation). If the rotation matrix is also used
  /// for rendering, it may not need to be transformed, for instance if your
  /// android.app.Activity Activity is running in landscape mode.
  /// </ul>
  ///
  ///
  /// Since the resulting coordinate system is orthonormal, only two axes need
  /// to be specified.
  ///@param inR the rotation matrix to be transformed. Usually it is the matrix
  ///        returned by \#getRotationMatrix.
  ///@param X defines the axis of the new cooridinate system that coincide with the X axis of the
  ///        original coordinate system.
  ///@param Y defines the axis of the new cooridinate system that coincide with the Y axis of the
  ///        original coordinate system.
  ///@param outR the transformed rotation matrix. inR and outR should not be the same
  ///        array.
  ///@return <code>true</code> on success. <code>false</code> if the input
  ///         parameters are incorrect, for instance if X and Y define the same
  ///         axis. Or if inR and outR don't have the same length.
  ///@see \#getRotationMatrix(float[], float[], float[], float[])
  static bool remapCoordinateSystem(
          jni.JniObject inR, int X, int Y, jni.JniObject outR) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_remapCoordinateSystem,
          jni.JniType.booleanType,
          [inR.reference, X, Y, outR.reference]).boolean;

  static final _id_getOrientation =
      jniAccessors.getStaticMethodIDOf(_classRef, "getOrientation", "([F[F)[F");

  /// from: static public float[] getOrientation(float[] R, float[] values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Computes the device's orientation based on the rotation matrix.
  ///
  /// When it returns, the array values are as follows:
  /// <ul>
  /// <li>values[0]: <i>Azimuth</i>, angle of rotation about the -z axis.
  ///                This value represents the angle between the device's y
  ///                axis and the magnetic north pole. When facing north, this
  ///                angle is 0, when facing south, this angle is &pi;.
  ///                Likewise, when facing east, this angle is &pi;/2, and
  ///                when facing west, this angle is -&pi;/2. The range of
  ///                values is -&pi; to &pi;.</li>
  /// <li>values[1]: <i>Pitch</i>, angle of rotation about the x axis.
  ///                This value represents the angle between a plane parallel
  ///                to the device's screen and a plane parallel to the ground.
  ///                Assuming that the bottom edge of the device faces the
  ///                user and that the screen is face-up, tilting the top edge
  ///                of the device toward the ground creates a positive pitch
  ///                angle. The range of values is -&pi; to &pi;.</li>
  /// <li>values[2]: <i>Roll</i>, angle of rotation about the y axis. This
  ///                value represents the angle between a plane perpendicular
  ///                to the device's screen and a plane perpendicular to the
  ///                ground. Assuming that the bottom edge of the device faces
  ///                the user and that the screen is face-up, tilting the left
  ///                edge of the device toward the ground creates a positive
  ///                roll angle. The range of values is -&pi;/2 to &pi;/2.</li>
  /// </ul>
  ///
  /// Applying these three rotations in the azimuth, pitch, roll order
  /// transforms an identity matrix to the rotation matrix passed into this
  /// method. Also, note that all three orientation angles are expressed in
  /// __radians__.
  ///@param R rotation matrix see \#getRotationMatrix.
  ///@param values an array of 3 floats to hold the result.
  ///@return The array values passed as argument.
  ///@see \#getRotationMatrix(float[], float[], float[], float[])
  ///@see GeomagneticField
  static jni.JniObject getOrientation(jni.JniObject R, jni.JniObject values) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getOrientation,
          jni.JniType.objectType,
          [R.reference, values.reference]).object);

  static final _id_getAltitude =
      jniAccessors.getStaticMethodIDOf(_classRef, "getAltitude", "(FF)F");

  /// from: static public float getAltitude(float p0, float p)
  ///
  /// Computes the Altitude in meters from the atmospheric pressure and the
  /// pressure at sea level.
  ///
  /// Typically the atmospheric pressure is read from a
  /// Sensor\#TYPE_PRESSURE sensor. The pressure at sea level must be
  /// known, usually it can be retrieved from airport databases in the
  /// vicinity. If unknown, you can use \#PRESSURE_STANDARD_ATMOSPHERE
  /// as an approximation, but absolute altitudes won't be accurate.
  ///
  ///
  ///
  /// To calculate altitude differences, you must calculate the difference
  /// between the altitudes at both points. If you don't know the altitude
  /// as sea level, you can use \#PRESSURE_STANDARD_ATMOSPHERE instead,
  /// which will give good results considering the range of pressure typically
  /// involved.
  ///
  ///
  ///
  /// <code><ul>
  ///  float altitude_difference =
  ///      getAltitude(SensorManager.PRESSURE_STANDARD_ATMOSPHERE, pressure_at_point2)
  ///      - getAltitude(SensorManager.PRESSURE_STANDARD_ATMOSPHERE, pressure_at_point1);
  /// </ul></code>
  ///
  ///
  ///@param p0 pressure at sea level
  ///@param p atmospheric pressure
  ///@return Altitude in meters
  static double getAltitude(double p0, double p) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getAltitude, jni.JniType.floatType, [p0, p]).float;

  static final _id_getAngleChange = jniAccessors.getStaticMethodIDOf(
      _classRef, "getAngleChange", "([F[F[F)V");

  /// from: static public void getAngleChange(float[] angleChange, float[] R, float[] prevR)
  ///
  /// Helper function to compute the angle change between two rotation matrices.
  ///  Given a current rotation matrix (R) and a previous rotation matrix
  ///  (prevR) computes the intrinsic rotation around the z, x, and y axes which
  ///  transforms prevR to R.
  ///  outputs a 3 element vector containing the z, x, and y angle
  ///  change at indexes 0, 1, and 2 respectively.
  ///  Each input matrix is either as a 3x3 or 4x4 row-major matrix
  /// depending on the length of the passed array:
  /// If the array length is 9, then the array elements represent this matrix
  /// <pre>
  ///   /  R[ 0]   R[ 1]   R[ 2]   \
  ///   |  R[ 3]   R[ 4]   R[ 5]   |
  ///   \  R[ 6]   R[ 7]   R[ 8]   /
  ///</pre>
  /// If the array length is 16, then the array elements represent this matrix
  /// <pre>
  ///   /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \
  ///   |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  |
  ///   |  R[ 8]   R[ 9]   R[10]   R[11]  |
  ///   \  R[12]   R[13]   R[14]   R[15]  /
  ///</pre>
  ///
  /// See \#getOrientation for more detailed definition of the output.
  ///@param R current rotation matrix
  ///@param prevR previous rotation matrix
  ///@param angleChange an an array of floats (z, x, and y) in which the angle change
  ///        (in radians) is stored
  static void getAngleChange(
          jni.JniObject angleChange, jni.JniObject R, jni.JniObject prevR) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getAngleChange,
          jni.JniType.voidType,
          [angleChange.reference, R.reference, prevR.reference]).check();

  static final _id_getRotationMatrixFromVector = jniAccessors
      .getStaticMethodIDOf(_classRef, "getRotationMatrixFromVector", "([F[F)V");

  /// from: static public void getRotationMatrixFromVector(float[] R, float[] rotationVector)
  ///
  /// Helper function to convert a rotation vector to a rotation matrix.
  ///  Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a
  ///  9  or 16 element rotation matrix in the array R.  R must have length 9 or 16.
  ///  If R.length == 9, the following matrix is returned:
  /// <pre>
  ///   /  R[ 0]   R[ 1]   R[ 2]   \
  ///   |  R[ 3]   R[ 4]   R[ 5]   |
  ///   \  R[ 6]   R[ 7]   R[ 8]   /
  ///</pre>
  /// If R.length == 16, the following matrix is returned:
  /// <pre>
  ///   /  R[ 0]   R[ 1]   R[ 2]   0  \
  ///   |  R[ 4]   R[ 5]   R[ 6]   0  |
  ///   |  R[ 8]   R[ 9]   R[10]   0  |
  ///   \  0       0       0       1  /
  ///</pre>
  ///@param rotationVector the rotation vector to convert
  ///@param R an array of floats in which to store the rotation matrix
  static void getRotationMatrixFromVector(
          jni.JniObject R, jni.JniObject rotationVector) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getRotationMatrixFromVector,
          jni.JniType.voidType,
          [R.reference, rotationVector.reference]).check();

  static final _id_getQuaternionFromVector = jniAccessors.getStaticMethodIDOf(
      _classRef, "getQuaternionFromVector", "([F[F)V");

  /// from: static public void getQuaternionFromVector(float[] Q, float[] rv)
  ///
  /// Helper function to convert a rotation vector to a normalized quaternion.
  ///  Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a normalized
  ///  quaternion in the array Q.  The quaternion is stored as [w, x, y, z]
  ///@param rv the rotation vector to convert
  ///@param Q an array of floats in which to store the computed quaternion
  static void getQuaternionFromVector(jni.JniObject Q, jni.JniObject rv) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getQuaternionFromVector,
          jni.JniType.voidType,
          [Q.reference, rv.reference]).check();

  static final _id_requestTriggerSensor = jniAccessors.getMethodIDOf(
      _classRef,
      "requestTriggerSensor",
      "(Landroid/hardware/TriggerEventListener;Landroid/hardware/Sensor;)Z");

  /// from: public boolean requestTriggerSensor(android.hardware.TriggerEventListener listener, android.hardware.Sensor sensor)
  ///
  /// Requests receiving trigger events for a trigger sensor.
  ///
  ///
  /// When the sensor detects a trigger event condition, such as significant motion in
  /// the case of the Sensor\#TYPE_SIGNIFICANT_MOTION, the provided trigger listener
  /// will be invoked once and then its request to receive trigger events will be canceled.
  /// To continue receiving trigger events, the application must request to receive trigger
  /// events again.
  ///
  ///
  ///@param listener The listener on which the
  ///        TriggerEventListener\#onTrigger(TriggerEvent) will be delivered.
  ///@param sensor The sensor to be enabled.
  ///@return true if the sensor was successfully enabled.
  ///@throws IllegalArgumentException when sensor is null or not a trigger sensor.
  bool requestTriggerSensor(triggereventlistener_.TriggerEventListener listener,
          sensor_.Sensor sensor) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestTriggerSensor,
          jni.JniType.booleanType,
          [listener.reference, sensor.reference]).boolean;

  static final _id_cancelTriggerSensor = jniAccessors.getMethodIDOf(
      _classRef,
      "cancelTriggerSensor",
      "(Landroid/hardware/TriggerEventListener;Landroid/hardware/Sensor;)Z");

  /// from: public boolean cancelTriggerSensor(android.hardware.TriggerEventListener listener, android.hardware.Sensor sensor)
  ///
  /// Cancels receiving trigger events for a trigger sensor.
  ///
  ///
  /// Note that a Trigger sensor will be auto disabled if
  /// TriggerEventListener\#onTrigger(TriggerEvent) has triggered.
  /// This method is provided in case the user wants to explicitly cancel the request
  /// to receive trigger events.
  ///
  ///
  ///@param listener The listener on which the
  ///        TriggerEventListener\#onTrigger(TriggerEvent)
  ///        is delivered.It should be the same as the one used
  ///        in \#requestTriggerSensor(TriggerEventListener, Sensor)
  ///@param sensor The sensor for which the trigger request should be canceled.
  ///        If null, it cancels receiving trigger for all sensors associated
  ///        with the listener.
  ///@return true if successfully canceled.
  ///@throws IllegalArgumentException when sensor is a trigger sensor.
  bool cancelTriggerSensor(triggereventlistener_.TriggerEventListener listener,
          sensor_.Sensor sensor) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_cancelTriggerSensor,
          jni.JniType.booleanType,
          [listener.reference, sensor.reference]).boolean;
}

/// from: android.hardware.SensorManager$DynamicSensorCallback
///
/// Used for receiving notifications from the SensorManager when dynamic sensors are connected or
/// disconnected.
class SensorManager_DynamicSensorCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/hardware/SensorManager\$DynamicSensorCallback");
  SensorManager_DynamicSensorCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  SensorManager_DynamicSensorCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onDynamicSensorConnected = jniAccessors.getMethodIDOf(
      _classRef, "onDynamicSensorConnected", "(Landroid/hardware/Sensor;)V");

  /// from: public void onDynamicSensorConnected(android.hardware.Sensor sensor)
  ///
  /// Called when there is a dynamic sensor being connected to the system.
  ///@param sensor the newly connected sensor. See android.hardware.Sensor Sensor.
  void onDynamicSensorConnected(sensor_.Sensor sensor) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDynamicSensorConnected,
          jni.JniType.voidType, [sensor.reference]).check();

  static final _id_onDynamicSensorDisconnected = jniAccessors.getMethodIDOf(
      _classRef, "onDynamicSensorDisconnected", "(Landroid/hardware/Sensor;)V");

  /// from: public void onDynamicSensorDisconnected(android.hardware.Sensor sensor)
  ///
  /// Called when there is a dynamic sensor being disconnected from the system.
  ///@param sensor the disconnected sensor. See android.hardware.Sensor Sensor.
  void onDynamicSensorDisconnected(sensor_.Sensor sensor) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onDynamicSensorDisconnected,
          jni.JniType.voidType,
          [sensor.reference]).check();
}
