// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.hardware.ConsumerIrManager
///
/// Class that operates consumer infrared on the device.
///
/// Requires the android.content.pm.PackageManager\#FEATURE_CONSUMER_IR PackageManager\#FEATURE_CONSUMER_IR feature which can be detected using android.content.pm.PackageManager\#hasSystemFeature(String) PackageManager.hasSystemFeature(String).
class ConsumerIrManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/hardware/ConsumerIrManager");
  ConsumerIrManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_hasIrEmitter =
      jniAccessors.getMethodIDOf(_classRef, "hasIrEmitter", "()Z");

  /// from: public boolean hasIrEmitter()
  ///
  /// Check whether the device has an infrared emitter.
  ///@return true if the device has an infrared emitter, else false.
  bool hasIrEmitter() => jniAccessors.callMethodWithArgs(
      reference, _id_hasIrEmitter, jni.JniType.booleanType, []).boolean;

  static final _id_transmit =
      jniAccessors.getMethodIDOf(_classRef, "transmit", "(I[I)V");

  /// from: public void transmit(int carrierFrequency, int[] pattern)
  ///
  /// Transmit an infrared pattern
  ///
  /// This method is synchronous; when it returns the pattern has
  /// been transmitted. Only patterns shorter than 2 seconds will
  /// be transmitted.
  ///
  ///
  ///@param carrierFrequency The IR carrier frequency in Hertz.
  ///@param pattern The alternating on/off pattern in microseconds to transmit.
  void transmit(int carrierFrequency, jni.JniObject pattern) =>
      jniAccessors.callMethodWithArgs(reference, _id_transmit,
          jni.JniType.voidType, [carrierFrequency, pattern.reference]).check();

  static final _id_getCarrierFrequencies = jniAccessors.getMethodIDOf(
      _classRef,
      "getCarrierFrequencies",
      "()[Landroid/hardware/ConsumerIrManager\$CarrierFrequencyRange;");

  /// from: public android.hardware.ConsumerIrManager.CarrierFrequencyRange[] getCarrierFrequencies()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the infrared transmitter's supported carrier frequencies
  ///@return an array of
  /// android.hardware.ConsumerIrManager.CarrierFrequencyRange
  /// objects representing the ranges that the transmitter can support, or
  /// null if there was an error communicating with the Consumer IR Service.
  jni.JniObject getCarrierFrequencies() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCarrierFrequencies, jni.JniType.objectType, []).object);
}

/// from: android.hardware.ConsumerIrManager$CarrierFrequencyRange
///
/// Represents a range of carrier frequencies (inclusive) on which the
/// infrared transmitter can transmit
class ConsumerIrManager_CarrierFrequencyRange extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/hardware/ConsumerIrManager\$CarrierFrequencyRange");
  ConsumerIrManager_CarrierFrequencyRange.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(II)V");

  /// from: public void <init>(int min, int max)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a segment of a carrier frequency range.
  ///@param min The minimum transmittable frequency in this range segment.
  ///@param max The maximum transmittable frequency in this range segment.
  ConsumerIrManager_CarrierFrequencyRange(int min, int max)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [min, max]).object);

  static final _id_getMinFrequency =
      jniAccessors.getMethodIDOf(_classRef, "getMinFrequency", "()I");

  /// from: public int getMinFrequency()
  ///
  /// Get the minimum (inclusive) frequency in this range segment.
  int getMinFrequency() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinFrequency, jni.JniType.intType, []).integer;

  static final _id_getMaxFrequency =
      jniAccessors.getMethodIDOf(_classRef, "getMaxFrequency", "()I");

  /// from: public int getMaxFrequency()
  ///
  /// Get the maximum (inclusive) frequency in this range segment.
  int getMaxFrequency() => jniAccessors.callMethodWithArgs(
      reference, _id_getMaxFrequency, jni.JniType.intType, []).integer;
}
