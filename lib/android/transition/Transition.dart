// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../animation/TimeInterpolator.dart" as timeinterpolator_;

import "../animation/Animator.dart" as animator_;

import "../view/ViewGroup.dart" as viewgroup_;

import "TransitionValues.dart" as transitionvalues_;

import "../view/View.dart" as view_;

import "../graphics/Rect.dart" as rect_;

import "PathMotion.dart" as pathmotion_;

import "TransitionPropagation.dart" as transitionpropagation_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.transition.Transition
///
/// A Transition holds information about animations that will be run on its
/// targets during a scene change. Subclasses of this abstract class may
/// choreograph several child transitions (TransitionSet or they may
/// perform custom animations themselves. Any Transition has two main jobs:
/// (1) capture property values, and (2) play animations based on changes to
/// captured property values. A custom transition knows what property values
/// on View objects are of interest to it, and also knows how to animate
/// changes to those values. For example, the Fade transition tracks
/// changes to visibility-related properties and is able to construct and run
/// animations that fade items in or out based on changes to those properties.
///
/// Note: Transitions may not work correctly with either SurfaceView
/// or TextureView, due to the way that these views are displayed
/// on the screen. For SurfaceView, the problem is that the view is updated from
/// a non-UI thread, so changes to the view due to transitions (such as moving
/// and resizing the view) may be out of sync with the display inside those bounds.
/// TextureView is more compatible with transitions in general, but some
/// specific transitions (such as Fade) may not be compatible
/// with TextureView because they rely on ViewOverlay functionality,
/// which does not currently work with TextureView.
///
///
/// Transitions can be declared in XML resource files inside the <code>res/transition</code>
/// directory. Transition resources consist of a tag name for one of the Transition
/// subclasses along with attributes to define some of the attributes of that transition.
/// For example, here is a minimal resource file that declares a ChangeBounds transition:
///
/// {@sample development/samples/ApiDemos/res/transition/changebounds.xml ChangeBounds}
///
/// This TransitionSet contains android.transition.Explode for visibility,
/// android.transition.ChangeBounds, android.transition.ChangeTransform,
/// and android.transition.ChangeClipBounds and
/// android.transition.ChangeImageTransform:
///
///
/// {@sample development/samples/ApiDemos/res/transition/explode_move_together.xml MultipleTransform}
///
/// Custom transition classes may be instantiated with a <code>transition</code> tag:
///
/// <pre>&lt;transition class="my.app.transition.CustomTransition"/></pre>
/// Custom transition classes loaded from XML should have a public constructor taking
/// a android.content.Context and android.util.AttributeSet.
///
///
/// Note that attributes for the transition are not required, just as they are
/// optional when declared in code; Transitions created from XML resources will use
/// the same defaults as their code-created equivalents. Here is a slightly more
/// elaborate example which declares a TransitionSet transition with
/// ChangeBounds and Fade child transitions:
///
///
/// {@sample development/samples/ApiDemos/res/transition/changebounds_fadeout_sequential.xml TransitionSet}
///
/// In this example, the transitionOrdering attribute is used on the TransitionSet
/// object to change from the default TransitionSet\#ORDERING_TOGETHER behavior
/// to be TransitionSet\#ORDERING_SEQUENTIAL instead. Also, the Fade
/// transition uses a fadingMode of Fade\#OUT instead of the default
/// out-in behavior. Finally, note the use of the <code>targets</code> sub-tag, which
/// takes a set of android.R.styleable\#TransitionTarget target tags, each
/// of which lists a specific <code>targetId</code>, <code>targetClass</code>,
/// <code>targetName</code>, <code>excludeId</code>, <code>excludeClass</code>, or
/// <code>excludeName</code>, which this transition acts upon.
/// Use of targets is optional, but can be used to either limit the time spent checking
/// attributes on unchanging views, or limiting the types of animations run on specific views.
/// In this case, we know that only the <code>grayscaleContainer</code> will be
/// disappearing, so we choose to limit the Fade transition to only that view.
///
///
/// Further information on XML resource descriptions for transitions can be found for
/// android.R.styleable\#Transition, android.R.styleable\#TransitionSet,
/// android.R.styleable\#TransitionTarget, android.R.styleable\#Fade,
/// android.R.styleable\#Slide, and android.R.styleable\#ChangeTransform.
class Transition extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/transition/Transition");
  Transition.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int MATCH_ID
  ///
  /// With \#setMatchOrder(int...), chooses to match by
  /// android.view.View\#getId(). Negative IDs will not be matched.
  static const MATCH_ID = 3;

  /// from: static public final int MATCH_INSTANCE
  ///
  /// With \#setMatchOrder(int...), chooses to match by View instance.
  static const MATCH_INSTANCE = 1;

  /// from: static public final int MATCH_ITEM_ID
  ///
  /// With \#setMatchOrder(int...), chooses to match by the android.widget.Adapter
  /// item id. When android.widget.Adapter\#hasStableIds() returns false, no match
  /// will be made for items.
  static const MATCH_ITEM_ID = 4;

  /// from: static public final int MATCH_NAME
  ///
  /// With \#setMatchOrder(int...), chooses to match by
  /// android.view.View\#getTransitionName(). Null names will not be matched.
  static const MATCH_NAME = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a Transition object with no target objects. A transition with
  /// no targets defaults to running on all target objects in the scene hierarchy
  /// (if the transition is not contained in a TransitionSet), or all target
  /// objects passed down from its parent (if it is in a TransitionSet).
  Transition()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform inflation from XML and apply a class-specific base style from a
  /// theme attribute or style resource. This constructor of Transition allows
  /// subclasses to use their own base style when they are inflating.
  ///@param context The Context the transition is running in, through which it can
  ///        access the current theme, resources, etc.
  ///@param attrs The attributes of the XML tag that is inflating the transition.
  Transition.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_setDuration = jniAccessors.getMethodIDOf(
      _classRef, "setDuration", "(J)Landroid/transition/Transition;");

  /// from: public android.transition.Transition setDuration(long duration)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the duration of this transition. By default, there is no duration
  /// (indicated by a negative number), which means that the Animator created by
  /// the transition will have its own specified duration. If the duration of a
  /// Transition is set, that duration will override the Animator duration.
  ///@param duration The length of the animation, in milliseconds.
  ///@return This transition object.
  ///@attr ref android.R.styleable\#Transition_duration
  Transition setDuration(int duration) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setDuration, jni.JniType.objectType, [duration]).object);

  static final _id_getDuration =
      jniAccessors.getMethodIDOf(_classRef, "getDuration", "()J");

  /// from: public long getDuration()
  ///
  /// Returns the duration set on this transition. If no duration has been set,
  /// the returned value will be negative, indicating that resulting animators will
  /// retain their own durations.
  ///@return The duration set on this transition, in milliseconds, if one has been
  /// set, otherwise returns a negative number.
  int getDuration() => jniAccessors.callMethodWithArgs(
      reference, _id_getDuration, jni.JniType.longType, []).long;

  static final _id_setStartDelay = jniAccessors.getMethodIDOf(
      _classRef, "setStartDelay", "(J)Landroid/transition/Transition;");

  /// from: public android.transition.Transition setStartDelay(long startDelay)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the startDelay of this transition. By default, there is no delay
  /// (indicated by a negative number), which means that the Animator created by
  /// the transition will have its own specified startDelay. If the delay of a
  /// Transition is set, that delay will override the Animator delay.
  ///@param startDelay The length of the delay, in milliseconds.
  ///@return This transition object.
  ///@attr ref android.R.styleable\#Transition_startDelay
  Transition setStartDelay(int startDelay) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_setStartDelay, jni.JniType.objectType, [startDelay]).object);

  static final _id_getStartDelay =
      jniAccessors.getMethodIDOf(_classRef, "getStartDelay", "()J");

  /// from: public long getStartDelay()
  ///
  /// Returns the startDelay set on this transition. If no startDelay has been set,
  /// the returned value will be negative, indicating that resulting animators will
  /// retain their own startDelays.
  ///@return The startDelay set on this transition, in milliseconds, if one has
  /// been set, otherwise returns a negative number.
  int getStartDelay() => jniAccessors.callMethodWithArgs(
      reference, _id_getStartDelay, jni.JniType.longType, []).long;

  static final _id_setInterpolator = jniAccessors.getMethodIDOf(
      _classRef,
      "setInterpolator",
      "(Landroid/animation/TimeInterpolator;)Landroid/transition/Transition;");

  /// from: public android.transition.Transition setInterpolator(android.animation.TimeInterpolator interpolator)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the interpolator of this transition. By default, the interpolator
  /// is null, which means that the Animator created by the transition
  /// will have its own specified interpolator. If the interpolator of a
  /// Transition is set, that interpolator will override the Animator interpolator.
  ///@param interpolator The time interpolator used by the transition
  ///@return This transition object.
  ///@attr ref android.R.styleable\#Transition_interpolator
  Transition setInterpolator(timeinterpolator_.TimeInterpolator interpolator) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_setInterpolator,
          jni.JniType.objectType,
          [interpolator.reference]).object);

  static final _id_getInterpolator = jniAccessors.getMethodIDOf(
      _classRef, "getInterpolator", "()Landroid/animation/TimeInterpolator;");

  /// from: public android.animation.TimeInterpolator getInterpolator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the interpolator set on this transition. If no interpolator has been set,
  /// the returned value will be null, indicating that resulting animators will
  /// retain their own interpolators.
  ///@return The interpolator set on this transition, if one has been set, otherwise
  /// returns null.
  timeinterpolator_.TimeInterpolator getInterpolator() =>
      timeinterpolator_.TimeInterpolator.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getInterpolator,
              jni.JniType.objectType, []).object);

  static final _id_getTransitionProperties = jniAccessors.getMethodIDOf(
      _classRef, "getTransitionProperties", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getTransitionProperties()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the set of property names used stored in the TransitionValues
  /// object passed into \#captureStartValues(TransitionValues) that
  /// this transition cares about for the purposes of canceling overlapping animations.
  /// When any transition is started on a given scene root, all transitions
  /// currently running on that same scene root are checked to see whether the
  /// properties on which they based their animations agree with the end values of
  /// the same properties in the new transition. If the end values are not equal,
  /// then the old animation is canceled since the new transition will start a new
  /// animation to these new values. If the values are equal, the old animation is
  /// allowed to continue and no new animation is started for that transition.
  ///
  /// A transition does not need to override this method. However, not doing so
  /// will mean that the cancellation logic outlined in the previous paragraph
  /// will be skipped for that transition, possibly leading to artifacts as
  /// old transitions and new transitions on the same targets run in parallel,
  /// animating views toward potentially different end values.
  ///
  ///@return An array of property names as described in the class documentation for
  /// TransitionValues. The default implementation returns <code>null</code>.
  jni.JniObject getTransitionProperties() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getTransitionProperties, jni.JniType.objectType, []).object);

  static final _id_createAnimator = jniAccessors.getMethodIDOf(
      _classRef,
      "createAnimator",
      "(Landroid/view/ViewGroup;Landroid/transition/TransitionValues;Landroid/transition/TransitionValues;)Landroid/animation/Animator;");

  /// from: public android.animation.Animator createAnimator(android.view.ViewGroup sceneRoot, android.transition.TransitionValues startValues, android.transition.TransitionValues endValues)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method creates an animation that will be run for this transition
  /// given the information in the startValues and endValues structures captured
  /// earlier for the start and end scenes. Subclasses of Transition should override
  /// this method. The method should only be called by the transition system; it is
  /// not intended to be called from external classes.
  ///
  /// This method is called by the transition's parent (all the way up to the
  /// topmost Transition in the hierarchy) with the sceneRoot and start/end
  /// values that the transition may need to set up initial target values
  /// and construct an appropriate animation. For example, if an overall
  /// Transition is a TransitionSet consisting of several
  /// child transitions in sequence, then some of the child transitions may
  /// want to set initial values on target views prior to the overall
  /// Transition commencing, to put them in an appropriate state for the
  /// delay between that start and the child Transition start time. For
  /// example, a transition that fades an item in may wish to set the starting
  /// alpha value to 0, to avoid it blinking in prior to the transition
  /// actually starting the animation. This is necessary because the scene
  /// change that triggers the Transition will automatically set the end-scene
  /// on all target views, so a Transition that wants to animate from a
  /// different value should set that value prior to returning from this method.
  ///
  ///
  /// Additionally, a Transition can perform logic to determine whether
  /// the transition needs to run on the given target and start/end values.
  /// For example, a transition that resizes objects on the screen may wish
  /// to avoid running for views which are not present in either the start
  /// or end scenes.
  ///
  ///
  /// If there is an animator created and returned from this method, the
  /// transition mechanism will apply any applicable duration, startDelay,
  /// and interpolator to that animation and start it. A return value of
  /// <code>null</code> indicates that no animation should run. The default
  /// implementation returns null.
  ///
  ///
  /// The method is called for every applicable target object, which is
  /// stored in the TransitionValues\#view field.
  ///
  ///@param sceneRoot The root of the transition hierarchy.
  ///@param startValues The values for a specific target in the start scene.
  ///@param endValues The values for the target in the end scene.
  ///@return A Animator to be started at the appropriate time in the
  /// overall transition for this scene change. A null value means no animation
  /// should be run.
  animator_.Animator createAnimator(
          viewgroup_.ViewGroup sceneRoot,
          transitionvalues_.TransitionValues startValues,
          transitionvalues_.TransitionValues endValues) =>
      animator_.Animator.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createAnimator, jni.JniType.objectType, [
        sceneRoot.reference,
        startValues.reference,
        endValues.reference
      ]).object);

  static final _id_setMatchOrder =
      jniAccessors.getMethodIDOf(_classRef, "setMatchOrder", "([I)V");

  /// from: public void setMatchOrder(int[] matches)
  ///
  /// Sets the order in which Transition matches View start and end values.
  ///
  /// The default behavior is to match first by android.view.View\#getTransitionName(),
  /// then by View instance, then by android.view.View\#getId() and finally
  /// by its item ID if it is in a direct child of ListView. The caller can
  /// choose to have only some or all of the values of \#MATCH_INSTANCE,
  /// \#MATCH_NAME, \#MATCH_ITEM_ID, and \#MATCH_ID. Only
  /// the match algorithms supplied will be used to determine whether Views are the
  /// the same in both the start and end Scene. Views that do not match will be considered
  /// as entering or leaving the Scene.
  ///
  ///
  ///@param matches A list of zero or more of \#MATCH_INSTANCE,
  ///                \#MATCH_NAME, \#MATCH_ITEM_ID, and \#MATCH_ID.
  ///                If none are provided, then the default match order will be set.
  void setMatchOrder(jni.JniObject matches) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMatchOrder,
      jni.JniType.voidType,
      [matches.reference]).check();

  static final _id_captureStartValues = jniAccessors.getMethodIDOf(_classRef,
      "captureStartValues", "(Landroid/transition/TransitionValues;)V");

  /// from: public abstract void captureStartValues(android.transition.TransitionValues transitionValues)
  ///
  /// Captures the values in the start scene for the properties that this
  /// transition monitors. These values are then passed as the startValues
  /// structure in a later call to
  /// \#createAnimator(ViewGroup, TransitionValues, TransitionValues).
  /// The main concern for an implementation is what the
  /// properties are that the transition cares about and what the values are
  /// for all of those properties. The start and end values will be compared
  /// later during the
  /// \#createAnimator(android.view.ViewGroup, TransitionValues, TransitionValues)
  /// method to determine what, if any, animations, should be run.
  ///
  /// Subclasses must implement this method. The method should only be called by the
  /// transition system; it is not intended to be called from external classes.
  ///
  ///@param transitionValues The holder for any values that the Transition
  /// wishes to store. Values are stored in the <code>values</code> field
  /// of this TransitionValues object and are keyed from
  /// a String value. For example, to store a view's rotation value,
  /// a transition might call
  /// <code>transitionValues.values.put("appname:transitionname:rotation",
  /// view.getRotation())</code>. The target view will already be stored in
  /// the transitionValues structure when this method is called.
  ///@see \#captureEndValues(TransitionValues)
  ///@see \#createAnimator(ViewGroup, TransitionValues, TransitionValues)
  void captureStartValues(
          transitionvalues_.TransitionValues transitionValues) =>
      jniAccessors.callMethodWithArgs(reference, _id_captureStartValues,
          jni.JniType.voidType, [transitionValues.reference]).check();

  static final _id_captureEndValues = jniAccessors.getMethodIDOf(_classRef,
      "captureEndValues", "(Landroid/transition/TransitionValues;)V");

  /// from: public abstract void captureEndValues(android.transition.TransitionValues transitionValues)
  ///
  /// Captures the values in the end scene for the properties that this
  /// transition monitors. These values are then passed as the endValues
  /// structure in a later call to
  /// \#createAnimator(ViewGroup, TransitionValues, TransitionValues).
  /// The main concern for an implementation is what the
  /// properties are that the transition cares about and what the values are
  /// for all of those properties. The start and end values will be compared
  /// later during the
  /// \#createAnimator(android.view.ViewGroup, TransitionValues, TransitionValues)
  /// method to determine what, if any, animations, should be run.
  ///
  /// Subclasses must implement this method. The method should only be called by the
  /// transition system; it is not intended to be called from external classes.
  ///
  ///@param transitionValues The holder for any values that the Transition
  /// wishes to store. Values are stored in the <code>values</code> field
  /// of this TransitionValues object and are keyed from
  /// a String value. For example, to store a view's rotation value,
  /// a transition might call
  /// <code>transitionValues.values.put("appname:transitionname:rotation",
  /// view.getRotation())</code>. The target view will already be stored in
  /// the transitionValues structure when this method is called.
  ///@see \#captureStartValues(TransitionValues)
  ///@see \#createAnimator(ViewGroup, TransitionValues, TransitionValues)
  void captureEndValues(transitionvalues_.TransitionValues transitionValues) =>
      jniAccessors.callMethodWithArgs(reference, _id_captureEndValues,
          jni.JniType.voidType, [transitionValues.reference]).check();

  static final _id_addTarget = jniAccessors.getMethodIDOf(
      _classRef, "addTarget", "(I)Landroid/transition/Transition;");

  /// from: public android.transition.Transition addTarget(int targetId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds the id of a target view that this Transition is interested in
  /// animating. By default, there are no targetIds, and a Transition will
  /// listen for changes on every view in the hierarchy below the sceneRoot
  /// of the Scene being transitioned into. Setting targetIds constrains
  /// the Transition to only listen for, and act on, views with these IDs.
  /// Views with different IDs, or no IDs whatsoever, will be ignored.
  ///
  /// Note that using ids to specify targets implies that ids should be unique
  /// within the view hierarchy underneath the scene root.
  ///
  ///@see View\#getId()
  ///@param targetId The id of a target view, must be a positive number.
  ///@return The Transition to which the targetId is added.
  /// Returning the same object makes it easier to chain calls during
  /// construction, such as
  /// <code>transitionSet.addTransitions(new Fade()).addTarget(someId);</code>
  Transition addTarget(int targetId) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_addTarget, jni.JniType.objectType, [targetId]).object);

  static final _id_addTarget1 = jniAccessors.getMethodIDOf(_classRef,
      "addTarget", "(Ljava/lang/String;)Landroid/transition/Transition;");

  /// from: public android.transition.Transition addTarget(java.lang.String targetName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds the transitionName of a target view that this Transition is interested in
  /// animating. By default, there are no targetNames, and a Transition will
  /// listen for changes on every view in the hierarchy below the sceneRoot
  /// of the Scene being transitioned into. Setting targetNames constrains
  /// the Transition to only listen for, and act on, views with these transitionNames.
  /// Views with different transitionNames, or no transitionName whatsoever, will be ignored.
  ///
  /// Note that transitionNames should be unique within the view hierarchy.
  ///
  ///@see android.view.View\#getTransitionName()
  ///@param targetName The transitionName of a target view, must be non-null.
  ///@return The Transition to which the target transitionName is added.
  /// Returning the same object makes it easier to chain calls during
  /// construction, such as
  /// <code>transitionSet.addTransitions(new Fade()).addTarget(someName);</code>
  Transition addTarget1(jni.JniString targetName) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addTarget1,
          jni.JniType.objectType,
          [targetName.reference]).object);

  static final _id_addTarget2 = jniAccessors.getMethodIDOf(_classRef,
      "addTarget", "(Ljava/lang/Class;)Landroid/transition/Transition;");

  /// from: public android.transition.Transition addTarget(java.lang.Class targetType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds the Class of a target view that this Transition is interested in
  /// animating. By default, there are no targetTypes, and a Transition will
  /// listen for changes on every view in the hierarchy below the sceneRoot
  /// of the Scene being transitioned into. Setting targetTypes constrains
  /// the Transition to only listen for, and act on, views with these classes.
  /// Views with different classes will be ignored.
  ///
  /// Note that any View that can be cast to targetType will be included, so
  /// if targetType is <code>View.class</code>, all Views will be included.
  ///
  ///@see \#addTarget(int)
  ///@see \#addTarget(android.view.View)
  ///@see \#excludeTarget(Class, boolean)
  ///@see \#excludeChildren(Class, boolean)
  ///@param targetType The type to include when running this transition.
  ///@return The Transition to which the target class was added.
  /// Returning the same object makes it easier to chain calls during
  /// construction, such as
  /// <code>transitionSet.addTransitions(new Fade()).addTarget(ImageView.class);</code>
  Transition addTarget2(jni.JniObject targetType) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addTarget2,
          jni.JniType.objectType,
          [targetType.reference]).object);

  static final _id_removeTarget = jniAccessors.getMethodIDOf(
      _classRef, "removeTarget", "(I)Landroid/transition/Transition;");

  /// from: public android.transition.Transition removeTarget(int targetId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes the given targetId from the list of ids that this Transition
  /// is interested in animating.
  ///@param targetId The id of a target view, must be a positive number.
  ///@return The Transition from which the targetId is removed.
  /// Returning the same object makes it easier to chain calls during
  /// construction, such as
  /// <code>transitionSet.addTransitions(new Fade()).removeTargetId(someId);</code>
  Transition removeTarget(int targetId) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_removeTarget, jni.JniType.objectType, [targetId]).object);

  static final _id_removeTarget1 = jniAccessors.getMethodIDOf(_classRef,
      "removeTarget", "(Ljava/lang/String;)Landroid/transition/Transition;");

  /// from: public android.transition.Transition removeTarget(java.lang.String targetName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes the given targetName from the list of transitionNames that this Transition
  /// is interested in animating.
  ///@param targetName The transitionName of a target view, must not be null.
  ///@return The Transition from which the targetName is removed.
  /// Returning the same object makes it easier to chain calls during
  /// construction, such as
  /// <code>transitionSet.addTransitions(new Fade()).removeTargetName(someName);</code>
  Transition removeTarget1(jni.JniString targetName) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_removeTarget1,
          jni.JniType.objectType,
          [targetName.reference]).object);

  static final _id_excludeTarget = jniAccessors.getMethodIDOf(
      _classRef, "excludeTarget", "(IZ)Landroid/transition/Transition;");

  /// from: public android.transition.Transition excludeTarget(int targetId, boolean exclude)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Whether to add the given id to the list of target ids to exclude from this
  /// transition. The <code>exclude</code> parameter specifies whether the target
  /// should be added to or removed from the excluded list.
  ///
  /// Excluding targets is a general mechanism for allowing transitions to run on
  /// a view hierarchy while skipping target views that should not be part of
  /// the transition. For example, you may want to avoid animating children
  /// of a specific ListView or Spinner. Views can be excluded either by their
  /// id, or by their instance reference, or by the Class of that view
  /// (eg, Spinner).
  ///
  ///@see \#excludeChildren(int, boolean)
  ///@see \#excludeTarget(View, boolean)
  ///@see \#excludeTarget(Class, boolean)
  ///@param targetId The id of a target to ignore when running this transition.
  ///@param exclude Whether to add the target to or remove the target from the
  /// current list of excluded targets.
  ///@return This transition object.
  Transition excludeTarget(int targetId, bool exclude) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_excludeTarget,
          jni.JniType.objectType,
          [targetId, exclude]).object);

  static final _id_excludeTarget1 = jniAccessors.getMethodIDOf(_classRef,
      "excludeTarget", "(Ljava/lang/String;Z)Landroid/transition/Transition;");

  /// from: public android.transition.Transition excludeTarget(java.lang.String targetName, boolean exclude)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Whether to add the given transitionName to the list of target transitionNames to exclude
  /// from this transition. The <code>exclude</code> parameter specifies whether the target
  /// should be added to or removed from the excluded list.
  ///
  /// Excluding targets is a general mechanism for allowing transitions to run on
  /// a view hierarchy while skipping target views that should not be part of
  /// the transition. For example, you may want to avoid animating children
  /// of a specific ListView or Spinner. Views can be excluded by their
  /// id, their instance reference, their transitionName, or by the Class of that view
  /// (eg, Spinner).
  ///
  ///@see \#excludeTarget(View, boolean)
  ///@see \#excludeTarget(int, boolean)
  ///@see \#excludeTarget(Class, boolean)
  ///@param targetName The name of a target to ignore when running this transition.
  ///@param exclude Whether to add the target to or remove the target from the
  /// current list of excluded targets.
  ///@return This transition object.
  Transition excludeTarget1(jni.JniString targetName, bool exclude) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_excludeTarget1,
          jni.JniType.objectType,
          [targetName.reference, exclude]).object);

  static final _id_excludeChildren = jniAccessors.getMethodIDOf(
      _classRef, "excludeChildren", "(IZ)Landroid/transition/Transition;");

  /// from: public android.transition.Transition excludeChildren(int targetId, boolean exclude)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Whether to add the children of the given id to the list of targets to exclude
  /// from this transition. The <code>exclude</code> parameter specifies whether
  /// the children of the target should be added to or removed from the excluded list.
  /// Excluding children in this way provides a simple mechanism for excluding all
  /// children of specific targets, rather than individually excluding each
  /// child individually.
  ///
  /// Excluding targets is a general mechanism for allowing transitions to run on
  /// a view hierarchy while skipping target views that should not be part of
  /// the transition. For example, you may want to avoid animating children
  /// of a specific ListView or Spinner. Views can be excluded either by their
  /// id, or by their instance reference, or by the Class of that view
  /// (eg, Spinner).
  ///
  ///@see \#excludeTarget(int, boolean)
  ///@see \#excludeChildren(View, boolean)
  ///@see \#excludeChildren(Class, boolean)
  ///@param targetId The id of a target whose children should be ignored when running
  /// this transition.
  ///@param exclude Whether to add the target to or remove the target from the
  /// current list of excluded-child targets.
  ///@return This transition object.
  Transition excludeChildren(int targetId, bool exclude) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_excludeChildren,
          jni.JniType.objectType,
          [targetId, exclude]).object);

  static final _id_excludeTarget2 = jniAccessors.getMethodIDOf(_classRef,
      "excludeTarget", "(Landroid/view/View;Z)Landroid/transition/Transition;");

  /// from: public android.transition.Transition excludeTarget(android.view.View target, boolean exclude)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Whether to add the given target to the list of targets to exclude from this
  /// transition. The <code>exclude</code> parameter specifies whether the target
  /// should be added to or removed from the excluded list.
  ///
  /// Excluding targets is a general mechanism for allowing transitions to run on
  /// a view hierarchy while skipping target views that should not be part of
  /// the transition. For example, you may want to avoid animating children
  /// of a specific ListView or Spinner. Views can be excluded either by their
  /// id, or by their instance reference, or by the Class of that view
  /// (eg, Spinner).
  ///
  ///@see \#excludeChildren(View, boolean)
  ///@see \#excludeTarget(int, boolean)
  ///@see \#excludeTarget(Class, boolean)
  ///@param target The target to ignore when running this transition.
  ///@param exclude Whether to add the target to or remove the target from the
  /// current list of excluded targets.
  ///@return This transition object.
  Transition excludeTarget2(view_.View target, bool exclude) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_excludeTarget2,
          jni.JniType.objectType,
          [target.reference, exclude]).object);

  static final _id_excludeChildren1 = jniAccessors.getMethodIDOf(
      _classRef,
      "excludeChildren",
      "(Landroid/view/View;Z)Landroid/transition/Transition;");

  /// from: public android.transition.Transition excludeChildren(android.view.View target, boolean exclude)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Whether to add the children of given target to the list of target children
  /// to exclude from this transition. The <code>exclude</code> parameter specifies
  /// whether the target should be added to or removed from the excluded list.
  ///
  /// Excluding targets is a general mechanism for allowing transitions to run on
  /// a view hierarchy while skipping target views that should not be part of
  /// the transition. For example, you may want to avoid animating children
  /// of a specific ListView or Spinner. Views can be excluded either by their
  /// id, or by their instance reference, or by the Class of that view
  /// (eg, Spinner).
  ///
  ///@see \#excludeTarget(View, boolean)
  ///@see \#excludeChildren(int, boolean)
  ///@see \#excludeChildren(Class, boolean)
  ///@param target The target to ignore when running this transition.
  ///@param exclude Whether to add the target to or remove the target from the
  /// current list of excluded targets.
  ///@return This transition object.
  Transition excludeChildren1(view_.View target, bool exclude) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_excludeChildren1,
          jni.JniType.objectType,
          [target.reference, exclude]).object);

  static final _id_excludeTarget3 = jniAccessors.getMethodIDOf(_classRef,
      "excludeTarget", "(Ljava/lang/Class;Z)Landroid/transition/Transition;");

  /// from: public android.transition.Transition excludeTarget(java.lang.Class type, boolean exclude)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Whether to add the given type to the list of types to exclude from this
  /// transition. The <code>exclude</code> parameter specifies whether the target
  /// type should be added to or removed from the excluded list.
  ///
  /// Excluding targets is a general mechanism for allowing transitions to run on
  /// a view hierarchy while skipping target views that should not be part of
  /// the transition. For example, you may want to avoid animating children
  /// of a specific ListView or Spinner. Views can be excluded either by their
  /// id, or by their instance reference, or by the Class of that view
  /// (eg, Spinner).
  ///
  ///@see \#excludeChildren(Class, boolean)
  ///@see \#excludeTarget(int, boolean)
  ///@see \#excludeTarget(View, boolean)
  ///@param type The type to ignore when running this transition.
  ///@param exclude Whether to add the target type to or remove it from the
  /// current list of excluded target types.
  ///@return This transition object.
  Transition excludeTarget3(jni.JniObject type, bool exclude) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_excludeTarget3,
          jni.JniType.objectType,
          [type.reference, exclude]).object);

  static final _id_excludeChildren2 = jniAccessors.getMethodIDOf(_classRef,
      "excludeChildren", "(Ljava/lang/Class;Z)Landroid/transition/Transition;");

  /// from: public android.transition.Transition excludeChildren(java.lang.Class type, boolean exclude)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Whether to add the given type to the list of types whose children should
  /// be excluded from this transition. The <code>exclude</code> parameter
  /// specifies whether the target type should be added to or removed from
  /// the excluded list.
  ///
  /// Excluding targets is a general mechanism for allowing transitions to run on
  /// a view hierarchy while skipping target views that should not be part of
  /// the transition. For example, you may want to avoid animating children
  /// of a specific ListView or Spinner. Views can be excluded either by their
  /// id, or by their instance reference, or by the Class of that view
  /// (eg, Spinner).
  ///
  ///@see \#excludeTarget(Class, boolean)
  ///@see \#excludeChildren(int, boolean)
  ///@see \#excludeChildren(View, boolean)
  ///@param type The type to ignore when running this transition.
  ///@param exclude Whether to add the target type to or remove it from the
  /// current list of excluded target types.
  ///@return This transition object.
  Transition excludeChildren2(jni.JniObject type, bool exclude) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_excludeChildren2,
          jni.JniType.objectType,
          [type.reference, exclude]).object);

  static final _id_addTarget3 = jniAccessors.getMethodIDOf(_classRef,
      "addTarget", "(Landroid/view/View;)Landroid/transition/Transition;");

  /// from: public android.transition.Transition addTarget(android.view.View target)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the target view instances that this Transition is interested in
  /// animating. By default, there are no targets, and a Transition will
  /// listen for changes on every view in the hierarchy below the sceneRoot
  /// of the Scene being transitioned into. Setting targets constrains
  /// the Transition to only listen for, and act on, these views.
  /// All other views will be ignored.
  ///
  /// The target list is like the \#addTarget(int) targetId
  /// list except this list specifies the actual View instances, not the ids
  /// of the views. This is an important distinction when scene changes involve
  /// view hierarchies which have been inflated separately; different views may
  /// share the same id but not actually be the same instance. If the transition
  /// should treat those views as the same, then \#addTarget(int) should be used
  /// instead of \#addTarget(View). If, on the other hand, scene changes involve
  /// changes all within the same view hierarchy, among views which do not
  /// necessarily have ids set on them, then the target list of views may be more
  /// convenient.
  ///
  ///@see \#addTarget(int)
  ///@param target A View on which the Transition will act, must be non-null.
  ///@return The Transition to which the target is added.
  /// Returning the same object makes it easier to chain calls during
  /// construction, such as
  /// <code>transitionSet.addTransitions(new Fade()).addTarget(someView);</code>
  Transition addTarget3(view_.View target) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_addTarget3, jni.JniType.objectType, [target.reference]).object);

  static final _id_removeTarget2 = jniAccessors.getMethodIDOf(_classRef,
      "removeTarget", "(Landroid/view/View;)Landroid/transition/Transition;");

  /// from: public android.transition.Transition removeTarget(android.view.View target)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes the given target from the list of targets that this Transition
  /// is interested in animating.
  ///@param target The target view, must be non-null.
  ///@return Transition The Transition from which the target is removed.
  /// Returning the same object makes it easier to chain calls during
  /// construction, such as
  /// <code>transitionSet.addTransitions(new Fade()).removeTarget(someView);</code>
  Transition removeTarget2(view_.View target) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_removeTarget2,
          jni.JniType.objectType,
          [target.reference]).object);

  static final _id_removeTarget3 = jniAccessors.getMethodIDOf(_classRef,
      "removeTarget", "(Ljava/lang/Class;)Landroid/transition/Transition;");

  /// from: public android.transition.Transition removeTarget(java.lang.Class target)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes the given target from the list of targets that this Transition
  /// is interested in animating.
  ///@param target The type of the target view, must be non-null.
  ///@return Transition The Transition from which the target is removed.
  /// Returning the same object makes it easier to chain calls during
  /// construction, such as
  /// <code>transitionSet.addTransitions(new Fade()).removeTarget(someType);</code>
  Transition removeTarget3(jni.JniObject target) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_removeTarget3,
          jni.JniType.objectType,
          [target.reference]).object);

  static final _id_getTargetIds = jniAccessors.getMethodIDOf(
      _classRef, "getTargetIds", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.Integer> getTargetIds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of target IDs that this transition limits itself to
  /// tracking and animating. If the list is null or empty for
  /// \#getTargetIds(), \#getTargets(), \#getTargetNames(), and
  /// \#getTargetTypes() then this transition is
  /// not limited to specific views, and will handle changes to any views
  /// in the hierarchy of a scene change.
  ///@return the list of target IDs
  jni.JniObject getTargetIds() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTargetIds, jni.JniType.objectType, []).object);

  static final _id_getTargets =
      jniAccessors.getMethodIDOf(_classRef, "getTargets", "()Ljava/util/List;");

  /// from: public java.util.List<android.view.View> getTargets()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of target views that this transition limits itself to
  /// tracking and animating. If the list is null or empty for
  /// \#getTargetIds(), \#getTargets(), \#getTargetNames(), and
  /// \#getTargetTypes() then this transition is
  /// not limited to specific views, and will handle changes to any views
  /// in the hierarchy of a scene change.
  ///@return the list of target views
  jni.JniObject getTargets() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTargets, jni.JniType.objectType, []).object);

  static final _id_getTargetNames = jniAccessors.getMethodIDOf(
      _classRef, "getTargetNames", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> getTargetNames()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of target transitionNames that this transition limits itself to
  /// tracking and animating. If the list is null or empty for
  /// \#getTargetIds(), \#getTargets(), \#getTargetNames(), and
  /// \#getTargetTypes() then this transition is
  /// not limited to specific views, and will handle changes to any views
  /// in the hierarchy of a scene change.
  ///@return the list of target transitionNames
  jni.JniObject getTargetNames() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTargetNames, jni.JniType.objectType, []).object);

  static final _id_getTargetTypes = jniAccessors.getMethodIDOf(
      _classRef, "getTargetTypes", "()Ljava/util/List;");

  /// from: public java.util.List<java.lang.Class> getTargetTypes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of target transitionNames that this transition limits itself to
  /// tracking and animating. If the list is null or empty for
  /// \#getTargetIds(), \#getTargets(), \#getTargetNames(), and
  /// \#getTargetTypes() then this transition is
  /// not limited to specific views, and will handle changes to any views
  /// in the hierarchy of a scene change.
  ///@return the list of target Types
  jni.JniObject getTargetTypes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTargetTypes, jni.JniType.objectType, []).object);

  static final _id_getTransitionValues = jniAccessors.getMethodIDOf(
      _classRef,
      "getTransitionValues",
      "(Landroid/view/View;Z)Landroid/transition/TransitionValues;");

  /// from: public android.transition.TransitionValues getTransitionValues(android.view.View view, boolean start)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method can be called by transitions to get the TransitionValues for
  /// any particular view during the transition-playing process. This might be
  /// necessary, for example, to query the before/after state of related views
  /// for a given transition.
  transitionvalues_.TransitionValues getTransitionValues(
          view_.View view, bool start) =>
      transitionvalues_.TransitionValues.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getTransitionValues,
              jni.JniType.objectType, [view.reference, start]).object);

  static final _id_isTransitionRequired = jniAccessors.getMethodIDOf(
      _classRef,
      "isTransitionRequired",
      "(Landroid/transition/TransitionValues;Landroid/transition/TransitionValues;)Z");

  /// from: public boolean isTransitionRequired(android.transition.TransitionValues startValues, android.transition.TransitionValues endValues)
  ///
  /// Returns whether or not the transition should create an Animator, based on the values
  /// captured during \#captureStartValues(TransitionValues) and
  /// \#captureEndValues(TransitionValues). The default implementation compares the
  /// property values returned from \#getTransitionProperties(), or all property values if
  /// {@code getTransitionProperties()} returns null. Subclasses may override this method to
  /// provide logic more specific to the transition implementation.
  ///@param startValues the values from captureStartValues, This may be {@code null} if the
  ///                    View did not exist in the start state.
  /// This value may be {@code null}.
  ///@param endValues the values from captureEndValues. This may be {@code null} if the View
  ///                  did not exist in the end state.
  ///
  /// This value may be {@code null}.
  bool isTransitionRequired(transitionvalues_.TransitionValues startValues,
          transitionvalues_.TransitionValues endValues) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isTransitionRequired,
          jni.JniType.booleanType,
          [startValues.reference, endValues.reference]).boolean;

  static final _id_addListener = jniAccessors.getMethodIDOf(
      _classRef,
      "addListener",
      "(Landroid/transition/Transition\$TransitionListener;)Landroid/transition/Transition;");

  /// from: public android.transition.Transition addListener(android.transition.Transition.TransitionListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds a listener to the set of listeners that are sent events through the
  /// life of an animation, such as start, repeat, and end.
  ///@param listener the listener to be added to the current set of listeners
  /// for this animation.
  ///@return This transition object.
  Transition addListener(Transition_TransitionListener listener) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_addListener,
          jni.JniType.objectType,
          [listener.reference]).object);

  static final _id_removeListener = jniAccessors.getMethodIDOf(
      _classRef,
      "removeListener",
      "(Landroid/transition/Transition\$TransitionListener;)Landroid/transition/Transition;");

  /// from: public android.transition.Transition removeListener(android.transition.Transition.TransitionListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Removes a listener from the set listening to this animation.
  ///@param listener the listener to be removed from the current set of
  /// listeners for this transition.
  ///@return This transition object.
  Transition removeListener(Transition_TransitionListener listener) =>
      Transition.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_removeListener,
          jni.JniType.objectType,
          [listener.reference]).object);

  static final _id_setEpicenterCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "setEpicenterCallback",
      "(Landroid/transition/Transition\$EpicenterCallback;)V");

  /// from: public void setEpicenterCallback(android.transition.Transition.EpicenterCallback epicenterCallback)
  ///
  /// Sets the callback to use to find the epicenter of a Transition. A null value indicates
  /// that there is no epicenter in the Transition and onGetEpicenter() will return null.
  /// Transitions like android.transition.Explode use a point or Rect to orient
  /// the direction of travel. This is called the epicenter of the Transition and is
  /// typically centered on a touched View. The
  /// android.transition.Transition.EpicenterCallback allows a Transition to
  /// dynamically retrieve the epicenter during a Transition.
  ///@param epicenterCallback The callback to use to find the epicenter of the Transition.
  void setEpicenterCallback(Transition_EpicenterCallback epicenterCallback) =>
      jniAccessors.callMethodWithArgs(reference, _id_setEpicenterCallback,
          jni.JniType.voidType, [epicenterCallback.reference]).check();

  static final _id_getEpicenterCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "getEpicenterCallback",
      "()Landroid/transition/Transition\$EpicenterCallback;");

  /// from: public android.transition.Transition.EpicenterCallback getEpicenterCallback()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the callback used to find the epicenter of the Transition.
  /// Transitions like android.transition.Explode use a point or Rect to orient
  /// the direction of travel. This is called the epicenter of the Transition and is
  /// typically centered on a touched View. The
  /// android.transition.Transition.EpicenterCallback allows a Transition to
  /// dynamically retrieve the epicenter during a Transition.
  ///@return the callback used to find the epicenter of the Transition.
  Transition_EpicenterCallback getEpicenterCallback() =>
      Transition_EpicenterCallback.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getEpicenterCallback,
          jni.JniType.objectType, []).object);

  static final _id_getEpicenter = jniAccessors.getMethodIDOf(
      _classRef, "getEpicenter", "()Landroid/graphics/Rect;");

  /// from: public android.graphics.Rect getEpicenter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the epicenter as specified by the
  /// android.transition.Transition.EpicenterCallback or null if no callback exists.
  ///@return the epicenter as specified by the
  /// android.transition.Transition.EpicenterCallback or null if no callback exists.
  ///@see \#setEpicenterCallback(android.transition.Transition.EpicenterCallback)
  rect_.Rect getEpicenter() =>
      rect_.Rect.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getEpicenter, jni.JniType.objectType, []).object);

  static final _id_setPathMotion = jniAccessors.getMethodIDOf(
      _classRef, "setPathMotion", "(Landroid/transition/PathMotion;)V");

  /// from: public void setPathMotion(android.transition.PathMotion pathMotion)
  ///
  /// Sets the algorithm used to calculate two-dimensional interpolation.
  ///
  ///     Transitions such as android.transition.ChangeBounds move Views, typically
  ///     in a straight path between the start and end positions. Applications that desire to
  ///     have these motions move in a curve can change how Views interpolate in two dimensions
  ///     by extending PathMotion and implementing
  ///     android.transition.PathMotion\#getPath(float, float, float, float).
  ///
  ///
  ///
  ///     When describing in XML, use a nested XML tag for the path motion. It can be one of
  ///     the built-in tags <code>arcMotion</code> or <code>patternPathMotion</code> or it can
  ///     be a custom PathMotion using <code>pathMotion</code> with the <code>class</code>
  ///     attributed with the fully-described class name. For example:
  ///
  /// <pre>
  /// {@code
  /// <changeBounds>
  ///     <pathMotion class="my.app.transition.MyPathMotion"/>
  /// </changeBounds>
  /// }
  /// </pre>
  /// or
  ///
  /// <pre>
  /// {@code
  /// <changeBounds>
  ///   <arcMotion android:minimumHorizontalAngle="15"
  ///     android:minimumVerticalAngle="0" android:maximumAngle="90"/>
  /// </changeBounds>
  /// }
  /// </pre>
  ///@param pathMotion Algorithm object to use for determining how to interpolate in two
  ///                   dimensions. If null, a straight-path algorithm will be used.
  ///@see android.transition.ArcMotion
  ///@see PatternPathMotion
  ///@see android.transition.PathMotion
  void setPathMotion(pathmotion_.PathMotion pathMotion) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPathMotion,
          jni.JniType.voidType, [pathMotion.reference]).check();

  static final _id_getPathMotion = jniAccessors.getMethodIDOf(
      _classRef, "getPathMotion", "()Landroid/transition/PathMotion;");

  /// from: public android.transition.PathMotion getPathMotion()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the algorithm object used to interpolate along two dimensions. This is typically
  /// used to determine the View motion between two points.
  ///
  ///
  ///     When describing in XML, use a nested XML tag for the path motion. It can be one of
  ///     the built-in tags <code>arcMotion</code> or <code>patternPathMotion</code> or it can
  ///     be a custom PathMotion using <code>pathMotion</code> with the <code>class</code>
  ///     attributed with the fully-described class name. For example:
  ///
  /// <pre>{@code
  /// <changeBounds>
  ///     <pathMotion class="my.app.transition.MyPathMotion"/>
  /// </changeBounds>}
  /// </pre>
  /// or
  ///
  /// <pre>{@code
  /// <changeBounds>
  ///   <arcMotion android:minimumHorizontalAngle="15"
  ///              android:minimumVerticalAngle="0"
  ///              android:maximumAngle="90"/>
  /// </changeBounds>}
  /// </pre>
  ///@return The algorithm object used to interpolate along two dimensions.
  ///@see android.transition.ArcMotion
  ///@see PatternPathMotion
  ///@see android.transition.PathMotion
  pathmotion_.PathMotion getPathMotion() =>
      pathmotion_.PathMotion.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPathMotion, jni.JniType.objectType, []).object);

  static final _id_setPropagation = jniAccessors.getMethodIDOf(_classRef,
      "setPropagation", "(Landroid/transition/TransitionPropagation;)V");

  /// from: public void setPropagation(android.transition.TransitionPropagation transitionPropagation)
  ///
  /// Sets the method for determining Animator start delays.
  /// When a Transition affects several Views like android.transition.Explode or
  /// android.transition.Slide, there may be a desire to have a "wave-front" effect
  /// such that the Animator start delay depends on position of the View. The
  /// TransitionPropagation specifies how the start delays are calculated.
  ///@param transitionPropagation The class used to determine the start delay of
  ///                              Animators created by this Transition. A null value
  ///                              indicates that no delay should be used.
  void setPropagation(
          transitionpropagation_.TransitionPropagation transitionPropagation) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPropagation,
          jni.JniType.voidType, [transitionPropagation.reference]).check();

  static final _id_getPropagation = jniAccessors.getMethodIDOf(_classRef,
      "getPropagation", "()Landroid/transition/TransitionPropagation;");

  /// from: public android.transition.TransitionPropagation getPropagation()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the android.transition.TransitionPropagation used to calculate Animator start
  /// delays.
  /// When a Transition affects several Views like android.transition.Explode or
  /// android.transition.Slide, there may be a desire to have a "wave-front" effect
  /// such that the Animator start delay depends on position of the View. The
  /// TransitionPropagation specifies how the start delays are calculated.
  ///@return the android.transition.TransitionPropagation used to calculate Animator start
  /// delays. This is null by default.
  transitionpropagation_.TransitionPropagation getPropagation() =>
      transitionpropagation_.TransitionPropagation.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getPropagation,
              jni.JniType.objectType, []).object);

  static final _id_canRemoveViews =
      jniAccessors.getMethodIDOf(_classRef, "canRemoveViews", "()Z");

  /// from: public boolean canRemoveViews()
  bool canRemoveViews() => jniAccessors.callMethodWithArgs(
      reference, _id_canRemoveViews, jni.JniType.booleanType, []).boolean;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_clone = jniAccessors.getMethodIDOf(
      _classRef, "clone", "()Landroid/transition/Transition;");

  /// from: public android.transition.Transition clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Transition clone() => Transition.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_getName =
      jniAccessors.getMethodIDOf(_classRef, "getName", "()Ljava/lang/String;");

  /// from: public java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name of this Transition. This name is used internally to distinguish
  /// between different transitions to determine when interrupting transitions overlap.
  /// For example, a ChangeBounds running on the same target view as another ChangeBounds
  /// should determine whether the old transition is animating to different end values
  /// and should be canceled in favor of the new transition.
  ///
  /// By default, a Transition's name is simply the value of Class\#getName(),
  /// but subclasses are free to override and return something different.
  ///
  ///@return The name of this transition.
  jni.JniString getName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniType.objectType, []).object);
}

/// from: android.transition.Transition$TransitionListener
///
/// A transition listener receives notifications from a transition.
/// Notifications indicate transition lifecycle events.
class Transition_TransitionListener extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/transition/Transition\$TransitionListener");
  Transition_TransitionListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onTransitionStart = jniAccessors.getMethodIDOf(
      _classRef, "onTransitionStart", "(Landroid/transition/Transition;)V");

  /// from: public abstract void onTransitionStart(android.transition.Transition transition)
  ///
  /// Notification about the start of the transition.
  ///@param transition The started transition.
  void onTransitionStart(Transition transition) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTransitionStart,
          jni.JniType.voidType, [transition.reference]).check();

  static final _id_onTransitionEnd = jniAccessors.getMethodIDOf(
      _classRef, "onTransitionEnd", "(Landroid/transition/Transition;)V");

  /// from: public abstract void onTransitionEnd(android.transition.Transition transition)
  ///
  /// Notification about the end of the transition. Canceled transitions
  /// will always notify listeners of both the cancellation and end
  /// events. That is, \#onTransitionEnd(Transition) is always called,
  /// regardless of whether the transition was canceled or played
  /// through to completion.
  ///@param transition The transition which reached its end.
  void onTransitionEnd(Transition transition) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTransitionEnd,
          jni.JniType.voidType, [transition.reference]).check();

  static final _id_onTransitionCancel = jniAccessors.getMethodIDOf(
      _classRef, "onTransitionCancel", "(Landroid/transition/Transition;)V");

  /// from: public abstract void onTransitionCancel(android.transition.Transition transition)
  ///
  /// Notification about the cancellation of the transition.
  /// Note that cancel may be called by a parent TransitionSet on
  /// a child transition which has not yet started. This allows the child
  /// transition to restore state on target objects which was set at
  /// \#createAnimator(android.view.ViewGroup, TransitionValues, TransitionValues) createAnimator() time.
  ///@param transition The transition which was canceled.
  void onTransitionCancel(Transition transition) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTransitionCancel,
          jni.JniType.voidType, [transition.reference]).check();

  static final _id_onTransitionPause = jniAccessors.getMethodIDOf(
      _classRef, "onTransitionPause", "(Landroid/transition/Transition;)V");

  /// from: public abstract void onTransitionPause(android.transition.Transition transition)
  ///
  /// Notification when a transition is paused.
  /// Note that createAnimator() may be called by a parent TransitionSet on
  /// a child transition which has not yet started. This allows the child
  /// transition to restore state on target objects which was set at
  /// \#createAnimator(android.view.ViewGroup, TransitionValues, TransitionValues) createAnimator() time.
  ///@param transition The transition which was paused.
  void onTransitionPause(Transition transition) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTransitionPause,
          jni.JniType.voidType, [transition.reference]).check();

  static final _id_onTransitionResume = jniAccessors.getMethodIDOf(
      _classRef, "onTransitionResume", "(Landroid/transition/Transition;)V");

  /// from: public abstract void onTransitionResume(android.transition.Transition transition)
  ///
  /// Notification when a transition is resumed.
  /// Note that resume() may be called by a parent TransitionSet on
  /// a child transition which has not yet started. This allows the child
  /// transition to restore state which may have changed in an earlier call
  /// to \#onTransitionPause(Transition).
  ///@param transition The transition which was resumed.
  void onTransitionResume(Transition transition) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTransitionResume,
          jni.JniType.voidType, [transition.reference]).check();
}

/// from: android.transition.Transition$EpicenterCallback
///
/// Class to get the epicenter of Transition. Use
/// \#setEpicenterCallback(android.transition.Transition.EpicenterCallback) to
/// set the callback used to calculate the epicenter of the Transition. Override
/// \#getEpicenter() to return the rectangular region in screen coordinates of
/// the epicenter of the transition.
///@see \#setEpicenterCallback(android.transition.Transition.EpicenterCallback)
class Transition_EpicenterCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/transition/Transition\$EpicenterCallback");
  Transition_EpicenterCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Transition_EpicenterCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onGetEpicenter = jniAccessors.getMethodIDOf(
      _classRef,
      "onGetEpicenter",
      "(Landroid/transition/Transition;)Landroid/graphics/Rect;");

  /// from: public abstract android.graphics.Rect onGetEpicenter(android.transition.Transition transition)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implementers must override to return the epicenter of the Transition in screen
  /// coordinates. Transitions like android.transition.Explode depend upon
  /// an epicenter for the Transition. In Explode, Views move toward or away from the
  /// center of the epicenter Rect along the vector between the epicenter and the center
  /// of the View appearing and disappearing. Some Transitions, such as
  /// android.transition.Fade pay no attention to the epicenter.
  ///@param transition The transition for which the epicenter applies.
  ///@return The Rect region of the epicenter of <code>transition</code> or null if
  /// there is no epicenter.
  rect_.Rect onGetEpicenter(Transition transition) =>
      rect_.Rect.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onGetEpicenter,
          jni.JniType.objectType,
          [transition.reference]).object);
}
