// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Visibility.dart" as visibility_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "TransitionValues.dart" as transitionvalues_;

import "../animation/Animator.dart" as animator_;

import "../view/ViewGroup.dart" as viewgroup_;

import "../view/View.dart" as view_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.transition.Fade
///
/// This transition tracks changes to the visibility of target views in the
/// start and end scenes and fades views in or out when they become visible
/// or non-visible. Visibility is determined by both the
/// View\#setVisibility(int) state of the view as well as whether it
/// is parented in the current view hierarchy.
///
/// The ability of this transition to fade out a particular view, and the
/// way that that fading operation takes place, is based on
/// the situation of the view in the view hierarchy. For example, if a view was
/// simply removed from its parent, then the view will be added into a android.view.ViewGroupOverlay while fading. If a visible view is
/// changed to be View\#GONE or View\#INVISIBLE, then the
/// visibility will be changed to View\#VISIBLE for the duration of
/// the animation. However, if a view is in a hierarchy which is also altering
/// its visibility, the situation can be more complicated. In general, if a
/// view that is no longer in the hierarchy in the end scene still has a
/// parent (so its parent hierarchy was removed, but it was not removed from
/// its parent), then it will be left alone to avoid side-effects from
/// improperly removing it from its parent. The only exception to this is if
/// the previous Scene was
/// Scene\#getSceneForLayout(android.view.ViewGroup, int, android.content.Context) created from a layout resource file, then it is considered safe to un-parent
/// the starting scene view in order to fade it out.
///
///
/// A Fade transition can be described in a resource file by using the
/// tag <code>fade</code>, along with the standard
/// attributes of android.R.styleable\#Fade and
/// android.R.styleable\#Transition.
///
class Fade extends visibility_.Visibility {
  static final _classRef = jniAccessors.getClassOf("android/transition/Fade");
  Fade.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int IN
  ///
  /// Fading mode used in \#Fade(int) to make the transition
  /// operate on targets that are appearing. Maybe be combined with
  /// \#OUT to fade both in and out. Equivalent to
  /// Visibility\#MODE_IN.
  static const IN = 1;

  /// from: static public final int OUT
  ///
  /// Fading mode used in \#Fade(int) to make the transition
  /// operate on targets that are disappearing. Maybe be combined with
  /// \#IN to fade both in and out. Equivalent to
  /// Visibility\#MODE_OUT.
  static const OUT = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a Fade transition that will fade targets in and out.
  Fade()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int fadingMode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a Fade transition that will fade targets in
  /// and/or out, according to the value of fadingMode.
  ///@param fadingMode The behavior of this transition, a combination of
  /// \#IN and \#OUT.
  Fade.ctor2(int fadingMode)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [fadingMode]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Fade.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_captureStartValues = jniAccessors.getMethodIDOf(_classRef,
      "captureStartValues", "(Landroid/transition/TransitionValues;)V");

  /// from: public void captureStartValues(android.transition.TransitionValues transitionValues)
  void captureStartValues(
          transitionvalues_.TransitionValues transitionValues) =>
      jniAccessors.callMethodWithArgs(reference, _id_captureStartValues,
          jni.JniType.voidType, [transitionValues.reference]).check();

  static final _id_onAppear1 = jniAccessors.getMethodIDOf(_classRef, "onAppear",
      "(Landroid/view/ViewGroup;Landroid/view/View;Landroid/transition/TransitionValues;Landroid/transition/TransitionValues;)Landroid/animation/Animator;");

  /// from: public android.animation.Animator onAppear(android.view.ViewGroup sceneRoot, android.view.View view, android.transition.TransitionValues startValues, android.transition.TransitionValues endValues)
  /// The returned object must be deleted after use, by calling the `delete` method.
  animator_.Animator onAppear1(
          viewgroup_.ViewGroup sceneRoot,
          view_.View view,
          transitionvalues_.TransitionValues startValues,
          transitionvalues_.TransitionValues endValues) =>
      animator_.Animator.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onAppear1, jni.JniType.objectType, [
        sceneRoot.reference,
        view.reference,
        startValues.reference,
        endValues.reference
      ]).object);

  static final _id_onDisappear1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onDisappear",
      "(Landroid/view/ViewGroup;Landroid/view/View;Landroid/transition/TransitionValues;Landroid/transition/TransitionValues;)Landroid/animation/Animator;");

  /// from: public android.animation.Animator onDisappear(android.view.ViewGroup sceneRoot, android.view.View view, android.transition.TransitionValues startValues, android.transition.TransitionValues endValues)
  /// The returned object must be deleted after use, by calling the `delete` method.
  animator_.Animator onDisappear1(
          viewgroup_.ViewGroup sceneRoot,
          view_.View view,
          transitionvalues_.TransitionValues startValues,
          transitionvalues_.TransitionValues endValues) =>
      animator_.Animator.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onDisappear1, jni.JniType.objectType, [
        sceneRoot.reference,
        view.reference,
        startValues.reference,
        endValues.reference
      ]).object);
}
