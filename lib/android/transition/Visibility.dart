// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "Transition.dart" as transition_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "TransitionValues.dart" as transitionvalues_;

import "../animation/Animator.dart" as animator_;

import "../view/ViewGroup.dart" as viewgroup_;

import "../view/View.dart" as view_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.transition.Visibility
///
/// This transition tracks changes to the visibility of target views in the
/// start and end scenes. Visibility is determined not just by the
/// View\#setVisibility(int) state of views, but also whether
/// views exist in the current view hierarchy. The class is intended to be a
/// utility for subclasses such as Fade, which use this visibility
/// information to determine the specific animations to run when visibility
/// changes occur. Subclasses should implement one or both of the methods
/// \#onAppear(ViewGroup, TransitionValues, int, TransitionValues, int),
/// \#onDisappear(ViewGroup, TransitionValues, int, TransitionValues, int) or
/// \#onAppear(ViewGroup, View, TransitionValues, TransitionValues),
/// \#onDisappear(ViewGroup, View, TransitionValues, TransitionValues).
class Visibility extends transition_.Transition {
  static final _classRef =
      jniAccessors.getClassOf("android/transition/Visibility");
  Visibility.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int MODE_IN
  ///
  /// Mode used in \#setMode(int) to make the transition
  /// operate on targets that are appearing. Maybe be combined with
  /// \#MODE_OUT to target Visibility changes both in and out.
  static const MODE_IN = 1;

  /// from: static public final int MODE_OUT
  ///
  /// Mode used in \#setMode(int) to make the transition
  /// operate on targets that are disappearing. Maybe be combined with
  /// \#MODE_IN to target Visibility changes both in and out.
  static const MODE_OUT = 2;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Visibility()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Visibility.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_setMode =
      jniAccessors.getMethodIDOf(_classRef, "setMode", "(I)V");

  /// from: public void setMode(int mode)
  ///
  /// Changes the transition to support appearing and/or disappearing Views, depending
  /// on <code>mode</code>.
  ///@param mode The behavior supported by this transition, a combination of
  ///             \#MODE_IN and \#MODE_OUT.
  /// Value is either <code>0</code> or a combination of android.transition.Visibility\#MODE_IN, and android.transition.Visibility\#MODE_OUT
  ///@attr ref android.R.styleable\#VisibilityTransition_transitionVisibilityMode
  void setMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setMode, jni.JniType.voidType, [mode]).check();

  static final _id_getMode =
      jniAccessors.getMethodIDOf(_classRef, "getMode", "()I");

  /// from: public int getMode()
  ///
  /// Returns whether appearing and/or disappearing Views are supported.
  ///
  /// Returns whether appearing and/or disappearing Views are supported. A combination of
  ///         \#MODE_IN and \#MODE_OUT.
  ///@attr ref android.R.styleable\#VisibilityTransition_transitionVisibilityMode
  ///@return Value is either <code>0</code> or a combination of android.transition.Visibility\#MODE_IN, and android.transition.Visibility\#MODE_OUT
  int getMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getMode, jni.JniType.intType, []).integer;

  static final _id_getTransitionProperties = jniAccessors.getMethodIDOf(
      _classRef, "getTransitionProperties", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getTransitionProperties()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getTransitionProperties() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getTransitionProperties, jni.JniType.objectType, []).object);

  static final _id_captureStartValues = jniAccessors.getMethodIDOf(_classRef,
      "captureStartValues", "(Landroid/transition/TransitionValues;)V");

  /// from: public void captureStartValues(android.transition.TransitionValues transitionValues)
  void captureStartValues(
          transitionvalues_.TransitionValues transitionValues) =>
      jniAccessors.callMethodWithArgs(reference, _id_captureStartValues,
          jni.JniType.voidType, [transitionValues.reference]).check();

  static final _id_captureEndValues = jniAccessors.getMethodIDOf(_classRef,
      "captureEndValues", "(Landroid/transition/TransitionValues;)V");

  /// from: public void captureEndValues(android.transition.TransitionValues transitionValues)
  void captureEndValues(transitionvalues_.TransitionValues transitionValues) =>
      jniAccessors.callMethodWithArgs(reference, _id_captureEndValues,
          jni.JniType.voidType, [transitionValues.reference]).check();

  static final _id_isVisible = jniAccessors.getMethodIDOf(
      _classRef, "isVisible", "(Landroid/transition/TransitionValues;)Z");

  /// from: public boolean isVisible(android.transition.TransitionValues values)
  ///
  /// Returns whether the view is 'visible' according to the given values
  /// object. This is determined by testing the same properties in the values
  /// object that are used to determine whether the object is appearing or
  /// disappearing in the Transition\#createAnimator(ViewGroup, TransitionValues, TransitionValues)
  /// method. This method can be called by, for example, subclasses that want
  /// to know whether the object is visible in the same way that Visibility
  /// determines it for the actual animation.
  ///@param values The TransitionValues object that holds the information by
  /// which visibility is determined.
  ///@return True if the view reference by <code>values</code> is visible,
  /// false otherwise.
  bool isVisible(transitionvalues_.TransitionValues values) =>
      jniAccessors.callMethodWithArgs(reference, _id_isVisible,
          jni.JniType.booleanType, [values.reference]).boolean;

  static final _id_createAnimator = jniAccessors.getMethodIDOf(
      _classRef,
      "createAnimator",
      "(Landroid/view/ViewGroup;Landroid/transition/TransitionValues;Landroid/transition/TransitionValues;)Landroid/animation/Animator;");

  /// from: public android.animation.Animator createAnimator(android.view.ViewGroup sceneRoot, android.transition.TransitionValues startValues, android.transition.TransitionValues endValues)
  /// The returned object must be deleted after use, by calling the `delete` method.
  animator_.Animator createAnimator(
          viewgroup_.ViewGroup sceneRoot,
          transitionvalues_.TransitionValues startValues,
          transitionvalues_.TransitionValues endValues) =>
      animator_.Animator.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createAnimator, jni.JniType.objectType, [
        sceneRoot.reference,
        startValues.reference,
        endValues.reference
      ]).object);

  static final _id_onAppear = jniAccessors.getMethodIDOf(_classRef, "onAppear",
      "(Landroid/view/ViewGroup;Landroid/transition/TransitionValues;ILandroid/transition/TransitionValues;I)Landroid/animation/Animator;");

  /// from: public android.animation.Animator onAppear(android.view.ViewGroup sceneRoot, android.transition.TransitionValues startValues, int startVisibility, android.transition.TransitionValues endValues, int endVisibility)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The default implementation of this method calls
  /// \#onAppear(ViewGroup, View, TransitionValues, TransitionValues).
  /// Subclasses should override this method or
  /// \#onAppear(ViewGroup, View, TransitionValues, TransitionValues).
  /// if they need to create an Animator when targets appear.
  /// The method should only be called by the Visibility class; it is
  /// not intended to be called from external classes.
  ///@param sceneRoot The root of the transition hierarchy
  ///@param startValues The target values in the start scene
  ///@param startVisibility The target visibility in the start scene
  ///@param endValues The target values in the end scene
  ///@param endVisibility The target visibility in the end scene
  ///@return An Animator to be started at the appropriate time in the
  /// overall transition for this scene change. A null value means no animation
  /// should be run.
  animator_.Animator onAppear(
          viewgroup_.ViewGroup sceneRoot,
          transitionvalues_.TransitionValues startValues,
          int startVisibility,
          transitionvalues_.TransitionValues endValues,
          int endVisibility) =>
      animator_.Animator.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_onAppear, jni.JniType.objectType, [
        sceneRoot.reference,
        startValues.reference,
        startVisibility,
        endValues.reference,
        endVisibility
      ]).object);

  static final _id_onAppear1 = jniAccessors.getMethodIDOf(_classRef, "onAppear",
      "(Landroid/view/ViewGroup;Landroid/view/View;Landroid/transition/TransitionValues;Landroid/transition/TransitionValues;)Landroid/animation/Animator;");

  /// from: public android.animation.Animator onAppear(android.view.ViewGroup sceneRoot, android.view.View view, android.transition.TransitionValues startValues, android.transition.TransitionValues endValues)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The default implementation of this method returns a null Animator. Subclasses should
  /// override this method to make targets appear with the desired transition. The
  /// method should only be called from
  /// \#onAppear(ViewGroup, TransitionValues, int, TransitionValues, int).
  ///@param sceneRoot The root of the transition hierarchy
  ///@param view The View to make appear. This will be in the target scene's View hierarchy and
  ///             will be VISIBLE.
  ///@param startValues The target values in the start scene
  ///@param endValues The target values in the end scene
  ///@return An Animator to be started at the appropriate time in the
  /// overall transition for this scene change. A null value means no animation
  /// should be run.
  animator_.Animator onAppear1(
          viewgroup_.ViewGroup sceneRoot,
          view_.View view,
          transitionvalues_.TransitionValues startValues,
          transitionvalues_.TransitionValues endValues) =>
      animator_.Animator.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onAppear1, jni.JniType.objectType, [
        sceneRoot.reference,
        view.reference,
        startValues.reference,
        endValues.reference
      ]).object);

  static final _id_onDisappear = jniAccessors.getMethodIDOf(
      _classRef,
      "onDisappear",
      "(Landroid/view/ViewGroup;Landroid/transition/TransitionValues;ILandroid/transition/TransitionValues;I)Landroid/animation/Animator;");

  /// from: public android.animation.Animator onDisappear(android.view.ViewGroup sceneRoot, android.transition.TransitionValues startValues, int startVisibility, android.transition.TransitionValues endValues, int endVisibility)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Subclasses should override this method or
  /// \#onDisappear(ViewGroup, View, TransitionValues, TransitionValues)
  /// if they need to create an Animator when targets disappear.
  /// The method should only be called by the Visibility class; it is
  /// not intended to be called from external classes.
  ///
  /// The default implementation of this method attempts to find a View to use to call
  /// \#onDisappear(ViewGroup, View, TransitionValues, TransitionValues),
  /// based on the situation of the View in the View hierarchy. For example,
  /// if a View was simply removed from its parent, then the View will be added
  /// into a android.view.ViewGroupOverlay and passed as the <code>view</code>
  /// parameter in \#onDisappear(ViewGroup, View, TransitionValues, TransitionValues).
  /// If a visible View is changed to be View\#GONE or View\#INVISIBLE,
  /// then it can be used as the <code>view</code> and the visibility will be changed
  /// to View\#VISIBLE for the duration of the animation. However, if a View
  /// is in a hierarchy which is also altering its visibility, the situation can be
  /// more complicated. In general, if a view that is no longer in the hierarchy in
  /// the end scene still has a parent (so its parent hierarchy was removed, but it
  /// was not removed from its parent), then it will be left alone to avoid side-effects from
  /// improperly removing it from its parent. The only exception to this is if
  /// the previous Scene was Scene\#getSceneForLayout(ViewGroup, int,
  /// android.content.Context) created from a layout resource file, then it is considered
  /// safe to un-parent the starting scene view in order to make it disappear.
  ///
  ///@param sceneRoot The root of the transition hierarchy
  ///@param startValues The target values in the start scene
  ///@param startVisibility The target visibility in the start scene
  ///@param endValues The target values in the end scene
  ///@param endVisibility The target visibility in the end scene
  ///@return An Animator to be started at the appropriate time in the
  /// overall transition for this scene change. A null value means no animation
  /// should be run.
  animator_.Animator onDisappear(
          viewgroup_.ViewGroup sceneRoot,
          transitionvalues_.TransitionValues startValues,
          int startVisibility,
          transitionvalues_.TransitionValues endValues,
          int endVisibility) =>
      animator_.Animator.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onDisappear, jni.JniType.objectType, [
        sceneRoot.reference,
        startValues.reference,
        startVisibility,
        endValues.reference,
        endVisibility
      ]).object);

  static final _id_isTransitionRequired = jniAccessors.getMethodIDOf(
      _classRef,
      "isTransitionRequired",
      "(Landroid/transition/TransitionValues;Landroid/transition/TransitionValues;)Z");

  /// from: public boolean isTransitionRequired(android.transition.TransitionValues startValues, android.transition.TransitionValues newValues)
  bool isTransitionRequired(transitionvalues_.TransitionValues startValues,
          transitionvalues_.TransitionValues newValues) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isTransitionRequired,
          jni.JniType.booleanType,
          [startValues.reference, newValues.reference]).boolean;

  static final _id_onDisappear1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onDisappear",
      "(Landroid/view/ViewGroup;Landroid/view/View;Landroid/transition/TransitionValues;Landroid/transition/TransitionValues;)Landroid/animation/Animator;");

  /// from: public android.animation.Animator onDisappear(android.view.ViewGroup sceneRoot, android.view.View view, android.transition.TransitionValues startValues, android.transition.TransitionValues endValues)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The default implementation of this method returns a null Animator. Subclasses should
  /// override this method to make targets disappear with the desired transition. The
  /// method should only be called from
  /// \#onDisappear(ViewGroup, TransitionValues, int, TransitionValues, int).
  ///@param sceneRoot The root of the transition hierarchy
  ///@param view The View to make disappear. This will be in the target scene's View
  ///             hierarchy or in an android.view.ViewGroupOverlay and will be
  ///             VISIBLE.
  ///@param startValues The target values in the start scene
  ///@param endValues The target values in the end scene
  ///@return An Animator to be started at the appropriate time in the
  /// overall transition for this scene change. A null value means no animation
  /// should be run.
  animator_.Animator onDisappear1(
          viewgroup_.ViewGroup sceneRoot,
          view_.View view,
          transitionvalues_.TransitionValues startValues,
          transitionvalues_.TransitionValues endValues) =>
      animator_.Animator.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onDisappear1, jni.JniType.objectType, [
        sceneRoot.reference,
        view.reference,
        startValues.reference,
        endValues.reference
      ]).object);
}
