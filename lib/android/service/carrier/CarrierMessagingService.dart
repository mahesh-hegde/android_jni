// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../app/Service.dart" as service_;

import "MessagePdu.dart" as messagepdu_;

import "../../net/Uri.dart" as uri_;

import "../../os/IBinder.dart" as ibinder_;

import "../../content/Intent.dart" as intent_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.service.carrier.CarrierMessagingService
///
/// A service that receives calls from the system when new SMS and MMS are
/// sent or received.
/// To extend this class, you must declare the service in your manifest file with
/// the android.Manifest.permission\#BIND_CARRIER_SERVICES permission
/// and include an intent filter with the \#SERVICE_INTERFACE action. For example:
///
/// <pre>
/// &lt;service android:name=".MyMessagingService"
///          android:label="&\#64;string/service_name"
///          android:permission="android.permission.BIND_CARRIER_SERVICES">
///     &lt;intent-filter>
///         &lt;action android:name="android.service.carrier.CarrierMessagingService" />
///     &lt;/intent-filter>
/// &lt;/service></pre>
class CarrierMessagingService extends service_.Service {
  static final _classRef = jniAccessors
      .getClassOf("android/service/carrier/CarrierMessagingService");
  CarrierMessagingService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int DOWNLOAD_STATUS_ERROR
  ///
  /// MMS downloading failed. We should not retry via the carrier network.
  static const DOWNLOAD_STATUS_ERROR = 2;

  /// from: static public final int DOWNLOAD_STATUS_OK
  ///
  /// Successfully downloaded an MMS message.
  static const DOWNLOAD_STATUS_OK = 0;

  /// from: static public final int DOWNLOAD_STATUS_RETRY_ON_CARRIER_NETWORK
  ///
  /// MMS downloading failed. We should retry via the carrier network.
  static const DOWNLOAD_STATUS_RETRY_ON_CARRIER_NETWORK = 1;

  /// from: static public final int RECEIVE_OPTIONS_DEFAULT
  ///
  /// The default bitmask value passed to the callback of \#onReceiveTextSms with all
  /// {@code RECEIVE_OPTIONS_x} flags cleared to indicate that the message should be kept and a
  /// new message notification should be shown.
  ///@see \#RECEIVE_OPTIONS_DROP
  ///@see \#RECEIVE_OPTIONS_SKIP_NOTIFY_WHEN_CREDENTIAL_PROTECTED_STORAGE_UNAVAILABLE
  static const RECEIVE_OPTIONS_DEFAULT = 0;

  /// from: static public final int RECEIVE_OPTIONS_DROP
  ///
  /// Used to set the flag in the bitmask passed to the callback of \#onReceiveTextSms to
  /// indicate that the inbound SMS should be dropped.
  static const RECEIVE_OPTIONS_DROP = 1;

  /// from: static public final int RECEIVE_OPTIONS_SKIP_NOTIFY_WHEN_CREDENTIAL_PROTECTED_STORAGE_UNAVAILABLE
  ///
  /// Used to set the flag in the bitmask passed to the callback of \#onReceiveTextSms to
  /// indicate that a new message notification should not be shown to the user when the
  /// credential-encrypted storage of the device is not available before the user unlocks the
  /// phone. It is only applicable to devices that support file-based encryption.
  static const RECEIVE_OPTIONS_SKIP_NOTIFY_WHEN_CREDENTIAL_PROTECTED_STORAGE_UNAVAILABLE =
      2;

  /// from: static public final int SEND_FLAG_REQUEST_DELIVERY_STATUS
  ///
  /// Flag to request SMS delivery status report.
  static const SEND_FLAG_REQUEST_DELIVERY_STATUS = 1;

  /// from: static public final int SEND_STATUS_ERROR
  ///
  /// SMS/MMS sending failed. We should not retry via the carrier network.
  static const SEND_STATUS_ERROR = 2;

  /// from: static public final int SEND_STATUS_OK
  ///
  /// Indicates that an SMS or MMS message was successfully sent.
  static const SEND_STATUS_OK = 0;

  /// from: static public final int SEND_STATUS_RETRY_ON_CARRIER_NETWORK
  ///
  /// SMS/MMS sending failed. We should retry via the carrier network.
  static const SEND_STATUS_RETRY_ON_CARRIER_NETWORK = 1;

  /// from: static public final java.lang.String SERVICE_INTERFACE
  ///
  /// The android.content.Intent that must be declared as handled by the service.
  static const SERVICE_INTERFACE =
      "android.service.carrier.CarrierMessagingService";

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  CarrierMessagingService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_onFilterSms = jniAccessors.getMethodIDOf(
      _classRef,
      "onFilterSms",
      "(Landroid/service/carrier/MessagePdu;Ljava/lang/String;IILandroid/service/carrier/CarrierMessagingService\$ResultCallback;)V");

  /// from: public void onFilterSms(android.service.carrier.MessagePdu pdu, java.lang.String format, int destPort, int subId, android.service.carrier.CarrierMessagingService.ResultCallback<java.lang.Boolean> callback)
  ///
  /// Override this method to filter inbound SMS messages.
  ///@param pdu the PDUs of the message
  /// This value must never be {@code null}.
  ///@param format the format of the PDUs, typically "3gpp" or "3gpp2"
  /// This value must never be {@code null}.
  ///@param destPort the destination port of a binary SMS, this will be -1 for text SMS
  ///@param subId SMS subscription ID of the SIM
  ///@param callback result callback. Call with {@code true} to keep an inbound SMS message and
  ///        deliver to SMS apps, and {@code false} to drop the message.
  /// This value must never be {@code null}.
  ///@deprecated Use \#onReceiveTextSms instead.
  void onFilterSms(
          messagepdu_.MessagePdu pdu,
          jni.JniString format,
          int destPort,
          int subId,
          CarrierMessagingService_ResultCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onFilterSms, jni.JniType.voidType, [
        pdu.reference,
        format.reference,
        destPort,
        subId,
        callback.reference
      ]).check();

  static final _id_onReceiveTextSms = jniAccessors.getMethodIDOf(
      _classRef,
      "onReceiveTextSms",
      "(Landroid/service/carrier/MessagePdu;Ljava/lang/String;IILandroid/service/carrier/CarrierMessagingService\$ResultCallback;)V");

  /// from: public void onReceiveTextSms(android.service.carrier.MessagePdu pdu, java.lang.String format, int destPort, int subId, android.service.carrier.CarrierMessagingService.ResultCallback<java.lang.Integer> callback)
  ///
  /// Override this method to filter inbound SMS messages.
  ///
  /// This method will be called once for every incoming text SMS. You can invoke the callback
  /// with a bitmask to tell the platform how to handle the SMS. For a SMS received on a
  /// file-based encryption capable device while the credential-encrypted storage is not available,
  /// this method will be called for the second time when the credential-encrypted storage becomes
  /// available after the user unlocks the phone, if the bit \#RECEIVE_OPTIONS_DROP is not
  /// set when invoking the callback.
  ///@param pdu the PDUs of the message
  /// This value must never be {@code null}.
  ///@param format the format of the PDUs, typically "3gpp" or "3gpp2"
  /// This value must never be {@code null}.
  ///@param destPort the destination port of a binary SMS, this will be -1 for text SMS
  ///@param subId SMS subscription ID of the SIM
  ///@param callback result callback. Call with a bitmask integer to indicate how the incoming
  ///        text SMS should be handled by the platform. Use \#RECEIVE_OPTIONS_DROP and
  ///        \#RECEIVE_OPTIONS_SKIP_NOTIFY_WHEN_CREDENTIAL_PROTECTED_STORAGE_UNAVAILABLE
  ///        to set the flags in the bitmask.
  ///
  /// This value must never be {@code null}.
  void onReceiveTextSms(
          messagepdu_.MessagePdu pdu,
          jni.JniString format,
          int destPort,
          int subId,
          CarrierMessagingService_ResultCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onReceiveTextSms, jni.JniType.voidType, [
        pdu.reference,
        format.reference,
        destPort,
        subId,
        callback.reference
      ]).check();

  static final _id_onSendTextSms = jniAccessors.getMethodIDOf(
      _classRef,
      "onSendTextSms",
      "(Ljava/lang/String;ILjava/lang/String;Landroid/service/carrier/CarrierMessagingService\$ResultCallback;)V");

  /// from: public void onSendTextSms(java.lang.String text, int subId, java.lang.String destAddress, android.service.carrier.CarrierMessagingService.ResultCallback<android.service.carrier.CarrierMessagingService.SendSmsResult> callback)
  ///
  /// Override this method to intercept text SMSs sent from the device.
  ///@deprecated Override \#onSendTextSms below instead.
  ///@param text the text to send
  /// This value must never be {@code null}.
  ///@param subId SMS subscription ID of the SIM
  ///@param destAddress phone number of the recipient of the message
  /// This value must never be {@code null}.
  ///@param callback result callback. Call with a SendSmsResult.
  ///
  /// This value must never be {@code null}.
  void onSendTextSms(jni.JniString text, int subId, jni.JniString destAddress,
          CarrierMessagingService_ResultCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onSendTextSms, jni.JniType.voidType, [
        text.reference,
        subId,
        destAddress.reference,
        callback.reference
      ]).check();

  static final _id_onSendTextSms1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onSendTextSms",
      "(Ljava/lang/String;ILjava/lang/String;ILandroid/service/carrier/CarrierMessagingService\$ResultCallback;)V");

  /// from: public void onSendTextSms(java.lang.String text, int subId, java.lang.String destAddress, int sendSmsFlag, android.service.carrier.CarrierMessagingService.ResultCallback<android.service.carrier.CarrierMessagingService.SendSmsResult> callback)
  ///
  /// Override this method to intercept text SMSs sent from the device.
  ///@param text the text to send
  /// This value must never be {@code null}.
  ///@param subId SMS subscription ID of the SIM
  ///@param destAddress phone number of the recipient of the message
  /// This value must never be {@code null}.
  ///@param sendSmsFlag Flag for sending SMS. Acceptable values are 0 and
  ///        \#SEND_FLAG_REQUEST_DELIVERY_STATUS.
  ///@param callback result callback. Call with a SendSmsResult.
  ///
  /// This value must never be {@code null}.
  void onSendTextSms1(jni.JniString text, int subId, jni.JniString destAddress,
          int sendSmsFlag, CarrierMessagingService_ResultCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onSendTextSms1, jni.JniType.voidType, [
        text.reference,
        subId,
        destAddress.reference,
        sendSmsFlag,
        callback.reference
      ]).check();

  static final _id_onSendDataSms = jniAccessors.getMethodIDOf(
      _classRef,
      "onSendDataSms",
      "([BILjava/lang/String;ILandroid/service/carrier/CarrierMessagingService\$ResultCallback;)V");

  /// from: public void onSendDataSms(byte[] data, int subId, java.lang.String destAddress, int destPort, android.service.carrier.CarrierMessagingService.ResultCallback<android.service.carrier.CarrierMessagingService.SendSmsResult> callback)
  ///
  /// Override this method to intercept binary SMSs sent from the device.
  ///@deprecated Override \#onSendDataSms below instead.
  ///@param data the binary content
  /// This value must never be {@code null}.
  ///@param subId SMS subscription ID of the SIM
  ///@param destAddress phone number of the recipient of the message
  /// This value must never be {@code null}.
  ///@param destPort the destination port
  ///@param callback result callback. Call with a SendSmsResult.
  ///
  /// This value must never be {@code null}.
  void onSendDataSms(jni.JniObject data, int subId, jni.JniString destAddress,
          int destPort, CarrierMessagingService_ResultCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onSendDataSms, jni.JniType.voidType, [
        data.reference,
        subId,
        destAddress.reference,
        destPort,
        callback.reference
      ]).check();

  static final _id_onSendDataSms1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onSendDataSms",
      "([BILjava/lang/String;IILandroid/service/carrier/CarrierMessagingService\$ResultCallback;)V");

  /// from: public void onSendDataSms(byte[] data, int subId, java.lang.String destAddress, int destPort, int sendSmsFlag, android.service.carrier.CarrierMessagingService.ResultCallback<android.service.carrier.CarrierMessagingService.SendSmsResult> callback)
  ///
  /// Override this method to intercept binary SMSs sent from the device.
  ///@param data the binary content
  /// This value must never be {@code null}.
  ///@param subId SMS subscription ID of the SIM
  ///@param destAddress phone number of the recipient of the message
  /// This value must never be {@code null}.
  ///@param destPort the destination port
  ///@param sendSmsFlag Flag for sending SMS. Acceptable values are 0 and
  ///        \#SEND_FLAG_REQUEST_DELIVERY_STATUS.
  ///@param callback result callback. Call with a SendSmsResult.
  ///
  /// This value must never be {@code null}.
  void onSendDataSms1(
          jni.JniObject data,
          int subId,
          jni.JniString destAddress,
          int destPort,
          int sendSmsFlag,
          CarrierMessagingService_ResultCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onSendDataSms1, jni.JniType.voidType, [
        data.reference,
        subId,
        destAddress.reference,
        destPort,
        sendSmsFlag,
        callback.reference
      ]).check();

  static final _id_onSendMultipartTextSms = jniAccessors.getMethodIDOf(
      _classRef,
      "onSendMultipartTextSms",
      "(Ljava/util/List;ILjava/lang/String;Landroid/service/carrier/CarrierMessagingService\$ResultCallback;)V");

  /// from: public void onSendMultipartTextSms(java.util.List<java.lang.String> parts, int subId, java.lang.String destAddress, android.service.carrier.CarrierMessagingService.ResultCallback<android.service.carrier.CarrierMessagingService.SendMultipartSmsResult> callback)
  ///
  /// Override this method to intercept long SMSs sent from the device.
  ///@deprecated Override \#onSendMultipartTextSms below instead.
  ///@param parts a List of the message parts
  /// This value must never be {@code null}.
  ///@param subId SMS subscription ID of the SIM
  ///@param destAddress phone number of the recipient of the message
  /// This value must never be {@code null}.
  ///@param callback result callback. Call with a SendMultipartSmsResult.
  ///
  /// This value must never be {@code null}.
  void onSendMultipartTextSms(
          jni.JniObject parts,
          int subId,
          jni.JniString destAddress,
          CarrierMessagingService_ResultCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onSendMultipartTextSms, jni.JniType.voidType, [
        parts.reference,
        subId,
        destAddress.reference,
        callback.reference
      ]).check();

  static final _id_onSendMultipartTextSms1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onSendMultipartTextSms",
      "(Ljava/util/List;ILjava/lang/String;ILandroid/service/carrier/CarrierMessagingService\$ResultCallback;)V");

  /// from: public void onSendMultipartTextSms(java.util.List<java.lang.String> parts, int subId, java.lang.String destAddress, int sendSmsFlag, android.service.carrier.CarrierMessagingService.ResultCallback<android.service.carrier.CarrierMessagingService.SendMultipartSmsResult> callback)
  ///
  /// Override this method to intercept long SMSs sent from the device.
  ///@param parts a List of the message parts
  /// This value must never be {@code null}.
  ///@param subId SMS subscription ID of the SIM
  ///@param destAddress phone number of the recipient of the message
  /// This value must never be {@code null}.
  ///@param sendSmsFlag Flag for sending SMS. Acceptable values are 0 and
  ///        \#SEND_FLAG_REQUEST_DELIVERY_STATUS.
  ///@param callback result callback. Call with a SendMultipartSmsResult.
  ///
  /// This value must never be {@code null}.
  void onSendMultipartTextSms1(
          jni.JniObject parts,
          int subId,
          jni.JniString destAddress,
          int sendSmsFlag,
          CarrierMessagingService_ResultCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onSendMultipartTextSms1, jni.JniType.voidType, [
        parts.reference,
        subId,
        destAddress.reference,
        sendSmsFlag,
        callback.reference
      ]).check();

  static final _id_onSendMms = jniAccessors.getMethodIDOf(
      _classRef,
      "onSendMms",
      "(Landroid/net/Uri;ILandroid/net/Uri;Landroid/service/carrier/CarrierMessagingService\$ResultCallback;)V");

  /// from: public void onSendMms(android.net.Uri pduUri, int subId, android.net.Uri location, android.service.carrier.CarrierMessagingService.ResultCallback<android.service.carrier.CarrierMessagingService.SendMmsResult> callback)
  ///
  /// Override this method to intercept MMSs sent from the device.
  ///@param pduUri the content provider URI of the PDU to send
  /// This value must never be {@code null}.
  ///@param subId SMS subscription ID of the SIM
  ///@param location the optional URI to send this MMS PDU. If this is {code null},
  ///        the PDU should be sent to the default MMSC URL.
  /// This value may be {@code null}.
  ///@param callback result callback. Call with a SendMmsResult.
  ///
  /// This value must never be {@code null}.
  void onSendMms(uri_.Uri pduUri, int subId, uri_.Uri location,
          CarrierMessagingService_ResultCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onSendMms, jni.JniType.voidType, [
        pduUri.reference,
        subId,
        location.reference,
        callback.reference
      ]).check();

  static final _id_onDownloadMms = jniAccessors.getMethodIDOf(
      _classRef,
      "onDownloadMms",
      "(Landroid/net/Uri;ILandroid/net/Uri;Landroid/service/carrier/CarrierMessagingService\$ResultCallback;)V");

  /// from: public void onDownloadMms(android.net.Uri contentUri, int subId, android.net.Uri location, android.service.carrier.CarrierMessagingService.ResultCallback<java.lang.Integer> callback)
  ///
  /// Override this method to download MMSs received.
  ///@param contentUri the content provider URI of the PDU to be downloaded.
  /// This value must never be {@code null}.
  ///@param subId SMS subscription ID of the SIM
  ///@param location the URI of the message to be downloaded.
  /// This value must never be {@code null}.
  ///@param callback result callback. Call with a status code which is one of
  ///        \#DOWNLOAD_STATUS_OK,
  ///        \#DOWNLOAD_STATUS_RETRY_ON_CARRIER_NETWORK, or \#DOWNLOAD_STATUS_ERROR.
  ///
  /// This value must never be {@code null}.
  void onDownloadMms(uri_.Uri contentUri, int subId, uri_.Uri location,
          CarrierMessagingService_ResultCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onDownloadMms, jni.JniType.voidType, [
        contentUri.reference,
        subId,
        location.reference,
        callback.reference
      ]).check();

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param intent This value must never be {@code null}.
  ///@return This value may be {@code null}.
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);
}

/// from: android.service.carrier.CarrierMessagingService$SendSmsResult
///
/// The result of sending an SMS.
class CarrierMessagingService_SendSmsResult extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/service/carrier/CarrierMessagingService\$SendSmsResult");
  CarrierMessagingService_SendSmsResult.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(II)V");

  /// from: public void <init>(int sendStatus, int messageRef)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a SendSmsResult with the send status and message reference for the
  /// just-sent SMS.
  ///@param sendStatus send status, one of \#SEND_STATUS_OK,
  ///        \#SEND_STATUS_RETRY_ON_CARRIER_NETWORK, and \#SEND_STATUS_ERROR.
  ///@param messageRef message reference of the just-sent SMS. This field is applicable only
  ///        if send status is \#SEND_STATUS_OK.
  CarrierMessagingService_SendSmsResult(int sendStatus, int messageRef)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [sendStatus, messageRef]).object);

  static final _id_getMessageRef =
      jniAccessors.getMethodIDOf(_classRef, "getMessageRef", "()I");

  /// from: public int getMessageRef()
  ///
  /// Returns the message reference of the just-sent SMS.
  ///@return the message reference
  int getMessageRef() => jniAccessors.callMethodWithArgs(
      reference, _id_getMessageRef, jni.JniType.intType, []).integer;

  static final _id_getSendStatus =
      jniAccessors.getMethodIDOf(_classRef, "getSendStatus", "()I");

  /// from: public int getSendStatus()
  ///
  /// Returns the send status of the just-sent SMS.
  ///@return the send status
  int getSendStatus() => jniAccessors.callMethodWithArgs(
      reference, _id_getSendStatus, jni.JniType.intType, []).integer;
}

/// from: android.service.carrier.CarrierMessagingService$SendMultipartSmsResult
///
/// The result of sending a multipart SMS.
class CarrierMessagingService_SendMultipartSmsResult extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/service/carrier/CarrierMessagingService\$SendMultipartSmsResult");
  CarrierMessagingService_SendMultipartSmsResult.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I[I)V");

  /// from: public void <init>(int sendStatus, int[] messageRefs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a SendMultipartSmsResult with the send status and message references for the
  /// just-sent multipart SMS.
  ///@param sendStatus send status, one of \#SEND_STATUS_OK,
  ///        \#SEND_STATUS_RETRY_ON_CARRIER_NETWORK, and \#SEND_STATUS_ERROR.
  ///@param messageRefs an array of message references, one for each part of the
  ///        multipart SMS. This field is applicable only if send status is
  ///        \#SEND_STATUS_OK.
  ///
  /// This value may be {@code null}.
  CarrierMessagingService_SendMultipartSmsResult(
      int sendStatus, jni.JniObject messageRefs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [sendStatus, messageRefs.reference]).object);

  static final _id_getMessageRefs =
      jniAccessors.getMethodIDOf(_classRef, "getMessageRefs", "()[I");

  /// from: public int[] getMessageRefs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the message references of the just-sent multipart SMS.
  ///@return the message references, one for each part of the multipart SMS
  ///
  /// This value may be {@code null}.
  jni.JniObject getMessageRefs() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMessageRefs, jni.JniType.objectType, []).object);

  static final _id_getSendStatus =
      jniAccessors.getMethodIDOf(_classRef, "getSendStatus", "()I");

  /// from: public int getSendStatus()
  ///
  /// Returns the send status of the just-sent SMS.
  ///@return the send status
  int getSendStatus() => jniAccessors.callMethodWithArgs(
      reference, _id_getSendStatus, jni.JniType.intType, []).integer;
}

/// from: android.service.carrier.CarrierMessagingService$SendMmsResult
///
/// The result of sending an MMS.
class CarrierMessagingService_SendMmsResult extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/service/carrier/CarrierMessagingService\$SendMmsResult");
  CarrierMessagingService_SendMmsResult.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I[B)V");

  /// from: public void <init>(int sendStatus, byte[] sendConfPdu)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a SendMmsResult with the MMS send result, and the SendConf PDU.
  ///@param sendStatus send status, one of \#SEND_STATUS_OK,
  ///        \#SEND_STATUS_RETRY_ON_CARRIER_NETWORK, and
  ///        \#SEND_STATUS_ERROR
  ///@param sendConfPdu a possibly {code null} SendConf PDU, which confirms that the message
  ///        was sent. sendConfPdu is ignored if the {@code result} is not
  ///        \#SEND_STATUS_OK.
  ///
  /// This value may be {@code null}.
  CarrierMessagingService_SendMmsResult(
      int sendStatus, jni.JniObject sendConfPdu)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [sendStatus, sendConfPdu.reference]).object);

  static final _id_getSendStatus =
      jniAccessors.getMethodIDOf(_classRef, "getSendStatus", "()I");

  /// from: public int getSendStatus()
  ///
  /// Returns the send status of the just-sent MMS.
  ///@return the send status which is one of \#SEND_STATUS_OK,
  ///         \#SEND_STATUS_RETRY_ON_CARRIER_NETWORK, and \#SEND_STATUS_ERROR
  int getSendStatus() => jniAccessors.callMethodWithArgs(
      reference, _id_getSendStatus, jni.JniType.intType, []).integer;

  static final _id_getSendConfPdu =
      jniAccessors.getMethodIDOf(_classRef, "getSendConfPdu", "()[B");

  /// from: public byte[] getSendConfPdu()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the SendConf PDU, which confirms that the message was sent.
  ///@return the SendConf PDU
  ///
  /// This value may be {@code null}.
  jni.JniObject getSendConfPdu() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSendConfPdu, jni.JniType.objectType, []).object);
}

/// from: android.service.carrier.CarrierMessagingService$ResultCallback
///
/// A callback interface used to provide results asynchronously.
class CarrierMessagingService_ResultCallback extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/service/carrier/CarrierMessagingService\$ResultCallback");
  CarrierMessagingService_ResultCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);
}
