// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../app/Service.dart" as service_;

import "../../os/PersistableBundle.dart" as persistablebundle_;

import "CarrierIdentifier.dart" as carrieridentifier_;

import "../../os/IBinder.dart" as ibinder_;

import "../../content/Intent.dart" as intent_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.service.carrier.CarrierService
///
/// A service that exposes carrier-specific functionality to the system.
///
/// To extend this class, you must declare the service in your manifest file to require the
/// android.Manifest.permission\#BIND_CARRIER_SERVICES permission and include an intent
/// filter with the \#CARRIER_SERVICE_INTERFACE. If the service should have a long-lived
/// binding, set <code>android.service.carrier.LONG_LIVED_BINDING</code> to <code>true</code> in the
/// service's metadata. For example:
///
///
///
/// <pre>{@code
/// <service android:name=".MyCarrierService"
///       android:label="@string/service_name"
///       android:permission="android.permission.BIND_CARRIER_SERVICES">
///  <intent-filter>
///      <action android:name="android.service.carrier.CarrierService" />
///  </intent-filter>
///  <meta-data android:name="android.service.carrier.LONG_LIVED_BINDING"
///             android:value="true" />
/// </service>
/// }</pre>
class CarrierService extends service_.Service {
  static final _classRef =
      jniAccessors.getClassOf("android/service/carrier/CarrierService");
  CarrierService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String CARRIER_SERVICE_INTERFACE
  static const CARRIER_SERVICE_INTERFACE =
      "android.service.carrier.CarrierService";

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  CarrierService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_onLoadConfig = jniAccessors.getMethodIDOf(
      _classRef,
      "onLoadConfig",
      "(Landroid/service/carrier/CarrierIdentifier;)Landroid/os/PersistableBundle;");

  /// from: public abstract android.os.PersistableBundle onLoadConfig(android.service.carrier.CarrierIdentifier id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Override this method to set carrier configuration.
  ///
  /// This method will be called by telephony services to get carrier-specific configuration
  /// values. The returned config will be saved by the system until,
  /// <ol>
  /// <li>The carrier app package is updated, or</li>
  /// <li>The carrier app requests a reload with
  /// android.telephony.CarrierConfigManager\#notifyConfigChangedForSubId notifyConfigChangedForSubId.</li>
  /// </ol>
  /// This method can be called after a SIM card loads, which may be before or after boot.
  ///
  ///
  ///
  /// This method should not block for a long time. If expensive operations (e.g. network access)
  /// are required, this method can schedule the work and return null. Then, use
  /// android.telephony.CarrierConfigManager\#notifyConfigChangedForSubId notifyConfigChangedForSubId to trigger a reload when the config is ready.
  ///
  ///
  ///
  /// Implementations should use the keys defined in android.telephony.CarrierConfigManager CarrierConfigManager. Any configuration values not set in the returned PersistableBundle may be overridden by the system's default configuration service.
  ///
  ///
  ///@param id contains details about the current carrier that can be used do decide what
  ///            configuration values to return.
  ///@return a PersistableBundle object containing the configuration or null if default
  ///         values should be used.
  persistablebundle_.PersistableBundle onLoadConfig(
          carrieridentifier_.CarrierIdentifier id) =>
      persistablebundle_.PersistableBundle.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_onLoadConfig,
              jni.JniType.objectType, [id.reference]).object);

  static final _id_notifyCarrierNetworkChange = jniAccessors.getMethodIDOf(
      _classRef, "notifyCarrierNetworkChange", "(Z)V");

  /// from: public final void notifyCarrierNetworkChange(boolean active)
  ///
  /// Informs the system of an intentional upcoming carrier network change by
  /// a carrier app. This call is optional and is only used to allow the
  /// system to provide alternative UI while telephony is performing an action
  /// that may result in intentional, temporary network lack of connectivity.
  ///
  /// Based on the active parameter passed in, this method will either show or
  /// hide the alternative UI. There is no timeout associated with showing
  /// this UX, so a carrier app must be sure to call with active set to false
  /// sometime after calling with it set to true.
  ///
  /// Requires Permission:
  ///   android.Manifest.permission\#MODIFY_PHONE_STATE MODIFY_PHONE_STATE
  /// or the calling app has carrier privileges.
  ///@param active Whether the carrier network change is or shortly will be
  ///               active. Set this value to true to begin showing
  ///               alternative UI and false to stop.
  ///@see android.telephony.TelephonyManager\#hasCarrierPrivileges
  void notifyCarrierNetworkChange(bool active) =>
      jniAccessors.callMethodWithArgs(reference, _id_notifyCarrierNetworkChange,
          jni.JniType.voidType, [active]).check();

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If overriding this method, call through to the super method for any unknown actions.
  /// {@inheritDoc}
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);
}
