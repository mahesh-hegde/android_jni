// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../app/Service.dart" as service_;

import "../../content/ComponentName.dart" as componentname_;

import "../../content/IntentFilter.dart" as intentfilter_;

import "../../os/IBinder.dart" as ibinder_;

import "../../content/Intent.dart" as intent_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.service.chooser.ChooserTargetService
///
/// A service that receives calls from the system when the user is asked to choose
/// a target for an intent explicitly by another app. The calling app must have invoked
/// android.content.Intent\#ACTION_CHOOSER ACTION_CHOOSER as handled by the system;
/// applications do not have the ability to query a ChooserTargetService directly.
///
/// Which ChooserTargetServices are queried depends on a system-level policy decision
/// made at the moment the chooser is invoked, including but not limited to user time
/// spent with the app package or associated components in the foreground, recency of usage
/// or frequency of usage. These will generally correlate with the order that app targets
/// are shown in the list of intent handlers shown in the system chooser or resolver.
///
///
/// To extend this class, you must declare the service in your manifest file with
/// the android.Manifest.permission\#BIND_CHOOSER_TARGET_SERVICE permission
/// and include an intent filter with the \#SERVICE_INTERFACE action. For example:
///
/// <pre>
///     &lt;service android:name=".MyChooserTargetService"
///             android:label="&\#64;string/service_name"
///             android:permission="android.permission.BIND_CHOOSER_TARGET_SERVICE">
///         &lt;intent-filter>
///             &lt;action android:name="android.service.chooser.ChooserTargetService" />
///         &lt;/intent-filter>
///     &lt;/service>
/// </pre>
///
/// For the system to query your service, you must add a &lt;meta-data> element to the
/// Activity in your manifest that can handle Intents that you would also like to provide
/// optional deep links for. For example, a chat app might offer deep links to recent active
/// conversations instead of invoking a generic picker after the app itself is chosen as a target.
///
///
///
/// The meta-data element should have the name
/// <code>android.service.chooser.chooser_target_service</code> and a value corresponding to
/// the component name of your service. Example:
///
/// <pre>
///     &lt;activity android:name=".MyShareActivity"
///             android:label="&\#64;string/share_activity_label">
///         &lt;intent-filter>
///             &lt;action android:name="android.intent.action.SEND" />
///         &lt;/intent-filter>
///         &lt;meta-data android:name="android.service.chooser.chooser_target_service"
///                 android:value=".MyChooserTargetService" />
///     &lt;/activity>
/// </pre>
class ChooserTargetService extends service_.Service {
  static final _classRef =
      jniAccessors.getClassOf("android/service/chooser/ChooserTargetService");
  ChooserTargetService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String BIND_PERMISSION
  ///
  /// The permission that a ChooserTargetService must require in order to bind to it.
  /// If this permission is not enforced the system will skip that ChooserTargetService.
  static const BIND_PERMISSION =
      "android.permission.BIND_CHOOSER_TARGET_SERVICE";

  /// from: static public final java.lang.String META_DATA_NAME
  ///
  /// The name of the <code>meta-data</code> element that must be present on an
  /// <code>activity</code> element in a manifest to link it to a ChooserTargetService
  static const META_DATA_NAME =
      "android.service.chooser.chooser_target_service";

  /// from: static public final java.lang.String SERVICE_INTERFACE
  ///
  /// The Intent action that a ChooserTargetService must respond to
  static const SERVICE_INTERFACE =
      "android.service.chooser.ChooserTargetService";

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ChooserTargetService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_onGetChooserTargets = jniAccessors.getMethodIDOf(
      _classRef,
      "onGetChooserTargets",
      "(Landroid/content/ComponentName;Landroid/content/IntentFilter;)Ljava/util/List;");

  /// from: public abstract java.util.List<android.service.chooser.ChooserTarget> onGetChooserTargets(android.content.ComponentName targetActivityName, android.content.IntentFilter matchedFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by the system to retrieve a set of deep-link ChooserTarget targets that
  /// can handle an intent.
  ///
  /// The returned list should be sorted such that the most relevant targets appear first.
  /// The score for each ChooserTarget will be combined with the system's score for the original
  /// target Activity to sort and filter targets presented to the user.
  ///
  ///
  /// _Important:_ Calls to this method from other applications will occur on
  /// a binder thread, not on your app's main thread. Make sure that access to relevant data
  /// within your app is thread-safe.
  ///
  ///@param targetActivityName the ComponentName of the matched activity that referred the system
  ///                           to this ChooserTargetService
  ///@param matchedFilter the specific IntentFilter on the component that was matched
  ///@return a list of deep-link targets to fulfill the intent match, sorted by relevance
  jni.JniObject onGetChooserTargets(
          componentname_.ComponentName targetActivityName,
          intentfilter_.IntentFilter matchedFilter) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onGetChooserTargets,
          jni.JniType.objectType,
          [targetActivityName.reference, matchedFilter.reference]).object);

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);
}
