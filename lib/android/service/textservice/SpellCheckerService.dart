// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../app/Service.dart" as service_;

import "../../os/IBinder.dart" as ibinder_;

import "../../content/Intent.dart" as intent_;

import "../../view/textservice/SuggestionsInfo.dart" as suggestionsinfo_;

import "../../view/textservice/TextInfo.dart" as textinfo_;

import "../../os/Bundle.dart" as bundle_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.service.textservice.SpellCheckerService
///
/// SpellCheckerService provides an abstract base class for a spell checker.
/// This class combines a service to the system with the spell checker service interface that
/// spell checker must implement.
///
/// In addition to the normal Service lifecycle methods, this class
/// introduces a new specific callback that subclasses should override
/// \#createSession() to provide a spell checker session that is corresponding
/// to requested language and so on. The spell checker session returned by this method
/// should extend SpellCheckerService.Session.
///
///
///
/// <h3>Returning spell check results</h3>
///
/// SpellCheckerService.Session\#onGetSuggestions(TextInfo, int)
/// should return spell check results.
/// It receives android.view.textservice.TextInfo and returns
/// android.view.textservice.SuggestionsInfo for the input.
/// You may want to override
/// SpellCheckerService.Session\#onGetSuggestionsMultiple(TextInfo[], int, boolean) for
/// better performance and quality.
///
///
///
/// Please note that SpellCheckerService.Session\#getLocale() does not return a valid
/// locale before SpellCheckerService.Session\#onCreate()
///
class SpellCheckerService extends service_.Service {
  static final _classRef = jniAccessors
      .getClassOf("android/service/textservice/SpellCheckerService");
  SpellCheckerService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String SERVICE_INTERFACE
  static const SERVICE_INTERFACE =
      "android.service.textservice.SpellCheckerService";

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  SpellCheckerService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public final android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement to return the implementation of the internal spell checker
  /// service interface. Subclasses should not override.
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);

  static final _id_createSession = jniAccessors.getMethodIDOf(
      _classRef,
      "createSession",
      "()Landroid/service/textservice/SpellCheckerService\$Session;");

  /// from: public abstract android.service.textservice.SpellCheckerService.Session createSession()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Factory method to create a spell checker session impl
  ///@return SpellCheckerSessionImpl which should be overridden by a concrete implementation.
  SpellCheckerService_Session createSession() =>
      SpellCheckerService_Session.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createSession, jni.JniType.objectType, []).object);
}

/// from: android.service.textservice.SpellCheckerService$Session
///
/// This abstract class should be overridden by a concrete implementation of a spell checker.
class SpellCheckerService_Session extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/service/textservice/SpellCheckerService\$Session");
  SpellCheckerService_Session.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  SpellCheckerService_Session()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onCreate =
      jniAccessors.getMethodIDOf(_classRef, "onCreate", "()V");

  /// from: public abstract void onCreate()
  ///
  /// This is called after the class is initialized, at which point it knows it can call
  /// getLocale() etc...
  void onCreate() => jniAccessors.callMethodWithArgs(
      reference, _id_onCreate, jni.JniType.voidType, []).check();

  static final _id_onGetSuggestions = jniAccessors.getMethodIDOf(
      _classRef,
      "onGetSuggestions",
      "(Landroid/view/textservice/TextInfo;I)Landroid/view/textservice/SuggestionsInfo;");

  /// from: public abstract android.view.textservice.SuggestionsInfo onGetSuggestions(android.view.textservice.TextInfo textInfo, int suggestionsLimit)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get suggestions for specified text in TextInfo.
  /// This function will run on the incoming IPC thread.
  /// So, this is not called on the main thread,
  /// but will be called in series on another thread.
  ///@param textInfo the text metadata
  ///@param suggestionsLimit the maximum number of suggestions to be returned
  ///@return SuggestionsInfo which contains suggestions for textInfo
  suggestionsinfo_.SuggestionsInfo onGetSuggestions(
          textinfo_.TextInfo textInfo, int suggestionsLimit) =>
      suggestionsinfo_.SuggestionsInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onGetSuggestions,
          jni.JniType.objectType,
          [textInfo.reference, suggestionsLimit]).object);

  static final _id_onGetSuggestionsMultiple = jniAccessors.getMethodIDOf(
      _classRef,
      "onGetSuggestionsMultiple",
      "([Landroid/view/textservice/TextInfo;IZ)[Landroid/view/textservice/SuggestionsInfo;");

  /// from: public android.view.textservice.SuggestionsInfo[] onGetSuggestionsMultiple(android.view.textservice.TextInfo[] textInfos, int suggestionsLimit, boolean sequentialWords)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A batch process of onGetSuggestions.
  /// This function will run on the incoming IPC thread.
  /// So, this is not called on the main thread,
  /// but will be called in series on another thread.
  ///@param textInfos an array of the text metadata
  ///@param suggestionsLimit the maximum number of suggestions to be returned
  ///@param sequentialWords true if textInfos can be treated as sequential words.
  ///@return an array of SentenceSuggestionsInfo returned by
  /// SpellCheckerService.Session\#onGetSuggestions(TextInfo, int)
  jni.JniObject onGetSuggestionsMultiple(jni.JniObject textInfos,
          int suggestionsLimit, bool sequentialWords) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onGetSuggestionsMultiple,
          jni.JniType.objectType,
          [textInfos.reference, suggestionsLimit, sequentialWords]).object);

  static final _id_onGetSentenceSuggestionsMultiple = jniAccessors.getMethodIDOf(
      _classRef,
      "onGetSentenceSuggestionsMultiple",
      "([Landroid/view/textservice/TextInfo;I)[Landroid/view/textservice/SentenceSuggestionsInfo;");

  /// from: public android.view.textservice.SentenceSuggestionsInfo[] onGetSentenceSuggestionsMultiple(android.view.textservice.TextInfo[] textInfos, int suggestionsLimit)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get sentence suggestions for specified texts in an array of TextInfo.
  /// The default implementation splits the input text to words and returns
  /// SentenceSuggestionsInfo which contains suggestions for each word.
  /// This function will run on the incoming IPC thread.
  /// So, this is not called on the main thread,
  /// but will be called in series on another thread.
  /// When you override this method, make sure that suggestionsLimit is applied to suggestions
  /// that share the same start position and length.
  ///@param textInfos an array of the text metadata
  ///@param suggestionsLimit the maximum number of suggestions to be returned
  ///@return an array of SentenceSuggestionsInfo returned by
  /// SpellCheckerService.Session\#onGetSuggestions(TextInfo, int)
  jni.JniObject onGetSentenceSuggestionsMultiple(
          jni.JniObject textInfos, int suggestionsLimit) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onGetSentenceSuggestionsMultiple,
          jni.JniType.objectType,
          [textInfos.reference, suggestionsLimit]).object);

  static final _id_onCancel =
      jniAccessors.getMethodIDOf(_classRef, "onCancel", "()V");

  /// from: public void onCancel()
  ///
  /// Request to abort all tasks executed in SpellChecker.
  /// This function will run on the incoming IPC thread.
  /// So, this is not called on the main thread,
  /// but will be called in series on another thread.
  void onCancel() => jniAccessors.callMethodWithArgs(
      reference, _id_onCancel, jni.JniType.voidType, []).check();

  static final _id_onClose =
      jniAccessors.getMethodIDOf(_classRef, "onClose", "()V");

  /// from: public void onClose()
  ///
  /// Request to close this session.
  /// This function will run on the incoming IPC thread.
  /// So, this is not called on the main thread,
  /// but will be called in series on another thread.
  void onClose() => jniAccessors.callMethodWithArgs(
      reference, _id_onClose, jni.JniType.voidType, []).check();

  static final _id_getLocale = jniAccessors.getMethodIDOf(
      _classRef, "getLocale", "()Ljava/lang/String;");

  /// from: public java.lang.String getLocale()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return Locale for this session
  jni.JniString getLocale() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLocale, jni.JniType.objectType, []).object);

  static final _id_getBundle = jniAccessors.getMethodIDOf(
      _classRef, "getBundle", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getBundle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return Bundle for this session
  bundle_.Bundle getBundle() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getBundle, jni.JniType.objectType, []).object);
}
