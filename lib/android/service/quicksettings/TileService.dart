// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../app/Service.dart" as service_;

import "../../app/Dialog.dart" as dialog_;

import "../../content/Intent.dart" as intent_;

import "Tile.dart" as tile_;

import "../../os/IBinder.dart" as ibinder_;

import "../../content/Context.dart" as context_;

import "../../content/ComponentName.dart" as componentname_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.service.quicksettings.TileService
///
/// A TileService provides the user a tile that can be added to Quick Settings.
/// Quick Settings is a space provided that allows the user to change settings and
/// take quick actions without leaving the context of their current app.
///
/// The lifecycle of a TileService is different from some other services in
/// that it may be unbound during parts of its lifecycle.  Any of the following
/// lifecycle events can happen indepently in a separate binding/creation of the
/// service.
///
///
/// <ul>
/// <li>When a tile is added by the user its TileService will be bound to and
/// \#onTileAdded() will be called.</li>
///
/// <li>When a tile should be up to date and listing will be indicated by
/// \#onStartListening() and \#onStopListening().</li>
///
/// <li>When the user removes a tile from Quick Settings \#onTileRemoved()
/// will be called.</li>
/// </ul>
/// TileService will be detected by tiles that match the {@value \#ACTION_QS_TILE}
/// and require the permission "android.permission.BIND_QUICK_SETTINGS_TILE".
/// The label and icon for the service will be used as the default label and
/// icon for the tile. Here is an example TileService declaration.
///
/// <pre class="prettyprint">
/// {@literal
/// <service
///     android:name=".MyQSTileService"
///     android:label="@string/my_default_tile_label"
///     android:icon="@drawable/my_default_icon_label"
///     android:permission="android.permission.BIND_QUICK_SETTINGS_TILE">
///     <intent-filter>
///         <action android:name="android.service.quicksettings.action.QS_TILE" />
///     </intent-filter>
/// </service>}
/// </pre>
///@see Tile Tile for details about the UI of a Quick Settings Tile.
class TileService extends service_.Service {
  static final _classRef =
      jniAccessors.getClassOf("android/service/quicksettings/TileService");
  TileService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_QS_TILE
  ///
  /// Action that identifies a Service as being a TileService.
  static const ACTION_QS_TILE = "android.service.quicksettings.action.QS_TILE";

  /// from: static public final java.lang.String ACTION_QS_TILE_PREFERENCES
  ///
  /// An activity that provides a user interface for adjusting TileService
  /// preferences. Optional but recommended for apps that implement a
  /// TileService.
  ///
  /// This intent may also define a Intent\#EXTRA_COMPONENT_NAME value
  /// to indicate the ComponentName that caused the preferences to be
  /// opened.
  static const ACTION_QS_TILE_PREFERENCES =
      "android.service.quicksettings.action.QS_TILE_PREFERENCES";

  /// from: static public final java.lang.String META_DATA_ACTIVE_TILE
  ///
  /// Meta-data for tile definition to set a tile into active mode.
  ///
  /// Active mode is for tiles which already listen and keep track of their state in their
  /// own process.  These tiles may request to send an update to the System while their process
  /// is alive using \#requestListeningState.  The System will only bind these tiles
  /// on its own when a click needs to occur.
  ///
  /// To make a TileService an active tile, set this meta-data to true on the TileService's
  /// manifest declaration.
  /// <pre class="prettyprint">
  /// {@literal
  /// <meta-data android:name="android.service.quicksettings.ACTIVE_TILE"
  ///      android:value="true" />
  /// }
  /// </pre>
  static const META_DATA_ACTIVE_TILE =
      "android.service.quicksettings.ACTIVE_TILE";

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  TileService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_onDestroy =
      jniAccessors.getMethodIDOf(_classRef, "onDestroy", "()V");

  /// from: public void onDestroy()
  void onDestroy() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroy, jni.JniType.voidType, []).check();

  static final _id_onTileAdded =
      jniAccessors.getMethodIDOf(_classRef, "onTileAdded", "()V");

  /// from: public void onTileAdded()
  ///
  /// Called when the user adds this tile to Quick Settings.
  /// <p/>
  /// Note that this is not guaranteed to be called between \#onCreate()
  /// and \#onStartListening(), it will only be called when the tile is added
  /// and not on subsequent binds.
  void onTileAdded() => jniAccessors.callMethodWithArgs(
      reference, _id_onTileAdded, jni.JniType.voidType, []).check();

  static final _id_onTileRemoved =
      jniAccessors.getMethodIDOf(_classRef, "onTileRemoved", "()V");

  /// from: public void onTileRemoved()
  ///
  /// Called when the user removes this tile from Quick Settings.
  void onTileRemoved() => jniAccessors.callMethodWithArgs(
      reference, _id_onTileRemoved, jni.JniType.voidType, []).check();

  static final _id_onStartListening =
      jniAccessors.getMethodIDOf(_classRef, "onStartListening", "()V");

  /// from: public void onStartListening()
  ///
  /// Called when this tile moves into a listening state.
  /// <p/>
  /// When this tile is in a listening state it is expected to keep the
  /// UI up to date.  Any listeners or callbacks needed to keep this tile
  /// up to date should be registered here and unregistered in \#onStopListening().
  ///@see \#getQsTile()
  ///@see Tile\#updateTile()
  void onStartListening() => jniAccessors.callMethodWithArgs(
      reference, _id_onStartListening, jni.JniType.voidType, []).check();

  static final _id_onStopListening =
      jniAccessors.getMethodIDOf(_classRef, "onStopListening", "()V");

  /// from: public void onStopListening()
  ///
  /// Called when this tile moves out of the listening state.
  void onStopListening() => jniAccessors.callMethodWithArgs(
      reference, _id_onStopListening, jni.JniType.voidType, []).check();

  static final _id_onClick =
      jniAccessors.getMethodIDOf(_classRef, "onClick", "()V");

  /// from: public void onClick()
  ///
  /// Called when the user clicks on this tile.
  void onClick() => jniAccessors.callMethodWithArgs(
      reference, _id_onClick, jni.JniType.voidType, []).check();

  static final _id_showDialog = jniAccessors.getMethodIDOf(
      _classRef, "showDialog", "(Landroid/app/Dialog;)V");

  /// from: public final void showDialog(android.app.Dialog dialog)
  ///
  /// Used to show a dialog.
  ///
  /// This will collapse the Quick Settings panel and show the dialog.
  ///@param dialog Dialog to show.
  ///@see \#isLocked()
  void showDialog(dialog_.Dialog dialog) => jniAccessors.callMethodWithArgs(
      reference,
      _id_showDialog,
      jni.JniType.voidType,
      [dialog.reference]).check();

  static final _id_unlockAndRun = jniAccessors.getMethodIDOf(
      _classRef, "unlockAndRun", "(Ljava/lang/Runnable;)V");

  /// from: public final void unlockAndRun(java.lang.Runnable runnable)
  ///
  /// Prompts the user to unlock the device before executing the Runnable.
  ///
  /// The user will be prompted for their current security method if applicable
  /// and if successful, runnable will be executed.  The Runnable will not be
  /// executed if the user fails to unlock the device or cancels the operation.
  void unlockAndRun(jni.JniObject runnable) => jniAccessors.callMethodWithArgs(
      reference,
      _id_unlockAndRun,
      jni.JniType.voidType,
      [runnable.reference]).check();

  static final _id_isSecure =
      jniAccessors.getMethodIDOf(_classRef, "isSecure", "()Z");

  /// from: public final boolean isSecure()
  ///
  /// Checks if the device is in a secure state.
  ///
  /// TileServices should detect when the device is secure and change their behavior
  /// accordingly.
  ///@return true if the device is secure.
  bool isSecure() => jniAccessors.callMethodWithArgs(
      reference, _id_isSecure, jni.JniType.booleanType, []).boolean;

  static final _id_isLocked =
      jniAccessors.getMethodIDOf(_classRef, "isLocked", "()Z");

  /// from: public final boolean isLocked()
  ///
  /// Checks if the lock screen is showing.
  ///
  /// When a device is locked, then \#showDialog will not present a dialog, as it will
  /// be under the lock screen. If the behavior of the Tile is safe to do while locked,
  /// then the user should use \#startActivity to launch an activity on top of the lock
  /// screen, otherwise the tile should use \#unlockAndRun(Runnable) to give the
  /// user their security challenge.
  ///@return true if the device is locked.
  bool isLocked() => jniAccessors.callMethodWithArgs(
      reference, _id_isLocked, jni.JniType.booleanType, []).boolean;

  static final _id_startActivityAndCollapse = jniAccessors.getMethodIDOf(
      _classRef, "startActivityAndCollapse", "(Landroid/content/Intent;)V");

  /// from: public final void startActivityAndCollapse(android.content.Intent intent)
  ///
  /// Start an activity while collapsing the panel.
  void startActivityAndCollapse(intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_startActivityAndCollapse,
          jni.JniType.voidType, [intent.reference]).check();

  static final _id_getQsTile = jniAccessors.getMethodIDOf(
      _classRef, "getQsTile", "()Landroid/service/quicksettings/Tile;");

  /// from: public final android.service.quicksettings.Tile getQsTile()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the Tile for this service.
  /// <p/>
  /// This tile may be used to get or set the current state for this
  /// tile. This tile is only valid for updates between \#onStartListening()
  /// and \#onStopListening().
  tile_.Tile getQsTile() => tile_.Tile.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getQsTile, jni.JniType.objectType, []).object);

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);

  static final _id_requestListeningState = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "requestListeningState",
      "(Landroid/content/Context;Landroid/content/ComponentName;)V");

  /// from: static public final void requestListeningState(android.content.Context context, android.content.ComponentName component)
  ///
  /// Requests that a tile be put in the listening state so it can send an update.
  ///
  /// This method is only applicable to tiles that have \#META_DATA_ACTIVE_TILE defined
  /// as true on their TileService Manifest declaration, and will do nothing otherwise.
  static void requestListeningState(
          context_.Context context, componentname_.ComponentName component) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_requestListeningState,
          jni.JniType.voidType,
          [context.reference, component.reference]).check();
}
