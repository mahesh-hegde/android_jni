// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../app/Service.dart" as service_;

import "../../view/KeyEvent.dart" as keyevent_;

import "../../view/MotionEvent.dart" as motionevent_;

import "../../view/accessibility/AccessibilityEvent.dart"
    as accessibilityevent_;

import "../../view/View.dart" as view_;

import "../../view/Menu.dart" as menu_;

import "../../view/MenuItem.dart" as menuitem_;

import "../../view/WindowManager.dart" as windowmanager_;

import "../../view/SearchEvent.dart" as searchevent_;

import "../../view/ActionMode.dart" as actionmode_;

import "../../view/Window.dart" as window_;

import "../../view/ViewGroup.dart" as viewgroup_;

import "../../os/IBinder.dart" as ibinder_;

import "../../content/Intent.dart" as intent_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.service.dreams.DreamService
///
/// Extend this class to implement a custom dream (available to the user as a "Daydream").
///
/// Dreams are interactive screensavers launched when a charging device is idle, or docked in a
/// desk dock. Dreams provide another modality for apps to express themselves, tailored for
/// an exhibition/lean-back experience.
///
///
/// The {@code DreamService} lifecycle is as follows:
///
/// <ol>
///   <li>\#onAttachedToWindow
///     Use this for initial setup, such as calling \#setContentView setContentView().</li>
///   <li>\#onDreamingStarted
///     Your dream has started, so you should begin animations or other behaviors here.</li>
///   <li>\#onDreamingStopped
///     Use this to stop the things you started in \#onDreamingStarted.</li>
///   <li>\#onDetachedFromWindow
///     Use this to dismantle resources (for example, detach from handlers
///        and listeners).</li>
/// </ol>
///
/// In addition, onCreate and onDestroy (from the Service interface) will also be called, but
/// initialization and teardown should be done by overriding the hooks above.
///
///
/// To be available to the system, your {@code DreamService} should be declared in the
/// manifest as follows:
///
/// <pre>
/// &lt;service
///     android:name=".MyDream"
///     android:exported="true"
///     android:icon="@drawable/my_icon"
///     android:label="@string/my_dream_label" >
///
///     &lt;intent-filter>
///         &lt;action android:name="android.service.dreams.DreamService" />
///         &lt;category android:name="android.intent.category.DEFAULT" />
///     &lt;/intent-filter>
///
///     &lt;!-- Point to additional information for this dream (optional) -->
///     &lt;meta-data
///         android:name="android.service.dream"
///         android:resource="@xml/my_dream" />
/// &lt;/service>
/// </pre>
///
/// If specified with the {@code <meta-data>} element,
/// additional information for the dream is defined using the
/// android.R.styleable\#Dream &lt;dream&gt; element in a separate XML file.
/// Currently, the only addtional
/// information you can provide is for a settings activity that allows the user to configure
/// the dream behavior. For example:
///
/// <p class="code-caption">res/xml/my_dream.xml
///
/// <pre>
/// &lt;dream xmlns:android="http://schemas.android.com/apk/res/android"
///     android:settingsActivity="com.example.app/.MyDreamSettingsActivity" />
/// </pre>
/// This makes a Settings button available alongside your dream's listing in the
/// system settings, which when pressed opens the specified activity.
///
///
///
/// To specify your dream layout, call \#setContentView, typically during the
/// \#onAttachedToWindow callback. For example:
///
/// <pre>
/// public class MyDream extends DreamService {
///
///     &\#64;Override
///     public void onAttachedToWindow() {
///         super.onAttachedToWindow();
///
///         // Exit dream upon user touch
///         setInteractive(false);
///         // Hide system UI
///         setFullscreen(true);
///         // Set the dream layout
///         setContentView(R.layout.dream);
///     }
/// }
/// </pre>
///
/// When targeting api level 21 and above, you must declare the service in your manifest file
/// with the android.Manifest.permission\#BIND_DREAM_SERVICE permission. For example:
///
/// <pre>
/// &lt;service
///     android:name=".MyDream"
///     android:exported="true"
///     android:icon="@drawable/my_icon"
///     android:label="@string/my_dream_label"
///     android:permission="android.permission.BIND_DREAM_SERVICE">
///   &lt;intent-filter>
///     &lt;action android:name=\u201dandroid.service.dreams.DreamService\u201d />
///     &lt;category android:name=\u201dandroid.intent.category.DEFAULT\u201d />
///   &lt;/intent-filter>
/// &lt;/service>
/// </pre>
class DreamService extends service_.Service {
  static final _classRef =
      jniAccessors.getClassOf("android/service/dreams/DreamService");
  DreamService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String DREAM_META_DATA
  ///
  /// Name under which a Dream publishes information about itself.
  /// This meta-data must reference an XML resource containing
  /// a <code>&lt;android.R.styleable\#Dream dream&gt;</code>
  /// tag.
  static const DREAM_META_DATA = "android.service.dream";

  /// from: static public final java.lang.String SERVICE_INTERFACE
  ///
  /// The Intent that must be declared as handled by the service.
  static const SERVICE_INTERFACE = "android.service.dreams.DreamService";

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  DreamService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_dispatchKeyEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchKeyEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyEvent(android.view.KeyEvent event)
  ///
  /// {@inheritDoc}
  bool dispatchKeyEvent(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchKeyEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchKeyShortcutEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchKeyShortcutEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyShortcutEvent(android.view.KeyEvent event)
  ///
  /// {@inheritDoc}
  bool dispatchKeyShortcutEvent(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchKeyShortcutEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchTouchEvent(android.view.MotionEvent event)
  ///
  /// {@inheritDoc}
  bool dispatchTouchEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchTouchEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchTrackballEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchTrackballEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchTrackballEvent(android.view.MotionEvent event)
  ///
  /// {@inheritDoc}
  bool dispatchTrackballEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchTrackballEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchGenericMotionEvent = jniAccessors.getMethodIDOf(
      _classRef, "dispatchGenericMotionEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean dispatchGenericMotionEvent(android.view.MotionEvent event)
  ///
  /// {@inheritDoc}
  bool dispatchGenericMotionEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchGenericMotionEvent,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_dispatchPopulateAccessibilityEvent =
      jniAccessors.getMethodIDOf(
          _classRef,
          "dispatchPopulateAccessibilityEvent",
          "(Landroid/view/accessibility/AccessibilityEvent;)Z");

  /// from: public boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)
  ///
  /// {@inheritDoc}
  bool dispatchPopulateAccessibilityEvent(
          accessibilityevent_.AccessibilityEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_dispatchPopulateAccessibilityEvent,
          jni.JniType.booleanType,
          [event.reference]).boolean;

  static final _id_onCreatePanelView = jniAccessors.getMethodIDOf(
      _classRef, "onCreatePanelView", "(I)Landroid/view/View;");

  /// from: public android.view.View onCreatePanelView(int featureId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  view_.View onCreatePanelView(int featureId) =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onCreatePanelView, jni.JniType.objectType, [featureId]).object);

  static final _id_onCreatePanelMenu = jniAccessors.getMethodIDOf(
      _classRef, "onCreatePanelMenu", "(ILandroid/view/Menu;)Z");

  /// from: public boolean onCreatePanelMenu(int featureId, android.view.Menu menu)
  ///
  /// {@inheritDoc}
  bool onCreatePanelMenu(int featureId, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCreatePanelMenu,
          jni.JniType.booleanType, [featureId, menu.reference]).boolean;

  static final _id_onPreparePanel = jniAccessors.getMethodIDOf(_classRef,
      "onPreparePanel", "(ILandroid/view/View;Landroid/view/Menu;)Z");

  /// from: public boolean onPreparePanel(int featureId, android.view.View view, android.view.Menu menu)
  ///
  /// {@inheritDoc}
  bool onPreparePanel(int featureId, view_.View view, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPreparePanel,
          jni.JniType.booleanType,
          [featureId, view.reference, menu.reference]).boolean;

  static final _id_onMenuOpened = jniAccessors.getMethodIDOf(
      _classRef, "onMenuOpened", "(ILandroid/view/Menu;)Z");

  /// from: public boolean onMenuOpened(int featureId, android.view.Menu menu)
  ///
  /// {@inheritDoc}
  bool onMenuOpened(int featureId, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMenuOpened,
          jni.JniType.booleanType, [featureId, menu.reference]).boolean;

  static final _id_onMenuItemSelected = jniAccessors.getMethodIDOf(
      _classRef, "onMenuItemSelected", "(ILandroid/view/MenuItem;)Z");

  /// from: public boolean onMenuItemSelected(int featureId, android.view.MenuItem item)
  ///
  /// {@inheritDoc}
  bool onMenuItemSelected(int featureId, menuitem_.MenuItem item) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMenuItemSelected,
          jni.JniType.booleanType, [featureId, item.reference]).boolean;

  static final _id_onWindowAttributesChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onWindowAttributesChanged",
      "(Landroid/view/WindowManager\$LayoutParams;)V");

  /// from: public void onWindowAttributesChanged(android.view.WindowManager.LayoutParams attrs)
  ///
  /// {@inheritDoc}
  void onWindowAttributesChanged(
          windowmanager_.WindowManager_LayoutParams attrs) =>
      jniAccessors.callMethodWithArgs(reference, _id_onWindowAttributesChanged,
          jni.JniType.voidType, [attrs.reference]).check();

  static final _id_onContentChanged =
      jniAccessors.getMethodIDOf(_classRef, "onContentChanged", "()V");

  /// from: public void onContentChanged()
  ///
  /// {@inheritDoc}
  void onContentChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_onContentChanged, jni.JniType.voidType, []).check();

  static final _id_onWindowFocusChanged =
      jniAccessors.getMethodIDOf(_classRef, "onWindowFocusChanged", "(Z)V");

  /// from: public void onWindowFocusChanged(boolean hasFocus)
  ///
  /// {@inheritDoc}
  void onWindowFocusChanged(bool hasFocus) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onWindowFocusChanged,
      jni.JniType.voidType,
      [hasFocus]).check();

  static final _id_onAttachedToWindow =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: public void onAttachedToWindow()
  ///
  /// {@inheritDoc}
  void onAttachedToWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow, jni.JniType.voidType, []).check();

  static final _id_onDetachedFromWindow =
      jniAccessors.getMethodIDOf(_classRef, "onDetachedFromWindow", "()V");

  /// from: public void onDetachedFromWindow()
  ///
  /// {@inheritDoc}
  void onDetachedFromWindow() => jniAccessors.callMethodWithArgs(
      reference, _id_onDetachedFromWindow, jni.JniType.voidType, []).check();

  static final _id_onPanelClosed = jniAccessors.getMethodIDOf(
      _classRef, "onPanelClosed", "(ILandroid/view/Menu;)V");

  /// from: public void onPanelClosed(int featureId, android.view.Menu menu)
  ///
  /// {@inheritDoc}
  void onPanelClosed(int featureId, menu_.Menu menu) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPanelClosed,
          jni.JniType.voidType, [featureId, menu.reference]).check();

  static final _id_onSearchRequested = jniAccessors.getMethodIDOf(
      _classRef, "onSearchRequested", "(Landroid/view/SearchEvent;)Z");

  /// from: public boolean onSearchRequested(android.view.SearchEvent event)
  ///
  /// {@inheritDoc}
  bool onSearchRequested(searchevent_.SearchEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSearchRequested,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onSearchRequested1 =
      jniAccessors.getMethodIDOf(_classRef, "onSearchRequested", "()Z");

  /// from: public boolean onSearchRequested()
  ///
  /// {@inheritDoc}
  bool onSearchRequested1() => jniAccessors.callMethodWithArgs(
      reference, _id_onSearchRequested1, jni.JniType.booleanType, []).boolean;

  static final _id_onWindowStartingActionMode = jniAccessors.getMethodIDOf(
      _classRef,
      "onWindowStartingActionMode",
      "(Landroid/view/ActionMode\$Callback;)Landroid/view/ActionMode;");

  /// from: public android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  actionmode_.ActionMode onWindowStartingActionMode(
          actionmode_.ActionMode_Callback callback) =>
      actionmode_.ActionMode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onWindowStartingActionMode,
          jni.JniType.objectType,
          [callback.reference]).object);

  static final _id_onWindowStartingActionMode1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onWindowStartingActionMode",
      "(Landroid/view/ActionMode\$Callback;I)Landroid/view/ActionMode;");

  /// from: public android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback, int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  actionmode_.ActionMode onWindowStartingActionMode1(
          actionmode_.ActionMode_Callback callback, int type) =>
      actionmode_.ActionMode.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onWindowStartingActionMode1,
          jni.JniType.objectType,
          [callback.reference, type]).object);

  static final _id_onActionModeStarted = jniAccessors.getMethodIDOf(
      _classRef, "onActionModeStarted", "(Landroid/view/ActionMode;)V");

  /// from: public void onActionModeStarted(android.view.ActionMode mode)
  ///
  /// {@inheritDoc}
  void onActionModeStarted(actionmode_.ActionMode mode) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActionModeStarted,
          jni.JniType.voidType, [mode.reference]).check();

  static final _id_onActionModeFinished = jniAccessors.getMethodIDOf(
      _classRef, "onActionModeFinished", "(Landroid/view/ActionMode;)V");

  /// from: public void onActionModeFinished(android.view.ActionMode mode)
  ///
  /// {@inheritDoc}
  void onActionModeFinished(actionmode_.ActionMode mode) =>
      jniAccessors.callMethodWithArgs(reference, _id_onActionModeFinished,
          jni.JniType.voidType, [mode.reference]).check();

  static final _id_getWindowManager = jniAccessors.getMethodIDOf(
      _classRef, "getWindowManager", "()Landroid/view/WindowManager;");

  /// from: public android.view.WindowManager getWindowManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the current android.view.WindowManager for the dream.
  /// Behaves similarly to android.app.Activity\#getWindowManager().
  ///@return The current window manager, or null if the dream is not started.
  windowmanager_.WindowManager getWindowManager() =>
      windowmanager_.WindowManager.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWindowManager, jni.JniType.objectType, []).object);

  static final _id_getWindow = jniAccessors.getMethodIDOf(
      _classRef, "getWindow", "()Landroid/view/Window;");

  /// from: public android.view.Window getWindow()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the current android.view.Window for the dream.
  /// Behaves similarly to android.app.Activity\#getWindow().
  ///@return The current window, or null if the dream is not started.
  window_.Window getWindow() =>
      window_.Window.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWindow, jni.JniType.objectType, []).object);

  static final _id_setContentView =
      jniAccessors.getMethodIDOf(_classRef, "setContentView", "(I)V");

  /// from: public void setContentView(int layoutResID)
  ///
  /// Inflates a layout resource and set it to be the content view for this Dream.
  /// Behaves similarly to android.app.Activity\#setContentView(int).
  ///
  /// Note: Requires a window, do not call before \#onAttachedToWindow()
  ///
  ///@param layoutResID Resource ID to be inflated.
  ///@see \#setContentView(android.view.View)
  ///@see \#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
  void setContentView(int layoutResID) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setContentView,
      jni.JniType.voidType,
      [layoutResID]).check();

  static final _id_setContentView1 = jniAccessors.getMethodIDOf(
      _classRef, "setContentView", "(Landroid/view/View;)V");

  /// from: public void setContentView(android.view.View view)
  ///
  /// Sets a view to be the content view for this Dream.
  /// Behaves similarly to android.app.Activity\#setContentView(android.view.View) in an activity,
  /// including using ViewGroup.LayoutParams\#MATCH_PARENT as the layout height and width of the view.
  ///
  /// Note: This requires a window, so you should usually call it during
  /// \#onAttachedToWindow() and never earlier (you <strong>cannot</strong> call it
  /// during \#onCreate).
  ///
  ///@see \#setContentView(int)
  ///@see \#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
  void setContentView1(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setContentView1,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_setContentView2 = jniAccessors.getMethodIDOf(
      _classRef,
      "setContentView",
      "(Landroid/view/View;Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void setContentView(android.view.View view, android.view.ViewGroup.LayoutParams params)
  ///
  /// Sets a view to be the content view for this Dream.
  /// Behaves similarly to
  /// android.app.Activity\#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
  /// in an activity.
  ///
  /// Note: This requires a window, so you should usually call it during
  /// \#onAttachedToWindow() and never earlier (you <strong>cannot</strong> call it
  /// during \#onCreate).
  ///
  ///@param view The desired content to display.
  ///@param params Layout parameters for the view.
  ///@see \#setContentView(android.view.View)
  ///@see \#setContentView(int)
  void setContentView2(
          view_.View view, viewgroup_.ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_setContentView2,
          jni.JniType.voidType, [view.reference, params.reference]).check();

  static final _id_addContentView = jniAccessors.getMethodIDOf(
      _classRef,
      "addContentView",
      "(Landroid/view/View;Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void addContentView(android.view.View view, android.view.ViewGroup.LayoutParams params)
  ///
  /// Adds a view to the Dream's window, leaving other content views in place.
  ///
  /// Note: Requires a window, do not call before \#onAttachedToWindow()
  ///
  ///@param view The desired content to display.
  ///@param params Layout parameters for the view.
  void addContentView(
          view_.View view, viewgroup_.ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_addContentView,
          jni.JniType.voidType, [view.reference, params.reference]).check();

  static final _id_setInteractive =
      jniAccessors.getMethodIDOf(_classRef, "setInteractive", "(Z)V");

  /// from: public void setInteractive(boolean interactive)
  ///
  /// Marks this dream as interactive to receive input events.
  ///
  /// Non-interactive dreams (default) will dismiss on the first input event.
  ///
  ///
  /// Interactive dreams should call \#finish() to dismiss themselves.
  ///
  ///@param interactive True if this dream will handle input events.
  void setInteractive(bool interactive) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setInteractive,
      jni.JniType.voidType,
      [interactive]).check();

  static final _id_isInteractive =
      jniAccessors.getMethodIDOf(_classRef, "isInteractive", "()Z");

  /// from: public boolean isInteractive()
  ///
  /// Returns whether or not this dream is interactive.  Defaults to false.
  ///@see \#setInteractive(boolean)
  bool isInteractive() => jniAccessors.callMethodWithArgs(
      reference, _id_isInteractive, jni.JniType.booleanType, []).boolean;

  static final _id_setFullscreen =
      jniAccessors.getMethodIDOf(_classRef, "setFullscreen", "(Z)V");

  /// from: public void setFullscreen(boolean fullscreen)
  ///
  /// Controls android.view.WindowManager.LayoutParams\#FLAG_FULLSCREEN
  /// on the dream's window.
  ///@param fullscreen If true, the fullscreen flag will be set; else it
  /// will be cleared.
  void setFullscreen(bool fullscreen) => jniAccessors.callMethodWithArgs(
      reference, _id_setFullscreen, jni.JniType.voidType, [fullscreen]).check();

  static final _id_isFullscreen =
      jniAccessors.getMethodIDOf(_classRef, "isFullscreen", "()Z");

  /// from: public boolean isFullscreen()
  ///
  /// Returns whether or not this dream is in fullscreen mode. Defaults to false.
  ///@see \#setFullscreen(boolean)
  bool isFullscreen() => jniAccessors.callMethodWithArgs(
      reference, _id_isFullscreen, jni.JniType.booleanType, []).boolean;

  static final _id_setScreenBright =
      jniAccessors.getMethodIDOf(_classRef, "setScreenBright", "(Z)V");

  /// from: public void setScreenBright(boolean screenBright)
  ///
  /// Marks this dream as keeping the screen bright while dreaming.
  ///@param screenBright True to keep the screen bright while dreaming.
  void setScreenBright(bool screenBright) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setScreenBright,
      jni.JniType.voidType,
      [screenBright]).check();

  static final _id_isScreenBright =
      jniAccessors.getMethodIDOf(_classRef, "isScreenBright", "()Z");

  /// from: public boolean isScreenBright()
  ///
  /// Returns whether or not this dream keeps the screen bright while dreaming.
  /// Defaults to false, allowing the screen to dim if necessary.
  ///@see \#setScreenBright(boolean)
  bool isScreenBright() => jniAccessors.callMethodWithArgs(
      reference, _id_isScreenBright, jni.JniType.booleanType, []).boolean;

  static final _id_onCreate =
      jniAccessors.getMethodIDOf(_classRef, "onCreate", "()V");

  /// from: public void onCreate()
  ///
  /// Called when this Dream is constructed.
  void onCreate() => jniAccessors.callMethodWithArgs(
      reference, _id_onCreate, jni.JniType.voidType, []).check();

  static final _id_onDreamingStarted =
      jniAccessors.getMethodIDOf(_classRef, "onDreamingStarted", "()V");

  /// from: public void onDreamingStarted()
  ///
  /// Called when the dream's window has been created and is visible and animation may now begin.
  void onDreamingStarted() => jniAccessors.callMethodWithArgs(
      reference, _id_onDreamingStarted, jni.JniType.voidType, []).check();

  static final _id_onDreamingStopped =
      jniAccessors.getMethodIDOf(_classRef, "onDreamingStopped", "()V");

  /// from: public void onDreamingStopped()
  ///
  /// Called when this Dream is stopped, either by external request or by calling finish(),
  /// before the window has been removed.
  void onDreamingStopped() => jniAccessors.callMethodWithArgs(
      reference, _id_onDreamingStopped, jni.JniType.voidType, []).check();

  static final _id_onWakeUp =
      jniAccessors.getMethodIDOf(_classRef, "onWakeUp", "()V");

  /// from: public void onWakeUp()
  ///
  /// Called when the dream is being asked to stop itself and wake.
  ///
  /// The default implementation simply calls \#finish which ends the dream
  /// immediately.  Subclasses may override this function to perform a smooth exit
  /// transition then call \#finish afterwards.
  ///
  ///
  /// Note that the dream will only be given a short period of time (currently about
  /// five seconds) to wake up.  If the dream does not finish itself in a timely manner
  /// then the system will forcibly finish it once the time allowance is up.
  ///
  ///
  void onWakeUp() => jniAccessors.callMethodWithArgs(
      reference, _id_onWakeUp, jni.JniType.voidType, []).check();

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public final android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);

  static final _id_finish =
      jniAccessors.getMethodIDOf(_classRef, "finish", "()V");

  /// from: public final void finish()
  ///
  /// Stops the dream and detaches from the window.
  ///
  /// When the dream ends, the system will be allowed to go to sleep fully unless there
  /// is a reason for it to be awake such as recent user activity or wake locks being held.
  ///
  ///
  void finish() => jniAccessors.callMethodWithArgs(
      reference, _id_finish, jni.JniType.voidType, []).check();

  static final _id_wakeUp =
      jniAccessors.getMethodIDOf(_classRef, "wakeUp", "()V");

  /// from: public final void wakeUp()
  ///
  /// Wakes the dream up gently.
  ///
  /// Calls \#onWakeUp to give the dream a chance to perform an exit transition.
  /// When the transition is over, the dream should call \#finish.
  ///
  ///
  void wakeUp() => jniAccessors.callMethodWithArgs(
      reference, _id_wakeUp, jni.JniType.voidType, []).check();

  static final _id_onDestroy =
      jniAccessors.getMethodIDOf(_classRef, "onDestroy", "()V");

  /// from: public void onDestroy()
  ///
  /// {@inheritDoc}
  void onDestroy() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroy, jni.JniType.voidType, []).check();

  static final _id_dump = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: protected void dump(java.io.FileDescriptor fd, java.io.PrintWriter pw, java.lang.String[] args)
  void dump(jni.JniObject fd, jni.JniObject pw, jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(reference, _id_dump, jni.JniType.voidType,
          [fd.reference, pw.reference, args.reference]).check();
}
