// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../app/Service.dart" as service_;

import "../../net/Uri.dart" as uri_;

import "../../content/ComponentName.dart" as componentname_;

import "Condition.dart" as condition_;

import "../../os/IBinder.dart" as ibinder_;

import "../../content/Intent.dart" as intent_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.service.notification.ConditionProviderService
///
/// A service that provides conditions about boolean state.
/// To extend this class, you must declare the service in your manifest file with
/// the android.Manifest.permission\#BIND_CONDITION_PROVIDER_SERVICE permission
/// and include an intent filter with the \#SERVICE_INTERFACE action. If you want users to be
/// able to create and update conditions for this service to monitor, include the
/// \#META_DATA_RULE_TYPE and \#META_DATA_CONFIGURATION_ACTIVITY tags and request the
/// android.Manifest.permission\#ACCESS_NOTIFICATION_POLICY permission. For example:
///
/// <pre>
/// &lt;service android:name=".MyConditionProvider"
///          android:label="&\#64;string/service_name"
///          android:permission="android.permission.BIND_CONDITION_PROVIDER_SERVICE">
///     &lt;intent-filter>
///         &lt;action android:name="android.service.notification.ConditionProviderService" />
///     &lt;/intent-filter>
///     &lt;meta-data
///               android:name="android.service.zen.automatic.ruleType"
///               android:value="@string/my_condition_rule">
///           &lt;/meta-data>
///           &lt;meta-data
///               android:name="android.service.zen.automatic.configurationActivity"
///               android:value="com.my.package/.MyConditionConfigurationActivity">
///           &lt;/meta-data>
/// &lt;/service></pre>
///
///   Condition providers cannot be bound by the system on
/// ActivityManager\#isLowRamDevice() low ram devices
///
class ConditionProviderService extends service_.Service {
  static final _classRef = jniAccessors
      .getClassOf("android/service/notification/ConditionProviderService");
  ConditionProviderService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String EXTRA_RULE_ID
  ///
  /// A String rule id extra passed to \#META_DATA_CONFIGURATION_ACTIVITY.
  static const EXTRA_RULE_ID = "android.service.notification.extra.RULE_ID";

  /// from: static public final java.lang.String META_DATA_CONFIGURATION_ACTIVITY
  ///
  /// The name of the {@code meta-data} tag containing the ComponentName of an activity
  /// that allows users to configure the conditions provided by this service.
  static const META_DATA_CONFIGURATION_ACTIVITY =
      "android.service.zen.automatic.configurationActivity";

  /// from: static public final java.lang.String META_DATA_RULE_INSTANCE_LIMIT
  ///
  /// The name of the {@code meta-data} tag containing the maximum number of rule instances that
  /// can be created for this rule type. Omit or enter a value <= 0 to allow unlimited instances.
  static const META_DATA_RULE_INSTANCE_LIMIT =
      "android.service.zen.automatic.ruleInstanceLimit";

  /// from: static public final java.lang.String META_DATA_RULE_TYPE
  ///
  /// The name of the {@code meta-data} tag containing a localized name of the type of zen rules
  /// provided by this service.
  static const META_DATA_RULE_TYPE = "android.service.zen.automatic.ruleType";

  /// from: static public final java.lang.String SERVICE_INTERFACE
  ///
  /// The Intent that must be declared as handled by the service.
  static const SERVICE_INTERFACE =
      "android.service.notification.ConditionProviderService";

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ConditionProviderService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_onConnected =
      jniAccessors.getMethodIDOf(_classRef, "onConnected", "()V");

  /// from: public abstract void onConnected()
  ///
  /// Called when this service is connected.
  void onConnected() => jniAccessors.callMethodWithArgs(
      reference, _id_onConnected, jni.JniType.voidType, []).check();

  static final _id_onRequestConditions =
      jniAccessors.getMethodIDOf(_classRef, "onRequestConditions", "(I)V");

  /// from: public void onRequestConditions(int relevance)
  void onRequestConditions(int relevance) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onRequestConditions,
      jni.JniType.voidType,
      [relevance]).check();

  static final _id_onSubscribe = jniAccessors.getMethodIDOf(
      _classRef, "onSubscribe", "(Landroid/net/Uri;)V");

  /// from: public abstract void onSubscribe(android.net.Uri conditionId)
  ///
  /// Called by the system when there is a new Condition to be managed by this provider.
  ///@param conditionId the Uri describing the criteria of the condition.
  void onSubscribe(uri_.Uri conditionId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onSubscribe,
      jni.JniType.voidType,
      [conditionId.reference]).check();

  static final _id_onUnsubscribe = jniAccessors.getMethodIDOf(
      _classRef, "onUnsubscribe", "(Landroid/net/Uri;)V");

  /// from: public abstract void onUnsubscribe(android.net.Uri conditionId)
  ///
  /// Called by the system when a Condition has been deleted.
  ///@param conditionId the Uri describing the criteria of the deleted condition.
  void onUnsubscribe(uri_.Uri conditionId) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onUnsubscribe,
      jni.JniType.voidType,
      [conditionId.reference]).check();

  static final _id_requestRebind = jniAccessors.getStaticMethodIDOf(
      _classRef, "requestRebind", "(Landroid/content/ComponentName;)V");

  /// from: static public final void requestRebind(android.content.ComponentName componentName)
  ///
  /// Request that the provider be rebound, after a previous call to (@link \#requestUnbind).
  ///
  /// This method will fail for providers that have not been granted the permission by the user.
  static void requestRebind(componentname_.ComponentName componentName) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_requestRebind,
          jni.JniType.voidType, [componentName.reference]).check();

  static final _id_requestUnbind =
      jniAccessors.getMethodIDOf(_classRef, "requestUnbind", "()V");

  /// from: public final void requestUnbind()
  ///
  /// Request that the provider service be unbound.
  ///
  /// This will no longer receive subscription updates and will not be able to update the
  /// state of conditions until \#requestRebind(ComponentName) is called.
  /// The service will likely be killed by the system after this call.
  ///
  /// The service should wait for the \#onConnected() event before performing this
  /// operation.
  void requestUnbind() => jniAccessors.callMethodWithArgs(
      reference, _id_requestUnbind, jni.JniType.voidType, []).check();

  static final _id_notifyCondition = jniAccessors.getMethodIDOf(_classRef,
      "notifyCondition", "(Landroid/service/notification/Condition;)V");

  /// from: public final void notifyCondition(android.service.notification.Condition condition)
  ///
  /// Informs the notification manager that the state of a Condition has changed. Use this method
  /// to put the system into Do Not Disturb mode or request that it exits Do Not Disturb mode. This
  /// call will be ignored unless there is an enabled android.app.AutomaticZenRule owned by
  /// service that has an android.app.AutomaticZenRule\#getConditionId() equal to this
  /// Condition\#id.
  ///@param condition the condition that has changed.
  void notifyCondition(condition_.Condition condition) =>
      jniAccessors.callMethodWithArgs(reference, _id_notifyCondition,
          jni.JniType.voidType, [condition.reference]).check();

  static final _id_notifyConditions = jniAccessors.getMethodIDOf(_classRef,
      "notifyConditions", "([Landroid/service/notification/Condition;)V");

  /// from: public final void notifyConditions(android.service.notification.Condition[] conditions)
  ///
  /// Informs the notification manager that the state of one or more Conditions has changed. See
  /// \#notifyCondition(Condition) for restrictions.
  ///@param conditions the changed conditions.
  void notifyConditions(jni.JniObject conditions) =>
      jniAccessors.callMethodWithArgs(reference, _id_notifyConditions,
          jni.JniType.voidType, [conditions.reference]).check();

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);
}
