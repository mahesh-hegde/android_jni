// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../app/Service.dart" as service_;

import "../../content/Context.dart" as context_;

import "StatusBarNotification.dart" as statusbarnotification_;

import "../../os/UserHandle.dart" as userhandle_;

import "../../app/NotificationChannel.dart" as notificationchannel_;

import "../../app/NotificationChannelGroup.dart" as notificationchannelgroup_;

import "../../os/IBinder.dart" as ibinder_;

import "../../content/Intent.dart" as intent_;

import "../../content/ComponentName.dart" as componentname_;

import "../../os/Parcelable.dart" as parcelable_;

import "../../os/Parcel.dart" as parcel_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.service.notification.NotificationListenerService
///
/// A service that receives calls from the system when new notifications are
/// posted or removed, or their ranking changed.
/// To extend this class, you must declare the service in your manifest file with
/// the android.Manifest.permission\#BIND_NOTIFICATION_LISTENER_SERVICE permission
/// and include an intent filter with the \#SERVICE_INTERFACE action. For example:
///
/// <pre>
/// &lt;service android:name=".NotificationListener"
///          android:label="&\#64;string/service_name"
///          android:permission="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE">
///     &lt;intent-filter>
///         &lt;action android:name="android.service.notification.NotificationListenerService" />
///     &lt;/intent-filter>
/// &lt;/service></pre>
///
/// The service should wait for the \#onListenerConnected() event
/// before performing any operations. The \#requestRebind(ComponentName)
/// method is the <i>only</i> one that is safe to call before \#onListenerConnected()
/// or after \#onListenerDisconnected().
///
///
///  Notification listeners cannot get notification access or be bound by the system on
/// {@linkplain ActivityManager\#isLowRamDevice() low-RAM} devices. The system also ignores
/// notification listeners running in a work profile. A
/// android.app.admin.DevicePolicyManager might block notifications originating from a work
/// profile.
///
class NotificationListenerService extends service_.Service {
  static final _classRef = jniAccessors
      .getClassOf("android/service/notification/NotificationListenerService");
  NotificationListenerService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int HINT_HOST_DISABLE_CALL_EFFECTS
  ///
  /// \#getCurrentListenerHints() Listener hints constant - the primary device UI
  /// should disable phone call sounds, buyt not notification sound.
  /// This does not change the interruption filter, only the effects.
  static const HINT_HOST_DISABLE_CALL_EFFECTS = 4;

  /// from: static public final int HINT_HOST_DISABLE_EFFECTS
  ///
  /// \#getCurrentListenerHints() Listener hints constant - the primary device UI
  /// should disable notification sound, vibrating and other visual or aural effects.
  /// This does not change the interruption filter, only the effects.
  static const HINT_HOST_DISABLE_EFFECTS = 1;

  /// from: static public final int HINT_HOST_DISABLE_NOTIFICATION_EFFECTS
  ///
  /// \#getCurrentListenerHints() Listener hints constant - the primary device UI
  /// should disable notification sound, but not phone calls.
  /// This does not change the interruption filter, only the effects.
  static const HINT_HOST_DISABLE_NOTIFICATION_EFFECTS = 2;

  /// from: static public final int INTERRUPTION_FILTER_ALARMS
  ///
  /// \#getCurrentInterruptionFilter() Interruption filter constant -
  ///     Alarms only interruption filter.
  static const INTERRUPTION_FILTER_ALARMS = 4;

  /// from: static public final int INTERRUPTION_FILTER_ALL
  ///
  /// \#getCurrentInterruptionFilter() Interruption filter constant -
  ///     Normal interruption filter.
  static const INTERRUPTION_FILTER_ALL = 1;

  /// from: static public final int INTERRUPTION_FILTER_NONE
  ///
  /// \#getCurrentInterruptionFilter() Interruption filter constant -
  ///     No interruptions filter.
  static const INTERRUPTION_FILTER_NONE = 3;

  /// from: static public final int INTERRUPTION_FILTER_PRIORITY
  ///
  /// \#getCurrentInterruptionFilter() Interruption filter constant -
  ///     Priority interruption filter.
  static const INTERRUPTION_FILTER_PRIORITY = 2;

  /// from: static public final int INTERRUPTION_FILTER_UNKNOWN
  ///
  /// \#getCurrentInterruptionFilter() Interruption filter constant - returned when
  /// the value is unavailable for any reason.  For example, before the notification listener
  /// is connected.
  ///
  /// {@see \#onListenerConnected()}
  static const INTERRUPTION_FILTER_UNKNOWN = 0;

  /// from: static public final int NOTIFICATION_CHANNEL_OR_GROUP_ADDED
  ///
  /// Channel or group modification reason provided to
  /// \#onNotificationChannelModified(String, UserHandle,NotificationChannel, int) or
  /// \#onNotificationChannelGroupModified(String, UserHandle, NotificationChannelGroup,
  /// int)- the provided object was created.
  static const NOTIFICATION_CHANNEL_OR_GROUP_ADDED = 1;

  /// from: static public final int NOTIFICATION_CHANNEL_OR_GROUP_DELETED
  ///
  /// Channel or group modification reason provided to
  /// \#onNotificationChannelModified(String, UserHandle, NotificationChannel, int) or
  /// \#onNotificationChannelGroupModified(String, UserHandle, NotificationChannelGroup,
  /// int)- the provided object was deleted.
  static const NOTIFICATION_CHANNEL_OR_GROUP_DELETED = 3;

  /// from: static public final int NOTIFICATION_CHANNEL_OR_GROUP_UPDATED
  ///
  /// Channel or group modification reason provided to
  /// \#onNotificationChannelModified(String, UserHandle, NotificationChannel, int) or
  /// \#onNotificationChannelGroupModified(String, UserHandle,NotificationChannelGroup, int)
  /// - the provided object was updated.
  static const NOTIFICATION_CHANNEL_OR_GROUP_UPDATED = 2;

  /// from: static public final int REASON_APP_CANCEL
  ///
  /// Notification was canceled by the app canceling this specific notification.
  static const REASON_APP_CANCEL = 8;

  /// from: static public final int REASON_APP_CANCEL_ALL
  ///
  /// Notification was canceled by the app cancelling all its notifications.
  static const REASON_APP_CANCEL_ALL = 9;

  /// from: static public final int REASON_CANCEL
  ///
  /// Notification was canceled by the status bar reporting a user dismissal.
  static const REASON_CANCEL = 2;

  /// from: static public final int REASON_CANCEL_ALL
  ///
  /// Notification was canceled by the status bar reporting a user dismiss all.
  static const REASON_CANCEL_ALL = 3;

  /// from: static public final int REASON_CHANNEL_BANNED
  ///
  /// Notification was canceled by the user banning the channel.
  static const REASON_CHANNEL_BANNED = 17;

  /// from: static public final int REASON_CLICK
  ///
  /// Notification was canceled by the status bar reporting a notification click.
  static const REASON_CLICK = 1;

  /// from: static public final int REASON_ERROR
  ///
  /// Notification was canceled by the status bar reporting an inflation error.
  static const REASON_ERROR = 4;

  /// from: static public final int REASON_GROUP_OPTIMIZATION
  ///
  /// Notification was canceled because it was an invisible member of a group.
  static const REASON_GROUP_OPTIMIZATION = 13;

  /// from: static public final int REASON_GROUP_SUMMARY_CANCELED
  ///
  /// Notification was canceled because it was a member of a canceled group.
  static const REASON_GROUP_SUMMARY_CANCELED = 12;

  /// from: static public final int REASON_LISTENER_CANCEL
  ///
  /// Notification was canceled by a listener reporting a user dismissal.
  static const REASON_LISTENER_CANCEL = 10;

  /// from: static public final int REASON_LISTENER_CANCEL_ALL
  ///
  /// Notification was canceled by a listener reporting a user dismiss all.
  static const REASON_LISTENER_CANCEL_ALL = 11;

  /// from: static public final int REASON_PACKAGE_BANNED
  ///
  /// Notification was canceled by the user banning the package.
  static const REASON_PACKAGE_BANNED = 7;

  /// from: static public final int REASON_PACKAGE_CHANGED
  ///
  /// Notification was canceled by the package manager modifying the package.
  static const REASON_PACKAGE_CHANGED = 5;

  /// from: static public final int REASON_PACKAGE_SUSPENDED
  ///
  /// Notification was canceled by the device administrator suspending the package.
  static const REASON_PACKAGE_SUSPENDED = 14;

  /// from: static public final int REASON_PROFILE_TURNED_OFF
  ///
  /// Notification was canceled by the owning managed profile being turned off.
  static const REASON_PROFILE_TURNED_OFF = 15;

  /// from: static public final int REASON_SNOOZED
  ///
  /// Notification was snoozed.
  static const REASON_SNOOZED = 18;

  /// from: static public final int REASON_TIMEOUT
  ///
  /// Notification was canceled due to timeout
  static const REASON_TIMEOUT = 19;

  /// from: static public final int REASON_UNAUTOBUNDLED
  ///
  /// Autobundled summary notification was canceled because its group was unbundled
  static const REASON_UNAUTOBUNDLED = 16;

  /// from: static public final int REASON_USER_STOPPED
  ///
  /// Notification was canceled by the owning user context being stopped.
  static const REASON_USER_STOPPED = 6;

  /// from: static public final java.lang.String SERVICE_INTERFACE
  ///
  /// The Intent that must be declared as handled by the service.
  static const SERVICE_INTERFACE =
      "android.service.notification.NotificationListenerService";

  /// from: static public final int SUPPRESSED_EFFECT_SCREEN_OFF
  ///
  /// Whether notification suppressed by DND should not interruption visually when the screen is
  /// off.
  ///@deprecated Use the more specific visual effects in NotificationManager.Policy.
  static const SUPPRESSED_EFFECT_SCREEN_OFF = 1;

  /// from: static public final int SUPPRESSED_EFFECT_SCREEN_ON
  ///
  /// Whether notification suppressed by DND should not interruption visually when the screen is
  /// on.
  ///@deprecated Use the more specific visual effects in NotificationManager.Policy.
  static const SUPPRESSED_EFFECT_SCREEN_ON = 2;

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  NotificationListenerService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_attachBaseContext1 = jniAccessors.getMethodIDOf(
      _classRef, "attachBaseContext", "(Landroid/content/Context;)V");

  /// from: protected void attachBaseContext(android.content.Context base)
  void attachBaseContext1(context_.Context base) =>
      jniAccessors.callMethodWithArgs(reference, _id_attachBaseContext1,
          jni.JniType.voidType, [base.reference]).check();

  static final _id_onNotificationPosted = jniAccessors.getMethodIDOf(
      _classRef,
      "onNotificationPosted",
      "(Landroid/service/notification/StatusBarNotification;)V");

  /// from: public void onNotificationPosted(android.service.notification.StatusBarNotification sbn)
  ///
  /// Implement this method to learn about new notifications as they are posted by apps.
  ///@param sbn A data structure encapsulating the original android.app.Notification
  ///            object as well as its identifying information (tag and id) and source
  ///            (package name).
  void onNotificationPosted(statusbarnotification_.StatusBarNotification sbn) =>
      jniAccessors.callMethodWithArgs(reference, _id_onNotificationPosted,
          jni.JniType.voidType, [sbn.reference]).check();

  static final _id_onNotificationPosted1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onNotificationPosted",
      "(Landroid/service/notification/StatusBarNotification;Landroid/service/notification/NotificationListenerService\$RankingMap;)V");

  /// from: public void onNotificationPosted(android.service.notification.StatusBarNotification sbn, android.service.notification.NotificationListenerService.RankingMap rankingMap)
  ///
  /// Implement this method to learn about new notifications as they are posted by apps.
  ///@param sbn A data structure encapsulating the original android.app.Notification
  ///            object as well as its identifying information (tag and id) and source
  ///            (package name).
  ///@param rankingMap The current ranking map that can be used to retrieve ranking information
  ///                   for active notifications, including the newly posted one.
  void onNotificationPosted1(statusbarnotification_.StatusBarNotification sbn,
          NotificationListenerService_RankingMap rankingMap) =>
      jniAccessors.callMethodWithArgs(reference, _id_onNotificationPosted1,
          jni.JniType.voidType, [sbn.reference, rankingMap.reference]).check();

  static final _id_onNotificationRemoved = jniAccessors.getMethodIDOf(
      _classRef,
      "onNotificationRemoved",
      "(Landroid/service/notification/StatusBarNotification;)V");

  /// from: public void onNotificationRemoved(android.service.notification.StatusBarNotification sbn)
  ///
  /// Implement this method to learn when notifications are removed.
  ///
  /// This might occur because the user has dismissed the notification using system UI (or another
  /// notification listener) or because the app has withdrawn the notification.
  ///
  /// NOTE: The StatusBarNotification object you receive will be "light"; that is, the
  /// result from StatusBarNotification\#getNotification may be missing some heavyweight
  /// fields such as android.app.Notification\#contentView and
  /// android.app.Notification\#largeIcon. However, all other fields on
  /// StatusBarNotification, sufficient to match this call with a prior call to
  /// \#onNotificationPosted(StatusBarNotification), will be intact.
  ///@param sbn A data structure encapsulating at least the original information (tag and id)
  ///            and source (package name) used to post the android.app.Notification that
  ///            was just removed.
  void onNotificationRemoved(
          statusbarnotification_.StatusBarNotification sbn) =>
      jniAccessors.callMethodWithArgs(reference, _id_onNotificationRemoved,
          jni.JniType.voidType, [sbn.reference]).check();

  static final _id_onNotificationRemoved1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onNotificationRemoved",
      "(Landroid/service/notification/StatusBarNotification;Landroid/service/notification/NotificationListenerService\$RankingMap;)V");

  /// from: public void onNotificationRemoved(android.service.notification.StatusBarNotification sbn, android.service.notification.NotificationListenerService.RankingMap rankingMap)
  ///
  /// Implement this method to learn when notifications are removed.
  ///
  /// This might occur because the user has dismissed the notification using system UI (or another
  /// notification listener) or because the app has withdrawn the notification.
  ///
  /// NOTE: The StatusBarNotification object you receive will be "light"; that is, the
  /// result from StatusBarNotification\#getNotification may be missing some heavyweight
  /// fields such as android.app.Notification\#contentView and
  /// android.app.Notification\#largeIcon. However, all other fields on
  /// StatusBarNotification, sufficient to match this call with a prior call to
  /// \#onNotificationPosted(StatusBarNotification), will be intact.
  ///@param sbn A data structure encapsulating at least the original information (tag and id)
  ///            and source (package name) used to post the android.app.Notification that
  ///            was just removed.
  ///@param rankingMap The current ranking map that can be used to retrieve ranking information
  ///                   for active notifications.
  void onNotificationRemoved1(statusbarnotification_.StatusBarNotification sbn,
          NotificationListenerService_RankingMap rankingMap) =>
      jniAccessors.callMethodWithArgs(reference, _id_onNotificationRemoved1,
          jni.JniType.voidType, [sbn.reference, rankingMap.reference]).check();

  static final _id_onNotificationRemoved2 = jniAccessors.getMethodIDOf(
      _classRef,
      "onNotificationRemoved",
      "(Landroid/service/notification/StatusBarNotification;Landroid/service/notification/NotificationListenerService\$RankingMap;I)V");

  /// from: public void onNotificationRemoved(android.service.notification.StatusBarNotification sbn, android.service.notification.NotificationListenerService.RankingMap rankingMap, int reason)
  ///
  /// Implement this method to learn when notifications are removed and why.
  ///
  /// This might occur because the user has dismissed the notification using system UI (or another
  /// notification listener) or because the app has withdrawn the notification.
  ///
  /// NOTE: The StatusBarNotification object you receive will be "light"; that is, the
  /// result from StatusBarNotification\#getNotification may be missing some heavyweight
  /// fields such as android.app.Notification\#contentView and
  /// android.app.Notification\#largeIcon. However, all other fields on
  /// StatusBarNotification, sufficient to match this call with a prior call to
  /// \#onNotificationPosted(StatusBarNotification), will be intact.
  ///@param sbn A data structure encapsulating at least the original information (tag and id)
  ///            and source (package name) used to post the android.app.Notification that
  ///            was just removed.
  ///@param rankingMap The current ranking map that can be used to retrieve ranking information
  ///                   for active notifications.
  ///@param reason see \#REASON_LISTENER_CANCEL, etc.
  void onNotificationRemoved2(statusbarnotification_.StatusBarNotification sbn,
          NotificationListenerService_RankingMap rankingMap, int reason) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onNotificationRemoved2,
          jni.JniType.voidType,
          [sbn.reference, rankingMap.reference, reason]).check();

  static final _id_onListenerConnected =
      jniAccessors.getMethodIDOf(_classRef, "onListenerConnected", "()V");

  /// from: public void onListenerConnected()
  ///
  /// Implement this method to learn about when the listener is enabled and connected to
  /// the notification manager.  You are safe to call \#getActiveNotifications()
  /// at this time.
  void onListenerConnected() => jniAccessors.callMethodWithArgs(
      reference, _id_onListenerConnected, jni.JniType.voidType, []).check();

  static final _id_onListenerDisconnected =
      jniAccessors.getMethodIDOf(_classRef, "onListenerDisconnected", "()V");

  /// from: public void onListenerDisconnected()
  ///
  /// Implement this method to learn about when the listener is disconnected from the
  /// notification manager.You will not receive any events after this call, and may only
  /// call \#requestRebind(ComponentName) at this time.
  void onListenerDisconnected() => jniAccessors.callMethodWithArgs(
      reference, _id_onListenerDisconnected, jni.JniType.voidType, []).check();

  static final _id_onNotificationRankingUpdate = jniAccessors.getMethodIDOf(
      _classRef,
      "onNotificationRankingUpdate",
      "(Landroid/service/notification/NotificationListenerService\$RankingMap;)V");

  /// from: public void onNotificationRankingUpdate(android.service.notification.NotificationListenerService.RankingMap rankingMap)
  ///
  /// Implement this method to be notified when the notification ranking changes.
  ///@param rankingMap The current ranking map that can be used to retrieve ranking information
  ///                   for active notifications.
  void onNotificationRankingUpdate(
          NotificationListenerService_RankingMap rankingMap) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onNotificationRankingUpdate,
          jni.JniType.voidType,
          [rankingMap.reference]).check();

  static final _id_onListenerHintsChanged =
      jniAccessors.getMethodIDOf(_classRef, "onListenerHintsChanged", "(I)V");

  /// from: public void onListenerHintsChanged(int hints)
  ///
  /// Implement this method to be notified when the
  /// \#getCurrentListenerHints() Listener hints change.
  ///@param hints The current \#getCurrentListenerHints() listener hints.
  void onListenerHintsChanged(int hints) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onListenerHintsChanged,
      jni.JniType.voidType,
      [hints]).check();

  static final _id_onNotificationChannelModified = jniAccessors.getMethodIDOf(
      _classRef,
      "onNotificationChannelModified",
      "(Ljava/lang/String;Landroid/os/UserHandle;Landroid/app/NotificationChannel;I)V");

  /// from: public void onNotificationChannelModified(java.lang.String pkg, android.os.UserHandle user, android.app.NotificationChannel channel, int modificationType)
  ///
  /// Implement this method to learn about notification channel modifications.
  ///
  /// The caller must have CompanionDeviceManager\#getAssociations() an associated
  /// device in order to receive this callback.
  ///@param pkg The package the channel belongs to.
  ///@param user The user on which the change was made.
  ///@param channel The channel that has changed.
  ///@param modificationType One of \#NOTIFICATION_CHANNEL_OR_GROUP_ADDED,
  ///                   \#NOTIFICATION_CHANNEL_OR_GROUP_UPDATED,
  ///                   \#NOTIFICATION_CHANNEL_OR_GROUP_DELETED.
  ///
  /// Value is android.service.notification.NotificationListenerService\#NOTIFICATION_CHANNEL_OR_GROUP_ADDED, android.service.notification.NotificationListenerService\#NOTIFICATION_CHANNEL_OR_GROUP_UPDATED, or android.service.notification.NotificationListenerService\#NOTIFICATION_CHANNEL_OR_GROUP_DELETED
  void onNotificationChannelModified(
          jni.JniString pkg,
          userhandle_.UserHandle user,
          notificationchannel_.NotificationChannel channel,
          int modificationType) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onNotificationChannelModified, jni.JniType.voidType, [
        pkg.reference,
        user.reference,
        channel.reference,
        modificationType
      ]).check();

  static final _id_onNotificationChannelGroupModified = jniAccessors.getMethodIDOf(
      _classRef,
      "onNotificationChannelGroupModified",
      "(Ljava/lang/String;Landroid/os/UserHandle;Landroid/app/NotificationChannelGroup;I)V");

  /// from: public void onNotificationChannelGroupModified(java.lang.String pkg, android.os.UserHandle user, android.app.NotificationChannelGroup group, int modificationType)
  ///
  /// Implement this method to learn about notification channel group modifications.
  ///
  /// The caller must have CompanionDeviceManager\#getAssociations() an associated
  /// device in order to receive this callback.
  ///@param pkg The package the group belongs to.
  ///@param user The user on which the change was made.
  ///@param group The group that has changed.
  ///@param modificationType One of \#NOTIFICATION_CHANNEL_OR_GROUP_ADDED,
  ///                   \#NOTIFICATION_CHANNEL_OR_GROUP_UPDATED,
  ///                   \#NOTIFICATION_CHANNEL_OR_GROUP_DELETED.
  ///
  /// Value is android.service.notification.NotificationListenerService\#NOTIFICATION_CHANNEL_OR_GROUP_ADDED, android.service.notification.NotificationListenerService\#NOTIFICATION_CHANNEL_OR_GROUP_UPDATED, or android.service.notification.NotificationListenerService\#NOTIFICATION_CHANNEL_OR_GROUP_DELETED
  void onNotificationChannelGroupModified(
          jni.JniString pkg,
          userhandle_.UserHandle user,
          notificationchannelgroup_.NotificationChannelGroup group,
          int modificationType) =>
      jniAccessors.callMethodWithArgs(reference,
          _id_onNotificationChannelGroupModified, jni.JniType.voidType, [
        pkg.reference,
        user.reference,
        group.reference,
        modificationType
      ]).check();

  static final _id_onInterruptionFilterChanged = jniAccessors.getMethodIDOf(
      _classRef, "onInterruptionFilterChanged", "(I)V");

  /// from: public void onInterruptionFilterChanged(int interruptionFilter)
  ///
  /// Implement this method to be notified when the
  /// \#getCurrentInterruptionFilter() interruption filter changed.
  ///@param interruptionFilter The current
  ///     \#getCurrentInterruptionFilter() interruption filter.
  void onInterruptionFilterChanged(int interruptionFilter) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onInterruptionFilterChanged,
          jni.JniType.voidType,
          [interruptionFilter]).check();

  static final _id_cancelNotification = jniAccessors.getMethodIDOf(_classRef,
      "cancelNotification", "(Ljava/lang/String;Ljava/lang/String;I)V");

  /// from: public final void cancelNotification(java.lang.String pkg, java.lang.String tag, int id)
  ///
  /// Inform the notification manager about dismissal of a single notification.
  ///
  /// Use this if your listener has a user interface that allows the user to dismiss individual
  /// notifications, similar to the behavior of Android's status bar and notification panel.
  /// It should be called after the user dismisses a single notification using your UI;
  /// upon being informed, the notification manager will actually remove the notification
  /// and you will get an \#onNotificationRemoved(StatusBarNotification) callback.
  ///
  /// __Note:__ If your listener allows the user to fire a notification's
  /// android.app.Notification\#contentIntent by tapping/clicking/etc., you should call
  /// this method at that time <i>if</i> the Notification in question has the
  /// android.app.Notification\#FLAG_AUTO_CANCEL flag set.
  ///
  /// The service should wait for the \#onListenerConnected() event
  /// before performing this operation.
  ///@param pkg Package of the notifying app.
  ///@param tag Tag of the notification as specified by the notifying app in
  ///     android.app.NotificationManager\#notify(String, int, android.app.Notification).
  ///@param id ID of the notification as specified by the notifying app in
  ///     android.app.NotificationManager\#notify(String, int, android.app.Notification).
  ///
  ///@deprecated Use \#cancelNotification(String key)
  /// instead. Beginning with android.os.Build.VERSION_CODES\#LOLLIPOP this method will no longer
  /// cancel the notification. It will continue to cancel the notification for applications
  /// whose {@code targetSdkVersion} is earlier than android.os.Build.VERSION_CODES\#LOLLIPOP.
  void cancelNotification(jni.JniString pkg, jni.JniString tag, int id) =>
      jniAccessors.callMethodWithArgs(reference, _id_cancelNotification,
          jni.JniType.voidType, [pkg.reference, tag.reference, id]).check();

  static final _id_cancelNotification1 = jniAccessors.getMethodIDOf(
      _classRef, "cancelNotification", "(Ljava/lang/String;)V");

  /// from: public final void cancelNotification(java.lang.String key)
  ///
  /// Inform the notification manager about dismissal of a single notification.
  ///
  /// Use this if your listener has a user interface that allows the user to dismiss individual
  /// notifications, similar to the behavior of Android's status bar and notification panel.
  /// It should be called after the user dismisses a single notification using your UI;
  /// upon being informed, the notification manager will actually remove the notification
  /// and you will get an \#onNotificationRemoved(StatusBarNotification) callback.
  ///
  /// __Note:__ If your listener allows the user to fire a notification's
  /// android.app.Notification\#contentIntent by tapping/clicking/etc., you should call
  /// this method at that time <i>if</i> the Notification in question has the
  /// android.app.Notification\#FLAG_AUTO_CANCEL flag set.
  ///
  ///
  /// The service should wait for the \#onListenerConnected() event
  /// before performing this operation.
  ///@param key Notification to dismiss from StatusBarNotification\#getKey().
  void cancelNotification1(jni.JniString key) =>
      jniAccessors.callMethodWithArgs(reference, _id_cancelNotification1,
          jni.JniType.voidType, [key.reference]).check();

  static final _id_cancelAllNotifications =
      jniAccessors.getMethodIDOf(_classRef, "cancelAllNotifications", "()V");

  /// from: public final void cancelAllNotifications()
  ///
  /// Inform the notification manager about dismissal of all notifications.
  ///
  /// Use this if your listener has a user interface that allows the user to dismiss all
  /// notifications, similar to the behavior of Android's status bar and notification panel.
  /// It should be called after the user invokes the "dismiss all" function of your UI;
  /// upon being informed, the notification manager will actually remove all active notifications
  /// and you will get multiple \#onNotificationRemoved(StatusBarNotification) callbacks.
  ///
  /// The service should wait for the \#onListenerConnected() event
  /// before performing this operation.
  ///
  /// {@see \#cancelNotification(String, String, int)}
  void cancelAllNotifications() => jniAccessors.callMethodWithArgs(
      reference, _id_cancelAllNotifications, jni.JniType.voidType, []).check();

  static final _id_cancelNotifications = jniAccessors.getMethodIDOf(
      _classRef, "cancelNotifications", "([Ljava/lang/String;)V");

  /// from: public final void cancelNotifications(java.lang.String[] keys)
  ///
  /// Inform the notification manager about dismissal of specific notifications.
  ///
  /// Use this if your listener has a user interface that allows the user to dismiss
  /// multiple notifications at once.
  ///
  /// The service should wait for the \#onListenerConnected() event
  /// before performing this operation.
  ///@param keys Notifications to dismiss, or {@code null} to dismiss all.
  ///
  /// {@see \#cancelNotification(String, String, int)}
  void cancelNotifications(jni.JniObject keys) =>
      jniAccessors.callMethodWithArgs(reference, _id_cancelNotifications,
          jni.JniType.voidType, [keys.reference]).check();

  static final _id_snoozeNotification = jniAccessors.getMethodIDOf(
      _classRef, "snoozeNotification", "(Ljava/lang/String;J)V");

  /// from: public final void snoozeNotification(java.lang.String key, long durationMs)
  ///
  /// Inform the notification manager about snoozing a specific notification.
  ///
  /// Use this if your listener has a user interface that allows the user to snooze a notification
  /// for a time. It should be called after the user snoozes a single notification using
  /// your UI; upon being informed, the notification manager will actually remove the notification
  /// and you will get an \#onNotificationRemoved(StatusBarNotification) callback. When the
  /// snoozing period expires, you will get a
  /// \#onNotificationPosted(StatusBarNotification, RankingMap) callback for the
  /// notification.
  ///@param key The key of the notification to snooze
  ///@param durationMs A duration to snooze the notification for, in milliseconds.
  void snoozeNotification(jni.JniString key, int durationMs) =>
      jniAccessors.callMethodWithArgs(reference, _id_snoozeNotification,
          jni.JniType.voidType, [key.reference, durationMs]).check();

  static final _id_setNotificationsShown = jniAccessors.getMethodIDOf(
      _classRef, "setNotificationsShown", "([Ljava/lang/String;)V");

  /// from: public final void setNotificationsShown(java.lang.String[] keys)
  ///
  /// Inform the notification manager that these notifications have been viewed by the
  /// user. This should only be called when there is sufficient confidence that the user is
  /// looking at the notifications, such as when the notifications appear on the screen due to
  /// an explicit user interaction.
  ///
  /// The service should wait for the \#onListenerConnected() event
  /// before performing this operation.
  ///@param keys Notifications to mark as seen.
  void setNotificationsShown(jni.JniObject keys) =>
      jniAccessors.callMethodWithArgs(reference, _id_setNotificationsShown,
          jni.JniType.voidType, [keys.reference]).check();

  static final _id_updateNotificationChannel = jniAccessors.getMethodIDOf(
      _classRef,
      "updateNotificationChannel",
      "(Ljava/lang/String;Landroid/os/UserHandle;Landroid/app/NotificationChannel;)V");

  /// from: public final void updateNotificationChannel(java.lang.String pkg, android.os.UserHandle user, android.app.NotificationChannel channel)
  ///
  /// Updates a notification channel for a given package for a given user. This should only be used
  /// to reflect changes a user has made to the channel via the listener's user interface.
  ///
  /// This method will throw a security exception if you don't have access to notifications
  /// for the given user.
  ///
  /// The caller must have CompanionDeviceManager\#getAssociations() an associated
  /// device in order to use this method.
  ///@param pkg The package the channel belongs to.
  /// This value must never be {@code null}.
  ///@param user The user the channel belongs to.
  /// This value must never be {@code null}.
  ///@param channel the channel to update.
  ///
  /// This value must never be {@code null}.
  void updateNotificationChannel(jni.JniString pkg, userhandle_.UserHandle user,
          notificationchannel_.NotificationChannel channel) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_updateNotificationChannel,
          jni.JniType.voidType,
          [pkg.reference, user.reference, channel.reference]).check();

  static final _id_getNotificationChannels = jniAccessors.getMethodIDOf(
      _classRef,
      "getNotificationChannels",
      "(Ljava/lang/String;Landroid/os/UserHandle;)Ljava/util/List;");

  /// from: public final java.util.List<android.app.NotificationChannel> getNotificationChannels(java.lang.String pkg, android.os.UserHandle user)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns all notification channels belonging to the given package for a given user.
  ///
  /// This method will throw a security exception if you don't have access to notifications
  /// for the given user.
  ///
  /// The caller must have CompanionDeviceManager\#getAssociations() an associated
  /// device in order to use this method.
  ///@param pkg The package to retrieve channels for.
  ///
  /// This value must never be {@code null}.
  ///@param user This value must never be {@code null}.
  jni.JniObject getNotificationChannels(
          jni.JniString pkg, userhandle_.UserHandle user) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getNotificationChannels,
          jni.JniType.objectType,
          [pkg.reference, user.reference]).object);

  static final _id_getNotificationChannelGroups = jniAccessors.getMethodIDOf(
      _classRef,
      "getNotificationChannelGroups",
      "(Ljava/lang/String;Landroid/os/UserHandle;)Ljava/util/List;");

  /// from: public final java.util.List<android.app.NotificationChannelGroup> getNotificationChannelGroups(java.lang.String pkg, android.os.UserHandle user)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns all notification channel groups belonging to the given package for a given user.
  ///
  /// This method will throw a security exception if you don't have access to notifications
  /// for the given user.
  ///
  /// The caller must have CompanionDeviceManager\#getAssociations() an associated
  /// device in order to use this method.
  ///@param pkg The package to retrieve channel groups for.
  ///
  /// This value must never be {@code null}.
  ///@param user This value must never be {@code null}.
  jni.JniObject getNotificationChannelGroups(
          jni.JniString pkg, userhandle_.UserHandle user) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getNotificationChannelGroups,
          jni.JniType.objectType,
          [pkg.reference, user.reference]).object);

  static final _id_getActiveNotifications = jniAccessors.getMethodIDOf(
      _classRef,
      "getActiveNotifications",
      "()[Landroid/service/notification/StatusBarNotification;");

  /// from: public android.service.notification.StatusBarNotification[] getActiveNotifications()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Request the list of outstanding notifications (that is, those that are visible to the
  /// current user). Useful when you don't know what's already been posted.
  ///
  /// The service should wait for the \#onListenerConnected() event
  /// before performing this operation.
  ///@return An array of active notifications, sorted in natural order.
  jni.JniObject getActiveNotifications() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getActiveNotifications, jni.JniType.objectType, []).object);

  static final _id_getSnoozedNotifications = jniAccessors.getMethodIDOf(
      _classRef,
      "getSnoozedNotifications",
      "()[Landroid/service/notification/StatusBarNotification;");

  /// from: public final android.service.notification.StatusBarNotification[] getSnoozedNotifications()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#getActiveNotifications(), but returns the list of currently snoozed
  /// notifications, for all users this listener has access to.
  ///
  /// The service should wait for the \#onListenerConnected() event
  /// before performing this operation.
  ///@return An array of snoozed notifications, sorted in natural order.
  jni.JniObject getSnoozedNotifications() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSnoozedNotifications, jni.JniType.objectType, []).object);

  static final _id_getActiveNotifications1 = jniAccessors.getMethodIDOf(
      _classRef,
      "getActiveNotifications",
      "([Ljava/lang/String;)[Landroid/service/notification/StatusBarNotification;");

  /// from: public android.service.notification.StatusBarNotification[] getActiveNotifications(java.lang.String[] keys)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Request one or more notifications by key. Useful if you have been keeping track of
  /// notifications but didn't want to retain the bits, and now need to go back and extract
  /// more data out of those notifications.
  ///
  /// The service should wait for the \#onListenerConnected() event
  /// before performing this operation.
  ///@param keys the keys of the notifications to request
  ///@return An array of notifications corresponding to the requested keys, in the
  /// same order as the key list.
  jni.JniObject getActiveNotifications1(jni.JniObject keys) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getActiveNotifications1,
          jni.JniType.objectType,
          [keys.reference]).object);

  static final _id_getCurrentListenerHints =
      jniAccessors.getMethodIDOf(_classRef, "getCurrentListenerHints", "()I");

  /// from: public final int getCurrentListenerHints()
  ///
  /// Gets the set of hints representing current state.
  ///
  ///
  /// The current state may differ from the requested state if the hint represents state
  /// shared across all listeners or a feature the notification host does not support or refuses
  /// to grant.
  ///
  /// The service should wait for the \#onListenerConnected() event
  /// before performing this operation.
  ///@return Zero or more of the HINT_ constants.
  int getCurrentListenerHints() => jniAccessors.callMethodWithArgs(
      reference, _id_getCurrentListenerHints, jni.JniType.intType, []).integer;

  static final _id_getCurrentInterruptionFilter = jniAccessors.getMethodIDOf(
      _classRef, "getCurrentInterruptionFilter", "()I");

  /// from: public final int getCurrentInterruptionFilter()
  ///
  /// Gets the current notification interruption filter active on the host.
  ///
  ///
  /// The interruption filter defines which notifications are allowed to interrupt the user
  /// (e.g. via sound &amp; vibration) and is applied globally. Listeners can find out whether
  /// a specific notification matched the interruption filter via
  /// Ranking\#matchesInterruptionFilter().
  ///
  /// The current filter may differ from the previously requested filter if the notification host
  /// does not support or refuses to apply the requested filter, or if another component changed
  /// the filter in the meantime.
  ///
  /// Listen for updates using \#onInterruptionFilterChanged(int).
  ///
  /// The service should wait for the \#onListenerConnected() event
  /// before performing this operation.
  ///@return One of the INTERRUPTION_FILTER_ constants, or INTERRUPTION_FILTER_UNKNOWN when
  /// unavailable.
  int getCurrentInterruptionFilter() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getCurrentInterruptionFilter,
      jni.JniType.intType, []).integer;

  static final _id_requestListenerHints =
      jniAccessors.getMethodIDOf(_classRef, "requestListenerHints", "(I)V");

  /// from: public final void requestListenerHints(int hints)
  ///
  /// Sets the desired \#getCurrentListenerHints() listener hints.
  ///
  ///
  /// This is merely a request, the host may or may not choose to take action depending
  /// on other listener requests or other global state.
  ///
  /// Listen for updates using \#onListenerHintsChanged(int).
  ///
  /// The service should wait for the \#onListenerConnected() event
  /// before performing this operation.
  ///@param hints One or more of the HINT_ constants.
  void requestListenerHints(int hints) => jniAccessors.callMethodWithArgs(
      reference,
      _id_requestListenerHints,
      jni.JniType.voidType,
      [hints]).check();

  static final _id_requestInterruptionFilter = jniAccessors.getMethodIDOf(
      _classRef, "requestInterruptionFilter", "(I)V");

  /// from: public final void requestInterruptionFilter(int interruptionFilter)
  ///
  /// Sets the desired \#getCurrentInterruptionFilter() interruption filter.
  ///
  ///
  /// This is merely a request, the host may or may not choose to apply the requested
  /// interruption filter depending on other listener requests or other global state.
  ///
  /// Listen for updates using \#onInterruptionFilterChanged(int).
  ///
  /// The service should wait for the \#onListenerConnected() event
  /// before performing this operation.
  ///@param interruptionFilter One of the INTERRUPTION_FILTER_ constants.
  void requestInterruptionFilter(int interruptionFilter) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestInterruptionFilter,
          jni.JniType.voidType, [interruptionFilter]).check();

  static final _id_getCurrentRanking = jniAccessors.getMethodIDOf(
      _classRef,
      "getCurrentRanking",
      "()Landroid/service/notification/NotificationListenerService\$RankingMap;");

  /// from: public android.service.notification.NotificationListenerService.RankingMap getCurrentRanking()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns current ranking information.
  ///
  ///
  /// The returned object represents the current ranking snapshot and only
  /// applies for currently active notifications.
  ///
  /// Generally you should use the RankingMap that is passed with events such
  /// as \#onNotificationPosted(StatusBarNotification, RankingMap),
  /// \#onNotificationRemoved(StatusBarNotification, RankingMap), and
  /// so on. This method should only be used when needing access outside of
  /// such events, for example to retrieve the RankingMap right after
  /// initialization.
  ///
  /// The service should wait for the \#onListenerConnected() event
  /// before performing this operation.
  ///@return A RankingMap object providing access to ranking information
  NotificationListenerService_RankingMap getCurrentRanking() =>
      NotificationListenerService_RankingMap.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getCurrentRanking,
              jni.JniType.objectType, []).object);

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This is not the lifecycle event you are looking for.
  ///
  /// The service should wait for the \#onListenerConnected() event
  /// before performing any operations.
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);

  static final _id_onDestroy =
      jniAccessors.getMethodIDOf(_classRef, "onDestroy", "()V");

  /// from: public void onDestroy()
  void onDestroy() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroy, jni.JniType.voidType, []).check();

  static final _id_requestRebind = jniAccessors.getStaticMethodIDOf(
      _classRef, "requestRebind", "(Landroid/content/ComponentName;)V");

  /// from: static public void requestRebind(android.content.ComponentName componentName)
  ///
  /// Request that the listener be rebound, after a previous call to \#requestUnbind.
  ///
  /// This method will fail for listeners that have
  /// not been granted the permission by the user.
  static void requestRebind(componentname_.ComponentName componentName) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_requestRebind,
          jni.JniType.voidType, [componentName.reference]).check();

  static final _id_requestUnbind =
      jniAccessors.getMethodIDOf(_classRef, "requestUnbind", "()V");

  /// from: public final void requestUnbind()
  ///
  /// Request that the service be unbound.
  ///
  /// Once this is called, you will no longer receive updates and no method calls are
  /// guaranteed to be successful, until you next receive the \#onListenerConnected() event.
  /// The service will likely be killed by the system after this call.
  ///
  /// The service should wait for the \#onListenerConnected() event
  /// before performing this operation. I know it's tempting, but you must wait.
  void requestUnbind() => jniAccessors.callMethodWithArgs(
      reference, _id_requestUnbind, jni.JniType.voidType, []).check();
}

/// from: android.service.notification.NotificationListenerService$RankingMap
///
/// Provides access to ranking information on currently active
/// notifications.
///
///
/// Note that this object represents a ranking snapshot that only applies to
/// notifications active at the time of retrieval.
class NotificationListenerService_RankingMap extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/service/notification/NotificationListenerService\$RankingMap");
  NotificationListenerService_RankingMap.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_CREATOR = jniAccessors.getStaticFieldIDOf(
      _classRef, "CREATOR", "Landroid/os/Parcelable\$Creator;");

  /// from: static public final android.os.Parcelable.Creator<android.service.notification.NotificationListenerService.RankingMap> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static parcelable_.Parcelable_Creator get CREATOR =>
      parcelable_.Parcelable_Creator.fromRef(jniAccessors
          .getStaticField(_classRef, _id_CREATOR, jni.JniType.objectType)
          .object);

  static final _id_getOrderedKeys = jniAccessors.getMethodIDOf(
      _classRef, "getOrderedKeys", "()[Ljava/lang/String;");

  /// from: public java.lang.String[] getOrderedKeys()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Request the list of notification keys in their current ranking
  /// order.
  ///@return An array of active notification keys, in their ranking order.
  jni.JniObject getOrderedKeys() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getOrderedKeys, jni.JniType.objectType, []).object);

  static final _id_getRanking = jniAccessors.getMethodIDOf(
      _classRef,
      "getRanking",
      "(Ljava/lang/String;Landroid/service/notification/NotificationListenerService\$Ranking;)Z");

  /// from: public boolean getRanking(java.lang.String key, android.service.notification.NotificationListenerService.Ranking outRanking)
  ///
  /// Populates outRanking with ranking information for the notification
  /// with the given key.
  ///@return true if a valid key has been passed and outRanking has
  ///     been populated; false otherwise
  bool getRanking(
          jni.JniString key, NotificationListenerService_Ranking outRanking) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getRanking,
          jni.JniType.booleanType,
          [key.reference, outRanking.reference]).boolean;

  static final _id_describeContents =
      jniAccessors.getMethodIDOf(_classRef, "describeContents", "()I");

  /// from: public int describeContents()
  int describeContents() => jniAccessors.callMethodWithArgs(
      reference, _id_describeContents, jni.JniType.intType, []).integer;

  static final _id_writeToParcel = jniAccessors.getMethodIDOf(
      _classRef, "writeToParcel", "(Landroid/os/Parcel;I)V");

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(parcel_.Parcel dest, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_writeToParcel,
          jni.JniType.voidType, [dest.reference, flags]).check();
}

/// from: android.service.notification.NotificationListenerService$Ranking
///
/// Stores ranking related information on a currently active notification.
///
///
/// Ranking objects aren't automatically updated as notification events
/// occur. Instead, ranking information has to be retrieved again via the
/// current RankingMap.
class NotificationListenerService_Ranking extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf(
      "android/service/notification/NotificationListenerService\$Ranking");
  NotificationListenerService_Ranking.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final int USER_SENTIMENT_NEGATIVE
  ///
  /// The user is likely to have a negative reaction to this notification.
  static const USER_SENTIMENT_NEGATIVE = -1;

  /// from: static public final int USER_SENTIMENT_NEUTRAL
  ///
  /// It is not known how the user will react to this notification.
  static const USER_SENTIMENT_NEUTRAL = 0;

  /// from: static public final int USER_SENTIMENT_POSITIVE
  ///
  /// The user is likely to have a positive reaction to this notification.
  static const USER_SENTIMENT_POSITIVE = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  NotificationListenerService_Ranking()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getKey =
      jniAccessors.getMethodIDOf(_classRef, "getKey", "()Ljava/lang/String;");

  /// from: public java.lang.String getKey()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the key of the notification this Ranking applies to.
  jni.JniString getKey() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getKey, jni.JniType.objectType, []).object);

  static final _id_getRank =
      jniAccessors.getMethodIDOf(_classRef, "getRank", "()I");

  /// from: public int getRank()
  ///
  /// Returns the rank of the notification.
  ///@return the rank of the notification, that is the 0-based index in
  ///     the list of active notifications.
  int getRank() => jniAccessors.callMethodWithArgs(
      reference, _id_getRank, jni.JniType.intType, []).integer;

  static final _id_isAmbient =
      jniAccessors.getMethodIDOf(_classRef, "isAmbient", "()Z");

  /// from: public boolean isAmbient()
  ///
  /// Returns whether the notification is an ambient notification, that is
  /// a notification that doesn't require the user's immediate attention.
  bool isAmbient() => jniAccessors.callMethodWithArgs(
      reference, _id_isAmbient, jni.JniType.booleanType, []).boolean;

  static final _id_getSuppressedVisualEffects = jniAccessors.getMethodIDOf(
      _classRef, "getSuppressedVisualEffects", "()I");

  /// from: public int getSuppressedVisualEffects()
  ///
  /// Returns the type(s) of visual effects that should be suppressed for this notification.
  /// See NotificationManager.Policy, e.g.
  /// NotificationManager.Policy\#SUPPRESSED_EFFECT_LIGHTS.
  int getSuppressedVisualEffects() => jniAccessors.callMethodWithArgs(reference,
      _id_getSuppressedVisualEffects, jni.JniType.intType, []).integer;

  static final _id_matchesInterruptionFilter =
      jniAccessors.getMethodIDOf(_classRef, "matchesInterruptionFilter", "()Z");

  /// from: public boolean matchesInterruptionFilter()
  ///
  /// Returns whether the notification matches the user's interruption
  /// filter.
  ///@return {@code true} if the notification is allowed by the filter, or
  /// {@code false} if it is blocked.
  bool matchesInterruptionFilter() => jniAccessors.callMethodWithArgs(reference,
      _id_matchesInterruptionFilter, jni.JniType.booleanType, []).boolean;

  static final _id_getImportance =
      jniAccessors.getMethodIDOf(_classRef, "getImportance", "()I");

  /// from: public int getImportance()
  ///
  /// Returns the importance of the notification, which dictates its
  /// modes of presentation, see: NotificationManager\#IMPORTANCE_DEFAULT, etc.
  ///@return the importance of the notification
  ///
  /// Value is android.app.NotificationManager\#IMPORTANCE_UNSPECIFIED, android.app.NotificationManager\#IMPORTANCE_NONE, android.app.NotificationManager\#IMPORTANCE_MIN, android.app.NotificationManager\#IMPORTANCE_LOW, android.app.NotificationManager\#IMPORTANCE_DEFAULT, or android.app.NotificationManager\#IMPORTANCE_HIGH
  int getImportance() => jniAccessors.callMethodWithArgs(
      reference, _id_getImportance, jni.JniType.intType, []).integer;

  static final _id_getImportanceExplanation = jniAccessors.getMethodIDOf(
      _classRef, "getImportanceExplanation", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getImportanceExplanation()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If the importance has been overridden by user preference, then this will be non-null,
  /// and should be displayed to the user.
  ///@return the explanation for the importance, or null if it is the natural importance
  jni.JniObject getImportanceExplanation() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getImportanceExplanation, jni.JniType.objectType, []).object);

  static final _id_getOverrideGroupKey = jniAccessors.getMethodIDOf(
      _classRef, "getOverrideGroupKey", "()Ljava/lang/String;");

  /// from: public java.lang.String getOverrideGroupKey()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If the system has overridden the group key, then this will be non-null, and this
  /// key should be used to bundle notifications.
  jni.JniString getOverrideGroupKey() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getOverrideGroupKey, jni.JniType.objectType, []).object);

  static final _id_getChannel = jniAccessors.getMethodIDOf(
      _classRef, "getChannel", "()Landroid/app/NotificationChannel;");

  /// from: public android.app.NotificationChannel getChannel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the notification channel this notification was posted to, which dictates
  /// notification behavior and presentation.
  notificationchannel_.NotificationChannel getChannel() =>
      notificationchannel_.NotificationChannel.fromRef(jniAccessors
          .callMethodWithArgs(
              reference, _id_getChannel, jni.JniType.objectType, []).object);

  static final _id_getUserSentiment =
      jniAccessors.getMethodIDOf(_classRef, "getUserSentiment", "()I");

  /// from: public int getUserSentiment()
  ///
  /// Returns how the system thinks the user feels about notifications from the
  /// channel provided by \#getChannel(). You can use this information to expose
  /// controls to help the user block this channel's notifications, if the sentiment is
  /// \#USER_SENTIMENT_NEGATIVE, or emphasize this notification if the sentiment is
  /// \#USER_SENTIMENT_POSITIVE.
  int getUserSentiment() => jniAccessors.callMethodWithArgs(
      reference, _id_getUserSentiment, jni.JniType.intType, []).integer;

  static final _id_canShowBadge =
      jniAccessors.getMethodIDOf(_classRef, "canShowBadge", "()Z");

  /// from: public boolean canShowBadge()
  ///
  /// Returns whether this notification can be displayed as a badge.
  ///@return true if the notification can be displayed as a badge, false otherwise.
  bool canShowBadge() => jniAccessors.callMethodWithArgs(
      reference, _id_canShowBadge, jni.JniType.booleanType, []).boolean;

  static final _id_isSuspended =
      jniAccessors.getMethodIDOf(_classRef, "isSuspended", "()Z");

  /// from: public boolean isSuspended()
  ///
  /// Returns whether the app that posted this notification is suspended, so this notification
  /// should be hidden.
  ///@return true if the notification should be hidden, false otherwise.
  bool isSuspended() => jniAccessors.callMethodWithArgs(
      reference, _id_isSuspended, jni.JniType.booleanType, []).boolean;
}
