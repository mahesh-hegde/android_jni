// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../content/Context.dart" as context_;

import "../../os/Handler.dart" as handler_;

import "../../os/Bundle.dart" as bundle_;

import "../../content/Intent.dart" as intent_;

import "../../view/LayoutInflater.dart" as layoutinflater_;

import "../../app/Dialog.dart" as dialog_;

import "../../view/View.dart" as view_;

import "../../app/assist/AssistStructure.dart" as assiststructure_;

import "../../app/assist/AssistContent.dart" as assistcontent_;

import "../../graphics/Bitmap.dart" as bitmap_;

import "../../view/KeyEvent.dart" as keyevent_;

import "../../content/res/Configuration.dart" as configuration_;

import "../../app/VoiceInteractor.dart" as voiceinteractor_;

import "../../graphics/Rect.dart" as rect_;

import "../../graphics/Region.dart" as region_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.service.voice.VoiceInteractionSession
///
/// An active voice interaction session, providing a facility for the implementation
/// to interact with the user in the voice interaction layer.  The user interface is
/// initially shown by default, and can be created be overriding \#onCreateContentView()
/// in which the UI can be built.
///
/// A voice interaction session can be self-contained, ultimately calling \#finish
/// when done.  It can also initiate voice interactions with applications by calling
/// \#startVoiceActivity
///.
class VoiceInteractionSession extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/service/voice/VoiceInteractionSession");
  VoiceInteractionSession.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int SHOW_SOURCE_ACTIVITY
  ///
  /// Flag for use with \#onShow: indicates that an Activity has invoked the voice
  /// interaction service for a local interaction using
  /// Activity\#startLocalVoiceInteraction(Bundle).
  static const SHOW_SOURCE_ACTIVITY = 16;

  /// from: static public final int SHOW_SOURCE_APPLICATION
  ///
  /// Flag for use with \#onShow: indicates that the application itself has invoked
  /// the assistant.
  static const SHOW_SOURCE_APPLICATION = 8;

  /// from: static public final int SHOW_SOURCE_ASSIST_GESTURE
  ///
  /// Flag for use with \#onShow: indicates that the session has been started from the
  /// system assist gesture.
  static const SHOW_SOURCE_ASSIST_GESTURE = 4;

  /// from: static public final int SHOW_WITH_ASSIST
  ///
  /// Flag received in \#onShow: originator requested that the session be started with
  /// assist data from the currently focused activity.
  static const SHOW_WITH_ASSIST = 1;

  /// from: static public final int SHOW_WITH_SCREENSHOT
  ///
  /// Flag received in \#onShow: originator requested that the session be started with
  /// a screen shot of the currently focused activity.
  static const SHOW_WITH_SCREENSHOT = 2;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  VoiceInteractionSession(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;Landroid/os/Handler;)V");

  /// from: public void <init>(android.content.Context context, android.os.Handler handler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  VoiceInteractionSession.ctor1(
      context_.Context context, handler_.Handler handler)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [context.reference, handler.reference]).object);

  static final _id_getContext = jniAccessors.getMethodIDOf(
      _classRef, "getContext", "()Landroid/content/Context;");

  /// from: public android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  context_.Context getContext() =>
      context_.Context.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getContext, jni.JniType.objectType, []).object);

  static final _id_setDisabledShowContext =
      jniAccessors.getMethodIDOf(_classRef, "setDisabledShowContext", "(I)V");

  /// from: public void setDisabledShowContext(int flags)
  ///
  /// Equivalent to VoiceInteractionService\#setDisabledShowContext VoiceInteractionService.setDisabledShowContext(int).
  void setDisabledShowContext(int flags) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDisabledShowContext,
      jni.JniType.voidType,
      [flags]).check();

  static final _id_getDisabledShowContext =
      jniAccessors.getMethodIDOf(_classRef, "getDisabledShowContext", "()I");

  /// from: public int getDisabledShowContext()
  ///
  /// Equivalent to VoiceInteractionService\#getDisabledShowContext VoiceInteractionService.getDisabledShowContext.
  int getDisabledShowContext() => jniAccessors.callMethodWithArgs(
      reference, _id_getDisabledShowContext, jni.JniType.intType, []).integer;

  static final _id_getUserDisabledShowContext = jniAccessors.getMethodIDOf(
      _classRef, "getUserDisabledShowContext", "()I");

  /// from: public int getUserDisabledShowContext()
  ///
  /// Return which show context flags have been disabled by the user through the system
  /// settings UI, so the session will never get this data.  Returned flags are any combination of
  /// VoiceInteractionSession\#SHOW_WITH_ASSIST VoiceInteractionSession.SHOW_WITH_ASSIST and
  /// VoiceInteractionSession\#SHOW_WITH_SCREENSHOT VoiceInteractionSession.SHOW_WITH_SCREENSHOT.  Note that this only tells you about
  /// global user settings, not about restrictions that may be applied contextual based on
  /// the current application the user is in or other transient states.
  int getUserDisabledShowContext() => jniAccessors.callMethodWithArgs(reference,
      _id_getUserDisabledShowContext, jni.JniType.intType, []).integer;

  static final _id_show0 =
      jniAccessors.getMethodIDOf(_classRef, "show", "(Landroid/os/Bundle;I)V");

  /// from: public void show(android.os.Bundle args, int flags)
  ///
  /// Show the UI for this session.  This asks the system to go through the process of showing
  /// your UI, which will eventually culminate in \#onShow.  This is similar to calling
  /// VoiceInteractionService\#showSession VoiceInteractionService.showSession.
  ///@param args Arbitrary arguments that will be propagated \#onShow.
  ///@param flags Indicates additional optional behavior that should be performed.  May
  /// be any combination of
  /// VoiceInteractionSession\#SHOW_WITH_ASSIST VoiceInteractionSession.SHOW_WITH_ASSIST and
  /// VoiceInteractionSession\#SHOW_WITH_SCREENSHOT VoiceInteractionSession.SHOW_WITH_SCREENSHOT
  /// to request that the system generate and deliver assist data on the current foreground
  /// app as part of showing the session UI.
  void show0(bundle_.Bundle args, int flags) => jniAccessors.callMethodWithArgs(
      reference,
      _id_show0,
      jni.JniType.voidType,
      [args.reference, flags]).check();

  static final _id_hide0 = jniAccessors.getMethodIDOf(_classRef, "hide", "()V");

  /// from: public void hide()
  ///
  /// Hide the session's UI, if currently shown.  Call this when you are done with your
  /// user interaction.
  void hide0() => jniAccessors.callMethodWithArgs(
      reference, _id_hide0, jni.JniType.voidType, []).check();

  static final _id_setUiEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setUiEnabled", "(Z)V");

  /// from: public void setUiEnabled(boolean enabled)
  ///
  /// Control whether the UI layer for this session is enabled.  It is enabled by default.
  /// If set to false, you will not be able to provide a UI through \#onCreateContentView().
  void setUiEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference, _id_setUiEnabled, jni.JniType.voidType, [enabled]).check();

  static final _id_setTheme =
      jniAccessors.getMethodIDOf(_classRef, "setTheme", "(I)V");

  /// from: public void setTheme(int theme)
  ///
  /// You can call this to customize the theme used by your IME's window.
  /// This must be set before \#onCreate, so you
  /// will typically call it in your constructor with the resource ID
  /// of your custom theme.
  void setTheme(int theme) => jniAccessors.callMethodWithArgs(
      reference, _id_setTheme, jni.JniType.voidType, [theme]).check();

  static final _id_startVoiceActivity = jniAccessors.getMethodIDOf(
      _classRef, "startVoiceActivity", "(Landroid/content/Intent;)V");

  /// from: public void startVoiceActivity(android.content.Intent intent)
  ///
  /// Ask that a new activity be started for voice interaction.  This will create a
  /// new dedicated task in the activity manager for this voice interaction session;
  /// this means that Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK
  /// will be set for you to make it a new task.
  ///
  /// The newly started activity will be displayed to the user in a special way, as
  /// a layer under the voice interaction UI.
  ///
  ///
  /// As the voice activity runs, it can retrieve a android.app.VoiceInteractor
  /// through which it can perform voice interactions through your session.  These requests
  /// for voice interactions will appear as callbacks on \#onGetSupportedCommands,
  /// \#onRequestConfirmation, \#onRequestPickOption,
  /// \#onRequestCompleteVoice, \#onRequestAbortVoice,
  /// or \#onRequestCommand
  ///
  /// You will receive a call to \#onTaskStarted when the task starts up
  /// and \#onTaskFinished when the last activity has finished.
  ///@param intent The Intent to start this voice interaction.  The given Intent will
  /// always have Intent\#CATEGORY_VOICE Intent.CATEGORY_VOICE added to it, since
  /// this is part of a voice interaction.
  void startVoiceActivity(intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_startVoiceActivity,
          jni.JniType.voidType, [intent.reference]).check();

  static final _id_startAssistantActivity = jniAccessors.getMethodIDOf(
      _classRef, "startAssistantActivity", "(Landroid/content/Intent;)V");

  /// from: public void startAssistantActivity(android.content.Intent intent)
  ///
  /// Ask that a new assistant activity be started.  This will create a new task in the
  /// in activity manager: this means that
  /// Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK
  /// will be set for you to make it a new task.
  ///
  ///
  /// The newly started activity will be displayed on top of other activities in the system
  /// in a new layer that is not affected by multi-window mode.  Tasks started from this activity
  /// will go into the normal activity layer and not this new layer.
  ///
  ///
  /// By default, the system will create a window for the UI for this session.  If you are using
  /// an assistant activity instead, then you can disable the window creation by calling
  /// \#setUiEnabled in \#onPrepareShow(Bundle, int).
  ///
  void startAssistantActivity(intent_.Intent intent) =>
      jniAccessors.callMethodWithArgs(reference, _id_startAssistantActivity,
          jni.JniType.voidType, [intent.reference]).check();

  static final _id_setKeepAwake =
      jniAccessors.getMethodIDOf(_classRef, "setKeepAwake", "(Z)V");

  /// from: public void setKeepAwake(boolean keepAwake)
  ///
  /// Set whether this session will keep the device awake while it is running a voice
  /// activity.  By default, the system holds a wake lock for it while in this state,
  /// so that it can work even if the screen is off.  Setting this to false removes that
  /// wake lock, allowing the CPU to go to sleep.  This is typically used if the
  /// session decides it has been waiting too long for a response from the user and
  /// doesn't want to let this continue to drain the battery.
  ///
  /// Passing false here will release the wake lock, and you can call later with
  /// true to re-acquire it.  It will also be automatically re-acquired for you each
  /// time you start a new voice activity task -- that is when you call
  /// \#startVoiceActivity.
  ///
  void setKeepAwake(bool keepAwake) => jniAccessors.callMethodWithArgs(
      reference, _id_setKeepAwake, jni.JniType.voidType, [keepAwake]).check();

  static final _id_closeSystemDialogs =
      jniAccessors.getMethodIDOf(_classRef, "closeSystemDialogs", "()V");

  /// from: public void closeSystemDialogs()
  ///
  /// Request that all system dialogs (and status bar shade etc) be closed, allowing
  /// access to the session's UI.  This will _not_ cause the lock screen to be
  /// dismissed.
  void closeSystemDialogs() => jniAccessors.callMethodWithArgs(
      reference, _id_closeSystemDialogs, jni.JniType.voidType, []).check();

  static final _id_getLayoutInflater = jniAccessors.getMethodIDOf(
      _classRef, "getLayoutInflater", "()Landroid/view/LayoutInflater;");

  /// from: public android.view.LayoutInflater getLayoutInflater()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for inflating views.
  layoutinflater_.LayoutInflater getLayoutInflater() =>
      layoutinflater_.LayoutInflater.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getLayoutInflater, jni.JniType.objectType, []).object);

  static final _id_getWindow = jniAccessors.getMethodIDOf(
      _classRef, "getWindow", "()Landroid/app/Dialog;");

  /// from: public android.app.Dialog getWindow()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the window being used to show the session's UI.
  dialog_.Dialog getWindow() =>
      dialog_.Dialog.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWindow, jni.JniType.objectType, []).object);

  static final _id_finish =
      jniAccessors.getMethodIDOf(_classRef, "finish", "()V");

  /// from: public void finish()
  ///
  /// Finish the session.  This completely destroys the session -- the next time it is shown,
  /// an entirely new one will be created.  You do not normally call this function; instead,
  /// use \#hide and allow the system to destroy your session if it needs its RAM.
  void finish() => jniAccessors.callMethodWithArgs(
      reference, _id_finish, jni.JniType.voidType, []).check();

  static final _id_onCreate =
      jniAccessors.getMethodIDOf(_classRef, "onCreate", "()V");

  /// from: public void onCreate()
  ///
  /// Initiatize a new session.  At this point you don't know exactly what this
  /// session will be used for; you will find that out in \#onShow.
  void onCreate() => jniAccessors.callMethodWithArgs(
      reference, _id_onCreate, jni.JniType.voidType, []).check();

  static final _id_onPrepareShow = jniAccessors.getMethodIDOf(
      _classRef, "onPrepareShow", "(Landroid/os/Bundle;I)V");

  /// from: public void onPrepareShow(android.os.Bundle args, int showFlags)
  ///
  /// Called prior to \#onShow before any UI setup has occurred.  Not generally useful.
  ///@param args The arguments that were supplied to
  /// VoiceInteractionService\#showSession VoiceInteractionService.showSession.
  ///@param showFlags The show flags originally provided to
  /// VoiceInteractionService\#showSession VoiceInteractionService.showSession.
  void onPrepareShow(bundle_.Bundle args, int showFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPrepareShow,
          jni.JniType.voidType, [args.reference, showFlags]).check();

  static final _id_onShow = jniAccessors.getMethodIDOf(
      _classRef, "onShow", "(Landroid/os/Bundle;I)V");

  /// from: public void onShow(android.os.Bundle args, int showFlags)
  ///
  /// Called when the session UI is going to be shown.  This is called after
  /// \#onCreateContentView (if the session's content UI needed to be created) and
  /// immediately prior to the window being shown.  This may be called while the window
  /// is already shown, if a show request has come in while it is shown, to allow you to
  /// update the UI to match the new show arguments.
  ///@param args The arguments that were supplied to
  /// VoiceInteractionService\#showSession VoiceInteractionService.showSession.
  ///@param showFlags The show flags originally provided to
  /// VoiceInteractionService\#showSession VoiceInteractionService.showSession.
  void onShow(bundle_.Bundle args, int showFlags) =>
      jniAccessors.callMethodWithArgs(reference, _id_onShow,
          jni.JniType.voidType, [args.reference, showFlags]).check();

  static final _id_onHide =
      jniAccessors.getMethodIDOf(_classRef, "onHide", "()V");

  /// from: public void onHide()
  ///
  /// Called immediately after stopping to show the session UI.
  void onHide() => jniAccessors.callMethodWithArgs(
      reference, _id_onHide, jni.JniType.voidType, []).check();

  static final _id_onDestroy =
      jniAccessors.getMethodIDOf(_classRef, "onDestroy", "()V");

  /// from: public void onDestroy()
  ///
  /// Last callback to the session as it is being finished.
  void onDestroy() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroy, jni.JniType.voidType, []).check();

  static final _id_onCreateContentView = jniAccessors.getMethodIDOf(
      _classRef, "onCreateContentView", "()Landroid/view/View;");

  /// from: public android.view.View onCreateContentView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Hook in which to create the session's UI.
  view_.View onCreateContentView() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onCreateContentView, jni.JniType.objectType, []).object);

  static final _id_setContentView = jniAccessors.getMethodIDOf(
      _classRef, "setContentView", "(Landroid/view/View;)V");

  /// from: public void setContentView(android.view.View view)
  void setContentView(view_.View view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setContentView,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_onAssistStructureFailure = jniAccessors.getMethodIDOf(
      _classRef, "onAssistStructureFailure", "(Ljava/lang/Throwable;)V");

  /// from: public void onAssistStructureFailure(java.lang.Throwable failure)
  ///
  /// Called when there has been a failure transferring the AssistStructure to
  /// the assistant.  This may happen, for example, if the data is too large and results
  /// in an out of memory exception, or the client has provided corrupt data.  This will
  /// be called immediately before \#onHandleAssist and the AssistStructure supplied
  /// there afterwards will be null.
  ///@param failure The failure exception that was thrown when building the
  /// AssistStructure.
  void onAssistStructureFailure(jni.JniObject failure) =>
      jniAccessors.callMethodWithArgs(reference, _id_onAssistStructureFailure,
          jni.JniType.voidType, [failure.reference]).check();

  static final _id_onHandleAssist = jniAccessors.getMethodIDOf(
      _classRef,
      "onHandleAssist",
      "(Landroid/os/Bundle;Landroid/app/assist/AssistStructure;Landroid/app/assist/AssistContent;)V");

  /// from: public void onHandleAssist(android.os.Bundle data, android.app.assist.AssistStructure structure, android.app.assist.AssistContent content)
  ///
  /// Called to receive data from the application that the user was currently viewing when
  /// an assist session is started.  If the original show request did not specify
  /// \#SHOW_WITH_ASSIST, this method will not be called.
  ///@param data Arbitrary data supplied by the app through
  /// android.app.Activity\#onProvideAssistData Activity.onProvideAssistData.
  /// May be null if assist data has been disabled by the user or device policy.
  /// This value may be {@code null}.
  ///@param structure If available, the structure definition of all windows currently
  /// displayed by the app.  May be null if assist data has been disabled by the user
  /// or device policy; will be an empty stub if the application has disabled assist
  /// by marking its window as secure.
  /// This value may be {@code null}.
  ///@param content Additional content data supplied by the app through
  /// android.app.Activity\#onProvideAssistContent Activity.onProvideAssistContent.
  /// May be null if assist data has been disabled by the user or device policy; will
  /// not be automatically filled in with data from the app if the app has marked its
  /// window as secure.
  ///
  /// This value may be {@code null}.
  void onHandleAssist(
          bundle_.Bundle data,
          assiststructure_.AssistStructure structure,
          assistcontent_.AssistContent content) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onHandleAssist,
          jni.JniType.voidType,
          [data.reference, structure.reference, content.reference]).check();

  static final _id_onHandleAssistSecondary = jniAccessors.getMethodIDOf(
      _classRef,
      "onHandleAssistSecondary",
      "(Landroid/os/Bundle;Landroid/app/assist/AssistStructure;Landroid/app/assist/AssistContent;II)V");

  /// from: public void onHandleAssistSecondary(android.os.Bundle data, android.app.assist.AssistStructure structure, android.app.assist.AssistContent content, int index, int count)
  ///
  /// Called to receive data from other applications that the user was or is interacting with,
  /// that are currently on the screen in a multi-window display environment, not including the
  /// currently focused activity. This could be
  /// a free-form window, a picture-in-picture window, or another window in a split-screen display.
  ///
  /// This method is very similar to
  /// \#onHandleAssist except that it is called
  /// for additional non-focused activities along with an index and count that indicates
  /// which additional activity the data is for. {@code index} will be between 1 and
  /// {@code count}-1 and this method is called once for each additional window, in no particular
  /// order. The {@code count} indicates how many windows to expect assist data for, including the
  /// top focused activity, which continues to be returned via \#onHandleAssist.
  ///
  /// To be responsive to assist requests, process assist data as soon as it is received,
  /// without waiting for all queued activities to return assist data.
  ///@param data Arbitrary data supplied by the app through
  /// android.app.Activity\#onProvideAssistData Activity.onProvideAssistData.
  /// May be null if assist data has been disabled by the user or device policy.
  /// This value may be {@code null}.
  ///@param structure If available, the structure definition of all windows currently
  /// displayed by the app.  May be null if assist data has been disabled by the user
  /// or device policy; will be an empty stub if the application has disabled assist
  /// by marking its window as secure.
  /// This value may be {@code null}.
  ///@param content Additional content data supplied by the app through
  /// android.app.Activity\#onProvideAssistContent Activity.onProvideAssistContent.
  /// May be null if assist data has been disabled by the user or device policy; will
  /// not be automatically filled in with data from the app if the app has marked its
  /// window as secure.
  /// This value may be {@code null}.
  ///@param index the index of the additional activity that this data
  ///        is for.
  ///@param count the total number of additional activities for which the assist data is being
  ///        returned, including the focused activity that is returned via
  ///        \#onHandleAssist.
  void onHandleAssistSecondary(
          bundle_.Bundle data,
          assiststructure_.AssistStructure structure,
          assistcontent_.AssistContent content,
          int index,
          int count) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onHandleAssistSecondary, jni.JniType.voidType, [
        data.reference,
        structure.reference,
        content.reference,
        index,
        count
      ]).check();

  static final _id_onHandleScreenshot = jniAccessors.getMethodIDOf(
      _classRef, "onHandleScreenshot", "(Landroid/graphics/Bitmap;)V");

  /// from: public void onHandleScreenshot(android.graphics.Bitmap screenshot)
  ///
  /// Called to receive a screenshot of what the user was currently viewing when an assist
  /// session is started.  May be null if screenshots are disabled by the user, policy,
  /// or application.  If the original show request did not specify
  /// \#SHOW_WITH_SCREENSHOT, this method will not be called.
  ///@param screenshot This value may be {@code null}.
  void onHandleScreenshot(bitmap_.Bitmap screenshot) =>
      jniAccessors.callMethodWithArgs(reference, _id_onHandleScreenshot,
          jni.JniType.voidType, [screenshot.reference]).check();

  static final _id_onKeyDown = jniAccessors.getMethodIDOf(
      _classRef, "onKeyDown", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  bool onKeyDown(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyDown,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyLongPress = jniAccessors.getMethodIDOf(
      _classRef, "onKeyLongPress", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyLongPress(int keyCode, android.view.KeyEvent event)
  bool onKeyLongPress(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyLongPress,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyUp = jniAccessors.getMethodIDOf(
      _classRef, "onKeyUp", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyUp(int keyCode, android.view.KeyEvent event)
  bool onKeyUp(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyUp,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyMultiple = jniAccessors.getMethodIDOf(
      _classRef, "onKeyMultiple", "(IILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyMultiple(int keyCode, int count, android.view.KeyEvent event)
  bool onKeyMultiple(int keyCode, int count, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyMultiple,
          jni.JniType.booleanType, [keyCode, count, event.reference]).boolean;

  static final _id_onBackPressed =
      jniAccessors.getMethodIDOf(_classRef, "onBackPressed", "()V");

  /// from: public void onBackPressed()
  ///
  /// Called when the user presses the back button while focus is in the session UI.  Note
  /// that this will only happen if the session UI has requested input focus in its window;
  /// otherwise, the back key will go to whatever window has focus and do whatever behavior
  /// it normally has there.  The default implementation simply calls \#hide.
  void onBackPressed() => jniAccessors.callMethodWithArgs(
      reference, _id_onBackPressed, jni.JniType.voidType, []).check();

  static final _id_onCloseSystemDialogs =
      jniAccessors.getMethodIDOf(_classRef, "onCloseSystemDialogs", "()V");

  /// from: public void onCloseSystemDialogs()
  ///
  /// Sessions automatically watch for requests that all system UI be closed (such as when
  /// the user presses HOME), which will appear here.  The default implementation always
  /// calls \#hide.
  void onCloseSystemDialogs() => jniAccessors.callMethodWithArgs(
      reference, _id_onCloseSystemDialogs, jni.JniType.voidType, []).check();

  static final _id_onLockscreenShown =
      jniAccessors.getMethodIDOf(_classRef, "onLockscreenShown", "()V");

  /// from: public void onLockscreenShown()
  ///
  /// Called when the lockscreen was shown.
  void onLockscreenShown() => jniAccessors.callMethodWithArgs(
      reference, _id_onLockscreenShown, jni.JniType.voidType, []).check();

  static final _id_onConfigurationChanged = jniAccessors.getMethodIDOf(
      _classRef,
      "onConfigurationChanged",
      "(Landroid/content/res/Configuration;)V");

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  void onConfigurationChanged(configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConfigurationChanged,
          jni.JniType.voidType, [newConfig.reference]).check();

  static final _id_onLowMemory =
      jniAccessors.getMethodIDOf(_classRef, "onLowMemory", "()V");

  /// from: public void onLowMemory()
  void onLowMemory() => jniAccessors.callMethodWithArgs(
      reference, _id_onLowMemory, jni.JniType.voidType, []).check();

  static final _id_onTrimMemory =
      jniAccessors.getMethodIDOf(_classRef, "onTrimMemory", "(I)V");

  /// from: public void onTrimMemory(int level)
  void onTrimMemory(int level) => jniAccessors.callMethodWithArgs(
      reference, _id_onTrimMemory, jni.JniType.voidType, [level]).check();

  static final _id_onComputeInsets = jniAccessors.getMethodIDOf(
      _classRef,
      "onComputeInsets",
      "(Landroid/service/voice/VoiceInteractionSession\$Insets;)V");

  /// from: public void onComputeInsets(android.service.voice.VoiceInteractionSession.Insets outInsets)
  ///
  /// Compute the interesting insets into your UI.  The default implementation
  /// sets Insets\#contentInsets outInsets.contentInsets.top to the height
  /// of the window, meaning it should not adjust content underneath.  The default touchable
  /// insets are Insets\#TOUCHABLE_INSETS_FRAME, meaning it consumes all touch
  /// events within its window frame.
  ///@param outInsets Fill in with the current UI insets.
  void onComputeInsets(VoiceInteractionSession_Insets outInsets) =>
      jniAccessors.callMethodWithArgs(reference, _id_onComputeInsets,
          jni.JniType.voidType, [outInsets.reference]).check();

  static final _id_onTaskStarted = jniAccessors.getMethodIDOf(
      _classRef, "onTaskStarted", "(Landroid/content/Intent;I)V");

  /// from: public void onTaskStarted(android.content.Intent intent, int taskId)
  ///
  /// Called when a task initiated by \#startVoiceActivity(android.content.Intent)
  /// has actually started.
  ///@param intent The original Intent supplied to
  /// \#startVoiceActivity(android.content.Intent).
  ///@param taskId Unique ID of the now running task.
  void onTaskStarted(intent_.Intent intent, int taskId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTaskStarted,
          jni.JniType.voidType, [intent.reference, taskId]).check();

  static final _id_onTaskFinished = jniAccessors.getMethodIDOf(
      _classRef, "onTaskFinished", "(Landroid/content/Intent;I)V");

  /// from: public void onTaskFinished(android.content.Intent intent, int taskId)
  ///
  /// Called when the last activity of a task initiated by
  /// \#startVoiceActivity(android.content.Intent) has finished.  The default
  /// implementation calls \#finish() on the assumption that this represents
  /// the completion of a voice action.  You can override the implementation if you would
  /// like a different behavior.
  ///@param intent The original Intent supplied to
  /// \#startVoiceActivity(android.content.Intent).
  ///@param taskId Unique ID of the finished task.
  void onTaskFinished(intent_.Intent intent, int taskId) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTaskFinished,
          jni.JniType.voidType, [intent.reference, taskId]).check();

  static final _id_onGetSupportedCommands = jniAccessors.getMethodIDOf(
      _classRef, "onGetSupportedCommands", "([Ljava/lang/String;)[Z");

  /// from: public boolean[] onGetSupportedCommands(java.lang.String[] commands)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Request to query for what extended commands the session supports.
  ///@param commands An array of commands that are being queried.
  ///@return Return an array of booleans indicating which of each entry in the
  /// command array is supported.  A true entry in the array indicates the command
  /// is supported; false indicates it is not.  The default implementation returns
  /// an array of all false entries.
  jni.JniObject onGetSupportedCommands(jni.JniObject commands) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onGetSupportedCommands,
          jni.JniType.objectType,
          [commands.reference]).object);

  static final _id_onRequestConfirmation = jniAccessors.getMethodIDOf(
      _classRef,
      "onRequestConfirmation",
      "(Landroid/service/voice/VoiceInteractionSession\$ConfirmationRequest;)V");

  /// from: public void onRequestConfirmation(android.service.voice.VoiceInteractionSession.ConfirmationRequest request)
  ///
  /// Request to confirm with the user before proceeding with an unrecoverable operation,
  /// corresponding to a android.app.VoiceInteractor.ConfirmationRequest VoiceInteractor.ConfirmationRequest.
  ///@param request The active request.
  void onRequestConfirmation(
          VoiceInteractionSession_ConfirmationRequest request) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRequestConfirmation,
          jni.JniType.voidType, [request.reference]).check();

  static final _id_onRequestPickOption = jniAccessors.getMethodIDOf(
      _classRef,
      "onRequestPickOption",
      "(Landroid/service/voice/VoiceInteractionSession\$PickOptionRequest;)V");

  /// from: public void onRequestPickOption(android.service.voice.VoiceInteractionSession.PickOptionRequest request)
  ///
  /// Request for the user to pick one of N options, corresponding to a
  /// android.app.VoiceInteractor.PickOptionRequest VoiceInteractor.PickOptionRequest.
  ///@param request The active request.
  void onRequestPickOption(VoiceInteractionSession_PickOptionRequest request) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRequestPickOption,
          jni.JniType.voidType, [request.reference]).check();

  static final _id_onRequestCompleteVoice = jniAccessors.getMethodIDOf(
      _classRef,
      "onRequestCompleteVoice",
      "(Landroid/service/voice/VoiceInteractionSession\$CompleteVoiceRequest;)V");

  /// from: public void onRequestCompleteVoice(android.service.voice.VoiceInteractionSession.CompleteVoiceRequest request)
  ///
  /// Request to complete the voice interaction session because the voice activity successfully
  /// completed its interaction using voice.  Corresponds to
  /// android.app.VoiceInteractor.CompleteVoiceRequest VoiceInteractor.CompleteVoiceRequest.  The default implementation just sends an empty
  /// confirmation back to allow the activity to exit.
  ///@param request The active request.
  void onRequestCompleteVoice(
          VoiceInteractionSession_CompleteVoiceRequest request) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRequestCompleteVoice,
          jni.JniType.voidType, [request.reference]).check();

  static final _id_onRequestAbortVoice = jniAccessors.getMethodIDOf(
      _classRef,
      "onRequestAbortVoice",
      "(Landroid/service/voice/VoiceInteractionSession\$AbortVoiceRequest;)V");

  /// from: public void onRequestAbortVoice(android.service.voice.VoiceInteractionSession.AbortVoiceRequest request)
  ///
  /// Request to abort the voice interaction session because the voice activity can not
  /// complete its interaction using voice.  Corresponds to
  /// android.app.VoiceInteractor.AbortVoiceRequest VoiceInteractor.AbortVoiceRequest.  The default implementation just sends an empty
  /// confirmation back to allow the activity to exit.
  ///@param request The active request.
  void onRequestAbortVoice(VoiceInteractionSession_AbortVoiceRequest request) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRequestAbortVoice,
          jni.JniType.voidType, [request.reference]).check();

  static final _id_onRequestCommand = jniAccessors.getMethodIDOf(
      _classRef,
      "onRequestCommand",
      "(Landroid/service/voice/VoiceInteractionSession\$CommandRequest;)V");

  /// from: public void onRequestCommand(android.service.voice.VoiceInteractionSession.CommandRequest request)
  ///
  /// Process an arbitrary extended command from the caller,
  /// corresponding to a android.app.VoiceInteractor.CommandRequest VoiceInteractor.CommandRequest.
  ///@param request The active request.
  void onRequestCommand(VoiceInteractionSession_CommandRequest request) =>
      jniAccessors.callMethodWithArgs(reference, _id_onRequestCommand,
          jni.JniType.voidType, [request.reference]).check();

  static final _id_onCancelRequest = jniAccessors.getMethodIDOf(
      _classRef,
      "onCancelRequest",
      "(Landroid/service/voice/VoiceInteractionSession\$Request;)V");

  /// from: public void onCancelRequest(android.service.voice.VoiceInteractionSession.Request request)
  ///
  /// Called when the android.app.VoiceInteractor has asked to cancel a Request
  /// that was previously delivered to \#onRequestConfirmation,
  /// \#onRequestPickOption, \#onRequestCompleteVoice, \#onRequestAbortVoice,
  /// or \#onRequestCommand.
  ///@param request The request that is being canceled.
  void onCancelRequest(VoiceInteractionSession_Request request) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCancelRequest,
          jni.JniType.voidType, [request.reference]).check();

  static final _id_dump = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/lang/String;Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: public void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Print the Service's state into the given stream.  This gets invoked by
  /// VoiceInteractionSessionService when its Service
  /// android.app.Service\#dump method is called.
  ///@param prefix Text to print at the front of each line.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer The PrintWriter to which you should dump your state.  This will be
  /// closed for you after you return.
  ///@param args additional arguments to the dump request.
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_dump, jni.JniType.voidType, [
        prefix.reference,
        fd.reference,
        writer.reference,
        args.reference
      ]).check();
}

/// from: android.service.voice.VoiceInteractionSession$Request
///
/// Base class representing a request from a voice-driver app to perform a particular
/// voice operation with the user.  See related subclasses for the types of requests
/// that are possible.
class VoiceInteractionSession_Request extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/service/voice/VoiceInteractionSession\$Request");
  VoiceInteractionSession_Request.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  VoiceInteractionSession_Request()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getCallingUid =
      jniAccessors.getMethodIDOf(_classRef, "getCallingUid", "()I");

  /// from: public int getCallingUid()
  ///
  /// Return the uid of the application that initiated the request.
  int getCallingUid() => jniAccessors.callMethodWithArgs(
      reference, _id_getCallingUid, jni.JniType.intType, []).integer;

  static final _id_getCallingPackage = jniAccessors.getMethodIDOf(
      _classRef, "getCallingPackage", "()Ljava/lang/String;");

  /// from: public java.lang.String getCallingPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the package name of the application that initiated the request.
  jni.JniString getCallingPackage() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCallingPackage, jni.JniType.objectType, []).object);

  static final _id_getExtras = jniAccessors.getMethodIDOf(
      _classRef, "getExtras", "()Landroid/os/Bundle;");

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return any additional extra information that was supplied as part of the request.
  bundle_.Bundle getExtras() =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtras, jni.JniType.objectType, []).object);

  static final _id_isActive =
      jniAccessors.getMethodIDOf(_classRef, "isActive", "()Z");

  /// from: public boolean isActive()
  ///
  /// Check whether this request is currently active.  A request becomes inactive after
  /// calling \#cancel or a final result method that completes the request.  After
  /// this point, further interactions with the request will result in
  /// java.lang.IllegalStateException errors; you should not catch these errors,
  /// but can use this method if you need to determine the state of the request.  Returns
  /// true if the request is still active.
  bool isActive() => jniAccessors.callMethodWithArgs(
      reference, _id_isActive, jni.JniType.booleanType, []).boolean;

  static final _id_cancel =
      jniAccessors.getMethodIDOf(_classRef, "cancel", "()V");

  /// from: public void cancel()
  ///
  /// Ask the app to cancel this current request.
  /// This also finishes the request (it is no longer active).
  void cancel() => jniAccessors.callMethodWithArgs(
      reference, _id_cancel, jni.JniType.voidType, []).check();

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);
}

/// from: android.service.voice.VoiceInteractionSession$PickOptionRequest
///
/// A request for the user to pick from a set of option, as per
/// android.app.VoiceInteractor.PickOptionRequest VoiceInteractor.PickOptionRequest.
class VoiceInteractionSession_PickOptionRequest
    extends VoiceInteractionSession_Request {
  static final _classRef = jniAccessors.getClassOf(
      "android/service/voice/VoiceInteractionSession\$PickOptionRequest");
  VoiceInteractionSession_PickOptionRequest.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  VoiceInteractionSession_PickOptionRequest()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getVoicePrompt = jniAccessors.getMethodIDOf(
      _classRef, "getVoicePrompt", "()Landroid/app/VoiceInteractor\$Prompt;");

  /// from: public android.app.VoiceInteractor.Prompt getVoicePrompt()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the prompt informing the user of what they are picking, as per
  /// android.app.VoiceInteractor.PickOptionRequest VoiceInteractor.PickOptionRequest.
  ///@return This value may be {@code null}.
  voiceinteractor_.VoiceInteractor_Prompt getVoicePrompt() =>
      voiceinteractor_.VoiceInteractor_Prompt.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getVoicePrompt,
              jni.JniType.objectType, []).object);

  static final _id_getPrompt = jniAccessors.getMethodIDOf(
      _classRef, "getPrompt", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getPrompt()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the prompt informing the user of what they are picking, as per
  /// android.app.VoiceInteractor.PickOptionRequest VoiceInteractor.PickOptionRequest.
  ///@deprecated Prefer \#getVoicePrompt() which allows multiple voice prompts.
  ///@return This value may be {@code null}.
  jni.JniObject getPrompt() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPrompt, jni.JniType.objectType, []).object);

  static final _id_getOptions = jniAccessors.getMethodIDOf(
      _classRef,
      "getOptions",
      "()[Landroid/app/VoiceInteractor\$PickOptionRequest\$Option;");

  /// from: public android.app.VoiceInteractor.PickOptionRequest.Option[] getOptions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the set of options the user is picking from, as per
  /// android.app.VoiceInteractor.PickOptionRequest VoiceInteractor.PickOptionRequest.
  jni.JniObject getOptions() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getOptions, jni.JniType.objectType, []).object);

  static final _id_sendIntermediatePickOptionResult = jniAccessors.getMethodIDOf(
      _classRef,
      "sendIntermediatePickOptionResult",
      "([Landroid/app/VoiceInteractor\$PickOptionRequest\$Option;Landroid/os/Bundle;)V");

  /// from: public void sendIntermediatePickOptionResult(android.app.VoiceInteractor.PickOptionRequest.Option[] selections, android.os.Bundle result)
  ///
  /// Report an intermediate option selection from the request, without completing it (the
  /// request is still active and the app is waiting for the final option selection),
  /// resulting in a call to
  /// android.app.VoiceInteractor.PickOptionRequest\#onPickOptionResult VoiceInteractor.PickOptionRequest.onPickOptionResult with false for finished.
  void sendIntermediatePickOptionResult(
          jni.JniObject selections, bundle_.Bundle result) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_sendIntermediatePickOptionResult,
          jni.JniType.voidType,
          [selections.reference, result.reference]).check();

  static final _id_sendPickOptionResult = jniAccessors.getMethodIDOf(
      _classRef,
      "sendPickOptionResult",
      "([Landroid/app/VoiceInteractor\$PickOptionRequest\$Option;Landroid/os/Bundle;)V");

  /// from: public void sendPickOptionResult(android.app.VoiceInteractor.PickOptionRequest.Option[] selections, android.os.Bundle result)
  ///
  /// Report the final option selection for the request, completing the request
  /// and resulting in a call to
  /// android.app.VoiceInteractor.PickOptionRequest\#onPickOptionResult VoiceInteractor.PickOptionRequest.onPickOptionResult with false for finished.
  /// This finishes the request (it is no longer active).
  void sendPickOptionResult(jni.JniObject selections, bundle_.Bundle result) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_sendPickOptionResult,
          jni.JniType.voidType,
          [selections.reference, result.reference]).check();
}

/// from: android.service.voice.VoiceInteractionSession$Insets
///
/// Information about where interesting parts of the input method UI appear.
class VoiceInteractionSession_Insets extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/service/voice/VoiceInteractionSession\$Insets");
  VoiceInteractionSession_Insets.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int TOUCHABLE_INSETS_CONTENT
  ///
  /// Option for \#touchableInsets: the area inside of
  /// the content insets can be touched.
  static const TOUCHABLE_INSETS_CONTENT = 1;

  /// from: static public final int TOUCHABLE_INSETS_FRAME
  ///
  /// Option for \#touchableInsets: the entire window frame
  /// can be touched.
  static const TOUCHABLE_INSETS_FRAME = 0;

  /// from: static public final int TOUCHABLE_INSETS_REGION
  ///
  /// Option for \#touchableInsets: the region specified by
  /// \#touchableRegion can be touched.
  static const TOUCHABLE_INSETS_REGION = 3;

  static final _id_contentInsets = jniAccessors.getFieldIDOf(
      _classRef, "contentInsets", "Landroid/graphics/Rect;");

  /// from: public final android.graphics.Rect contentInsets
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This is the part of the UI that is the main content.  It is
  /// used to determine the basic space needed, to resize/pan the
  /// application behind.  It is assumed that this inset does not
  /// change very much, since any change will cause a full resize/pan
  /// of the application behind.  This value is relative to the top edge
  /// of the input method window.
  rect_.Rect get contentInsets => rect_.Rect.fromRef(jniAccessors
      .getField(reference, _id_contentInsets, jni.JniType.objectType)
      .object);

  static final _id_touchableInsets =
      jniAccessors.getFieldIDOf(_classRef, "touchableInsets", "I");

  /// from: public int touchableInsets
  ///
  /// Determine which area of the window is touchable by the user.  May
  /// be one of: \#TOUCHABLE_INSETS_FRAME,
  /// \#TOUCHABLE_INSETS_CONTENT, or \#TOUCHABLE_INSETS_REGION.
  int get touchableInsets => jniAccessors
      .getField(reference, _id_touchableInsets, jni.JniType.intType)
      .integer;

  /// from: public int touchableInsets
  ///
  /// Determine which area of the window is touchable by the user.  May
  /// be one of: \#TOUCHABLE_INSETS_FRAME,
  /// \#TOUCHABLE_INSETS_CONTENT, or \#TOUCHABLE_INSETS_REGION.
  set touchableInsets(int value) =>
      jniEnv.SetIntField(reference, _id_touchableInsets, value);

  static final _id_touchableRegion = jniAccessors.getFieldIDOf(
      _classRef, "touchableRegion", "Landroid/graphics/Region;");

  /// from: public final android.graphics.Region touchableRegion
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This is the region of the UI that is touchable.  It is used when
  /// \#touchableInsets is set to \#TOUCHABLE_INSETS_REGION.
  /// The region should be specified relative to the origin of the window frame.
  region_.Region get touchableRegion => region_.Region.fromRef(jniAccessors
      .getField(reference, _id_touchableRegion, jni.JniType.objectType)
      .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  VoiceInteractionSession_Insets()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.service.voice.VoiceInteractionSession$ConfirmationRequest
///
/// A request for confirmation from the user of an operation, as per
/// android.app.VoiceInteractor.ConfirmationRequest VoiceInteractor.ConfirmationRequest.
class VoiceInteractionSession_ConfirmationRequest
    extends VoiceInteractionSession_Request {
  static final _classRef = jniAccessors.getClassOf(
      "android/service/voice/VoiceInteractionSession\$ConfirmationRequest");
  VoiceInteractionSession_ConfirmationRequest.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  VoiceInteractionSession_ConfirmationRequest()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getVoicePrompt = jniAccessors.getMethodIDOf(
      _classRef, "getVoicePrompt", "()Landroid/app/VoiceInteractor\$Prompt;");

  /// from: public android.app.VoiceInteractor.Prompt getVoicePrompt()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the prompt informing the user of what will happen, as per
  /// android.app.VoiceInteractor.ConfirmationRequest VoiceInteractor.ConfirmationRequest.
  ///@return This value may be {@code null}.
  voiceinteractor_.VoiceInteractor_Prompt getVoicePrompt() =>
      voiceinteractor_.VoiceInteractor_Prompt.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getVoicePrompt,
              jni.JniType.objectType, []).object);

  static final _id_getPrompt = jniAccessors.getMethodIDOf(
      _classRef, "getPrompt", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getPrompt()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the prompt informing the user of what will happen, as per
  /// android.app.VoiceInteractor.ConfirmationRequest VoiceInteractor.ConfirmationRequest.
  ///@deprecated Prefer \#getVoicePrompt() which allows multiple voice prompts.
  ///@return This value may be {@code null}.
  jni.JniObject getPrompt() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPrompt, jni.JniType.objectType, []).object);

  static final _id_sendConfirmationResult = jniAccessors.getMethodIDOf(
      _classRef, "sendConfirmationResult", "(ZLandroid/os/Bundle;)V");

  /// from: public void sendConfirmationResult(boolean confirmed, android.os.Bundle result)
  ///
  /// Report that the voice interactor has confirmed the operation with the user, resulting
  /// in a call to
  /// android.app.VoiceInteractor.ConfirmationRequest\#onConfirmationResult VoiceInteractor.ConfirmationRequest.onConfirmationResult.
  /// This finishes the request (it is no longer active).
  void sendConfirmationResult(bool confirmed, bundle_.Bundle result) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendConfirmationResult,
          jni.JniType.voidType, [confirmed, result.reference]).check();
}

/// from: android.service.voice.VoiceInteractionSession$CompleteVoiceRequest
///
/// A request to simply inform the user that the voice operation has completed, as per
/// android.app.VoiceInteractor.CompleteVoiceRequest VoiceInteractor.CompleteVoiceRequest.
class VoiceInteractionSession_CompleteVoiceRequest
    extends VoiceInteractionSession_Request {
  static final _classRef = jniAccessors.getClassOf(
      "android/service/voice/VoiceInteractionSession\$CompleteVoiceRequest");
  VoiceInteractionSession_CompleteVoiceRequest.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  VoiceInteractionSession_CompleteVoiceRequest()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getVoicePrompt = jniAccessors.getMethodIDOf(
      _classRef, "getVoicePrompt", "()Landroid/app/VoiceInteractor\$Prompt;");

  /// from: public android.app.VoiceInteractor.Prompt getVoicePrompt()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the message informing the user of the completion, as per
  /// android.app.VoiceInteractor.CompleteVoiceRequest VoiceInteractor.CompleteVoiceRequest.
  ///@return This value may be {@code null}.
  voiceinteractor_.VoiceInteractor_Prompt getVoicePrompt() =>
      voiceinteractor_.VoiceInteractor_Prompt.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getVoicePrompt,
              jni.JniType.objectType, []).object);

  static final _id_getMessage = jniAccessors.getMethodIDOf(
      _classRef, "getMessage", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getMessage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the message informing the user of the completion, as per
  /// android.app.VoiceInteractor.CompleteVoiceRequest VoiceInteractor.CompleteVoiceRequest.
  ///@deprecated Prefer \#getVoicePrompt() which allows a separate visual message.
  ///@return This value may be {@code null}.
  jni.JniObject getMessage() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMessage, jni.JniType.objectType, []).object);

  static final _id_sendCompleteResult = jniAccessors.getMethodIDOf(
      _classRef, "sendCompleteResult", "(Landroid/os/Bundle;)V");

  /// from: public void sendCompleteResult(android.os.Bundle result)
  ///
  /// Report that the voice interactor has finished completing the voice operation, resulting
  /// in a call to
  /// android.app.VoiceInteractor.CompleteVoiceRequest\#onCompleteResult VoiceInteractor.CompleteVoiceRequest.onCompleteResult.
  /// This finishes the request (it is no longer active).
  void sendCompleteResult(bundle_.Bundle result) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendCompleteResult,
          jni.JniType.voidType, [result.reference]).check();
}

/// from: android.service.voice.VoiceInteractionSession$CommandRequest
///
/// A generic vendor-specific request, as per
/// android.app.VoiceInteractor.CommandRequest VoiceInteractor.CommandRequest.
class VoiceInteractionSession_CommandRequest
    extends VoiceInteractionSession_Request {
  static final _classRef = jniAccessors.getClassOf(
      "android/service/voice/VoiceInteractionSession\$CommandRequest");
  VoiceInteractionSession_CommandRequest.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  VoiceInteractionSession_CommandRequest()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getCommand = jniAccessors.getMethodIDOf(
      _classRef, "getCommand", "()Ljava/lang/String;");

  /// from: public java.lang.String getCommand()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the command that is being executed, as per
  /// android.app.VoiceInteractor.CommandRequest VoiceInteractor.CommandRequest.
  jni.JniString getCommand() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCommand, jni.JniType.objectType, []).object);

  static final _id_sendIntermediateResult = jniAccessors.getMethodIDOf(
      _classRef, "sendIntermediateResult", "(Landroid/os/Bundle;)V");

  /// from: public void sendIntermediateResult(android.os.Bundle result)
  ///
  /// Report an intermediate result of the request, without completing it (the request
  /// is still active and the app is waiting for the final result), resulting in a call to
  /// android.app.VoiceInteractor.CommandRequest\#onCommandResult VoiceInteractor.CommandRequest.onCommandResult with false for isCompleted.
  void sendIntermediateResult(bundle_.Bundle result) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendIntermediateResult,
          jni.JniType.voidType, [result.reference]).check();

  static final _id_sendResult = jniAccessors.getMethodIDOf(
      _classRef, "sendResult", "(Landroid/os/Bundle;)V");

  /// from: public void sendResult(android.os.Bundle result)
  ///
  /// Report the final result of the request, completing the request and resulting in a call to
  /// android.app.VoiceInteractor.CommandRequest\#onCommandResult VoiceInteractor.CommandRequest.onCommandResult with true for isCompleted.
  /// This finishes the request (it is no longer active).
  void sendResult(bundle_.Bundle result) => jniAccessors.callMethodWithArgs(
      reference,
      _id_sendResult,
      jni.JniType.voidType,
      [result.reference]).check();
}

/// from: android.service.voice.VoiceInteractionSession$AbortVoiceRequest
///
/// A request to report that the current user interaction can not be completed with voice, as per
/// android.app.VoiceInteractor.AbortVoiceRequest VoiceInteractor.AbortVoiceRequest.
class VoiceInteractionSession_AbortVoiceRequest
    extends VoiceInteractionSession_Request {
  static final _classRef = jniAccessors.getClassOf(
      "android/service/voice/VoiceInteractionSession\$AbortVoiceRequest");
  VoiceInteractionSession_AbortVoiceRequest.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  VoiceInteractionSession_AbortVoiceRequest()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getVoicePrompt = jniAccessors.getMethodIDOf(
      _classRef, "getVoicePrompt", "()Landroid/app/VoiceInteractor\$Prompt;");

  /// from: public android.app.VoiceInteractor.Prompt getVoicePrompt()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the message informing the user of the problem, as per
  /// android.app.VoiceInteractor.AbortVoiceRequest VoiceInteractor.AbortVoiceRequest.
  ///@return This value may be {@code null}.
  voiceinteractor_.VoiceInteractor_Prompt getVoicePrompt() =>
      voiceinteractor_.VoiceInteractor_Prompt.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getVoicePrompt,
              jni.JniType.objectType, []).object);

  static final _id_getMessage = jniAccessors.getMethodIDOf(
      _classRef, "getMessage", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getMessage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the message informing the user of the problem, as per
  /// android.app.VoiceInteractor.AbortVoiceRequest VoiceInteractor.AbortVoiceRequest.
  ///@deprecated Prefer \#getVoicePrompt() which allows a separate visual message.
  ///@return This value may be {@code null}.
  jni.JniObject getMessage() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getMessage, jni.JniType.objectType, []).object);

  static final _id_sendAbortResult = jniAccessors.getMethodIDOf(
      _classRef, "sendAbortResult", "(Landroid/os/Bundle;)V");

  /// from: public void sendAbortResult(android.os.Bundle result)
  ///
  /// Report that the voice interactor has finished aborting the voice operation, resulting
  /// in a call to
  /// android.app.VoiceInteractor.AbortVoiceRequest\#onAbortResult VoiceInteractor.AbortVoiceRequest.onAbortResult.  This finishes the request (it
  /// is no longer active).
  void sendAbortResult(bundle_.Bundle result) =>
      jniAccessors.callMethodWithArgs(reference, _id_sendAbortResult,
          jni.JniType.voidType, [result.reference]).check();
}
