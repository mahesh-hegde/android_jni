// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../app/Service.dart" as service_;

import "../../content/Context.dart" as context_;

import "../../content/ComponentName.dart" as componentname_;

import "../../os/Bundle.dart" as bundle_;

import "../../os/IBinder.dart" as ibinder_;

import "../../content/Intent.dart" as intent_;

import "AlwaysOnHotwordDetector.dart" as alwaysonhotworddetector_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.service.voice.VoiceInteractionService
///
/// Top-level service of the current global voice interactor, which is providing
/// support for hotwording, the back-end of a android.app.VoiceInteractor, etc.
/// The current VoiceInteractionService that has been selected by the user is kept
/// always running by the system, to allow it to do things like listen for hotwords
/// in the background to instigate voice interactions.
///
/// Because this service is always running, it should be kept as lightweight as
/// possible.  Heavy-weight operations (including showing UI) should be implemented
/// in the associated android.service.voice.VoiceInteractionSessionService when
/// an actual voice interaction is taking place, and that service should run in a
/// separate process from this one.
class VoiceInteractionService extends service_.Service {
  static final _classRef =
      jniAccessors.getClassOf("android/service/voice/VoiceInteractionService");
  VoiceInteractionService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String SERVICE_INTERFACE
  ///
  /// The Intent that must be declared as handled by the service.
  /// To be supported, the service must also require the
  /// android.Manifest.permission\#BIND_VOICE_INTERACTION permission so
  /// that other applications can not abuse it.
  static const SERVICE_INTERFACE =
      "android.service.voice.VoiceInteractionService";

  /// from: static public final java.lang.String SERVICE_META_DATA
  ///
  /// Name under which a VoiceInteractionService component publishes information about itself.
  /// This meta-data should reference an XML resource containing a
  /// <code>&lt;android.R.styleable\#VoiceInteractionService voice-interaction-service&gt;</code> tag.
  static const SERVICE_META_DATA = "android.voice_interaction";

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  VoiceInteractionService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_onLaunchVoiceAssistFromKeyguard = jniAccessors.getMethodIDOf(
      _classRef, "onLaunchVoiceAssistFromKeyguard", "()V");

  /// from: public void onLaunchVoiceAssistFromKeyguard()
  ///
  /// Called when a user has activated an affordance to launch voice assist from the Keyguard.
  ///
  /// This method will only be called if the VoiceInteractionService has set
  /// android.R.attr\#supportsLaunchVoiceAssistFromKeyguard and the Keyguard is showing.
  ///
  ///
  /// A valid implementation must start a new activity that should use android.view.WindowManager.LayoutParams\#FLAG_SHOW_WHEN_LOCKED to display
  /// on top of the lock screen.
  ///
  void onLaunchVoiceAssistFromKeyguard() => jniAccessors.callMethodWithArgs(
      reference,
      _id_onLaunchVoiceAssistFromKeyguard,
      jni.JniType.voidType, []).check();

  static final _id_isActiveService = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "isActiveService",
      "(Landroid/content/Context;Landroid/content/ComponentName;)Z");

  /// from: static public boolean isActiveService(android.content.Context context, android.content.ComponentName service)
  ///
  /// Check whether the given service component is the currently active
  /// VoiceInteractionService.
  static bool isActiveService(
          context_.Context context, componentname_.ComponentName service) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_isActiveService,
          jni.JniType.booleanType,
          [context.reference, service.reference]).boolean;

  static final _id_setDisabledShowContext =
      jniAccessors.getMethodIDOf(_classRef, "setDisabledShowContext", "(I)V");

  /// from: public void setDisabledShowContext(int flags)
  ///
  /// Set contextual options you would always like to have disabled when a session
  /// is shown.  The flags may be any combination of
  /// VoiceInteractionSession\#SHOW_WITH_ASSIST VoiceInteractionSession.SHOW_WITH_ASSIST and
  /// VoiceInteractionSession\#SHOW_WITH_SCREENSHOT VoiceInteractionSession.SHOW_WITH_SCREENSHOT.
  void setDisabledShowContext(int flags) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDisabledShowContext,
      jni.JniType.voidType,
      [flags]).check();

  static final _id_getDisabledShowContext =
      jniAccessors.getMethodIDOf(_classRef, "getDisabledShowContext", "()I");

  /// from: public int getDisabledShowContext()
  ///
  /// Return the value set by \#setDisabledShowContext.
  int getDisabledShowContext() => jniAccessors.callMethodWithArgs(
      reference, _id_getDisabledShowContext, jni.JniType.intType, []).integer;

  static final _id_showSession = jniAccessors.getMethodIDOf(
      _classRef, "showSession", "(Landroid/os/Bundle;I)V");

  /// from: public void showSession(android.os.Bundle args, int flags)
  ///
  /// Request that the associated android.service.voice.VoiceInteractionSession be
  /// shown to the user, starting it if necessary.
  ///@param args Arbitrary arguments that will be propagated to the session.
  ///@param flags Indicates additional optional behavior that should be performed.  May
  /// be any combination of
  /// VoiceInteractionSession\#SHOW_WITH_ASSIST VoiceInteractionSession.SHOW_WITH_ASSIST and
  /// VoiceInteractionSession\#SHOW_WITH_SCREENSHOT VoiceInteractionSession.SHOW_WITH_SCREENSHOT
  /// to request that the system generate and deliver assist data on the current foreground
  /// app as part of showing the session UI.
  void showSession(bundle_.Bundle args, int flags) =>
      jniAccessors.callMethodWithArgs(reference, _id_showSession,
          jni.JniType.voidType, [args.reference, flags]).check();

  static final _id_onCreate =
      jniAccessors.getMethodIDOf(_classRef, "onCreate", "()V");

  /// from: public void onCreate()
  void onCreate() => jniAccessors.callMethodWithArgs(
      reference, _id_onCreate, jni.JniType.voidType, []).check();

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);

  static final _id_onReady =
      jniAccessors.getMethodIDOf(_classRef, "onReady", "()V");

  /// from: public void onReady()
  ///
  /// Called during service initialization to tell you when the system is ready
  /// to receive interaction from it. You should generally do initialization here
  /// rather than in \#onCreate. Methods such as \#showSession and
  /// \#createAlwaysOnHotwordDetector
  /// will not be operational until this point.
  void onReady() => jniAccessors.callMethodWithArgs(
      reference, _id_onReady, jni.JniType.voidType, []).check();

  static final _id_onShutdown =
      jniAccessors.getMethodIDOf(_classRef, "onShutdown", "()V");

  /// from: public void onShutdown()
  ///
  /// Called during service de-initialization to tell you when the system is shutting the
  /// service down.
  /// At this point this service may no longer be the active VoiceInteractionService.
  void onShutdown() => jniAccessors.callMethodWithArgs(
      reference, _id_onShutdown, jni.JniType.voidType, []).check();

  static final _id_createAlwaysOnHotwordDetector = jniAccessors.getMethodIDOf(
      _classRef,
      "createAlwaysOnHotwordDetector",
      "(Ljava/lang/String;Ljava/util/Locale;Landroid/service/voice/AlwaysOnHotwordDetector\$Callback;)Landroid/service/voice/AlwaysOnHotwordDetector;");

  /// from: public final android.service.voice.AlwaysOnHotwordDetector createAlwaysOnHotwordDetector(java.lang.String keyphrase, java.util.Locale locale, android.service.voice.AlwaysOnHotwordDetector.Callback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an AlwaysOnHotwordDetector for the given keyphrase and locale.
  /// This instance must be retained and used by the client.
  /// Calling this a second time invalidates the previously created hotword detector
  /// which can no longer be used to manage recognition.
  ///@param keyphrase The keyphrase that's being used, for example "Hello Android".
  ///@param locale The locale for which the enrollment needs to be performed.
  ///@param callback The callback to notify of detection events.
  ///@return An always-on hotword detector for the given keyphrase and locale.
  alwaysonhotworddetector_
      .AlwaysOnHotwordDetector createAlwaysOnHotwordDetector(
          jni.JniString keyphrase,
          jni.JniObject locale,
          alwaysonhotworddetector_.AlwaysOnHotwordDetector_Callback callback) =>
      alwaysonhotworddetector_.AlwaysOnHotwordDetector.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_createAlwaysOnHotwordDetector,
              jni.JniType.objectType, [
        keyphrase.reference,
        locale.reference,
        callback.reference
      ]).object);

  static final _id_dump = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: protected void dump(java.io.FileDescriptor fd, java.io.PrintWriter pw, java.lang.String[] args)
  void dump(jni.JniObject fd, jni.JniObject pw, jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(reference, _id_dump, jni.JniType.voidType,
          [fd.reference, pw.reference, args.reference]).check();
}
