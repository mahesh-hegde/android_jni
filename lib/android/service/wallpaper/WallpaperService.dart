// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../../app/Service.dart" as service_;

import "../../os/IBinder.dart" as ibinder_;

import "../../content/Intent.dart" as intent_;

import "../../view/SurfaceHolder.dart" as surfaceholder_;

import "../../view/WindowInsets.dart" as windowinsets_;

import "../../view/MotionEvent.dart" as motionevent_;

import "../../os/Bundle.dart" as bundle_;

import "../../app/WallpaperColors.dart" as wallpapercolors_;
import "../../../_init.dart" show jniEnv, jniAccessors;

/// from: android.service.wallpaper.WallpaperService
///
/// A wallpaper service is responsible for showing a live wallpaper behind
/// applications that would like to sit on top of it.  This service object
/// itself does very little -- its only purpose is to generate instances of
/// Engine as needed.  Implementing a wallpaper thus
/// involves subclassing from this, subclassing an Engine implementation,
/// and implementing \#onCreateEngine() to return a new instance of
/// your engine.
class WallpaperService extends service_.Service {
  static final _classRef =
      jniAccessors.getClassOf("android/service/wallpaper/WallpaperService");
  WallpaperService.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final java.lang.String SERVICE_INTERFACE
  ///
  /// The Intent that must be declared as handled by the service.
  /// To be supported, the service must also require the
  /// android.Manifest.permission\#BIND_WALLPAPER permission so
  /// that other applications can not abuse it.
  static const SERVICE_INTERFACE = "android.service.wallpaper.WallpaperService";

  /// from: static public final java.lang.String SERVICE_META_DATA
  ///
  /// Name under which a WallpaperService component publishes information
  /// about itself.  This meta-data must reference an XML resource containing
  /// a <code>&lt;android.R.styleable\#Wallpaper wallpaper&gt;</code>
  /// tag.
  static const SERVICE_META_DATA = "android.service.wallpaper";

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WallpaperService.ctor2()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_onCreate =
      jniAccessors.getMethodIDOf(_classRef, "onCreate", "()V");

  /// from: public void onCreate()
  void onCreate() => jniAccessors.callMethodWithArgs(
      reference, _id_onCreate, jni.JniType.voidType, []).check();

  static final _id_onDestroy =
      jniAccessors.getMethodIDOf(_classRef, "onDestroy", "()V");

  /// from: public void onDestroy()
  void onDestroy() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroy, jni.JniType.voidType, []).check();

  static final _id_onBind = jniAccessors.getMethodIDOf(
      _classRef, "onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;");

  /// from: public final android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement to return the implementation of the internal accessibility
  /// service interface.  Subclasses should not override.
  ibinder_.IBinder onBind(intent_.Intent intent) =>
      ibinder_.IBinder.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_onBind, jni.JniType.objectType, [intent.reference]).object);

  static final _id_onCreateEngine = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateEngine",
      "()Landroid/service/wallpaper/WallpaperService\$Engine;");

  /// from: public abstract android.service.wallpaper.WallpaperService.Engine onCreateEngine()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Must be implemented to return a new instance of the wallpaper's engine.
  /// Note that multiple instances may be active at the same time, such as
  /// when the wallpaper is currently set as the active wallpaper and the user
  /// is in the wallpaper picker viewing a preview of it as well.
  WallpaperService_Engine onCreateEngine() =>
      WallpaperService_Engine.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onCreateEngine, jni.JniType.objectType, []).object);

  static final _id_dump = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: protected void dump(java.io.FileDescriptor fd, java.io.PrintWriter out, java.lang.String[] args)
  void dump(jni.JniObject fd, jni.JniObject out, jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(reference, _id_dump, jni.JniType.voidType,
          [fd.reference, out.reference, args.reference]).check();
}

/// from: android.service.wallpaper.WallpaperService$Engine
///
/// The actual implementation of a wallpaper.  A wallpaper service may
/// have multiple instances running (for example as a real wallpaper
/// and as a preview), each of which is represented by its own Engine
/// instance.  You must implement WallpaperService\#onCreateEngine()
/// to return your concrete Engine implementation.
class WallpaperService_Engine extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/service/wallpaper/WallpaperService\$Engine");
  WallpaperService_Engine.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Default constructor
  WallpaperService_Engine()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getSurfaceHolder = jniAccessors.getMethodIDOf(
      _classRef, "getSurfaceHolder", "()Landroid/view/SurfaceHolder;");

  /// from: public android.view.SurfaceHolder getSurfaceHolder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provides access to the surface in which this wallpaper is drawn.
  surfaceholder_.SurfaceHolder getSurfaceHolder() =>
      surfaceholder_.SurfaceHolder.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSurfaceHolder, jni.JniType.objectType, []).object);

  static final _id_getDesiredMinimumWidth =
      jniAccessors.getMethodIDOf(_classRef, "getDesiredMinimumWidth", "()I");

  /// from: public int getDesiredMinimumWidth()
  ///
  /// Convenience for WallpaperManager\#getDesiredMinimumWidth() WallpaperManager.getDesiredMinimumWidth(), returning the width
  /// that the system would like this wallpaper to run in.
  int getDesiredMinimumWidth() => jniAccessors.callMethodWithArgs(
      reference, _id_getDesiredMinimumWidth, jni.JniType.intType, []).integer;

  static final _id_getDesiredMinimumHeight =
      jniAccessors.getMethodIDOf(_classRef, "getDesiredMinimumHeight", "()I");

  /// from: public int getDesiredMinimumHeight()
  ///
  /// Convenience for WallpaperManager\#getDesiredMinimumHeight() WallpaperManager.getDesiredMinimumHeight(), returning the height
  /// that the system would like this wallpaper to run in.
  int getDesiredMinimumHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getDesiredMinimumHeight, jni.JniType.intType, []).integer;

  static final _id_isVisible =
      jniAccessors.getMethodIDOf(_classRef, "isVisible", "()Z");

  /// from: public boolean isVisible()
  ///
  /// Return whether the wallpaper is currently visible to the user,
  /// this is the last value supplied to
  /// \#onVisibilityChanged(boolean).
  bool isVisible() => jniAccessors.callMethodWithArgs(
      reference, _id_isVisible, jni.JniType.booleanType, []).boolean;

  static final _id_isPreview =
      jniAccessors.getMethodIDOf(_classRef, "isPreview", "()Z");

  /// from: public boolean isPreview()
  ///
  /// Returns true if this engine is running in preview mode -- that is,
  /// it is being shown to the user before they select it as the actual
  /// wallpaper.
  bool isPreview() => jniAccessors.callMethodWithArgs(
      reference, _id_isPreview, jni.JniType.booleanType, []).boolean;

  static final _id_setTouchEventsEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setTouchEventsEnabled", "(Z)V");

  /// from: public void setTouchEventsEnabled(boolean enabled)
  ///
  /// Control whether this wallpaper will receive raw touch events
  /// from the window manager as the user interacts with the window
  /// that is currently displaying the wallpaper.  By default they
  /// are turned off.  If enabled, the events will be received in
  /// \#onTouchEvent(MotionEvent).
  void setTouchEventsEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setTouchEventsEnabled,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_setOffsetNotificationsEnabled = jniAccessors.getMethodIDOf(
      _classRef, "setOffsetNotificationsEnabled", "(Z)V");

  /// from: public void setOffsetNotificationsEnabled(boolean enabled)
  ///
  /// Control whether this wallpaper will receive notifications when the wallpaper
  /// has been scrolled. By default, wallpapers will receive notifications, although
  /// the default static image wallpapers do not. It is a performance optimization to
  /// set this to false.
  ///@param enabled whether the wallpaper wants to receive offset notifications
  void setOffsetNotificationsEnabled(bool enabled) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setOffsetNotificationsEnabled,
          jni.JniType.voidType,
          [enabled]).check();

  static final _id_onCreate = jniAccessors.getMethodIDOf(
      _classRef, "onCreate", "(Landroid/view/SurfaceHolder;)V");

  /// from: public void onCreate(android.view.SurfaceHolder surfaceHolder)
  ///
  /// Called once to initialize the engine.  After returning, the
  /// engine's surface will be created by the framework.
  void onCreate(surfaceholder_.SurfaceHolder surfaceHolder) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCreate,
          jni.JniType.voidType, [surfaceHolder.reference]).check();

  static final _id_onDestroy =
      jniAccessors.getMethodIDOf(_classRef, "onDestroy", "()V");

  /// from: public void onDestroy()
  ///
  /// Called right before the engine is going away.  After this the
  /// surface will be destroyed and this Engine object is no longer
  /// valid.
  void onDestroy() => jniAccessors.callMethodWithArgs(
      reference, _id_onDestroy, jni.JniType.voidType, []).check();

  static final _id_onVisibilityChanged =
      jniAccessors.getMethodIDOf(_classRef, "onVisibilityChanged", "(Z)V");

  /// from: public void onVisibilityChanged(boolean visible)
  ///
  /// Called to inform you of the wallpaper becoming visible or
  /// hidden.  _It is very important that a wallpaper only use
  /// CPU while it is visible._.
  void onVisibilityChanged(bool visible) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onVisibilityChanged,
      jni.JniType.voidType,
      [visible]).check();

  static final _id_onApplyWindowInsets = jniAccessors.getMethodIDOf(
      _classRef, "onApplyWindowInsets", "(Landroid/view/WindowInsets;)V");

  /// from: public void onApplyWindowInsets(android.view.WindowInsets insets)
  ///
  /// Called with the current insets that are in effect for the wallpaper.
  /// This gives you the part of the overall wallpaper surface that will
  /// generally be visible to the user (ignoring position offsets applied to it).
  ///@param insets Insets to apply.
  void onApplyWindowInsets(windowinsets_.WindowInsets insets) =>
      jniAccessors.callMethodWithArgs(reference, _id_onApplyWindowInsets,
          jni.JniType.voidType, [insets.reference]).check();

  static final _id_onTouchEvent = jniAccessors.getMethodIDOf(
      _classRef, "onTouchEvent", "(Landroid/view/MotionEvent;)V");

  /// from: public void onTouchEvent(android.view.MotionEvent event)
  ///
  /// Called as the user performs touch-screen interaction with the
  /// window that is currently showing this wallpaper.  Note that the
  /// events you receive here are driven by the actual application the
  /// user is interacting with, so if it is slow you will get fewer
  /// move events.
  void onTouchEvent(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouchEvent,
          jni.JniType.voidType, [event.reference]).check();

  static final _id_onOffsetsChanged =
      jniAccessors.getMethodIDOf(_classRef, "onOffsetsChanged", "(FFFFII)V");

  /// from: public void onOffsetsChanged(float xOffset, float yOffset, float xOffsetStep, float yOffsetStep, int xPixelOffset, int yPixelOffset)
  ///
  /// Called to inform you of the wallpaper's offsets changing
  /// within its contain, corresponding to the container's
  /// call to WallpaperManager\#setWallpaperOffsets(IBinder, float, float) WallpaperManager.setWallpaperOffsets().
  void onOffsetsChanged(double xOffset, double yOffset, double xOffsetStep,
          double yOffsetStep, int xPixelOffset, int yPixelOffset) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onOffsetsChanged, jni.JniType.voidType, [
        xOffset,
        yOffset,
        xOffsetStep,
        yOffsetStep,
        xPixelOffset,
        yPixelOffset
      ]).check();

  static final _id_onCommand = jniAccessors.getMethodIDOf(
      _classRef,
      "onCommand",
      "(Ljava/lang/String;IIILandroid/os/Bundle;Z)Landroid/os/Bundle;");

  /// from: public android.os.Bundle onCommand(java.lang.String action, int x, int y, int z, android.os.Bundle extras, boolean resultRequested)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Process a command that was sent to the wallpaper with
  /// WallpaperManager\#sendWallpaperCommand.
  /// The default implementation does nothing, and always returns null
  /// as the result.
  ///@param action The name of the command to perform.  This tells you
  /// what to do and how to interpret the rest of the arguments.
  ///@param x Generic integer parameter.
  ///@param y Generic integer parameter.
  ///@param z Generic integer parameter.
  ///@param extras Any additional parameters.
  ///@param resultRequested If true, the caller is requesting that
  /// a result, appropriate for the command, be returned back.
  ///@return If returning a result, create a Bundle and place the
  /// result data in to it.  Otherwise return null.
  bundle_.Bundle onCommand(jni.JniString action, int x, int y, int z,
          bundle_.Bundle extras, bool resultRequested) =>
      bundle_.Bundle.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onCommand, jni.JniType.objectType, [
        action.reference,
        x,
        y,
        z,
        extras.reference,
        resultRequested
      ]).object);

  static final _id_onDesiredSizeChanged =
      jniAccessors.getMethodIDOf(_classRef, "onDesiredSizeChanged", "(II)V");

  /// from: public void onDesiredSizeChanged(int desiredWidth, int desiredHeight)
  ///
  /// Called when an application has changed the desired virtual size of
  /// the wallpaper.
  void onDesiredSizeChanged(int desiredWidth, int desiredHeight) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDesiredSizeChanged,
          jni.JniType.voidType, [desiredWidth, desiredHeight]).check();

  static final _id_onSurfaceChanged = jniAccessors.getMethodIDOf(
      _classRef, "onSurfaceChanged", "(Landroid/view/SurfaceHolder;III)V");

  /// from: public void onSurfaceChanged(android.view.SurfaceHolder holder, int format, int width, int height)
  ///
  /// Convenience for SurfaceHolder.Callback\#surfaceChanged SurfaceHolder.Callback.surfaceChanged().
  void onSurfaceChanged(surfaceholder_.SurfaceHolder holder, int format,
          int width, int height) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onSurfaceChanged,
          jni.JniType.voidType,
          [holder.reference, format, width, height]).check();

  static final _id_onSurfaceRedrawNeeded = jniAccessors.getMethodIDOf(
      _classRef, "onSurfaceRedrawNeeded", "(Landroid/view/SurfaceHolder;)V");

  /// from: public void onSurfaceRedrawNeeded(android.view.SurfaceHolder holder)
  ///
  /// Convenience for SurfaceHolder.Callback2\#surfaceRedrawNeeded SurfaceHolder.Callback.surfaceRedrawNeeded().
  void onSurfaceRedrawNeeded(surfaceholder_.SurfaceHolder holder) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSurfaceRedrawNeeded,
          jni.JniType.voidType, [holder.reference]).check();

  static final _id_onSurfaceCreated = jniAccessors.getMethodIDOf(
      _classRef, "onSurfaceCreated", "(Landroid/view/SurfaceHolder;)V");

  /// from: public void onSurfaceCreated(android.view.SurfaceHolder holder)
  ///
  /// Convenience for SurfaceHolder.Callback\#surfaceCreated SurfaceHolder.Callback.surfaceCreated().
  void onSurfaceCreated(surfaceholder_.SurfaceHolder holder) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSurfaceCreated,
          jni.JniType.voidType, [holder.reference]).check();

  static final _id_onSurfaceDestroyed = jniAccessors.getMethodIDOf(
      _classRef, "onSurfaceDestroyed", "(Landroid/view/SurfaceHolder;)V");

  /// from: public void onSurfaceDestroyed(android.view.SurfaceHolder holder)
  ///
  /// Convenience for SurfaceHolder.Callback\#surfaceDestroyed SurfaceHolder.Callback.surfaceDestroyed().
  void onSurfaceDestroyed(surfaceholder_.SurfaceHolder holder) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSurfaceDestroyed,
          jni.JniType.voidType, [holder.reference]).check();

  static final _id_notifyColorsChanged =
      jniAccessors.getMethodIDOf(_classRef, "notifyColorsChanged", "()V");

  /// from: public void notifyColorsChanged()
  ///
  /// Notifies the engine that wallpaper colors changed significantly.
  /// This will trigger a \#onComputeColors() call.
  void notifyColorsChanged() => jniAccessors.callMethodWithArgs(
      reference, _id_notifyColorsChanged, jni.JniType.voidType, []).check();

  static final _id_onComputeColors = jniAccessors.getMethodIDOf(
      _classRef, "onComputeColors", "()Landroid/app/WallpaperColors;");

  /// from: public android.app.WallpaperColors onComputeColors()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by the system when it needs to know what colors the wallpaper is using.
  /// You might return null if no color information is available at the moment.
  /// In that case you might want to call \#notifyColorsChanged() when
  /// color information becomes available.
  ///
  /// The simplest way of creating a android.app.WallpaperColors object is by using
  /// android.app.WallpaperColors\#fromBitmap(Bitmap) or
  /// android.app.WallpaperColors\#fromDrawable(Drawable), but you can also specify
  /// your main colors by constructing a android.app.WallpaperColors object manually.
  ///@return Wallpaper colors.
  wallpapercolors_.WallpaperColors onComputeColors() =>
      wallpapercolors_.WallpaperColors.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_onComputeColors, jni.JniType.objectType, []).object);

  static final _id_dump = jniAccessors.getMethodIDOf(_classRef, "dump",
      "(Ljava/lang/String;Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V");

  /// from: protected void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter out, java.lang.String[] args)
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject out,
          jni.JniObject args) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_dump, jni.JniType.voidType, [
        prefix.reference,
        fd.reference,
        out.reference,
        args.reference
      ]).check();
}
