// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../widget/AbsoluteLayout.dart" as absolutelayout_;

import "../content/Context.dart" as context_;

import "../util/AttributeSet.dart" as attributeset_;

import "../net/http/SslCertificate.dart" as sslcertificate_;

import "WebBackForwardList.dart" as webbackforwardlist_;

import "../os/Bundle.dart" as bundle_;

import "ValueCallback.dart" as valuecallback_;

import "../graphics/Picture.dart" as picture_;

import "../print/PrintDocumentAdapter.dart" as printdocumentadapter_;

import "../os/Message.dart" as message_;

import "../graphics/Bitmap.dart" as bitmap_;

import "../net/Uri.dart" as uri_;

import "WebViewClient.dart" as webviewclient_;

import "DownloadListener.dart" as downloadlistener_;

import "WebChromeClient.dart" as webchromeclient_;

import "WebMessage.dart" as webmessage_;

import "WebSettings.dart" as websettings_;

import "../view/View.dart" as view_;

import "../view/textclassifier/TextClassifier.dart" as textclassifier_;

import "../os/Looper.dart" as looper_;

import "../view/ViewGroup.dart" as viewgroup_;

import "../view/MotionEvent.dart" as motionevent_;

import "../view/KeyEvent.dart" as keyevent_;

import "../view/accessibility/AccessibilityNodeProvider.dart"
    as accessibilitynodeprovider_;

import "../view/ViewStructure.dart" as viewstructure_;

import "../util/SparseArray.dart" as sparsearray_;

import "../graphics/Canvas.dart" as canvas_;

import "../content/res/Configuration.dart" as configuration_;

import "../view/inputmethod/InputConnection.dart" as inputconnection_;

import "../view/inputmethod/EditorInfo.dart" as editorinfo_;

import "../view/DragEvent.dart" as dragevent_;

import "../graphics/Rect.dart" as rect_;

import "../graphics/Paint.dart" as paint_;

import "../os/Handler.dart" as handler_;

import "../content/pm/PackageInfo.dart" as packageinfo_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.webkit.WebView
///
/// A View that displays web pages.
///
/// <h3>Basic usage</h3>
///
///
/// In most cases, we recommend using a standard web browser, like Chrome, to deliver
/// content to the user. To learn more about web browsers, read the guide on
/// <a href="/guide/components/intents-common\#Browser">
/// invoking a browser with an intent</a>.
///
/// WebView objects allow you to display web content as part of your activity layout, but
/// lack some of the features of fully-developed browsers. A WebView is useful when
/// you need increased control over the UI and advanced configuration options that will allow
/// you to embed web pages in a specially-designed environment for your app.
///
/// To learn more about WebView and alternatives for serving web content, read the
/// documentation on
/// <a href="/guide/webapps/">
/// Web-based content</a>.
class WebView extends absolutelayout_.AbsoluteLayout {
  static final _classRef = jniAccessors.getClassOf("android/webkit/WebView");
  WebView.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int RENDERER_PRIORITY_BOUND
  ///
  /// The renderer associated with this WebView is bound with
  /// the default priority for services.
  ///
  /// Use with \#setRendererPriorityPolicy.
  static const RENDERER_PRIORITY_BOUND = 1;

  /// from: static public final int RENDERER_PRIORITY_IMPORTANT
  ///
  /// The renderer associated with this WebView is bound with
  /// Context\#BIND_IMPORTANT.
  ///
  /// Use with \#setRendererPriorityPolicy.
  static const RENDERER_PRIORITY_IMPORTANT = 2;

  /// from: static public final int RENDERER_PRIORITY_WAIVED
  ///
  /// The renderer associated with this WebView is bound with
  /// Context\#BIND_WAIVE_PRIORITY. At this priority level
  /// WebView renderers will be strong targets for out of memory
  /// killing.
  ///
  /// Use with \#setRendererPriorityPolicy.
  static const RENDERER_PRIORITY_WAIVED = 0;

  /// from: static public final java.lang.String SCHEME_GEO
  ///
  /// URI scheme for map address.
  static const SCHEME_GEO = "geo:0,0?q=";

  /// from: static public final java.lang.String SCHEME_MAILTO
  ///
  /// URI scheme for email address.
  static const SCHEME_MAILTO = "mailto:";

  /// from: static public final java.lang.String SCHEME_TEL
  ///
  /// URI scheme for telephone number.
  static const SCHEME_TEL = "tel:";

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/content/Context;)V");

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new WebView with an Activity Context object.
  ///
  /// <p class="note">__Note:__ WebView should always be instantiated with an Activity Context.
  /// If instantiated with an Application Context, WebView will be unable to provide several
  /// features, such as JavaScript dialogs and autofill.
  ///@param context an Activity Context to access application assets
  WebView(context_.Context context)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor, [context.reference]).object);

  static final _id_ctor1 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new WebView with layout parameters.
  ///@param context an Activity Context to access application assets
  ///@param attrs an AttributeSet passed to our parent
  WebView.ctor1(context_.Context context, attributeset_.AttributeSet attrs)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor1, [context.reference, attrs.reference]).object);

  static final _id_ctor2 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;I)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new WebView with layout parameters and a default style.
  ///@param context an Activity Context to access application assets
  ///@param attrs an AttributeSet passed to our parent
  ///@param defStyleAttr an attribute in the current theme that contains a
  ///        reference to a style resource that supplies default values for
  ///        the view. Can be 0 to not look for defaults.
  WebView.ctor2(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor2,
            [context.reference, attrs.reference, defStyleAttr]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;II)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new WebView with layout parameters and a default style.
  ///@param context an Activity Context to access application assets
  ///@param attrs an AttributeSet passed to our parent
  ///@param defStyleAttr an attribute in the current theme that contains a
  ///        reference to a style resource that supplies default values for
  ///        the view. Can be 0 to not look for defaults.
  ///@param defStyleRes a resource identifier of a style resource that
  ///        supplies default values for the view, used only if
  ///        defStyleAttr is 0 or can not be found in the theme. Can be 0
  ///        to not look for defaults.
  WebView.ctor3(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          defStyleRes
        ]).object);

  static final _id_ctor4 = jniAccessors.getMethodIDOf(_classRef, "<init>",
      "(Landroid/content/Context;Landroid/util/AttributeSet;IZ)V");

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, boolean privateBrowsing)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs a new WebView with layout parameters and a default style.
  ///@param context an Activity Context to access application assets
  ///@param attrs an AttributeSet passed to our parent
  ///@param defStyleAttr an attribute in the current theme that contains a
  ///        reference to a style resource that supplies default values for
  ///        the view. Can be 0 to not look for defaults.
  ///@param privateBrowsing whether this WebView will be initialized in
  ///                        private mode
  ///@deprecated Private browsing is no longer supported directly via
  /// WebView and will be removed in a future release. Prefer using
  /// WebSettings, WebViewDatabase, CookieManager
  /// and WebStorage for fine-grained control of privacy data.
  WebView.ctor4(context_.Context context, attributeset_.AttributeSet attrs,
      int defStyleAttr, bool privateBrowsing)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor4, [
          context.reference,
          attrs.reference,
          defStyleAttr,
          privateBrowsing
        ]).object);

  static final _id_setHorizontalScrollbarOverlay = jniAccessors.getMethodIDOf(
      _classRef, "setHorizontalScrollbarOverlay", "(Z)V");

  /// from: public void setHorizontalScrollbarOverlay(boolean overlay)
  ///
  /// Specifies whether the horizontal scrollbar has overlay style.
  ///@deprecated This method has no effect.
  ///@param overlay {@code true} if horizontal scrollbar should have overlay style
  void setHorizontalScrollbarOverlay(bool overlay) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setHorizontalScrollbarOverlay,
          jni.JniType.voidType,
          [overlay]).check();

  static final _id_setVerticalScrollbarOverlay = jniAccessors.getMethodIDOf(
      _classRef, "setVerticalScrollbarOverlay", "(Z)V");

  /// from: public void setVerticalScrollbarOverlay(boolean overlay)
  ///
  /// Specifies whether the vertical scrollbar has overlay style.
  ///@deprecated This method has no effect.
  ///@param overlay {@code true} if vertical scrollbar should have overlay style
  void setVerticalScrollbarOverlay(bool overlay) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setVerticalScrollbarOverlay,
          jni.JniType.voidType,
          [overlay]).check();

  static final _id_overlayHorizontalScrollbar = jniAccessors.getMethodIDOf(
      _classRef, "overlayHorizontalScrollbar", "()Z");

  /// from: public boolean overlayHorizontalScrollbar()
  ///
  /// Gets whether horizontal scrollbar has overlay style.
  ///@deprecated This method is now obsolete.
  ///@return {@code true}
  bool overlayHorizontalScrollbar() => jniAccessors.callMethodWithArgs(
      reference,
      _id_overlayHorizontalScrollbar,
      jni.JniType.booleanType, []).boolean;

  static final _id_overlayVerticalScrollbar =
      jniAccessors.getMethodIDOf(_classRef, "overlayVerticalScrollbar", "()Z");

  /// from: public boolean overlayVerticalScrollbar()
  ///
  /// Gets whether vertical scrollbar has overlay style.
  ///@deprecated This method is now obsolete.
  ///@return {@code false}
  bool overlayVerticalScrollbar() => jniAccessors.callMethodWithArgs(reference,
      _id_overlayVerticalScrollbar, jni.JniType.booleanType, []).boolean;

  static final _id_getCertificate = jniAccessors.getMethodIDOf(
      _classRef, "getCertificate", "()Landroid/net/http/SslCertificate;");

  /// from: public android.net.http.SslCertificate getCertificate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the SSL certificate for the main top-level page or {@code null} if there is
  /// no certificate (the site is not secure).
  ///@return the SSL certificate for the main top-level page
  sslcertificate_.SslCertificate getCertificate() =>
      sslcertificate_.SslCertificate.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getCertificate, jni.JniType.objectType, []).object);

  static final _id_setCertificate = jniAccessors.getMethodIDOf(
      _classRef, "setCertificate", "(Landroid/net/http/SslCertificate;)V");

  /// from: public void setCertificate(android.net.http.SslCertificate certificate)
  ///
  /// Sets the SSL certificate for the main top-level page.
  ///@deprecated Calling this function has no useful effect, and will be
  /// ignored in future releases.
  void setCertificate(sslcertificate_.SslCertificate certificate) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCertificate,
          jni.JniType.voidType, [certificate.reference]).check();

  static final _id_savePassword = jniAccessors.getMethodIDOf(
      _classRef,
      "savePassword",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void savePassword(java.lang.String host, java.lang.String username, java.lang.String password)
  ///
  /// Sets a username and password pair for the specified host. This data is
  /// used by the WebView to autocomplete username and password fields in web
  /// forms. Note that this is unrelated to the credentials used for HTTP
  /// authentication.
  ///@param host the host that required the credentials
  ///@param username the username for the given host
  ///@param password the password for the given host
  ///@see WebViewDatabase\#clearUsernamePassword
  ///@see WebViewDatabase\#hasUsernamePassword
  ///@deprecated Saving passwords in WebView will not be supported in future versions.
  void savePassword(
          jni.JniString host, jni.JniString username, jni.JniString password) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_savePassword,
          jni.JniType.voidType,
          [host.reference, username.reference, password.reference]).check();

  static final _id_setHttpAuthUsernamePassword = jniAccessors.getMethodIDOf(
      _classRef,
      "setHttpAuthUsernamePassword",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void setHttpAuthUsernamePassword(java.lang.String host, java.lang.String realm, java.lang.String username, java.lang.String password)
  ///
  /// Stores HTTP authentication credentials for a given host and realm to the WebViewDatabase
  /// instance.
  ///@param host the host to which the credentials apply
  ///@param realm the realm to which the credentials apply
  ///@param username the username
  ///@param password the password
  ///@deprecated Use WebViewDatabase\#setHttpAuthUsernamePassword instead
  void setHttpAuthUsernamePassword(jni.JniString host, jni.JniString realm,
          jni.JniString username, jni.JniString password) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_setHttpAuthUsernamePassword, jni.JniType.voidType, [
        host.reference,
        realm.reference,
        username.reference,
        password.reference
      ]).check();

  static final _id_getHttpAuthUsernamePassword = jniAccessors.getMethodIDOf(
      _classRef,
      "getHttpAuthUsernamePassword",
      "(Ljava/lang/String;Ljava/lang/String;)[Ljava/lang/String;");

  /// from: public java.lang.String[] getHttpAuthUsernamePassword(java.lang.String host, java.lang.String realm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves HTTP authentication credentials for a given host and realm from the WebViewDatabase instance.
  ///@param host the host to which the credentials apply
  ///@param realm the realm to which the credentials apply
  ///@return the credentials as a String array, if found. The first element
  ///         is the username and the second element is the password. {@code null} if
  ///         no credentials are found.
  ///@deprecated Use WebViewDatabase\#getHttpAuthUsernamePassword instead
  jni.JniObject getHttpAuthUsernamePassword(
          jni.JniString host, jni.JniString realm) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getHttpAuthUsernamePassword,
          jni.JniType.objectType,
          [host.reference, realm.reference]).object);

  static final _id_destroy =
      jniAccessors.getMethodIDOf(_classRef, "destroy", "()V");

  /// from: public void destroy()
  ///
  /// Destroys the internal state of this WebView. This method should be called
  /// after this WebView has been removed from the view system. No other
  /// methods may be called on this WebView after destroy.
  void destroy() => jniAccessors.callMethodWithArgs(
      reference, _id_destroy, jni.JniType.voidType, []).check();

  static final _id_setNetworkAvailable =
      jniAccessors.getMethodIDOf(_classRef, "setNetworkAvailable", "(Z)V");

  /// from: public void setNetworkAvailable(boolean networkUp)
  ///
  /// Informs WebView of the network state. This is used to set
  /// the JavaScript property window.navigator.isOnline and
  /// generates the online/offline event as specified in HTML5, sec. 5.7.7
  ///@param networkUp a boolean indicating if network is available
  void setNetworkAvailable(bool networkUp) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setNetworkAvailable,
      jni.JniType.voidType,
      [networkUp]).check();

  static final _id_saveState = jniAccessors.getMethodIDOf(_classRef,
      "saveState", "(Landroid/os/Bundle;)Landroid/webkit/WebBackForwardList;");

  /// from: public android.webkit.WebBackForwardList saveState(android.os.Bundle outState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Saves the state of this WebView used in
  /// android.app.Activity\#onSaveInstanceState. Please note that this
  /// method no longer stores the display data for this WebView. The previous
  /// behavior could potentially leak files if \#restoreState was never
  /// called.
  ///@param outState the Bundle to store this WebView's state
  ///@return the same copy of the back/forward list used to save the state, {@code null} if the
  ///         method fails.
  webbackforwardlist_.WebBackForwardList saveState(bundle_.Bundle outState) =>
      webbackforwardlist_.WebBackForwardList.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_saveState, jni.JniType.objectType,
              [outState.reference]).object);

  static final _id_restoreState = jniAccessors.getMethodIDOf(
      _classRef,
      "restoreState",
      "(Landroid/os/Bundle;)Landroid/webkit/WebBackForwardList;");

  /// from: public android.webkit.WebBackForwardList restoreState(android.os.Bundle inState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Restores the state of this WebView from the given Bundle. This method is
  /// intended for use in android.app.Activity\#onRestoreInstanceState
  /// and should be called to restore the state of this WebView. If
  /// it is called after this WebView has had a chance to build state (load
  /// pages, create a back/forward list, etc.) there may be undesirable
  /// side-effects. Please note that this method no longer restores the
  /// display data for this WebView.
  ///@param inState the incoming Bundle of state
  ///@return the restored back/forward list or {@code null} if restoreState failed
  webbackforwardlist_.WebBackForwardList restoreState(bundle_.Bundle inState) =>
      webbackforwardlist_.WebBackForwardList.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_restoreState,
              jni.JniType.objectType, [inState.reference]).object);

  static final _id_loadUrl = jniAccessors.getMethodIDOf(
      _classRef, "loadUrl", "(Ljava/lang/String;Ljava/util/Map;)V");

  /// from: public void loadUrl(java.lang.String url, java.util.Map<java.lang.String,java.lang.String> additionalHttpHeaders)
  ///
  /// Loads the given URL with the specified additional HTTP headers.
  ///
  /// Also see compatibility note on \#evaluateJavascript.
  ///@param url the URL of the resource to load
  ///@param additionalHttpHeaders the additional headers to be used in the
  ///            HTTP request for this URL, specified as a map from name to
  ///            value. Note that if this map contains any of the headers
  ///            that are set by default by this WebView, such as those
  ///            controlling caching, accept types or the User-Agent, their
  ///            values may be overridden by this WebView's defaults.
  void loadUrl(jni.JniString url, jni.JniObject additionalHttpHeaders) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_loadUrl,
          jni.JniType.voidType,
          [url.reference, additionalHttpHeaders.reference]).check();

  static final _id_loadUrl1 =
      jniAccessors.getMethodIDOf(_classRef, "loadUrl", "(Ljava/lang/String;)V");

  /// from: public void loadUrl(java.lang.String url)
  ///
  /// Loads the given URL.
  ///
  /// Also see compatibility note on \#evaluateJavascript.
  ///@param url the URL of the resource to load
  void loadUrl1(jni.JniString url) => jniAccessors.callMethodWithArgs(
      reference, _id_loadUrl1, jni.JniType.voidType, [url.reference]).check();

  static final _id_postUrl = jniAccessors.getMethodIDOf(
      _classRef, "postUrl", "(Ljava/lang/String;[B)V");

  /// from: public void postUrl(java.lang.String url, byte[] postData)
  ///
  /// Loads the URL with postData using "POST" method into this WebView. If url
  /// is not a network URL, it will be loaded with \#loadUrl(String)
  /// instead, ignoring the postData param.
  ///@param url the URL of the resource to load
  ///@param postData the data will be passed to "POST" request, which must be
  ///     be "application/x-www-form-urlencoded" encoded.
  void postUrl(jni.JniString url, jni.JniObject postData) =>
      jniAccessors.callMethodWithArgs(reference, _id_postUrl,
          jni.JniType.voidType, [url.reference, postData.reference]).check();

  static final _id_loadData = jniAccessors.getMethodIDOf(_classRef, "loadData",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void loadData(java.lang.String data, java.lang.String mimeType, java.lang.String encoding)
  ///
  /// Loads the given data into this WebView using a 'data' scheme URL.
  ///
  /// Note that JavaScript's same origin policy means that script running in a
  /// page loaded using this method will be unable to access content loaded
  /// using any scheme other than 'data', including 'http(s)'. To avoid this
  /// restriction, use \#loadDataWithBaseURL(String,String,String,String,String) loadDataWithBaseURL() with an appropriate base URL.
  ///
  /// The {@code encoding} parameter specifies whether the data is base64 or URL
  /// encoded. If the data is base64 encoded, the value of the encoding
  /// parameter must be 'base64'. HTML can be encoded with android.util.Base64\#encodeToString(byte[],int) like so:
  /// <pre>
  /// String unencodedHtml =
  ///     "&lt;html&gt;&lt;body&gt;'%28' is the code for '('&lt;/body&gt;&lt;/html&gt;";
  /// String encodedHtml = Base64.encodeToString(unencodedHtml.getBytes(), Base64.NO_PADDING);
  /// webView.loadData(encodedHtml, "text/html", "base64");
  /// </pre>
  ///
  /// For all other values of {@code encoding} (including {@code null}) it is assumed that the
  /// data uses ASCII encoding for octets inside the range of safe URL characters and use the
  /// standard %xx hex encoding of URLs for octets outside that range. See <a href="https://tools.ietf.org/html/rfc3986\#section-2.2">RFC 3986</a> for more information.
  ///
  /// The {@code mimeType} parameter specifies the format of the data.
  /// If WebView can't handle the specified MIME type, it will download the data.
  /// If {@code null}, defaults to 'text/html'.
  ///
  /// The 'data' scheme URL formed by this method uses the default US-ASCII
  /// charset. If you need to set a different charset, you should form a
  /// 'data' scheme URL which explicitly specifies a charset parameter in the
  /// mediatype portion of the URL and call \#loadUrl(String) instead.
  /// Note that the charset obtained from the mediatype portion of a data URL
  /// always overrides that specified in the HTML or XML document itself.
  ///
  /// Content loaded using this method will have a {@code window.origin} value
  /// of {@code "null"}. This must not be considered to be a trusted origin
  /// by the application or by any JavaScript code running inside the WebView
  /// (for example, event sources in DOM event handlers or web messages),
  /// because malicious content can also create frames with a null origin. If
  /// you need to identify the main frame's origin in a trustworthy way, you
  /// should use \#loadDataWithBaseURL(String,String,String,String,String) loadDataWithBaseURL() with a valid HTTP or HTTPS base URL to set the
  /// origin.
  ///@param data a String of data in the given encoding
  ///@param mimeType the MIME type of the data, e.g. 'text/html'.
  /// This value may be {@code null}.
  ///@param encoding the encoding of the data
  ///
  /// This value may be {@code null}.
  void loadData(
          jni.JniString data, jni.JniString mimeType, jni.JniString encoding) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_loadData,
          jni.JniType.voidType,
          [data.reference, mimeType.reference, encoding.reference]).check();

  static final _id_loadDataWithBaseURL = jniAccessors.getMethodIDOf(
      _classRef,
      "loadDataWithBaseURL",
      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void loadDataWithBaseURL(java.lang.String baseUrl, java.lang.String data, java.lang.String mimeType, java.lang.String encoding, java.lang.String historyUrl)
  ///
  /// Loads the given data into this WebView, using baseUrl as the base URL for
  /// the content. The base URL is used both to resolve relative URLs and when
  /// applying JavaScript's same origin policy. The historyUrl is used for the
  /// history entry.
  ///
  /// The {@code mimeType} parameter specifies the format of the data.
  /// If WebView can't handle the specified MIME type, it will download the data.
  /// If {@code null}, defaults to 'text/html'.
  ///
  /// Note that content specified in this way can access local device files
  /// (via 'file' scheme URLs) only if baseUrl specifies a scheme other than
  /// 'http', 'https', 'ftp', 'ftps', 'about' or 'javascript'.
  ///
  /// If the base URL uses the data scheme, this method is equivalent to
  /// calling \#loadData(String,String,String) loadData() and the
  /// historyUrl is ignored, and the data will be treated as part of a data: URL.
  /// If the base URL uses any other scheme, then the data will be loaded into
  /// the WebView as a plain string (i.e. not part of a data URL) and any URL-encoded
  /// entities in the string will not be decoded.
  ///
  /// Note that the baseUrl is sent in the 'Referer' HTTP header when
  /// requesting subresources (images, etc.) of the page loaded using this method.
  ///
  /// If a valid HTTP or HTTPS base URL is not specified in {@code baseUrl}, then
  /// content loaded using this method will have a {@code window.origin} value
  /// of {@code "null"}. This must not be considered to be a trusted origin
  /// by the application or by any JavaScript code running inside the WebView
  /// (for example, event sources in DOM event handlers or web messages),
  /// because malicious content can also create frames with a null origin. If
  /// you need to identify the main frame's origin in a trustworthy way, you
  /// should use a valid HTTP or HTTPS base URL to set the origin.
  ///@param baseUrl the URL to use as the page's base URL. If {@code null} defaults to
  ///                'about:blank'.
  /// This value may be {@code null}.
  ///@param data a String of data in the given encoding
  ///@param mimeType the MIME type of the data, e.g. 'text/html'.
  /// This value may be {@code null}.
  ///@param encoding the encoding of the data
  /// This value may be {@code null}.
  ///@param historyUrl the URL to use as the history entry. If {@code null} defaults
  ///                   to 'about:blank'. If non-null, this must be a valid URL.
  ///
  /// This value may be {@code null}.
  void loadDataWithBaseURL(
          jni.JniString baseUrl,
          jni.JniString data,
          jni.JniString mimeType,
          jni.JniString encoding,
          jni.JniString historyUrl) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_loadDataWithBaseURL, jni.JniType.voidType, [
        baseUrl.reference,
        data.reference,
        mimeType.reference,
        encoding.reference,
        historyUrl.reference
      ]).check();

  static final _id_evaluateJavascript = jniAccessors.getMethodIDOf(
      _classRef,
      "evaluateJavascript",
      "(Ljava/lang/String;Landroid/webkit/ValueCallback;)V");

  /// from: public void evaluateJavascript(java.lang.String script, android.webkit.ValueCallback<java.lang.String> resultCallback)
  ///
  /// Asynchronously evaluates JavaScript in the context of the currently displayed page.
  /// If non-null, |resultCallback| will be invoked with any result returned from that
  /// execution. This method must be called on the UI thread and the callback will
  /// be made on the UI thread.
  ///
  /// Compatibility note. Applications targeting android.os.Build.VERSION_CODES\#N or
  /// later, JavaScript state from an empty WebView is no longer persisted across navigations like
  /// \#loadUrl(String). For example, global variables and functions defined before calling
  /// \#loadUrl(String) will not exist in the loaded page. Applications should use
  /// \#addJavascriptInterface instead to persist JavaScript objects across navigations.
  ///@param script the JavaScript to execute.
  ///@param resultCallback A callback to be invoked when the script execution
  ///                       completes with the result of the execution (if any).
  ///                       May be {@code null} if no notification of the result is required.
  ///
  /// This value may be {@code null}.
  void evaluateJavascript(
          jni.JniString script, valuecallback_.ValueCallback resultCallback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_evaluateJavascript,
          jni.JniType.voidType,
          [script.reference, resultCallback.reference]).check();

  static final _id_saveWebArchive = jniAccessors.getMethodIDOf(
      _classRef, "saveWebArchive", "(Ljava/lang/String;)V");

  /// from: public void saveWebArchive(java.lang.String filename)
  ///
  /// Saves the current view as a web archive.
  ///@param filename the filename where the archive should be placed
  void saveWebArchive(jni.JniString filename) =>
      jniAccessors.callMethodWithArgs(reference, _id_saveWebArchive,
          jni.JniType.voidType, [filename.reference]).check();

  static final _id_saveWebArchive1 = jniAccessors.getMethodIDOf(_classRef,
      "saveWebArchive", "(Ljava/lang/String;ZLandroid/webkit/ValueCallback;)V");

  /// from: public void saveWebArchive(java.lang.String basename, boolean autoname, android.webkit.ValueCallback<java.lang.String> callback)
  ///
  /// Saves the current view as a web archive.
  ///@param basename the filename where the archive should be placed
  ///@param autoname if {@code false}, takes basename to be a file. If {@code true}, basename
  ///                 is assumed to be a directory in which a filename will be
  ///                 chosen according to the URL of the current page.
  ///@param callback called after the web archive has been saved. The
  ///                 parameter for onReceiveValue will either be the filename
  ///                 under which the file was saved, or {@code null} if saving the
  ///                 file failed.
  ///
  /// This value may be {@code null}.
  void saveWebArchive1(jni.JniString basename, bool autoname,
          valuecallback_.ValueCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_saveWebArchive1,
          jni.JniType.voidType,
          [basename.reference, autoname, callback.reference]).check();

  static final _id_stopLoading =
      jniAccessors.getMethodIDOf(_classRef, "stopLoading", "()V");

  /// from: public void stopLoading()
  ///
  /// Stops the current load.
  void stopLoading() => jniAccessors.callMethodWithArgs(
      reference, _id_stopLoading, jni.JniType.voidType, []).check();

  static final _id_reload =
      jniAccessors.getMethodIDOf(_classRef, "reload", "()V");

  /// from: public void reload()
  ///
  /// Reloads the current URL.
  void reload() => jniAccessors.callMethodWithArgs(
      reference, _id_reload, jni.JniType.voidType, []).check();

  static final _id_canGoBack =
      jniAccessors.getMethodIDOf(_classRef, "canGoBack", "()Z");

  /// from: public boolean canGoBack()
  ///
  /// Gets whether this WebView has a back history item.
  ///@return {@code true} if this WebView has a back history item
  bool canGoBack() => jniAccessors.callMethodWithArgs(
      reference, _id_canGoBack, jni.JniType.booleanType, []).boolean;

  static final _id_goBack =
      jniAccessors.getMethodIDOf(_classRef, "goBack", "()V");

  /// from: public void goBack()
  ///
  /// Goes back in the history of this WebView.
  void goBack() => jniAccessors.callMethodWithArgs(
      reference, _id_goBack, jni.JniType.voidType, []).check();

  static final _id_canGoForward =
      jniAccessors.getMethodIDOf(_classRef, "canGoForward", "()Z");

  /// from: public boolean canGoForward()
  ///
  /// Gets whether this WebView has a forward history item.
  ///@return {@code true} if this WebView has a forward history item
  bool canGoForward() => jniAccessors.callMethodWithArgs(
      reference, _id_canGoForward, jni.JniType.booleanType, []).boolean;

  static final _id_goForward =
      jniAccessors.getMethodIDOf(_classRef, "goForward", "()V");

  /// from: public void goForward()
  ///
  /// Goes forward in the history of this WebView.
  void goForward() => jniAccessors.callMethodWithArgs(
      reference, _id_goForward, jni.JniType.voidType, []).check();

  static final _id_canGoBackOrForward =
      jniAccessors.getMethodIDOf(_classRef, "canGoBackOrForward", "(I)Z");

  /// from: public boolean canGoBackOrForward(int steps)
  ///
  /// Gets whether the page can go back or forward the given
  /// number of steps.
  ///@param steps the negative or positive number of steps to move the
  ///              history
  bool canGoBackOrForward(int steps) => jniAccessors.callMethodWithArgs(
      reference,
      _id_canGoBackOrForward,
      jni.JniType.booleanType,
      [steps]).boolean;

  static final _id_goBackOrForward =
      jniAccessors.getMethodIDOf(_classRef, "goBackOrForward", "(I)V");

  /// from: public void goBackOrForward(int steps)
  ///
  /// Goes to the history item that is the number of steps away from
  /// the current item. Steps is negative if backward and positive
  /// if forward.
  ///@param steps the number of steps to take back or forward in the back
  ///              forward list
  void goBackOrForward(int steps) => jniAccessors.callMethodWithArgs(
      reference, _id_goBackOrForward, jni.JniType.voidType, [steps]).check();

  static final _id_isPrivateBrowsingEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isPrivateBrowsingEnabled", "()Z");

  /// from: public boolean isPrivateBrowsingEnabled()
  ///
  /// Gets whether private browsing is enabled in this WebView.
  bool isPrivateBrowsingEnabled() => jniAccessors.callMethodWithArgs(reference,
      _id_isPrivateBrowsingEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_pageUp =
      jniAccessors.getMethodIDOf(_classRef, "pageUp", "(Z)Z");

  /// from: public boolean pageUp(boolean top)
  ///
  /// Scrolls the contents of this WebView up by half the view size.
  ///@param top {@code true} to jump to the top of the page
  ///@return {@code true} if the page was scrolled
  bool pageUp(bool top) => jniAccessors.callMethodWithArgs(
      reference, _id_pageUp, jni.JniType.booleanType, [top]).boolean;

  static final _id_pageDown =
      jniAccessors.getMethodIDOf(_classRef, "pageDown", "(Z)Z");

  /// from: public boolean pageDown(boolean bottom)
  ///
  /// Scrolls the contents of this WebView down by half the page size.
  ///@param bottom {@code true} to jump to bottom of page
  ///@return {@code true} if the page was scrolled
  bool pageDown(bool bottom) => jniAccessors.callMethodWithArgs(
      reference, _id_pageDown, jni.JniType.booleanType, [bottom]).boolean;

  static final _id_postVisualStateCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "postVisualStateCallback",
      "(JLandroid/webkit/WebView\$VisualStateCallback;)V");

  /// from: public void postVisualStateCallback(long requestId, android.webkit.WebView.VisualStateCallback callback)
  ///
  /// Posts a VisualStateCallback, which will be called when
  /// the current state of the WebView is ready to be drawn.
  ///
  /// Because updates to the DOM are processed asynchronously, updates to the DOM may not
  /// immediately be reflected visually by subsequent WebView\#onDraw invocations. The
  /// VisualStateCallback provides a mechanism to notify the caller when the contents of
  /// the DOM at the current time are ready to be drawn the next time the WebView
  /// draws.
  ///
  /// The next draw after the callback completes is guaranteed to reflect all the updates to the
  /// DOM up to the point at which the VisualStateCallback was posted, but it may also
  /// contain updates applied after the callback was posted.
  ///
  /// The state of the DOM covered by this API includes the following:
  /// <ul>
  /// <li>primitive HTML elements (div, img, span, etc..)</li>
  /// <li>images</li>
  /// <li>CSS animations</li>
  /// <li>WebGL</li>
  /// <li>canvas</li>
  /// </ul>
  /// It does not include the state of:
  /// <ul>
  /// <li>the video tag</li>
  /// </ul>
  ///
  /// To guarantee that the WebView will successfully render the first frame
  /// after the VisualStateCallback\#onComplete method has been called a set of conditions
  /// must be met:
  /// <ul>
  /// <li>If the WebView's visibility is set to View\#VISIBLE VISIBLE then
  /// the WebView must be attached to the view hierarchy.</li>
  /// <li>If the WebView's visibility is set to View\#INVISIBLE INVISIBLE
  /// then the WebView must be attached to the view hierarchy and must be made
  /// View\#VISIBLE VISIBLE from the VisualStateCallback\#onComplete method.</li>
  /// <li>If the WebView's visibility is set to View\#GONE GONE then the
  /// WebView must be attached to the view hierarchy and its
  /// AbsoluteLayout.LayoutParams LayoutParams's width and height need to be set to fixed
  /// values and must be made View\#VISIBLE VISIBLE from the
  /// VisualStateCallback\#onComplete method.</li>
  /// </ul>
  ///
  /// When using this API it is also recommended to enable pre-rasterization if the WebView is off screen to avoid flickering. See WebSettings\#setOffscreenPreRaster for
  /// more details and do consider its caveats.
  ///@param requestId An id that will be returned in the callback to allow callers to match
  ///                  requests with callbacks.
  ///@param callback The callback to be invoked.
  void postVisualStateCallback(
          int requestId, WebView_VisualStateCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_postVisualStateCallback,
          jni.JniType.voidType, [requestId, callback.reference]).check();

  static final _id_clearView =
      jniAccessors.getMethodIDOf(_classRef, "clearView", "()V");

  /// from: public void clearView()
  ///
  /// Clears this WebView so that onDraw() will draw nothing but white background,
  /// and onMeasure() will return 0 if MeasureSpec is not MeasureSpec.EXACTLY.
  ///@deprecated Use WebView.loadUrl("about:blank") to reliably reset the view state
  ///             and release page resources (including any running JavaScript).
  void clearView() => jniAccessors.callMethodWithArgs(
      reference, _id_clearView, jni.JniType.voidType, []).check();

  static final _id_capturePicture = jniAccessors.getMethodIDOf(
      _classRef, "capturePicture", "()Landroid/graphics/Picture;");

  /// from: public android.graphics.Picture capturePicture()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a new picture that captures the current contents of this WebView.
  /// The picture is of the entire document being displayed, and is not
  /// limited to the area currently displayed by this WebView. Also, the
  /// picture is a static copy and is unaffected by later changes to the
  /// content being displayed.
  ///
  /// Note that due to internal changes, for API levels between
  /// android.os.Build.VERSION_CODES\#HONEYCOMB and
  /// android.os.Build.VERSION_CODES\#ICE_CREAM_SANDWICH inclusive, the
  /// picture does not include fixed position elements or scrollable divs.
  ///
  /// Note that from android.os.Build.VERSION_CODES\#JELLY_BEAN_MR1 the returned picture
  /// should only be drawn into bitmap-backed Canvas - using any other type of Canvas will involve
  /// additional conversion at a cost in memory and performance. Also the
  /// android.graphics.Picture\#createFromStream and
  /// android.graphics.Picture\#writeToStream methods are not supported on the
  /// returned object.
  ///@deprecated Use \#onDraw to obtain a bitmap snapshot of the WebView, or
  /// \#saveWebArchive to save the content to a file.
  ///@return a picture that captures the current contents of this WebView
  picture_.Picture capturePicture() =>
      picture_.Picture.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_capturePicture, jni.JniType.objectType, []).object);

  static final _id_createPrintDocumentAdapter = jniAccessors.getMethodIDOf(
      _classRef,
      "createPrintDocumentAdapter",
      "()Landroid/print/PrintDocumentAdapter;");

  /// from: public android.print.PrintDocumentAdapter createPrintDocumentAdapter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Use \#createPrintDocumentAdapter(String) which requires user
  ///             to provide a print document name.
  printdocumentadapter_.PrintDocumentAdapter createPrintDocumentAdapter() =>
      printdocumentadapter_.PrintDocumentAdapter.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_createPrintDocumentAdapter,
              jni.JniType.objectType, []).object);

  static final _id_createPrintDocumentAdapter1 = jniAccessors.getMethodIDOf(
      _classRef,
      "createPrintDocumentAdapter",
      "(Ljava/lang/String;)Landroid/print/PrintDocumentAdapter;");

  /// from: public android.print.PrintDocumentAdapter createPrintDocumentAdapter(java.lang.String documentName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a PrintDocumentAdapter that provides the content of this WebView for printing.
  ///
  /// The adapter works by converting the WebView contents to a PDF stream. The WebView cannot
  /// be drawn during the conversion process - any such draws are undefined. It is recommended
  /// to use a dedicated off screen WebView for the printing. If necessary, an application may
  /// temporarily hide a visible WebView by using a custom PrintDocumentAdapter instance
  /// wrapped around the object returned and observing the onStart and onFinish methods. See
  /// android.print.PrintDocumentAdapter for more information.
  ///@param documentName The user-facing name of the printed document. See
  ///                      android.print.PrintDocumentInfo
  printdocumentadapter_.PrintDocumentAdapter createPrintDocumentAdapter1(
          jni.JniString documentName) =>
      printdocumentadapter_.PrintDocumentAdapter.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_createPrintDocumentAdapter1,
              jni.JniType.objectType, [documentName.reference]).object);

  static final _id_getScale =
      jniAccessors.getMethodIDOf(_classRef, "getScale", "()F");

  /// from: public float getScale()
  ///
  /// Gets the current scale of this WebView.
  ///@return the current scale
  ///@deprecated This method is prone to inaccuracy due to race conditions
  /// between the web rendering and UI threads; prefer
  /// WebViewClient\#onScaleChanged.
  double getScale() => jniAccessors.callMethodWithArgs(
      reference, _id_getScale, jni.JniType.floatType, []).float;

  static final _id_setInitialScale =
      jniAccessors.getMethodIDOf(_classRef, "setInitialScale", "(I)V");

  /// from: public void setInitialScale(int scaleInPercent)
  ///
  /// Sets the initial scale for this WebView. 0 means default.
  /// The behavior for the default scale depends on the state of
  /// WebSettings\#getUseWideViewPort() and
  /// WebSettings\#getLoadWithOverviewMode().
  /// If the content fits into the WebView control by width, then
  /// the zoom is set to 100%. For wide content, the behavior
  /// depends on the state of WebSettings\#getLoadWithOverviewMode().
  /// If its value is {@code true}, the content will be zoomed out to be fit
  /// by width into the WebView control, otherwise not.
  ///
  /// If initial scale is greater than 0, WebView starts with this value
  /// as initial scale.
  /// Please note that unlike the scale properties in the viewport meta tag,
  /// this method doesn't take the screen density into account.
  ///@param scaleInPercent the initial scale in percent
  void setInitialScale(int scaleInPercent) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setInitialScale,
      jni.JniType.voidType,
      [scaleInPercent]).check();

  static final _id_invokeZoomPicker =
      jniAccessors.getMethodIDOf(_classRef, "invokeZoomPicker", "()V");

  /// from: public void invokeZoomPicker()
  ///
  /// Invokes the graphical zoom picker widget for this WebView. This will
  /// result in the zoom widget appearing on the screen to control the zoom
  /// level of this WebView.
  void invokeZoomPicker() => jniAccessors.callMethodWithArgs(
      reference, _id_invokeZoomPicker, jni.JniType.voidType, []).check();

  static final _id_getHitTestResult = jniAccessors.getMethodIDOf(_classRef,
      "getHitTestResult", "()Landroid/webkit/WebView\$HitTestResult;");

  /// from: public android.webkit.WebView.HitTestResult getHitTestResult()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a HitTestResult based on the current cursor node. If a HTML::a
  /// tag is found and the anchor has a non-JavaScript URL, the HitTestResult
  /// type is set to SRC_ANCHOR_TYPE and the URL is set in the "extra" field.
  /// If the anchor does not have a URL or if it is a JavaScript URL, the type
  /// will be UNKNOWN_TYPE and the URL has to be retrieved through
  /// \#requestFocusNodeHref asynchronously. If a HTML::img tag is
  /// found, the HitTestResult type is set to IMAGE_TYPE and the URL is set in
  /// the "extra" field. A type of
  /// SRC_IMAGE_ANCHOR_TYPE indicates an anchor with a URL that has an image as
  /// a child node. If a phone number is found, the HitTestResult type is set
  /// to PHONE_TYPE and the phone number is set in the "extra" field of
  /// HitTestResult. If a map address is found, the HitTestResult type is set
  /// to GEO_TYPE and the address is set in the "extra" field of HitTestResult.
  /// If an email address is found, the HitTestResult type is set to EMAIL_TYPE
  /// and the email is set in the "extra" field of HitTestResult. Otherwise,
  /// HitTestResult type is set to UNKNOWN_TYPE.
  WebView_HitTestResult getHitTestResult() =>
      WebView_HitTestResult.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getHitTestResult, jni.JniType.objectType, []).object);

  static final _id_requestFocusNodeHref = jniAccessors.getMethodIDOf(
      _classRef, "requestFocusNodeHref", "(Landroid/os/Message;)V");

  /// from: public void requestFocusNodeHref(android.os.Message hrefMsg)
  ///
  /// Requests the anchor or image element URL at the last tapped point.
  /// If hrefMsg is {@code null}, this method returns immediately and does not
  /// dispatch hrefMsg to its target. If the tapped point hits an image,
  /// an anchor, or an image in an anchor, the message associates
  /// strings in named keys in its data. The value paired with the key
  /// may be an empty string.
  ///@param hrefMsg the message to be dispatched with the result of the
  ///                request. The message data contains three keys. "url"
  ///                returns the anchor's href attribute. "title" returns the
  ///                anchor's text. "src" returns the image's src attribute.
  ///
  /// This value may be {@code null}.
  void requestFocusNodeHref(message_.Message hrefMsg) =>
      jniAccessors.callMethodWithArgs(reference, _id_requestFocusNodeHref,
          jni.JniType.voidType, [hrefMsg.reference]).check();

  static final _id_requestImageRef = jniAccessors.getMethodIDOf(
      _classRef, "requestImageRef", "(Landroid/os/Message;)V");

  /// from: public void requestImageRef(android.os.Message msg)
  ///
  /// Requests the URL of the image last touched by the user. msg will be sent
  /// to its target with a String representing the URL as its object.
  ///@param msg the message to be dispatched with the result of the request
  ///            as the data member with "url" as key. The result can be {@code null}.
  void requestImageRef(message_.Message msg) => jniAccessors.callMethodWithArgs(
      reference,
      _id_requestImageRef,
      jni.JniType.voidType,
      [msg.reference]).check();

  static final _id_getUrl =
      jniAccessors.getMethodIDOf(_classRef, "getUrl", "()Ljava/lang/String;");

  /// from: public java.lang.String getUrl()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the URL for the current page. This is not always the same as the URL
  /// passed to WebViewClient.onPageStarted because although the load for
  /// that URL has begun, the current page may not have changed.
  ///@return the URL for the current page
  jni.JniString getUrl() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getUrl, jni.JniType.objectType, []).object);

  static final _id_getOriginalUrl = jniAccessors.getMethodIDOf(
      _classRef, "getOriginalUrl", "()Ljava/lang/String;");

  /// from: public java.lang.String getOriginalUrl()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the original URL for the current page. This is not always the same
  /// as the URL passed to WebViewClient.onPageStarted because although the
  /// load for that URL has begun, the current page may not have changed.
  /// Also, there may have been redirects resulting in a different URL to that
  /// originally requested.
  ///@return the URL that was originally requested for the current page
  jni.JniString getOriginalUrl() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getOriginalUrl, jni.JniType.objectType, []).object);

  static final _id_getTitle =
      jniAccessors.getMethodIDOf(_classRef, "getTitle", "()Ljava/lang/String;");

  /// from: public java.lang.String getTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the title for the current page. This is the title of the current page
  /// until WebViewClient.onReceivedTitle is called.
  ///@return the title for the current page
  jni.JniString getTitle() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTitle, jni.JniType.objectType, []).object);

  static final _id_getFavicon = jniAccessors.getMethodIDOf(
      _classRef, "getFavicon", "()Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getFavicon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the favicon for the current page. This is the favicon of the current
  /// page until WebViewClient.onReceivedIcon is called.
  ///@return the favicon for the current page
  bitmap_.Bitmap getFavicon() =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFavicon, jni.JniType.objectType, []).object);

  static final _id_getProgress =
      jniAccessors.getMethodIDOf(_classRef, "getProgress", "()I");

  /// from: public int getProgress()
  ///
  /// Gets the progress for the current page.
  ///@return the progress for the current page between 0 and 100
  int getProgress() => jniAccessors.callMethodWithArgs(
      reference, _id_getProgress, jni.JniType.intType, []).integer;

  static final _id_getContentHeight =
      jniAccessors.getMethodIDOf(_classRef, "getContentHeight", "()I");

  /// from: public int getContentHeight()
  ///
  /// Gets the height of the HTML content.
  ///@return the height of the HTML content
  int getContentHeight() => jniAccessors.callMethodWithArgs(
      reference, _id_getContentHeight, jni.JniType.intType, []).integer;

  static final _id_pauseTimers =
      jniAccessors.getMethodIDOf(_classRef, "pauseTimers", "()V");

  /// from: public void pauseTimers()
  ///
  /// Pauses all layout, parsing, and JavaScript timers for all WebViews. This
  /// is a global requests, not restricted to just this WebView. This can be
  /// useful if the application has been paused.
  void pauseTimers() => jniAccessors.callMethodWithArgs(
      reference, _id_pauseTimers, jni.JniType.voidType, []).check();

  static final _id_resumeTimers =
      jniAccessors.getMethodIDOf(_classRef, "resumeTimers", "()V");

  /// from: public void resumeTimers()
  ///
  /// Resumes all layout, parsing, and JavaScript timers for all WebViews.
  /// This will resume dispatching all timers.
  void resumeTimers() => jniAccessors.callMethodWithArgs(
      reference, _id_resumeTimers, jni.JniType.voidType, []).check();

  static final _id_onPause =
      jniAccessors.getMethodIDOf(_classRef, "onPause", "()V");

  /// from: public void onPause()
  ///
  /// Does a best-effort attempt to pause any processing that can be paused
  /// safely, such as animations and geolocation. Note that this call
  /// does not pause JavaScript. To pause JavaScript globally, use
  /// \#pauseTimers.
  ///
  /// To resume WebView, call \#onResume.
  void onPause() => jniAccessors.callMethodWithArgs(
      reference, _id_onPause, jni.JniType.voidType, []).check();

  static final _id_onResume =
      jniAccessors.getMethodIDOf(_classRef, "onResume", "()V");

  /// from: public void onResume()
  ///
  /// Resumes a WebView after a previous call to \#onPause.
  void onResume() => jniAccessors.callMethodWithArgs(
      reference, _id_onResume, jni.JniType.voidType, []).check();

  static final _id_freeMemory =
      jniAccessors.getMethodIDOf(_classRef, "freeMemory", "()V");

  /// from: public void freeMemory()
  ///
  /// Informs this WebView that memory is low so that it can free any available
  /// memory.
  ///@deprecated Memory caches are automatically dropped when no longer needed, and in response
  ///             to system memory pressure.
  void freeMemory() => jniAccessors.callMethodWithArgs(
      reference, _id_freeMemory, jni.JniType.voidType, []).check();

  static final _id_clearCache =
      jniAccessors.getMethodIDOf(_classRef, "clearCache", "(Z)V");

  /// from: public void clearCache(boolean includeDiskFiles)
  ///
  /// Clears the resource cache. Note that the cache is per-application, so
  /// this will clear the cache for all WebViews used.
  ///@param includeDiskFiles if {@code false}, only the RAM cache is cleared
  void clearCache(bool includeDiskFiles) => jniAccessors.callMethodWithArgs(
      reference,
      _id_clearCache,
      jni.JniType.voidType,
      [includeDiskFiles]).check();

  static final _id_clearFormData =
      jniAccessors.getMethodIDOf(_classRef, "clearFormData", "()V");

  /// from: public void clearFormData()
  ///
  /// Removes the autocomplete popup from the currently focused form field, if
  /// present. Note this only affects the display of the autocomplete popup,
  /// it does not remove any saved form data from this WebView's store. To do
  /// that, use WebViewDatabase\#clearFormData.
  void clearFormData() => jniAccessors.callMethodWithArgs(
      reference, _id_clearFormData, jni.JniType.voidType, []).check();

  static final _id_clearHistory =
      jniAccessors.getMethodIDOf(_classRef, "clearHistory", "()V");

  /// from: public void clearHistory()
  ///
  /// Tells this WebView to clear its internal back/forward list.
  void clearHistory() => jniAccessors.callMethodWithArgs(
      reference, _id_clearHistory, jni.JniType.voidType, []).check();

  static final _id_clearSslPreferences =
      jniAccessors.getMethodIDOf(_classRef, "clearSslPreferences", "()V");

  /// from: public void clearSslPreferences()
  ///
  /// Clears the SSL preferences table stored in response to proceeding with
  /// SSL certificate errors.
  void clearSslPreferences() => jniAccessors.callMethodWithArgs(
      reference, _id_clearSslPreferences, jni.JniType.voidType, []).check();

  static final _id_clearClientCertPreferences =
      jniAccessors.getStaticMethodIDOf(
          _classRef, "clearClientCertPreferences", "(Ljava/lang/Runnable;)V");

  /// from: static public void clearClientCertPreferences(java.lang.Runnable onCleared)
  ///
  /// Clears the client certificate preferences stored in response
  /// to proceeding/cancelling client cert requests. Note that WebView
  /// automatically clears these preferences when it receives a
  /// KeyChain\#ACTION_STORAGE_CHANGED intent. The preferences are
  /// shared by all the WebViews that are created by the embedder application.
  ///@param onCleared A runnable to be invoked when client certs are cleared.
  ///                   The runnable will be called in UI thread.
  ///
  /// This value may be {@code null}.
  static void clearClientCertPreferences(jni.JniObject onCleared) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_clearClientCertPreferences,
          jni.JniType.voidType,
          [onCleared.reference]).check();

  static final _id_startSafeBrowsing = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "startSafeBrowsing",
      "(Landroid/content/Context;Landroid/webkit/ValueCallback;)V");

  /// from: static public void startSafeBrowsing(android.content.Context context, android.webkit.ValueCallback<java.lang.Boolean> callback)
  ///
  /// Starts Safe Browsing initialization.
  ///
  /// URL loads are not guaranteed to be protected by Safe Browsing until after {@code callback} is
  /// invoked with {@code true}. Safe Browsing is not fully supported on all devices. For those
  /// devices {@code callback} will receive {@code false}.
  ///
  /// This should not be called if Safe Browsing has been disabled by manifest tag or WebSettings\#setSafeBrowsingEnabled. This prepares resources used for Safe Browsing.
  ///
  /// This should be called with the Application Context (and will always use the Application
  /// context to do its work regardless).
  ///@param context Application Context.
  /// This value must never be {@code null}.
  ///@param callback will be called on the UI thread with {@code true} if initialization is
  /// successful, {@code false} otherwise.
  ///
  /// This value may be {@code null}.
  static void startSafeBrowsing(
          context_.Context context, valuecallback_.ValueCallback callback) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_startSafeBrowsing,
          jni.JniType.voidType,
          [context.reference, callback.reference]).check();

  static final _id_setSafeBrowsingWhitelist = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "setSafeBrowsingWhitelist",
      "(Ljava/util/List;Landroid/webkit/ValueCallback;)V");

  /// from: static public void setSafeBrowsingWhitelist(java.util.List<java.lang.String> hosts, android.webkit.ValueCallback<java.lang.Boolean> callback)
  ///
  /// Sets the list of hosts (domain names/IP addresses) that are exempt from SafeBrowsing checks.
  /// The list is global for all the WebViews.
  ///
  /// Each rule should take one of these:
  /// <table>
  /// <tr><th> Rule </th> <th> Example </th> <th> Matches Subdomain</th> </tr>
  /// <tr><td> HOSTNAME </td> <td> example.com </td> <td> Yes </td> </tr>
  /// <tr><td> .HOSTNAME </td> <td> .example.com </td> <td> No </td> </tr>
  /// <tr><td> IPV4_LITERAL </td> <td> 192.168.1.1 </td> <td> No </td></tr>
  /// <tr><td> IPV6_LITERAL_WITH_BRACKETS </td><td>[10:20:30:40:50:60:70:80]</td><td>No</td></tr>
  /// </table>
  ///
  /// All other rules, including wildcards, are invalid.
  ///
  /// The correct syntax for hosts is defined by <a href="https://tools.ietf.org/html/rfc3986\#section-3.2.2">RFC 3986</a>.
  ///@param hosts the list of hosts
  /// This value must never be {@code null}.
  ///@param callback will be called with {@code true} if hosts are successfully added to the
  /// whitelist. It will be called with {@code false} if any hosts are malformed. The callback
  /// will be run on the UI thread
  ///
  /// This value may be {@code null}.
  static void setSafeBrowsingWhitelist(
          jni.JniObject hosts, valuecallback_.ValueCallback callback) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_setSafeBrowsingWhitelist,
          jni.JniType.voidType,
          [hosts.reference, callback.reference]).check();

  static final _id_getSafeBrowsingPrivacyPolicyUrl =
      jniAccessors.getStaticMethodIDOf(
          _classRef, "getSafeBrowsingPrivacyPolicyUrl", "()Landroid/net/Uri;");

  /// from: static public android.net.Uri getSafeBrowsingPrivacyPolicyUrl()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a URL pointing to the privacy policy for Safe Browsing reporting.
  ///@return the url pointing to a privacy policy document which can be displayed to users.
  ///
  /// This value will never be {@code null}.
  static uri_.Uri getSafeBrowsingPrivacyPolicyUrl() =>
      uri_.Uri.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getSafeBrowsingPrivacyPolicyUrl,
          jni.JniType.objectType, []).object);

  static final _id_copyBackForwardList = jniAccessors.getMethodIDOf(_classRef,
      "copyBackForwardList", "()Landroid/webkit/WebBackForwardList;");

  /// from: public android.webkit.WebBackForwardList copyBackForwardList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the WebBackForwardList for this WebView. This contains the
  /// back/forward list for use in querying each item in the history stack.
  /// This is a copy of the private WebBackForwardList so it contains only a
  /// snapshot of the current state. Multiple calls to this method may return
  /// different objects. The object returned from this method will not be
  /// updated to reflect any new state.
  webbackforwardlist_.WebBackForwardList copyBackForwardList() =>
      webbackforwardlist_.WebBackForwardList.fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_copyBackForwardList,
              jni.JniType.objectType, []).object);

  static final _id_setFindListener = jniAccessors.getMethodIDOf(_classRef,
      "setFindListener", "(Landroid/webkit/WebView\$FindListener;)V");

  /// from: public void setFindListener(android.webkit.WebView.FindListener listener)
  ///
  /// Registers the listener to be notified as find-on-page operations
  /// progress. This will replace the current listener.
  ///@param listener an implementation of FindListener
  void setFindListener(WebView_FindListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFindListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_findNext =
      jniAccessors.getMethodIDOf(_classRef, "findNext", "(Z)V");

  /// from: public void findNext(boolean forward)
  ///
  /// Highlights and scrolls to the next match found by
  /// \#findAllAsync, wrapping around page boundaries as necessary.
  /// Notifies any registered FindListener. If \#findAllAsync(String)
  /// has not been called yet, or if \#clearMatches has been called since the
  /// last find operation, this function does nothing.
  ///@param forward the direction to search
  ///@see \#setFindListener
  void findNext(bool forward) => jniAccessors.callMethodWithArgs(
      reference, _id_findNext, jni.JniType.voidType, [forward]).check();

  static final _id_findAll =
      jniAccessors.getMethodIDOf(_classRef, "findAll", "(Ljava/lang/String;)I");

  /// from: public int findAll(java.lang.String find)
  ///
  /// Finds all instances of find on the page and highlights them.
  /// Notifies any registered FindListener.
  ///@param find the string to find
  ///@return the number of occurrences of the String "find" that were found
  ///@deprecated \#findAllAsync is preferred.
  ///@see \#setFindListener
  int findAll(jni.JniString find) => jniAccessors.callMethodWithArgs(
      reference, _id_findAll, jni.JniType.intType, [find.reference]).integer;

  static final _id_findAllAsync = jniAccessors.getMethodIDOf(
      _classRef, "findAllAsync", "(Ljava/lang/String;)V");

  /// from: public void findAllAsync(java.lang.String find)
  ///
  /// Finds all instances of find on the page and highlights them,
  /// asynchronously. Notifies any registered FindListener.
  /// Successive calls to this will cancel any pending searches.
  ///@param find the string to find.
  ///@see \#setFindListener
  void findAllAsync(jni.JniString find) => jniAccessors.callMethodWithArgs(
      reference,
      _id_findAllAsync,
      jni.JniType.voidType,
      [find.reference]).check();

  static final _id_showFindDialog = jniAccessors.getMethodIDOf(
      _classRef, "showFindDialog", "(Ljava/lang/String;Z)Z");

  /// from: public boolean showFindDialog(java.lang.String text, boolean showIme)
  ///
  /// Starts an ActionMode for finding text in this WebView.  Only works if this
  /// WebView is attached to the view system.
  ///@param text if non-null, will be the initial text to search for.
  ///             Otherwise, the last String searched for in this WebView will
  ///             be used to start.
  /// This value may be {@code null}.
  ///@param showIme if {@code true}, show the IME, assuming the user will begin typing.
  ///                If {@code false} and text is non-null, perform a find all.
  ///@return {@code true} if the find dialog is shown, {@code false} otherwise
  ///@deprecated This method does not work reliably on all Android versions;
  ///             implementing a custom find dialog using WebView.findAllAsync()
  ///             provides a more robust solution.
  bool showFindDialog(jni.JniString text, bool showIme) =>
      jniAccessors.callMethodWithArgs(reference, _id_showFindDialog,
          jni.JniType.booleanType, [text.reference, showIme]).boolean;

  static final _id_findAddress = jniAccessors.getStaticMethodIDOf(
      _classRef, "findAddress", "(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String findAddress(java.lang.String addr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the first substring consisting of the address of a physical
  /// location. Currently, only addresses in the United States are detected,
  /// and consist of:
  /// <ul>
  ///   <li>a house number</li>
  ///   <li>a street name</li>
  ///   <li>a street type (Road, Circle, etc), either spelled out or
  ///       abbreviated</li>
  ///   <li>a city name</li>
  ///   <li>a state or territory, either spelled out or two-letter abbr</li>
  ///   <li>an optional 5 digit or 9 digit zip code</li>
  /// </ul>
  /// All names must be correctly capitalized, and the zip code, if present,
  /// must be valid for the state. The street type must be a standard USPS
  /// spelling or abbreviation. The state or territory must also be spelled
  /// or abbreviated using USPS standards. The house number may not exceed
  /// five digits.
  ///@param addr the string to search for addresses
  ///@return the address, or if no address is found, {@code null}
  ///@deprecated this method is superseded by TextClassifier\#generateLinks(
  /// android.view.textclassifier.TextLinks.Request). Avoid using this method even when targeting
  /// API levels where no alternative is available.
  static jni.JniString findAddress(jni.JniString addr) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_findAddress, jni.JniType.objectType, [addr.reference]).object);

  static final _id_enableSlowWholeDocumentDraw = jniAccessors
      .getStaticMethodIDOf(_classRef, "enableSlowWholeDocumentDraw", "()V");

  /// from: static public void enableSlowWholeDocumentDraw()
  ///
  /// For apps targeting the L release, WebView has a new default behavior that reduces
  /// memory footprint and increases performance by intelligently choosing
  /// the portion of the HTML document that needs to be drawn. These
  /// optimizations are transparent to the developers. However, under certain
  /// circumstances, an App developer may want to disable them:
  /// <ol>
  ///   <li>When an app uses \#onDraw to do own drawing and accesses portions
  ///       of the page that is way outside the visible portion of the page.</li>
  ///   <li>When an app uses \#capturePicture to capture a very large HTML document.
  ///       Note that capturePicture is a deprecated API.</li>
  /// </ol>
  /// Enabling drawing the entire HTML document has a significant performance
  /// cost. This method should be called before any WebViews are created.
  static void enableSlowWholeDocumentDraw() =>
      jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_enableSlowWholeDocumentDraw, jni.JniType.voidType, []).check();

  static final _id_clearMatches =
      jniAccessors.getMethodIDOf(_classRef, "clearMatches", "()V");

  /// from: public void clearMatches()
  ///
  /// Clears the highlighting surrounding text matches created by
  /// \#findAllAsync.
  void clearMatches() => jniAccessors.callMethodWithArgs(
      reference, _id_clearMatches, jni.JniType.voidType, []).check();

  static final _id_documentHasImages = jniAccessors.getMethodIDOf(
      _classRef, "documentHasImages", "(Landroid/os/Message;)V");

  /// from: public void documentHasImages(android.os.Message response)
  ///
  /// Queries the document to see if it contains any image references. The
  /// message object will be dispatched with arg1 being set to 1 if images
  /// were found and 0 if the document does not reference any images.
  ///@param response the message that will be dispatched with the result
  void documentHasImages(message_.Message response) =>
      jniAccessors.callMethodWithArgs(reference, _id_documentHasImages,
          jni.JniType.voidType, [response.reference]).check();

  static final _id_setWebViewClient = jniAccessors.getMethodIDOf(
      _classRef, "setWebViewClient", "(Landroid/webkit/WebViewClient;)V");

  /// from: public void setWebViewClient(android.webkit.WebViewClient client)
  ///
  /// Sets the WebViewClient that will receive various notifications and
  /// requests. This will replace the current handler.
  ///@param client an implementation of WebViewClient
  ///@see \#getWebViewClient
  void setWebViewClient(webviewclient_.WebViewClient client) =>
      jniAccessors.callMethodWithArgs(reference, _id_setWebViewClient,
          jni.JniType.voidType, [client.reference]).check();

  static final _id_getWebViewClient = jniAccessors.getMethodIDOf(
      _classRef, "getWebViewClient", "()Landroid/webkit/WebViewClient;");

  /// from: public android.webkit.WebViewClient getWebViewClient()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the WebViewClient.
  ///@return the WebViewClient, or a default client if not yet set
  ///@see \#setWebViewClient
  webviewclient_.WebViewClient getWebViewClient() =>
      webviewclient_.WebViewClient.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWebViewClient, jni.JniType.objectType, []).object);

  static final _id_setDownloadListener = jniAccessors.getMethodIDOf(
      _classRef, "setDownloadListener", "(Landroid/webkit/DownloadListener;)V");

  /// from: public void setDownloadListener(android.webkit.DownloadListener listener)
  ///
  /// Registers the interface to be used when content can not be handled by
  /// the rendering engine, and should be downloaded instead. This will replace
  /// the current handler.
  ///@param listener an implementation of DownloadListener
  void setDownloadListener(downloadlistener_.DownloadListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDownloadListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_setWebChromeClient = jniAccessors.getMethodIDOf(
      _classRef, "setWebChromeClient", "(Landroid/webkit/WebChromeClient;)V");

  /// from: public void setWebChromeClient(android.webkit.WebChromeClient client)
  ///
  /// Sets the chrome handler. This is an implementation of WebChromeClient for
  /// use in handling JavaScript dialogs, favicons, titles, and the progress.
  /// This will replace the current handler.
  ///@param client an implementation of WebChromeClient
  ///@see \#getWebChromeClient
  void setWebChromeClient(webchromeclient_.WebChromeClient client) =>
      jniAccessors.callMethodWithArgs(reference, _id_setWebChromeClient,
          jni.JniType.voidType, [client.reference]).check();

  static final _id_getWebChromeClient = jniAccessors.getMethodIDOf(
      _classRef, "getWebChromeClient", "()Landroid/webkit/WebChromeClient;");

  /// from: public android.webkit.WebChromeClient getWebChromeClient()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the chrome handler.
  ///@return the WebChromeClient, or {@code null} if not yet set
  ///@see \#setWebChromeClient
  webchromeclient_.WebChromeClient getWebChromeClient() =>
      webchromeclient_.WebChromeClient.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getWebChromeClient,
          jni.JniType.objectType, []).object);

  static final _id_setPictureListener = jniAccessors.getMethodIDOf(_classRef,
      "setPictureListener", "(Landroid/webkit/WebView\$PictureListener;)V");

  /// from: public void setPictureListener(android.webkit.WebView.PictureListener listener)
  ///
  /// Sets the Picture listener. This is an interface used to receive
  /// notifications of a new Picture.
  ///@param listener an implementation of WebView.PictureListener
  ///@deprecated This method is now obsolete.
  void setPictureListener(WebView_PictureListener listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPictureListener,
          jni.JniType.voidType, [listener.reference]).check();

  static final _id_addJavascriptInterface = jniAccessors.getMethodIDOf(
      _classRef,
      "addJavascriptInterface",
      "(Ljava/lang/Object;Ljava/lang/String;)V");

  /// from: public void addJavascriptInterface(java.lang.Object object, java.lang.String name)
  ///
  /// Injects the supplied Java object into this WebView. The object is
  /// injected into the JavaScript context of the main frame, using the
  /// supplied name. This allows the Java object's methods to be
  /// accessed from JavaScript. For applications targeted to API
  /// level android.os.Build.VERSION_CODES\#JELLY_BEAN_MR1
  /// and above, only public methods that are annotated with
  /// android.webkit.JavascriptInterface can be accessed from JavaScript.
  /// For applications targeted to API level android.os.Build.VERSION_CODES\#JELLY_BEAN or below,
  /// all public methods (including the inherited ones) can be accessed, see the
  /// important security note below for implications.
  ///  Note that injected objects will not appear in JavaScript until the page is next
  /// (re)loaded. JavaScript should be enabled before injecting the object. For example:
  /// <pre>
  /// class JsObject {
  ///    {@literal @}JavascriptInterface
  ///    public String toString() { return "injectedObject"; }
  /// }
  /// webview.getSettings().setJavaScriptEnabled(true);
  /// webView.addJavascriptInterface(new JsObject(), "injectedObject");
  /// webView.loadData("html<title></title>", "text/html", null);
  /// webView.loadUrl("javascript:alert(injectedObject.toString())");</pre>
  ///
  /// <strong>IMPORTANT:</strong>
  /// <ul>
  /// <li> This method can be used to allow JavaScript to control the host
  /// application. This is a powerful feature, but also presents a security
  /// risk for apps targeting android.os.Build.VERSION_CODES\#JELLY_BEAN or earlier.
  /// Apps that target a version later than android.os.Build.VERSION_CODES\#JELLY_BEAN
  /// are still vulnerable if the app runs on a device running Android earlier than 4.2.
  /// The most secure way to use this method is to target android.os.Build.VERSION_CODES\#JELLY_BEAN_MR1
  /// and to ensure the method is called only when running on Android 4.2 or later.
  /// With these older versions, JavaScript could use reflection to access an
  /// injected object's public fields. Use of this method in a WebView
  /// containing untrusted content could allow an attacker to manipulate the
  /// host application in unintended ways, executing Java code with the
  /// permissions of the host application. Use extreme care when using this
  /// method in a WebView which could contain untrusted content.</li>
  /// <li> JavaScript interacts with Java object on a private, background
  /// thread of this WebView. Care is therefore required to maintain thread
  /// safety.
  /// </li>
  /// <li> The Java object's fields are not accessible.</li>
  /// <li> For applications targeted to API level android.os.Build.VERSION_CODES\#LOLLIPOP
  /// and above, methods of injected Java objects are enumerable from
  /// JavaScript.</li>
  /// </ul>
  ///@param object the Java object to inject into this WebView's JavaScript
  ///               context. {@code null} values are ignored.
  ///@param name the name used to expose the object in JavaScript
  void addJavascriptInterface(jni.JniObject object, jni.JniString name) =>
      jniAccessors.callMethodWithArgs(reference, _id_addJavascriptInterface,
          jni.JniType.voidType, [object.reference, name.reference]).check();

  static final _id_removeJavascriptInterface = jniAccessors.getMethodIDOf(
      _classRef, "removeJavascriptInterface", "(Ljava/lang/String;)V");

  /// from: public void removeJavascriptInterface(java.lang.String name)
  ///
  /// Removes a previously injected Java object from this WebView. Note that
  /// the removal will not be reflected in JavaScript until the page is next
  /// (re)loaded. See \#addJavascriptInterface.
  ///@param name the name used to expose the object in JavaScript
  ///
  /// This value must never be {@code null}.
  void removeJavascriptInterface(jni.JniString name) =>
      jniAccessors.callMethodWithArgs(reference, _id_removeJavascriptInterface,
          jni.JniType.voidType, [name.reference]).check();

  static final _id_createWebMessageChannel = jniAccessors.getMethodIDOf(
      _classRef,
      "createWebMessageChannel",
      "()[Landroid/webkit/WebMessagePort;");

  /// from: public android.webkit.WebMessagePort[] createWebMessageChannel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a message channel to communicate with JS and returns the message
  /// ports that represent the endpoints of this message channel. The HTML5 message
  /// channel functionality is described
  /// <a href="https://html.spec.whatwg.org/multipage/comms.html\#messagechannel">here
  /// </a>
  ///
  /// The returned message channels are entangled and already in started state.
  ///@return the two message ports that form the message channel.
  jni.JniObject createWebMessageChannel() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_createWebMessageChannel, jni.JniType.objectType, []).object);

  static final _id_postWebMessage = jniAccessors.getMethodIDOf(_classRef,
      "postWebMessage", "(Landroid/webkit/WebMessage;Landroid/net/Uri;)V");

  /// from: public void postWebMessage(android.webkit.WebMessage message, android.net.Uri targetOrigin)
  ///
  /// Post a message to main frame. The embedded application can restrict the
  /// messages to a certain target origin. See
  /// <a href="https://html.spec.whatwg.org/multipage/comms.html\#posting-messages">
  /// HTML5 spec</a> for how target origin can be used.
  ///
  /// A target origin can be set as a wildcard ("*"). However this is not recommended.
  /// See the page above for security issues.
  ///
  /// Content loaded via \#loadData(String,String,String) will not have a
  /// valid origin, and thus cannot be sent messages securely. If you need to send
  /// messages using this function, you should use
  /// \#loadDataWithBaseURL(String,String,String,String,String) with a valid
  /// HTTP or HTTPS {@code baseUrl} to define a valid origin that can be used for
  /// messaging.
  ///@param message the WebMessage
  ///@param targetOrigin the target origin.
  void postWebMessage(webmessage_.WebMessage message, uri_.Uri targetOrigin) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_postWebMessage,
          jni.JniType.voidType,
          [message.reference, targetOrigin.reference]).check();

  static final _id_getSettings = jniAccessors.getMethodIDOf(
      _classRef, "getSettings", "()Landroid/webkit/WebSettings;");

  /// from: public android.webkit.WebSettings getSettings()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the WebSettings object used to control the settings for this
  /// WebView.
  ///@return a WebSettings object that can be used to control this WebView's
  ///         settings
  websettings_.WebSettings getSettings() =>
      websettings_.WebSettings.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getSettings, jni.JniType.objectType, []).object);

  static final _id_setWebContentsDebuggingEnabled = jniAccessors
      .getStaticMethodIDOf(_classRef, "setWebContentsDebuggingEnabled", "(Z)V");

  /// from: static public void setWebContentsDebuggingEnabled(boolean enabled)
  ///
  /// Enables debugging of web contents (HTML / CSS / JavaScript)
  /// loaded into any WebViews of this application. This flag can be enabled
  /// in order to facilitate debugging of web layouts and JavaScript
  /// code running inside WebViews. Please refer to WebView documentation
  /// for the debugging guide.
  ///
  /// The default is {@code false}.
  ///@param enabled whether to enable web contents debugging
  static void setWebContentsDebuggingEnabled(bool enabled) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_setWebContentsDebuggingEnabled,
          jni.JniType.voidType,
          [enabled]).check();

  static final _id_setDataDirectorySuffix = jniAccessors.getStaticMethodIDOf(
      _classRef, "setDataDirectorySuffix", "(Ljava/lang/String;)V");

  /// from: static public void setDataDirectorySuffix(java.lang.String suffix)
  ///
  /// Define the directory used to store WebView data for the current process.
  /// The provided suffix will be used when constructing data and cache
  /// directory paths. If this API is not called, no suffix will be used.
  /// Each directory can be used by only one process in the application. If more
  /// than one process in an app wishes to use WebView, only one process can use
  /// the default directory, and other processes must call this API to define
  /// a unique suffix.
  ///
  /// This means that different processes in the same application cannot directly
  /// share WebView-related data, since the data directories must be distinct.
  /// Applications that use this API may have to explicitly pass data between
  /// processes. For example, login cookies may have to be copied from one
  /// process's cookie jar to the other using CookieManager if both
  /// processes' WebViews are intended to be logged in.
  ///
  /// Most applications should simply ensure that all components of the app
  /// that rely on WebView are in the same process, to avoid needing multiple
  /// data directories. The \#disableWebView method can be used to ensure
  /// that the other processes do not use WebView by accident in this case.
  ///
  /// This API must be called before any instances of WebView are created in
  /// this process and before any other methods in the android.webkit package
  /// are called by this process.
  ///@param suffix The directory name suffix to be used for the current
  ///               process. Must not contain a path separator.
  ///@throws IllegalStateException if WebView has already been initialized
  ///                               in the current process.
  ///@throws IllegalArgumentException if the suffix contains a path separator.
  static void setDataDirectorySuffix(jni.JniString suffix) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_setDataDirectorySuffix,
          jni.JniType.voidType,
          [suffix.reference]).check();

  static final _id_disableWebView =
      jniAccessors.getStaticMethodIDOf(_classRef, "disableWebView", "()V");

  /// from: static public void disableWebView()
  ///
  /// Indicate that the current process does not intend to use WebView, and
  /// that an exception should be thrown if a WebView is created or any other
  /// methods in the android.webkit package are used.
  ///
  /// Applications with multiple processes may wish to call this in processes
  /// that are not intended to use WebView to avoid accidentally incurring
  /// the memory usage of initializing WebView in long-lived processes that
  /// have no need for it, and to prevent potential data directory conflicts
  /// (see \#setDataDirectorySuffix).
  ///
  /// For example, an audio player application with one process for its
  /// activities and another process for its playback service may wish to call
  /// this method in the playback service's android.app.Service\#onCreate.
  ///@throws IllegalStateException if WebView has already been initialized
  ///                               in the current process.
  static void disableWebView() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_disableWebView, jni.JniType.voidType, []).check();

  static final _id_onChildViewAdded = jniAccessors.getMethodIDOf(_classRef,
      "onChildViewAdded", "(Landroid/view/View;Landroid/view/View;)V");

  /// from: public void onChildViewAdded(android.view.View parent, android.view.View child)
  ///
  /// @deprecated WebView no longer needs to implement
  /// ViewGroup.OnHierarchyChangeListener.  This method does nothing now.
  void onChildViewAdded(view_.View parent, view_.View child) =>
      jniAccessors.callMethodWithArgs(reference, _id_onChildViewAdded,
          jni.JniType.voidType, [parent.reference, child.reference]).check();

  static final _id_onChildViewRemoved = jniAccessors.getMethodIDOf(_classRef,
      "onChildViewRemoved", "(Landroid/view/View;Landroid/view/View;)V");

  /// from: public void onChildViewRemoved(android.view.View p, android.view.View child)
  ///
  /// @deprecated WebView no longer needs to implement
  /// ViewGroup.OnHierarchyChangeListener.  This method does nothing now.
  void onChildViewRemoved(view_.View p, view_.View child) =>
      jniAccessors.callMethodWithArgs(reference, _id_onChildViewRemoved,
          jni.JniType.voidType, [p.reference, child.reference]).check();

  static final _id_onGlobalFocusChanged = jniAccessors.getMethodIDOf(_classRef,
      "onGlobalFocusChanged", "(Landroid/view/View;Landroid/view/View;)V");

  /// from: public void onGlobalFocusChanged(android.view.View oldFocus, android.view.View newFocus)
  ///
  /// @deprecated WebView should not have implemented
  /// ViewTreeObserver.OnGlobalFocusChangeListener. This method does nothing now.
  void onGlobalFocusChanged(view_.View oldFocus, view_.View newFocus) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onGlobalFocusChanged,
          jni.JniType.voidType,
          [oldFocus.reference, newFocus.reference]).check();

  static final _id_setMapTrackballToArrowKeys = jniAccessors.getMethodIDOf(
      _classRef, "setMapTrackballToArrowKeys", "(Z)V");

  /// from: public void setMapTrackballToArrowKeys(boolean setMap)
  ///
  /// @deprecated Only the default case, {@code true}, will be supported in a future version.
  void setMapTrackballToArrowKeys(bool setMap) =>
      jniAccessors.callMethodWithArgs(reference, _id_setMapTrackballToArrowKeys,
          jni.JniType.voidType, [setMap]).check();

  static final _id_flingScroll =
      jniAccessors.getMethodIDOf(_classRef, "flingScroll", "(II)V");

  /// from: public void flingScroll(int vx, int vy)
  void flingScroll(int vx, int vy) => jniAccessors.callMethodWithArgs(
      reference, _id_flingScroll, jni.JniType.voidType, [vx, vy]).check();

  static final _id_canZoomIn =
      jniAccessors.getMethodIDOf(_classRef, "canZoomIn", "()Z");

  /// from: public boolean canZoomIn()
  ///
  /// Gets whether this WebView can be zoomed in.
  ///@return {@code true} if this WebView can be zoomed in
  ///@deprecated This method is prone to inaccuracy due to race conditions
  /// between the web rendering and UI threads; prefer
  /// WebViewClient\#onScaleChanged.
  bool canZoomIn() => jniAccessors.callMethodWithArgs(
      reference, _id_canZoomIn, jni.JniType.booleanType, []).boolean;

  static final _id_canZoomOut =
      jniAccessors.getMethodIDOf(_classRef, "canZoomOut", "()Z");

  /// from: public boolean canZoomOut()
  ///
  /// Gets whether this WebView can be zoomed out.
  ///@return {@code true} if this WebView can be zoomed out
  ///@deprecated This method is prone to inaccuracy due to race conditions
  /// between the web rendering and UI threads; prefer
  /// WebViewClient\#onScaleChanged.
  bool canZoomOut() => jniAccessors.callMethodWithArgs(
      reference, _id_canZoomOut, jni.JniType.booleanType, []).boolean;

  static final _id_zoomBy =
      jniAccessors.getMethodIDOf(_classRef, "zoomBy", "(F)V");

  /// from: public void zoomBy(float zoomFactor)
  ///
  /// Performs a zoom operation in this WebView.
  ///@param zoomFactor the zoom factor to apply. The zoom factor will be clamped to the WebView's
  /// zoom limits. This value must be in the range 0.01 to 100.0 inclusive.
  void zoomBy(double zoomFactor) => jniAccessors.callMethodWithArgs(
      reference, _id_zoomBy, jni.JniType.voidType, [zoomFactor]).check();

  static final _id_zoomIn =
      jniAccessors.getMethodIDOf(_classRef, "zoomIn", "()Z");

  /// from: public boolean zoomIn()
  ///
  /// Performs zoom in in this WebView.
  ///@return {@code true} if zoom in succeeds, {@code false} if no zoom changes
  bool zoomIn() => jniAccessors.callMethodWithArgs(
      reference, _id_zoomIn, jni.JniType.booleanType, []).boolean;

  static final _id_zoomOut =
      jniAccessors.getMethodIDOf(_classRef, "zoomOut", "()Z");

  /// from: public boolean zoomOut()
  ///
  /// Performs zoom out in this WebView.
  ///@return {@code true} if zoom out succeeds, {@code false} if no zoom changes
  bool zoomOut() => jniAccessors.callMethodWithArgs(
      reference, _id_zoomOut, jni.JniType.booleanType, []).boolean;

  static final _id_setRendererPriorityPolicy = jniAccessors.getMethodIDOf(
      _classRef, "setRendererPriorityPolicy", "(IZ)V");

  /// from: public void setRendererPriorityPolicy(int rendererRequestedPriority, boolean waivedWhenNotVisible)
  ///
  /// Set the renderer priority policy for this WebView. The
  /// priority policy will be used to determine whether an out of
  /// process renderer should be considered to be a target for OOM
  /// killing.
  ///
  /// Because a renderer can be associated with more than one
  /// WebView, the final priority it is computed as the maximum of
  /// any attached WebViews. When a WebView is destroyed it will
  /// cease to be considerered when calculating the renderer
  /// priority. Once no WebViews remain associated with the renderer,
  /// the priority of the renderer will be reduced to
  /// \#RENDERER_PRIORITY_WAIVED.
  ///
  /// The default policy is to set the priority to
  /// \#RENDERER_PRIORITY_IMPORTANT regardless of visibility,
  /// and this should not be changed unless the caller also handles
  /// renderer crashes with
  /// WebViewClient\#onRenderProcessGone. Any other setting
  /// will result in WebView renderers being killed by the system
  /// more aggressively than the application.
  ///@param rendererRequestedPriority the minimum priority at which
  ///        this WebView desires the renderer process to be bound.
  /// Value is android.webkit.WebView\#RENDERER_PRIORITY_WAIVED, android.webkit.WebView\#RENDERER_PRIORITY_BOUND, or android.webkit.WebView\#RENDERER_PRIORITY_IMPORTANT
  ///@param waivedWhenNotVisible if {@code true}, this flag specifies that
  ///        when this WebView is not visible, it will be treated as
  ///        if it had requested a priority of
  ///        \#RENDERER_PRIORITY_WAIVED.
  void setRendererPriorityPolicy(
          int rendererRequestedPriority, bool waivedWhenNotVisible) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setRendererPriorityPolicy,
          jni.JniType.voidType,
          [rendererRequestedPriority, waivedWhenNotVisible]).check();

  static final _id_getRendererRequestedPriority = jniAccessors.getMethodIDOf(
      _classRef, "getRendererRequestedPriority", "()I");

  /// from: public int getRendererRequestedPriority()
  ///
  /// Get the requested renderer priority for this WebView.
  ///@return the requested renderer priority policy.
  ///
  /// Value is android.webkit.WebView\#RENDERER_PRIORITY_WAIVED, android.webkit.WebView\#RENDERER_PRIORITY_BOUND, or android.webkit.WebView\#RENDERER_PRIORITY_IMPORTANT
  int getRendererRequestedPriority() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getRendererRequestedPriority,
      jni.JniType.intType, []).integer;

  static final _id_getRendererPriorityWaivedWhenNotVisible =
      jniAccessors.getMethodIDOf(
          _classRef, "getRendererPriorityWaivedWhenNotVisible", "()Z");

  /// from: public boolean getRendererPriorityWaivedWhenNotVisible()
  ///
  /// Return whether this WebView requests a priority of
  /// \#RENDERER_PRIORITY_WAIVED when not visible.
  ///@return whether this WebView requests a priority of
  /// \#RENDERER_PRIORITY_WAIVED when not visible.
  bool getRendererPriorityWaivedWhenNotVisible() =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getRendererPriorityWaivedWhenNotVisible,
          jni.JniType.booleanType, []).boolean;

  static final _id_setTextClassifier = jniAccessors.getMethodIDOf(_classRef,
      "setTextClassifier", "(Landroid/view/textclassifier/TextClassifier;)V");

  /// from: public void setTextClassifier(android.view.textclassifier.TextClassifier textClassifier)
  ///
  /// Sets the TextClassifier for this WebView.
  ///@param textClassifier This value may be {@code null}.
  void setTextClassifier(textclassifier_.TextClassifier textClassifier) =>
      jniAccessors.callMethodWithArgs(reference, _id_setTextClassifier,
          jni.JniType.voidType, [textClassifier.reference]).check();

  static final _id_getTextClassifier = jniAccessors.getMethodIDOf(_classRef,
      "getTextClassifier", "()Landroid/view/textclassifier/TextClassifier;");

  /// from: public android.view.textclassifier.TextClassifier getTextClassifier()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the TextClassifier used by this WebView.
  /// If no TextClassifier has been set, this WebView uses the default set by the system.
  ///@return This value will never be {@code null}.
  textclassifier_.TextClassifier getTextClassifier() =>
      textclassifier_.TextClassifier.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTextClassifier, jni.JniType.objectType, []).object);

  static final _id_getWebViewClassLoader = jniAccessors.getStaticMethodIDOf(
      _classRef, "getWebViewClassLoader", "()Ljava/lang/ClassLoader;");

  /// from: static public java.lang.ClassLoader getWebViewClassLoader()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the ClassLoader used to load internal WebView classes.
  /// This method is meant for use by the WebView Support Library, there is no reason to use this
  /// method otherwise.
  ///@return This value will never be {@code null}.
  static jni.JniObject getWebViewClassLoader() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(_classRef,
          _id_getWebViewClassLoader, jni.JniType.objectType, []).object);

  static final _id_getWebViewLooper = jniAccessors.getMethodIDOf(
      _classRef, "getWebViewLooper", "()Landroid/os/Looper;");

  /// from: public android.os.Looper getWebViewLooper()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Looper corresponding to the thread on which WebView calls must be made.
  ///@return This value will never be {@code null}.
  looper_.Looper getWebViewLooper() =>
      looper_.Looper.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getWebViewLooper, jni.JniType.objectType, []).object);

  static final _id_onAttachedToWindow1 =
      jniAccessors.getMethodIDOf(_classRef, "onAttachedToWindow", "()V");

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow1() => jniAccessors.callMethodWithArgs(
      reference, _id_onAttachedToWindow1, jni.JniType.voidType, []).check();

  static final _id_setLayoutParams1 = jniAccessors.getMethodIDOf(_classRef,
      "setLayoutParams", "(Landroid/view/ViewGroup\$LayoutParams;)V");

  /// from: public void setLayoutParams(android.view.ViewGroup.LayoutParams params)
  void setLayoutParams1(viewgroup_.ViewGroup_LayoutParams params) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLayoutParams1,
          jni.JniType.voidType, [params.reference]).check();

  static final _id_setOverScrollMode1 =
      jniAccessors.getMethodIDOf(_classRef, "setOverScrollMode", "(I)V");

  /// from: public void setOverScrollMode(int mode)
  void setOverScrollMode1(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setOverScrollMode1, jni.JniType.voidType, [mode]).check();

  static final _id_setScrollBarStyle1 =
      jniAccessors.getMethodIDOf(_classRef, "setScrollBarStyle", "(I)V");

  /// from: public void setScrollBarStyle(int style)
  void setScrollBarStyle1(int style) => jniAccessors.callMethodWithArgs(
      reference, _id_setScrollBarStyle1, jni.JniType.voidType, [style]).check();

  static final _id_computeHorizontalScrollRange1 = jniAccessors.getMethodIDOf(
      _classRef, "computeHorizontalScrollRange", "()I");

  /// from: protected int computeHorizontalScrollRange()
  int computeHorizontalScrollRange1() => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeHorizontalScrollRange1,
      jni.JniType.intType, []).integer;

  static final _id_computeHorizontalScrollOffset1 = jniAccessors.getMethodIDOf(
      _classRef, "computeHorizontalScrollOffset", "()I");

  /// from: protected int computeHorizontalScrollOffset()
  int computeHorizontalScrollOffset1() => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeHorizontalScrollOffset1,
      jni.JniType.intType, []).integer;

  static final _id_computeVerticalScrollRange1 = jniAccessors.getMethodIDOf(
      _classRef, "computeVerticalScrollRange", "()I");

  /// from: protected int computeVerticalScrollRange()
  int computeVerticalScrollRange1() => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeVerticalScrollRange1,
      jni.JniType.intType, []).integer;

  static final _id_computeVerticalScrollOffset1 = jniAccessors.getMethodIDOf(
      _classRef, "computeVerticalScrollOffset", "()I");

  /// from: protected int computeVerticalScrollOffset()
  int computeVerticalScrollOffset1() => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeVerticalScrollOffset1,
      jni.JniType.intType, []).integer;

  static final _id_computeVerticalScrollExtent1 = jniAccessors.getMethodIDOf(
      _classRef, "computeVerticalScrollExtent", "()I");

  /// from: protected int computeVerticalScrollExtent()
  int computeVerticalScrollExtent1() => jniAccessors.callMethodWithArgs(
      reference,
      _id_computeVerticalScrollExtent1,
      jni.JniType.intType, []).integer;

  static final _id_computeScroll1 =
      jniAccessors.getMethodIDOf(_classRef, "computeScroll", "()V");

  /// from: public void computeScroll()
  void computeScroll1() => jniAccessors.callMethodWithArgs(
      reference, _id_computeScroll1, jni.JniType.voidType, []).check();

  static final _id_onHoverEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "onHoverEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onHoverEvent(android.view.MotionEvent event)
  bool onHoverEvent1(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onHoverEvent1,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onTouchEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "onTouchEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTouchEvent(android.view.MotionEvent event)
  bool onTouchEvent1(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTouchEvent1,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onGenericMotionEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "onGenericMotionEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent event)
  bool onGenericMotionEvent1(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onGenericMotionEvent1,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onTrackballEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "onTrackballEvent", "(Landroid/view/MotionEvent;)Z");

  /// from: public boolean onTrackballEvent(android.view.MotionEvent event)
  bool onTrackballEvent1(motionevent_.MotionEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onTrackballEvent1,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onKeyDown1 = jniAccessors.getMethodIDOf(
      _classRef, "onKeyDown", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  bool onKeyDown1(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyDown1,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyUp1 = jniAccessors.getMethodIDOf(
      _classRef, "onKeyUp", "(ILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyUp(int keyCode, android.view.KeyEvent event)
  bool onKeyUp1(int keyCode, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onKeyUp1,
          jni.JniType.booleanType, [keyCode, event.reference]).boolean;

  static final _id_onKeyMultiple1 = jniAccessors.getMethodIDOf(
      _classRef, "onKeyMultiple", "(IILandroid/view/KeyEvent;)Z");

  /// from: public boolean onKeyMultiple(int keyCode, int repeatCount, android.view.KeyEvent event)
  bool onKeyMultiple1(int keyCode, int repeatCount, keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onKeyMultiple1,
          jni.JniType.booleanType,
          [keyCode, repeatCount, event.reference]).boolean;

  static final _id_getAccessibilityNodeProvider1 = jniAccessors.getMethodIDOf(
      _classRef,
      "getAccessibilityNodeProvider",
      "()Landroid/view/accessibility/AccessibilityNodeProvider;");

  /// from: public android.view.accessibility.AccessibilityNodeProvider getAccessibilityNodeProvider()
  /// The returned object must be deleted after use, by calling the `delete` method.
  accessibilitynodeprovider_.AccessibilityNodeProvider
      getAccessibilityNodeProvider1() =>
          accessibilitynodeprovider_.AccessibilityNodeProvider.fromRef(
              jniAccessors.callMethodWithArgs(
                  reference,
                  _id_getAccessibilityNodeProvider1,
                  jni.JniType.objectType, []).object);

  static final _id_shouldDelayChildPressedState = jniAccessors.getMethodIDOf(
      _classRef, "shouldDelayChildPressedState", "()Z");

  /// from: public boolean shouldDelayChildPressedState()
  bool shouldDelayChildPressedState() => jniAccessors.callMethodWithArgs(
      reference,
      _id_shouldDelayChildPressedState,
      jni.JniType.booleanType, []).boolean;

  static final _id_getAccessibilityClassName1 = jniAccessors.getMethodIDOf(
      _classRef, "getAccessibilityClassName", "()Ljava/lang/CharSequence;");

  /// from: public java.lang.CharSequence getAccessibilityClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getAccessibilityClassName1() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getAccessibilityClassName1, jni.JniType.objectType, []).object);

  static final _id_onProvideVirtualStructure1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onProvideVirtualStructure",
      "(Landroid/view/ViewStructure;)V");

  /// from: public void onProvideVirtualStructure(android.view.ViewStructure structure)
  void onProvideVirtualStructure1(viewstructure_.ViewStructure structure) =>
      jniAccessors.callMethodWithArgs(reference, _id_onProvideVirtualStructure1,
          jni.JniType.voidType, [structure.reference]).check();

  static final _id_onProvideAutofillVirtualStructure1 =
      jniAccessors.getMethodIDOf(_classRef, "onProvideAutofillVirtualStructure",
          "(Landroid/view/ViewStructure;I)V");

  /// from: public void onProvideAutofillVirtualStructure(android.view.ViewStructure structure, int flags)
  ///
  /// {@inheritDoc}
  ///
  /// The ViewStructure traditionally represents a View, while for web pages
  /// it represent HTML nodes. Hence, it's necessary to "map" the HTML properties in a way that is
  /// understood by the android.service.autofill.AutofillService implementations:
  ///
  /// <ol>
  ///   <li>Only the HTML nodes inside a {@code FORM} are generated.
  ///   <li>The source of the HTML is set using ViewStructure\#setWebDomain(String) in the
  ///   node representing the WebView.
  ///   <li>If a web page has multiple {@code FORM}s, only the data for the current form is
  ///   represented&mdash;if the user taps a field from another form, then the current autofill
  ///   context is canceled (by calling android.view.autofill.AutofillManager\#cancel() and
  ///   a new context is created for that {@code FORM}.
  ///   <li>Similarly, if the page has {@code IFRAME} nodes, they are not initially represented in
  ///   the view structure until the user taps a field from a {@code FORM} inside the
  ///   {@code IFRAME}, in which case it would be treated the same way as multiple forms described
  ///   above, except that the ViewStructure\#setWebDomain(String) web domain of the
  ///   {@code FORM} contains the {@code src} attribute from the {@code IFRAME} node.
  ///   <li>The W3C autofill field ({@code autocomplete} tag attribute) maps to
  ///   ViewStructure\#setAutofillHints(String[]).
  ///   <li>If the view is editable, the ViewStructure\#setAutofillType(int) and
  ///   ViewStructure\#setAutofillValue(AutofillValue) must be set.
  ///   <li>The {@code placeholder} attribute maps to ViewStructure\#setHint(CharSequence).
  ///   <li>Other HTML attributes can be represented through
  ///   ViewStructure\#setHtmlInfo(android.view.ViewStructure.HtmlInfo).
  /// </ol>
  ///
  /// If the WebView implementation can determine that the value of a field was set statically
  /// (for example, not through Javascript), it should also call
  /// {@code structure.setDataIsSensitive(false)}.
  ///
  /// For example, an HTML form with 2 fields for username and password:
  ///
  /// <pre class="prettyprint">
  ///    &lt;label&gt;Username:&lt;/label&gt;
  ///    &lt;input type="text" name="username" id="user" value="Type your username" autocomplete="username" placeholder="Email or username"&gt;
  ///    &lt;label&gt;Password:&lt;/label&gt;
  ///    &lt;input type="password" name="password" id="pass" autocomplete="current-password" placeholder="Password"&gt;
  /// </pre>
  ///
  /// Would map to:
  ///
  /// <pre class="prettyprint">
  ///     int index = structure.addChildCount(2);
  ///     ViewStructure username = structure.newChild(index);
  ///     username.setAutofillId(structure.getAutofillId(), 1); // id 1 - first child
  ///     username.setAutofillHints("username");
  ///     username.setHtmlInfo(username.newHtmlInfoBuilder("input")
  ///         .addAttribute("type", "text")
  ///         .addAttribute("name", "username")
  ///         .addAttribute("label", "Username:")
  ///         .build());
  ///     username.setHint("Email or username");
  ///     username.setAutofillType(View.AUTOFILL_TYPE_TEXT);
  ///     username.setAutofillValue(AutofillValue.forText("Type your username"));
  ///     // Value of the field is not sensitive because it was created statically and not changed.
  ///     username.setDataIsSensitive(false);
  ///
  ///     ViewStructure password = structure.newChild(index + 1);
  ///     username.setAutofillId(structure, 2); // id 2 - second child
  ///     password.setAutofillHints("current-password");
  ///     password.setHtmlInfo(password.newHtmlInfoBuilder("input")
  ///         .addAttribute("type", "password")
  ///         .addAttribute("name", "password")
  ///         .addAttribute("label", "Password:")
  ///         .build());
  ///     password.setHint("Password");
  ///     password.setAutofillType(View.AUTOFILL_TYPE_TEXT);
  /// </pre>
  void onProvideAutofillVirtualStructure1(
          viewstructure_.ViewStructure structure, int flags) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onProvideAutofillVirtualStructure1,
          jni.JniType.voidType,
          [structure.reference, flags]).check();

  static final _id_autofill2 = jniAccessors.getMethodIDOf(
      _classRef, "autofill", "(Landroid/util/SparseArray;)V");

  /// from: public void autofill(android.util.SparseArray<android.view.autofill.AutofillValue> values)
  void autofill2(sparsearray_.SparseArray values) =>
      jniAccessors.callMethodWithArgs(reference, _id_autofill2,
          jni.JniType.voidType, [values.reference]).check();

  static final _id_isVisibleToUserForAutofill1 = jniAccessors.getMethodIDOf(
      _classRef, "isVisibleToUserForAutofill", "(I)Z");

  /// from: public boolean isVisibleToUserForAutofill(int virtualId)
  bool isVisibleToUserForAutofill1(int virtualId) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_isVisibleToUserForAutofill1,
          jni.JniType.booleanType,
          [virtualId]).boolean;

  static final _id_onOverScrolled1 =
      jniAccessors.getMethodIDOf(_classRef, "onOverScrolled", "(IIZZ)V");

  /// from: protected void onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY)
  void onOverScrolled1(
          int scrollX, int scrollY, bool clampedX, bool clampedY) =>
      jniAccessors.callMethodWithArgs(reference, _id_onOverScrolled1,
          jni.JniType.voidType, [scrollX, scrollY, clampedX, clampedY]).check();

  static final _id_onWindowVisibilityChanged1 = jniAccessors.getMethodIDOf(
      _classRef, "onWindowVisibilityChanged", "(I)V");

  /// from: protected void onWindowVisibilityChanged(int visibility)
  void onWindowVisibilityChanged1(int visibility) =>
      jniAccessors.callMethodWithArgs(reference, _id_onWindowVisibilityChanged1,
          jni.JniType.voidType, [visibility]).check();

  static final _id_onDraw1 = jniAccessors.getMethodIDOf(
      _classRef, "onDraw", "(Landroid/graphics/Canvas;)V");

  /// from: protected void onDraw(android.graphics.Canvas canvas)
  void onDraw1(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference, _id_onDraw1, jni.JniType.voidType, [canvas.reference]).check();

  static final _id_performLongClick2 =
      jniAccessors.getMethodIDOf(_classRef, "performLongClick", "()Z");

  /// from: public boolean performLongClick()
  bool performLongClick2() => jniAccessors.callMethodWithArgs(
      reference, _id_performLongClick2, jni.JniType.booleanType, []).boolean;

  static final _id_onConfigurationChanged1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onConfigurationChanged",
      "(Landroid/content/res/Configuration;)V");

  /// from: protected void onConfigurationChanged(android.content.res.Configuration newConfig)
  void onConfigurationChanged1(configuration_.Configuration newConfig) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConfigurationChanged1,
          jni.JniType.voidType, [newConfig.reference]).check();

  static final _id_onCreateInputConnection1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onCreateInputConnection",
      "(Landroid/view/inputmethod/EditorInfo;)Landroid/view/inputmethod/InputConnection;");

  /// from: public android.view.inputmethod.InputConnection onCreateInputConnection(android.view.inputmethod.EditorInfo outAttrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new InputConnection for an InputMethod to interact with the WebView.
  /// This is similar to View\#onCreateInputConnection but note that WebView
  /// calls InputConnection methods on a thread other than the UI thread.
  /// If these methods are overridden, then the overriding methods should respect
  /// thread restrictions when calling View methods or accessing data.
  inputconnection_.InputConnection onCreateInputConnection1(
          editorinfo_.EditorInfo outAttrs) =>
      inputconnection_.InputConnection.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_onCreateInputConnection1,
          jni.JniType.objectType,
          [outAttrs.reference]).object);

  static final _id_onDragEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "onDragEvent", "(Landroid/view/DragEvent;)Z");

  /// from: public boolean onDragEvent(android.view.DragEvent event)
  bool onDragEvent1(dragevent_.DragEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_onDragEvent1,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_onVisibilityChanged1 = jniAccessors.getMethodIDOf(
      _classRef, "onVisibilityChanged", "(Landroid/view/View;I)V");

  /// from: protected void onVisibilityChanged(android.view.View changedView, int visibility)
  void onVisibilityChanged1(view_.View changedView, int visibility) =>
      jniAccessors.callMethodWithArgs(reference, _id_onVisibilityChanged1,
          jni.JniType.voidType, [changedView.reference, visibility]).check();

  static final _id_onWindowFocusChanged1 =
      jniAccessors.getMethodIDOf(_classRef, "onWindowFocusChanged", "(Z)V");

  /// from: public void onWindowFocusChanged(boolean hasWindowFocus)
  void onWindowFocusChanged1(bool hasWindowFocus) =>
      jniAccessors.callMethodWithArgs(reference, _id_onWindowFocusChanged1,
          jni.JniType.voidType, [hasWindowFocus]).check();

  static final _id_onFocusChanged1 = jniAccessors.getMethodIDOf(
      _classRef, "onFocusChanged", "(ZILandroid/graphics/Rect;)V");

  /// from: protected void onFocusChanged(boolean focused, int direction, android.graphics.Rect previouslyFocusedRect)
  void onFocusChanged1(
          bool focused, int direction, rect_.Rect previouslyFocusedRect) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onFocusChanged1,
          jni.JniType.voidType,
          [focused, direction, previouslyFocusedRect.reference]).check();

  static final _id_onSizeChanged1 =
      jniAccessors.getMethodIDOf(_classRef, "onSizeChanged", "(IIII)V");

  /// from: protected void onSizeChanged(int w, int h, int ow, int oh)
  void onSizeChanged1(int w, int h, int ow, int oh) =>
      jniAccessors.callMethodWithArgs(reference, _id_onSizeChanged1,
          jni.JniType.voidType, [w, h, ow, oh]).check();

  static final _id_onScrollChanged1 =
      jniAccessors.getMethodIDOf(_classRef, "onScrollChanged", "(IIII)V");

  /// from: protected void onScrollChanged(int l, int t, int oldl, int oldt)
  void onScrollChanged1(int l, int t, int oldl, int oldt) =>
      jniAccessors.callMethodWithArgs(reference, _id_onScrollChanged1,
          jni.JniType.voidType, [l, t, oldl, oldt]).check();

  static final _id_dispatchKeyEvent1 = jniAccessors.getMethodIDOf(
      _classRef, "dispatchKeyEvent", "(Landroid/view/KeyEvent;)Z");

  /// from: public boolean dispatchKeyEvent(android.view.KeyEvent event)
  bool dispatchKeyEvent1(keyevent_.KeyEvent event) =>
      jniAccessors.callMethodWithArgs(reference, _id_dispatchKeyEvent1,
          jni.JniType.booleanType, [event.reference]).boolean;

  static final _id_requestFocus3 = jniAccessors.getMethodIDOf(
      _classRef, "requestFocus", "(ILandroid/graphics/Rect;)Z");

  /// from: public boolean requestFocus(int direction, android.graphics.Rect previouslyFocusedRect)
  bool requestFocus3(int direction, rect_.Rect previouslyFocusedRect) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestFocus3,
          jni.JniType.booleanType,
          [direction, previouslyFocusedRect.reference]).boolean;

  static final _id_onMeasure1 =
      jniAccessors.getMethodIDOf(_classRef, "onMeasure", "(II)V");

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure1(int widthMeasureSpec, int heightMeasureSpec) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMeasure1,
          jni.JniType.voidType, [widthMeasureSpec, heightMeasureSpec]).check();

  static final _id_requestChildRectangleOnScreen1 = jniAccessors.getMethodIDOf(
      _classRef,
      "requestChildRectangleOnScreen",
      "(Landroid/view/View;Landroid/graphics/Rect;Z)Z");

  /// from: public boolean requestChildRectangleOnScreen(android.view.View child, android.graphics.Rect rect, boolean immediate)
  bool requestChildRectangleOnScreen1(
          view_.View child, rect_.Rect rect, bool immediate) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_requestChildRectangleOnScreen1,
          jni.JniType.booleanType,
          [child.reference, rect.reference, immediate]).boolean;

  static final _id_setBackgroundColor1 =
      jniAccessors.getMethodIDOf(_classRef, "setBackgroundColor", "(I)V");

  /// from: public void setBackgroundColor(int color)
  void setBackgroundColor1(int color) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setBackgroundColor1,
      jni.JniType.voidType,
      [color]).check();

  static final _id_setLayerType1 = jniAccessors.getMethodIDOf(
      _classRef, "setLayerType", "(ILandroid/graphics/Paint;)V");

  /// from: public void setLayerType(int layerType, android.graphics.Paint paint)
  void setLayerType1(int layerType, paint_.Paint paint) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLayerType1,
          jni.JniType.voidType, [layerType, paint.reference]).check();

  static final _id_dispatchDraw1 = jniAccessors.getMethodIDOf(
      _classRef, "dispatchDraw", "(Landroid/graphics/Canvas;)V");

  /// from: protected void dispatchDraw(android.graphics.Canvas canvas)
  void dispatchDraw1(canvas_.Canvas canvas) => jniAccessors.callMethodWithArgs(
      reference,
      _id_dispatchDraw1,
      jni.JniType.voidType,
      [canvas.reference]).check();

  static final _id_onStartTemporaryDetach1 =
      jniAccessors.getMethodIDOf(_classRef, "onStartTemporaryDetach", "()V");

  /// from: public void onStartTemporaryDetach()
  void onStartTemporaryDetach1() => jniAccessors.callMethodWithArgs(
      reference, _id_onStartTemporaryDetach1, jni.JniType.voidType, []).check();

  static final _id_onFinishTemporaryDetach1 =
      jniAccessors.getMethodIDOf(_classRef, "onFinishTemporaryDetach", "()V");

  /// from: public void onFinishTemporaryDetach()
  void onFinishTemporaryDetach1() => jniAccessors.callMethodWithArgs(reference,
      _id_onFinishTemporaryDetach1, jni.JniType.voidType, []).check();

  static final _id_getHandler1 = jniAccessors.getMethodIDOf(
      _classRef, "getHandler", "()Landroid/os/Handler;");

  /// from: public android.os.Handler getHandler()
  /// The returned object must be deleted after use, by calling the `delete` method.
  handler_.Handler getHandler1() =>
      handler_.Handler.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getHandler1, jni.JniType.objectType, []).object);

  static final _id_findFocus1 = jniAccessors.getMethodIDOf(
      _classRef, "findFocus", "()Landroid/view/View;");

  /// from: public android.view.View findFocus()
  /// The returned object must be deleted after use, by calling the `delete` method.
  view_.View findFocus1() => view_.View.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_findFocus1, jni.JniType.objectType, []).object);

  static final _id_getCurrentWebViewPackage = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getCurrentWebViewPackage",
      "()Landroid/content/pm/PackageInfo;");

  /// from: static public android.content.pm.PackageInfo getCurrentWebViewPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If WebView has already been loaded into the current process this method will return the
  /// package that was used to load it. Otherwise, the package that would be used if the WebView
  /// was loaded right now will be returned; this does not cause WebView to be loaded, so this
  /// information may become outdated at any time.
  /// The WebView package changes either when the current WebView package is updated, disabled, or
  /// uninstalled. It can also be changed through a Developer Setting.
  /// If the WebView package changes, any app process that has loaded WebView will be killed. The
  /// next time the app starts and loads WebView it will use the new WebView package instead.
  ///@return the current WebView package, or {@code null} if there is none.
  static packageinfo_.PackageInfo getCurrentWebViewPackage() =>
      packageinfo_.PackageInfo.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getCurrentWebViewPackage,
          jni.JniType.objectType, []).object);

  static final _id_onCheckIsTextEditor1 =
      jniAccessors.getMethodIDOf(_classRef, "onCheckIsTextEditor", "()Z");

  /// from: public boolean onCheckIsTextEditor()
  bool onCheckIsTextEditor1() => jniAccessors.callMethodWithArgs(
      reference, _id_onCheckIsTextEditor1, jni.JniType.booleanType, []).boolean;
}

/// from: android.webkit.WebView$WebViewTransport
///
/// Transportation object for returning WebView across thread boundaries.
class WebView_WebViewTransport extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/webkit/WebView\$WebViewTransport");
  WebView_WebViewTransport.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WebView_WebViewTransport()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setWebView = jniAccessors.getMethodIDOf(
      _classRef, "setWebView", "(Landroid/webkit/WebView;)V");

  /// from: synchronized public void setWebView(android.webkit.WebView webview)
  ///
  /// Sets the WebView to the transportation object.
  ///@param webview the WebView to transport
  void setWebView(WebView webview) => jniAccessors.callMethodWithArgs(reference,
      _id_setWebView, jni.JniType.voidType, [webview.reference]).check();

  static final _id_getWebView = jniAccessors.getMethodIDOf(
      _classRef, "getWebView", "()Landroid/webkit/WebView;");

  /// from: synchronized public android.webkit.WebView getWebView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the WebView object.
  ///@return the transported WebView object
  WebView getWebView() => WebView.fromRef(jniAccessors.callMethodWithArgs(
      reference, _id_getWebView, jni.JniType.objectType, []).object);
}

/// from: android.webkit.WebView$VisualStateCallback
///
/// Callback interface supplied to \#postVisualStateCallback for receiving
/// notifications about the visual state.
class WebView_VisualStateCallback extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/webkit/WebView\$VisualStateCallback");
  WebView_VisualStateCallback.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WebView_VisualStateCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onComplete =
      jniAccessors.getMethodIDOf(_classRef, "onComplete", "(J)V");

  /// from: public abstract void onComplete(long requestId)
  ///
  /// Invoked when the visual state is ready to be drawn in the next \#onDraw.
  ///@param requestId The identifier passed to \#postVisualStateCallback when this
  ///                  callback was posted.
  void onComplete(int requestId) => jniAccessors.callMethodWithArgs(
      reference, _id_onComplete, jni.JniType.voidType, [requestId]).check();
}

/// from: android.webkit.WebView$PictureListener
///
/// Interface to listen for new pictures as they change.
///@deprecated This interface is now obsolete.
class WebView_PictureListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/webkit/WebView\$PictureListener");
  WebView_PictureListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onNewPicture = jniAccessors.getMethodIDOf(_classRef,
      "onNewPicture", "(Landroid/webkit/WebView;Landroid/graphics/Picture;)V");

  /// from: public abstract void onNewPicture(android.webkit.WebView view, android.graphics.Picture picture)
  ///
  /// Used to provide notification that the WebView's picture has changed.
  /// See WebView\#capturePicture for details of the picture.
  ///@param view the WebView that owns the picture
  ///@param picture the new picture. Applications targeting
  ///     android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2 or above
  ///     will always receive a {@code null} Picture.
  /// This value may be {@code null}.
  ///@deprecated Deprecated due to internal changes.
  void onNewPicture(WebView view, picture_.Picture picture) =>
      jniAccessors.callMethodWithArgs(reference, _id_onNewPicture,
          jni.JniType.voidType, [view.reference, picture.reference]).check();
}

/// from: android.webkit.WebView$HitTestResult
class WebView_HitTestResult extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/webkit/WebView\$HitTestResult");
  WebView_HitTestResult.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int ANCHOR_TYPE
  ///
  /// @deprecated This type is no longer used.
  static const ANCHOR_TYPE = 1;

  /// from: static public final int EDIT_TEXT_TYPE
  ///
  /// HitTestResult for hitting an edit text area.
  static const EDIT_TEXT_TYPE = 9;

  /// from: static public final int EMAIL_TYPE
  ///
  /// HitTestResult for hitting an email address.
  static const EMAIL_TYPE = 4;

  /// from: static public final int GEO_TYPE
  ///
  /// HitTestResult for hitting a map address.
  static const GEO_TYPE = 3;

  /// from: static public final int IMAGE_ANCHOR_TYPE
  ///
  /// @deprecated This type is no longer used.
  static const IMAGE_ANCHOR_TYPE = 6;

  /// from: static public final int IMAGE_TYPE
  ///
  /// HitTestResult for hitting an HTML::img tag.
  static const IMAGE_TYPE = 5;

  /// from: static public final int PHONE_TYPE
  ///
  /// HitTestResult for hitting a phone number.
  static const PHONE_TYPE = 2;

  /// from: static public final int SRC_ANCHOR_TYPE
  ///
  /// HitTestResult for hitting a HTML::a tag with src=http.
  static const SRC_ANCHOR_TYPE = 7;

  /// from: static public final int SRC_IMAGE_ANCHOR_TYPE
  ///
  /// HitTestResult for hitting a HTML::a tag with src=http + HTML::img.
  static const SRC_IMAGE_ANCHOR_TYPE = 8;

  /// from: static public final int UNKNOWN_TYPE
  ///
  /// Default HitTestResult, where the target is unknown.
  static const UNKNOWN_TYPE = 0;

  static final _id_getType =
      jniAccessors.getMethodIDOf(_classRef, "getType", "()I");

  /// from: public int getType()
  ///
  /// Gets the type of the hit test result. See the XXX_TYPE constants
  /// defined in this class.
  ///@return the type of the hit test result
  int getType() => jniAccessors.callMethodWithArgs(
      reference, _id_getType, jni.JniType.intType, []).integer;

  static final _id_getExtra =
      jniAccessors.getMethodIDOf(_classRef, "getExtra", "()Ljava/lang/String;");

  /// from: public java.lang.String getExtra()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets additional type-dependant information about the result. See
  /// WebView\#getHitTestResult() for details. May either be {@code null}
  /// or contain extra information about this result.
  ///@return additional type-dependant information about the result
  jni.JniString getExtra() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getExtra, jni.JniType.objectType, []).object);
}

/// from: android.webkit.WebView$FindListener
///
/// Interface to listen for find results.
class WebView_FindListener extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/webkit/WebView\$FindListener");
  WebView_FindListener.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_onFindResultReceived =
      jniAccessors.getMethodIDOf(_classRef, "onFindResultReceived", "(IIZ)V");

  /// from: public abstract void onFindResultReceived(int activeMatchOrdinal, int numberOfMatches, boolean isDoneCounting)
  ///
  /// Notifies the listener about progress made by a find operation.
  ///@param activeMatchOrdinal the zero-based ordinal of the currently selected match
  ///@param numberOfMatches how many matches have been found
  ///@param isDoneCounting whether the find operation has actually completed. The listener
  ///                       may be notified multiple times while the
  ///                       operation is underway, and the numberOfMatches
  ///                       value should not be considered final unless
  ///                       isDoneCounting is {@code true}.
  void onFindResultReceived(
          int activeMatchOrdinal, int numberOfMatches, bool isDoneCounting) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onFindResultReceived,
          jni.JniType.voidType,
          [activeMatchOrdinal, numberOfMatches, isDoneCounting]).check();
}
