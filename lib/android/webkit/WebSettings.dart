// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.webkit.WebSettings
///
/// Manages settings state for a WebView. When a WebView is first created, it
/// obtains a set of default settings. These default settings will be returned
/// from any getter call. A {@code WebSettings} object obtained from
/// WebView\#getSettings() is tied to the life of the WebView. If a WebView has
/// been destroyed, any method call on {@code WebSettings} will throw an
/// IllegalStateException.
class WebSettings extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/webkit/WebSettings");
  WebSettings.fromRef(jni.JObject ref) : super.fromRef(ref);

  /// from: static public final int LOAD_CACHE_ELSE_NETWORK
  ///
  /// Use cached resources when they are available, even if they have expired.
  /// Otherwise load resources from the network.
  /// Use with \#setCacheMode.
  static const LOAD_CACHE_ELSE_NETWORK = 1;

  /// from: static public final int LOAD_CACHE_ONLY
  ///
  /// Don't use the network, load from the cache.
  /// Use with \#setCacheMode.
  static const LOAD_CACHE_ONLY = 3;

  /// from: static public final int LOAD_DEFAULT
  ///
  /// Default cache usage mode. If the navigation type doesn't impose any
  /// specific behavior, use cached resources when they are available
  /// and not expired, otherwise load resources from the network.
  /// Use with \#setCacheMode.
  static const LOAD_DEFAULT = -1;

  /// from: static public final int LOAD_NORMAL
  ///
  /// Normal cache usage mode. Use with \#setCacheMode.
  ///@deprecated This value is obsolete, as from API level
  /// android.os.Build.VERSION_CODES\#HONEYCOMB and onwards it has the
  /// same effect as \#LOAD_DEFAULT.
  static const LOAD_NORMAL = 0;

  /// from: static public final int LOAD_NO_CACHE
  ///
  /// Don't use the cache, load from the network.
  /// Use with \#setCacheMode.
  static const LOAD_NO_CACHE = 2;

  /// from: static public final int MENU_ITEM_NONE
  ///
  /// Used with \#setDisabledActionModeMenuItems.
  ///
  /// No menu items should be disabled.
  static const MENU_ITEM_NONE = 0;

  /// from: static public final int MENU_ITEM_PROCESS_TEXT
  ///
  /// Used with \#setDisabledActionModeMenuItems.
  ///
  /// Disable all the action mode menu items for text processing.
  /// By default WebView searches for activities that are able to handle
  /// android.content.Intent\#ACTION_PROCESS_TEXT and show them in the
  /// action mode menu. If this flag is set via \#setDisabledActionModeMenuItems, these menu items will be disabled.
  static const MENU_ITEM_PROCESS_TEXT = 4;

  /// from: static public final int MENU_ITEM_SHARE
  ///
  /// Used with \#setDisabledActionModeMenuItems.
  ///
  /// Disable menu item "Share".
  static const MENU_ITEM_SHARE = 1;

  /// from: static public final int MENU_ITEM_WEB_SEARCH
  ///
  /// Used with \#setDisabledActionModeMenuItems.
  ///
  /// Disable menu item "Web Search".
  static const MENU_ITEM_WEB_SEARCH = 2;

  /// from: static public final int MIXED_CONTENT_ALWAYS_ALLOW
  ///
  /// Used with \#setMixedContentMode
  ///
  /// In this mode, the WebView will allow a secure origin to load content from any other origin,
  /// even if that origin is insecure. This is the least secure mode of operation for the WebView,
  /// and where possible apps should not set this mode.
  static const MIXED_CONTENT_ALWAYS_ALLOW = 0;

  /// from: static public final int MIXED_CONTENT_COMPATIBILITY_MODE
  ///
  /// Used with \#setMixedContentMode
  ///
  /// In this mode, the WebView will attempt to be compatible with the approach of a modern web
  /// browser with regard to mixed content. Some insecure content may be allowed to be loaded by
  /// a secure origin and other types of content will be blocked. The types of content are allowed
  /// or blocked may change release to release and are not explicitly defined.
  ///
  /// This mode is intended to be used by apps that are not in control of the content that they
  /// render but desire to operate in a reasonably secure environment. For highest security, apps
  /// are recommended to use \#MIXED_CONTENT_NEVER_ALLOW.
  static const MIXED_CONTENT_COMPATIBILITY_MODE = 2;

  /// from: static public final int MIXED_CONTENT_NEVER_ALLOW
  ///
  /// Used with \#setMixedContentMode
  ///
  /// In this mode, the WebView will not allow a secure origin to load content from an insecure
  /// origin. This is the preferred and most secure mode of operation for the WebView and apps are
  /// strongly advised to use this mode.
  static const MIXED_CONTENT_NEVER_ALLOW = 1;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WebSettings()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_setSupportZoom =
      jniAccessors.getMethodIDOf(_classRef, "setSupportZoom", "(Z)V");

  /// from: public abstract void setSupportZoom(boolean support)
  ///
  /// Sets whether the WebView should support zooming using its on-screen zoom
  /// controls and gestures. The particular zoom mechanisms that should be used
  /// can be set with \#setBuiltInZoomControls. This setting does not
  /// affect zooming performed using the WebView\#zoomIn() and
  /// WebView\#zoomOut() methods. The default is {@code true}.
  ///@param support whether the WebView should support zoom
  void setSupportZoom(bool support) => jniAccessors.callMethodWithArgs(
      reference, _id_setSupportZoom, jni.JniType.voidType, [support]).check();

  static final _id_supportZoom =
      jniAccessors.getMethodIDOf(_classRef, "supportZoom", "()Z");

  /// from: public abstract boolean supportZoom()
  ///
  /// Gets whether the WebView supports zoom.
  ///@return {@code true} if the WebView supports zoom
  ///@see \#setSupportZoom
  bool supportZoom() => jniAccessors.callMethodWithArgs(
      reference, _id_supportZoom, jni.JniType.booleanType, []).boolean;

  static final _id_setMediaPlaybackRequiresUserGesture = jniAccessors
      .getMethodIDOf(_classRef, "setMediaPlaybackRequiresUserGesture", "(Z)V");

  /// from: public abstract void setMediaPlaybackRequiresUserGesture(boolean require)
  ///
  /// Sets whether the WebView requires a user gesture to play media.
  /// The default is {@code true}.
  ///@param require whether the WebView requires a user gesture to play media
  void setMediaPlaybackRequiresUserGesture(bool require) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setMediaPlaybackRequiresUserGesture,
          jni.JniType.voidType,
          [require]).check();

  static final _id_getMediaPlaybackRequiresUserGesture = jniAccessors
      .getMethodIDOf(_classRef, "getMediaPlaybackRequiresUserGesture", "()Z");

  /// from: public abstract boolean getMediaPlaybackRequiresUserGesture()
  ///
  /// Gets whether the WebView requires a user gesture to play media.
  ///@return {@code true} if the WebView requires a user gesture to play media
  ///@see \#setMediaPlaybackRequiresUserGesture
  bool getMediaPlaybackRequiresUserGesture() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getMediaPlaybackRequiresUserGesture,
      jni.JniType.booleanType, []).boolean;

  static final _id_setBuiltInZoomControls =
      jniAccessors.getMethodIDOf(_classRef, "setBuiltInZoomControls", "(Z)V");

  /// from: public abstract void setBuiltInZoomControls(boolean enabled)
  ///
  /// Sets whether the WebView should use its built-in zoom mechanisms. The
  /// built-in zoom mechanisms comprise on-screen zoom controls, which are
  /// displayed over the WebView's content, and the use of a pinch gesture to
  /// control zooming. Whether or not these on-screen controls are displayed
  /// can be set with \#setDisplayZoomControls. The default is {@code false}.
  ///
  /// The built-in mechanisms are the only currently supported zoom
  /// mechanisms, so it is recommended that this setting is always enabled.
  ///@param enabled whether the WebView should use its built-in zoom mechanisms
  void setBuiltInZoomControls(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setBuiltInZoomControls,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_getBuiltInZoomControls =
      jniAccessors.getMethodIDOf(_classRef, "getBuiltInZoomControls", "()Z");

  /// from: public abstract boolean getBuiltInZoomControls()
  ///
  /// Gets whether the zoom mechanisms built into WebView are being used.
  ///@return {@code true} if the zoom mechanisms built into WebView are being used
  ///@see \#setBuiltInZoomControls
  bool getBuiltInZoomControls() => jniAccessors.callMethodWithArgs(reference,
      _id_getBuiltInZoomControls, jni.JniType.booleanType, []).boolean;

  static final _id_setDisplayZoomControls =
      jniAccessors.getMethodIDOf(_classRef, "setDisplayZoomControls", "(Z)V");

  /// from: public abstract void setDisplayZoomControls(boolean enabled)
  ///
  /// Sets whether the WebView should display on-screen zoom controls when
  /// using the built-in zoom mechanisms. See \#setBuiltInZoomControls.
  /// The default is {@code true}.
  ///@param enabled whether the WebView should display on-screen zoom controls
  void setDisplayZoomControls(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDisplayZoomControls,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_getDisplayZoomControls =
      jniAccessors.getMethodIDOf(_classRef, "getDisplayZoomControls", "()Z");

  /// from: public abstract boolean getDisplayZoomControls()
  ///
  /// Gets whether the WebView displays on-screen zoom controls when using
  /// the built-in zoom mechanisms.
  ///@return {@code true} if the WebView displays on-screen zoom controls when using
  ///         the built-in zoom mechanisms
  ///@see \#setDisplayZoomControls
  bool getDisplayZoomControls() => jniAccessors.callMethodWithArgs(reference,
      _id_getDisplayZoomControls, jni.JniType.booleanType, []).boolean;

  static final _id_setAllowFileAccess =
      jniAccessors.getMethodIDOf(_classRef, "setAllowFileAccess", "(Z)V");

  /// from: public abstract void setAllowFileAccess(boolean allow)
  ///
  /// Enables or disables file access within WebView. File access is enabled by
  /// default.  Note that this enables or disables file system access only.
  /// Assets and resources are still accessible using file:///android_asset and
  /// file:///android_res.
  void setAllowFileAccess(bool allow) => jniAccessors.callMethodWithArgs(
      reference, _id_setAllowFileAccess, jni.JniType.voidType, [allow]).check();

  static final _id_getAllowFileAccess =
      jniAccessors.getMethodIDOf(_classRef, "getAllowFileAccess", "()Z");

  /// from: public abstract boolean getAllowFileAccess()
  ///
  /// Gets whether this WebView supports file access.
  ///@see \#setAllowFileAccess
  bool getAllowFileAccess() => jniAccessors.callMethodWithArgs(
      reference, _id_getAllowFileAccess, jni.JniType.booleanType, []).boolean;

  static final _id_setAllowContentAccess =
      jniAccessors.getMethodIDOf(_classRef, "setAllowContentAccess", "(Z)V");

  /// from: public abstract void setAllowContentAccess(boolean allow)
  ///
  /// Enables or disables content URL access within WebView.  Content URL
  /// access allows WebView to load content from a content provider installed
  /// in the system. The default is enabled.
  void setAllowContentAccess(bool allow) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setAllowContentAccess,
      jni.JniType.voidType,
      [allow]).check();

  static final _id_getAllowContentAccess =
      jniAccessors.getMethodIDOf(_classRef, "getAllowContentAccess", "()Z");

  /// from: public abstract boolean getAllowContentAccess()
  ///
  /// Gets whether this WebView supports content URL access.
  ///@see \#setAllowContentAccess
  bool getAllowContentAccess() => jniAccessors.callMethodWithArgs(reference,
      _id_getAllowContentAccess, jni.JniType.booleanType, []).boolean;

  static final _id_setLoadWithOverviewMode =
      jniAccessors.getMethodIDOf(_classRef, "setLoadWithOverviewMode", "(Z)V");

  /// from: public abstract void setLoadWithOverviewMode(boolean overview)
  ///
  /// Sets whether the WebView loads pages in overview mode, that is,
  /// zooms out the content to fit on screen by width. This setting is
  /// taken into account when the content width is greater than the width
  /// of the WebView control, for example, when \#getUseWideViewPort
  /// is enabled. The default is {@code false}.
  void setLoadWithOverviewMode(bool overview) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLoadWithOverviewMode,
          jni.JniType.voidType, [overview]).check();

  static final _id_getLoadWithOverviewMode =
      jniAccessors.getMethodIDOf(_classRef, "getLoadWithOverviewMode", "()Z");

  /// from: public abstract boolean getLoadWithOverviewMode()
  ///
  /// Gets whether this WebView loads pages in overview mode.
  ///@return whether this WebView loads pages in overview mode
  ///@see \#setLoadWithOverviewMode
  bool getLoadWithOverviewMode() => jniAccessors.callMethodWithArgs(reference,
      _id_getLoadWithOverviewMode, jni.JniType.booleanType, []).boolean;

  static final _id_setEnableSmoothTransition = jniAccessors.getMethodIDOf(
      _classRef, "setEnableSmoothTransition", "(Z)V");

  /// from: public abstract void setEnableSmoothTransition(boolean enable)
  ///
  /// Sets whether the WebView will enable smooth transition while panning or
  /// zooming or while the window hosting the WebView does not have focus.
  /// If it is {@code true}, WebView will choose a solution to maximize the performance.
  /// e.g. the WebView's content may not be updated during the transition.
  /// If it is false, WebView will keep its fidelity. The default value is {@code false}.
  ///@deprecated This method is now obsolete, and will become a no-op in future.
  void setEnableSmoothTransition(bool enable) =>
      jniAccessors.callMethodWithArgs(reference, _id_setEnableSmoothTransition,
          jni.JniType.voidType, [enable]).check();

  static final _id_enableSmoothTransition =
      jniAccessors.getMethodIDOf(_classRef, "enableSmoothTransition", "()Z");

  /// from: public abstract boolean enableSmoothTransition()
  ///
  /// Gets whether the WebView enables smooth transition while panning or
  /// zooming.
  ///@see \#setEnableSmoothTransition
  ///@deprecated This method is now obsolete, and will become a no-op in future.
  bool enableSmoothTransition() => jniAccessors.callMethodWithArgs(reference,
      _id_enableSmoothTransition, jni.JniType.booleanType, []).boolean;

  static final _id_setSaveFormData =
      jniAccessors.getMethodIDOf(_classRef, "setSaveFormData", "(Z)V");

  /// from: public abstract void setSaveFormData(boolean save)
  ///
  /// Sets whether the WebView should save form data. In Android O, the
  /// platform has implemented a fully functional Autofill feature to store
  /// form data. Therefore, the Webview form data save feature is disabled.
  ///
  /// Note that the feature will continue to be supported on older versions of
  /// Android as before.
  ///
  /// This function does not have any effect.
  void setSaveFormData(bool save) => jniAccessors.callMethodWithArgs(
      reference, _id_setSaveFormData, jni.JniType.voidType, [save]).check();

  static final _id_getSaveFormData =
      jniAccessors.getMethodIDOf(_classRef, "getSaveFormData", "()Z");

  /// from: public abstract boolean getSaveFormData()
  ///
  /// Gets whether the WebView saves form data.
  ///@return whether the WebView saves form data
  ///@see \#setSaveFormData
  bool getSaveFormData() => jniAccessors.callMethodWithArgs(
      reference, _id_getSaveFormData, jni.JniType.booleanType, []).boolean;

  static final _id_setSavePassword =
      jniAccessors.getMethodIDOf(_classRef, "setSavePassword", "(Z)V");

  /// from: public abstract void setSavePassword(boolean save)
  ///
  /// Sets whether the WebView should save passwords. The default is {@code true}.
  ///@deprecated Saving passwords in WebView will not be supported in future versions.
  void setSavePassword(bool save) => jniAccessors.callMethodWithArgs(
      reference, _id_setSavePassword, jni.JniType.voidType, [save]).check();

  static final _id_getSavePassword =
      jniAccessors.getMethodIDOf(_classRef, "getSavePassword", "()Z");

  /// from: public abstract boolean getSavePassword()
  ///
  /// Gets whether the WebView saves passwords.
  ///@return whether the WebView saves passwords
  ///@see \#setSavePassword
  ///@deprecated Saving passwords in WebView will not be supported in future versions.
  bool getSavePassword() => jniAccessors.callMethodWithArgs(
      reference, _id_getSavePassword, jni.JniType.booleanType, []).boolean;

  static final _id_setTextZoom =
      jniAccessors.getMethodIDOf(_classRef, "setTextZoom", "(I)V");

  /// from: public abstract void setTextZoom(int textZoom)
  ///
  /// Sets the text zoom of the page in percent. The default is 100.
  ///@param textZoom the text zoom in percent
  void setTextZoom(int textZoom) => jniAccessors.callMethodWithArgs(
      reference, _id_setTextZoom, jni.JniType.voidType, [textZoom]).check();

  static final _id_getTextZoom =
      jniAccessors.getMethodIDOf(_classRef, "getTextZoom", "()I");

  /// from: public abstract int getTextZoom()
  ///
  /// Gets the text zoom of the page in percent.
  ///@return the text zoom of the page in percent
  ///@see \#setTextZoom
  int getTextZoom() => jniAccessors.callMethodWithArgs(
      reference, _id_getTextZoom, jni.JniType.intType, []).integer;

  static final _id_setTextSize = jniAccessors.getMethodIDOf(
      _classRef, "setTextSize", "(Landroid/webkit/WebSettings\$TextSize;)V");

  /// from: synchronized public void setTextSize(android.webkit.WebSettings.TextSize t)
  ///
  /// Sets the text size of the page. The default is TextSize\#NORMAL.
  ///@param t the text size as a TextSize value
  ///@deprecated Use \#setTextZoom instead.
  void setTextSize(WebSettings_TextSize t) => jniAccessors.callMethodWithArgs(
      reference, _id_setTextSize, jni.JniType.voidType, [t.reference]).check();

  static final _id_getTextSize = jniAccessors.getMethodIDOf(
      _classRef, "getTextSize", "()Landroid/webkit/WebSettings\$TextSize;");

  /// from: synchronized public android.webkit.WebSettings.TextSize getTextSize()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the text size of the page. If the text size was previously specified
  /// in percent using \#setTextZoom, this will return the closest
  /// matching TextSize.
  ///@return the text size as a TextSize value
  ///@see \#setTextSize
  ///@deprecated Use \#getTextZoom instead.
  WebSettings_TextSize getTextSize() =>
      WebSettings_TextSize.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTextSize, jni.JniType.objectType, []).object);

  static final _id_setDefaultZoom = jniAccessors.getMethodIDOf(_classRef,
      "setDefaultZoom", "(Landroid/webkit/WebSettings\$ZoomDensity;)V");

  /// from: public abstract void setDefaultZoom(android.webkit.WebSettings.ZoomDensity zoom)
  ///
  /// Sets the default zoom density of the page. This must be called from the UI
  /// thread. The default is ZoomDensity\#MEDIUM.
  ///
  /// This setting is not recommended for use in new applications.  If the WebView
  /// is utilized to display mobile-oriented pages, the desired effect can be achieved by
  /// adjusting 'width' and 'initial-scale' attributes of page's 'meta viewport'
  /// tag. For pages lacking the tag, android.webkit.WebView\#setInitialScale
  /// and \#setUseWideViewPort can be used.
  ///@param zoom the zoom density
  ///@deprecated This method is no longer supported, see the function documentation for
  ///             recommended alternatives.
  void setDefaultZoom(WebSettings_ZoomDensity zoom) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDefaultZoom,
          jni.JniType.voidType, [zoom.reference]).check();

  static final _id_getDefaultZoom = jniAccessors.getMethodIDOf(_classRef,
      "getDefaultZoom", "()Landroid/webkit/WebSettings\$ZoomDensity;");

  /// from: public abstract android.webkit.WebSettings.ZoomDensity getDefaultZoom()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the default zoom density of the page. This should be called from
  /// the UI thread.
  ///
  /// This setting is not recommended for use in new applications.
  ///@return the zoom density
  ///@see \#setDefaultZoom
  ///@deprecated Will only return the default value.
  WebSettings_ZoomDensity getDefaultZoom() =>
      WebSettings_ZoomDensity.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDefaultZoom, jni.JniType.objectType, []).object);

  static final _id_setLightTouchEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setLightTouchEnabled", "(Z)V");

  /// from: public abstract void setLightTouchEnabled(boolean enabled)
  ///
  /// Enables using light touches to make a selection and activate mouseovers.
  ///@deprecated From android.os.Build.VERSION_CODES\#JELLY_BEAN this
  ///             setting is obsolete and has no effect.
  void setLightTouchEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setLightTouchEnabled,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_getLightTouchEnabled =
      jniAccessors.getMethodIDOf(_classRef, "getLightTouchEnabled", "()Z");

  /// from: public abstract boolean getLightTouchEnabled()
  ///
  /// Gets whether light touches are enabled.
  ///@see \#setLightTouchEnabled
  ///@deprecated This setting is obsolete.
  bool getLightTouchEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_getLightTouchEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setUseWideViewPort =
      jniAccessors.getMethodIDOf(_classRef, "setUseWideViewPort", "(Z)V");

  /// from: public abstract void setUseWideViewPort(boolean use)
  ///
  /// Sets whether the WebView should enable support for the &quot;viewport&quot;
  /// HTML meta tag or should use a wide viewport.
  /// When the value of the setting is {@code false}, the layout width is always set to the
  /// width of the WebView control in device-independent (CSS) pixels.
  /// When the value is {@code true} and the page contains the viewport meta tag, the value
  /// of the width specified in the tag is used. If the page does not contain the tag or
  /// does not provide a width, then a wide viewport will be used.
  ///@param use whether to enable support for the viewport meta tag
  void setUseWideViewPort(bool use) => jniAccessors.callMethodWithArgs(
      reference, _id_setUseWideViewPort, jni.JniType.voidType, [use]).check();

  static final _id_getUseWideViewPort =
      jniAccessors.getMethodIDOf(_classRef, "getUseWideViewPort", "()Z");

  /// from: public abstract boolean getUseWideViewPort()
  ///
  /// Gets whether the WebView supports the &quot;viewport&quot;
  /// HTML meta tag or will use a wide viewport.
  ///@return {@code true} if the WebView supports the viewport meta tag
  ///@see \#setUseWideViewPort
  bool getUseWideViewPort() => jniAccessors.callMethodWithArgs(
      reference, _id_getUseWideViewPort, jni.JniType.booleanType, []).boolean;

  static final _id_setSupportMultipleWindows = jniAccessors.getMethodIDOf(
      _classRef, "setSupportMultipleWindows", "(Z)V");

  /// from: public abstract void setSupportMultipleWindows(boolean support)
  ///
  /// Sets whether the WebView whether supports multiple windows. If set to
  /// true, WebChromeClient\#onCreateWindow must be implemented by the
  /// host application. The default is {@code false}.
  ///@param support whether to support multiple windows
  void setSupportMultipleWindows(bool support) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSupportMultipleWindows,
          jni.JniType.voidType, [support]).check();

  static final _id_supportMultipleWindows =
      jniAccessors.getMethodIDOf(_classRef, "supportMultipleWindows", "()Z");

  /// from: public abstract boolean supportMultipleWindows()
  ///
  /// Gets whether the WebView supports multiple windows.
  ///@return {@code true} if the WebView supports multiple windows
  ///@see \#setSupportMultipleWindows
  bool supportMultipleWindows() => jniAccessors.callMethodWithArgs(reference,
      _id_supportMultipleWindows, jni.JniType.booleanType, []).boolean;

  static final _id_setLayoutAlgorithm = jniAccessors.getMethodIDOf(_classRef,
      "setLayoutAlgorithm", "(Landroid/webkit/WebSettings\$LayoutAlgorithm;)V");

  /// from: public abstract void setLayoutAlgorithm(android.webkit.WebSettings.LayoutAlgorithm l)
  ///
  /// Sets the underlying layout algorithm. This will cause a re-layout of the
  /// WebView. The default is LayoutAlgorithm\#NARROW_COLUMNS.
  ///@param l the layout algorithm to use, as a LayoutAlgorithm value
  void setLayoutAlgorithm(WebSettings_LayoutAlgorithm l) =>
      jniAccessors.callMethodWithArgs(reference, _id_setLayoutAlgorithm,
          jni.JniType.voidType, [l.reference]).check();

  static final _id_getLayoutAlgorithm = jniAccessors.getMethodIDOf(_classRef,
      "getLayoutAlgorithm", "()Landroid/webkit/WebSettings\$LayoutAlgorithm;");

  /// from: public abstract android.webkit.WebSettings.LayoutAlgorithm getLayoutAlgorithm()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current layout algorithm.
  ///@return the layout algorithm in use, as a LayoutAlgorithm value
  ///@see \#setLayoutAlgorithm
  WebSettings_LayoutAlgorithm getLayoutAlgorithm() =>
      WebSettings_LayoutAlgorithm.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getLayoutAlgorithm,
          jni.JniType.objectType, []).object);

  static final _id_setStandardFontFamily = jniAccessors.getMethodIDOf(
      _classRef, "setStandardFontFamily", "(Ljava/lang/String;)V");

  /// from: public abstract void setStandardFontFamily(java.lang.String font)
  ///
  /// Sets the standard font family name. The default is "sans-serif".
  ///@param font a font family name
  void setStandardFontFamily(jni.JniString font) =>
      jniAccessors.callMethodWithArgs(reference, _id_setStandardFontFamily,
          jni.JniType.voidType, [font.reference]).check();

  static final _id_getStandardFontFamily = jniAccessors.getMethodIDOf(
      _classRef, "getStandardFontFamily", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getStandardFontFamily()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the standard font family name.
  ///@return the standard font family name as a string
  ///@see \#setStandardFontFamily
  jni.JniString getStandardFontFamily() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getStandardFontFamily, jni.JniType.objectType, []).object);

  static final _id_setFixedFontFamily = jniAccessors.getMethodIDOf(
      _classRef, "setFixedFontFamily", "(Ljava/lang/String;)V");

  /// from: public abstract void setFixedFontFamily(java.lang.String font)
  ///
  /// Sets the fixed font family name. The default is "monospace".
  ///@param font a font family name
  void setFixedFontFamily(jni.JniString font) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFixedFontFamily,
          jni.JniType.voidType, [font.reference]).check();

  static final _id_getFixedFontFamily = jniAccessors.getMethodIDOf(
      _classRef, "getFixedFontFamily", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getFixedFontFamily()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the fixed font family name.
  ///@return the fixed font family name as a string
  ///@see \#setFixedFontFamily
  jni.JniString getFixedFontFamily() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getFixedFontFamily, jni.JniType.objectType, []).object);

  static final _id_setSansSerifFontFamily = jniAccessors.getMethodIDOf(
      _classRef, "setSansSerifFontFamily", "(Ljava/lang/String;)V");

  /// from: public abstract void setSansSerifFontFamily(java.lang.String font)
  ///
  /// Sets the sans-serif font family name. The default is "sans-serif".
  ///@param font a font family name
  void setSansSerifFontFamily(jni.JniString font) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSansSerifFontFamily,
          jni.JniType.voidType, [font.reference]).check();

  static final _id_getSansSerifFontFamily = jniAccessors.getMethodIDOf(
      _classRef, "getSansSerifFontFamily", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getSansSerifFontFamily()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the sans-serif font family name.
  ///@return the sans-serif font family name as a string
  ///@see \#setSansSerifFontFamily
  jni.JniString getSansSerifFontFamily() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSansSerifFontFamily, jni.JniType.objectType, []).object);

  static final _id_setSerifFontFamily = jniAccessors.getMethodIDOf(
      _classRef, "setSerifFontFamily", "(Ljava/lang/String;)V");

  /// from: public abstract void setSerifFontFamily(java.lang.String font)
  ///
  /// Sets the serif font family name. The default is "sans-serif".
  ///@param font a font family name
  void setSerifFontFamily(jni.JniString font) =>
      jniAccessors.callMethodWithArgs(reference, _id_setSerifFontFamily,
          jni.JniType.voidType, [font.reference]).check();

  static final _id_getSerifFontFamily = jniAccessors.getMethodIDOf(
      _classRef, "getSerifFontFamily", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getSerifFontFamily()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the serif font family name. The default is "serif".
  ///@return the serif font family name as a string
  ///@see \#setSerifFontFamily
  jni.JniString getSerifFontFamily() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getSerifFontFamily, jni.JniType.objectType, []).object);

  static final _id_setCursiveFontFamily = jniAccessors.getMethodIDOf(
      _classRef, "setCursiveFontFamily", "(Ljava/lang/String;)V");

  /// from: public abstract void setCursiveFontFamily(java.lang.String font)
  ///
  /// Sets the cursive font family name. The default is "cursive".
  ///@param font a font family name
  void setCursiveFontFamily(jni.JniString font) =>
      jniAccessors.callMethodWithArgs(reference, _id_setCursiveFontFamily,
          jni.JniType.voidType, [font.reference]).check();

  static final _id_getCursiveFontFamily = jniAccessors.getMethodIDOf(
      _classRef, "getCursiveFontFamily", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getCursiveFontFamily()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the cursive font family name.
  ///@return the cursive font family name as a string
  ///@see \#setCursiveFontFamily
  jni.JniString getCursiveFontFamily() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getCursiveFontFamily, jni.JniType.objectType, []).object);

  static final _id_setFantasyFontFamily = jniAccessors.getMethodIDOf(
      _classRef, "setFantasyFontFamily", "(Ljava/lang/String;)V");

  /// from: public abstract void setFantasyFontFamily(java.lang.String font)
  ///
  /// Sets the fantasy font family name. The default is "fantasy".
  ///@param font a font family name
  void setFantasyFontFamily(jni.JniString font) =>
      jniAccessors.callMethodWithArgs(reference, _id_setFantasyFontFamily,
          jni.JniType.voidType, [font.reference]).check();

  static final _id_getFantasyFontFamily = jniAccessors.getMethodIDOf(
      _classRef, "getFantasyFontFamily", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getFantasyFontFamily()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the fantasy font family name.
  ///@return the fantasy font family name as a string
  ///@see \#setFantasyFontFamily
  jni.JniString getFantasyFontFamily() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getFantasyFontFamily, jni.JniType.objectType, []).object);

  static final _id_setMinimumFontSize =
      jniAccessors.getMethodIDOf(_classRef, "setMinimumFontSize", "(I)V");

  /// from: public abstract void setMinimumFontSize(int size)
  ///
  /// Sets the minimum font size. The default is 8.
  ///@param size a non-negative integer between 1 and 72. Any number outside
  ///             the specified range will be pinned.
  void setMinimumFontSize(int size) => jniAccessors.callMethodWithArgs(
      reference, _id_setMinimumFontSize, jni.JniType.voidType, [size]).check();

  static final _id_getMinimumFontSize =
      jniAccessors.getMethodIDOf(_classRef, "getMinimumFontSize", "()I");

  /// from: public abstract int getMinimumFontSize()
  ///
  /// Gets the minimum font size.
  ///@return a non-negative integer between 1 and 72
  ///@see \#setMinimumFontSize
  int getMinimumFontSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getMinimumFontSize, jni.JniType.intType, []).integer;

  static final _id_setMinimumLogicalFontSize = jniAccessors.getMethodIDOf(
      _classRef, "setMinimumLogicalFontSize", "(I)V");

  /// from: public abstract void setMinimumLogicalFontSize(int size)
  ///
  /// Sets the minimum logical font size. The default is 8.
  ///@param size a non-negative integer between 1 and 72. Any number outside
  ///             the specified range will be pinned.
  void setMinimumLogicalFontSize(int size) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setMinimumLogicalFontSize,
      jni.JniType.voidType,
      [size]).check();

  static final _id_getMinimumLogicalFontSize =
      jniAccessors.getMethodIDOf(_classRef, "getMinimumLogicalFontSize", "()I");

  /// from: public abstract int getMinimumLogicalFontSize()
  ///
  /// Gets the minimum logical font size.
  ///@return a non-negative integer between 1 and 72
  ///@see \#setMinimumLogicalFontSize
  int getMinimumLogicalFontSize() => jniAccessors.callMethodWithArgs(reference,
      _id_getMinimumLogicalFontSize, jni.JniType.intType, []).integer;

  static final _id_setDefaultFontSize =
      jniAccessors.getMethodIDOf(_classRef, "setDefaultFontSize", "(I)V");

  /// from: public abstract void setDefaultFontSize(int size)
  ///
  /// Sets the default font size. The default is 16.
  ///@param size a non-negative integer between 1 and 72. Any number outside
  ///             the specified range will be pinned.
  void setDefaultFontSize(int size) => jniAccessors.callMethodWithArgs(
      reference, _id_setDefaultFontSize, jni.JniType.voidType, [size]).check();

  static final _id_getDefaultFontSize =
      jniAccessors.getMethodIDOf(_classRef, "getDefaultFontSize", "()I");

  /// from: public abstract int getDefaultFontSize()
  ///
  /// Gets the default font size.
  ///@return a non-negative integer between 1 and 72
  ///@see \#setDefaultFontSize
  int getDefaultFontSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getDefaultFontSize, jni.JniType.intType, []).integer;

  static final _id_setDefaultFixedFontSize =
      jniAccessors.getMethodIDOf(_classRef, "setDefaultFixedFontSize", "(I)V");

  /// from: public abstract void setDefaultFixedFontSize(int size)
  ///
  /// Sets the default fixed font size. The default is 16.
  ///@param size a non-negative integer between 1 and 72. Any number outside
  ///             the specified range will be pinned.
  void setDefaultFixedFontSize(int size) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDefaultFixedFontSize,
      jni.JniType.voidType,
      [size]).check();

  static final _id_getDefaultFixedFontSize =
      jniAccessors.getMethodIDOf(_classRef, "getDefaultFixedFontSize", "()I");

  /// from: public abstract int getDefaultFixedFontSize()
  ///
  /// Gets the default fixed font size.
  ///@return a non-negative integer between 1 and 72
  ///@see \#setDefaultFixedFontSize
  int getDefaultFixedFontSize() => jniAccessors.callMethodWithArgs(
      reference, _id_getDefaultFixedFontSize, jni.JniType.intType, []).integer;

  static final _id_setLoadsImagesAutomatically = jniAccessors.getMethodIDOf(
      _classRef, "setLoadsImagesAutomatically", "(Z)V");

  /// from: public abstract void setLoadsImagesAutomatically(boolean flag)
  ///
  /// Sets whether the WebView should load image resources. Note that this method
  /// controls loading of all images, including those embedded using the data
  /// URI scheme. Use \#setBlockNetworkImage to control loading only
  /// of images specified using network URI schemes. Note that if the value of this
  /// setting is changed from {@code false} to {@code true}, all images resources referenced
  /// by content currently displayed by the WebView are loaded automatically.
  /// The default is {@code true}.
  ///@param flag whether the WebView should load image resources
  void setLoadsImagesAutomatically(bool flag) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setLoadsImagesAutomatically,
          jni.JniType.voidType,
          [flag]).check();

  static final _id_getLoadsImagesAutomatically = jniAccessors.getMethodIDOf(
      _classRef, "getLoadsImagesAutomatically", "()Z");

  /// from: public abstract boolean getLoadsImagesAutomatically()
  ///
  /// Gets whether the WebView loads image resources. This includes
  /// images embedded using the data URI scheme.
  ///@return {@code true} if the WebView loads image resources
  ///@see \#setLoadsImagesAutomatically
  bool getLoadsImagesAutomatically() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getLoadsImagesAutomatically,
      jni.JniType.booleanType, []).boolean;

  static final _id_setBlockNetworkImage =
      jniAccessors.getMethodIDOf(_classRef, "setBlockNetworkImage", "(Z)V");

  /// from: public abstract void setBlockNetworkImage(boolean flag)
  ///
  /// Sets whether the WebView should not load image resources from the
  /// network (resources accessed via http and https URI schemes).  Note
  /// that this method has no effect unless
  /// \#getLoadsImagesAutomatically returns {@code true}. Also note that
  /// disabling all network loads using \#setBlockNetworkLoads
  /// will also prevent network images from loading, even if this flag is set
  /// to false. When the value of this setting is changed from {@code true} to {@code false},
  /// network images resources referenced by content currently displayed by
  /// the WebView are fetched automatically. The default is {@code false}.
  ///@param flag whether the WebView should not load image resources from the
  ///             network
  ///@see \#setBlockNetworkLoads
  void setBlockNetworkImage(bool flag) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setBlockNetworkImage,
      jni.JniType.voidType,
      [flag]).check();

  static final _id_getBlockNetworkImage =
      jniAccessors.getMethodIDOf(_classRef, "getBlockNetworkImage", "()Z");

  /// from: public abstract boolean getBlockNetworkImage()
  ///
  /// Gets whether the WebView does not load image resources from the network.
  ///@return {@code true} if the WebView does not load image resources from the network
  ///@see \#setBlockNetworkImage
  bool getBlockNetworkImage() => jniAccessors.callMethodWithArgs(
      reference, _id_getBlockNetworkImage, jni.JniType.booleanType, []).boolean;

  static final _id_setBlockNetworkLoads =
      jniAccessors.getMethodIDOf(_classRef, "setBlockNetworkLoads", "(Z)V");

  /// from: public abstract void setBlockNetworkLoads(boolean flag)
  ///
  /// Sets whether the WebView should not load resources from the network.
  /// Use \#setBlockNetworkImage to only avoid loading
  /// image resources. Note that if the value of this setting is
  /// changed from {@code true} to {@code false}, network resources referenced by content
  /// currently displayed by the WebView are not fetched until
  /// android.webkit.WebView\#reload is called.
  /// If the application does not have the
  /// android.Manifest.permission\#INTERNET permission, attempts to set
  /// a value of {@code false} will cause a java.lang.SecurityException
  /// to be thrown. The default value is {@code false} if the application has the
  /// android.Manifest.permission\#INTERNET permission, otherwise it is
  /// {@code true}.
  ///@param flag {@code true} means block network loads by the WebView
  ///@see android.webkit.WebView\#reload
  void setBlockNetworkLoads(bool flag) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setBlockNetworkLoads,
      jni.JniType.voidType,
      [flag]).check();

  static final _id_getBlockNetworkLoads =
      jniAccessors.getMethodIDOf(_classRef, "getBlockNetworkLoads", "()Z");

  /// from: public abstract boolean getBlockNetworkLoads()
  ///
  /// Gets whether the WebView does not load any resources from the network.
  ///@return {@code true} if the WebView does not load any resources from the network
  ///@see \#setBlockNetworkLoads
  bool getBlockNetworkLoads() => jniAccessors.callMethodWithArgs(
      reference, _id_getBlockNetworkLoads, jni.JniType.booleanType, []).boolean;

  static final _id_setJavaScriptEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setJavaScriptEnabled", "(Z)V");

  /// from: public abstract void setJavaScriptEnabled(boolean flag)
  ///
  /// Tells the WebView to enable JavaScript execution.
  /// __The default is {@code false}.__
  ///@param flag {@code true} if the WebView should execute JavaScript
  void setJavaScriptEnabled(bool flag) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setJavaScriptEnabled,
      jni.JniType.voidType,
      [flag]).check();

  static final _id_setAllowUniversalAccessFromFileURLs = jniAccessors
      .getMethodIDOf(_classRef, "setAllowUniversalAccessFromFileURLs", "(Z)V");

  /// from: public abstract void setAllowUniversalAccessFromFileURLs(boolean flag)
  ///
  /// Sets whether JavaScript running in the context of a file scheme URL
  /// should be allowed to access content from any origin. This includes
  /// access to content from other file scheme URLs. See
  /// \#setAllowFileAccessFromFileURLs. To enable the most restrictive,
  /// and therefore secure policy, this setting should be disabled.
  /// Note that this setting affects only JavaScript access to file scheme
  /// resources. Other access to such resources, for example, from image HTML
  /// elements, is unaffected. To prevent possible violation of same domain policy
  /// when targeting android.os.Build.VERSION_CODES\#ICE_CREAM_SANDWICH_MR1 and earlier,
  /// you should explicitly set this value to {@code false}.
  ///
  /// The default value is {@code true} for apps targeting
  /// android.os.Build.VERSION_CODES\#ICE_CREAM_SANDWICH_MR1 and below,
  /// and {@code false} when targeting android.os.Build.VERSION_CODES\#JELLY_BEAN
  /// and above.
  ///@param flag whether JavaScript running in the context of a file scheme
  ///             URL should be allowed to access content from any origin
  void setAllowUniversalAccessFromFileURLs(bool flag) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAllowUniversalAccessFromFileURLs,
          jni.JniType.voidType,
          [flag]).check();

  static final _id_setAllowFileAccessFromFileURLs = jniAccessors.getMethodIDOf(
      _classRef, "setAllowFileAccessFromFileURLs", "(Z)V");

  /// from: public abstract void setAllowFileAccessFromFileURLs(boolean flag)
  ///
  /// Sets whether JavaScript running in the context of a file scheme URL
  /// should be allowed to access content from other file scheme URLs. To
  /// enable the most restrictive, and therefore secure, policy this setting
  /// should be disabled. Note that the value of this setting is ignored if
  /// the value of \#getAllowUniversalAccessFromFileURLs is {@code true}.
  /// Note too, that this setting affects only JavaScript access to file scheme
  /// resources. Other access to such resources, for example, from image HTML
  /// elements, is unaffected. To prevent possible violation of same domain policy
  /// when targeting android.os.Build.VERSION_CODES\#ICE_CREAM_SANDWICH_MR1 and earlier,
  /// you should explicitly set this value to {@code false}.
  ///
  /// The default value is {@code true} for apps targeting
  /// android.os.Build.VERSION_CODES\#ICE_CREAM_SANDWICH_MR1 and below,
  /// and {@code false} when targeting android.os.Build.VERSION_CODES\#JELLY_BEAN
  /// and above.
  ///@param flag whether JavaScript running in the context of a file scheme
  ///             URL should be allowed to access content from other file
  ///             scheme URLs
  void setAllowFileAccessFromFileURLs(bool flag) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setAllowFileAccessFromFileURLs,
          jni.JniType.voidType,
          [flag]).check();

  static final _id_setPluginState = jniAccessors.getMethodIDOf(_classRef,
      "setPluginState", "(Landroid/webkit/WebSettings\$PluginState;)V");

  /// from: public abstract void setPluginState(android.webkit.WebSettings.PluginState state)
  ///
  /// Tells the WebView to enable, disable, or have plugins on demand. On
  /// demand mode means that if a plugin exists that can handle the embedded
  /// content, a placeholder icon will be shown instead of the plugin. When
  /// the placeholder is clicked, the plugin will be enabled. The default is
  /// PluginState\#OFF.
  ///@param state a PluginState value
  ///@deprecated Plugins will not be supported in future, and should not be used.
  void setPluginState(WebSettings_PluginState state) =>
      jniAccessors.callMethodWithArgs(reference, _id_setPluginState,
          jni.JniType.voidType, [state.reference]).check();

  static final _id_setDatabasePath = jniAccessors.getMethodIDOf(
      _classRef, "setDatabasePath", "(Ljava/lang/String;)V");

  /// from: public abstract void setDatabasePath(java.lang.String databasePath)
  ///
  /// Sets the path to where database storage API databases should be saved.
  /// In order for the database storage API to function correctly, this method
  /// must be called with a path to which the application can write. This
  /// method should only be called once: repeated calls are ignored.
  ///@param databasePath a path to the directory where databases should be
  ///                     saved.
  ///@deprecated Database paths are managed by the implementation and calling this method
  ///             will have no effect.
  void setDatabasePath(jni.JniString databasePath) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDatabasePath,
          jni.JniType.voidType, [databasePath.reference]).check();

  static final _id_setGeolocationDatabasePath = jniAccessors.getMethodIDOf(
      _classRef, "setGeolocationDatabasePath", "(Ljava/lang/String;)V");

  /// from: public abstract void setGeolocationDatabasePath(java.lang.String databasePath)
  ///
  /// Sets the path where the Geolocation databases should be saved. In order
  /// for Geolocation permissions and cached positions to be persisted, this
  /// method must be called with a path to which the application can write.
  ///@param databasePath a path to the directory where databases should be
  ///                     saved.
  ///@deprecated Geolocation database are managed by the implementation and calling this method
  ///             will have no effect.
  void setGeolocationDatabasePath(jni.JniString databasePath) =>
      jniAccessors.callMethodWithArgs(reference, _id_setGeolocationDatabasePath,
          jni.JniType.voidType, [databasePath.reference]).check();

  static final _id_setAppCacheEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setAppCacheEnabled", "(Z)V");

  /// from: public abstract void setAppCacheEnabled(boolean flag)
  ///
  /// Sets whether the Application Caches API should be enabled. The default
  /// is {@code false}. Note that in order for the Application Caches API to be
  /// enabled, a valid database path must also be supplied to
  /// \#setAppCachePath.
  ///@param flag {@code true} if the WebView should enable Application Caches
  void setAppCacheEnabled(bool flag) => jniAccessors.callMethodWithArgs(
      reference, _id_setAppCacheEnabled, jni.JniType.voidType, [flag]).check();

  static final _id_setAppCachePath = jniAccessors.getMethodIDOf(
      _classRef, "setAppCachePath", "(Ljava/lang/String;)V");

  /// from: public abstract void setAppCachePath(java.lang.String appCachePath)
  ///
  /// Sets the path to the Application Caches files. In order for the
  /// Application Caches API to be enabled, this method must be called with a
  /// path to which the application can write. This method should only be
  /// called once: repeated calls are ignored.
  ///@param appCachePath a String path to the directory containing
  ///                     Application Caches files.
  ///@see \#setAppCacheEnabled
  void setAppCachePath(jni.JniString appCachePath) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAppCachePath,
          jni.JniType.voidType, [appCachePath.reference]).check();

  static final _id_setAppCacheMaxSize =
      jniAccessors.getMethodIDOf(_classRef, "setAppCacheMaxSize", "(J)V");

  /// from: public abstract void setAppCacheMaxSize(long appCacheMaxSize)
  ///
  /// Sets the maximum size for the Application Cache content. The passed size
  /// will be rounded to the nearest value that the database can support, so
  /// this should be viewed as a guide, not a hard limit. Setting the
  /// size to a value less than current database size does not cause the
  /// database to be trimmed. The default size is Long\#MAX_VALUE.
  /// It is recommended to leave the maximum size set to the default value.
  ///@param appCacheMaxSize the maximum size in bytes
  ///@deprecated In future quota will be managed automatically.
  void setAppCacheMaxSize(int appCacheMaxSize) =>
      jniAccessors.callMethodWithArgs(reference, _id_setAppCacheMaxSize,
          jni.JniType.voidType, [appCacheMaxSize]).check();

  static final _id_setDatabaseEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setDatabaseEnabled", "(Z)V");

  /// from: public abstract void setDatabaseEnabled(boolean flag)
  ///
  /// Sets whether the database storage API is enabled. The default value is
  /// false. See also \#setDatabasePath for how to correctly set up the
  /// database storage API.
  ///
  /// This setting is global in effect, across all WebView instances in a process.
  /// Note you should only modify this setting prior to making __any__ WebView
  /// page load within a given process, as the WebView implementation may ignore
  /// changes to this setting after that point.
  ///@param flag {@code true} if the WebView should use the database storage API
  void setDatabaseEnabled(bool flag) => jniAccessors.callMethodWithArgs(
      reference, _id_setDatabaseEnabled, jni.JniType.voidType, [flag]).check();

  static final _id_setDomStorageEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setDomStorageEnabled", "(Z)V");

  /// from: public abstract void setDomStorageEnabled(boolean flag)
  ///
  /// Sets whether the DOM storage API is enabled. The default value is {@code false}.
  ///@param flag {@code true} if the WebView should use the DOM storage API
  void setDomStorageEnabled(bool flag) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setDomStorageEnabled,
      jni.JniType.voidType,
      [flag]).check();

  static final _id_getDomStorageEnabled =
      jniAccessors.getMethodIDOf(_classRef, "getDomStorageEnabled", "()Z");

  /// from: public abstract boolean getDomStorageEnabled()
  ///
  /// Gets whether the DOM Storage APIs are enabled.
  ///@return {@code true} if the DOM Storage APIs are enabled
  ///@see \#setDomStorageEnabled
  bool getDomStorageEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_getDomStorageEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_getDatabasePath = jniAccessors.getMethodIDOf(
      _classRef, "getDatabasePath", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getDatabasePath()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the path to where database storage API databases are saved.
  ///@return the String path to the database storage API databases
  ///@see \#setDatabasePath
  ///@deprecated Database paths are managed by the implementation this method is obsolete.
  jni.JniString getDatabasePath() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDatabasePath, jni.JniType.objectType, []).object);

  static final _id_getDatabaseEnabled =
      jniAccessors.getMethodIDOf(_classRef, "getDatabaseEnabled", "()Z");

  /// from: public abstract boolean getDatabaseEnabled()
  ///
  /// Gets whether the database storage API is enabled.
  ///@return {@code true} if the database storage API is enabled
  ///@see \#setDatabaseEnabled
  bool getDatabaseEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_getDatabaseEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setGeolocationEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setGeolocationEnabled", "(Z)V");

  /// from: public abstract void setGeolocationEnabled(boolean flag)
  ///
  /// Sets whether Geolocation is enabled. The default is {@code true}.
  ///
  /// Please note that in order for the Geolocation API to be usable
  /// by a page in the WebView, the following requirements must be met:
  /// <ul>
  ///   <li>an application must have permission to access the device location,
  ///   see android.Manifest.permission\#ACCESS_COARSE_LOCATION,
  ///   android.Manifest.permission\#ACCESS_FINE_LOCATION;
  ///   <li>an application must provide an implementation of the
  ///   WebChromeClient\#onGeolocationPermissionsShowPrompt callback
  ///   to receive notifications that a page is requesting access to location
  ///   via the JavaScript Geolocation API.
  /// </ul>
  ///
  ///@param flag whether Geolocation should be enabled
  void setGeolocationEnabled(bool flag) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setGeolocationEnabled,
      jni.JniType.voidType,
      [flag]).check();

  static final _id_getJavaScriptEnabled =
      jniAccessors.getMethodIDOf(_classRef, "getJavaScriptEnabled", "()Z");

  /// from: public abstract boolean getJavaScriptEnabled()
  ///
  /// Gets whether JavaScript is enabled.
  ///@return {@code true} if JavaScript is enabled
  ///@see \#setJavaScriptEnabled
  bool getJavaScriptEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_getJavaScriptEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_getAllowUniversalAccessFromFileURLs = jniAccessors
      .getMethodIDOf(_classRef, "getAllowUniversalAccessFromFileURLs", "()Z");

  /// from: public abstract boolean getAllowUniversalAccessFromFileURLs()
  ///
  /// Gets whether JavaScript running in the context of a file scheme URL can
  /// access content from any origin. This includes access to content from
  /// other file scheme URLs.
  ///@return whether JavaScript running in the context of a file scheme URL
  ///         can access content from any origin
  ///@see \#setAllowUniversalAccessFromFileURLs
  bool getAllowUniversalAccessFromFileURLs() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getAllowUniversalAccessFromFileURLs,
      jni.JniType.booleanType, []).boolean;

  static final _id_getAllowFileAccessFromFileURLs = jniAccessors.getMethodIDOf(
      _classRef, "getAllowFileAccessFromFileURLs", "()Z");

  /// from: public abstract boolean getAllowFileAccessFromFileURLs()
  ///
  /// Gets whether JavaScript running in the context of a file scheme URL can
  /// access content from other file scheme URLs.
  ///@return whether JavaScript running in the context of a file scheme URL
  ///         can access content from other file scheme URLs
  ///@see \#setAllowFileAccessFromFileURLs
  bool getAllowFileAccessFromFileURLs() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getAllowFileAccessFromFileURLs,
      jni.JniType.booleanType, []).boolean;

  static final _id_getPluginState = jniAccessors.getMethodIDOf(_classRef,
      "getPluginState", "()Landroid/webkit/WebSettings\$PluginState;");

  /// from: public abstract android.webkit.WebSettings.PluginState getPluginState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current state regarding whether plugins are enabled.
  ///@return the plugin state as a PluginState value
  ///@see \#setPluginState
  ///@deprecated Plugins will not be supported in future, and should not be used.
  WebSettings_PluginState getPluginState() =>
      WebSettings_PluginState.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getPluginState, jni.JniType.objectType, []).object);

  static final _id_setJavaScriptCanOpenWindowsAutomatically =
      jniAccessors.getMethodIDOf(
          _classRef, "setJavaScriptCanOpenWindowsAutomatically", "(Z)V");

  /// from: public abstract void setJavaScriptCanOpenWindowsAutomatically(boolean flag)
  ///
  /// Tells JavaScript to open windows automatically. This applies to the
  /// JavaScript function {@code window.open()}. The default is {@code false}.
  ///@param flag {@code true} if JavaScript can open windows automatically
  void setJavaScriptCanOpenWindowsAutomatically(bool flag) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setJavaScriptCanOpenWindowsAutomatically,
          jni.JniType.voidType,
          [flag]).check();

  static final _id_getJavaScriptCanOpenWindowsAutomatically =
      jniAccessors.getMethodIDOf(
          _classRef, "getJavaScriptCanOpenWindowsAutomatically", "()Z");

  /// from: public abstract boolean getJavaScriptCanOpenWindowsAutomatically()
  ///
  /// Gets whether JavaScript can open windows automatically.
  ///@return {@code true} if JavaScript can open windows automatically during
  ///         {@code window.open()}
  ///@see \#setJavaScriptCanOpenWindowsAutomatically
  bool getJavaScriptCanOpenWindowsAutomatically() =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getJavaScriptCanOpenWindowsAutomatically,
          jni.JniType.booleanType, []).boolean;

  static final _id_setDefaultTextEncodingName = jniAccessors.getMethodIDOf(
      _classRef, "setDefaultTextEncodingName", "(Ljava/lang/String;)V");

  /// from: public abstract void setDefaultTextEncodingName(java.lang.String encoding)
  ///
  /// Sets the default text encoding name to use when decoding html pages.
  /// The default is "UTF-8".
  ///@param encoding the text encoding name
  void setDefaultTextEncodingName(jni.JniString encoding) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDefaultTextEncodingName,
          jni.JniType.voidType, [encoding.reference]).check();

  static final _id_getDefaultTextEncodingName = jniAccessors.getMethodIDOf(
      _classRef, "getDefaultTextEncodingName", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getDefaultTextEncodingName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the default text encoding name.
  ///@return the default text encoding name as a string
  ///@see \#setDefaultTextEncodingName
  jni.JniString getDefaultTextEncodingName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDefaultTextEncodingName, jni.JniType.objectType, []).object);

  static final _id_setUserAgentString = jniAccessors.getMethodIDOf(
      _classRef, "setUserAgentString", "(Ljava/lang/String;)V");

  /// from: public abstract void setUserAgentString(java.lang.String ua)
  ///
  /// Sets the WebView's user-agent string. If the string is {@code null} or empty,
  /// the system default value will be used.
  ///
  /// Note that starting from android.os.Build.VERSION_CODES\#KITKAT Android
  /// version, changing the user-agent while loading a web page causes WebView
  /// to initiate loading once again.
  ///@param ua new user-agent string
  ///
  /// This value may be {@code null}.
  void setUserAgentString(jni.JniString ua) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setUserAgentString,
      jni.JniType.voidType,
      [ua.reference]).check();

  static final _id_getUserAgentString = jniAccessors.getMethodIDOf(
      _classRef, "getUserAgentString", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getUserAgentString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the WebView's user-agent string.
  ///@return the WebView's user-agent string
  ///@see \#setUserAgentString
  jni.JniString getUserAgentString() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getUserAgentString, jni.JniType.objectType, []).object);

  static final _id_getDefaultUserAgent = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "getDefaultUserAgent",
      "(Landroid/content/Context;)Ljava/lang/String;");

  /// from: static public java.lang.String getDefaultUserAgent(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the default User-Agent used by a WebView.
  /// An instance of WebView could use a different User-Agent if a call
  /// is made to WebSettings\#setUserAgentString(String).
  ///@param context a Context object used to access application assets
  static jni.JniString getDefaultUserAgent(context_.Context context) =>
      jni.JniString.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getDefaultUserAgent,
          jni.JniType.objectType,
          [context.reference]).object);

  static final _id_setNeedInitialFocus =
      jniAccessors.getMethodIDOf(_classRef, "setNeedInitialFocus", "(Z)V");

  /// from: public abstract void setNeedInitialFocus(boolean flag)
  ///
  /// Tells the WebView whether it needs to set a node to have focus when
  /// WebView\#requestFocus(int, android.graphics.Rect) is called. The
  /// default value is {@code true}.
  ///@param flag whether the WebView needs to set a node
  void setNeedInitialFocus(bool flag) => jniAccessors.callMethodWithArgs(
      reference, _id_setNeedInitialFocus, jni.JniType.voidType, [flag]).check();

  static final _id_setRenderPriority = jniAccessors.getMethodIDOf(_classRef,
      "setRenderPriority", "(Landroid/webkit/WebSettings\$RenderPriority;)V");

  /// from: public abstract void setRenderPriority(android.webkit.WebSettings.RenderPriority priority)
  ///
  /// Sets the priority of the Render thread. Unlike the other settings, this
  /// one only needs to be called once per process. The default value is
  /// RenderPriority\#NORMAL.
  ///@param priority the priority
  ///@deprecated It is not recommended to adjust thread priorities, and this will
  ///             not be supported in future versions.
  void setRenderPriority(WebSettings_RenderPriority priority) =>
      jniAccessors.callMethodWithArgs(reference, _id_setRenderPriority,
          jni.JniType.voidType, [priority.reference]).check();

  static final _id_setCacheMode =
      jniAccessors.getMethodIDOf(_classRef, "setCacheMode", "(I)V");

  /// from: public abstract void setCacheMode(int mode)
  ///
  /// Overrides the way the cache is used. The way the cache is used is based
  /// on the navigation type. For a normal page load, the cache is checked
  /// and content is re-validated as needed. When navigating back, content is
  /// not revalidated, instead the content is just retrieved from the cache.
  /// This method allows the client to override this behavior by specifying
  /// one of \#LOAD_DEFAULT,
  /// \#LOAD_CACHE_ELSE_NETWORK, \#LOAD_NO_CACHE or
  /// \#LOAD_CACHE_ONLY. The default value is \#LOAD_DEFAULT.
  ///@param mode the mode to use
  ///
  /// Value is android.webkit.WebSettings\#LOAD_DEFAULT, android.webkit.WebSettings\#LOAD_NORMAL, android.webkit.WebSettings\#LOAD_CACHE_ELSE_NETWORK, android.webkit.WebSettings\#LOAD_NO_CACHE, or android.webkit.WebSettings\#LOAD_CACHE_ONLY
  void setCacheMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setCacheMode, jni.JniType.voidType, [mode]).check();

  static final _id_getCacheMode =
      jniAccessors.getMethodIDOf(_classRef, "getCacheMode", "()I");

  /// from: public abstract int getCacheMode()
  ///
  /// Gets the current setting for overriding the cache mode.
  ///@return the current setting for overriding the cache mode
  /// Value is android.webkit.WebSettings\#LOAD_DEFAULT, android.webkit.WebSettings\#LOAD_NORMAL, android.webkit.WebSettings\#LOAD_CACHE_ELSE_NETWORK, android.webkit.WebSettings\#LOAD_NO_CACHE, or android.webkit.WebSettings\#LOAD_CACHE_ONLY
  ///@see \#setCacheMode
  int getCacheMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getCacheMode, jni.JniType.intType, []).integer;

  static final _id_setMixedContentMode =
      jniAccessors.getMethodIDOf(_classRef, "setMixedContentMode", "(I)V");

  /// from: public abstract void setMixedContentMode(int mode)
  ///
  /// Configures the WebView's behavior when a secure origin attempts to load a resource from an
  /// insecure origin.
  ///
  /// By default, apps that target android.os.Build.VERSION_CODES\#KITKAT or below default
  /// to \#MIXED_CONTENT_ALWAYS_ALLOW. Apps targeting
  /// android.os.Build.VERSION_CODES\#LOLLIPOP default to \#MIXED_CONTENT_NEVER_ALLOW.
  ///
  /// The preferred and most secure mode of operation for the WebView is
  /// \#MIXED_CONTENT_NEVER_ALLOW and use of \#MIXED_CONTENT_ALWAYS_ALLOW is
  /// strongly discouraged.
  ///@param mode The mixed content mode to use. One of \#MIXED_CONTENT_NEVER_ALLOW,
  ///     \#MIXED_CONTENT_ALWAYS_ALLOW or \#MIXED_CONTENT_COMPATIBILITY_MODE.
  void setMixedContentMode(int mode) => jniAccessors.callMethodWithArgs(
      reference, _id_setMixedContentMode, jni.JniType.voidType, [mode]).check();

  static final _id_getMixedContentMode =
      jniAccessors.getMethodIDOf(_classRef, "getMixedContentMode", "()I");

  /// from: public abstract int getMixedContentMode()
  ///
  /// Gets the current behavior of the WebView with regard to loading insecure content from a
  /// secure origin.
  ///@return The current setting, one of \#MIXED_CONTENT_NEVER_ALLOW,
  ///     \#MIXED_CONTENT_ALWAYS_ALLOW or \#MIXED_CONTENT_COMPATIBILITY_MODE.
  int getMixedContentMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getMixedContentMode, jni.JniType.intType, []).integer;

  static final _id_setOffscreenPreRaster =
      jniAccessors.getMethodIDOf(_classRef, "setOffscreenPreRaster", "(Z)V");

  /// from: public abstract void setOffscreenPreRaster(boolean enabled)
  ///
  /// Sets whether this WebView should raster tiles when it is
  /// offscreen but attached to a window. Turning this on can avoid
  /// rendering artifacts when animating an offscreen WebView on-screen.
  /// Offscreen WebViews in this mode use more memory. The default value is
  /// false.<br>
  /// Please follow these guidelines to limit memory usage:
  /// <ul>
  /// <li> WebView size should be not be larger than the device screen size.
  /// <li> Limit use of this mode to a small number of WebViews. Use it for
  ///   visible WebViews and WebViews about to be animated to visible.
  /// </ul>
  void setOffscreenPreRaster(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setOffscreenPreRaster,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_getOffscreenPreRaster =
      jniAccessors.getMethodIDOf(_classRef, "getOffscreenPreRaster", "()Z");

  /// from: public abstract boolean getOffscreenPreRaster()
  ///
  /// Gets whether this WebView should raster tiles when it is
  /// offscreen but attached to a window.
  ///@return {@code true} if this WebView will raster tiles when it is
  /// offscreen but attached to a window.
  bool getOffscreenPreRaster() => jniAccessors.callMethodWithArgs(reference,
      _id_getOffscreenPreRaster, jni.JniType.booleanType, []).boolean;

  static final _id_setSafeBrowsingEnabled =
      jniAccessors.getMethodIDOf(_classRef, "setSafeBrowsingEnabled", "(Z)V");

  /// from: public abstract void setSafeBrowsingEnabled(boolean enabled)
  ///
  /// Sets whether Safe Browsing is enabled. Safe Browsing allows WebView to
  /// protect against malware and phishing attacks by verifying the links.
  ///
  ///
  /// Safe Browsing can be disabled for all WebViews using a manifest tag (read <a href="{@docRoot}reference/android/webkit/WebView.html">general Safe Browsing info</a>). The
  /// manifest tag has a lower precedence than this API.
  ///
  ///
  /// Safe Browsing is enabled by default for devices which support it.
  ///@param enabled Whether Safe Browsing is enabled.
  void setSafeBrowsingEnabled(bool enabled) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setSafeBrowsingEnabled,
      jni.JniType.voidType,
      [enabled]).check();

  static final _id_getSafeBrowsingEnabled =
      jniAccessors.getMethodIDOf(_classRef, "getSafeBrowsingEnabled", "()Z");

  /// from: public abstract boolean getSafeBrowsingEnabled()
  ///
  /// Gets whether Safe Browsing is enabled.
  /// See \#setSafeBrowsingEnabled.
  ///@return {@code true} if Safe Browsing is enabled and {@code false} otherwise.
  bool getSafeBrowsingEnabled() => jniAccessors.callMethodWithArgs(reference,
      _id_getSafeBrowsingEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_setDisabledActionModeMenuItems = jniAccessors.getMethodIDOf(
      _classRef, "setDisabledActionModeMenuItems", "(I)V");

  /// from: public abstract void setDisabledActionModeMenuItems(int menuItems)
  ///
  /// Disables the action mode menu items according to {@code menuItems} flag.
  ///@param menuItems an integer field flag for the menu items to be disabled.
  ///
  /// Value is either <code>0</code> or a combination of android.webkit.WebSettings\#MENU_ITEM_NONE, android.webkit.WebSettings\#MENU_ITEM_SHARE, android.webkit.WebSettings\#MENU_ITEM_WEB_SEARCH, and android.webkit.WebSettings\#MENU_ITEM_PROCESS_TEXT
  void setDisabledActionModeMenuItems(int menuItems) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setDisabledActionModeMenuItems,
          jni.JniType.voidType,
          [menuItems]).check();

  static final _id_getDisabledActionModeMenuItems = jniAccessors.getMethodIDOf(
      _classRef, "getDisabledActionModeMenuItems", "()I");

  /// from: public abstract int getDisabledActionModeMenuItems()
  ///
  /// Gets the action mode menu items that are disabled, expressed in an integer field flag.
  /// The default value is \#MENU_ITEM_NONE
  ///@return all the disabled menu item flags combined with bitwise OR.
  ///
  /// Value is either <code>0</code> or a combination of android.webkit.WebSettings\#MENU_ITEM_NONE, android.webkit.WebSettings\#MENU_ITEM_SHARE, android.webkit.WebSettings\#MENU_ITEM_WEB_SEARCH, and android.webkit.WebSettings\#MENU_ITEM_PROCESS_TEXT
  int getDisabledActionModeMenuItems() => jniAccessors.callMethodWithArgs(
      reference,
      _id_getDisabledActionModeMenuItems,
      jni.JniType.intType, []).integer;
}

/// from: android.webkit.WebSettings$ZoomDensity
///
/// Enum for specifying the WebView's desired density.
/// <ul>
///   <li>{@code FAR} makes 100% looking like in 240dpi</li>
///   <li>{@code MEDIUM} makes 100% looking like in 160dpi</li>
///   <li>{@code CLOSE} makes 100% looking like in 120dpi</li>
/// </ul>
class WebSettings_ZoomDensity extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/webkit/WebSettings\$ZoomDensity");
  WebSettings_ZoomDensity.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/webkit/WebSettings\$ZoomDensity;");

  /// from: static public android.webkit.WebSettings.ZoomDensity[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/webkit/WebSettings\$ZoomDensity;");

  /// from: static public android.webkit.WebSettings.ZoomDensity valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static WebSettings_ZoomDensity valueOf(jni.JniString name) =>
      WebSettings_ZoomDensity.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WebSettings_ZoomDensity()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.webkit.WebSettings$TextSize
///
/// Enum for specifying the text size.
/// <ul>
///   <li>SMALLEST is 50%</li>
///   <li>SMALLER is 75%</li>
///   <li>NORMAL is 100%</li>
///   <li>LARGER is 150%</li>
///   <li>LARGEST is 200%</li>
/// </ul>
///@deprecated Use WebSettings\#setTextZoom(int) and WebSettings\#getTextZoom() instead.
class WebSettings_TextSize extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/webkit/WebSettings\$TextSize");
  WebSettings_TextSize.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/webkit/WebSettings\$TextSize;");

  /// from: static public android.webkit.WebSettings.TextSize[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(_classRef,
      "valueOf", "(Ljava/lang/String;)Landroid/webkit/WebSettings\$TextSize;");

  /// from: static public android.webkit.WebSettings.TextSize valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static WebSettings_TextSize valueOf(jni.JniString name) =>
      WebSettings_TextSize.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WebSettings_TextSize()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.webkit.WebSettings$RenderPriority
class WebSettings_RenderPriority extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/webkit/WebSettings\$RenderPriority");
  WebSettings_RenderPriority.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/webkit/WebSettings\$RenderPriority;");

  /// from: static public android.webkit.WebSettings.RenderPriority[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/webkit/WebSettings\$RenderPriority;");

  /// from: static public android.webkit.WebSettings.RenderPriority valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static WebSettings_RenderPriority valueOf(jni.JniString name) =>
      WebSettings_RenderPriority.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WebSettings_RenderPriority()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.webkit.WebSettings$PluginState
///
/// The plugin state effects how plugins are treated on a page. ON means
/// that any object will be loaded even if a plugin does not exist to handle
/// the content. ON_DEMAND means that if there is a plugin installed that
/// can handle the content, a placeholder is shown until the user clicks on
/// the placeholder. Once clicked, the plugin will be enabled on the page.
/// OFF means that all plugins will be turned off and any fallback content
/// will be used.
class WebSettings_PluginState extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/webkit/WebSettings\$PluginState");
  WebSettings_PluginState.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/webkit/WebSettings\$PluginState;");

  /// from: static public android.webkit.WebSettings.PluginState[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/webkit/WebSettings\$PluginState;");

  /// from: static public android.webkit.WebSettings.PluginState valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static WebSettings_PluginState valueOf(jni.JniString name) =>
      WebSettings_PluginState.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WebSettings_PluginState()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}

/// from: android.webkit.WebSettings$LayoutAlgorithm
///
/// Enum for controlling the layout of html.
/// <ul>
///   <li>{@code NORMAL} means no rendering changes. This is the recommended choice for maximum
///       compatibility across different platforms and Android versions.</li>
///   <li>{@code SINGLE_COLUMN} moves all content into one column that is the width of the
///       view.</li>
///   <li>{@code NARROW_COLUMNS} makes all columns no wider than the screen if possible. Only use
///       this for API levels prior to android.os.Build.VERSION_CODES\#KITKAT.</li>
///   <li>{@code TEXT_AUTOSIZING} boosts font size of paragraphs based on heuristics to make
///       the text readable when viewing a wide-viewport layout in the overview mode.
///       It is recommended to enable zoom support \#setSupportZoom when
///       using this mode. Supported from API level
///       android.os.Build.VERSION_CODES\#KITKAT</li>
/// </ul>
class WebSettings_LayoutAlgorithm extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/webkit/WebSettings\$LayoutAlgorithm");
  WebSettings_LayoutAlgorithm.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_values = jniAccessors.getStaticMethodIDOf(
      _classRef, "values", "()[Landroid/webkit/WebSettings\$LayoutAlgorithm;");

  /// from: static public android.webkit.WebSettings.LayoutAlgorithm[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject values() =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_values, jni.JniType.objectType, []).object);

  static final _id_valueOf = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "valueOf",
      "(Ljava/lang/String;)Landroid/webkit/WebSettings\$LayoutAlgorithm;");

  /// from: static public android.webkit.WebSettings.LayoutAlgorithm valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static WebSettings_LayoutAlgorithm valueOf(jni.JniString name) =>
      WebSettings_LayoutAlgorithm.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_valueOf,
          jni.JniType.objectType,
          [name.reference]).object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: private void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WebSettings_LayoutAlgorithm()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);
}
