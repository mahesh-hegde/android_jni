// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "WebMessage.dart" as webmessage_;

import "../os/Handler.dart" as handler_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.webkit.WebMessagePort
///
/// The Java representation of the
/// <a href="https://html.spec.whatwg.org/multipage/comms.html\#messageport">
/// HTML5 message ports.</a>
///
/// A Message port represents one endpoint of a Message Channel. In Android
/// webview, there is no separate Message Channel object. When a message channel
/// is created, both ports are tangled to each other and started, and then
/// returned in a MessagePort array, see WebView\#createWebMessageChannel
/// for creating a message channel.
///
/// When a message port is first created or received via transfer, it does not
/// have a WebMessageCallback to receive web messages. The messages are queued until
/// a WebMessageCallback is set.
///
/// A message port should be closed when it is not used by the embedder application
/// anymore. A closed port cannot be transferred or cannot be reopened to send
/// messages. Close can be called multiple times.
///
/// When a port is transferred to JS, it cannot be used to send or receive messages
/// at the Java side anymore. Different from HTML5 Spec, a port cannot be transferred
/// if one of these has ever happened: i. a message callback was set, ii. a message was
/// posted on it. A transferred port cannot be closed by the application, since
/// the ownership is also transferred.
///
/// It is possible to transfer both ports of a channel to JS, for example for
/// communication between subframes.
class WebMessagePort extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/webkit/WebMessagePort");
  WebMessagePort.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructor.
  ///@hide
  WebMessagePort()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_postMessage = jniAccessors.getMethodIDOf(
      _classRef, "postMessage", "(Landroid/webkit/WebMessage;)V");

  /// from: public abstract void postMessage(android.webkit.WebMessage message)
  ///
  /// Post a WebMessage to the entangled port.
  ///@param message the message from Java to JS.
  ///@throws IllegalStateException If message port is already transferred or closed.
  void postMessage(webmessage_.WebMessage message) =>
      jniAccessors.callMethodWithArgs(reference, _id_postMessage,
          jni.JniType.voidType, [message.reference]).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public abstract void close()
  ///
  /// Close the message port and free any resources associated with it.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_setWebMessageCallback = jniAccessors.getMethodIDOf(
      _classRef,
      "setWebMessageCallback",
      "(Landroid/webkit/WebMessagePort\$WebMessageCallback;)V");

  /// from: public abstract void setWebMessageCallback(android.webkit.WebMessagePort.WebMessageCallback callback)
  ///
  /// Sets a callback to receive message events on the main thread.
  ///@param callback the message callback.
  void setWebMessageCallback(WebMessagePort_WebMessageCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_setWebMessageCallback,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_setWebMessageCallback1 = jniAccessors.getMethodIDOf(
      _classRef,
      "setWebMessageCallback",
      "(Landroid/webkit/WebMessagePort\$WebMessageCallback;Landroid/os/Handler;)V");

  /// from: public abstract void setWebMessageCallback(android.webkit.WebMessagePort.WebMessageCallback callback, android.os.Handler handler)
  ///
  /// Sets a callback to receive message events on the handler that is provided
  /// by the application.
  ///@param callback the message callback.
  ///@param handler the handler to receive the message messages.
  void setWebMessageCallback1(WebMessagePort_WebMessageCallback callback,
          handler_.Handler handler) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setWebMessageCallback1,
          jni.JniType.voidType,
          [callback.reference, handler.reference]).check();
}

/// from: android.webkit.WebMessagePort$WebMessageCallback
///
/// The listener for handling MessagePort events. The message callback
/// methods are called on the main thread. If the embedder application
/// wants to receive the messages on a different thread, it can do this
/// by passing a Handler in
///  WebMessagePort\#setWebMessageCallback(WebMessageCallback, Handler).
/// In the latter case, the application should be extra careful for thread safety
/// since WebMessagePort methods should be called on main thread.
class WebMessagePort_WebMessageCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/webkit/WebMessagePort\$WebMessageCallback");
  WebMessagePort_WebMessageCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WebMessagePort_WebMessageCallback()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onMessage = jniAccessors.getMethodIDOf(
      _classRef,
      "onMessage",
      "(Landroid/webkit/WebMessagePort;Landroid/webkit/WebMessage;)V");

  /// from: public void onMessage(android.webkit.WebMessagePort port, android.webkit.WebMessage message)
  ///
  /// Message callback for receiving onMessage events.
  ///@param port the WebMessagePort that the message is destined for
  ///@param message the message from the entangled port.
  void onMessage(WebMessagePort port, webmessage_.WebMessage message) =>
      jniAccessors.callMethodWithArgs(reference, _id_onMessage,
          jni.JniType.voidType, [port.reference, message.reference]).check();
}
