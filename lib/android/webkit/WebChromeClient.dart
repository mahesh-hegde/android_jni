// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "WebView.dart" as webview_;

import "../graphics/Bitmap.dart" as bitmap_;

import "../view/View.dart" as view_;

import "../os/Message.dart" as message_;

import "JsResult.dart" as jsresult_;

import "JsPromptResult.dart" as jspromptresult_;

import "WebStorage.dart" as webstorage_;

import "GeolocationPermissions.dart" as geolocationpermissions_;

import "PermissionRequest.dart" as permissionrequest_;

import "ConsoleMessage.dart" as consolemessage_;

import "ValueCallback.dart" as valuecallback_;

import "../content/Intent.dart" as intent_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.webkit.WebChromeClient
class WebChromeClient extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/webkit/WebChromeClient");
  WebChromeClient.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WebChromeClient()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_onProgressChanged = jniAccessors.getMethodIDOf(
      _classRef, "onProgressChanged", "(Landroid/webkit/WebView;I)V");

  /// from: public void onProgressChanged(android.webkit.WebView view, int newProgress)
  ///
  /// Tell the host application the current progress of loading a page.
  ///@param view The WebView that initiated the callback.
  ///@param newProgress Current page loading progress, represented by
  ///                    an integer between 0 and 100.
  void onProgressChanged(webview_.WebView view, int newProgress) =>
      jniAccessors.callMethodWithArgs(reference, _id_onProgressChanged,
          jni.JniType.voidType, [view.reference, newProgress]).check();

  static final _id_onReceivedTitle = jniAccessors.getMethodIDOf(_classRef,
      "onReceivedTitle", "(Landroid/webkit/WebView;Ljava/lang/String;)V");

  /// from: public void onReceivedTitle(android.webkit.WebView view, java.lang.String title)
  ///
  /// Notify the host application of a change in the document title.
  ///@param view The WebView that initiated the callback.
  ///@param title A String containing the new title of the document.
  void onReceivedTitle(webview_.WebView view, jni.JniString title) =>
      jniAccessors.callMethodWithArgs(reference, _id_onReceivedTitle,
          jni.JniType.voidType, [view.reference, title.reference]).check();

  static final _id_onReceivedIcon = jniAccessors.getMethodIDOf(_classRef,
      "onReceivedIcon", "(Landroid/webkit/WebView;Landroid/graphics/Bitmap;)V");

  /// from: public void onReceivedIcon(android.webkit.WebView view, android.graphics.Bitmap icon)
  ///
  /// Notify the host application of a new favicon for the current page.
  ///@param view The WebView that initiated the callback.
  ///@param icon A Bitmap containing the favicon for the current page.
  void onReceivedIcon(webview_.WebView view, bitmap_.Bitmap icon) =>
      jniAccessors.callMethodWithArgs(reference, _id_onReceivedIcon,
          jni.JniType.voidType, [view.reference, icon.reference]).check();

  static final _id_onReceivedTouchIconUrl = jniAccessors.getMethodIDOf(
      _classRef,
      "onReceivedTouchIconUrl",
      "(Landroid/webkit/WebView;Ljava/lang/String;Z)V");

  /// from: public void onReceivedTouchIconUrl(android.webkit.WebView view, java.lang.String url, boolean precomposed)
  ///
  /// Notify the host application of the url for an apple-touch-icon.
  ///@param view The WebView that initiated the callback.
  ///@param url The icon url.
  ///@param precomposed {@code true} if the url is for a precomposed touch icon.
  void onReceivedTouchIconUrl(
          webview_.WebView view, jni.JniString url, bool precomposed) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onReceivedTouchIconUrl,
          jni.JniType.voidType,
          [view.reference, url.reference, precomposed]).check();

  static final _id_onShowCustomView = jniAccessors.getMethodIDOf(
      _classRef,
      "onShowCustomView",
      "(Landroid/view/View;Landroid/webkit/WebChromeClient\$CustomViewCallback;)V");

  /// from: public void onShowCustomView(android.view.View view, android.webkit.WebChromeClient.CustomViewCallback callback)
  ///
  /// Notify the host application that the current page has entered full
  /// screen mode. The host application must show the custom View which
  /// contains the web contents &mdash; video or other HTML content &mdash;
  /// in full screen mode. Also see "Full screen support" documentation on
  /// WebView.
  ///@param view is the View object to be shown.
  ///@param callback invoke this callback to request the page to exit
  /// full screen mode.
  void onShowCustomView(
          view_.View view, WebChromeClient_CustomViewCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_onShowCustomView,
          jni.JniType.voidType, [view.reference, callback.reference]).check();

  static final _id_onShowCustomView1 = jniAccessors.getMethodIDOf(
      _classRef,
      "onShowCustomView",
      "(Landroid/view/View;ILandroid/webkit/WebChromeClient\$CustomViewCallback;)V");

  /// from: public void onShowCustomView(android.view.View view, int requestedOrientation, android.webkit.WebChromeClient.CustomViewCallback callback)
  ///
  /// Notify the host application that the current page would
  /// like to show a custom View in a particular orientation.
  ///@param view is the View object to be shown.
  ///@param requestedOrientation An orientation constant as used in
  /// ActivityInfo\#screenOrientation ActivityInfo.screenOrientation.
  ///@param callback is the callback to be invoked if and when the view
  /// is dismissed.
  ///@deprecated This method supports the obsolete plugin mechanism,
  /// and will not be invoked in future
  void onShowCustomView1(view_.View view, int requestedOrientation,
          WebChromeClient_CustomViewCallback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onShowCustomView1,
          jni.JniType.voidType,
          [view.reference, requestedOrientation, callback.reference]).check();

  static final _id_onHideCustomView =
      jniAccessors.getMethodIDOf(_classRef, "onHideCustomView", "()V");

  /// from: public void onHideCustomView()
  ///
  /// Notify the host application that the current page has exited full
  /// screen mode. The host application must hide the custom View, ie. the
  /// View passed to \#onShowCustomView when the content entered fullscreen.
  /// Also see "Full screen support" documentation on WebView.
  void onHideCustomView() => jniAccessors.callMethodWithArgs(
      reference, _id_onHideCustomView, jni.JniType.voidType, []).check();

  static final _id_onCreateWindow = jniAccessors.getMethodIDOf(_classRef,
      "onCreateWindow", "(Landroid/webkit/WebView;ZZLandroid/os/Message;)Z");

  /// from: public boolean onCreateWindow(android.webkit.WebView view, boolean isDialog, boolean isUserGesture, android.os.Message resultMsg)
  ///
  /// Request the host application to create a new window. If the host
  /// application chooses to honor this request, it should return {@code true} from
  /// this method, create a new WebView to host the window, insert it into the
  /// View system and send the supplied resultMsg message to its target with
  /// the new WebView as an argument. If the host application chooses not to
  /// honor the request, it should return {@code false} from this method. The default
  /// implementation of this method does nothing and hence returns {@code false}.
  ///
  /// Applications should typically not allow windows to be created when the
  /// {@code isUserGesture} flag is false, as this may be an unwanted popup.
  ///
  /// Applications should be careful how they display the new window: don't simply
  /// overlay it over the existing WebView as this may mislead the user about which
  /// site they are viewing. If your application displays the URL of the main page,
  /// make sure to also display the URL of the new window in a similar fashion. If
  /// your application does not display URLs, consider disallowing the creation of
  /// new windows entirely.
  /// <p class="note">__Note:__ There is no trustworthy way to tell which page
  /// requested the new window: the request might originate from a third-party iframe
  /// inside the WebView.
  ///@param view The WebView from which the request for a new window
  ///             originated.
  ///@param isDialog {@code true} if the new window should be a dialog, rather than
  ///                 a full-size window.
  ///@param isUserGesture {@code true} if the request was initiated by a user gesture,
  ///                      such as the user clicking a link.
  ///@param resultMsg The message to send when once a new WebView has been
  ///                  created. resultMsg.obj is a
  ///                  WebView.WebViewTransport object. This should be
  ///                  used to transport the new WebView, by calling
  ///                  WebView.WebViewTransport\#setWebView(WebView) WebView.WebViewTransport.setWebView(WebView).
  ///@return This method should return {@code true} if the host application will
  ///         create a new window, in which case resultMsg should be sent to
  ///         its target. Otherwise, this method should return {@code false}. Returning
  ///         {@code false} from this method but also sending resultMsg will result in
  ///         undefined behavior.
  bool onCreateWindow(webview_.WebView view, bool isDialog, bool isUserGesture,
          message_.Message resultMsg) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onCreateWindow, jni.JniType.booleanType, [
        view.reference,
        isDialog,
        isUserGesture,
        resultMsg.reference
      ]).boolean;

  static final _id_onRequestFocus = jniAccessors.getMethodIDOf(
      _classRef, "onRequestFocus", "(Landroid/webkit/WebView;)V");

  /// from: public void onRequestFocus(android.webkit.WebView view)
  ///
  /// Request display and focus for this WebView. This may happen due to
  /// another WebView opening a link in this WebView and requesting that this
  /// WebView be displayed.
  ///@param view The WebView that needs to be focused.
  void onRequestFocus(webview_.WebView view) => jniAccessors.callMethodWithArgs(
      reference,
      _id_onRequestFocus,
      jni.JniType.voidType,
      [view.reference]).check();

  static final _id_onCloseWindow = jniAccessors.getMethodIDOf(
      _classRef, "onCloseWindow", "(Landroid/webkit/WebView;)V");

  /// from: public void onCloseWindow(android.webkit.WebView window)
  ///
  /// Notify the host application to close the given WebView and remove it
  /// from the view system if necessary. At this point, WebCore has stopped
  /// any loading in this window and has removed any cross-scripting ability
  /// in javascript.
  ///
  /// As with \#onCreateWindow, the application should ensure that any
  /// URL or security indicator displayed is updated so that the user can tell
  /// that the page they were interacting with has been closed.
  ///@param window The WebView that needs to be closed.
  void onCloseWindow(webview_.WebView window) =>
      jniAccessors.callMethodWithArgs(reference, _id_onCloseWindow,
          jni.JniType.voidType, [window.reference]).check();

  static final _id_onJsAlert = jniAccessors.getMethodIDOf(
      _classRef,
      "onJsAlert",
      "(Landroid/webkit/WebView;Ljava/lang/String;Ljava/lang/String;Landroid/webkit/JsResult;)Z");

  /// from: public boolean onJsAlert(android.webkit.WebView view, java.lang.String url, java.lang.String message, android.webkit.JsResult result)
  ///
  /// Tell the client to display a javascript alert dialog.  If the client
  /// returns {@code true}, WebView will assume that the client will handle the
  /// dialog.  If the client returns {@code false}, it will continue execution.
  ///@param view The WebView that initiated the callback.
  ///@param url The url of the page requesting the dialog.
  ///@param message Message to be displayed in the window.
  ///@param result A JsResult to confirm that the user hit enter.
  ///@return boolean Whether the client will handle the alert dialog.
  bool onJsAlert(webview_.WebView view, jni.JniString url,
          jni.JniString message, jsresult_.JsResult result) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onJsAlert, jni.JniType.booleanType, [
        view.reference,
        url.reference,
        message.reference,
        result.reference
      ]).boolean;

  static final _id_onJsConfirm = jniAccessors.getMethodIDOf(
      _classRef,
      "onJsConfirm",
      "(Landroid/webkit/WebView;Ljava/lang/String;Ljava/lang/String;Landroid/webkit/JsResult;)Z");

  /// from: public boolean onJsConfirm(android.webkit.WebView view, java.lang.String url, java.lang.String message, android.webkit.JsResult result)
  ///
  /// Tell the client to display a confirm dialog to the user. If the client
  /// returns {@code true}, WebView will assume that the client will handle the
  /// confirm dialog and call the appropriate JsResult method. If the
  /// client returns false, a default value of {@code false} will be returned to
  /// javascript. The default behavior is to return {@code false}.
  ///@param view The WebView that initiated the callback.
  ///@param url The url of the page requesting the dialog.
  ///@param message Message to be displayed in the window.
  ///@param result A JsResult used to send the user's response to
  ///               javascript.
  ///@return boolean Whether the client will handle the confirm dialog.
  bool onJsConfirm(webview_.WebView view, jni.JniString url,
          jni.JniString message, jsresult_.JsResult result) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onJsConfirm, jni.JniType.booleanType, [
        view.reference,
        url.reference,
        message.reference,
        result.reference
      ]).boolean;

  static final _id_onJsPrompt = jniAccessors.getMethodIDOf(
      _classRef,
      "onJsPrompt",
      "(Landroid/webkit/WebView;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Landroid/webkit/JsPromptResult;)Z");

  /// from: public boolean onJsPrompt(android.webkit.WebView view, java.lang.String url, java.lang.String message, java.lang.String defaultValue, android.webkit.JsPromptResult result)
  ///
  /// Tell the client to display a prompt dialog to the user. If the client
  /// returns {@code true}, WebView will assume that the client will handle the
  /// prompt dialog and call the appropriate JsPromptResult method. If the
  /// client returns false, a default value of {@code false} will be returned to to
  /// javascript. The default behavior is to return {@code false}.
  ///@param view The WebView that initiated the callback.
  ///@param url The url of the page requesting the dialog.
  ///@param message Message to be displayed in the window.
  ///@param defaultValue The default value displayed in the prompt dialog.
  ///@param result A JsPromptResult used to send the user's reponse to
  ///               javascript.
  ///@return boolean Whether the client will handle the prompt dialog.
  bool onJsPrompt(
          webview_.WebView view,
          jni.JniString url,
          jni.JniString message,
          jni.JniString defaultValue,
          jspromptresult_.JsPromptResult result) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onJsPrompt, jni.JniType.booleanType, [
        view.reference,
        url.reference,
        message.reference,
        defaultValue.reference,
        result.reference
      ]).boolean;

  static final _id_onJsBeforeUnload = jniAccessors.getMethodIDOf(
      _classRef,
      "onJsBeforeUnload",
      "(Landroid/webkit/WebView;Ljava/lang/String;Ljava/lang/String;Landroid/webkit/JsResult;)Z");

  /// from: public boolean onJsBeforeUnload(android.webkit.WebView view, java.lang.String url, java.lang.String message, android.webkit.JsResult result)
  ///
  /// Tell the client to display a dialog to confirm navigation away from the
  /// current page. This is the result of the onbeforeunload javascript event.
  /// If the client returns {@code true}, WebView will assume that the client will
  /// handle the confirm dialog and call the appropriate JsResult method. If
  /// the client returns {@code false}, a default value of {@code true} will be returned to
  /// javascript to accept navigation away from the current page. The default
  /// behavior is to return {@code false}. Setting the JsResult to {@code true} will navigate
  /// away from the current page, {@code false} will cancel the navigation.
  ///@param view The WebView that initiated the callback.
  ///@param url The url of the page requesting the dialog.
  ///@param message Message to be displayed in the window.
  ///@param result A JsResult used to send the user's response to
  ///               javascript.
  ///@return boolean Whether the client will handle the confirm dialog.
  bool onJsBeforeUnload(webview_.WebView view, jni.JniString url,
          jni.JniString message, jsresult_.JsResult result) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onJsBeforeUnload, jni.JniType.booleanType, [
        view.reference,
        url.reference,
        message.reference,
        result.reference
      ]).boolean;

  static final _id_onExceededDatabaseQuota = jniAccessors.getMethodIDOf(
      _classRef,
      "onExceededDatabaseQuota",
      "(Ljava/lang/String;Ljava/lang/String;JJJLandroid/webkit/WebStorage\$QuotaUpdater;)V");

  /// from: public void onExceededDatabaseQuota(java.lang.String url, java.lang.String databaseIdentifier, long quota, long estimatedDatabaseSize, long totalQuota, android.webkit.WebStorage.QuotaUpdater quotaUpdater)
  ///
  /// Tell the client that the quota has been exceeded for the Web SQL Database
  /// API for a particular origin and request a new quota. The client must
  /// respond by invoking the
  /// WebStorage.QuotaUpdater\#updateQuota(long) updateQuota(long)
  /// method of the supplied WebStorage.QuotaUpdater instance. The
  /// minimum value that can be set for the new quota is the current quota. The
  /// default implementation responds with the current quota, so the quota will
  /// not be increased.
  ///@param url The URL of the page that triggered the notification
  ///@param databaseIdentifier The identifier of the database where the quota
  ///                           was exceeded.
  ///@param quota The quota for the origin, in bytes
  ///@param estimatedDatabaseSize The estimated size of the offending
  ///                              database, in bytes
  ///@param totalQuota The total quota for all origins, in bytes
  ///@param quotaUpdater An instance of WebStorage.QuotaUpdater which
  ///                     must be used to inform the WebView of the new quota.
  ///@deprecated This method is no longer called; WebView now uses the HTML5 / JavaScript Quota
  ///             Management API.
  void onExceededDatabaseQuota(
          jni.JniString url,
          jni.JniString databaseIdentifier,
          int quota,
          int estimatedDatabaseSize,
          int totalQuota,
          webstorage_.WebStorage_QuotaUpdater quotaUpdater) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onExceededDatabaseQuota, jni.JniType.voidType, [
        url.reference,
        databaseIdentifier.reference,
        quota,
        estimatedDatabaseSize,
        totalQuota,
        quotaUpdater.reference
      ]).check();

  static final _id_onReachedMaxAppCacheSize = jniAccessors.getMethodIDOf(
      _classRef,
      "onReachedMaxAppCacheSize",
      "(JJLandroid/webkit/WebStorage\$QuotaUpdater;)V");

  /// from: public void onReachedMaxAppCacheSize(long requiredStorage, long quota, android.webkit.WebStorage.QuotaUpdater quotaUpdater)
  ///
  /// Notify the host application that the Application Cache has reached the
  /// maximum size. The client must respond by invoking the
  /// WebStorage.QuotaUpdater\#updateQuota(long) updateQuota(long)
  /// method of the supplied WebStorage.QuotaUpdater instance. The
  /// minimum value that can be set for the new quota is the current quota. The
  /// default implementation responds with the current quota, so the quota will
  /// not be increased.
  ///@param requiredStorage The amount of storage required by the Application
  ///                        Cache operation that triggered this notification,
  ///                        in bytes.
  ///@param quota the current maximum Application Cache size, in bytes
  ///@param quotaUpdater An instance of WebStorage.QuotaUpdater which
  ///                     must be used to inform the WebView of the new quota.
  ///@deprecated This method is no longer called; WebView now uses the HTML5 / JavaScript Quota
  ///             Management API.
  void onReachedMaxAppCacheSize(int requiredStorage, int quota,
          webstorage_.WebStorage_QuotaUpdater quotaUpdater) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onReachedMaxAppCacheSize,
          jni.JniType.voidType,
          [requiredStorage, quota, quotaUpdater.reference]).check();

  static final _id_onGeolocationPermissionsShowPrompt = jniAccessors.getMethodIDOf(
      _classRef,
      "onGeolocationPermissionsShowPrompt",
      "(Ljava/lang/String;Landroid/webkit/GeolocationPermissions\$Callback;)V");

  /// from: public void onGeolocationPermissionsShowPrompt(java.lang.String origin, android.webkit.GeolocationPermissions.Callback callback)
  ///
  /// Notify the host application that web content from the specified origin
  /// is attempting to use the Geolocation API, but no permission state is
  /// currently set for that origin. The host application should invoke the
  /// specified callback with the desired permission state. See
  /// GeolocationPermissions for details.
  ///
  /// Note that for applications targeting Android N and later SDKs
  /// (API level > android.os.Build.VERSION_CODES\#M)
  /// this method is only called for requests originating from secure
  /// origins such as https. On non-secure origins geolocation requests
  /// are automatically denied.
  ///@param origin The origin of the web content attempting to use the
  ///               Geolocation API.
  ///@param callback The callback to use to set the permission state for the
  ///                 origin.
  void onGeolocationPermissionsShowPrompt(jni.JniString origin,
          geolocationpermissions_.GeolocationPermissions_Callback callback) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onGeolocationPermissionsShowPrompt,
          jni.JniType.voidType,
          [origin.reference, callback.reference]).check();

  static final _id_onGeolocationPermissionsHidePrompt = jniAccessors
      .getMethodIDOf(_classRef, "onGeolocationPermissionsHidePrompt", "()V");

  /// from: public void onGeolocationPermissionsHidePrompt()
  ///
  /// Notify the host application that a request for Geolocation permissions,
  /// made with a previous call to
  /// \#onGeolocationPermissionsShowPrompt(String,GeolocationPermissions.Callback) onGeolocationPermissionsShowPrompt()
  /// has been canceled. Any related UI should therefore be hidden.
  void onGeolocationPermissionsHidePrompt() => jniAccessors.callMethodWithArgs(
      reference,
      _id_onGeolocationPermissionsHidePrompt,
      jni.JniType.voidType, []).check();

  static final _id_onPermissionRequest = jniAccessors.getMethodIDOf(_classRef,
      "onPermissionRequest", "(Landroid/webkit/PermissionRequest;)V");

  /// from: public void onPermissionRequest(android.webkit.PermissionRequest request)
  ///
  /// Notify the host application that web content is requesting permission to
  /// access the specified resources and the permission currently isn't granted
  /// or denied. The host application must invoke PermissionRequest\#grant(String[])
  /// or PermissionRequest\#deny().
  ///
  /// If this method isn't overridden, the permission is denied.
  ///@param request the PermissionRequest from current web content.
  void onPermissionRequest(permissionrequest_.PermissionRequest request) =>
      jniAccessors.callMethodWithArgs(reference, _id_onPermissionRequest,
          jni.JniType.voidType, [request.reference]).check();

  static final _id_onPermissionRequestCanceled = jniAccessors.getMethodIDOf(
      _classRef,
      "onPermissionRequestCanceled",
      "(Landroid/webkit/PermissionRequest;)V");

  /// from: public void onPermissionRequestCanceled(android.webkit.PermissionRequest request)
  ///
  /// Notify the host application that the given permission request
  /// has been canceled. Any related UI should therefore be hidden.
  ///@param request the PermissionRequest that needs be canceled.
  void onPermissionRequestCanceled(
          permissionrequest_.PermissionRequest request) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onPermissionRequestCanceled,
          jni.JniType.voidType,
          [request.reference]).check();

  static final _id_onJsTimeout =
      jniAccessors.getMethodIDOf(_classRef, "onJsTimeout", "()Z");

  /// from: public boolean onJsTimeout()
  ///
  /// Tell the client that a JavaScript execution timeout has occured. And the
  /// client may decide whether or not to interrupt the execution. If the
  /// client returns {@code true}, the JavaScript will be interrupted. If the client
  /// returns {@code false}, the execution will continue. Note that in the case of
  /// continuing execution, the timeout counter will be reset, and the callback
  /// will continue to occur if the script does not finish at the next check
  /// point.
  ///@return boolean Whether the JavaScript execution should be interrupted.
  ///@deprecated This method is no longer supported and will not be invoked.
  bool onJsTimeout() => jniAccessors.callMethodWithArgs(
      reference, _id_onJsTimeout, jni.JniType.booleanType, []).boolean;

  static final _id_onConsoleMessage = jniAccessors.getMethodIDOf(_classRef,
      "onConsoleMessage", "(Ljava/lang/String;ILjava/lang/String;)V");

  /// from: public void onConsoleMessage(java.lang.String message, int lineNumber, java.lang.String sourceID)
  ///
  /// Report a JavaScript error message to the host application. The ChromeClient
  /// should override this to process the log message as they see fit.
  ///@param message The error message to report.
  ///@param lineNumber The line number of the error.
  ///@param sourceID The name of the source file that caused the error.
  ///@deprecated Use \#onConsoleMessage(ConsoleMessage) onConsoleMessage(ConsoleMessage)
  ///      instead.
  void onConsoleMessage(
          jni.JniString message, int lineNumber, jni.JniString sourceID) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_onConsoleMessage,
          jni.JniType.voidType,
          [message.reference, lineNumber, sourceID.reference]).check();

  static final _id_onConsoleMessage1 = jniAccessors.getMethodIDOf(
      _classRef, "onConsoleMessage", "(Landroid/webkit/ConsoleMessage;)Z");

  /// from: public boolean onConsoleMessage(android.webkit.ConsoleMessage consoleMessage)
  ///
  /// Report a JavaScript console message to the host application. The ChromeClient
  /// should override this to process the log message as they see fit.
  ///@param consoleMessage Object containing details of the console message.
  ///@return {@code true} if the message is handled by the client.
  bool onConsoleMessage1(consolemessage_.ConsoleMessage consoleMessage) =>
      jniAccessors.callMethodWithArgs(reference, _id_onConsoleMessage1,
          jni.JniType.booleanType, [consoleMessage.reference]).boolean;

  static final _id_getDefaultVideoPoster = jniAccessors.getMethodIDOf(
      _classRef, "getDefaultVideoPoster", "()Landroid/graphics/Bitmap;");

  /// from: public android.graphics.Bitmap getDefaultVideoPoster()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// When not playing, video elements are represented by a 'poster' image. The
  /// image to use can be specified by the poster attribute of the video tag in
  /// HTML. If the attribute is absent, then a default poster will be used. This
  /// method allows the ChromeClient to provide that default image.
  ///@return Bitmap The image to use as a default poster, or {@code null} if no such image is
  /// available.
  bitmap_.Bitmap getDefaultVideoPoster() =>
      bitmap_.Bitmap.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getDefaultVideoPoster, jni.JniType.objectType, []).object);

  static final _id_getVideoLoadingProgressView = jniAccessors.getMethodIDOf(
      _classRef, "getVideoLoadingProgressView", "()Landroid/view/View;");

  /// from: public android.view.View getVideoLoadingProgressView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtains a View to be displayed while buffering of full screen video is taking
  /// place. The host application can override this method to provide a View
  /// containing a spinner or similar.
  ///@return View The View to be displayed whilst the video is loading.
  ///
  /// This value may be {@code null}.
  view_.View getVideoLoadingProgressView() =>
      view_.View.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getVideoLoadingProgressView, jni.JniType.objectType, []).object);

  static final _id_getVisitedHistory = jniAccessors.getMethodIDOf(
      _classRef, "getVisitedHistory", "(Landroid/webkit/ValueCallback;)V");

  /// from: public void getVisitedHistory(android.webkit.ValueCallback<java.lang.String[]> callback)
  ///
  /// Obtains a list of all visited history items, used for link coloring
  void getVisitedHistory(valuecallback_.ValueCallback callback) =>
      jniAccessors.callMethodWithArgs(reference, _id_getVisitedHistory,
          jni.JniType.voidType, [callback.reference]).check();

  static final _id_onShowFileChooser = jniAccessors.getMethodIDOf(
      _classRef,
      "onShowFileChooser",
      "(Landroid/webkit/WebView;Landroid/webkit/ValueCallback;Landroid/webkit/WebChromeClient\$FileChooserParams;)Z");

  /// from: public boolean onShowFileChooser(android.webkit.WebView webView, android.webkit.ValueCallback<android.net.Uri[]> filePathCallback, android.webkit.WebChromeClient.FileChooserParams fileChooserParams)
  ///
  /// Tell the client to show a file chooser.
  ///
  /// This is called to handle HTML forms with 'file' input type, in response to the
  /// user pressing the "Select File" button.
  /// To cancel the request, call <code>filePathCallback.onReceiveValue(null)</code> and
  /// return {@code true}.
  ///@param webView The WebView instance that is initiating the request.
  ///@param filePathCallback Invoke this callback to supply the list of paths to files to upload,
  ///                         or {@code null} to cancel. Must only be called if the
  ///                         \#onShowFileChooser implementation returns {@code true}.
  ///@param fileChooserParams Describes the mode of file chooser to be opened, and options to be
  ///                          used with it.
  ///@return {@code true} if filePathCallback will be invoked, {@code false} to use default
  ///         handling.
  ///@see FileChooserParams
  bool onShowFileChooser(
          webview_.WebView webView,
          valuecallback_.ValueCallback filePathCallback,
          WebChromeClient_FileChooserParams fileChooserParams) =>
      jniAccessors.callMethodWithArgs(
          reference, _id_onShowFileChooser, jni.JniType.booleanType, [
        webView.reference,
        filePathCallback.reference,
        fileChooserParams.reference
      ]).boolean;
}

/// from: android.webkit.WebChromeClient$FileChooserParams
///
/// Parameters used in the \#onShowFileChooser method.
class WebChromeClient_FileChooserParams extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/webkit/WebChromeClient\$FileChooserParams");
  WebChromeClient_FileChooserParams.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  /// from: static public final int MODE_OPEN
  ///
  /// Open single file. Requires that the file exists before allowing the user to pick it.
  static const MODE_OPEN = 0;

  /// from: static public final int MODE_OPEN_MULTIPLE
  ///
  /// Like Open but allows multiple files to be selected.
  static const MODE_OPEN_MULTIPLE = 1;

  /// from: static public final int MODE_SAVE
  ///
  /// Allows picking a nonexistent file and saving it.
  static const MODE_SAVE = 3;

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  WebChromeClient_FileChooserParams()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_parseResult = jniAccessors.getStaticMethodIDOf(_classRef,
      "parseResult", "(ILandroid/content/Intent;)[Landroid/net/Uri;");

  /// from: static public android.net.Uri[] parseResult(int resultCode, android.content.Intent data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parse the result returned by the file picker activity. This method should be used with
  /// \#createIntent. Refer to \#createIntent for how to use it.
  ///@param resultCode the integer result code returned by the file picker activity.
  ///@param data the intent returned by the file picker activity.
  ///@return the Uris of selected file(s) or {@code null} if the resultCode indicates
  ///         activity canceled or any other error.
  static jni.JniObject parseResult(int resultCode, intent_.Intent data) =>
      jni.JniObject.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_parseResult,
          jni.JniType.objectType,
          [resultCode, data.reference]).object);

  static final _id_getMode =
      jniAccessors.getMethodIDOf(_classRef, "getMode", "()I");

  /// from: public abstract int getMode()
  ///
  /// Returns file chooser mode.
  int getMode() => jniAccessors.callMethodWithArgs(
      reference, _id_getMode, jni.JniType.intType, []).integer;

  static final _id_getAcceptTypes = jniAccessors.getMethodIDOf(
      _classRef, "getAcceptTypes", "()[Ljava/lang/String;");

  /// from: public abstract java.lang.String[] getAcceptTypes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an array of acceptable MIME types. The returned MIME type
  /// could be partial such as audio/*. The array will be empty if no
  /// acceptable types are specified.
  jni.JniObject getAcceptTypes() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getAcceptTypes, jni.JniType.objectType, []).object);

  static final _id_isCaptureEnabled =
      jniAccessors.getMethodIDOf(_classRef, "isCaptureEnabled", "()Z");

  /// from: public abstract boolean isCaptureEnabled()
  ///
  /// Returns preference for a live media captured value (e.g.&nbsp;Camera, Microphone).
  /// True indicates capture is enabled, {@code false} disabled.
  ///
  /// Use <code>getAcceptTypes</code> to determine suitable capture devices.
  bool isCaptureEnabled() => jniAccessors.callMethodWithArgs(
      reference, _id_isCaptureEnabled, jni.JniType.booleanType, []).boolean;

  static final _id_getTitle = jniAccessors.getMethodIDOf(
      _classRef, "getTitle", "()Ljava/lang/CharSequence;");

  /// from: public abstract java.lang.CharSequence getTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the title to use for this file selector. If {@code null} a default title should
  /// be used.
  jni.JniObject getTitle() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getTitle, jni.JniType.objectType, []).object);

  static final _id_getFilenameHint = jniAccessors.getMethodIDOf(
      _classRef, "getFilenameHint", "()Ljava/lang/String;");

  /// from: public abstract java.lang.String getFilenameHint()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The file name of a default selection if specified, or {@code null}.
  jni.JniString getFilenameHint() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getFilenameHint, jni.JniType.objectType, []).object);

  static final _id_createIntent = jniAccessors.getMethodIDOf(
      _classRef, "createIntent", "()Landroid/content/Intent;");

  /// from: public abstract android.content.Intent createIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an intent that would start a file picker for file selection.
  /// The Intent supports choosing files from simple file sources available
  /// on the device. Some advanced sources (for example, live media capture)
  /// may not be supported and applications wishing to support these sources
  /// or more advanced file operations should build their own Intent.
  ///
  /// <pre>
  /// How to use:
  /// 1. Build an intent using \#createIntent
  /// 2. Fire the intent using android.app.Activity\#startActivityForResult.
  /// 3. Check for ActivityNotFoundException and take a user friendly action if thrown.
  /// 4. Listen the result using android.app.Activity\#onActivityResult
  /// 5. Parse the result using \#parseResult only if media capture was not requested.
  /// 6. Send the result using filePathCallback of WebChromeClient\#onShowFileChooser
  /// </pre>
  ///@return an Intent that supports basic file chooser sources.
  intent_.Intent createIntent() =>
      intent_.Intent.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_createIntent, jni.JniType.objectType, []).object);
}

/// from: android.webkit.WebChromeClient$CustomViewCallback
///
/// A callback interface used by the host application to notify
/// the current page that its custom view has been dismissed.
class WebChromeClient_CustomViewCallback extends jni.JniObject {
  static final _classRef = jniAccessors
      .getClassOf("android/webkit/WebChromeClient\$CustomViewCallback");
  WebChromeClient_CustomViewCallback.fromRef(jni.JObject ref)
      : super.fromRef(ref);

  static final _id_onCustomViewHidden =
      jniAccessors.getMethodIDOf(_classRef, "onCustomViewHidden", "()V");

  /// from: public abstract void onCustomViewHidden()
  ///
  /// Invoked when the host application dismisses the
  /// custom view.
  void onCustomViewHidden() => jniAccessors.callMethodWithArgs(
      reference, _id_onCustomViewHidden, jni.JniType.voidType, []).check();
}
