// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../content/Context.dart" as context_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.webkit.CookieSyncManager
///
/// The CookieSyncManager is used to synchronize the browser cookie store
/// between RAM and permanent storage. To get the best performance, browser cookies are
/// saved in RAM. A separate thread saves the cookies between, driven by a timer.
///
///
/// To use the CookieSyncManager, the host application has to call the following
/// when the application starts:
///
///
/// <pre class="prettyprint">CookieSyncManager.createInstance(context)</pre>
///
/// To set up for sync, the host application has to call
/// <pre class="prettyprint">CookieSyncManager.getInstance().startSync()</pre>
///
/// in Activity.onResume(), and call
///
///
/// <pre class="prettyprint">
/// CookieSyncManager.getInstance().stopSync()
/// </pre>
///
/// in Activity.onPause().
///
/// To get instant sync instead of waiting for the timer to trigger, the host can
/// call
///
/// <pre class="prettyprint">CookieSyncManager.getInstance().sync()</pre>
///
/// The sync interval is 5 minutes, so you will want to force syncs
/// manually anyway, for instance in WebViewClient\#onPageFinished. Note that even sync() happens
/// asynchronously, so don't do it just as your activity is shutting
/// down.
///@deprecated The WebView now automatically syncs cookies as necessary.
///             You no longer need to create or use the CookieSyncManager.
///             To manually force a sync you can use the CookieManager
///             method CookieManager\#flush which is a synchronous
///             replacement for \#sync.
class CookieSyncManager extends jni.JniObject {
  static final _classRef =
      jniAccessors.getClassOf("android/webkit/CookieSyncManager");
  CookieSyncManager.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_getInstance = jniAccessors.getStaticMethodIDOf(
      _classRef, "getInstance", "()Landroid/webkit/CookieSyncManager;");

  /// from: static public android.webkit.CookieSyncManager getInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Singleton access to a CookieSyncManager. An
  /// IllegalStateException will be thrown if
  /// CookieSyncManager\#createInstance(Context) is not called before.
  ///@return CookieSyncManager
  static CookieSyncManager getInstance() =>
      CookieSyncManager.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getInstance, jni.JniType.objectType, []).object);

  static final _id_createInstance = jniAccessors.getStaticMethodIDOf(
      _classRef,
      "createInstance",
      "(Landroid/content/Context;)Landroid/webkit/CookieSyncManager;");

  /// from: static public android.webkit.CookieSyncManager createInstance(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a singleton CookieSyncManager within a context
  ///@param context
  ///@return CookieSyncManager
  static CookieSyncManager createInstance(context_.Context context) =>
      CookieSyncManager.fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_createInstance,
          jni.JniType.objectType,
          [context.reference]).object);

  static final _id_sync0 = jniAccessors.getMethodIDOf(_classRef, "sync", "()V");

  /// from: public void sync()
  ///
  /// sync() forces sync manager to sync now
  ///@deprecated Use CookieManager\#flush instead.
  void sync0() => jniAccessors.callMethodWithArgs(
      reference, _id_sync0, jni.JniType.voidType, []).check();

  static final _id_syncFromRamToFlash =
      jniAccessors.getMethodIDOf(_classRef, "syncFromRamToFlash", "()V");

  /// from: protected void syncFromRamToFlash()
  ///
  /// @deprecated Use CookieManager\#flush instead.
  void syncFromRamToFlash() => jniAccessors.callMethodWithArgs(
      reference, _id_syncFromRamToFlash, jni.JniType.voidType, []).check();

  static final _id_resetSync =
      jniAccessors.getMethodIDOf(_classRef, "resetSync", "()V");

  /// from: public void resetSync()
  ///
  /// resetSync() resets sync manager's timer.
  ///@deprecated Calling resetSync is no longer necessary as the WebView automatically
  ///             syncs cookies.
  void resetSync() => jniAccessors.callMethodWithArgs(
      reference, _id_resetSync, jni.JniType.voidType, []).check();

  static final _id_startSync =
      jniAccessors.getMethodIDOf(_classRef, "startSync", "()V");

  /// from: public void startSync()
  ///
  /// startSync() requests sync manager to start sync.
  ///@deprecated Calling startSync is no longer necessary as the WebView automatically
  ///             syncs cookies.
  void startSync() => jniAccessors.callMethodWithArgs(
      reference, _id_startSync, jni.JniType.voidType, []).check();

  static final _id_stopSync =
      jniAccessors.getMethodIDOf(_classRef, "stopSync", "()V");

  /// from: public void stopSync()
  ///
  /// stopSync() requests sync manager to stop sync. remove any SYNC_MESSAGE in
  /// the queue to break the sync loop
  ///@deprecated Calling stopSync is no longer useful as the WebView
  ///             automatically syncs cookies.
  void stopSync() => jniAccessors.callMethodWithArgs(
      reference, _id_stopSync, jni.JniType.voidType, []).check();

  static final _id_onSyncInit =
      jniAccessors.getMethodIDOf(_classRef, "onSyncInit", "()V");

  /// from: protected void onSyncInit()
  void onSyncInit() => jniAccessors.callMethodWithArgs(
      reference, _id_onSyncInit, jni.JniType.voidType, []).check();

  static final _id_clone =
      jniAccessors.getMethodIDOf(_classRef, "clone", "()Ljava/lang/Object;");

  /// from: protected java.lang.Object clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject clone() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniType.objectType, []).object);

  static final _id_run = jniAccessors.getMethodIDOf(_classRef, "run", "()V");

  /// from: public void run()
  void run() => jniAccessors
      .callMethodWithArgs(reference, _id_run, jni.JniType.voidType, []).check();
}
