// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_import
// ignore_for_file: unused_element
// ignore_for_file: unused_field

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

import "../hardware/usb/UsbDevice.dart" as usbdevice_;

import "../hardware/usb/UsbDeviceConnection.dart" as usbdeviceconnection_;

import "MtpDeviceInfo.dart" as mtpdeviceinfo_;

import "MtpStorageInfo.dart" as mtpstorageinfo_;

import "MtpObjectInfo.dart" as mtpobjectinfo_;

import "../os/ParcelFileDescriptor.dart" as parcelfiledescriptor_;

import "MtpEvent.dart" as mtpevent_;

import "../os/CancellationSignal.dart" as cancellationsignal_;
import "../../_init.dart" show jniEnv, jniAccessors;

/// from: android.mtp.MtpDevice
///
/// This class represents an MTP or PTP device connected on the USB host bus. An application can
/// instantiate an object of this type, by referencing an attached android.hardware.usb.UsbDevice and then use methods in this class to get information about the
/// device and objects stored on it, as well as open the connection and transfer data.
class MtpDevice extends jni.JniObject {
  static final _classRef = jniAccessors.getClassOf("android/mtp/MtpDevice");
  MtpDevice.fromRef(jni.JObject ref) : super.fromRef(ref);

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, "<init>", "(Landroid/hardware/usb/UsbDevice;)V");

  /// from: public void <init>(android.hardware.usb.UsbDevice device)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// MtpClient constructor
  ///@param device the android.hardware.usb.UsbDevice for the MTP or PTP device
  ///
  /// This value must never be {@code null}.
  MtpDevice(usbdevice_.UsbDevice device)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [device.reference]).object);

  static final _id_open = jniAccessors.getMethodIDOf(
      _classRef, "open", "(Landroid/hardware/usb/UsbDeviceConnection;)Z");

  /// from: public boolean open(android.hardware.usb.UsbDeviceConnection connection)
  ///
  /// Opens the MTP device.  Once the device is open it takes ownership of the
  /// android.hardware.usb.UsbDeviceConnection.
  /// The connection will be closed when you call \#close()
  /// The connection will also be closed if this method fails.
  ///@param connection an open android.hardware.usb.UsbDeviceConnection for the device
  /// This value must never be {@code null}.
  ///@return true if the device was successfully opened.
  bool open(usbdeviceconnection_.UsbDeviceConnection connection) =>
      jniAccessors.callMethodWithArgs(reference, _id_open,
          jni.JniType.booleanType, [connection.reference]).boolean;

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, "close", "()V");

  /// from: public void close()
  ///
  /// Closes all resources related to the MtpDevice object.
  /// After this is called, the object can not be used until \#open is called again
  /// with a new android.hardware.usb.UsbDeviceConnection.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, "finalize", "()V");

  /// from: protected void finalize()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniType.voidType, []).check();

  static final _id_getDeviceName = jniAccessors.getMethodIDOf(
      _classRef, "getDeviceName", "()Ljava/lang/String;");

  /// from: public java.lang.String getDeviceName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name of the USB device
  /// This returns the same value as android.hardware.usb.UsbDevice\#getDeviceName
  /// for the device's android.hardware.usb.UsbDevice
  ///@return the device name
  ///
  /// This value will never be {@code null}.
  jni.JniString getDeviceName() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDeviceName, jni.JniType.objectType, []).object);

  static final _id_getDeviceId =
      jniAccessors.getMethodIDOf(_classRef, "getDeviceId", "()I");

  /// from: public int getDeviceId()
  ///
  /// Returns the USB ID of the USB device.
  /// This returns the same value as android.hardware.usb.UsbDevice\#getDeviceId
  /// for the device's android.hardware.usb.UsbDevice
  ///@return the device ID
  int getDeviceId() => jniAccessors.callMethodWithArgs(
      reference, _id_getDeviceId, jni.JniType.intType, []).integer;

  static final _id_toString1 =
      jniAccessors.getMethodIDOf(_classRef, "toString", "()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return This value will never be {@code null}.
  jni.JniString toString1() =>
      jni.JniString.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniType.objectType, []).object);

  static final _id_getDeviceInfo = jniAccessors.getMethodIDOf(
      _classRef, "getDeviceInfo", "()Landroid/mtp/MtpDeviceInfo;");

  /// from: public android.mtp.MtpDeviceInfo getDeviceInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the MtpDeviceInfo for this device
  ///@return the device info, or null if fetching device info fails
  mtpdeviceinfo_.MtpDeviceInfo getDeviceInfo() =>
      mtpdeviceinfo_.MtpDeviceInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getDeviceInfo, jni.JniType.objectType, []).object);

  static final _id_getStorageIds =
      jniAccessors.getMethodIDOf(_classRef, "getStorageIds", "()[I");

  /// from: public int[] getStorageIds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of IDs for all storage units on this device
  /// Information about each storage unit can be accessed via \#getStorageInfo.
  ///@return the list of storage IDs, or null if fetching storage IDs fails
  jni.JniObject getStorageIds() =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getStorageIds, jni.JniType.objectType, []).object);

  static final _id_getObjectHandles =
      jniAccessors.getMethodIDOf(_classRef, "getObjectHandles", "(III)[I");

  /// from: public int[] getObjectHandles(int storageId, int format, int objectHandle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of object handles for all objects on the given storage unit,
  /// with the given format and parent.
  /// Information about each object can be accessed via \#getObjectInfo.
  ///@param storageId the storage unit to query
  ///@param format the format of the object to return, or zero for all formats
  ///@param objectHandle the parent object to query, -1 for the storage root,
  ///     or zero for all objects
  ///@return the object handles, or null if fetching object handles fails
  jni.JniObject getObjectHandles(int storageId, int format, int objectHandle) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getObjectHandles,
          jni.JniType.objectType,
          [storageId, format, objectHandle]).object);

  static final _id_getObject =
      jniAccessors.getMethodIDOf(_classRef, "getObject", "(II)[B");

  /// from: public byte[] getObject(int objectHandle, int objectSize)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the data for an object as a byte array.
  /// This call may block for an arbitrary amount of time depending on the size
  /// of the data and speed of the devices.
  ///@param objectHandle handle of the object to read
  ///@param objectSize the size of the object (this should match
  ///      MtpObjectInfo\#getCompressedSize)
  ///@return the object's data, or null if reading fails
  jni.JniObject getObject(int objectHandle, int objectSize) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getObject,
          jni.JniType.objectType,
          [objectHandle, objectSize]).object);

  static final _id_getPartialObject =
      jniAccessors.getMethodIDOf(_classRef, "getPartialObject", "(IJJ[B)J");

  /// from: public long getPartialObject(int objectHandle, long offset, long size, byte[] buffer)
  ///
  /// Obtains object bytes in the specified range and writes it to an array.
  /// This call may block for an arbitrary amount of time depending on the size
  /// of the data and speed of the devices.
  ///@param objectHandle handle of the object to read
  ///@param offset Start index of reading range. It must be a non-negative value at most
  ///     0xffffffff.
  ///@param size Size of reading range. It must be a non-negative value at most Integer.MAX_VALUE
  ///     or 0xffffffff. If 0xffffffff is specified, the method obtains the full bytes of object.
  ///@param buffer Array to write data.
  /// This value must never be {@code null}.
  ///@return Size of bytes that are actually read.
  int getPartialObject(
          int objectHandle, int offset, int size, jni.JniObject buffer) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getPartialObject,
          jni.JniType.longType,
          [objectHandle, offset, size, buffer.reference]).long;

  static final _id_getPartialObject64 =
      jniAccessors.getMethodIDOf(_classRef, "getPartialObject64", "(IJJ[B)J");

  /// from: public long getPartialObject64(int objectHandle, long offset, long size, byte[] buffer)
  ///
  /// Obtains object bytes in the specified range and writes it to an array.
  /// This call may block for an arbitrary amount of time depending on the size
  /// of the data and speed of the devices.
  ///
  /// This is a vender-extended operation supported by Android that enables us to pass
  /// unsigned 64-bit offset. Check if the MTP device supports the operation by using
  /// MtpDeviceInfo\#getOperationsSupported().
  ///@param objectHandle handle of the object to read
  ///@param offset Start index of reading range. It must be a non-negative value.
  ///@param size Size of reading range. It must be a non-negative value at most Integer.MAX_VALUE.
  ///@param buffer Array to write data.
  /// This value must never be {@code null}.
  ///@return Size of bytes that are actually read.
  ///@see MtpConstants\#OPERATION_GET_PARTIAL_OBJECT_64
  int getPartialObject64(
          int objectHandle, int offset, int size, jni.JniObject buffer) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_getPartialObject64,
          jni.JniType.longType,
          [objectHandle, offset, size, buffer.reference]).long;

  static final _id_getThumbnail =
      jniAccessors.getMethodIDOf(_classRef, "getThumbnail", "(I)[B");

  /// from: public byte[] getThumbnail(int objectHandle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the thumbnail data for an object as a byte array.
  /// The size and format of the thumbnail data can be determined via
  /// MtpObjectInfo\#getThumbCompressedSize and
  /// MtpObjectInfo\#getThumbFormat.
  /// For typical devices the format is JPEG.
  ///@param objectHandle handle of the object to read
  ///@return the object's thumbnail, or null if reading fails
  jni.JniObject getThumbnail(int objectHandle) =>
      jni.JniObject.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_getThumbnail, jni.JniType.objectType, [objectHandle]).object);

  static final _id_getStorageInfo = jniAccessors.getMethodIDOf(
      _classRef, "getStorageInfo", "(I)Landroid/mtp/MtpStorageInfo;");

  /// from: public android.mtp.MtpStorageInfo getStorageInfo(int storageId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the MtpStorageInfo for a storage unit.
  ///@param storageId the ID of the storage unit
  ///@return the MtpStorageInfo, or null if fetching storage info fails
  mtpstorageinfo_.MtpStorageInfo getStorageInfo(int storageId) =>
      mtpstorageinfo_.MtpStorageInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getStorageInfo,
          jni.JniType.objectType,
          [storageId]).object);

  static final _id_getObjectInfo = jniAccessors.getMethodIDOf(
      _classRef, "getObjectInfo", "(I)Landroid/mtp/MtpObjectInfo;");

  /// from: public android.mtp.MtpObjectInfo getObjectInfo(int objectHandle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the MtpObjectInfo for an object.
  ///@param objectHandle the handle of the object
  ///@return the MtpObjectInfo, or null if fetching object info fails
  mtpobjectinfo_.MtpObjectInfo getObjectInfo(int objectHandle) =>
      mtpobjectinfo_.MtpObjectInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getObjectInfo,
          jni.JniType.objectType,
          [objectHandle]).object);

  static final _id_deleteObject =
      jniAccessors.getMethodIDOf(_classRef, "deleteObject", "(I)Z");

  /// from: public boolean deleteObject(int objectHandle)
  ///
  /// Deletes an object on the device.  This call may block, since
  /// deleting a directory containing many files may take a long time
  /// on some devices.
  ///@param objectHandle handle of the object to delete
  ///@return true if the deletion succeeds
  bool deleteObject(int objectHandle) => jniAccessors.callMethodWithArgs(
      reference,
      _id_deleteObject,
      jni.JniType.booleanType,
      [objectHandle]).boolean;

  static final _id_getParent =
      jniAccessors.getMethodIDOf(_classRef, "getParent", "(I)J");

  /// from: public long getParent(int objectHandle)
  ///
  /// Retrieves the object handle for the parent of an object on the device.
  ///@param objectHandle handle of the object to query
  ///@return the parent's handle, or zero if it is in the root of the storage
  int getParent(int objectHandle) => jniAccessors.callMethodWithArgs(
      reference, _id_getParent, jni.JniType.longType, [objectHandle]).long;

  static final _id_getStorageId =
      jniAccessors.getMethodIDOf(_classRef, "getStorageId", "(I)J");

  /// from: public long getStorageId(int objectHandle)
  ///
  /// Retrieves the ID of the storage unit containing the given object on the device.
  ///@param objectHandle handle of the object to query
  ///@return the object's storage unit ID
  int getStorageId(int objectHandle) => jniAccessors.callMethodWithArgs(
      reference, _id_getStorageId, jni.JniType.longType, [objectHandle]).long;

  static final _id_importFile = jniAccessors.getMethodIDOf(
      _classRef, "importFile", "(ILjava/lang/String;)Z");

  /// from: public boolean importFile(int objectHandle, java.lang.String destPath)
  ///
  /// Copies the data for an object to a file in external storage.
  /// This call may block for an arbitrary amount of time depending on the size
  /// of the data and speed of the devices.
  ///@param objectHandle handle of the object to read
  ///@param destPath path to destination for the file transfer.
  ///      This path should be in the external storage as defined by
  ///      android.os.Environment\#getExternalStorageDirectory
  /// This value must never be {@code null}.
  ///@return true if the file transfer succeeds
  bool importFile(int objectHandle, jni.JniString destPath) =>
      jniAccessors.callMethodWithArgs(reference, _id_importFile,
          jni.JniType.booleanType, [objectHandle, destPath.reference]).boolean;

  static final _id_importFile1 = jniAccessors.getMethodIDOf(
      _classRef, "importFile", "(ILandroid/os/ParcelFileDescriptor;)Z");

  /// from: public boolean importFile(int objectHandle, android.os.ParcelFileDescriptor descriptor)
  ///
  /// Copies the data for an object to a file descriptor.
  /// This call may block for an arbitrary amount of time depending on the size
  /// of the data and speed of the devices. The file descriptor is not closed
  /// on completion, and must be done by the caller.
  ///@param objectHandle handle of the object to read
  ///@param descriptor file descriptor to write the data to for the file transfer.
  /// This value must never be {@code null}.
  ///@return true if the file transfer succeeds
  bool importFile1(int objectHandle,
          parcelfiledescriptor_.ParcelFileDescriptor descriptor) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_importFile1,
          jni.JniType.booleanType,
          [objectHandle, descriptor.reference]).boolean;

  static final _id_sendObject = jniAccessors.getMethodIDOf(
      _classRef, "sendObject", "(IJLandroid/os/ParcelFileDescriptor;)Z");

  /// from: public boolean sendObject(int objectHandle, long size, android.os.ParcelFileDescriptor descriptor)
  ///
  /// Copies the data for an object from a file descriptor.
  /// This call may block for an arbitrary amount of time depending on the size
  /// of the data and speed of the devices. The file descriptor is not closed
  /// on completion, and must be done by the caller.
  ///@param objectHandle handle of the target file
  ///@param size size of the file in bytes
  ///@param descriptor file descriptor to read the data from.
  /// This value must never be {@code null}.
  ///@return true if the file transfer succeeds
  bool sendObject(int objectHandle, int size,
          parcelfiledescriptor_.ParcelFileDescriptor descriptor) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_sendObject,
          jni.JniType.booleanType,
          [objectHandle, size, descriptor.reference]).boolean;

  static final _id_sendObjectInfo = jniAccessors.getMethodIDOf(
      _classRef,
      "sendObjectInfo",
      "(Landroid/mtp/MtpObjectInfo;)Landroid/mtp/MtpObjectInfo;");

  /// from: public android.mtp.MtpObjectInfo sendObjectInfo(android.mtp.MtpObjectInfo info)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Uploads an object metadata for a new entry. The MtpObjectInfo can be
  /// created with the MtpObjectInfo.Builder class.
  ///
  /// The returned MtpObjectInfo has the new object handle field filled in.
  ///@param info metadata of the entry
  /// This value must never be {@code null}.
  ///@return object info of the created entry, or null if sending object info fails
  mtpobjectinfo_.MtpObjectInfo sendObjectInfo(
          mtpobjectinfo_.MtpObjectInfo info) =>
      mtpobjectinfo_.MtpObjectInfo.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_sendObjectInfo,
          jni.JniType.objectType,
          [info.reference]).object);

  static final _id_readEvent = jniAccessors.getMethodIDOf(_classRef,
      "readEvent", "(Landroid/os/CancellationSignal;)Landroid/mtp/MtpEvent;");

  /// from: public android.mtp.MtpEvent readEvent(android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Reads an event from the device. It blocks the current thread until it gets an event.
  /// It throws OperationCanceledException if it is cancelled by signal.
  ///@param signal signal for cancellation
  /// This value may be {@code null}.
  ///@return obtained event
  /// This value will never be {@code null}.
  ///@throws IOException
  mtpevent_.MtpEvent readEvent(cancellationsignal_.CancellationSignal signal) =>
      mtpevent_.MtpEvent.fromRef(jniAccessors.callMethodWithArgs(reference,
          _id_readEvent, jni.JniType.objectType, [signal.reference]).object);
}
